Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
5,<android.animation.LayoutTransition: Animator getAnimator(int)>,15,16,<android.animation.LayoutTransition: Animator getAnimator(int)>,<android.animation.LayoutTransition: Animator getAnimator(int)>,0,"{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingAnim;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingAnim;
        case APPEARING:
            return mAppearingAnim;
        case DISAPPEARING:
            return mDisappearingAnim;
    }
    // shouldn't reach here
    return null;
}","{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingAnim;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingAnim;
        case CHANGING:
            return mChangingAnim;
        case APPEARING:
            return mAppearingAnim;
        case DISAPPEARING:
            return mDisappearingAnim;
    }
    // shouldn't reach here
    return null;
}",1,"/**
 * Gets the animation used during one of the transition types that may run.
 *
 * @param transitionType one of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #APPEARING}, or {@link #DISAPPEARING}, which determines the animation whose
 * duration is being set.
 * @return Animator The animation being used for the given transition type.
 * @see #setAnimator(int, Animator)
 */
","/**
 * Gets the animation used during one of the transition types that may run.
 *
 * @param transitionType One of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #CHANGING}, {@link #APPEARING}, or {@link #DISAPPEARING}, which determines
 * the animation whose animator is being returned.
 * @return Animator The animation being used for the given transition type.
 * @see #setAnimator(int, Animator)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The 'switch' control structure has changed, an extra case 'CHANGING' has been added in the late implementation. Therefore, the code change type is 3 (Control dependency changed).","With the addition of a new case 'CHANGING', the outcome of the 'switch' control structure could potentially lead to different return values, hence there is a Compatibility Issue due to potentially different return values or types (CI type 1)."
6,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int)>",15,16,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int)>","<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int)>",0,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.setAllowFds(false);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues);
        if (result == IActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
    }
}","{
    startIntentSender(intent, fillInIntent, flagsMask, flagsValues, extraFlags, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,The entire implementation of the method has been replaced by another method invocation with different argument number and types. So it's classified as Others changed and Dependent API changed because the invoked method is different as well.,"Since the original handling and return in the early version (includes different operations and checks) are removed and replaced by a different API call in the late version which may have different internal implementation, potentially leading to different return values. Therefore, this is classified as a compatibility issue caused by potential different return values or types."
7,<android.speech.tts.EventLogger: void onWriteData()>,15,16,<android.speech.tts.EventLogger: void onWriteData()>,<android.speech.tts.EventLogger: void onWriteData()>,0,"{
    if (mLogWritten) {
        return;
    } else {
        mLogWritten = true;
    }
    long completionTime = SystemClock.elapsedRealtime();
    // error does not occur.
    if (mError || mPlaybackStartTime == -1 || mEngineCompleteTime == -1) {
        EventLogTags.writeTtsSpeakFailure(mServiceApp, mCallingApp, getUtteranceLength(), getLocaleString(), mRequest.getSpeechRate(), mRequest.getPitch());
        return;
    }
    // the length of the utterance).
    if (mStopped) {
        return;
    }
    final long audioLatency = mPlaybackStartTime - mReceivedTime;
    final long engineLatency = mEngineStartTime - mRequestProcessingStartTime;
    final long engineTotal = mEngineCompleteTime - mRequestProcessingStartTime;
    EventLogTags.writeTtsSpeakSuccess(mServiceApp, mCallingApp, getUtteranceLength(), getLocaleString(), mRequest.getSpeechRate(), mRequest.getPitch(), engineLatency, engineTotal, audioLatency);
}","{
    if (mLogWritten) {
        return;
    } else {
        mLogWritten = true;
    }
    long completionTime = SystemClock.elapsedRealtime();
    // error does not occur.
    if (mError || mPlaybackStartTime == -1 || mEngineCompleteTime == -1) {
        EventLogTags.writeTtsSpeakFailure(mServiceApp, mCallerUid, mCallerPid, getUtteranceLength(), getLocaleString(), mRequest.getSpeechRate(), mRequest.getPitch());
        return;
    }
    // the length of the utterance).
    if (mStopped) {
        return;
    }
    final long audioLatency = mPlaybackStartTime - mReceivedTime;
    final long engineLatency = mEngineStartTime - mRequestProcessingStartTime;
    final long engineTotal = mEngineCompleteTime - mRequestProcessingStartTime;
    EventLogTags.writeTtsSpeakSuccess(mServiceApp, mCallerUid, mCallerPid, getUtteranceLength(), getLocaleString(), mRequest.getSpeechRate(), mRequest.getPitch(), engineLatency, engineTotal, audioLatency);
}",1,"/**
 * Notifies the logger that the current synthesis has completed.
 * All available data is not logged.
 */
","/**
 * Notifies the logger that the current synthesis has completed.
 * All available data is not logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The parameters within EventLogTags.writeTtsSpeakFailure and EventLogTags.writeTtsSpeakSuccess methods have changed from mCallingApp to mCallerUid and mCallerPid. So the change type is 4,5. ","The change in method parameters does not effect the behavior of the current method. The error logging might differ, but it does not potentially cause the API to return a different variable or throws the exception differently. Therefore, there is no Compatibility Issue (CI type 0)."
8,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openOrCreateDatabase(String,CursorFactory)>",15,16,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openOrCreateDatabase(String,CursorFactory)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openOrCreateDatabase(String,CursorFactory)>",0,"{
    return openDatabase(path, factory, CREATE_IF_NECESSARY);
}","{
    return openDatabase(path, factory, CREATE_IF_NECESSARY, null);
}",1,"/**
 * Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).
 */
","/**
 * Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from openDatabase(path, factory, CREATE_IF_NECESSARY) to openDatabase(path, factory, CREATE_IF_NECESSARY, null) and the parameter type of openDatabase() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
9,<android.view.KeyCharacterMap: boolean[] deviceHasKeys(int[])>,15,16,<android.view.KeyCharacterMap: boolean[] deviceHasKeys(int[])>,<android.view.KeyCharacterMap: boolean[] deviceHasKeys(int[])>,0,"{
    boolean[] ret = new boolean[keyCodes.length];
    IWindowManager wm = Display.getWindowManager();
    try {
        wm.hasKeys(keyCodes, ret);
    } catch (RemoteException e) {
    // no fallback; just return the empty array
    }
    return ret;
}","{
    return InputManager.getInstance().deviceHasKeys(keyCodes);
}",1,"/**
 * Queries the framework about whether any physical keys exist on the
 * any keyboard attached to the device that are capable of producing the given
 * array of key codes.
 *
 * @param keyCodes The array of key codes to query.
 * @return A new array of the same size as the key codes array whose elements
 * are set to true if at least one attached keyboard supports the corresponding key code
 * at the same index in the key codes array.
 */
","/**
 * Queries the framework about whether any physical keys exist on the
 * any keyboard attached to the device that are capable of producing the given
 * array of key codes.
 *
 * @param keyCodes The array of key codes to query.
 * @return A new array of the same size as the key codes array whose elements
 * are set to true if at least one attached keyboard supports the corresponding key code
 * at the same index in the key codes array.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method has had its implementation changed entirely, from manipulating a boolean array using the `wm.hasKeys(keyCodes, ret)` method to directly returning the result from `InputManager.getInstance().deviceHasKeys(keyCodes)`. Therefore, the changes fall under categories 1 and 5.","Given that the late version uses an entirely different approach to obtain the result, it's possible that it may return different results when compared to the early version, depending on the implementation of `InputManager.getInstance().deviceHasKeys(keyCodes)`. Therefore, it is categorized as type 1 CI."
11,"<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>",15,16,"<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>",0,"{
    if (mActivity == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mActivity != null && mCurState == Fragment.RESUMED) {
            mActivity.invalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}","{
    if (mActivity == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle, false);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mActivity != null && mCurState == Fragment.RESUMED) {
            mActivity.invalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called inside the for loop has changed from moveToState(f, newState, transit, transitStyle) to moveToState(f, newState, transit, transitStyle, false), with an additional boolean parameter. Therefore, the code change type is 1,5.","The change of method call might change the internal state of object 'f' and eventually affect the return value of the method f.mLoaderManager.hasRunningLoaders() which carries the potential to change the overall behavior of the method run, therefore a compatibility issue might exist. The CI type is 1."
15,"<android.webkit.WebView: boolean savePicture(Bundle,File)>",15,16,"<android.webkit.WebView: boolean savePicture(Bundle,File)>","<android.webkit.WebView: boolean savePicture(Bundle,File)>",0,"{
    checkThread();
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    // Use a temporary file while writing to ensure the destination file
    // contains valid data.
    final File temp = new File(dest.getPath() + "".writing"");
    new Thread(new Runnable() {

        public void run() {
            FileOutputStream out = null;
            try {
                out = new FileOutputStream(temp);
                p.writeToStream(out);
                // Writing the picture succeeded, rename the temporary file
                // to the destination.
                temp.renameTo(dest);
            } catch (Exception e) {
            // too late to do anything about it.
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e) {
                    // Can't do anything about that
                    }
                }
                temp.delete();
            }
        }
    }).start();
    // now update the bundle
    b.putInt(""scrollX"", mScrollX);
    b.putInt(""scrollY"", mScrollY);
    mZoomManager.saveZoomState(b);
    return true;
}","{
    checkThread();
    return mProvider.savePicture(b, dest);
}",1,"/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 * @deprecated This method is now obsolete.
 */
","/**
 * Saves the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b a Bundle to store the display data
 * @param dest the file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return true if the picture was successfully saved
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The 'return' and all the other statements have changed in the late version. Moreover, the dependent API 'mProvider.savePicture()' is introduced in the late version. Therefore, the code change types include 1, 4 and 5.","The implementation of the function has been entirely changed, which means it's likely to return different return values. Thus, the CI type is 1."
16,<android.view.accessibility.AccessibilityNodeInfo: int getWindowId()>,15,16,<android.view.accessibility.AccessibilityNodeInfo: int getWindowId()>,<android.view.accessibility.AccessibilityNodeInfo: int getWindowId()>,0,"{
    return mAccessibilityWindowId;
}","{
    return mWindowId;
}",1,"/**
 * Gets the id of the window from which the info comes from.
 *
 * @return The window id.
 */
","/**
 * Gets the id of the window from which the info comes from.
 *
 * @return The window id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed from 'return mAccessibilityWindowId;' to 'return mWindowId;', indicating that the API might be referencing a different variable, therefore the code change type is 1,5.","The change in the return statement in the late version could lead to the API potentially returning a different value, so the CI type is 1."
17,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",15,16,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",0,"{
    throw new UnsupportedOperationException();
}","{
    path.computeBounds(mPathBounds, true);
    return nQuickReject(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom, type.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2","1,2","In the early version of the API, an exception is thrown unconditionally, while in the late version the exception throw statement is deleted and a new return statement is added. So the code change type is 1,2.","The behaviour has changed significantly, the early version will always throw UnsupportedOperationException, while the late version returns a boolean value. Therefore, the potential return value (from exception to boolean) as well as the way exception is handled has changed. CI type is classified as 1,2."
19,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,15,16,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
        // Start fresh
        reset();
    }
    boolean handled = true;
    if (mInvalidGesture) {
        handled = false;
    } else if (!mGestureInProgress) {
        switch(action) {
            case MotionEvent.ACTION_DOWN:
                {
                    mActiveId0 = event.getPointerId(0);
                    mActive0MostRecent = true;
                }
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // We have a new multi-finger gesture
                    // as orientation can change, query the metrics in touch down
                    DisplayMetrics metrics = mContext.getResources().getDisplayMetrics();
                    mRightSlopEdge = metrics.widthPixels - mEdgeSlop;
                    mBottomSlopEdge = metrics.heightPixels - mEdgeSlop;
                    if (mPrevEvent != null)
                        mPrevEvent.recycle();
                    mPrevEvent = MotionEvent.obtain(event);
                    mTimeDelta = 0;
                    int index1 = event.getActionIndex();
                    int index0 = event.findPointerIndex(mActiveId0);
                    mActiveId1 = event.getPointerId(index1);
                    if (index0 < 0 || index0 == index1) {
                        // Probably someone sending us a broken event stream.
                        index0 = findNewActiveIndex(event, index0 == index1 ? -1 : mActiveId1, index0);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    mActive0MostRecent = false;
                    setContext(event);
                    // Check if we have a sloppy gesture. If so, delay
                    // the beginning of the gesture until we're sure that's
                    // what the user wanted. Sloppy gestures can happen if the
                    // edge of the user's hand is touching the screen, for example.
                    final float edgeSlop = mEdgeSlop;
                    final float rightSlop = mRightSlopEdge;
                    final float bottomSlop = mBottomSlopEdge;
                    float x0 = getRawX(event, index0);
                    float y0 = getRawY(event, index0);
                    float x1 = getRawX(event, index1);
                    float y1 = getRawY(event, index1);
                    boolean p0sloppy = x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
                    boolean p1sloppy = x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
                    if (p0sloppy && p1sloppy) {
                        mFocusX = -1;
                        mFocusY = -1;
                        mSloppyGesture = true;
                    } else if (p0sloppy) {
                        mFocusX = event.getX(index1);
                        mFocusY = event.getY(index1);
                        mSloppyGesture = true;
                    } else if (p1sloppy) {
                        mFocusX = event.getX(index0);
                        mFocusY = event.getY(index0);
                        mSloppyGesture = true;
                    } else {
                        mSloppyGesture = false;
                        mGestureInProgress = mListener.onScaleBegin(this);
                    }
                }
                break;
            case MotionEvent.ACTION_MOVE:
                if (mSloppyGesture) {
                    // Initiate sloppy gestures if we've moved outside of the slop area.
                    final float edgeSlop = mEdgeSlop;
                    final float rightSlop = mRightSlopEdge;
                    final float bottomSlop = mBottomSlopEdge;
                    int index0 = event.findPointerIndex(mActiveId0);
                    int index1 = event.findPointerIndex(mActiveId1);
                    float x0 = getRawX(event, index0);
                    float y0 = getRawY(event, index0);
                    float x1 = getRawX(event, index1);
                    float y1 = getRawY(event, index1);
                    boolean p0sloppy = x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
                    boolean p1sloppy = x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
                    if (p0sloppy) {
                        // Do we have a different pointer that isn't sloppy?
                        int index = findNewActiveIndex(event, mActiveId1, index0);
                        if (index >= 0) {
                            index0 = index;
                            mActiveId0 = event.getPointerId(index);
                            x0 = getRawX(event, index);
                            y0 = getRawY(event, index);
                            p0sloppy = false;
                        }
                    }
                    if (p1sloppy) {
                        // Do we have a different pointer that isn't sloppy?
                        int index = findNewActiveIndex(event, mActiveId0, index1);
                        if (index >= 0) {
                            index1 = index;
                            mActiveId1 = event.getPointerId(index);
                            x1 = getRawX(event, index);
                            y1 = getRawY(event, index);
                            p1sloppy = false;
                        }
                    }
                    if (p0sloppy && p1sloppy) {
                        mFocusX = -1;
                        mFocusY = -1;
                    } else if (p0sloppy) {
                        mFocusX = event.getX(index1);
                        mFocusY = event.getY(index1);
                    } else if (p1sloppy) {
                        mFocusX = event.getX(index0);
                        mFocusY = event.getY(index0);
                    } else {
                        mSloppyGesture = false;
                        mGestureInProgress = mListener.onScaleBegin(this);
                    }
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                if (mSloppyGesture) {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0)
                                mActiveId0 = event.getPointerId(newIndex);
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0)
                                mActiveId1 = event.getPointerId(newIndex);
                        }
                    } else {
                        // Set focus point to the remaining finger
                        final int index = event.findPointerIndex(actionId == mActiveId0 ? mActiveId1 : mActiveId0);
                        if (index < 0) {
                            mInvalidGesture = true;
                            Log.e(TAG, ""Invalid MotionEvent stream detected."", new Throwable());
                            if (mGestureInProgress) {
                                mListener.onScaleEnd(this);
                            }
                            return false;
                        }
                        mActiveId0 = event.getPointerId(index);
                        mActive0MostRecent = true;
                        mActiveId1 = -1;
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                    }
                }
                break;
        }
    } else {
        // Transform gesture in progress - attempt to handle it
        switch(action) {
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // End the old gesture and begin a new one with the most recent two fingers.
                    mListener.onScaleEnd(this);
                    final int oldActive0 = mActiveId0;
                    final int oldActive1 = mActiveId1;
                    reset();
                    mPrevEvent = MotionEvent.obtain(event);
                    mActiveId0 = mActive0MostRecent ? oldActive0 : oldActive1;
                    mActiveId1 = event.getPointerId(event.getActionIndex());
                    mActive0MostRecent = false;
                    int index0 = event.findPointerIndex(mActiveId0);
                    if (index0 < 0 || mActiveId0 == mActiveId1) {
                        // Probably someone sending us a broken event stream.
                        Log.e(TAG, ""Got "" + MotionEvent.actionToString(action) + "" with bad state while a gesture was in progress. "" + ""Did you forget to pass an event to "" + ""ScaleGestureDetector#onTouchEvent?"");
                        index0 = findNewActiveIndex(event, mActiveId0 == mActiveId1 ? -1 : mActiveId1, index0);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    setContext(event);
                    mGestureInProgress = mListener.onScaleBegin(this);
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    boolean gestureEnded = false;
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId0 = event.getPointerId(newIndex);
                                mActive0MostRecent = true;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId1 = event.getPointerId(newIndex);
                                mActive0MostRecent = false;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        }
                        mPrevEvent.recycle();
                        mPrevEvent = MotionEvent.obtain(event);
                        setContext(event);
                    } else {
                        gestureEnded = true;
                    }
                    if (gestureEnded) {
                        // Gesture ended
                        setContext(event);
                        // Set focus point to the remaining finger
                        final int activeId = actionId == mActiveId0 ? mActiveId1 : mActiveId0;
                        final int index = event.findPointerIndex(activeId);
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                        mListener.onScaleEnd(this);
                        reset();
                        mActiveId0 = activeId;
                        mActive0MostRecent = true;
                    }
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mListener.onScaleEnd(this);
                reset();
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_MOVE:
                {
                    setContext(event);
                    // finger is lifted.
                    if (mCurrPressure / mPrevPressure > PRESSURE_THRESHOLD) {
                        final boolean updatePrevious = mListener.onScale(this);
                        if (updatePrevious) {
                            mPrevEvent.recycle();
                            mPrevEvent = MotionEvent.obtain(event);
                        }
                    }
                }
                break;
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
        // Start fresh
        reset();
    }
    boolean handled = true;
    if (mInvalidGesture) {
        handled = false;
    } else if (!mGestureInProgress) {
        switch(action) {
            case MotionEvent.ACTION_DOWN:
                {
                    mActiveId0 = event.getPointerId(0);
                    mActive0MostRecent = true;
                }
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // We have a new multi-finger gesture
                    if (mPrevEvent != null)
                        mPrevEvent.recycle();
                    mPrevEvent = MotionEvent.obtain(event);
                    mTimeDelta = 0;
                    int index1 = event.getActionIndex();
                    int index0 = event.findPointerIndex(mActiveId0);
                    mActiveId1 = event.getPointerId(index1);
                    if (index0 < 0 || index0 == index1) {
                        // Probably someone sending us a broken event stream.
                        index0 = findNewActiveIndex(event, mActiveId1, -1);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    mActive0MostRecent = false;
                    setContext(event);
                    mGestureInProgress = mListener.onScaleBegin(this);
                    break;
                }
        }
    } else {
        // Transform gesture in progress - attempt to handle it
        switch(action) {
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // End the old gesture and begin a new one with the most recent two fingers.
                    mListener.onScaleEnd(this);
                    final int oldActive0 = mActiveId0;
                    final int oldActive1 = mActiveId1;
                    reset();
                    mPrevEvent = MotionEvent.obtain(event);
                    mActiveId0 = mActive0MostRecent ? oldActive0 : oldActive1;
                    mActiveId1 = event.getPointerId(event.getActionIndex());
                    mActive0MostRecent = false;
                    int index0 = event.findPointerIndex(mActiveId0);
                    if (index0 < 0 || mActiveId0 == mActiveId1) {
                        // Probably someone sending us a broken event stream.
                        Log.e(TAG, ""Got "" + MotionEvent.actionToString(action) + "" with bad state while a gesture was in progress. "" + ""Did you forget to pass an event to "" + ""ScaleGestureDetector#onTouchEvent?"");
                        index0 = findNewActiveIndex(event, mActiveId1, -1);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    setContext(event);
                    mGestureInProgress = mListener.onScaleBegin(this);
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    boolean gestureEnded = false;
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId0 = event.getPointerId(newIndex);
                                mActive0MostRecent = true;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId1 = event.getPointerId(newIndex);
                                mActive0MostRecent = false;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        }
                        mPrevEvent.recycle();
                        mPrevEvent = MotionEvent.obtain(event);
                        setContext(event);
                    } else {
                        gestureEnded = true;
                    }
                    if (gestureEnded) {
                        // Gesture ended
                        setContext(event);
                        // Set focus point to the remaining finger
                        final int activeId = actionId == mActiveId0 ? mActiveId1 : mActiveId0;
                        final int index = event.findPointerIndex(activeId);
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                        mListener.onScaleEnd(this);
                        reset();
                        mActiveId0 = activeId;
                        mActive0MostRecent = true;
                    }
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mListener.onScaleEnd(this);
                reset();
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_MOVE:
                {
                    setContext(event);
                    // finger is lifted.
                    if (mCurrPressure / mPrevPressure > PRESSURE_THRESHOLD) {
                        final boolean updatePrevious = mListener.onScale(this);
                        if (updatePrevious) {
                            mPrevEvent.recycle();
                            mPrevEvent = MotionEvent.obtain(event);
                        }
                    }
                }
                break;
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return handled;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
20,<com.google.android.mms.pdu.PduPersister: GenericPdu load(Uri)>,15,16,<com.google.android.mms.pdu.PduPersister: GenericPdu load(Uri)>,<com.google.android.mms.pdu.PduPersister: GenericPdu load(Uri)>,0,"{
    PduCacheEntry cacheEntry = PDU_CACHE_INSTANCE.get(uri);
    if (cacheEntry != null) {
        return cacheEntry.getPdu();
    }
    Cursor c = SqliteWrapper.query(mContext, mContentResolver, uri, PDU_PROJECTION, null, null, null);
    PduHeaders headers = new PduHeaders();
    Set<Entry<Integer, Integer>> set;
    long msgId = ContentUris.parseId(uri);
    int msgBox;
    long threadId;
    try {
        if ((c == null) || (c.getCount() != 1) || !c.moveToFirst()) {
            throw new MmsException(""Bad uri: "" + uri);
        }
        msgBox = c.getInt(PDU_COLUMN_MESSAGE_BOX);
        threadId = c.getLong(PDU_COLUMN_THREAD_ID);
        set = ENCODED_STRING_COLUMN_INDEX_MAP.entrySet();
        for (Entry<Integer, Integer> e : set) {
            setEncodedStringValueToHeaders(c, e.getValue(), headers, e.getKey());
        }
        set = TEXT_STRING_COLUMN_INDEX_MAP.entrySet();
        for (Entry<Integer, Integer> e : set) {
            setTextStringToHeaders(c, e.getValue(), headers, e.getKey());
        }
        set = OCTET_COLUMN_INDEX_MAP.entrySet();
        for (Entry<Integer, Integer> e : set) {
            setOctetToHeaders(c, e.getValue(), headers, e.getKey());
        }
        set = LONG_COLUMN_INDEX_MAP.entrySet();
        for (Entry<Integer, Integer> e : set) {
            setLongToHeaders(c, e.getValue(), headers, e.getKey());
        }
    } finally {
        if (c != null) {
            c.close();
        }
    }
    // Check whether 'msgId' has been assigned a valid value.
    if (msgId == -1L) {
        throw new MmsException(""Error! ID of the message: -1."");
    }
    // Load address information of the MM.
    loadAddress(msgId, headers);
    int msgType = headers.getOctet(PduHeaders.MESSAGE_TYPE);
    PduBody body = new PduBody();
    // load multiparts and put them into the body of the PDU.
    if ((msgType == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) || (msgType == PduHeaders.MESSAGE_TYPE_SEND_REQ)) {
        PduPart[] parts = loadParts(msgId);
        if (parts != null) {
            int partsNum = parts.length;
            for (int i = 0; i < partsNum; i++) {
                body.addPart(parts[i]);
            }
        }
    }
    GenericPdu pdu = null;
    switch(msgType) {
        case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
            pdu = new NotificationInd(headers);
            break;
        case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
            pdu = new DeliveryInd(headers);
            break;
        case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
            pdu = new ReadOrigInd(headers);
            break;
        case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
            pdu = new RetrieveConf(headers, body);
            break;
        case PduHeaders.MESSAGE_TYPE_SEND_REQ:
            pdu = new SendReq(headers, body);
            break;
        case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
            pdu = new AcknowledgeInd(headers);
            break;
        case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
            pdu = new NotifyRespInd(headers);
            break;
        case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
            pdu = new ReadRecInd(headers);
            break;
        case PduHeaders.MESSAGE_TYPE_SEND_CONF:
        case PduHeaders.MESSAGE_TYPE_FORWARD_REQ:
        case PduHeaders.MESSAGE_TYPE_FORWARD_CONF:
        case PduHeaders.MESSAGE_TYPE_MBOX_STORE_REQ:
        case PduHeaders.MESSAGE_TYPE_MBOX_STORE_CONF:
        case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_REQ:
        case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_CONF:
        case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_REQ:
        case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_CONF:
        case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_REQ:
        case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_CONF:
        case PduHeaders.MESSAGE_TYPE_MBOX_DESCR:
        case PduHeaders.MESSAGE_TYPE_DELETE_REQ:
        case PduHeaders.MESSAGE_TYPE_DELETE_CONF:
        case PduHeaders.MESSAGE_TYPE_CANCEL_REQ:
        case PduHeaders.MESSAGE_TYPE_CANCEL_CONF:
            throw new MmsException(""Unsupported PDU type: "" + Integer.toHexString(msgType));
        default:
            throw new MmsException(""Unrecognized PDU type: "" + Integer.toHexString(msgType));
    }
    cacheEntry = new PduCacheEntry(pdu, msgBox, threadId);
    PDU_CACHE_INSTANCE.put(uri, cacheEntry);
    return pdu;
}","{
    GenericPdu pdu = null;
    PduCacheEntry cacheEntry = null;
    int msgBox = 0;
    long threadId = -1;
    try {
        synchronized (PDU_CACHE_INSTANCE) {
            if (PDU_CACHE_INSTANCE.isUpdating(uri)) {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""load: "" + uri + "" blocked by isUpdating()"");
                }
                try {
                    PDU_CACHE_INSTANCE.wait();
                } catch (InterruptedException e) {
                    Log.e(TAG, ""load: "", e);
                }
                cacheEntry = PDU_CACHE_INSTANCE.get(uri);
                if (cacheEntry != null) {
                    return cacheEntry.getPdu();
                }
            }
            // Tell the cache to indicate to other callers that this item
            // is currently being updated.
            PDU_CACHE_INSTANCE.setUpdating(uri, true);
        }
        Cursor c = SqliteWrapper.query(mContext, mContentResolver, uri, PDU_PROJECTION, null, null, null);
        PduHeaders headers = new PduHeaders();
        Set<Entry<Integer, Integer>> set;
        long msgId = ContentUris.parseId(uri);
        try {
            if ((c == null) || (c.getCount() != 1) || !c.moveToFirst()) {
                throw new MmsException(""Bad uri: "" + uri);
            }
            msgBox = c.getInt(PDU_COLUMN_MESSAGE_BOX);
            threadId = c.getLong(PDU_COLUMN_THREAD_ID);
            set = ENCODED_STRING_COLUMN_INDEX_MAP.entrySet();
            for (Entry<Integer, Integer> e : set) {
                setEncodedStringValueToHeaders(c, e.getValue(), headers, e.getKey());
            }
            set = TEXT_STRING_COLUMN_INDEX_MAP.entrySet();
            for (Entry<Integer, Integer> e : set) {
                setTextStringToHeaders(c, e.getValue(), headers, e.getKey());
            }
            set = OCTET_COLUMN_INDEX_MAP.entrySet();
            for (Entry<Integer, Integer> e : set) {
                setOctetToHeaders(c, e.getValue(), headers, e.getKey());
            }
            set = LONG_COLUMN_INDEX_MAP.entrySet();
            for (Entry<Integer, Integer> e : set) {
                setLongToHeaders(c, e.getValue(), headers, e.getKey());
            }
        } finally {
            if (c != null) {
                c.close();
            }
        }
        // Check whether 'msgId' has been assigned a valid value.
        if (msgId == -1L) {
            throw new MmsException(""Error! ID of the message: -1."");
        }
        // Load address information of the MM.
        loadAddress(msgId, headers);
        int msgType = headers.getOctet(PduHeaders.MESSAGE_TYPE);
        PduBody body = new PduBody();
        // load multiparts and put them into the body of the PDU.
        if ((msgType == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) || (msgType == PduHeaders.MESSAGE_TYPE_SEND_REQ)) {
            PduPart[] parts = loadParts(msgId);
            if (parts != null) {
                int partsNum = parts.length;
                for (int i = 0; i < partsNum; i++) {
                    body.addPart(parts[i]);
                }
            }
        }
        switch(msgType) {
            case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
                pdu = new NotificationInd(headers);
                break;
            case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
                pdu = new DeliveryInd(headers);
                break;
            case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
                pdu = new ReadOrigInd(headers);
                break;
            case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
                pdu = new RetrieveConf(headers, body);
                break;
            case PduHeaders.MESSAGE_TYPE_SEND_REQ:
                pdu = new SendReq(headers, body);
                break;
            case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
                pdu = new AcknowledgeInd(headers);
                break;
            case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
                pdu = new NotifyRespInd(headers);
                break;
            case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
                pdu = new ReadRecInd(headers);
                break;
            case PduHeaders.MESSAGE_TYPE_SEND_CONF:
            case PduHeaders.MESSAGE_TYPE_FORWARD_REQ:
            case PduHeaders.MESSAGE_TYPE_FORWARD_CONF:
            case PduHeaders.MESSAGE_TYPE_MBOX_STORE_REQ:
            case PduHeaders.MESSAGE_TYPE_MBOX_STORE_CONF:
            case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_REQ:
            case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_CONF:
            case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_REQ:
            case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_CONF:
            case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_REQ:
            case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_CONF:
            case PduHeaders.MESSAGE_TYPE_MBOX_DESCR:
            case PduHeaders.MESSAGE_TYPE_DELETE_REQ:
            case PduHeaders.MESSAGE_TYPE_DELETE_CONF:
            case PduHeaders.MESSAGE_TYPE_CANCEL_REQ:
            case PduHeaders.MESSAGE_TYPE_CANCEL_CONF:
                throw new MmsException(""Unsupported PDU type: "" + Integer.toHexString(msgType));
            default:
                throw new MmsException(""Unrecognized PDU type: "" + Integer.toHexString(msgType));
        }
    } finally {
        synchronized (PDU_CACHE_INSTANCE) {
            if (pdu != null) {
                assert (PDU_CACHE_INSTANCE.get(uri) == null);
                // Update the cache entry with the real info
                cacheEntry = new PduCacheEntry(pdu, msgBox, threadId);
                PDU_CACHE_INSTANCE.put(uri, cacheEntry);
            }
            PDU_CACHE_INSTANCE.setUpdating(uri, false);
            // tell anybody waiting on this entry to go ahead
            PDU_CACHE_INSTANCE.notifyAll();
        }
    }
    return pdu;
}",1,"/**
 * Load a PDU from storage by given Uri.
 *
 * @param uri The Uri of the PDU to be loaded.
 * @return A generic PDU object, it may be cast to dedicated PDU.
 * @throws MmsException Failed to load some fields of a PDU.
 */
","/**
 * Load a PDU from storage by given Uri.
 *
 * @param uri The Uri of the PDU to be loaded.
 * @return A generic PDU object, it may be cast to dedicated PDU.
 * @throws MmsException Failed to load some fields of a PDU.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependencies, such as conditions and synchronization blocks, have changed. Additionally, new statements are added, including PDU_CACHE_INSTANCE.wait() and PDU_CACHE_INSTANCE.notifyAll(), hence the change type is 3,4.","The change of control dependencies and other statements introduce new behaviors to the API, which could potentially lead this API to return a different value or act differently under certain circumstances, thus the CI type is 1."
21,"<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>",15,16,"<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>","<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>",0,"{
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    int modifiers = setupModifiers(paint);
    nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"In the late implementation setupModifiers method's parameters have changed and a new try/finally block has been introduced. Thus, the Code Change types are 1 (return statement has changed because of the new setupModifiers parameters) and 3 (Control dependency has changed because of the introduced try/finally block).","Despite these changes, there is no potential Compatibility Issue, because both changes should not affect the API's behavior in terms of returned values or thrown exceptions. The try block does not catch or throw any new exceptions leading to different behavior in the latest version. Therefore, the CI type is 0."
23,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",15,16,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>","<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",0,"{
    return mContentProvider.insert(url, initialValues);
}","{
    try {
        return mContentProvider.insert(url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
","/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"Exception handling statement has been introduced (try-catch block with DeadObjectException) and control dependency also changed ('try' condition and the 'catch' condition), thus the change type is 2,3.","The newly added exception handling statement could lead the API to throw a new 'DeadObjectException' in the late version. This change leads to different behavior when this exception occurs, thus the Compatibility Issue type is 2."
24,"<android.view.GLES20Canvas: void drawPosText(char[],int,int,float[],Paint)>",15,16,"<android.view.GLES20Canvas: void drawPosText(char[],int,int,float[],Paint)>","<android.view.GLES20Canvas: void drawPosText(char[],int,int,float[],Paint)>",0,"{
// TODO: Implement
}","{
    if (index < 0 || index + count > text.length || count * 2 > pos.length) {
        throw new IndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawPosText(mRenderer, text, index, count, pos, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],"[@SuppressWarnings(""deprecation""), @Override]",-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","In the early implementation, no code was implemented, while in the late version, multiple statements including return, control statement, normal statement, and exception handling were added, so the code change type is 1,2,3,4.","As new exception handling and return statement introduced in late version, the API will throw new exceptions and return different values which were not there in the early version. Therefore, the CI type is 1,2."
25,"<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>",15,16,"<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>","<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>",0,"{
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onCreateOptionsMenu(menu, inflater);
                if (newMenus == null) {
                    newMenus = new ArrayList<Fragment>();
                }
                newMenus.add(f);
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}","{
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onCreateOptionsMenu(menu, inflater);
                if (newMenus == null) {
                    newMenus = new ArrayList<Fragment>();
                }
                newMenus.add(f);
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change observed between the Early_Version and the Late_Version of this API.,"Since there is no change, there is no Compatibility Issue."
26,<android.webkit.CookieManager: boolean allowFileSchemeCookies()>,15,16,<android.webkit.CookieManager: boolean allowFileSchemeCookies()>,<android.webkit.CookieManager: boolean allowFileSchemeCookies()>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        return nativeAcceptFileSchemeCookies();
    } else {
        return true;
    }
}","{
    return getInstance().allowFileSchemeCookiesImpl();
}",1,"/**
 * Whether cookies are accepted for file scheme URLs.
 */
","// Static for backward compatibility.
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation called the nativeAcceptFileSchemeCookies() method based on the condition, while the late implementation directly returned the result from allowFileSchemeCookiesImpl() of getInstance(). This shows the change in both calling dependent APIs and the return statement, so the code change type is 1,5.","The return values in the early and late versions could possibly be different due to changes in the methods being called, indicating a potential compatibility issue. Therefore, the CI is type 1."
27,<android.accessibilityservice.AccessibilityServiceInfo: String getDescription()>,15,16,<android.accessibilityservice.AccessibilityServiceInfo: String getDescription()>,<android.accessibilityservice.AccessibilityServiceInfo: String getDescription()>,0,"{
    return mDescription;
}","{
    return mNonLocalizedDescription;
}",1,"/**
 * Description of the accessibility service.
 * <p>
 * <strong>Statically set from
 * {@link AccessibilityService#SERVICE_META_DATA meta-data}.</strong>
 * </p>
 * @return The description.
 */
","/**
 * Gets the non-localized description of the accessibility service.
 * <p>
 * <strong>Statically set from
 * {@link AccessibilityService#SERVICE_META_DATA meta-data}.</strong>
 * </p>
 * @return The description.
 *
 * @deprecated Use {@link #loadDescription(PackageManager)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The returned variable has changed from 'mDescription' to 'mNonLocalizedDescription', so the code change type is 1.","The change of return statement means that the API potentially returns a different value in the two versions, so the CI type is 1."
28,<android.webkit.WebView: void clearMatches()>,15,16,<android.webkit.WebView: void clearMatches()>,<android.webkit.WebView: void clearMatches()>,0,"{
    checkThread();
    if (mNativeClass == 0)
        return;
    nativeSetFindIsEmpty();
    invalidate();
}","{
    checkThread();
    mProvider.clearMatches();
}",1,"/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
","/**
 * Clears the highlighting surrounding text matches created by
 * {@link #findAll} or {@link #findAllAsync}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"In the Late Implementation, the return statement is deleted and a new statement 'mProvider.clearMatches();' which is another API, has been added. Also, the statements 'nativeSetFindIsEmpty();' and 'invalidate();' are removed in the Late Version. Therefore, the change types are 1,4,5.","Due to the elimination of the return statement and the addition of another API call execution, it is possible that the method would not exit at the same point or perform the same tasks as in the early version, therefore, resulting in potentially different return types or values. The CI type is 1."
29,<android.webkit.WebView: boolean canGoBackOrForward(int)>,15,16,<android.webkit.WebView: boolean canGoBackOrForward(int)>,<android.webkit.WebView: boolean canGoBackOrForward(int)>,0,"{
    checkThread();
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            int newIndex = l.getCurrentIndex() + steps;
            return newIndex >= 0 && newIndex < l.getSize();
        }
    }
}","{
    checkThread();
    return mProvider.canGoBackOrForward(steps);
}",1,"/**
 * Return true if the page can go back or forward the given
 * number of steps.
 * @param steps The negative or positive number of steps to move the
 * history.
 */
","/**
 * Gets whether the page can go back or forward the given
 * number of steps.
 *
 * @param steps the negative or positive number of steps to move the
 * history
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The code block has been completely replaced by a single return statement which calls mProvider.canGoBackOrForward(steps). This is a significant change in implementation, so the code change type is 1,4,5.","As the entire implementation has been changed including the return statement, the latter version of the API will likely return a different value than the earlier version, thus the CI type is 1."
32,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,15,16,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,0,"{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    execPendingActions();
    mStateSaved = true;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.get(i);
        if (f != null) {
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        String msg = ""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget;
                        Slog.e(TAG, msg);
                        dump(""  "", null, new PrintWriter(new LogWriter(Log.ERROR, TAG, Log.LOG_ID_SYSTEM)), new String[] {});
                        throw new IllegalStateException(msg);
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    if (mAdded != null) {
        N = mAdded.size();
        if (N > 0) {
            added = new int[N];
            for (int i = 0; i < N; i++) {
                added[i] = mAdded.get(i).mIndex;
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
            }
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    return fms;
}","{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    execPendingActions();
    mStateSaved = true;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.get(i);
        if (f != null) {
            if (f.mIndex < 0) {
                String msg = ""Failure saving state: active "" + f + "" has cleared index: "" + f.mIndex;
                Slog.e(TAG, msg);
                dump(""  "", null, new PrintWriter(new LogWriter(Log.ERROR, TAG, Log.LOG_ID_SYSTEM)), new String[] {});
                throw new IllegalStateException(msg);
            }
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        String msg = ""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget;
                        Slog.e(TAG, msg);
                        dump(""  "", null, new PrintWriter(new LogWriter(Log.ERROR, TAG, Log.LOG_ID_SYSTEM)), new String[] {});
                        throw new IllegalStateException(msg);
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    if (mAdded != null) {
        N = mAdded.size();
        if (N > 0) {
            added = new int[N];
            for (int i = 0; i < N; i++) {
                added[i] = mAdded.get(i).mIndex;
                if (added[i] < 0) {
                    String msg = ""Failure saving state: active "" + mAdded.get(i) + "" has cleared index: "" + added[i];
                    Slog.e(TAG, msg);
                    dump(""  "", null, new PrintWriter(new LogWriter(Log.ERROR, TAG, Log.LOG_ID_SYSTEM)), new String[] {});
                    throw new IllegalStateException(msg);
                }
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
            }
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    return fms;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The conditions inside 'if' statements have changed, and new exception handling statements have been introduced, so the change type is 2,3.","The introduced new exception handling blocks could potentially throw a new exception, so the CI type is 2."
33,<android.server.BluetoothAdapterStateMachine.BluetoothOn: boolean processMessage(Message)>,15,16,<android.server.BluetoothAdapterStateMachine.BluetoothOn: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.BluetoothOn: boolean processMessage(Message)>,0,"{
    log(""BluetoothOn process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_OFF:
            if ((Boolean) message.obj) {
                persistSwitchSetting(false);
            }
            if (mBluetoothService.isDiscovering()) {
                mBluetoothService.cancelDiscovery();
            }
            if (!mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
                transitionTo(mPerProcessState);
                deferMessage(obtainMessage(TURN_HOT));
                break;
            }
        // $FALL-THROUGH$ to AIRPLANE_MODE_ON
        case AIRPLANE_MODE_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
            transitionTo(mSwitching);
            if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
                mBluetoothService.disconnectDevices();
                sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT, DEVICES_DISCONNECT_TIMEOUT_TIME);
            } else {
                mBluetoothService.switchConnectable(false);
                sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            }
            // we turn all the way to PowerOff with AIRPLANE_MODE_ON
            if (message.what == AIRPLANE_MODE_ON) {
                // We inform all the per process callbacks
                allProcessesCallback(false);
                deferMessage(obtainMessage(AIRPLANE_MODE_ON));
            }
            break;
        case AIRPLANE_MODE_OFF:
        case USER_TURN_ON:
            Log.w(TAG, ""BluetoothOn received: "" + message.what);
            break;
        case PER_PROCESS_TURN_ON:
            perProcessCallback(true, (IBluetoothStateChangeCallback) message.obj);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                // reset the state machine and send it TURN_ON_CONTINUE message
                recoverStateMachine(USER_TURN_ON, false);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""BluetoothOn process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_OFF:
            if ((Boolean) message.obj) {
                persistSwitchSetting(false);
            }
            if (mBluetoothService.isDiscovering()) {
                mBluetoothService.cancelDiscovery();
            }
            if (!mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
                transitionTo(mPerProcessState);
                deferMessage(obtainMessage(TURN_HOT));
                break;
            }
        // $FALL-THROUGH$ to AIRPLANE_MODE_ON
        case AIRPLANE_MODE_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
            transitionTo(mSwitching);
            if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
                mBluetoothService.disconnectDevices();
                sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT, DEVICES_DISCONNECT_TIMEOUT_TIME);
            } else {
                mBluetoothService.switchConnectable(false);
                sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
            }
            if (message.what == AIRPLANE_MODE_ON || mBluetoothService.isAirplaneModeOn()) {
                // We inform all the per process callbacks
                allProcessesCallback(false);
            }
            break;
        case AIRPLANE_MODE_OFF:
        case USER_TURN_ON:
            Log.w(TAG, ""BluetoothOn received: "" + message.what);
            break;
        case PER_PROCESS_TURN_ON:
            perProcessCallback(true, (IBluetoothStateChangeCallback) message.obj);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                // reset the state machine and send it TURN_ON_CONTINUE message
                recoverStateMachine(USER_TURN_ON, false);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In AIRPLANE_MODE_ON case, a new code `mBluetoothService.isAirplaneModeOn()` is added inside if statement and `sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME)` is replaced `sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME)`. So the changes are control dependency change and other statement change, the code change type is 3,4.",This change of control statement and other statement could potentially make the code behave differently and hence the return value of this API could be different in the late version. Thus the CI type is 1.
36,<android.webkit.WebSettings: boolean supportMultipleWindows()>,15,16,<android.webkit.WebSettings: boolean supportMultipleWindows()>,<android.webkit.WebSettings: boolean supportMultipleWindows()>,0,"{
    return mSupportMultipleWindows;
}","{
    throw new MustOverrideException();
}",1,"/**
 * @return True if the WebView is supporting multiple windows. This means
 * that {@link WebChromeClient#onCreateWindow(WebView, boolean,
 * boolean, Message)} is implemented by the host application.
 */
","/**
 * Gets whether the WebView is supporting multiple windows.
 *
 * @return true if the WebView is supporting multiple windows. This means
 * that {@link WebChromeClient#onCreateWindow(WebView, boolean,
 * boolean, Message)} is implemented by the host application.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The implementation completely changes from a return statement to a throw exception statement, so the code change belongs to type 1,2.","The old version is returning a boolean value, but the new version only throws an exception. This clearly cause potential different return values or types, and exception handlings between two versions, so the CI type is 1,2."
37,"<android.view.GLES20Canvas: void drawPicture(Picture,Rect)>",15,16,"<android.view.GLES20Canvas: void drawPicture(Picture,Rect)>","<android.view.GLES20Canvas: void drawPicture(Picture,Rect)>",0,"{
    throw new UnsupportedOperationException();
}","{
    if (picture.createdFromStream) {
        return;
    }
    save();
    translate(dst.left, dst.top);
    if (picture.getWidth() > 0 && picture.getHeight() > 0) {
        scale(dst.width() / picture.getWidth(), dst.height() / picture.getHeight());
    }
    drawPicture(picture);
    restore();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The early version only throws an exception while the late version removed this exception and implemented this method. This includes adding a 'return' statement, new control dependencies like 'if', method invocation of the object 'picture', and working with different methods such as save(), translate(), scale(), drawPicture() and restore(). Thus, the change type is 1,2,3,4.","Because the early version throws an exception regardless of what the input is and the late version could either return nothing or return a value after executing a series of operations, the behavior of the two versions could be essentially different. Thus, the compatibility issue type is 1,2."
38,<android.database.sqlite.SQLiteDatabase: void finalize()>,15,16,<android.database.sqlite.SQLiteDatabase: void finalize()>,<android.database.sqlite.SQLiteDatabase: void finalize()>,0,"{
    try {
        if (isOpen()) {
            Log.e(TAG, ""close() was never explicitly called on database '"" + mPath + ""' "", mStackTrace);
            closeClosable();
            onAllReferencesReleased();
            releaseCustomFunctions();
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        dispose(true);
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5","1,2","The whole try block got replaced with another method call dispose(true), so the code change type is 4,5.","The new dispose(true) method could potentially throw a different exception or return another result, which could lead to different behaviour of the application that rely on this method. Thus, the CI type is 1,2."
39,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,15,16,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mAccessibilityViewId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mAccessibilityWindowId, mAccessibilityViewId, action);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mWindowId, mSourceNodeId, action, null);
}",1,"/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement was changed from canPerformRequestOverConnection(mAccessibilityViewId) to canPerformRequestOverConnection(mSourceNodeId) and the argument on performAccessibilityAction() method also changed, hence the code change type is 1,5.","The API potentially returns a different value because of the changed condition and the modification in the return statement of the method performAccessibilityAction(), hence the CI type is 1."
42,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>",15,16,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>","<android.provider.Settings.Secure: String getString(ContentResolver,String)>",0,"{
    if (sNameValueCache == null) {
        sNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI, CALL_METHOD_GET_SECURE);
    }
    return sNameValueCache.getString(resolver, name);
}","{
    if (sNameValueCache == null) {
        sNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI, CALL_METHOD_GET_SECURE);
    }
    if (sLockSettings == null) {
        sLockSettings = ILockSettings.Stub.asInterface((IBinder) ServiceManager.getService(""lock_settings""));
        sIsSystemProcess = Process.myUid() == Process.SYSTEM_UID;
    }
    if (sLockSettings != null && !sIsSystemProcess && MOVED_TO_LOCK_SETTINGS.contains(name)) {
        try {
            return sLockSettings.getString(name, ""0"", UserId.getCallingUserId());
        } catch (RemoteException re) {
        // Fall through
        }
    }
    return sNameValueCache.getString(resolver, name);
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Several new statements regarding to sLockSettings object and its manipulation have been added, hence the change types are 3 and 4.  Additionally, a new return statement 'return sLockSettings.getString()' is also introduced which causes the change type to be 1.","The new return statement 'return sLockSettings.getString()' increases the potential behaviour of this API. For certain input parameter 'name', 'sLockSettings.getString()' can be returned in the late version while not in the early version, possibly leading to different return values which stands for CI type 1."
44,<android.widget.PopupWindow: void dismiss()>,15,16,<android.widget.PopupWindow: void dismiss()>,<android.widget.PopupWindow: void dismiss()>,0,"{
    if (isShowing() && mPopupView != null) {
        mIsShowing = false;
        unregisterForScrollChanged();
        try {
            mWindowManager.removeView(mPopupView);
        } finally {
            if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
                ((ViewGroup) mPopupView).removeView(mContentView);
            }
            mPopupView = null;
            if (mOnDismissListener != null) {
                mOnDismissListener.onDismiss();
            }
        }
    }
}","{
    if (isShowing() && mPopupView != null) {
        mIsShowing = false;
        unregisterForScrollChanged();
        try {
            mWindowManager.removeViewImmediate(mPopupView);
        } finally {
            if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
                ((ViewGroup) mPopupView).removeView(mContentView);
            }
            mPopupView = null;
            if (mOnDismissListener != null) {
                mOnDismissListener.onDismiss();
            }
        }
    }
}",1,"/**
 * <p>Dispose of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
 * this method will have no effect.</p>
 *
 * @see #showAsDropDown(android.view.View)
 */
","/**
 * <p>Dispose of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
 * this method will have no effect.</p>
 *
 * @see #showAsDropDown(android.view.View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method of WindowManager is changed from removeView() to removeViewImmediate(). So, the change type is 4 (other statement changed).","The change is in the implementation of the method called, but it doesn't affect the return or exception values of the API. Hence, no compatibility issue exists."
45,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",15,16,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",0,"{
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    float left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        float left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The code condition has been changed with the addition of a throw statement and a conditional check (if (bitmap.isRecycled())), thus the code change types are 2,3.","The new condition (bitmap.isRecycled()) will throw a new exception that wasn't present in the early version of the code. Hence, the CI type is 2, considering that the method might throw a different exception."
46,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,15,16,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"An additional parameter `Binder.getOrigCallingUser()` has been added in `ActivityManagerNative.getDefault().broadcastIntent()` function call, so the code change types are 4,5 (other statement changed and dependent API changed).","Since the change only alters an internal method call without altering the return value or the exception, it does not cause any compatibility issues, so the CI type is 0 (no Compatibility Issue exist)."
47,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,15,16,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,0,"{
    return mContentProvider.applyBatch(operations);
}","{
    try {
        return mContentProvider.applyBatch(operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
","/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"An exception handler has been introduced in the late version, so the code change type is 2.","The addition of an exception handler could allow the function to behave differently when an exception occurs, potentially causing an exception that was previously caught to be thrown. So the CI type is 2."
48,<android.webkit.CookieManager: String getCookie(String)>,15,16,<android.webkit.CookieManager: String getCookie(String)>,<android.webkit.CookieManager: String getCookie(String)>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        return getCookie(url, false);
    }
    WebAddress uri;
    try {
        uri = new WebAddress(url);
    } catch (ParseException ex) {
        Log.e(LOGTAG, ""Bad address: "" + url);
        return null;
    }
    return getCookie(uri);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get cookie(s) for a given url so that it can be set to ""cookie:"" in http
 * request header.
 * @param url The url needs cookie
 * @return The cookies in the format of NAME=VALUE [; NAME=VALUE]
 */
","/**
 * Gets the cookies for the given URL.
 *
 * @param url the URL for which the cookies are requested
 * @return value the cookies as a string, using the format of the 'Cookie'
 * HTTP request header
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 2","1, 2","The entire early implementation has been replaced in the later version with a 'throw' statement, classified as code change types 1 and 2.","The latest version of the implementation throws a 'MustOverrideException' unconditionally, which could cause previously expected return types to differ and propagate an exception that was not present in the early version. Therefore, the CI type is 1,2."
50,<android.database.sqlite.SQLiteDatabase: void setTransactionSuccessful()>,15,16,<android.database.sqlite.SQLiteDatabase: void setTransactionSuccessful()>,<android.database.sqlite.SQLiteDatabase: void setTransactionSuccessful()>,0,"{
    verifyDbIsOpen();
    if (!mLock.isHeldByCurrentThread()) {
        throw new IllegalStateException(""no transaction pending"");
    }
    if (mInnerTransactionIsSuccessful) {
        throw new IllegalStateException(""setTransactionSuccessful may only be called once per call to beginTransaction"");
    }
    mInnerTransactionIsSuccessful = true;
}","{
    acquireReference();
    try {
        getThreadSession().setTransactionSuccessful();
    } finally {
        releaseReference();
    }
}",1,"/**
 * Marks the current transaction as successful. Do not do any more database work between
 * calling this and calling endTransaction. Do as little non-database work as possible in that
 * situation too. If any errors are encountered between this and endTransaction the transaction
 * will still be committed.
 *
 * @throws IllegalStateException if the current thread is not in a transaction or the
 * transaction is already marked as successful.
 */
","/**
 * Marks the current transaction as successful. Do not do any more database work between
 * calling this and calling endTransaction. Do as little non-database work as possible in that
 * situation too. If any errors are encountered between this and endTransaction the transaction
 * will still be committed.
 *
 * @throws IllegalStateException if the current thread is not in a transaction or the
 * transaction is already marked as successful.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The entire implementation of this function has been rewritten. The early version is throwing IllegalStateException if the conditions meet, and changing the value of mInnerTransactionIsSuccessful to true. However, the late version is trying to setTransactionSuccessful with getThreadSession() and also adds acquireReference() and releaseReference() function calls. This falls under all categories of code change (1: Return statement changed; 2: Exception handling statement changed; 3: Control dependency changed; 4: Other statement changed).","The change in exception handling from the early version to the late version can cause the API to throw different exceptions. Also, due to change in the implementation logic, it could potentially return different values. Hence, the CI type is 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
51,"<android.app.ApplicationPackageManager: ResolveInfo resolveService(Intent,int)>",15,16,"<android.app.ApplicationPackageManager: ResolveInfo resolveService(Intent,int)>","<android.app.ApplicationPackageManager: ResolveInfo resolveService(Intent,int)>",0,"{
    try {
        return mPM.resolveService(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.resolveService(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed with an additional parameter UserId.myUserId() being added to the mPM.resolveService function, so the code change types are 1,5.","The addition of a new parameter to the mPM.resolveService function has the potential to change the return type and thereby the behavior of the API. Therefore, the CI type is 1."
52,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,15,16,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,0,"{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG)
            Log.v(FragmentManagerImpl.TAG, ""BSE "" + bse + "" set base fragment #"" + mOps[pos]);
        Fragment f = fm.mActive.get(mOps[pos++]);
        op.fragment = f;
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG)
                    Log.v(FragmentManagerImpl.TAG, ""BSE "" + bse + "" set remove fragment #"" + mOps[pos]);
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.addOp(op);
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.bumpBackStackNesting(1);
    return bse;
}","{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG)
            Log.v(FragmentManagerImpl.TAG, ""BSE "" + bse + "" set base fragment #"" + mOps[pos]);
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG)
                    Log.v(FragmentManagerImpl.TAG, ""BSE "" + bse + "" set remove fragment #"" + mOps[pos]);
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.addOp(op);
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.bumpBackStackNesting(1);
    return bse;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the middle of the implementation, the way the fragment 'f' is assigned has changed to include a conditional check (from Fragment f = fm.mActive.get(mOps[pos++]) to if (findex >= 0) {Fragment f = fm.mActive.get(findex); op.fragment = f;}  else {op.fragment = null;}). Therefore, the code change types are 3 and 4.","This change potentially results in a different return value of op.fragment as it might be assigned as null in the later version, which may not happen in the early version. Therefore, the Compatibility Issue type is 1."
53,<android.webkit.WebViewDatabase: void clearFormData()>,15,16,<android.webkit.WebViewDatabase: void clearFormData()>,<android.webkit.WebViewDatabase: void clearFormData()>,0,"{
    if (!checkInitialized()) {
        return;
    }
    synchronized (mFormLock) {
        mDatabase.delete(mTableNames[TABLE_FORMURL_ID], null, null);
        mDatabase.delete(mTableNames[TABLE_FORMDATA_ID], null, null);
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Clear form database
 */
","/**
 * Clears any stored previously-entered form data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early implementation of the API contains several statements and a return statement which are completely replaced by a single throw statement in the late implementation. Thus, the code change type is 1,2.","As the entire implementation was changed from return statement and operations on the mDatabase to just throwing a MustOverrideException, the API may return a different output or throw a different exception, thus the CI types are 1,2."
54,<android.widget.ActivityChooserView.Callbacks: void onClick(View)>,15,16,<android.widget.ActivityChooserView.Callbacks: void onClick(View)>,<android.widget.ActivityChooserView.Callbacks: void onClick(View)>,0,"{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            mContext.startActivity(launchIntent);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}","{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
            mContext.startActivity(launchIntent);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}",1,"// View.OnClickListener
","// View.OnClickListener
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change only applies a new flag to the launchIntent variable without affecting the flow of the method. Hence, the code change type is 4.","There is no Compatibility Issue in this change as it does not modify any return values, exception handling, or behaviors of the method. Thus, the CI type is 0."
56,<android.view.View: int getSuggestedMinimumHeight()>,15,16,<android.view.View: int getSuggestedMinimumHeight()>,<android.view.View: int getSuggestedMinimumHeight()>,0,"{
    int suggestedMinHeight = mMinHeight;
    if (mBGDrawable != null) {
        final int bgMinHeight = mBGDrawable.getMinimumHeight();
        if (suggestedMinHeight < bgMinHeight) {
            suggestedMinHeight = bgMinHeight;
        }
    }
    return suggestedMinHeight;
}","{
    return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());
}",1,"/**
 * Returns the suggested minimum height that the view should use. This
 * returns the maximum of the view's minimum height
 * and the background's minimum height
 * ({@link android.graphics.drawable.Drawable#getMinimumHeight()}).
 * <p>
 * When being used in {@link #onMeasure(int, int)}, the caller should still
 * ensure the returned height is within the requirements of the parent.
 *
 * @return The suggested minimum height of the view.
 */
","/**
 * Returns the suggested minimum height that the view should use. This
 * returns the maximum of the view's minimum height
 * and the background's minimum height
 * ({@link android.graphics.drawable.Drawable#getMinimumHeight()}).
 * <p>
 * When being used in {@link #onMeasure(int, int)}, the caller should still
 * ensure the returned height is within the requirements of the parent.
 *
 * @return The suggested minimum height of the view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The implementation of return statement has been condensed into a ternary statement, causing a change in the return statement. Therefore, the code change type is 1.","The change in the return statement means the API could potentially return a different variable value in the later version as compared to the early version. Therefore, the CI type is 1."
58,"<android.view.GLES20Canvas: void drawPatch(Bitmap,byte[],RectF,Paint)>",15,16,"<android.view.GLES20Canvas: void drawPatch(Bitmap,byte[],RectF,Paint)>","<android.view.GLES20Canvas: void drawPatch(Bitmap,byte[],RectF,Paint)>",0,"{
    // Shaders are ignored when drawing patches
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, chunks, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    if (modifier != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifier);
}","{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing patches
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, chunks, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"A 'throw' statement has been introduced and the control dependency has changed due to the introduction of 'try...finally' block. Hence, the change type is 2,3.","Since a new exception is introduced, there is a possibility of throwing a new exception in the late version, hence, the CI type is 2."
59,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",15,16,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"{
    return mContentProvider.update(url, values, selection, selectionArgs);
}","{
    try {
        return mContentProvider.update(url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The change in code can be classified under both category 1 (Return statement changed) and category 2 (Exception handling statement changed). In the late version, a 'try/catch' statement has been introduced where an exception 'DeadObjectException' is being handled. Also, the 'return' statement is now under a 'try' block.","The compatibility issues arise due to potential different return values and different exception handling. The return statement is now enclosed in a 'try' block, which means it will only be executed if no exception is raised. In the 'catch' block, the same exception is rethrown after some specific handling, which also changes the way in how exceptions are dealt with, therefore it causes a potential different exception handling. Hence, the CI type is 1,2."
60,<android.webkit.WebView: float getScale()>,15,16,<android.webkit.WebView: float getScale()>,<android.webkit.WebView: float getScale()>,0,"{
    checkThread();
    return mZoomManager.getScale();
}","{
    checkThread();
    return mProvider.getScale();
}",1,"/**
 * Return the current scale of the WebView
 * @return The current scale.
 */
","/**
 * Gets the current scale of this WebView.
 *
 * @return the current scale
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mZoomManager.getScale() to mProvider.getScale() and the method from which the return value is acquired has also changed, hence the code change type is 1,5.","The change of return statement can potentially cause the API to return a different value hence causing a compatibility issue. Therefore, the CI type is 1."
61,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,15,16,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            if (mPositionScroller != null) {
                                mPositionScroller.stop();
                            }
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionX = (int) ev.getX();
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            mDirection = 0;
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling).
                                    // It might be a click or a scroll. Assume it is a click until
                                    // proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        mFlingRunnable.flywheelTouch();
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                if (performButtonActionOnTouchDown(ev)) {
                    if (mTouchMode == TOUCH_MODE_DOWN) {
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                int pointerIndex = ev.findPointerIndex(mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    mActivePointerId = ev.getPointerId(pointerIndex);
                }
                final int y = (int) ev.getY(pointerIndex);
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(y);
                        break;
                    case TOUCH_MODE_SCROLL:
                    case TOUCH_MODE_OVERSCROLL:
                        scrollIfNeeded(y);
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        final float x = ev.getX();
                        final boolean inList = x > mListPadding.left && x < getWidth() - mListPadding.right;
                        if (child != null && !child.hasFocusable() && inList) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(mMotionPosition, child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    if (mTouchModeReset != null) {
                                        removeCallbacks(mTouchModeReset);
                                    }
                                    mTouchModeReset = new Runnable() {

                                        @Override
                                        public void run() {
                                            mTouchMode = TOUCH_MODE_REST;
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                performClick.run();
                                            }
                                        }
                                    };
                                    postDelayed(mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    updateSelectorState();
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                performClick.run();
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        updateSelectorState();
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) (velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                    if (mFlingRunnable != null) {
                                        mFlingRunnable.endFling();
                                    }
                                    if (mPositionScroller != null) {
                                        mPositionScroller.stop();
                                    }
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                recycleVelocityTracker();
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                if (mScrollStrictSpan != null) {
                    mScrollStrictSpan.finish();
                    mScrollStrictSpan = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        recycleVelocityTracker();
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!mIsAttached) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            if (mPositionScroller != null) {
                                mPositionScroller.stop();
                            }
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionX = (int) ev.getX();
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            mDirection = 0;
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling).
                                    // It might be a click or a scroll. Assume it is a click until
                                    // proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        mFlingRunnable.flywheelTouch();
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                if (performButtonActionOnTouchDown(ev)) {
                    if (mTouchMode == TOUCH_MODE_DOWN) {
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                int pointerIndex = ev.findPointerIndex(mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    mActivePointerId = ev.getPointerId(pointerIndex);
                }
                final int y = (int) ev.getY(pointerIndex);
                if (mDataChanged) {
                    // Re-sync everything if data has been changed
                    // since the scroll operation can query the adapter.
                    layoutChildren();
                }
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(y);
                        break;
                    case TOUCH_MODE_SCROLL:
                    case TOUCH_MODE_OVERSCROLL:
                        scrollIfNeeded(y);
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        final float x = ev.getX();
                        final boolean inList = x > mListPadding.left && x < getWidth() - mListPadding.right;
                        if (child != null && !child.hasFocusable() && inList) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(mMotionPosition, child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    if (mTouchModeReset != null) {
                                        removeCallbacks(mTouchModeReset);
                                    }
                                    mTouchModeReset = new Runnable() {

                                        @Override
                                        public void run() {
                                            mTouchMode = TOUCH_MODE_REST;
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                performClick.run();
                                            }
                                        }
                                    };
                                    postDelayed(mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    updateSelectorState();
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                performClick.run();
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        updateSelectorState();
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) (velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                    if (mFlingRunnable != null) {
                                        mFlingRunnable.endFling();
                                    }
                                    if (mPositionScroller != null) {
                                        mPositionScroller.stop();
                                    }
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                recycleVelocityTracker();
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                if (mScrollStrictSpan != null) {
                    mScrollStrictSpan.finish();
                    mScrollStrictSpan = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        recycleVelocityTracker();
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
62,<android.view.accessibility.AccessibilityRecord: void enforceNotSealed()>,15,16,<android.view.accessibility.AccessibilityRecord: void enforceNotSealed()>,<android.view.accessibility.AccessibilityRecord: void enforceNotSealed()>,0,"{
    if (isSealed()) {
        throw new IllegalStateException(""Cannot perform this "" + ""action on an sealed instance."");
    }
}","{
    if (isSealed()) {
        throw new IllegalStateException(""Cannot perform this "" + ""action on a sealed instance."");
    }
}",1,"/**
 * Enforces that this instance is not sealed.
 *
 * @throws IllegalStateException If this instance is sealed.
 */
","/**
 * Enforces that this instance is not sealed.
 *
 * @throws IllegalStateException If this instance is sealed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the message in the exception has changed. This only changes the error message displayed and doesn't influence the functionality of the code. Therefore, the change category is 4 (other statement changed).","Although the text in the exception message has changed, the conditions for this exception to be thrown haven't changed. Therefore, this change does not result in different return values or types nor different exception handlings. Hence, no compatibility issue (CI type 0) exists."
65,<android.webkit.WebView: boolean overlayVerticalScrollbar()>,15,16,<android.webkit.WebView: boolean overlayVerticalScrollbar()>,<android.webkit.WebView: boolean overlayVerticalScrollbar()>,0,"{
    checkThread();
    return mOverlayVerticalScrollbar;
}","{
    checkThread();
    return mProvider.overlayVerticalScrollbar();
}",1,"/**
 * Return whether vertical scrollbar has overlay style
 * @return TRUE if vertical scrollbar has overlay style.
 */
","/**
 * Gets whether vertical scrollbar has overlay style.
 *
 * @return true if vertical scrollbar has overlay style
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the late version, the method of providing the returned value has changed from a direct access to the mOverlayVerticalScrollbar field to mProvider.overlayVerticalScrollbar() method call. This change falls into category 1 and 5.","The change can potentially lead to a compatibility issue of type 1, because the new source of the returned value could potentially be different from that of the early version, since it now relies on the behavior of mProvider.overlayVerticalScrollbar()."
66,"<android.view.View: boolean postDelayed(Runnable,long)>",15,16,"<android.view.View: boolean postDelayed(Runnable,long)>","<android.view.View: boolean postDelayed(Runnable,long)>",0,"{
    Handler handler;
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        handler = attachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);
        return true;
    }
    return handler.postDelayed(action, delayMillis);
}","{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.postDelayed(action, delayMillis);
    }
    // Assume that post will succeed later
    ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);
    return true;
}",1,"/**
 * <p>Causes the Runnable to be added to the message queue, to be run
 * after the specified amount of time elapses.
 * The runnable will be run on the user interface thread.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable that will be executed.
 * @param delayMillis The delay (in milliseconds) until the Runnable
 * will be executed.
 *
 * @return true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the Runnable will be processed --
 * if the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 */
","/**
 * <p>Causes the Runnable to be added to the message queue, to be run
 * after the specified amount of time elapses.
 * The runnable will be run on the user interface thread.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable that will be executed.
 * @param delayMillis The delay (in milliseconds) until the Runnable
 * will be executed.
 *
 * @return true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the Runnable will be processed --
 * if the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 *
 * @see #post
 * @see #removeCallbacks
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3,",1,"The assignment operation for the variable 'handler' is removed and the order of the return statements has changed, so the code change type is 1, 3.","Due to change in the order of return statements and removal of handler variable assignment, the method potentially returns a different value in the late version compared to the early version, so the CI type is 1."
67,<android.webkit.WebSettings: void setMinimumFontSize(int)>,15,16,<android.webkit.WebSettings: void setMinimumFontSize(int)>,<android.webkit.WebSettings: void setMinimumFontSize(int)>,0,"{
    size = pin(size);
    if (mMinimumFontSize != size) {
        mMinimumFontSize = size;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the minimum font size.
 * @param size A non-negative integer between 1 and 72.
 * Any number outside the specified range will be pinned.
 */
","/**
 * Sets the minimum font size. The default is 8.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The entire implementation of the method has been changed; the statements are removed and replaced with a new 'throw' statement, so the code change type is 1,2.","The API in the late version will throw a new exception. Also, due to the removal of the earlier statements, the API will not return the value as per the previous version. Thereby resulting in different return values and exception handling. This leads to the CI type to be classified as 1,2."
68,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",15,16,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>","<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.synthesizeToFile(getPackageName(), text, filename, getParams(params));
        }
    }, ERROR, ""synthesizeToFile"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.synthesizeToFile(getCallerIdentity(), text, filename, getParams(params));
        }
    }, ERROR, ""synthesizeToFile"");
}",1,"/**
 * Synthesizes the given text to a file using the specified parameters.
 *
 * @param text The text that should be synthesized
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param filename Absolute file filename to write the generated audio data to.It should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Synthesizes the given text to a file using the specified parameters.
 *
 * @param text The text that should be synthesized
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param filename Absolute file filename to write the generated audio data to.It should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call inside the return statement is changed from getPackageName() to getCallerIdentity(), so the code change type is 1,5.","With the method call change within return statement, the API may potentially return different results. Therefore, the CI type is 1."
69,<android.view.View: ActionMode startActionMode(Callback)>,15,16,<android.view.View: ActionMode startActionMode(Callback)>,<android.view.View: ActionMode startActionMode(Callback)>,0,"{
    return getParent().startActionModeForChild(this, callback);
}","{
    ViewParent parent = getParent();
    if (parent == null)
        return null;
    return parent.startActionModeForChild(this, callback);
}",1,"/**
 * Start an action mode.
 *
 * @param callback Callback that will control the lifecycle of the action mode
 * @return The new action mode if it is started, null otherwise
 *
 * @see ActionMode
 */
","/**
 * Start an action mode.
 *
 * @param callback Callback that will control the lifecycle of the action mode
 * @return The new action mode if it is started, null otherwise
 *
 * @see ActionMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early implementation is directly returning the result of the `startActionModeForChild()` method, while in the later version, the parent object is first checked for null. If it is null, null is returned. Therefore, the return statement is changed, and there's a new control dependency introduced. The change types are both 1 and 3.","The introduction of null check for parent object could potentially lead the API to return null which was not possible in the early version. Therefore, the API could return a different value in the late version making the Compatibility Issues type to be 1."
70,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,15,16,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,0,"{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (mSelectingText) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if ((mMapTrackballToArrowKeys && (ev.getMetaState() & KeyEvent.META_SHIFT_ON) == 0) || AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time, ev.getMetaState());
    return true;
}","{
    return mProvider.getViewDelegate().onTrackballEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The whole implementation of the method has been changed. Instead of calling multiple function and control statements, it is simply calling a single method, hence the change type is 1,5 for return statement changed and dependent API changed.","Since the implementation of the method has been changed drastically, the behavior of the method might change depending upon the return from the newly called function. Thus, the CI type is 1, which means return values might be different between the two versions."
72,<android.app.ApplicationPackageManager: int getApplicationEnabledSetting(String)>,15,16,<android.app.ApplicationPackageManager: int getApplicationEnabledSetting(String)>,<android.app.ApplicationPackageManager: int getApplicationEnabledSetting(String)>,0,"{
    try {
        return mPM.getApplicationEnabledSetting(packageName);
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}","{
    try {
        return mPM.getApplicationEnabledSetting(packageName, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement's dependent API, mPM.getApplicationEnabledSetting(), has changed from one parameter to two parameters, so the code change type is 1,5.","The change in the parameters of the mPM.getApplicationEnabledSetting() method in the return statement may alter the return value of the method, potentially introducing compatibility issues. So, the CI type is 1."
73,"<android.view.GLES20Canvas: void drawTextOnPath(String,Path,float,float,Paint)>",15,16,"<android.view.GLES20Canvas: void drawTextOnPath(String,Path,float,float,Paint)>","<android.view.GLES20Canvas: void drawTextOnPath(String,Path,float,float,Paint)>",0,"{
// TODO: Implement
}","{
    if (text.length() == 0)
        return;
    int modifiers = setupModifiers(paint);
    try {
        nDrawTextOnPath(mRenderer, text, 0, text.length(), path.mNativePath, hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"Several new statements have been added including an 'if' statement and a 'try-finally' block, hence code change is classified as 1,3.","The addition of the 'if' statement which involves a return, could potentially lead to different results when invoking the same API. Thus, the Compatibility Issue is classified as 1."
74,<android.webkit.WebSettings: int getTextZoom()>,15,16,<android.webkit.WebSettings: int getTextZoom()>,<android.webkit.WebSettings: int getTextZoom()>,0,"{
    return mTextSize;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the text zoom of the page in percent.
 * @return A percent value describing the text zoom.
 * @see setTextSizeZoom
 */
","/**
 * Gets the text zoom of the page in percent.
 *
 * @return a percent value describing the text zoom
 * @see #setTextSizeZoom
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late version, the original return statement has been removed and replaced with a throw new MustOverrideException(), which classifies this code change as type 1 and type 2.","The late version of the code replaces the return statement with an exception, which means the behavior of the API has changed: instead of returning a value as it did in the early version, it now throws an exception. So this categorizes a Compatibility Issue (CI) as type 1 and type 2."
76,<android.widget.TextView: boolean performLongClick()>,15,16,<android.widget.TextView: boolean performLongClick()>,<android.widget.TextView: boolean performLongClick()>,0,"{
    boolean handled = false;
    boolean vibrate = true;
    if (super.performLongClick()) {
        mDiscardNextActionUp = true;
        handled = true;
    }
    // Long press in empty space moves cursor and shows the Paste affordance if available.
    if (!handled && !isPositionOnText(mLastDownPositionX, mLastDownPositionY) && mInsertionControllerEnabled) {
        final int offset = getOffsetForPosition(mLastDownPositionX, mLastDownPositionY);
        stopSelectionActionMode();
        Selection.setSelection((Spannable) mText, offset);
        getInsertionController().showWithActionPopup();
        handled = true;
        vibrate = false;
    }
    if (!handled && mSelectionActionMode != null) {
        if (touchPositionIsInSelection()) {
            // Start a drag
            final int start = getSelectionStart();
            final int end = getSelectionEnd();
            CharSequence selectedText = getTransformedText(start, end);
            ClipData data = ClipData.newPlainText(null, selectedText);
            DragLocalState localState = new DragLocalState(this, start, end);
            startDrag(data, getTextThumbnailBuilder(selectedText), localState, 0);
            stopSelectionActionMode();
        } else {
            getSelectionController().hide();
            selectCurrentWord();
            getSelectionController().show();
        }
        handled = true;
    }
    // Start a new selection
    if (!handled) {
        vibrate = handled = startSelectionActionMode();
    }
    if (vibrate) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    if (handled) {
        mDiscardNextActionUp = true;
    }
    return handled;
}","{
    boolean handled = false;
    if (super.performLongClick()) {
        handled = true;
    }
    if (mEditor != null) {
        handled |= mEditor.performLongClick(handled);
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        if (mEditor != null)
            mEditor.mDiscardNextActionUp = true;
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"There are new assignment operations added in the late implementation such as 'handled |= mEditor.performLongClick(handled);'. Also, the return type has changed as 'handled' variable now holds different settings. Therefore, the change type is '1,4' ;","Considering the logic of the implementations, return statement 'return handled;' can have a different outcome in the late implementation due to the new assignment operations. Therefore, the API could return different boolean values, indicating 'Compatibility Issue caused by potential different return values or types', which is type '1'."
78,<android.webkit.WebSettings: boolean getNavDump()>,15,16,<android.webkit.WebSettings: boolean getNavDump()>,<android.webkit.WebSettings: boolean getNavDump()>,0,"{
    return mNavDump;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if dumping the navigation cache is enabled.
 * @deprecated This method is now obsolete.
 */
","/**
 * Gets whether dumping the navigation cache is enabled.
 *
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2","1,2","In the later implementation, the return statement was replaced by an exception throw statement, leading to change classification 1,2.","The later version now throws an exception instead of returning a value, which completely changes the behavior of the method compared to the former version. Therefore, this creates a compatibility issue of both types 1 and 2."
80,<android.webkit.CookieManager: CookieManager getInstance()>,15,16,<android.webkit.CookieManager: CookieManager getInstance()>,<android.webkit.CookieManager: CookieManager getInstance()>,0,"{
    if (sRef == null) {
        sRef = new CookieManager();
    }
    return sRef;
}","{
    return WebViewFactory.getProvider().getCookieManager();
}",1,"/**
 * Get a singleton CookieManager. If this is called before any
 * {@link WebView} is created or outside of {@link WebView} context, the
 * caller needs to call {@link CookieSyncManager#createInstance(Context)}
 * first.
 *
 * @return CookieManager
 */
","/**
 * Gets the singleton CookieManager instance. If this method is used
 * before the application instantiates a {@link WebView} instance,
 * {@link CookieSyncManager#createInstance(Context)} must be called
 * first.
 *
 * @return the singleton CookieManager instance
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole method implementation has completely changed in the new version where now it is calling the getProvider() method of WebViewFactory, and then calling getCookieManager() on its resultant object to get an instance of CookieManager. Previous flow involving 'if' condition and instantiation of CookieManager is gone completely. So, the code changes include 'Return statement changed' and 'Dependent API changed'.","The change in the returned object from 'sRef' to 'WebViewFactory.getProvider().getCookieManager()' can lead to different behaviors (results) of the API in the newer version as compared to the old version, causing a compatibility issue due to potential different returned values. This is regarded as 'Compatibility Issue caused by potential different return values or types'."
81,<android.webkit.WebSettings: void setAppCacheMaxSize(long)>,15,16,<android.webkit.WebSettings: void setAppCacheMaxSize(long)>,<android.webkit.WebSettings: void setAppCacheMaxSize(long)>,0,"{
    if (appCacheMaxSize != mAppCacheMaxSize) {
        mAppCacheMaxSize = appCacheMaxSize;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the maximum size for the Application Caches content.
 * @param appCacheMaxSize the maximum size in bytes.
 */
","/**
 * Sets the maximum size for the Application Caches content.
 *
 * @param appCacheMaxSize the maximum size in bytes
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","The logic of checking and setting the app cache size has been completely replaced by an exception throw statement. Therefore, the code change type includes two classifications: the exception handling statement changed (2), and other statement changed (4).","The implementation in the late version will always throw an exception regardless of the input, differing from the behavior in the early version. Therefore, the changes will lead to different return values and exceptions. Thus the CI type is both potential different return values or types (1) and potential different exception handlings (2)."
82,<android.widget.TextView: boolean onTextContextMenuItem(int)>,15,16,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            // This does not enter text selection mode. Text is highlighted, so that it can be
            // bulk edited, like selectAllOnFocus does. Returns true even if text is empty.
            selectAll();
            return true;
        case ID_PASTE:
            paste(min, max);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            stopSelectionActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopSelectionActionMode();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            // This does not enter text selection mode. Text is highlighted, so that it can be
            // bulk edited, like selectAllOnFocus does. Returns true even if text is empty.
            selectAllText();
            return true;
        case ID_PASTE:
            paste(min, max);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            stopSelectionActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopSelectionActionMode();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy} or {@link android.R.id#paste}.
 *
 * @return true if the context menu item action was performed.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy} or {@link android.R.id#paste}.
 *
 * @return true if the context menu item action was performed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the case ID_SELECT_ALL has changed from selectAll() to selectAllText() in the switch block, and the dependent API selectAll() has been replaced by a new API selectAllText(). Thus the change type is 4,5.","The change from selectAll() to selectAllText() might change the behavior of the ID_SELECT_ALL case, and thus leads to potentially different return behavior, so the CI type is 1."
85,<android.widget.TextView: boolean didTouchFocusSelect()>,15,16,<android.widget.TextView: boolean didTouchFocusSelect()>,<android.widget.TextView: boolean didTouchFocusSelect()>,0,"{
    return mTouchFocusSelected;
}","{
    return mEditor != null && mEditor.mTouchFocusSelected;
}",1,"/**
 * Returns true, only while processing a touch gesture, if the initial
 * touch down event caused focus to move to the text view and as a result
 * its selection changed.  Only valid while processing the touch gesture
 * of interest.
 */
","/**
 * Returns true, only while processing a touch gesture, if the initial
 * touch down event caused focus to move to the text view and as a result
 * its selection changed.  Only valid while processing the touch gesture
 * of interest, in an editable text view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has been modified with a new condition 'mEditor != null', so the code changing types are 1 (return statement changed) and 3 (control dependency changed).","With the change in the return statement, it is possible that the API will return a different boolean value, causing potential compatibility issues. As such, the CI type is 1 (Compatibility Issue caused by potential different return values)."
89,"<android.view.GLES20Canvas: void drawRoundRect(RectF,float,float,Paint)>",15,16,"<android.view.GLES20Canvas: void drawRoundRect(RectF,float,float,Paint)>","<android.view.GLES20Canvas: void drawRoundRect(RectF,float,float,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    nDrawRoundRect(mRenderer, rect.left, rect.top, rect.right, rect.bottom, rx, ry, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawRoundRect(mRenderer, rect.left, rect.top, rect.right, rect.bottom, rx, ry, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,2",0,"A try-finally block with exception handling is introduced in the late version and arguments of the method setupModifiers() are changed. So the change type is 2,3.","The change on the try-finally block doesn't cause the method to throw an exception and the use of setupModifiers() method is internal (control flow) and doesn't impact the result of the API, so the CI type is 0."
90,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",15,16,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",0,"{
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    mNfcActivityManager.setNdefPushMessageCallback(activity, callback);
    for (Activity a : activities) {
        if (a == null) {
            throw new NullPointerException(""activities cannot contain null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(a, callback);
    }
}","{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(activity, callback);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessageCallback(a, callback);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set the callback to create a {@link NdefMessage} to push over NFC.
 *
 * <p>This method may be called at any time, but this callback is
 * only made if one of the specified activities
 * is in resumed (foreground) state.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set then
 * the callback will take priority.
 *
 * <p>Pass a null callback to disable the callback in the
 * specified activities.
 *
 * <p>At least one activity must be specified, and usually only one is necessary.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity an activity in which NDEF push should be enabled to share an NDEF message
 * that's retrieved from the provided callback
 * @param activities optional additional activities that should also enable NDEF push using
 * the provided callback
 */
","/**
 * Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code &lt;meta-data>} element inside the {@code &lt;application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessageCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The most notable changes involve the addition of the 'getSdkVersion()' method, and an additional try-catch block which has been implemented to handle an IllegalStateException. This represents Change Types 2 (Exception handling statement changed) and 3 (Control dependency change).","Changing how the system responds to IllegalStateExceptions between the two versions, as well as adding another layer of control in the updated version with the new try-catch block can potentially affect both the return value and exception handling of the late version API. This corresponds to Compatibility Issue types 1 and 2."
91,<android.animation.ValueAnimator: long getDuration()>,15,16,<android.animation.ValueAnimator: long getDuration()>,<android.animation.ValueAnimator: long getDuration()>,0,"{
    return mDuration;
}","{
    return mUnscaledDuration;
}",1,"/**
 * Gets the length of the animation. The default duration is 300 milliseconds.
 *
 * @return The length of the animation, in milliseconds.
 */
","/**
 * Gets the length of the animation. The default duration is 300 milliseconds.
 *
 * @return The length of the animation, in milliseconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning 'mDuration' to 'mUnscaledDuration', so the code change type is 1.","The change in the return statement can potentially cause the API to return a different value, so the CI type is 1."
93,<android.server.BluetoothAdapterStateMachine.Switching: boolean processMessage(Message)>,15,16,<android.server.BluetoothAdapterStateMachine.Switching: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.Switching: boolean processMessage(Message)>,0,"{
    log(""Switching process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SCAN_MODE_CHANGED:
            // This event matches mBluetoothService.switchConnectable action
            if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
                // set pairable if it's not
                mBluetoothService.setPairable();
                mBluetoothService.initBluetoothAfterTurningOn();
                transitionTo(mBluetoothOn);
                broadcastState(BluetoothAdapter.STATE_ON);
                // run bluetooth now that it's turned on
                // Note runBluetooth should be called only in adapter STATE_ON
                mBluetoothService.runBluetooth();
            }
            break;
        case POWER_STATE_CHANGED:
            removeMessages(POWER_DOWN_TIMEOUT);
            if (!((Boolean) message.obj)) {
                if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
                    transitionTo(mHotOff);
                    finishSwitchingOff();
                    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                        deferMessage(obtainMessage(TURN_COLD));
                    }
                }
            } else {
                if (mPublicState != BluetoothAdapter.STATE_TURNING_ON) {
                    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                        recoverStateMachine(TURN_HOT, null);
                    } else {
                        recoverStateMachine(TURN_COLD, null);
                    }
                }
            }
            break;
        case ALL_DEVICES_DISCONNECTED:
            removeMessages(DEVICES_DISCONNECT_TIMEOUT);
            mBluetoothService.switchConnectable(false);
            sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            break;
        case DEVICES_DISCONNECT_TIMEOUT:
            sendMessage(ALL_DEVICES_DISCONNECTED);
            // reset the hardware for error recovery
            Log.e(TAG, ""Devices failed to disconnect, reseting..."");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case POWER_DOWN_TIMEOUT:
            transitionTo(mHotOff);
            finishSwitchingOff();
            // reset the hardware for error recovery
            Log.e(TAG, ""Devices failed to power down, reseting..."");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case USER_TURN_ON:
        case AIRPLANE_MODE_OFF:
        case AIRPLANE_MODE_ON:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
        case USER_TURN_OFF:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""Switching process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SCAN_MODE_CHANGED:
            // This event matches mBluetoothService.switchConnectable action
            if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
                // set pairable if it's not
                mBluetoothService.setPairable();
                mBluetoothService.initBluetoothAfterTurningOn();
                transitionTo(mBluetoothOn);
                broadcastState(BluetoothAdapter.STATE_ON);
                // run bluetooth now that it's turned on
                // Note runBluetooth should be called only in adapter STATE_ON
                mBluetoothService.runBluetooth();
            }
            break;
        case POWER_STATE_CHANGED:
            removeMessages(TURN_OFF_TIMEOUT);
            if (!((Boolean) message.obj)) {
                if (mPublicState == BluetoothAdapter.STATE_TURNING_OFF) {
                    transitionTo(mHotOff);
                    mBluetoothService.finishDisable();
                    mBluetoothService.cleanupAfterFinishDisable();
                    deferMessage(obtainMessage(TURN_COLD));
                    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch) && !mBluetoothService.isAirplaneModeOn()) {
                        deferMessage(obtainMessage(TURN_HOT));
                        mDelayBroadcastStateOff = true;
                    }
                }
            } else {
                if (mPublicState != BluetoothAdapter.STATE_TURNING_ON) {
                    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                        recoverStateMachine(TURN_HOT, null);
                    } else {
                        recoverStateMachine(TURN_COLD, null);
                    }
                }
            }
            break;
        case ALL_DEVICES_DISCONNECTED:
            removeMessages(DEVICES_DISCONNECT_TIMEOUT);
            mBluetoothService.switchConnectable(false);
            sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
            break;
        case DEVICES_DISCONNECT_TIMEOUT:
            sendMessage(ALL_DEVICES_DISCONNECTED);
            // reset the hardware for error recovery
            Log.e(TAG, ""Devices failed to disconnect, reseting..."");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case TURN_OFF_TIMEOUT:
            transitionTo(mHotOff);
            finishSwitchingOff();
            // reset the hardware for error recovery
            Log.e(TAG, ""Devices failed to power down, reseting..."");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case USER_TURN_ON:
        case AIRPLANE_MODE_OFF:
        case AIRPLANE_MODE_ON:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
        case USER_TURN_OFF:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation of 'POWER_STATE_CHANGED' and 'ALL_DEVICES_DISCONNECTED' within the switch statement has been modified. The removed and introduced methods and variable assignments have also changed, which corresponds to a code change of type 3 and 4.","The changed statements under 'POWER_STATE_CHANGED' and 'ALL_DEVICES_DISCONNECTED' could potentially make the method return different behaviours, so a CI of type 1 is likely to exist."
94,<android.webkit.CookieManager: boolean hasCookies()>,15,16,<android.webkit.CookieManager: boolean hasCookies()>,<android.webkit.CookieManager: boolean hasCookies()>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        return hasCookies(false);
    }
    return CookieSyncManager.getInstance().hasCookies();
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return true if there are stored cookies.
 */
","/**
 * Gets whether there are stored cookies.
 *
 * @return true if there are stored cookies
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has completely changed from a complex reasoning to a direct exception throw, so the change type is 1,2.","The change of return statement and the new exception throw will make the API potentially return a different value or throw a different exception when the late version API is invoked, so the CI type is 1,2."
95,<android.view.View: boolean verifyDrawable(Drawable)>,15,16,<android.view.View: boolean verifyDrawable(Drawable)>,<android.view.View: boolean verifyDrawable(Drawable)>,0,"{
    return who == mBGDrawable;
}","{
    return who == mBackground;
}",1,"/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
","/**
 * If your view subclass is displaying its own Drawable objects, it should
 * override this function and return true for any Drawable it is
 * displaying.  This allows animations for those drawables to be
 * scheduled.
 *
 * <p>Be sure to call through to the super class when overriding this
 * function.
 *
 * @param who The Drawable to verify.  Return true if it is one you are
 * displaying, else return the result of calling through to the
 * super class.
 *
 * @return boolean If true than the Drawable is being displayed in the
 * view; else false and it is not allowed to animate.
 *
 * @see #unscheduleDrawable(android.graphics.drawable.Drawable)
 * @see #drawableStateChanged()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The variable in the return statement has changed from 'mBGDrawable' to 'mBackground', and it appears to be relying on a different variable now, so the code change is type 1,5.","The change in the return statement results in the potential return of a different boolean value, causing a compatibility issue. Therefore, the CI_type is 1."
98,<android.widget.TextView: boolean isSuggestionsEnabled()>,15,16,<android.widget.TextView: boolean isSuggestionsEnabled()>,<android.widget.TextView: boolean isSuggestionsEnabled()>,0,"{
    if ((mInputType & InputType.TYPE_MASK_CLASS) != InputType.TYPE_CLASS_TEXT)
        return false;
    if ((mInputType & InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS) > 0)
        return false;
    final int variation = mInputType & EditorInfo.TYPE_MASK_VARIATION;
    return (variation == EditorInfo.TYPE_TEXT_VARIATION_NORMAL || variation == EditorInfo.TYPE_TEXT_VARIATION_EMAIL_SUBJECT || variation == EditorInfo.TYPE_TEXT_VARIATION_LONG_MESSAGE || variation == EditorInfo.TYPE_TEXT_VARIATION_SHORT_MESSAGE || variation == EditorInfo.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT);
}","{
    if (mEditor == null)
        return false;
    if ((mEditor.mInputType & InputType.TYPE_MASK_CLASS) != InputType.TYPE_CLASS_TEXT) {
        return false;
    }
    if ((mEditor.mInputType & InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS) > 0)
        return false;
    final int variation = mEditor.mInputType & EditorInfo.TYPE_MASK_VARIATION;
    return (variation == EditorInfo.TYPE_TEXT_VARIATION_NORMAL || variation == EditorInfo.TYPE_TEXT_VARIATION_EMAIL_SUBJECT || variation == EditorInfo.TYPE_TEXT_VARIATION_LONG_MESSAGE || variation == EditorInfo.TYPE_TEXT_VARIATION_SHORT_MESSAGE || variation == EditorInfo.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT);
}",1,"/**
 * Return whether or not suggestions are enabled on this TextView. The suggestions are generated
 * by the IME or by the spell checker as the user types. This is done by adding
 * {@link SuggestionSpan}s to the text.
 *
 * When suggestions are enabled (default), this list of suggestions will be displayed when the
 * user asks for them on these parts of the text. This value depends on the inputType of this
 * TextView.
 *
 * The class of the input type must be {@link InputType#TYPE_CLASS_TEXT}.
 *
 * In addition, the type variation must be one of
 * {@link InputType#TYPE_TEXT_VARIATION_NORMAL},
 * {@link InputType#TYPE_TEXT_VARIATION_EMAIL_SUBJECT},
 * {@link InputType#TYPE_TEXT_VARIATION_LONG_MESSAGE},
 * {@link InputType#TYPE_TEXT_VARIATION_SHORT_MESSAGE} or
 * {@link InputType#TYPE_TEXT_VARIATION_WEB_EDIT_TEXT}.
 *
 * And finally, the {@link InputType#TYPE_TEXT_FLAG_NO_SUGGESTIONS} flag must <i>not</i> be set.
 *
 * @return true if the suggestions popup window is enabled, based on the inputType.
 */
","/**
 * Return whether or not suggestions are enabled on this TextView. The suggestions are generated
 * by the IME or by the spell checker as the user types. This is done by adding
 * {@link SuggestionSpan}s to the text.
 *
 * When suggestions are enabled (default), this list of suggestions will be displayed when the
 * user asks for them on these parts of the text. This value depends on the inputType of this
 * TextView.
 *
 * The class of the input type must be {@link InputType#TYPE_CLASS_TEXT}.
 *
 * In addition, the type variation must be one of
 * {@link InputType#TYPE_TEXT_VARIATION_NORMAL},
 * {@link InputType#TYPE_TEXT_VARIATION_EMAIL_SUBJECT},
 * {@link InputType#TYPE_TEXT_VARIATION_LONG_MESSAGE},
 * {@link InputType#TYPE_TEXT_VARIATION_SHORT_MESSAGE} or
 * {@link InputType#TYPE_TEXT_VARIATION_WEB_EDIT_TEXT}.
 *
 * And finally, the {@link InputType#TYPE_TEXT_FLAG_NO_SUGGESTIONS} flag must <i>not</i> be set.
 *
 * @return true if the suggestions popup window is enabled, based on the inputType.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The statements have changed to use 'mEditor.mInputType' instead of 'mInputType', also a new 'if' condition checking 'mEditor == null' has been introduced before the others. This means that the dependent API 'mInputType' has changed to 'mEditor.mInputType' and some new control dependency is added. The return statement may also vary under different conditions, thus the change types are 1,3,5.","As some new control dependency is added and the dependent API has changed, it could potentially lead to different return values in the late version. Hence, the CI type is 1."
99,<android.widget.TextView: void setEnabled(boolean)>,15,16,<android.widget.TextView: void setEnabled(boolean)>,<android.widget.TextView: void setEnabled(boolean)>,0,"{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
    prepareCursorControllers();
    if (enabled) {
        // Make sure IME is updated with current editor info.
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null)
            imm.restartInput(this);
    }
    // start or stop the cursor blinking as appropriate
    makeBlink();
}","{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
    if (enabled) {
        // Make sure IME is updated with current editor info.
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null)
            imm.restartInput(this);
    }
    // Will change text color
    if (mEditor != null) {
        mEditor.invalidateTextDisplayList();
        mEditor.prepareCursorControllers();
        // start or stop the cursor blinking as appropriate
        mEditor.makeBlink();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,3",1,"The method additions surrounding mEditor indicate that behavior has been moved to a different class. This qualifies the changes as falling within 'Other statement changed' (type 4). In addition, the condition 'if (mEditor != null)' has been added, which qualifies as a 'Control dependency change' (type 3).","The code now checks whether 'mEditor' is null and if not, it calls several functions on 'mEditor'. If 'mEditor' is in fact null, these calls will be skipped, causing the function to exhibit different behavior when compared to before. As such, this results in a 'Compatibility Issue caused by potential different return values or types' (type 1)."
100,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",15,16,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>","<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",0,"{
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    // TODO: Colors are ignored for now
    colors = null;
    colorOffset = 0;
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    // TODO: Colors are ignored for now
    colors = null;
    colorOffset = 0;
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"A new exception statement has been introduced at the beginning (throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");), and a 'try-finally' statement has been added to the block where 'nDrawBitmapMesh' is called, so the code change type is 2,3.","With the changes, a new exception IllegalArgumentException can be thrown when the bitmap is recycled, and the 'finally' block ensures the execution of 'nResetModifiers' even when an exception occurs. This different exception handling leads to the CI type 2."
104,<android.webkit.WebHistoryItem: Bitmap getFavicon()>,15,16,<android.webkit.WebHistoryItem: Bitmap getFavicon()>,<android.webkit.WebHistoryItem: Bitmap getFavicon()>,0,"{
    return mFavicon;
}","{
    if (mFavicon == null && mNativeBridge != 0) {
        mFavicon = nativeGetFavicon(mNativeBridge);
    }
    return mFavicon;
}",1,"/**
 * Return the favicon of this history item or null if no favicon was found.
 * @return A Bitmap containing the favicon for this history item or null.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */
","/**
 * Return the favicon of this history item or null if no favicon was found.
 * @return A Bitmap containing the favicon for this history item or null.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version introduces a new if statement and a new assignment statement within this if statement, so the code change type is 1,3.","Based on the new if statement, if mFavicon is null and mNativeBridge is not 0, the API would return the result of nativeGetFavicon(mNativeBridge) instead of null. Therefore, the late version of the API may return a different value from its early version, so the CI type is 1."
105,"<android.view.View: void postInvalidateDelayed(long,int,int,int,int)>",15,16,"<android.view.View: void postInvalidateDelayed(long,int,int,int,int)>","<android.view.View: void postInvalidateDelayed(long,int,int,int,int)>",0,"{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.acquire();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        final Message msg = Message.obtain();
        msg.what = AttachInfo.INVALIDATE_RECT_MSG;
        msg.obj = info;
        attachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds);
    }
}","{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.acquire();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
    }
}",1,"/**
 * <p>Cause an invalidate of the specified area to happen on a subsequent cycle
 * through the event loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 */
","/**
 * <p>Cause an invalidate of the specified area to happen on a subsequent cycle
 * through the event loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 *
 * @see #invalidate(int, int, int, int)
 * @see #invalidate(Rect)
 * @see #postInvalidate(int, int, int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation for the AttachInfo object has transformed from using a ""message"" to invoke 'sendMessageDelayed' to now calling 'dispatchInvalidateRectDelayed' directly, which qualifies as a change in the dependent API (type 5).","Despite the implementation changes, the overall result of the function remains the same: to delay an invalidation by a certain amount of time. Therefore, no compatibility issues (type 0) should be expected as the behavior of the function has not been affected, only the way it is achieved."
106,<android.webkit.WebView: Bitmap getFavicon()>,15,16,<android.webkit.WebView: Bitmap getFavicon()>,<android.webkit.WebView: Bitmap getFavicon()>,0,"{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getFavicon() : null;
}","{
    checkThread();
    return mProvider.getFavicon();
}",1,"/**
 * Get the favicon for the current page. This is the favicon of the current
 * page until WebViewClient.onReceivedIcon is called.
 * @return The favicon for the current page.
 */
","/**
 * Gets the favicon for the current page. This is the favicon of the current
 * page until WebViewClient.onReceivedIcon is called.
 *
 * @return the favicon for the current page
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The statement in return line has completely changed in the late version implementation. Also, the method from API mCallbackProxy.getBackForwardList().getCurrentItem() is changed to mProvider.getFavicon(). Thus, the code change type is 1,5.","Since the return statement is changed, this will potentially affect the returned value, leading to compatibility issues. Therefore, the CI type is 1."
107,"<android.webkit.WebIconDatabase: void requestIconForPageUrl(String,IconListener)>",15,16,"<android.webkit.WebIconDatabase: void requestIconForPageUrl(String,IconListener)>","<android.webkit.WebIconDatabase: void requestIconForPageUrl(String,IconListener)>",0,"{
    if (listener == null || url == null) {
        return;
    }
    Message msg = Message.obtain(null, EventHandler.REQUEST_ICON, listener);
    msg.getData().putString(""url"", url);
    mEventHandler.postMessage(msg);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Request the Bitmap representing the icon for the given page
 * url. If the icon exists, the listener will be called with the result.
 * @param url The page's url.
 * @param listener An implementation on IconListener to receive the result.
 */
","/**
 * Request the Bitmap representing the icon for the given page
 * url. If the icon exists, the listener will be called with the result.
 * @param url The page's url.
 * @param listener An implementation on IconListener to receive the result.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the revised code all of the early implementation is removed and replaced by throwing an exception. The code change type is 1,2, as both return and exception statements have changed.","This type of change potentially makes the API throw a different exception and no return value. Thus, the CI type is 1,2."
111,<android.view.InputDevice: InputDevice getDevice(int)>,15,16,<android.view.InputDevice: InputDevice getDevice(int)>,<android.view.InputDevice: InputDevice getDevice(int)>,0,"{
    IWindowManager wm = Display.getWindowManager();
    try {
        return wm.getInputDevice(id);
    } catch (RemoteException ex) {
        throw new RuntimeException(""Could not get input device information from Window Manager."", ex);
    }
}","{
    return InputManager.getInstance().getInputDevice(id);
}",1,"/**
 * Gets information about the input device with the specified id.
 * @param id The device id.
 * @return The input device or null if not found.
 */
","/**
 * Gets information about the input device with the specified id.
 * @param id The device id.
 * @return The input device or null if not found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,The implementation of the method was updated from executing operations on IWindowManager wm = Display.getWindowManager(); to directly using InputManager.getInstance().getInputDevice(id);,#CI_description
112,"<android.net.TrafficStats: void incrementOperationCount(int,int)>",15,16,"<android.net.TrafficStats: void incrementOperationCount(int,int)>","<android.net.TrafficStats: void incrementOperationCount(int,int)>",0,"{
    final INetworkStatsService statsService = INetworkStatsService.Stub.asInterface(ServiceManager.getService(Context.NETWORK_STATS_SERVICE));
    final int uid = android.os.Process.myUid();
    try {
        statsService.incrementOperationCount(uid, tag, operationCount);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    final int uid = android.os.Process.myUid();
    try {
        getStatsService().incrementOperationCount(uid, tag, operationCount);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}",1,"/**
 * Increment count of network operations performed under the given
 * accounting tag. This can be used to derive bytes-per-operation.
 *
 * @param tag Accounting tag used in {@link #setThreadStatsTag(int)}.
 * @param operationCount Number of operations to increment count by.
 */
","/**
 * Increment count of network operations performed under the given
 * accounting tag. This can be used to derive bytes-per-operation.
 *
 * @param tag Accounting tag used in {@link #setThreadStatsTag(int)}.
 * @param operationCount Number of operations to increment count by.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method of getting 'statsService' is different between the two versions. Also, the dependent API invocation INetworkStatsService.Stub.asInterface() has been removed in the late version. Therefore, the code change types are 4 and 5.","Despite the differences in the method of obtaining 'statsService', this change does not influence the output of the API. Hence, there is no Compatibility Issue (CI Type 0)."
113,<android.nfc.NfcActivityManager.NfcActivityState: String toString()>,15,16,<android.nfc.NfcActivityManager.NfcActivityState: String toString()>,<android.nfc.NfcActivityManager.NfcActivityState: String toString()>,0,"{
    StringBuilder s = new StringBuilder(""["").append(resumed).append("" "");
    s.append(ndefMessage).append("" "").append(ndefMessageCallback).append("" "");
    s.append(onNdefPushCompleteCallback).append(""]"");
    return s.toString();
}","{
    StringBuilder s = new StringBuilder(""["").append("" "");
    s.append(ndefMessage).append("" "").append(ndefMessageCallback).append("" "");
    s.append(uriCallback).append("" "");
    if (uris != null) {
        for (Uri uri : uris) {
            s.append(onNdefPushCompleteCallback).append("" "").append(uri).append(""]"");
        }
    }
    return s.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The returned String value modification is evident due to changes in the StringBuilder's parameters. Adding a new for-loop to the StringBuilder is a form of control change. The dependent API has changed from 'onNdefPushCompleteCallback' to 'uriCallback', and the newly added 'uri' is included in the return string, so the change type is 1,3,5.","The returned String is different between the two versions because of a could change in 'uriCallback' and 'uri', causing a potential compatibility issue, thus the CI type is 1."
114,"<android.app.ApplicationPackageManager: ProviderInfo getProviderInfo(ComponentName,int)>",15,16,"<android.app.ApplicationPackageManager: ProviderInfo getProviderInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ProviderInfo getProviderInfo(ComponentName,int)>",0,"{
    try {
        ProviderInfo pi = mPM.getProviderInfo(className, flags);
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ProviderInfo pi = mPM.getProviderInfo(className, flags, UserId.myUserId());
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mPM.getProviderInfo(className, flags) to mPM.getProviderInfo(className, flags, UserId.myUserId()), the parameter list of getProviderInfo() changed which means the dependent API changed, so the change type is 1,5.","The change of return statement will make the API potentially return a different value, therefore the CI type is 1."
116,<android.app.ActivityManager: int getLauncherLargeIconDensity()>,15,16,<android.app.ActivityManager: int getLauncherLargeIconDensity()>,<android.app.ActivityManager: int getLauncherLargeIconDensity()>,0,"{
    final Resources res = mContext.getResources();
    final int density = res.getDisplayMetrics().densityDpi;
    if ((res.getConfiguration().screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) != Configuration.SCREENLAYOUT_SIZE_XLARGE) {
        return density;
    }
    switch(density) {
        case DisplayMetrics.DENSITY_LOW:
            return DisplayMetrics.DENSITY_MEDIUM;
        case DisplayMetrics.DENSITY_MEDIUM:
            return DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_HIGH:
            return DisplayMetrics.DENSITY_XHIGH;
        case DisplayMetrics.DENSITY_XHIGH:
            return DisplayMetrics.DENSITY_MEDIUM * 2;
        default:
            return density;
    }
}","{
    final Resources res = mContext.getResources();
    final int density = res.getDisplayMetrics().densityDpi;
    final int sw = res.getConfiguration().smallestScreenWidthDp;
    if (sw < 600) {
        // Smaller than approx 7"" tablets, use the regular icon size.
        return density;
    }
    switch(density) {
        case DisplayMetrics.DENSITY_LOW:
            return DisplayMetrics.DENSITY_MEDIUM;
        case DisplayMetrics.DENSITY_MEDIUM:
            return DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_TV:
            return DisplayMetrics.DENSITY_XHIGH;
        case DisplayMetrics.DENSITY_HIGH:
            return DisplayMetrics.DENSITY_XHIGH;
        case DisplayMetrics.DENSITY_XHIGH:
            return DisplayMetrics.DENSITY_XXHIGH;
        case DisplayMetrics.DENSITY_XXHIGH:
            return DisplayMetrics.DENSITY_XHIGH * 2;
        default:
            // abnormal value that is a reasonable scaling of it.
            return (int) ((density * 1.5f) + .5f);
    }
}",1,"/**
 * Get the preferred density of icons for the launcher. This is used when
 * custom drawables are created (e.g., for shortcuts).
 *
 * @return density in terms of DPI
 */
","/**
 * Get the preferred density of icons for the launcher. This is used when
 * custom drawables are created (e.g., for shortcuts).
 *
 * @return density in terms of DPI
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The condition statement under 'if' and 'switch' cases have changed and the new arithmetic operation '+.5' has been introduced in the return statement of the 'default' case in the late version, so the code change type is 1,3,4.","As the condition under 'if' and 'switch' statements has changed and new arithmetic operation '+.5' has been introduced in return statement, the returned value can potentially be different in the late version. Hence, the CI type is 1."
117,<android.widget.AbsListView.PositionScroller: void start(int)>,15,16,<android.widget.AbsListView.PositionScroller: void start(int)>,<android.widget.AbsListView.PositionScroller: void start(int)>,0,"{
    stop();
    final int firstPos = mFirstPosition;
    final int lastPos = firstPos + getChildCount() - 1;
    int viewTravelCount;
    if (position <= firstPos) {
        viewTravelCount = firstPos - position + 1;
        mMode = MOVE_UP_POS;
    } else if (position >= lastPos) {
        viewTravelCount = position - lastPos + 1;
        mMode = MOVE_DOWN_POS;
    } else {
        // Already on screen, nothing to do
        return;
    }
    if (viewTravelCount > 0) {
        mScrollDuration = SCROLL_DURATION / viewTravelCount;
    } else {
        mScrollDuration = SCROLL_DURATION;
    }
    mTargetPos = position;
    mBoundPos = INVALID_POSITION;
    mLastSeenPos = INVALID_POSITION;
    post(this);
}","{
    stop();
    if (mDataChanged) {
        // Wait until we're back in a stable state to try this.
        mPositionScrollAfterLayout = new Runnable() {

            @Override
            public void run() {
                start(position);
            }
        };
        return;
    }
    final int childCount = getChildCount();
    if (childCount == 0) {
        // Can't scroll without children.
        return;
    }
    final int firstPos = mFirstPosition;
    final int lastPos = firstPos + childCount - 1;
    int viewTravelCount;
    int clampedPosition = Math.max(0, Math.min(getCount() - 1, position));
    if (clampedPosition < firstPos) {
        viewTravelCount = firstPos - clampedPosition + 1;
        mMode = MOVE_UP_POS;
    } else if (clampedPosition > lastPos) {
        viewTravelCount = clampedPosition - lastPos + 1;
        mMode = MOVE_DOWN_POS;
    } else {
        scrollToVisible(clampedPosition, INVALID_POSITION, SCROLL_DURATION);
        return;
    }
    if (viewTravelCount > 0) {
        mScrollDuration = SCROLL_DURATION / viewTravelCount;
    } else {
        mScrollDuration = SCROLL_DURATION;
    }
    mTargetPos = clampedPosition;
    mBoundPos = INVALID_POSITION;
    mLastSeenPos = INVALID_POSITION;
    postOnAnimation(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The conditions (mDataChanged and childCount==0), the variables (clampedPosition), an introduce of a new method postOnAnimation(this) replacing the old post(this), as well as the different variables of the method scrollToVisible() have been introduced in the late version. Therefore, the code change types are 1, 3, and 4.","The new conditions (mDataChanged and childCount ==0) and variables can potientially change the return values, leading to a different behaviour of the API. Therefore, the CI type is 1."
119,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivityOptions(ComponentName,Intent[],Intent,int)>",15,16,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivityOptions(ComponentName,Intent[],Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivityOptions(ComponentName,Intent[],Intent,int)>",0,"{
    final ContentResolver resolver = mContext.getContentResolver();
    String[] specificTypes = null;
    if (specifics != null) {
        final int N = specifics.length;
        for (int i = 0; i < N; i++) {
            Intent sp = specifics[i];
            if (sp != null) {
                String t = sp.resolveTypeIfNeeded(resolver);
                if (t != null) {
                    if (specificTypes == null) {
                        specificTypes = new String[N];
                    }
                    specificTypes[i] = t;
                }
            }
        }
    }
    try {
        return mPM.queryIntentActivityOptions(caller, specifics, specificTypes, intent, intent.resolveTypeIfNeeded(resolver), flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    final ContentResolver resolver = mContext.getContentResolver();
    String[] specificTypes = null;
    if (specifics != null) {
        final int N = specifics.length;
        for (int i = 0; i < N; i++) {
            Intent sp = specifics[i];
            if (sp != null) {
                String t = sp.resolveTypeIfNeeded(resolver);
                if (t != null) {
                    if (specificTypes == null) {
                        specificTypes = new String[N];
                    }
                    specificTypes[i] = t;
                }
            }
        }
    }
    try {
        return mPM.queryIntentActivityOptions(caller, specifics, specificTypes, intent, intent.resolveTypeIfNeeded(resolver), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameters of the mPM.queryIntentActivityOptions() function have changed - a new parameter UserId.myUserId() is added in the late version, so the code change types are 1 and 5.","The new parameter(UserId.myUserId()) added in the function mPM.queryIntentActivityOptions() can cause different return value of the function, hence causing an API behavior change. Thus the Compatibility Issue type is 1."
120,<android.webkit.WebSettings: void setLayoutAlgorithm(LayoutAlgorithm)>,15,16,<android.webkit.WebSettings: void setLayoutAlgorithm(LayoutAlgorithm)>,<android.webkit.WebSettings: void setLayoutAlgorithm(LayoutAlgorithm)>,0,"{
    // ANDROID_LAYOUT defined.
    if (mLayoutAlgorithm != l) {
        mLayoutAlgorithm = l;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the underlying layout algorithm. This will cause a relayout of the
 * WebView.
 * @param l A LayoutAlgorithm enum specifying the algorithm to use.
 * @see WebSettings.LayoutAlgorithm
 */
","/**
 * Sets the underlying layout algorithm. This will cause a relayout of the
 * WebView. The default is NARROW_COLUMNS.
 *
 * @param l a LayoutAlgorithm enum specifying the algorithm to use
 * @see WebSettings.LayoutAlgorithm
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early implementation's logic has been totally replaced with a throw statement in the late version, so the code change type is 1,2.","The late version implementation introduces a new exception (MustOverrideException), which can lead to different behavior when the API is called compared to the early version. Also, the API does not return the same variables as the early version anymore. Hence, the CI type is 1,2."
121,"<android.app.ApplicationPackageManager: PackageInfo getPackageInfo(String,int)>",15,16,"<android.app.ApplicationPackageManager: PackageInfo getPackageInfo(String,int)>","<android.app.ApplicationPackageManager: PackageInfo getPackageInfo(String,int)>",0,"{
    try {
        PackageInfo pi = mPM.getPackageInfo(packageName, flags);
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}","{
    try {
        PackageInfo pi = mPM.getPackageInfo(packageName, flags, UserId.myUserId());
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API method mPM.getPackageInfo() signature has changed because it now includes another parameter, UserId.myUserId(). Consequently, the return statement which returns the mPM.getPackageInfo() result is also affected so the code change type is 1,5.","The method mPM.getPackageInfo() has added a new parameter in the late version. As a result of this change, the output value generated by this method may differ between the early and late versions. Therefore, the API could potentially return different values which leads to Compatibility Issue type 1."
122,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",15,16,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>","<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",0,"{
    return mContentProvider.openTypedAssetFile(uri, mimeType, opts);
}","{
    try {
        return mContentProvider.openTypedAssetFile(uri, mimeType, opts);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
","/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new control statement (try/catch) has been added and exception handling statement is also introduced, so the code change type is 2,3.","The new exception handling block may throw a `DeadObjectException` differently, which could change the behavior of the API. This could potentially cause compatibility issues. Thus, the CI type is class 2."
123,<android.widget.AbsListView: void handleDataChanged()>,15,16,<android.widget.AbsListView: void handleDataChanged()>,<android.widget.AbsListView: void handleDataChanged()>,0,"{
    int count = mItemCount;
    int lastHandledItemCount = mLastHandledItemCount;
    mLastHandledItemCount = mItemCount;
    if (mChoiceMode != CHOICE_MODE_NONE && mAdapter != null && mAdapter.hasStableIds()) {
        confirmCheckedPositionsById();
    }
    if (count > 0) {
        int newPos;
        int selectablePos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects it
            mNeedSync = false;
            if (mTranscriptMode == TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                return;
            } else if (mTranscriptMode == TRANSCRIPT_MODE_NORMAL) {
                if (mForceTranscriptScroll) {
                    mForceTranscriptScroll = false;
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                final int childCount = getChildCount();
                final int listBottom = getHeight() - getPaddingBottom();
                final View lastChild = getChildAt(childCount - 1);
                final int lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                if (mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                // Something new came in and we didn't scroll; give the user a clue that
                // there's something new.
                awakenScrollBars();
            }
            switch(mSyncMode) {
                case SYNC_SELECTED_POSITION:
                    if (isInTouchMode()) {
                        // We saved our state when not in touch mode. (We know this because
                        // mSyncMode is SYNC_SELECTED_POSITION.) Now we are trying to
                        // restore in touch mode. Just leave mSyncPosition as it is (possibly
                        // adjusting if the available range changed) and return.
                        mLayoutMode = LAYOUT_SYNC;
                        mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                        return;
                    } else {
                        // See if we can find a position in the new data with the same
                        // id as the old selection. This will change mSyncPosition.
                        newPos = findSyncPosition();
                        if (newPos >= 0) {
                            // Found it. Now verify that new selection is still selectable
                            selectablePos = lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                // Same row id is selected
                                mSyncPosition = newPos;
                                if (mSyncHeight == getHeight()) {
                                    // If we are at the same height as when we saved state, try
                                    // to restore the scroll position too.
                                    mLayoutMode = LAYOUT_SYNC;
                                } else {
                                    // We are not the same height as when the selection was saved, so
                                    // don't try to restore the exact position
                                    mLayoutMode = LAYOUT_SET_SELECTION;
                                }
                                // Restore selection
                                setNextSelectedPositionInt(newPos);
                                return;
                            }
                        }
                    }
                    break;
                case SYNC_FIRST_POSITION:
                    // Leave mSyncPosition as it is -- just pin to available range
                    mLayoutMode = LAYOUT_SYNC;
                    mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                    return;
            }
        }
        if (!isInTouchMode()) {
            // We couldn't find matching data -- try to use the same position
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                return;
            } else {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
                if (selectablePos >= 0) {
                    setNextSelectedPositionInt(selectablePos);
                    return;
                }
            }
        } else {
            // We already know where we want to resurrect the selection
            if (mResurrectToPosition >= 0) {
                return;
            }
        }
    }
    // Nothing is selected. Give up and reset everything.
    mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP;
    mSelectedPosition = INVALID_POSITION;
    mSelectedRowId = INVALID_ROW_ID;
    mNextSelectedPosition = INVALID_POSITION;
    mNextSelectedRowId = INVALID_ROW_ID;
    mNeedSync = false;
    mSelectorPosition = INVALID_POSITION;
    checkSelectionChanged();
}","{
    int count = mItemCount;
    int lastHandledItemCount = mLastHandledItemCount;
    mLastHandledItemCount = mItemCount;
    if (mChoiceMode != CHOICE_MODE_NONE && mAdapter != null && mAdapter.hasStableIds()) {
        confirmCheckedPositionsById();
    }
    // TODO: In the future we can recycle these views based on stable ID instead.
    mRecycler.clearTransientStateViews();
    if (count > 0) {
        int newPos;
        int selectablePos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects it
            mNeedSync = false;
            if (mTranscriptMode == TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                return;
            } else if (mTranscriptMode == TRANSCRIPT_MODE_NORMAL) {
                if (mForceTranscriptScroll) {
                    mForceTranscriptScroll = false;
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                final int childCount = getChildCount();
                final int listBottom = getHeight() - getPaddingBottom();
                final View lastChild = getChildAt(childCount - 1);
                final int lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                if (mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                // Something new came in and we didn't scroll; give the user a clue that
                // there's something new.
                awakenScrollBars();
            }
            switch(mSyncMode) {
                case SYNC_SELECTED_POSITION:
                    if (isInTouchMode()) {
                        // We saved our state when not in touch mode. (We know this because
                        // mSyncMode is SYNC_SELECTED_POSITION.) Now we are trying to
                        // restore in touch mode. Just leave mSyncPosition as it is (possibly
                        // adjusting if the available range changed) and return.
                        mLayoutMode = LAYOUT_SYNC;
                        mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                        return;
                    } else {
                        // See if we can find a position in the new data with the same
                        // id as the old selection. This will change mSyncPosition.
                        newPos = findSyncPosition();
                        if (newPos >= 0) {
                            // Found it. Now verify that new selection is still selectable
                            selectablePos = lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                // Same row id is selected
                                mSyncPosition = newPos;
                                if (mSyncHeight == getHeight()) {
                                    // If we are at the same height as when we saved state, try
                                    // to restore the scroll position too.
                                    mLayoutMode = LAYOUT_SYNC;
                                } else {
                                    // We are not the same height as when the selection was saved, so
                                    // don't try to restore the exact position
                                    mLayoutMode = LAYOUT_SET_SELECTION;
                                }
                                // Restore selection
                                setNextSelectedPositionInt(newPos);
                                return;
                            }
                        }
                    }
                    break;
                case SYNC_FIRST_POSITION:
                    // Leave mSyncPosition as it is -- just pin to available range
                    mLayoutMode = LAYOUT_SYNC;
                    mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                    return;
            }
        }
        if (!isInTouchMode()) {
            // We couldn't find matching data -- try to use the same position
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                return;
            } else {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
                if (selectablePos >= 0) {
                    setNextSelectedPositionInt(selectablePos);
                    return;
                }
            }
        } else {
            // We already know where we want to resurrect the selection
            if (mResurrectToPosition >= 0) {
                return;
            }
        }
    }
    // Nothing is selected. Give up and reset everything.
    mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP;
    mSelectedPosition = INVALID_POSITION;
    mSelectedRowId = INVALID_ROW_ID;
    mNextSelectedPosition = INVALID_POSITION;
    mNextSelectedRowId = INVALID_ROW_ID;
    mNeedSync = false;
    mSelectorPosition = INVALID_POSITION;
    checkSelectionChanged();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only difference between the early and late implementation is the addition of a new line, mRecycler.clearTransientStateViews(), in the late implementation, which is classified as type 4-Other statement changed.","The added new line does not introduce any potential compatibility issues, as it does not affect return values or potential exception handling, so it is safe to say that no CI exist here."
124,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,15,16,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,0,"{
    if (mFirstDayOfWeek == firstDayOfWeek) {
        return;
    }
    mFirstDayOfWeek = firstDayOfWeek;
    mAdapter.init();
    mAdapter.notifyDataSetChanged();
    setUpHeader(DEFAULT_WEEK_DAY_TEXT_APPEARANCE_RES_ID);
}","{
    if (mFirstDayOfWeek == firstDayOfWeek) {
        return;
    }
    mFirstDayOfWeek = firstDayOfWeek;
    mAdapter.init();
    mAdapter.notifyDataSetChanged();
    setUpHeader();
}",1,"/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 */
","/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call to setUpHeader has been altered from setUpHeader(DEFAULT_WEEK_DAY_TEXT_APPEARANCE_RES_ID) to setUpHeader() in the late implementation. Therefore, this falls into the category 4 - 'Other statement changed'.","Despite the change in the setUpHeader method call, it doesn't alter what the 'setFirstDayOfWeek' API returns (which is nothing, as this is a void method) and there's no change in exception handling. Hence, no Compatibility Issue exists, indicating a type 0 CI."
125,<android.widget.SimpleCursorAdapter: Cursor swapCursor(Cursor)>,15,16,<android.widget.SimpleCursorAdapter: Cursor swapCursor(Cursor)>,<android.widget.SimpleCursorAdapter: Cursor swapCursor(Cursor)>,0,"{
    // happens
    if (mFrom == null) {
        findColumns(mOriginalFrom);
    }
    Cursor res = super.swapCursor(c);
    // rescan columns in case cursor layout is different
    findColumns(mOriginalFrom);
    return res;
}","{
    // super.swapCursor() will notify observers before we have
    // a valid mapping, make sure we have a mapping before this
    // happens
    findColumns(c, mOriginalFrom);
    return super.swapCursor(c);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been rearranged, a local variable assignment (Cursor res = super.swapCursor(c)) has been removed, the method findColumns is called with different parameters, and the super.swapCursor(c) is invoked at a different order, so the code change type is 1,4,5.","The change in return statement order and the removal of local variable assignment might lead the API to return a different value, so the CI type is 1."
126,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",15,16,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",0,"{
    if (listener == null || sensor == null) {
        return false;
    }
    boolean result = true;
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20000;
            break;
        case SENSOR_DELAY_UI:
            delay = 66667;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200000;
            break;
        default:
            delay = rate;
            break;
    }
    synchronized (sListeners) {
        // look for this listener in our list
        ListenerDelegate l = null;
        for (ListenerDelegate i : sListeners) {
            if (i.getListener() == listener) {
                l = i;
                break;
            }
        }
        // if we don't find it, add it to the list
        if (l == null) {
            l = new ListenerDelegate(listener, sensor, handler);
            sListeners.add(l);
            // if the list is not empty, start our main thread
            if (!sListeners.isEmpty()) {
                if (sSensorThread.startLocked()) {
                    if (!enableSensorLocked(sensor, delay)) {
                        // oops. there was an error
                        sListeners.remove(l);
                        result = false;
                    }
                } else {
                    // there was an error, remove the listener
                    sListeners.remove(l);
                    result = false;
                }
            } else {
                // weird, we couldn't add the listener
                result = false;
            }
        } else {
            l.addSensor(sensor);
            if (!enableSensorLocked(sensor, delay)) {
                // oops. there was an error
                l.removeSensor(sensor);
                result = false;
            }
        }
    }
    return result;
}","{
    if (listener == null || sensor == null) {
        return false;
    }
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20000;
            break;
        case SENSOR_DELAY_UI:
            delay = 66667;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200000;
            break;
        default:
            delay = rate;
            break;
    }
    return registerListenerImpl(listener, sensor, delay, handler);
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rate
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microsecond.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rate
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microsecond.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The function implementation has been refactored and a new method 'registerListenerImpl()' is called in the return statement. The 'boolean result' and synchronized block statements are deleted in the late version. So the change type is 1,4.","The return statement involves a new method call and the control flow has been changed, this could result in a different return value. Thus the Compatibility Issue type is 1."
127,<android.nfc.NdefRecord: byte[] toByteArray()>,15,16,<android.nfc.NdefRecord: byte[] toByteArray()>,<android.nfc.NdefRecord: byte[] toByteArray()>,0,"{
    return generate(mFlags, mTnf, mType, mId, mPayload);
}","{
    ByteBuffer buffer = ByteBuffer.allocate(getByteLength());
    writeToByteBuffer(buffer, true, true);
    return buffer.array();
}",1,"/**
 * Returns this entire NDEF Record as a byte array.
 */
","/**
 * Return this NDEF Record as a byte array.<p>
 * This method is deprecated, use {@link NdefMessage#toByteArray}
 * instead. This is because the NDEF binary format is not defined for
 * a record outside of the context of a message: the MB and ME flags
 * cannot be set without knowing the location inside a message.<p>
 * This implementation will attempt to serialize a single record by
 * always setting the MB and ME flags (in other words, assume this
 * is a single-record NDEF Message).<p>
 *
 * @deprecated use {@link NdefMessage#toByteArray()} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed, and the implementation of how the byte array is generated and returned has also changed. Therefore, the change types are 1 and 4.","Because of the change in the return statement, the API could potentially return a different byte array than in the early version. Thus, the CI type is 1."
128,<android.webkit.WebView: int computeHorizontalScrollOffset()>,15,16,<android.webkit.WebView: int computeHorizontalScrollOffset()>,<android.webkit.WebView: int computeHorizontalScrollOffset()>,0,"{
    return Math.max(mScrollX, 0);
}","{
    return mProvider.getScrollDelegate().computeHorizontalScrollOffset();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning maximum value between 'mScrollX' and '0' in early version to calling a method on an object in provider in the late version. Also, this signifies a change in the dependent API which eventually alters the return value. Hence, the code change type is 1,5.","The change of return statement means that the API will potentially return a different value. In the early version, it returned the maximum value between 'mScrollX' and '0', while in the late version it returned a value after calling a method on an object in provider. Hence, the Compatibility Issue type is 1."
129,<android.app.ActivityThread.H: String codeToString(int)>,15,16,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
        }
    }
    return ""(unknown)"";
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Two switch cases have been added in the late version, and the default return statement has been changed from ""(unknown)"" - a String value to ""Integer.toString(code)"" - the representation of an Integer value in the String type, so the code change type is 1,3.",The return value of the function varies because newly added cases and a new default statement which will potentially return differently when the input 'code' is not in the case list; hence the CI type is 1.
131,<android.view.View: void setBackgroundResource(int)>,15,16,<android.view.View: void setBackgroundResource(int)>,<android.view.View: void setBackgroundResource(int)>,0,"{
    if (resid != 0 && resid == mBackgroundResource) {
        return;
    }
    Drawable d = null;
    if (resid != 0) {
        d = mResources.getDrawable(resid);
    }
    setBackgroundDrawable(d);
    mBackgroundResource = resid;
}","{
    if (resid != 0 && resid == mBackgroundResource) {
        return;
    }
    Drawable d = null;
    if (resid != 0) {
        d = mResources.getDrawable(resid);
    }
    setBackground(d);
    mBackgroundResource = resid;
}",1,"/**
 * Set the background to a given resource. The resource should refer to
 * a Drawable object or 0 to remove the background.
 * @param resid The identifier of the resource.
 * @attr ref android.R.styleable#View_background
 */
","/**
 * Set the background to a given resource. The resource should refer to
 * a Drawable object or 0 to remove the background.
 * @param resid The identifier of the resource.
 *
 * @attr ref android.R.styleable#View_background
 */
",-1,[@RemotableViewMethod],[@RemotableViewMethod],-1,-1,-1,-1,-1,-1,"1,5",0,"The API for setting the background drawable has been changed from setBackgroundDrawable(d) to setBackground(d), therefore the compatibility changes are categorized into 1 and 5.","There is no compatibility issue since these two methods perform the same functionality, the return value and exception handling do not change in both versions."
132,<android.hardware.SensorManager: int getSensors()>,15,16,<android.hardware.SensorManager: int getSensors()>,<android.hardware.SensorManager: int getSensors()>,0,"{
    int result = 0;
    final ArrayList<Sensor> fullList = sFullSensorsList;
    for (Sensor i : fullList) {
        switch(i.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
                result |= SensorManager.SENSOR_ACCELEROMETER;
                break;
            case Sensor.TYPE_MAGNETIC_FIELD:
                result |= SensorManager.SENSOR_MAGNETIC_FIELD;
                break;
            case Sensor.TYPE_ORIENTATION:
                result |= SensorManager.SENSOR_ORIENTATION | SensorManager.SENSOR_ORIENTATION_RAW;
                break;
        }
    }
    return result;
}","{
    return getLegacySensorManager().getSensors();
}",1,"/**
 * @return available sensors.
 * @deprecated This method is deprecated, use
 * {@link SensorManager#getSensorList(int)} instead
 */
","/**
 * @return available sensors.
 * @deprecated This method is deprecated, use
 * {@link SensorManager#getSensorList(int)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1, 3, 4, 5",1,"The method has been significantly changed. The way to get 'result' is totally different between two versions. They removed entire for loop and replaced it with a single line. Therefore, the code change type is Return statement changed (1), Control dependency changed (3), Other statement changed (4) and Dependent API changed (5).","The return statement has been changed and since there's a change in the definition of result it can potentially return a different value in the later version, therefore a possible compatibility issue exists. CI type is return value has changed (1)."
133,<android.content.Intent: String toString()>,15,16,<android.content.Intent: String toString()>,<android.content.Intent: String toString()>,0,"{
    StringBuilder b = new StringBuilder(128);
    b.append(""Intent { "");
    toShortString(b, true, true, true);
    b.append("" }"");
    return b.toString();
}","{
    StringBuilder b = new StringBuilder(128);
    b.append(""Intent { "");
    toShortString(b, true, true, true, false);
    b.append("" }"");
    return b.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4, 5",1,"A parameter has been added to the toShortString() method, so the code change types are 4 and 5.","With the addition of the new parameter to the toShortString() method, the output string could potentially differ from the original implementation, leading to a compatibility issue of type 1."
134,<android.widget.ExpandableListConnector: boolean expandGroup(int)>,15,16,<android.widget.ExpandableListConnector: boolean expandGroup(int)>,<android.widget.ExpandableListConnector: boolean expandGroup(int)>,0,"{
    PositionMetadata pm = getFlattenedPos(ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1));
    boolean retValue = expandGroup(pm);
    pm.recycle();
    return retValue;
}","{
    ExpandableListPosition elGroupPos = ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1);
    PositionMetadata pm = getFlattenedPos(elGroupPos);
    elGroupPos.recycle();
    boolean retValue = expandGroup(pm);
    pm.recycle();
    return retValue;
}",1,"/**
 * Expand a group in the grouped list view
 * @param groupPos the group to be expanded
 */
","/**
 * Expand a group in the grouped list view
 * @param groupPos the group to be expanded
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method of obtaining 'ExpandableListPosition' instance and the method of releasing it have changed, indicating a change in the return statement and the dependent API. Therefore, the code change type is 1,5.","Since no exception is thrown and the final return statement is the same in both versions, the function behavior remains consistent. Therefore, there's no compatibility issue, and the CI type is 0."
135,<android.webkit.WebViewCore.WebCoreThread: void run()>,15,16,<android.webkit.WebViewCore.WebCoreThread: void run()>,<android.webkit.WebViewCore.WebCoreThread: void run()>,0,"{
    Looper.prepare();
    Assert.assertNull(sWebCoreHandler);
    synchronized (WebViewCore.class) {
        sWebCoreHandler = new Handler() {

            @Override
            public void handleMessage(Message msg) {
                switch(msg.what) {
                    case INITIALIZE:
                        WebViewCore core = (WebViewCore) msg.obj;
                        core.initialize();
                        break;
                    case REDUCE_PRIORITY:
                        // 3 is an adjustable number.
                        Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT + 3 * Process.THREAD_PRIORITY_LESS_FAVORABLE);
                        break;
                    case RESUME_PRIORITY:
                        Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                        break;
                    case EventHub.ADD_PACKAGE_NAME:
                        if (BrowserFrame.sJavaBridge == null) {
                            throw new IllegalStateException(""No WebView has been created in this process!"");
                        }
                        BrowserFrame.sJavaBridge.addPackageName((String) msg.obj);
                        break;
                    case EventHub.REMOVE_PACKAGE_NAME:
                        if (BrowserFrame.sJavaBridge == null) {
                            throw new IllegalStateException(""No WebView has been created in this process!"");
                        }
                        BrowserFrame.sJavaBridge.removePackageName((String) msg.obj);
                        break;
                    case EventHub.PROXY_CHANGED:
                        if (BrowserFrame.sJavaBridge == null) {
                            throw new IllegalStateException(""No WebView has been created in this process!"");
                        }
                        BrowserFrame.sJavaBridge.updateProxy((ProxyProperties) msg.obj);
                        break;
                }
            }
        };
        WebViewCore.class.notify();
    }
    Looper.loop();
}","{
    Looper.prepare();
    Assert.assertNull(sWebCoreHandler);
    synchronized (WebViewCore.class) {
        sWebCoreHandler = new Handler() {

            @Override
            public void handleMessage(Message msg) {
                switch(msg.what) {
                    case INITIALIZE:
                        WebViewCore core = (WebViewCore) msg.obj;
                        core.initialize();
                        break;
                    case REDUCE_PRIORITY:
                        // 3 is an adjustable number.
                        Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT + 3 * Process.THREAD_PRIORITY_LESS_FAVORABLE);
                        break;
                    case RESUME_PRIORITY:
                        Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                        break;
                    case EventHub.ADD_PACKAGE_NAME:
                        if (BrowserFrame.sJavaBridge == null) {
                            throw new IllegalStateException(""No WebView has been created in this process!"");
                        }
                        BrowserFrame.sJavaBridge.addPackageName((String) msg.obj);
                        break;
                    case EventHub.REMOVE_PACKAGE_NAME:
                        if (BrowserFrame.sJavaBridge == null) {
                            throw new IllegalStateException(""No WebView has been created in this process!"");
                        }
                        BrowserFrame.sJavaBridge.removePackageName((String) msg.obj);
                        break;
                    case EventHub.PROXY_CHANGED:
                        if (BrowserFrame.sJavaBridge == null) {
                            throw new IllegalStateException(""No WebView has been created in this process!"");
                        }
                        BrowserFrame.sJavaBridge.updateProxy((ProxyProperties) msg.obj);
                        break;
                    case EventHub.HEARTBEAT:
                        // Ping back the watchdog to let it know we're still processing
                        // messages.
                        Message m = (Message) msg.obj;
                        m.sendToTarget();
                        break;
                    case EventHub.TRUST_STORAGE_UPDATED:
                        // post a task to network thread for updating trust manager
                        nativeCertTrustChanged();
                        CertificateChainValidator.handleTrustStorageUpdate();
                        break;
                }
            }
        };
        WebViewCore.class.notify();
    }
    Looper.loop();
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,3,2,"Two new cases (EventHub.HEARTBEAT and EventHub.TRUST_STORAGE_UPDATED) are introduced under 'switch'. A new exception may be thrown under EventHub.TRUST_STORAGE_UPDATED, so the code change type is 3.","The newly introduced case (EventHub.TRUST_STORAGE_UPDATED) can potentially throw a new exception, causing the API to behave differently in terms of exception handling. Therefore the CI type is 2."
136,<android.webkit.WebSettings: void setBlockNetworkImage(boolean)>,15,16,<android.webkit.WebSettings: void setBlockNetworkImage(boolean)>,<android.webkit.WebSettings: void setBlockNetworkImage(boolean)>,0,"{
    if (mBlockNetworkImage != flag) {
        mBlockNetworkImage = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to block network images. This is only checked when
 * {@link #getLoadsImagesAutomatically} is true. If you set the value to
 * false, images will automatically be loaded. Use this api to reduce
 * bandwidth only. Use {@link #setBlockNetworkLoads} if possible.
 * @param flag True if the WebView should block network images.
 * @see #setBlockNetworkLoads
 */
","/**
 * Sets whether the WebView should not load image resources from the
 * network (resources accessed via http and https URI schemes).  Note
 * that this method has no effect unless
 * {@link #getLoadsImagesAutomatically} returns true. Also note that
 * disabling all network loads using {@link #setBlockNetworkLoads}
 * will also prevent network images from loading, even if this flag is set
 * to false. When the value of this setting is changed from true to false,
 * network images resources referenced by content currently displayed by
 * the WebView are fetched automatically. The default is false.
 *
 * @param flag whether the WebView should not load image resources from the
 * network
 * @see #setBlockNetworkLoads
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The implementation of the API changed completely: the early version contains an if statement that controls a block of code, while the late version simply throws an exception. Thus the change types are 1 (return statement changed) and 2 (exception handling statement changed).","The complete change in implementation can lead to various compatibility issues. In the early version, this API would change a variable value conditionally and perform some synchronization. However, in the late version, it simply throws an exception immediately without performing any of the former actions. Thus, the compatibility issue types are 1 (return different values or types) and 2 (throw different exceptions)."
140,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,15,16,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,0,"{
    try {
        long timeStart = acquireAndLock(READ);
        String retValue = native_1x1_string();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } catch (SQLiteDoneException e) {
        throw new SQLiteDoneException(""expected 1 row from this query but query returned no data. check the query: "" + mSql);
    } finally {
        releaseAndUnlock();
    }
}","{
    acquireReference();
    try {
        return getSession().executeForString(getSql(), getBindArgs(), getConnectionFlags(), null);
    } catch (SQLiteDatabaseCorruptException ex) {
        onCorruption();
        throw ex;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Execute a statement that returns a 1 by 1 table with a text value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a text value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The overall return statements and exception handling in the two versions completely changed, and included some other statement changes as well. The APIs such as getSession(), executeForString(...), getSql(), getBindArgs(), getConnectionFlags(), and onCorruption() are newly introduced in the late version. Therefore, the code change type is 1,2,4,5.","Firstly, the return values from two different versions come from different functions and hence could differ leading to potential CI_1. The exception handling situation is similar, given the SQLiteDoneException in the early version changed to SQLiteDatabaseCorruptException in the late version, leading to potential CI_2. Hence, the Compatibility Issue type is 1,2."
141,<android.webkit.WebSettings: String getUserAgentString()>,15,16,<android.webkit.WebSettings: String getUserAgentString()>,<android.webkit.WebSettings: String getUserAgentString()>,0,"{
    if (DESKTOP_USERAGENT.equals(mUserAgent) || IPHONE_USERAGENT.equals(mUserAgent) || !mUseDefaultUserAgent) {
        return mUserAgent;
    }
    boolean doPostSync = false;
    synchronized (sLockForLocaleSettings) {
        Locale currentLocale = Locale.getDefault();
        if (!sLocale.equals(currentLocale)) {
            sLocale = currentLocale;
            mUserAgent = getCurrentUserAgent();
            mAcceptLanguage = getCurrentAcceptLanguage();
            doPostSync = true;
        }
    }
    if (doPostSync) {
        postSync();
    }
    return mUserAgent;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return the WebView's user-agent string.
 */
","/**
 * Gets the WebView's user-agent string.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the late version, the whole method body is replaced by a throw statement, so the code change type is 1,2,4.","The original method can return a certain `mUserAgent`, while the late version always throw a `MustOverrideException`. Therefore, the API will have a completely different behaviour, meaning the CI type is 1,2."
142,"<android.app.AlarmManager: void set(int,long,PendingIntent)>",15,16,"<android.app.AlarmManager: void set(int,long,PendingIntent)>","<android.app.AlarmManager: void set(int,long,PendingIntent)>",0,"{
    try {
        mService.set(type, triggerAtTime, operation);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mService.set(type, triggerAtMillis, operation);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Schedule an alarm.  <b>Note: for timing operations (ticks, timeouts,
 * etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>If the time occurs in the past, the alarm will be triggered
 * immediately.  If there is already an alarm for this Intent
 * scheduled (with the equality of two intents being defined by
 * {@link Intent#filterEquals}), then it will be removed and replaced by
 * this one.
 *
 * <p>
 * The alarm is an intent broadcast that goes to a broadcast receiver that
 * you registered with {@link android.content.Context#registerReceiver}
 * or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.
 *
 * <p>
 * Alarm intents are delivered with a data extra of type int called
 * {@link Intent#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT} that indicates
 * how many past alarm events have been accumulated into this intent
 * broadcast.  Recurring alarms that have gone undelivered because the
 * phone was asleep may have a count greater than one when delivered.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP, RTC or
 * RTC_WAKEUP.
 * @param triggerAtTime Time the alarm should go off, using the
 * appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #setRepeating
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
","/**
 * Schedule an alarm.  <b>Note: for timing operations (ticks, timeouts,
 * etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>If the time occurs in the past, the alarm will be triggered
 * immediately.  If there is already an alarm for this Intent
 * scheduled (with the equality of two intents being defined by
 * {@link Intent#filterEquals}), then it will be removed and replaced by
 * this one.
 *
 * <p>
 * The alarm is an intent broadcast that goes to a broadcast receiver that
 * you registered with {@link android.content.Context#registerReceiver}
 * or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.
 *
 * <p>
 * Alarm intents are delivered with a data extra of type int called
 * {@link Intent#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT} that indicates
 * how many past alarm events have been accumulated into this intent
 * broadcast.  Recurring alarms that have gone undelivered because the
 * phone was asleep may have a count greater than one when delivered.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should go
 * off, using the appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #setRepeating
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The method call mService.set(type, triggerAtTime, operation) changed to mService.set(type, triggerAtMillis, operation), where the variable passed in the method call has changed. Hence, the class of change would be 4.","Because the variable passed in the method call has changed from triggerAtTime to triggerAtMillis, it may potentially return different values. Therefore, the type of compatibility issue is 1."
143,<android.speech.tts.AudioPlaybackHandler: boolean isSpeaking()>,15,16,<android.speech.tts.AudioPlaybackHandler: boolean isSpeaking()>,<android.speech.tts.AudioPlaybackHandler: boolean isSpeaking()>,0,"{
    return (mQueue.peek() != null) || (mCurrentParams != null);
}","{
    return (mQueue.peek() != null) || (mCurrentWorkItem != null);
}",1,"/**
 * @return false iff the queue is empty and no queue item is currently
 * being handled, true otherwise.
 */
","/**
 * @return false iff the queue is empty and no queue item is currently
 * being handled, true otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed. Specifically, the second part of the logical condition within the return statement has been modified from checking if mCurrentParams is null to checking if mCurrentWorkItem is null. Therefore, the change type is 1, 5.","Due to the change in the return statement, the method has a potential to return a different boolean result between the two versions. Hence, there is a Compatibility Issue of type 1."
144,<android.widget.TextView: KeyListener getKeyListener()>,15,16,<android.widget.TextView: KeyListener getKeyListener()>,<android.widget.TextView: KeyListener getKeyListener()>,0,"{
    return mInput;
}","{
    return mEditor == null ? null : mEditor.mKeyListener;
}",1,"/**
 * @return the current key listener for this TextView.
 * This will frequently be null for non-EditText TextViews.
 */
","/**
 * @return the current key listener for this TextView.
 * This will frequently be null for non-EditText TextViews.
 *
 * @attr ref android.R.styleable#TextView_numeric
 * @attr ref android.R.styleable#TextView_digits
 * @attr ref android.R.styleable#TextView_phoneNumber
 * @attr ref android.R.styleable#TextView_inputMethod
 * @attr ref android.R.styleable#TextView_capitalize
 * @attr ref android.R.styleable#TextView_autoText
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mInput;' to 'return mEditor == null ? null : mEditor.mKeyListener;', so the code change type is 1.","As the return statement changed, the API could potentially return a different value in the late version, thus the CI type is 1."
145,"<android.view.GLES20Canvas: boolean clipPath(Path,Op)>",15,16,"<android.view.GLES20Canvas: boolean clipPath(Path,Op)>","<android.view.GLES20Canvas: boolean clipPath(Path,Op)>",0,"{
    throw new UnsupportedOperationException();
}","{
    // TODO: Implement
    path.computeBounds(mPathBounds, true);
    return nClipRect(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom, op.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The early version of the implementation solely consists of an UnsupportedOperationException, while the late version entails a logical implementation, with the calling of two separate methods and return of a value. A new return statement and exception handling statement are introduced, in addition to other new coding statements, Therefore, the code change types are 1, 2 and 4.","Given the drastic change in the return statements and the handling of exceptions, the potential behavior of the function may vary significantly between the two versions. As such, a compatibility issue definitely exists, in both the return values or types (1), as well as the handling of exceptions(2)."
146,"<android.widget.NumberPicker: void onMeasure(int,int)>",15,16,"<android.widget.NumberPicker: void onMeasure(int,int)>","<android.widget.NumberPicker: void onMeasure(int,int)>",0,"{
    // Try greedily to fit the max width and height.
    final int newWidthMeasureSpec = makeMeasureSpec(widthMeasureSpec, mMaxWidth);
    final int newHeightMeasureSpec = makeMeasureSpec(heightMeasureSpec, mMaxHeight);
    super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);
    // Flag if we are measured with width or height less than the respective min.
    final int widthSize = resolveSizeAndStateRespectingMinSize(mMinWidth, getMeasuredWidth(), widthMeasureSpec);
    final int heightSize = resolveSizeAndStateRespectingMinSize(mMinHeight, getMeasuredHeight(), heightMeasureSpec);
    setMeasuredDimension(widthSize, heightSize);
}","{
    if (!mHasSelectorWheel) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    // Try greedily to fit the max width and height.
    final int newWidthMeasureSpec = makeMeasureSpec(widthMeasureSpec, mMaxWidth);
    final int newHeightMeasureSpec = makeMeasureSpec(heightMeasureSpec, mMaxHeight);
    super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);
    // Flag if we are measured with width or height less than the respective min.
    final int widthSize = resolveSizeAndStateRespectingMinSize(mMinWidth, getMeasuredWidth(), widthMeasureSpec);
    final int heightSize = resolveSizeAndStateRespectingMinSize(mMinHeight, getMeasuredHeight(), heightMeasureSpec);
    setMeasuredDimension(widthSize, heightSize);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"In the late-version code, an if condition and return statement were added. This leads to an early exit from the function if the condition is met. This is categorized as a change type 1,3.","The early return introduced in the late-version could potentially alter the returned value of the function in certain cases when 'mHasSelectorWheel' is false. This could lead to a compatibility issue of type 1, caused by potential differences in return values or types."
148,<android.webkit.WebView: String findAddress(String)>,15,16,<android.webkit.WebView: String findAddress(String)>,<android.webkit.WebView: String findAddress(String)>,0,"{
    checkThread();
    return findAddress(addr, false);
}","{
    checkThread();
    return getFactory().getStatics().findAddress(addr);
}",1,"/**
 * Return the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * - a house number
 * - a street name
 * - a street type (Road, Circle, etc), either spelled out or abbreviated
 * - a city name
 * - a state or territory, either spelled out or two-letter abbr.
 * - an optional 5 digit or 9 digit zip code.
 *
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 * @param addr The string to search for addresses.
 *
 * @return the address, or if no address is found, return null.
 */
","/**
 * Gets the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * <ul>
 * <li>a house number</li>
 * <li>a street name</li>
 * <li>a street type (Road, Circle, etc), either spelled out or
 * abbreviated</li>
 * <li>a city name</li>
 * <li>a state or territory, either spelled out or two-letter abbr</li>
 * <li>an optional 5 digit or 9 digit zip code</li>
 * </ul>
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 *
 * @param addr the string to search for addresses
 * @return the address, or if no address is found, null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the late version is changed to 'return getFactory().getStatics().findAddress(addr);' from 'return findAddress(addr, false);'. This change includes calling different depending APIs which changes method name and parameters, thus, we classify this change as type 1 (Return statement changed) and type 5 (Dependent API changed).","The change in the underlying implementation method being called can affect the return variable of the parent method, potentially making it return a different value or type. Therefore, the CI is classified as type 1 (Compatibility Issue caused by potential different return values or types)."
149,<android.speech.tts.PlaybackSynthesisCallback: int done()>,15,16,<android.speech.tts.PlaybackSynthesisCallback: int done()>,<android.speech.tts.PlaybackSynthesisCallback: int done()>,0,"{
    if (DBG)
        Log.d(TAG, ""done()"");
    SynthesisMessageParams token = null;
    synchronized (mStateLock) {
        if (mDone) {
            Log.w(TAG, ""Duplicate call to done()"");
            return TextToSpeech.ERROR;
        }
        mDone = true;
        if (mToken == null) {
            return TextToSpeech.ERROR;
        }
        token = mToken;
    }
    mAudioTrackHandler.enqueueSynthesisDone(token);
    mLogger.onEngineComplete();
    return TextToSpeech.SUCCESS;
}","{
    if (DBG)
        Log.d(TAG, ""done()"");
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mDone) {
            Log.w(TAG, ""Duplicate call to done()"");
            return TextToSpeech.ERROR;
        }
        mDone = true;
        if (mItem == null) {
            return TextToSpeech.ERROR;
        }
        item = mItem;
    }
    item.done();
    mLogger.onEngineComplete();
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The ""SynthesisMessageParams token"" has been replaced with ""SynthesisPlaybackQueueItem item"". Additionally, the method ""mAudioTrackHandler.enqueueSynthesisDone(token)"" in early implementation has been replaced with ""item.done()"". Hence, the change types are 1 and 4.","Even though the variable and methods used have changed, the functionality is the same, i.e., it checks whether the operation is done or not. If it is done, it either returns an error or completes successfully. Thus, there is no compatibility issue."
150,<android.widget.TextView: boolean bringPointIntoView(int)>,15,16,<android.widget.TextView: boolean bringPointIntoView(int)>,<android.widget.TextView: boolean bringPointIntoView(int)>,0,"{
    boolean changed = false;
    if (mLayout == null)
        return changed;
    int line = mLayout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) mLayout.getPrimaryHorizontal(offset);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(mLayout.getLineLeft(line));
    int right = (int) FloatMath.ceil(mLayout.getLineRight(line));
    int ht = mLayout.getHeight();
    int grav;
    switch(mLayout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = mLayout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -mLayout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        if (mTempRect == null)
            mTempRect = new Rect();
        // The offsets here are to ensure the rectangle we are using is
        // within our view bounds, in case the cursor is on the far left
        // or right.  If it isn't withing the bounds, then this request
        // will be ignored.
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}","{
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(layout.getLineLeft(line));
    int right = (int) FloatMath.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a replacement of variable in the code - mLayout is replaced by layout, but the value of layout is derived in the same way as mLayout. So, the change type is 4 (Other statement changed).","Despite the change, the new implementation of the method performs the same function as the old one. The behaviors, returns, and exceptions of the API remain the same. Hence, there is no compatibility issue."
151,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",15,16,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>","<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",0,"{
    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    // Don't put header or footer views or views that should be ignored
    // into the scrap heap
    int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            removeDetachedView(scrap, false);
        }
        return;
    }
    lp.scrappedFromPosition = position;
    if (mViewTypeCount == 1) {
        scrap.dispatchStartTemporaryDetach();
        mCurrentScrap.add(scrap);
    } else {
        scrap.dispatchStartTemporaryDetach();
        mScrapViews[viewType].add(scrap);
    }
    if (mRecyclerListener != null) {
        mRecyclerListener.onMovedToScrapHeap(scrap);
    }
}","{
    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Don't put header or footer views or views that should be ignored
    // into the scrap heap
    int viewType = lp.viewType;
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
        if (scrapHasTransientState) {
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            scrap.dispatchStartTemporaryDetach();
            mTransientStateViews.put(position, scrap);
        }
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    if (mViewTypeCount == 1) {
        mCurrentScrap.add(scrap);
    } else {
        mScrapViews[viewType].add(scrap);
    }
    scrap.setAccessibilityDelegate(null);
    if (mRecyclerListener != null) {
        mRecyclerListener.onMovedToScrapHeap(scrap);
    }
}",1,"/**
 * Put a view into the ScapViews list. These views are unordered.
 *
 * @param scrap The view to add
 */
","/**
 * Put a view into the ScrapViews list. These views are unordered.
 *
 * @param scrap The view to add
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method structure and conditional dependencies have been changed with new control variables. A new return statement is introduced, and some methods (like `setAccessibilityDelegate(null)`) in the implementation are introduced. So the change type is 1,3,4.","The new return statement and the control dependency change could potentially alter the behavior of the method. Depending on the conditions, the method might return earlier and behave differently, resulting in the CI type of 1."
152,<android.speech.tts.TextToSpeech: void shutdown()>,15,16,<android.speech.tts.TextToSpeech: void shutdown()>,<android.speech.tts.TextToSpeech: void shutdown()>,0,"{
    runActionNoReconnect(new Action<Void>() {

        @Override
        public Void run(ITextToSpeechService service) throws RemoteException {
            service.setCallback(getPackageName(), null);
            service.stop(getPackageName());
            mServiceConnection.disconnect();
            // Context#unbindService does not result in a call to
            // ServiceConnection#onServiceDisconnected. As a result, the
            // service ends up being destroyed (if there are no other open
            // connections to it) but the process lives on and the
            // ServiceConnection continues to refer to the destroyed service.
            // 
            // This leads to tons of log spam about SynthThread being dead.
            mServiceConnection = null;
            mCurrentEngine = null;
            return null;
        }
    }, null, ""shutdown"");
}","{
    runActionNoReconnect(new Action<Void>() {

        @Override
        public Void run(ITextToSpeechService service) throws RemoteException {
            service.setCallback(getCallerIdentity(), null);
            service.stop(getCallerIdentity());
            mServiceConnection.disconnect();
            // Context#unbindService does not result in a call to
            // ServiceConnection#onServiceDisconnected. As a result, the
            // service ends up being destroyed (if there are no other open
            // connections to it) but the process lives on and the
            // ServiceConnection continues to refer to the destroyed service.
            // 
            // This leads to tons of log spam about SynthThread being dead.
            mServiceConnection = null;
            mCurrentEngine = null;
            return null;
        }
    }, null, ""shutdown"");
}",1,"/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
","/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statements 'service.setCallback(getPackageName(), null)' and 'service.stop(getPackageName())' have been changed to 'service.setCallback(getCallerIdentity(), null)' and 'service.stop(getCallerIdentity())'. Hence, the statements are changed (category 4), and the dependent APIs (getPackageName() and getCallerIdentity()) are changed (category 5).","Due to the change in the dependent APIs, the shutdown() method could potentially execute differently. This means the changes might lead to different effects from the previous version, causing compatibility issues with potential different return values (category 1)."
154,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",15,16,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true);
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"In the late implementation, a new argument ""Binder.getOrigCallingUser()"" is added to the method ""broadcastIntent"", thus both the dependent API and the other statement has been changed. This leads to a code change type of 4,5.","With the new argument added to the method ""broadcastIntent"", it is possible that a different execution path is taken inside ""broadcastIntent"" and hence a different return value. So, this change could potentially lead to Compatibility Issue type 1."
158,"<android.view.View: View findUserSetNextFocus(View,int)>",15,16,"<android.view.View: View findUserSetNextFocus(View,int)>","<android.view.View: View findUserSetNextFocus(View,int)>",0,"{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                final int id = mID;
                return root.findViewByPredicateInsideOut(this, new Predicate<View>() {

                    @Override
                    public boolean apply(View t) {
                        return t.mNextFocusForwardId == id;
                    }
                });
            }
    }
    return null;
}","{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                if (mID == View.NO_ID)
                    return null;
                final int id = mID;
                return root.findViewByPredicateInsideOut(this, new Predicate<View>() {

                    @Override
                    public boolean apply(View t) {
                        return t.mNextFocusForwardId == id;
                    }
                });
            }
    }
    return null;
}",1,"/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
","/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An 'if' condition statement (if (mID == View.NO_ID)) has been inserted under 'case FOCUS_BACKWARD:', which is a control dependency change, so the code change type is 3.","The inserted condition can cause the function to return null in some scenarios where it previously would not, thus possibly making the function return a different value, so the CI type is 1."
162,<android.content.ContentResolver: String getType(Uri)>,15,16,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url);
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url);
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change of the code between the early and late versions except for a comment, and this does not affect the behavior of the function.","Since there is no significant change in the implementation code, there are no Compatibility Issues between these versions."
163,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>",15,16,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>",0,"{
    return mMainThread.acquireProvider(context, name);
}","{
    return mMainThread.acquireProvider(context, name, true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API acquireProvider(Context,String) has changed to acquireProvider(Context,String,boolean) with an additional parameter, therefore, the code change type is 1,5.","The change of the dependent API may lead to a different return value, so the CI type is 1."
164,<com.google.android.mms.pdu.PduParser: EncodedStringValue parseEncodedStringValue(ByteArrayInputStream)>,15,16,<com.google.android.mms.pdu.PduParser: EncodedStringValue parseEncodedStringValue(ByteArrayInputStream)>,<com.google.android.mms.pdu.PduParser: EncodedStringValue parseEncodedStringValue(ByteArrayInputStream)>,0,"{
    /**
     * From OMA-TS-MMS-ENC-V1_3-20050927-C.pdf
     * Encoded-string-value = Text-string | Value-length Char-set Text-string
     */
    assert (null != pduDataStream);
    pduDataStream.mark(1);
    EncodedStringValue returnValue = null;
    int charset = 0;
    int temp = pduDataStream.read();
    assert (-1 != temp);
    int first = temp & 0xFF;
    pduDataStream.reset();
    if (first < TEXT_MIN) {
        parseValueLength(pduDataStream);
        // get the ""Charset""
        charset = parseShortInteger(pduDataStream);
    }
    byte[] textString = parseWapString(pduDataStream, TYPE_TEXT_STRING);
    try {
        if (0 != charset) {
            returnValue = new EncodedStringValue(charset, textString);
        } else {
            returnValue = new EncodedStringValue(textString);
        }
    } catch (Exception e) {
        return null;
    }
    return returnValue;
}","{
    /**
     * From OMA-TS-MMS-ENC-V1_3-20050927-C.pdf
     * Encoded-string-value = Text-string | Value-length Char-set Text-string
     */
    assert (null != pduDataStream);
    pduDataStream.mark(1);
    EncodedStringValue returnValue = null;
    int charset = 0;
    int temp = pduDataStream.read();
    assert (-1 != temp);
    int first = temp & 0xFF;
    if (first == 0) {
        // Blank subject, bail.
        return null;
    }
    pduDataStream.reset();
    if (first < TEXT_MIN) {
        parseValueLength(pduDataStream);
        // get the ""Charset""
        charset = parseShortInteger(pduDataStream);
    }
    byte[] textString = parseWapString(pduDataStream, TYPE_TEXT_STRING);
    try {
        if (0 != charset) {
            returnValue = new EncodedStringValue(charset, textString);
        } else {
            returnValue = new EncodedStringValue(textString);
        }
    } catch (Exception e) {
        return null;
    }
    return returnValue;
}",1,"/**
 * Parse encoded string value.
 *
 * @param pduDataStream pdu data input stream
 * @return the EncodedStringValue
 */
","/**
 * Parse encoded string value.
 *
 * @param pduDataStream pdu data input stream
 * @return the EncodedStringValue
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement 'if (first == 0)' has added into the late version implementation, which makes the value returned could be changed in the scenario where the condition is satisfied, so the change type is 3.","The new 'if' statement introduced could potentially lead to different return values: in the previous version, the method does not return anything if 'first' is 0, while in the later version, it will return null directly if 'first' is 0. This potentially different return value leads to a CI and the type is 1."
165,"<android.view.GLES20Canvas: void drawTextOnPath(char[],int,int,Path,float,float,Paint)>",15,16,"<android.view.GLES20Canvas: void drawTextOnPath(char[],int,int,Path,float,float,Paint)>","<android.view.GLES20Canvas: void drawTextOnPath(char[],int,int,Path,float,float,Paint)>",0,"{
// TODO: Implement
}","{
    if (index < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawTextOnPath(mRenderer, text, index, count, path.mNativePath, hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The early version has no implementation while the late version has introduced new exception handling statement, for-loop statement, and dependencies on other APIs. So the code change type is 2,3,4.","The new introduced exception handling statement potentially leads to a new exception and dependencies on other APIs. It also potentially changes the return type of this API, so the CI type is 1,2."
166,<android.app.ContextImpl: void startActivities(Intent[])>,15,16,<android.app.ContextImpl: void startActivities(Intent[])>,<android.app.ContextImpl: void startActivities(Intent[])>,0,"{
    if ((intents[0].getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(""Calling startActivities() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag on first Intent."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivities(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intents);
}","{
    startActivities(intents, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5","1,2","In the later version, the entire early implementation is replaced with a call to startActivities(intents, null);, not only changing the functionality of the method but also calling a different version of startActivities() that takes an extra argument. Therefore, the change type is 4,5.","The method was refactored to call a new method with different arguments. This could lead to different behaviors, either returning a different value or throwing a different exception, depending on the implementation of the new method. Therefore, the CI type is 1,2."
168,<android.webkit.WebSettings: void setGeolocationEnabled(boolean)>,15,16,<android.webkit.WebSettings: void setGeolocationEnabled(boolean)>,<android.webkit.WebSettings: void setGeolocationEnabled(boolean)>,0,"{
    if (mGeolocationEnabled != flag) {
        mGeolocationEnabled = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Sets whether Geolocation is enabled.
 * @param flag Whether Geolocation should be enabled.
 */
","/**
 * Sets whether Geolocation is enabled.
 *
 * @param flag whether Geolocation should be enabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 2","1, 2","The API implementation has completely changed. The previous implementation logic has been deleted, and a new `throw` statement has been added, so the change type is 1,2.","The change in the return statement and the newly added exception will cause this method to have a completely different behavior, resulting in compatibility issues of type 1,2."
169,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,15,16,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,0,"{
    checkThread();
    if (outState == null) {
        return null;
    }
    // We grab a copy of the back/forward list because a client of WebView
    // may have invalidated the history list by calling clearHistory.
    WebBackForwardList list = copyBackForwardList();
    final int currentIndex = list.getCurrentIndex();
    final int size = list.getSize();
    // not in a valid range.
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
        return null;
    }
    outState.putInt(""index"", currentIndex);
    // FIXME: This should just be a byte[][] instead of ArrayList but
    // Parcel.java does not have the code to handle multi-dimensional
    // arrays.
    ArrayList<byte[]> history = new ArrayList<byte[]>(size);
    for (int i = 0; i < size; i++) {
        WebHistoryItem item = list.getItemAtIndex(i);
        if (null == item) {
            // FIXME: this shouldn't happen
            // need to determine how item got set to null
            Log.w(LOGTAG, ""saveState: Unexpected null history item."");
            return null;
        }
        byte[] data = item.getFlattenedData();
        if (data == null) {
            // flattened data.
            return null;
        }
        history.add(data);
    }
    outState.putSerializable(""history"", history);
    if (mCertificate != null) {
        outState.putBundle(""certificate"", SslCertificate.saveState(mCertificate));
    }
    outState.putBoolean(""privateBrowsingEnabled"", isPrivateBrowsingEnabled());
    mZoomManager.saveZoomState(outState);
    return list;
}","{
    checkThread();
    return mProvider.saveState(outState);
}",1,"/**
 * Save the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called. See {@link #savePicture} and {@link #restorePicture} for saving
 * and restoring the display data.
 * @param outState The Bundle to store the WebView state.
 * @return The same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 * @see #savePicture
 * @see #restorePicture
 */
","/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called. See {@link #savePicture} and {@link #restorePicture} for saving
 * and restoring the display data.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 * @see #savePicture
 * @see #restorePicture
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method drastically changed from multiple statements and complex control flow to a simple return statement mProvider.saveState(outState). This indicates that the return statement and the dependent API have been changed, so the code change type is 1,5.","It is clear that the new implementation of the method returns a completely different value. Given that this will affect the behavior of the API, it constitutes a Compatibility Issue of type 1, which pertains to the return of different values or types."
170,"<android.widget.GridLayout: int getMargin1(View,boolean,boolean)>",15,16,"<android.widget.GridLayout: int getMargin1(View,boolean,boolean)>","<android.widget.GridLayout: int getMargin1(View,boolean,boolean)>",0,"{
    LayoutParams lp = getLayoutParams(view);
    int margin = horizontal ? (leading ? lp.leftMargin : lp.rightMargin) : (leading ? lp.topMargin : lp.bottomMargin);
    return margin == UNDEFINED ? getDefaultMarginValue(view, lp, horizontal, leading) : margin;
}","{
    LayoutParams lp = getLayoutParams(view);
    int margin = horizontal ? (leading ? lp.leftMargin : lp.rightMargin) : (leading ? lp.topMargin : lp.bottomMargin);
    return margin == UNDEFINED ? getDefaultMargin(view, lp, horizontal, leading) : margin;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed, ""getDefaultMarginValue(view, lp, horizontal, leading)"" method call was replaced by ""getDefaultMargin(view, lp, horizontal, leading)"", so the code change type is 1,5.","The different dependent APIs used in the return statement could lead to potentially different return values. Therefore, the CI type is 1."
171,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,15,16,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,<android.animation.ValueAnimator: ValueAnimator setDuration(long)>,0,"{
    if (duration < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative duration: "" + duration);
    }
    mDuration = duration;
    return this;
}","{
    if (duration < 0) {
        throw new IllegalArgumentException(""Animators cannot have negative duration: "" + duration);
    }
    mUnscaledDuration = duration;
    mDuration = (long) (duration * sDurationScale);
    return this;
}",1,"/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */
","/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late implementation, a new variable 'mUnscaledDuration' is introduced and assigned the value of 'duration'. Also, 'mDuration' is now assigned the value of 'duration' times 'sDurationScale'. Hence, the code change is classified as 'Other statement changed' which is type 4.","The method still returns 'this' in both versions and the exception that could be thrown is the same. So there would not be any Compatibility Issues, which means the CI type is 0."
172,<android.webkit.WebView: int computeVerticalScrollExtent()>,15,16,<android.webkit.WebView: int computeVerticalScrollExtent()>,<android.webkit.WebView: int computeVerticalScrollExtent()>,0,"{
    return getViewHeight();
}","{
    return mProvider.getScrollDelegate().computeVerticalScrollExtent();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getViewHeight() to mProvider.getScrollDelegate().computeVerticalScrollExtent(). In addition, a new dependent API getScrollDelegate() is invoked, so the code change type is 1,5.","Since the return statement was changed, the API potentially returns a different value in two versions, hence CI type is 1."
173,<android.view.HardwareRenderer.Gl20Renderer.Gl20RendererEglContext: void onTerminate(EGLContext)>,15,16,<android.view.HardwareRenderer.Gl20Renderer.Gl20RendererEglContext: void onTerminate(EGLContext)>,<android.view.HardwareRenderer.Gl20Renderer.Gl20RendererEglContext: void onTerminate(EGLContext)>,0,"{
    // Make sure we do this on the correct thread.
    if (mHandler.getLooper() != Looper.myLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                onTerminate(eglContext);
            }
        });
        return;
    }
    synchronized (sEglLock) {
        if (sEgl == null)
            return;
        if (EGLImpl.getInitCount(sEglDisplay) == 1) {
            usePbufferSurface(eglContext);
            GLES20Canvas.terminateCaches();
            sEgl.eglDestroyContext(sEglDisplay, eglContext);
            sEglContextStorage.remove();
            sEgl.eglDestroySurface(sEglDisplay, sPbuffer);
            sEgl.eglMakeCurrent(sEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
            sEgl.eglReleaseThread();
            sEgl.eglTerminate(sEglDisplay);
            sEgl = null;
            sEglDisplay = null;
            sEglConfig = null;
            sPbuffer = null;
            sEglContextStorage.set(null);
        }
    }
}","{
    // Make sure we do this on the correct thread.
    if (mHandler.getLooper() != Looper.myLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                onTerminate(eglContext);
            }
        });
        return;
    }
    synchronized (sEglLock) {
        if (sEgl == null)
            return;
        if (EGLImpl.getInitCount(sEglDisplay) == 1) {
            usePbufferSurface(eglContext);
            GLES20Canvas.terminateCaches();
            sEgl.eglDestroyContext(sEglDisplay, eglContext);
            sEglContextStorage.set(null);
            sEglContextStorage.remove();
            sEgl.eglDestroySurface(sEglDisplay, sPbuffer);
            sEgl.eglMakeCurrent(sEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
            sEgl.eglReleaseThread();
            sEgl.eglTerminate(sEglDisplay);
            sEgl = null;
            sEglDisplay = null;
            sEglConfig = null;
            sPbuffer = null;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The order of sEglContextStorage.set(null) and sEglContextStorage.remove() has been changed, so the code change type is 4 (Other statement changed).","The change of ordering doesn't cause the API to return a different variable or throw the exception differently, so there is no Compatibility Issue (CI)."
174,<android.database.sqlite.SQLiteDatabase: SQLiteDatabase create(CursorFactory)>,15,16,<android.database.sqlite.SQLiteDatabase: SQLiteDatabase create(CursorFactory)>,<android.database.sqlite.SQLiteDatabase: SQLiteDatabase create(CursorFactory)>,0,"{
    // This is a magic string with special meaning for SQLite.
    return openDatabase(MEMORY_DB_PATH, factory, CREATE_IF_NECESSARY);
}","{
    // This is a magic string with special meaning for SQLite.
    return openDatabase(SQLiteDatabaseConfiguration.MEMORY_DB_PATH, factory, CREATE_IF_NECESSARY);
}",1,"/**
 * Create a memory backed SQLite database.  Its contents will be destroyed
 * when the database is closed.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called
 * @return a SQLiteDatabase object, or null if the database can't be created
 */
","/**
 * Create a memory backed SQLite database.  Its contents will be destroyed
 * when the database is closed.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called
 * @return a SQLiteDatabase object, or null if the database can't be created
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,The dependent API parameter has been altered from MEMORY_DB_PATH to SQLiteDatabaseConfiguration.MEMORY_DB_PATH. Therefore the code change type is 5.,"The change in the dependent API's parameter may potentially cause the API to return a different value in the late version. Thus, a compatibility issue could exist, specifically potential different return values or types, which is CI type 1."
176,<android.webkit.WebSettings: boolean getDomStorageEnabled()>,15,16,<android.webkit.WebSettings: boolean getDomStorageEnabled()>,<android.webkit.WebSettings: boolean getDomStorageEnabled()>,0,"{
    return mDomStorageEnabled;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if the DOM Storage API's are enabled.
 * @return True if the DOM Storage API's are enabled.
 */
","/**
 * Gets whether the DOM Storage APIs are enabled.
 *
 * @return true if the DOM Storage APIs are enabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The existing return statement has been removed and the new `throw` statement has been introduced. So, the code change type is 1,2.","The change in the return statement can lead to the API returning a different value. The new `throw` statement can potentially cause the API to throw a different exception. Therefore, the CI type is 1,2."
177,<android.webkit.WebView: boolean performLongClick()>,15,16,<android.webkit.WebView: boolean performLongClick()>,<android.webkit.WebView: boolean performLongClick()>,0,"{
    // view system. In that case, do nothing.
    if (getParent() == null)
        return false;
    // A multi-finger gesture can look like a long press; make sure we don't take
    // long press actions if we're scaling.
    final ScaleGestureDetector detector = mZoomManager.getMultiTouchGestureDetector();
    if (detector != null && detector.isInProgress()) {
        return false;
    }
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        centerKeyPressOnTextField();
        rebuildWebTextView();
    } else {
        clearTextEntry();
    }
    if (inEditingMode()) {
        // Since we just called rebuildWebTextView, the layout is not set
        // properly.  Update it so it can correctly find the word to select.
        mWebTextView.ensureLayout();
        // Provide a touch down event to WebTextView, which will allow it
        // to store the location to use in performLongClick.
        AbsoluteLayout.LayoutParams params = (AbsoluteLayout.LayoutParams) mWebTextView.getLayoutParams();
        MotionEvent fake = MotionEvent.obtain(mLastTouchTime, mLastTouchTime, MotionEvent.ACTION_DOWN, mLastTouchX - params.x + mScrollX, mLastTouchY - params.y + mScrollY, 0);
        mWebTextView.dispatchTouchEvent(fake);
        return mWebTextView.performLongClick();
    }
    // long click does nothing on selection
    if (mSelectingText)
        return false;
    /* if long click brings up a context menu, the super function
         * returns true and we're done. Otherwise, nothing happened when
         * the user clicked. */
    if (super.performLongClick()) {
        return true;
    }
    /* In the case where the application hasn't already handled the long
         * click action, look for a word under the  click. If one is found,
         * animate the text selection into view.
         * FIXME: no animation code yet */
    final boolean isSelecting = selectText();
    if (isSelecting) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return isSelecting;
}","{
    return mProvider.getViewDelegate().performLongClick();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has been totally replaced from a long block of code to a single return statement return mProvider.getViewDelegate().performLongClick();. Here, the invoked method is changed as well. Thus, the classes of code change are 1 and 5.","The total replacement of the implementation could lead to different return values between two versions, and thus the Compatibility Issue type is 1."
179,<android.widget.TextView: boolean isInBatchEditMode()>,15,16,<android.widget.TextView: boolean isInBatchEditMode()>,<android.widget.TextView: boolean isInBatchEditMode()>,0,"{
    final InputMethodState ims = mInputMethodState;
    if (ims != null) {
        return ims.mBatchEditNesting > 0;
    }
    return mInBatchEditControllers;
}","{
    if (mEditor == null)
        return false;
    final Editor.InputMethodState ims = mEditor.mInputMethodState;
    if (ims != null) {
        return ims.mBatchEditNesting > 0;
    }
    return mEditor.mInBatchEditControllers;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementation added a new condition (if (mEditor == null)) and the code statements inside the first if block and the return statement outside the block are also updated, showing changes in the return statement, control dependencies, other statements, and dependent API, so the code change type is 1,3,4,5.","As the conditions, return type and the relationship to dependent APIs have changed, this could lead to the method returning a different result between the two versions. Therefore, the CI type is 1."
181,<android.webkit.ZoomManager: void animateZoom(Canvas)>,15,16,<android.webkit.ZoomManager: void animateZoom(Canvas)>,<android.webkit.ZoomManager: void animateZoom(Canvas)>,0,"{
    mInitialZoomOverview = false;
    if (mZoomScale == 0) {
        Log.w(LOGTAG, ""A WebView is attempting to perform a fixed length "" + ""zoom animation when no zoom is in progress"");
        return;
    }
    float zoomScale;
    int interval = (int) (SystemClock.uptimeMillis() - mZoomStart);
    if (interval < ZOOM_ANIMATION_LENGTH) {
        float ratio = (float) interval / ZOOM_ANIMATION_LENGTH;
        zoomScale = 1.0f / (mInvInitialZoomScale + (mInvFinalZoomScale - mInvInitialZoomScale) * ratio);
        mWebView.invalidate();
    } else {
        zoomScale = mZoomScale;
        // set mZoomScale to be 0 as we have finished animating
        mZoomScale = 0;
        mWebView.onFixedLengthZoomAnimationEnd();
    }
    // calculate the intermediate scroll position. Since we need to use
    // zoomScale, we can't use the WebView's pinLocX/Y functions directly.
    float scale = zoomScale * mInvInitialZoomScale;
    int tx = Math.round(scale * (mInitialScrollX + mZoomCenterX) - mZoomCenterX);
    tx = -WebView.pinLoc(tx, mWebView.getViewWidth(), Math.round(mWebView.getContentWidth() * zoomScale)) + mWebView.getScrollX();
    int titleHeight = mWebView.getTitleHeight();
    int ty = Math.round(scale * (mInitialScrollY + mZoomCenterY - titleHeight) - (mZoomCenterY - titleHeight));
    ty = -(ty <= titleHeight ? Math.max(ty, 0) : WebView.pinLoc(ty - titleHeight, mWebView.getViewHeight(), Math.round(mWebView.getContentHeight() * zoomScale)) + titleHeight) + mWebView.getScrollY();
    if (mHardwareAccelerated) {
        mWebView.updateScrollCoordinates(mWebView.getScrollX() - tx, mWebView.getScrollY() - ty);
        // By adding webView matrix, we need to offset the canvas a bit
        // to make the animation smooth.
        canvas.translate(tx, ty);
        setZoomScale(zoomScale, false);
        if (mZoomScale == 0) {
            // We've reached the end of the zoom animation.
            mInHWAcceleratedZoom = false;
            // Ensure that the zoom level is pushed to WebCore. This has not
            // yet occurred because we prevent it from happening while
            // mInHWAcceleratedZoom is true.
            mWebView.sendViewSizeZoom(false);
        }
    } else {
        canvas.translate(tx, ty);
        canvas.scale(zoomScale, zoomScale);
    }
}","{
    mInitialZoomOverview = false;
    if (mZoomScale == 0) {
        Log.w(LOGTAG, ""A WebView is attempting to perform a fixed length "" + ""zoom animation when no zoom is in progress"");
        // Now that we've logged about it, go ahead and just recover
        mInHWAcceleratedZoom = false;
        return;
    }
    float zoomScale;
    int interval = (int) (SystemClock.uptimeMillis() - mZoomStart);
    if (interval < ZOOM_ANIMATION_LENGTH) {
        float ratio = (float) interval / ZOOM_ANIMATION_LENGTH;
        zoomScale = 1.0f / (mInvInitialZoomScale + (mInvFinalZoomScale - mInvInitialZoomScale) * ratio);
        mWebView.invalidate();
    } else {
        zoomScale = mZoomScale;
        // set mZoomScale to be 0 as we have finished animating
        mZoomScale = 0;
        mWebView.onFixedLengthZoomAnimationEnd();
    }
    // calculate the intermediate scroll position. Since we need to use
    // zoomScale, we can't use the WebView's pinLocX/Y functions directly.
    float scale = zoomScale * mInvInitialZoomScale;
    int tx = Math.round(scale * (mInitialScrollX + mZoomCenterX) - mZoomCenterX);
    tx = -WebViewClassic.pinLoc(tx, mWebView.getViewWidth(), Math.round(mWebView.getContentWidth() * zoomScale)) + mWebView.getScrollX();
    int titleHeight = mWebView.getTitleHeight();
    int ty = Math.round(scale * (mInitialScrollY + mZoomCenterY - titleHeight) - (mZoomCenterY - titleHeight));
    ty = -(ty <= titleHeight ? Math.max(ty, 0) : WebViewClassic.pinLoc(ty - titleHeight, mWebView.getViewHeight(), Math.round(mWebView.getContentHeight() * zoomScale)) + titleHeight) + mWebView.getScrollY();
    if (mHardwareAccelerated) {
        mWebView.updateScrollCoordinates(mWebView.getScrollX() - tx, mWebView.getScrollY() - ty);
        // By adding webView matrix, we need to offset the canvas a bit
        // to make the animation smooth.
        canvas.translate(tx, ty);
        setZoomScale(zoomScale, false);
        if (mZoomScale == 0) {
            // We've reached the end of the zoom animation.
            mInHWAcceleratedZoom = false;
            // Ensure that the zoom level is pushed to WebCore. This has not
            // yet occurred because we prevent it from happening while
            // mInHWAcceleratedZoom is true.
            mWebView.sendViewSizeZoom(false);
        }
    } else {
        canvas.translate(tx, ty);
        canvas.scale(zoomScale, zoomScale);
    }
}",1,"/**
 * This method is called by the WebView's drawing code when a fixed length zoom
 * animation is occurring. Its purpose is to animate the zooming of the canvas
 * to the desired scale which was specified in startZoomAnimation(...).
 *
 * A fixed length animation begins when startZoomAnimation(...) is called and
 * continues until the ZOOM_ANIMATION_LENGTH time has elapsed. During that
 * interval each time the WebView draws it calls this function which is
 * responsible for generating the animation.
 *
 * Additionally, the WebView can check to see if such an animation is currently
 * in progress by calling isFixedLengthAnimationInProgress().
 */
","/**
 * This method is called by the WebView's drawing code when a fixed length zoom
 * animation is occurring. Its purpose is to animate the zooming of the canvas
 * to the desired scale which was specified in startZoomAnimation(...).
 *
 * A fixed length animation begins when startZoomAnimation(...) is called and
 * continues until the ZOOM_ANIMATION_LENGTH time has elapsed. During that
 * interval each time the WebView draws it calls this function which is
 * responsible for generating the animation.
 *
 * Additionally, the WebView can check to see if such an animation is currently
 * in progress by calling isFixedLengthAnimationInProgress().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the case where mZoomScale == 0, a return statement has been modified and an additional statement ""mInHWAcceleratedZoom = false"" has been added, which is categorised as 'Other statement changed'. ","The modified return statement and added statement ""mInHWAcceleratedZoom=false"" in the condition where mZoomScale==0 can potentially lead to different runtime behaviour. Because ""mInHWAcceleratedZoom=false"" might affect subsequent code paths, it has potential return a different value."
182,"<android.view.FocusFinder: View findNextFocus(ViewGroup,View,int)>",15,16,"<android.view.FocusFinder: View findNextFocus(ViewGroup,View,int)>","<android.view.FocusFinder: View findNextFocus(ViewGroup,View,int)>",0,"{
    if (focused != null) {
        // check for user specified next focus
        View userSetNextFocus = focused.findUserSetNextFocus(root, direction);
        if (userSetNextFocus != null && userSetNextFocus.isFocusable() && (!userSetNextFocus.isInTouchMode() || userSetNextFocus.isFocusableInTouchMode())) {
            return userSetNextFocus;
        }
        // fill in interesting rect from focused
        focused.getFocusedRect(mFocusedRect);
        root.offsetDescendantRectToMyCoords(focused, mFocusedRect);
    } else {
        // make up a rect at top left or bottom right of root
        switch(direction) {
            case View.FOCUS_RIGHT:
            case View.FOCUS_DOWN:
            case View.FOCUS_FORWARD:
                final int rootTop = root.getScrollY();
                final int rootLeft = root.getScrollX();
                mFocusedRect.set(rootLeft, rootTop, rootLeft, rootTop);
                break;
            case View.FOCUS_LEFT:
            case View.FOCUS_UP:
            case View.FOCUS_BACKWARD:
                final int rootBottom = root.getScrollY() + root.getHeight();
                final int rootRight = root.getScrollX() + root.getWidth();
                mFocusedRect.set(rootRight, rootBottom, rootRight, rootBottom);
                break;
        }
    }
    return findNextFocus(root, focused, mFocusedRect, direction);
}","{
    return findNextFocus(root, focused, null, direction);
}",1,"/**
 * Find the next view to take focus in root's descendants, starting from the view
 * that currently is focused.
 * @param root Contains focused
 * @param focused Has focus now.
 * @param direction Direction to look.
 * @return The next focusable view, or null if none exists.
 */
","/**
 * Find the next view to take focus in root's descendants, starting from the view
 * that currently is focused.
 * @param root Contains focused. Cannot be null.
 * @param focused Has focus now.
 * @param direction Direction to look.
 * @return The next focusable view, or null if none exists.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The early version of the implementation contains condition checks, rectangle assignments, and calls the method 'findNextFocus' with four parameters that change in behavior due to conditional checks. However, the late version of the implementation directly calls the 'findNextFocus' method with null as the third parameter. Therefore, the code change type is 1.","The change in return statement directly impacts the returned result of the method. Since the third parameter passed in the 'findNextFocus' function call has changed from mFocusedRect (which has specific assignments in if else conditions in the early version) to null in the late version, the method may return different results. So, a potential compatibility issue due to different return values exists, which is CI type 1."
183,<android.app.LoaderManagerImpl.LoaderInfo: void destroy()>,15,16,<android.app.LoaderManagerImpl.LoaderInfo: void destroy()>,<android.app.LoaderManagerImpl.LoaderInfo: void destroy()>,0,"{
    if (DEBUG)
        Log.v(TAG, ""  Destroying: "" + this);
    mDestroyed = true;
    boolean needReset = mDeliveredData;
    mDeliveredData = false;
    if (mCallbacks != null && mLoader != null && mHaveData && needReset) {
        if (DEBUG)
            Log.v(TAG, ""  Reseting: "" + this);
        String lastBecause = null;
        if (mActivity != null) {
            lastBecause = mActivity.mFragments.mNoTransactionsBecause;
            mActivity.mFragments.mNoTransactionsBecause = ""onLoaderReset"";
        }
        try {
            mCallbacks.onLoaderReset(mLoader);
        } finally {
            if (mActivity != null) {
                mActivity.mFragments.mNoTransactionsBecause = lastBecause;
            }
        }
    }
    mCallbacks = null;
    mData = null;
    mHaveData = false;
    if (mLoader != null) {
        if (mListenerRegistered) {
            mListenerRegistered = false;
            mLoader.unregisterListener(this);
        }
        mLoader.reset();
    }
    if (mPendingLoader != null) {
        mPendingLoader.destroy();
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""  Destroying: "" + this);
    mDestroyed = true;
    boolean needReset = mDeliveredData;
    mDeliveredData = false;
    if (mCallbacks != null && mLoader != null && mHaveData && needReset) {
        if (DEBUG)
            Log.v(TAG, ""  Reseting: "" + this);
        String lastBecause = null;
        if (mActivity != null) {
            lastBecause = mActivity.mFragments.mNoTransactionsBecause;
            mActivity.mFragments.mNoTransactionsBecause = ""onLoaderReset"";
        }
        try {
            mCallbacks.onLoaderReset(mLoader);
        } finally {
            if (mActivity != null) {
                mActivity.mFragments.mNoTransactionsBecause = lastBecause;
            }
        }
    }
    mCallbacks = null;
    mData = null;
    mHaveData = false;
    if (mLoader != null) {
        if (mListenerRegistered) {
            mListenerRegistered = false;
            mLoader.unregisterListener(this);
            mLoader.unregisterOnLoadCanceledListener(this);
        }
        mLoader.reset();
    }
    if (mPendingLoader != null) {
        mPendingLoader.destroy();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the new version, the method `mLoader.unregisterOnLoadCanceledListener(this);` was added. This change is not linked to return statement, exception handling, control dependency, or dependent API. So, the code change type is 4.","The additional method invocation does not alter the behavior of the API, as the return variable and exception handling are not affected. Therefore, no compatibility issue exists, and the CI type is 0."
185,"<android.database.sqlite.SQLiteDatabase: Cursor queryWithFactory(CursorFactory,boolean,String,String[],String,String[],String,String,String,String)>",15,16,"<android.database.sqlite.SQLiteDatabase: Cursor queryWithFactory(CursorFactory,boolean,String,String[],String,String[],String,String,String,String)>","<android.database.sqlite.SQLiteDatabase: Cursor queryWithFactory(CursorFactory,boolean,String,String[],String,String[],String,String,String,String)>",0,"{
    verifyDbIsOpen();
    String sql = SQLiteQueryBuilder.buildQueryString(distinct, table, columns, selection, groupBy, having, orderBy, limit);
    return rawQueryWithFactory(cursorFactory, sql, selectionArgs, findEditTable(table));
}","{
    return queryWithFactory(cursorFactory, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit, null);
}",1,"/**
 * Query the given URL, returning a {@link Cursor} over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param table The table name to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null
 * will return all rows for the given table.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in order that they
 * appear in the selection. The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * GROUP BY clause (excluding the GROUP BY itself). Passing null
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL HAVING
 * clause (excluding the HAVING itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
 * (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 * @see Cursor
 */
","/**
 * Query the given URL, returning a {@link Cursor} over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param table The table name to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null
 * will return all rows for the given table.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in order that they
 * appear in the selection. The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * GROUP BY clause (excluding the GROUP BY itself). Passing null
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL HAVING
 * clause (excluding the HAVING itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
 * (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 * @see Cursor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"Two method invocations have been replaced by a new one. The return statement now calls ""queryWithFactory"" instead of ""rawQueryWithFactory"", and the input parameters have been changed. So the code change type is 1,5.","The different method used in return will return different types of output, which may affect the behavior of the programs invoking this method. So, the CI type is 1."
186,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,15,16,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    return enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS);
}","{
    return enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS);
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS) to enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS) and the parameter type of enable() also changed, so the code change type is 1,5.","The change of return statement will lead the API to potentially return different values, so the CI type is 1."
187,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,15,16,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,0,"{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetFloatMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
        Log.d(""PropertyValuesHolder"", ""Can't find native method using JNI, use reflection"" + e);
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetFloatMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,1,"The exception handling statement 'Log.d(""PropertyValuesHolder"", ""Can't find native method using JNI, use reflection"" + e);' has been deleted in the catch block, so the change type is 2.","The removal of the Log statement within the catch block could lead to different exception handling behavior. In the late version API, it will silently swallow the NoSuchMethodError exception, whereas in the earlier version it would log an error message before doing so. Hence, the CI type is 1."
189,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,15,16,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; accessibilityId: "" + mAccessibilityViewId);
        builder.append(""; parentAccessibilityId: "" + mParentAccessibilityViewId);
        SparseIntArray childIds = mChildAccessibilityIds;
        builder.append(""; childAccessibilityIds: ["");
        for (int i = 0, count = childIds.size(); i < count; i++) {
            builder.append(childIds.valueAt(i));
            if (i < count - 1) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "" + isScrollable());
    builder.append(""; ["");
    for (int actionBits = mActions; actionBits != 0; ) {
        final int action = 1 << Integer.numberOfTrailingZeros(actionBits);
        actionBits &= ~action;
        builder.append(getActionSymbolicName(action));
        if (actionBits != 0) {
            builder.append("", "");
        }
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        SparseLongArray childIds = mChildNodeIds;
        builder.append(""; childAccessibilityIds: ["");
        for (int i = 0, count = childIds.size(); i < count; i++) {
            builder.append(childIds.valueAt(i));
            if (i < count - 1) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "" + isScrollable());
    builder.append(""; ["");
    for (int actionBits = mActions; actionBits != 0; ) {
        final int action = 1 << Integer.numberOfTrailingZeros(actionBits);
        actionBits &= ~action;
        builder.append(getActionSymbolicName(action));
        if (actionBits != 0) {
            builder.append("", "");
        }
    }
    builder.append(""]"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The return statement has changed significantly, with new method calls and variable assignments. The loop condition and control dependency under the 'if (DEBUG)' clause has also been changed. Some dependent APIs are changed too, so the code change type is 1,3,4,5.","Because the return statement has changed significantly, including new method calls, changed loop conditions and variable assignments, this could potentially lead to the API returning a different value or type. Therefore, the CI type is 1."
190,<android.webkit.WebSettings: void setSavePassword(boolean)>,15,16,<android.webkit.WebSettings: void setSavePassword(boolean)>,<android.webkit.WebSettings: void setSavePassword(boolean)>,0,"{
    mSavePassword = save;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Store whether the WebView is saving password.
 */
","/**
 * Stores whether the WebView is saving password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"In the late implementation, the old statement setting 'mSavePassword' has been deleted, and a new exception throwing statement has been introduced, so the code change type is 2.","The introduction of a new exception (MustOverrideException) will cause different exception handling in the late version compared to the early version when this API is invoked, so the CI type is 2."
191,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,15,16,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,0,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"The control dependency (switch statement) has changed in the late version, two new cases are added. Hence, the code change type is 3,1.","The changes in the switch-case structure can lead to the method returning a different string value depending on the flag input value. Thus, the method potentially returns different values, making the CI type 1."
192,"<android.widget.AbsListView: boolean performItemClick(View,int,long)>",15,16,"<android.widget.AbsListView: boolean performItemClick(View,int,long)>","<android.widget.AbsListView: boolean performItemClick(View,int,long)>",0,"{
    boolean handled = false;
    boolean dispatchItemClick = true;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE || (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null)) {
            boolean newValue = !mCheckStates.get(position, false);
            mCheckStates.put(position, newValue);
            if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                if (newValue) {
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                } else {
                    mCheckedIdStates.delete(mAdapter.getItemId(position));
                }
            }
            if (newValue) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
            if (mChoiceActionMode != null) {
                mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, newValue);
                dispatchItemClick = false;
            }
        } else if (mChoiceMode == CHOICE_MODE_SINGLE) {
            boolean newValue = !mCheckStates.get(position, false);
            if (newValue) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
                if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                    mCheckedIdStates.clear();
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                }
                mCheckedItemCount = 1;
            } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
                mCheckedItemCount = 0;
            }
        }
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
    if (dispatchItemClick) {
        handled |= super.performItemClick(view, position, id);
    }
    return handled;
}","{
    boolean handled = false;
    boolean dispatchItemClick = true;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        boolean checkedStateChanged = false;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE || (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null)) {
            boolean newValue = !mCheckStates.get(position, false);
            mCheckStates.put(position, newValue);
            if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                if (newValue) {
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                } else {
                    mCheckedIdStates.delete(mAdapter.getItemId(position));
                }
            }
            if (newValue) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
            if (mChoiceActionMode != null) {
                mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, newValue);
                dispatchItemClick = false;
            }
            checkedStateChanged = true;
        } else if (mChoiceMode == CHOICE_MODE_SINGLE) {
            boolean newValue = !mCheckStates.get(position, false);
            if (newValue) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
                if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                    mCheckedIdStates.clear();
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                }
                mCheckedItemCount = 1;
            } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
                mCheckedItemCount = 0;
            }
            checkedStateChanged = true;
        }
        if (checkedStateChanged) {
            updateOnScreenCheckedViews();
        }
    }
    if (dispatchItemClick) {
        handled |= super.performItemClick(view, position, id);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The condition statement of if (mChoiceMode != CHOICE_MODE_NONE) changed, and a new variable 'checkedStateChanged' and an new statement 'updateOnScreenCheckedViews();' were added on the code, so it's a control dependency change(type 3). Also another variable 'dispatchItemClick' is added on the last two lines, so there is also other statement change (type 4).","The changes in the condition statement and new statements potentially cause the API to return a different variable (because the final result depends on the new variable 'handled', which might be affected by the new variable 'dispatchItemClick'), therefore, the CI type is 1."
193,<android.speech.tts.TextToSpeech: int stop()>,15,16,<android.speech.tts.TextToSpeech: int stop()>,<android.speech.tts.TextToSpeech: int stop()>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.stop(getPackageName());
        }
    }, ERROR, ""stop"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.stop(getCallerIdentity());
        }
    }, ERROR, ""stop"");
}",1,"/**
 * Interrupts the current utterance (whether played or rendered to file) and discards other
 * utterances in the queue.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Interrupts the current utterance (whether played or rendered to file) and discards other
 * utterances in the queue.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent method service.stop() has changed its parameter from getPackageName() to getCallerIdentity(), indicating a change in return statement and dependent API. Hence, the categories of code changes are 1,5.","Due to the change of the parameter inside the stop() method, the return value of run(ITextToSpeechService service) could be different, causing a potential Compatibility Issue of returning a different value (CI type: 1)."
197,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String)>",15,16,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String)>","<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String)>",0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        return null;
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Cursor qCursor = provider.query(uri, projection, selection, selectionArgs, sortOrder);
        if (qCursor == null) {
            releaseProvider(provider);
            return null;
        }
        // force query execution
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object
        return new CursorWrapperInner(qCursor, provider);
    } catch (RemoteException e) {
        releaseProvider(provider);
        // Manager will kill this process shortly anyway.
        return null;
    } catch (RuntimeException e) {
        releaseProvider(provider);
        throw e;
    }
}","{
    return query(uri, projection, selection, selectionArgs, sortOrder, null);
}",1,"/**
 * <p>
 * Query the given URI, returning a {@link Cursor} over the result set.
 * </p>
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * <p>
 * Query the given URI, returning a {@link Cursor} over the result set.
 * </p>
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 4",1,"The entire body of the method was replaced with a different return statement calling a modified version of the query. This largely changes the flow of the API but the signature still remains the same, so it will classified as Return Statement changed and Other statement changed.","As a result of the changes in the implementation, this might potentially cause the API to return a different Cursor object than the earlier version. This identifies as a compatibility issue caused by potential difference in return values or types."
198,"<android.view.GLES20Canvas: boolean quickReject(RectF,EdgeType)>",15,16,"<android.view.GLES20Canvas: boolean quickReject(RectF,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(RectF,EdgeType)>",0,"{
    return quickReject(rect.left, rect.top, rect.right, rect.bottom, type);
}","{
    return nQuickReject(mRenderer, rect.left, rect.top, rect.right, rect.bottom, type.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API quickReject() has changed to its native implementation nQuickReject() with additional parameters. Therefore, the code change type is 1,5.","The dependent API changes, and thus the return statement is also changed. The late version API may return different value. Therefore, the CI type is 1."
199,"<android.view.KeyCharacterMap: int get(int,int)>",15,16,"<android.view.KeyCharacterMap: int get(int,int)>","<android.view.KeyCharacterMap: int get(int,int)>",0,"{
    metaState = KeyEvent.normalizeMetaState(metaState);
    char ch = nativeGetCharacter(mPtr, keyCode, metaState);
    int map = COMBINING.get(ch);
    if (map != 0) {
        return map;
    } else {
        return ch;
    }
}","{
    metaState = KeyEvent.normalizeMetaState(metaState);
    char ch = nativeGetCharacter(mPtr, keyCode, metaState);
    int map = sCombiningToAccent.get(ch);
    if (map != 0) {
        return map | COMBINING_ACCENT;
    } else {
        return ch;
    }
}",1,"/**
 * Gets the Unicode character generated by the specified key and meta
 * key state combination.
 * <p>
 * Returns the Unicode character that the specified key would produce
 * when the specified meta bits (see {@link MetaKeyKeyListener})
 * were active.
 * </p><p>
 * Returns 0 if the key is not one that is used to type Unicode
 * characters.
 * </p><p>
 * If the return value has bit {@link #COMBINING_ACCENT} set, the
 * key is a ""dead key"" that should be combined with another to
 * actually produce a character -- see {@link #getDeadChar} --
 * after masking with {@link #COMBINING_ACCENT_MASK}.
 * </p>
 *
 * @param keyCode The key code.
 * @param metaState The meta key modifier state.
 * @return The associated character or combining accent, or 0 if none.
 */
","/**
 * Gets the Unicode character generated by the specified key and meta
 * key state combination.
 * <p>
 * Returns the Unicode character that the specified key would produce
 * when the specified meta bits (see {@link MetaKeyKeyListener})
 * were active.
 * </p><p>
 * Returns 0 if the key is not one that is used to type Unicode
 * characters.
 * </p><p>
 * If the return value has bit {@link #COMBINING_ACCENT} set, the
 * key is a ""dead key"" that should be combined with another to
 * actually produce a character -- see {@link #getDeadChar} --
 * after masking with {@link #COMBINING_ACCENT_MASK}.
 * </p>
 *
 * @param keyCode The key code.
 * @param metaState The meta key modifier state.
 * @return The associated character or combining accent, or 0 if none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The statement `int map = COMBINING.get(ch);` in the early version has been changed to `int map = sCombiningToAccent.get(ch);` in the late version, where not only the variable reference has changed, but also the dependent API get() is changed due to this change. Thus the code change type is 1,4,5.","The change in the return statement and dependent API may cause the method return different value comparing with early version, thus there's compatibility issue caused by potential different return values, so the CI type is 1."
201,"<android.os.MessageQueue: void removeMessages(Handler,Runnable,Object)>",15,16,"<android.os.MessageQueue: void removeMessages(Handler,Runnable,Object)>","<android.os.MessageQueue: void removeMessages(Handler,Runnable,Object)>",0,"{
    if (r == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && p.callback == r && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && n.callback == r && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}","{
    if (h == null || r == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && p.callback == r && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && n.callback == r && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition of the if statement at the start of the method has changed from (r == null) to (h == null || r == null), hence the code change type is 3.","The change in the API is related to the condition under which it returns without performing any operations. This doesn't affect the return values or the exceptions thrown by the method. Therefore, no compatibility issue exists, and the type is 0."
203,<android.database.sqlite.SQLiteDatabase: SQLiteStatement compileStatement(String)>,15,16,<android.database.sqlite.SQLiteDatabase: SQLiteStatement compileStatement(String)>,<android.database.sqlite.SQLiteDatabase: SQLiteStatement compileStatement(String)>,0,"{
    verifyDbIsOpen();
    return new SQLiteStatement(this, sql, null);
}","{
    acquireReference();
    try {
        return new SQLiteStatement(this, sql, null);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Compiles an SQL statement into a reusable pre-compiled statement object.
 * The parameters are identical to {@link #execSQL(String)}. You may put ?s in the
 * statement and fill in those values with {@link SQLiteProgram#bindString}
 * and {@link SQLiteProgram#bindLong} each time you want to run the
 * statement. Statements may not return result sets larger than 1x1.
 * <p>
 * No two threads should be using the same {@link SQLiteStatement} at the same time.
 *
 * @param sql The raw SQL statement, may contain ? for unknown values to be
 * bound later.
 * @return A pre-compiled {@link SQLiteStatement} object. Note that
 * {@link SQLiteStatement}s are not synchronized, see the documentation for more details.
 */
","/**
 * Compiles an SQL statement into a reusable pre-compiled statement object.
 * The parameters are identical to {@link #execSQL(String)}. You may put ?s in the
 * statement and fill in those values with {@link SQLiteProgram#bindString}
 * and {@link SQLiteProgram#bindLong} each time you want to run the
 * statement. Statements may not return result sets larger than 1x1.
 * <p>
 * No two threads should be using the same {@link SQLiteStatement} at the same time.
 *
 * @param sql The raw SQL statement, may contain ? for unknown values to be
 * bound later.
 * @return A pre-compiled {@link SQLiteStatement} object. Note that
 * {@link SQLiteStatement}s are not synchronized, see the documentation for more details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2, 4",0,"In the Late_Implementation, the API introduce two reference handling method 'acquireReference()' and 'releaseReference()' in a try-finally block, while the Early_Implementation does not involve these method. This identifies the exception handling changes (into category 2) and other statements changes (into category 4). ","In terms of compatibility issue, although the Late Implementation introduces acquireReference() and releaseReference(), they don't affect the actual return value or exceptions of this method, which means no Compatibility Issue (into category 0) is introduced by those changes."
206,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",15,16,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter list of method ActivityManagerNative.getDefault().broadcastIntent() has changed with the introduction of a new parameter 'Binder.getOrigCallingUser()'. This constitutes a change type of 1,5.","With the introduction of a new parameter to the method call, the return value of this method could potentially be different. Therefore, the change leads to a potential compatibility issue type of 1 (Compatibility Issue caused by potential different return values or types)."
207,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,15,16,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,<android.view.TextureView: Bitmap getBitmap(Bitmap)>,0,"{
    if (bitmap != null && isAvailable()) {
        AttachInfo info = mAttachInfo;
        if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled()) {
            if (!info.mHardwareRenderer.validate()) {
                throw new IllegalStateException(""Could not acquire hardware rendering context"");
            }
        }
        applyUpdate();
        applyTransformMatrix();
        mLayer.copyInto(bitmap);
    }
    return bitmap;
}","{
    if (bitmap != null && isAvailable()) {
        AttachInfo info = mAttachInfo;
        if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled()) {
            if (!info.mHardwareRenderer.validate()) {
                throw new IllegalStateException(""Could not acquire hardware rendering context"");
            }
        }
        applyUpdate();
        applyTransformMatrix();
        // this method
        if (mLayer == null && mUpdateSurface) {
            getHardwareLayer();
        }
        if (mLayer != null) {
            mLayer.copyInto(bitmap);
        }
    }
    return bitmap;
}",1,"/**
 * <p>Copies the content of this view's surface texture into the specified
 * bitmap. If the surface texture is not available, the copy is not executed.
 * The content of the surface texture will be scaled to fit exactly inside
 * the specified bitmap.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs, the bitmap is left unchanged.</p>
 *
 * @param bitmap The bitmap to copy the content of the surface texture into,
 * cannot be null, all configurations are supported
 *
 * @return The bitmap specified as a parameter
 *
 * @see #isAvailable()
 * @see #getBitmap(int, int)
 * @see #getBitmap()
 *
 * @throws IllegalStateException if the hardware rendering context cannot be
 * acquired to capture the bitmap
 */
","/**
 * <p>Copies the content of this view's surface texture into the specified
 * bitmap. If the surface texture is not available, the copy is not executed.
 * The content of the surface texture will be scaled to fit exactly inside
 * the specified bitmap.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs, the bitmap is left unchanged.</p>
 *
 * @param bitmap The bitmap to copy the content of the surface texture into,
 * cannot be null, all configurations are supported
 *
 * @return The bitmap specified as a parameter
 *
 * @see #isAvailable()
 * @see #getBitmap(int, int)
 * @see #getBitmap()
 *
 * @throws IllegalStateException if the hardware rendering context cannot be
 * acquired to capture the bitmap
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version of the code has been changed with the introduction of if (mLayer == null && mUpdateSurface) { getHardwareLayer(); } and if (mLayer != null) { mLayer.copyInto(bitmap); }. This denotes that there is a change in the control dependency (if statement) as well as other statements (mLayer.copyInto(bitmap)), hence the code change types are 3 and 4.","No compatibility issue exists in the given API between two versions because the change in the code will not impact the value returned by the API or bring about any new exceptions. Therefore, the CI type is 0."
208,<android.widget.TextView: Parcelable onSaveInstanceState()>,15,16,<android.widget.TextView: Parcelable onSaveInstanceState()>,<android.widget.TextView: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            removeMisspelledSpans(sp);
            sp.removeSpan(mSuggestionRangeSpan);
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = mError;
        return ss;
    }
    return superState;
}","{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            if (mEditor != null) {
                removeMisspelledSpans(sp);
                sp.removeSpan(mEditor.mSuggestionRangeSpan);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        return ss;
    }
    return superState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"Beside the change in control dependency ('if (mEditor != null)'), the return statement has also changed ('ss.error = getError();'), and a method called by the API implementation ('getError()') is also different. Therefore, the change type should be classified as 1, 3 and 5.","As the return statement of saving state changes in the late version API, it is possible that the API will return a different value. Thus the CI type is 1."
210,<android.speech.tts.TextToSpeechService.AudioSpeechItem: int playImpl()>,15,16,<android.speech.tts.TextToSpeechService.AudioSpeechItem: int playImpl()>,<android.speech.tts.TextToSpeechService.AudioSpeechItem: int playImpl()>,0,"{
    mToken = new AudioMessageParams(this, getCallingApp(), mPlayer);
    mAudioPlaybackHandler.enqueueAudio(mToken);
    return TextToSpeech.SUCCESS;
}","{
    mAudioPlaybackHandler.enqueue(mItem);
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method of 'enqueueAudio()' has been changed to 'enqueue()' and the parameters of the calling method have also changed, so the code change type is 4,5.","Changing the method and its parameters from 'enqueueAudio(mToken)' to 'enqueue(mItem)' may potentially affect the behavior of the API and cause it to return different values, so the CI type is 1."
211,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",15,16,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String key;
                key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(filename, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                Parcelable[] result = getVolumeList();
                reply.writeNoException();
                reply.writeParcelableArray(result, 0);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String key;
                key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(filename, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                Parcelable[] result = getVolumeList();
                reply.writeNoException();
                reply.writeParcelableArray(result, 0);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
212,<android.webkit.WebView: void requestImageRef(Message)>,15,16,<android.webkit.WebView: void requestImageRef(Message)>,<android.webkit.WebView: void requestImageRef(Message)>,0,"{
    checkThread();
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    int contentX = viewToContentX(mLastTouchX + mScrollX);
    int contentY = viewToContentY(mLastTouchY + mScrollY);
    String ref = nativeImageURI(contentX, contentY);
    Bundle data = msg.getData();
    data.putString(""url"", ref);
    msg.setData(data);
    msg.sendToTarget();
}","{
    checkThread();
    mProvider.requestImageRef(msg);
}",1,"/**
 * Request the url of the image last touched by the user. msg will be sent
 * to its target with a String representing the url as its object.
 *
 * @param msg This message will be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
","/**
 * Requests the URL of the image last touched by the user. msg will be sent
 * to its target with a String representing the URL as its object.
 *
 * @param msg the message to be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire body of the method has been replaced, with a new method call to mProvider.requestImageRef(msg). That means both return statement and dependent API have changed. So the code change type is 1,5.","The change of method implementation can make this method return different values. They no longer have the entire calculation process but call another function directly. Therefore, the CI type is 1."
213,<android.os.ServiceManagerProxy: String[] listServices()>,15,16,<android.os.ServiceManagerProxy: String[] listServices()>,<android.os.ServiceManagerProxy: String[] listServices()>,0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IServiceManager.descriptor);
    mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0);
    String[] list = reply.readStringArray();
    reply.recycle();
    data.recycle();
    return list;
}","{
    ArrayList<String> services = new ArrayList<String>();
    int n = 0;
    while (true) {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeInt(n);
        n++;
        try {
            boolean res = mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0);
            if (!res) {
                break;
            }
        } catch (RuntimeException e) {
            // returning a nice result...  so eat it here and go on.
            break;
        }
        services.add(reply.readString());
        reply.recycle();
        data.recycle();
    }
    String[] array = new String[services.size()];
    services.toArray(array);
    return array;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",Several changes are detected here: ,    3) Control structures (while-loop) have been added.
215,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,15,16,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,0,"{
    switch(eventType) {
        case TYPE_VIEW_CLICKED:
            return ""TYPE_VIEW_CLICKED"";
        case TYPE_VIEW_LONG_CLICKED:
            return ""TYPE_VIEW_LONG_CLICKED"";
        case TYPE_VIEW_SELECTED:
            return ""TYPE_VIEW_SELECTED"";
        case TYPE_VIEW_FOCUSED:
            return ""TYPE_VIEW_FOCUSED"";
        case TYPE_VIEW_TEXT_CHANGED:
            return ""TYPE_VIEW_TEXT_CHANGED"";
        case TYPE_WINDOW_STATE_CHANGED:
            return ""TYPE_WINDOW_STATE_CHANGED"";
        case TYPE_VIEW_HOVER_ENTER:
            return ""TYPE_VIEW_HOVER_ENTER"";
        case TYPE_VIEW_HOVER_EXIT:
            return ""TYPE_VIEW_HOVER_EXIT"";
        case TYPE_NOTIFICATION_STATE_CHANGED:
            return ""TYPE_NOTIFICATION_STATE_CHANGED"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_START:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_START"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_END:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_END"";
        case TYPE_WINDOW_CONTENT_CHANGED:
            return ""TYPE_WINDOW_CONTENT_CHANGED"";
        case TYPE_VIEW_TEXT_SELECTION_CHANGED:
            return ""TYPE_VIEW_TEXT_SELECTION_CHANGED"";
        case TYPE_VIEW_SCROLLED:
            return ""TYPE_VIEW_SCROLLED"";
        default:
            return null;
    }
}","{
    switch(eventType) {
        case TYPE_VIEW_CLICKED:
            return ""TYPE_VIEW_CLICKED"";
        case TYPE_VIEW_LONG_CLICKED:
            return ""TYPE_VIEW_LONG_CLICKED"";
        case TYPE_VIEW_SELECTED:
            return ""TYPE_VIEW_SELECTED"";
        case TYPE_VIEW_FOCUSED:
            return ""TYPE_VIEW_FOCUSED"";
        case TYPE_VIEW_TEXT_CHANGED:
            return ""TYPE_VIEW_TEXT_CHANGED"";
        case TYPE_WINDOW_STATE_CHANGED:
            return ""TYPE_WINDOW_STATE_CHANGED"";
        case TYPE_VIEW_HOVER_ENTER:
            return ""TYPE_VIEW_HOVER_ENTER"";
        case TYPE_VIEW_HOVER_EXIT:
            return ""TYPE_VIEW_HOVER_EXIT"";
        case TYPE_NOTIFICATION_STATE_CHANGED:
            return ""TYPE_NOTIFICATION_STATE_CHANGED"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_START:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_START"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_END:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_END"";
        case TYPE_WINDOW_CONTENT_CHANGED:
            return ""TYPE_WINDOW_CONTENT_CHANGED"";
        case TYPE_VIEW_TEXT_SELECTION_CHANGED:
            return ""TYPE_VIEW_TEXT_SELECTION_CHANGED"";
        case TYPE_VIEW_SCROLLED:
            return ""TYPE_VIEW_SCROLLED"";
        case TYPE_ANNOUNCEMENT:
            return ""TYPE_ANNOUNCEMENT"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUSED"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"";
        case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
            return ""TYPE_CURRENT_AT_GRANULARITY_MOVEMENT_CHANGED"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
","/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The 'switch' statement has been changed with the introduction of new 'case' blocks, which also lead to a change in the return statements. Therefore, the code change type is 1,3.","The introduction of new 'case' blocks in the 'switch' statement can potentially make the API return different values. Hence, the CI type is 1."
217,"<android.hardware.Camera.Parameters: void set(String,String)>",15,16,"<android.hardware.Camera.Parameters: void set(String,String)>","<android.hardware.Camera.Parameters: void set(String,String)>",0,"{
    if (key.indexOf('=') != -1 || key.indexOf(';') != -1) {
        Log.e(TAG, ""Key \"""" + key + ""\"" contains invalid character (= or ;)"");
        return;
    }
    if (value.indexOf('=') != -1 || value.indexOf(';') != -1) {
        Log.e(TAG, ""Value \"""" + value + ""\"" contains invalid character (= or ;)"");
        return;
    }
    mMap.put(key, value);
}","{
    if (key.indexOf('=') != -1 || key.indexOf(';') != -1 || key.indexOf(0) != -1) {
        Log.e(TAG, ""Key \"""" + key + ""\"" contains invalid character (= or ; or \\0)"");
        return;
    }
    if (value.indexOf('=') != -1 || value.indexOf(';') != -1 || value.indexOf(0) != -1) {
        Log.e(TAG, ""Value \"""" + value + ""\"" contains invalid character (= or ; or \\0)"");
        return;
    }
    mMap.put(key, value);
}",1,"/**
 * Sets a String parameter.
 *
 * @param key   the key name for the parameter
 * @param value the String value of the parameter
 */
","/**
 * Sets a String parameter.
 *
 * @param key   the key name for the parameter
 * @param value the String value of the parameter
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"In the control dependency statement, the part of the conditions in the 'if' has changed with the addition of '|| key.indexOf(0) != -1' and '|| value.indexOf(0) != -1'. Therefore, the code change type is 3.","With the change in the conditions, the corresponding return statements under the 'if' control statement, might now be reached under different circumstances. Therefore, the function might potentially return (which means the function terminates) in different situations when compared between the versions, leading to a different behavior of the API. Thus CI type is 1."
218,<android.view.WindowOrientationListener.SensorEventListenerImpl: int getProposedRotation()>,15,16,<android.view.WindowOrientationListener.SensorEventListenerImpl: int getProposedRotation()>,<android.view.WindowOrientationListener.SensorEventListenerImpl: int getProposedRotation()>,0,"{
    return mProposalAgeMS >= SETTLE_TIME_MS ? mProposalRotation : -1;
}","{
    return mProposedRotation;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The 'if' control statement mProposalAgeMS >= SETTLE_TIME_MS is removed and the return statement has been simplified to return mProposedRotation directly, so the code change type is 1,3.","The removal of the 'if' control statement and the change in the return statement can lead to a different returned value from the method if mProposalAgeMS < SETTLE_TIME_MS, so the CI type is 1."
219,<android.webkit.WebSettings: void setDefaultTextEncodingName(String)>,15,16,<android.webkit.WebSettings: void setDefaultTextEncodingName(String)>,<android.webkit.WebSettings: void setDefaultTextEncodingName(String)>,0,"{
    if (encoding != null && !encoding.equals(mDefaultTextEncoding)) {
        mDefaultTextEncoding = encoding;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the default text encoding name to use when decoding html pages.
 * @param encoding The text encoding name.
 */
","/**
 * Sets the default text encoding name to use when decoding html pages.
 * The default is ""Latin-1"".
 *
 * @param encoding the text encoding name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"A throw statement is introduced in the late version, and some statements are deleted, so the code change type is 2,4.","The newly introduced throw statement could cause the late version API to have different exception handling than the early version. Therefore, the CI type is 2."
220,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,15,16,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,0,"{
    synchronized (mIMM.mH) {
        Handler h = mTargetView != null ? mTargetView.getHandler() : null;
        if (h == null) {
            if (mIMM.mServedView != null) {
                h = mIMM.mServedView.getHandler();
            }
        }
        if (h != null) {
            h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, event));
        }
    }
    return false;
}","{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    return false;
}",1,"/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
","/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"Several variables and used methods have been changed from .getHandler() method to .getViewRootImpl() method and from h.sendMessage() method to viewRootImpl.dispatchKeyFromIme(), so the code change type is 4,5.","Although there are several changes in this method, it does not lead to a compatibility issue because the return value and exceptions haven't been affected by these changes. Thus, there is no compatibility issue."
222,"<android.app.ApplicationPackageManager: ActivityInfo getActivityInfo(ComponentName,int)>",15,16,"<android.app.ApplicationPackageManager: ActivityInfo getActivityInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ActivityInfo getActivityInfo(ComponentName,int)>",0,"{
    try {
        ActivityInfo ai = mPM.getActivityInfo(className, flags);
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ActivityInfo ai = mPM.getActivityInfo(className, flags, UserId.myUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called to get 'ai' has changed from mPM.getActivityInfo(className, flags) in the early version to mPM.getActivityInfo(className, flags, UserId.myUserId()) in the late version. This change indicates a change in the return statement and also a change in the dependent API, so the change type is 1,5.","The method called to get 'ai' has changed, thus, it may get a different 'ai', and possibly return a different activity info. Thus, the CI type is 1."
223,<android.widget.TextView: int[] onCreateDrawableState(int)>,15,16,<android.widget.TextView: int[] onCreateDrawableState(int)>,<android.widget.TextView: int[] onCreateDrawableState(int)>,0,"{
    final int[] drawableState;
    if (mSingleLine) {
        drawableState = super.onCreateDrawableState(extraSpace);
    } else {
        drawableState = super.onCreateDrawableState(extraSpace + 1);
        mergeDrawableStates(drawableState, MULTILINE_STATE_SET);
    }
    if (mTextIsSelectable) {
        // Disable pressed state, which was introduced when TextView was made clickable.
        // Prevents text color change.
        // setClickable(false) would have a similar effect, but it also disables focus changes
        // and long press actions, which are both needed by text selection.
        final int length = drawableState.length;
        for (int i = 0; i < length; i++) {
            if (drawableState[i] == R.attr.state_pressed) {
                final int[] nonPressedState = new int[length - 1];
                System.arraycopy(drawableState, 0, nonPressedState, 0, i);
                System.arraycopy(drawableState, i + 1, nonPressedState, i, length - i - 1);
                return nonPressedState;
            }
        }
    }
    return drawableState;
}","{
    final int[] drawableState;
    if (mSingleLine) {
        drawableState = super.onCreateDrawableState(extraSpace);
    } else {
        drawableState = super.onCreateDrawableState(extraSpace + 1);
        mergeDrawableStates(drawableState, MULTILINE_STATE_SET);
    }
    if (isTextSelectable()) {
        // Disable pressed state, which was introduced when TextView was made clickable.
        // Prevents text color change.
        // setClickable(false) would have a similar effect, but it also disables focus changes
        // and long press actions, which are both needed by text selection.
        final int length = drawableState.length;
        for (int i = 0; i < length; i++) {
            if (drawableState[i] == R.attr.state_pressed) {
                final int[] nonPressedState = new int[length - 1];
                System.arraycopy(drawableState, 0, nonPressedState, 0, i);
                System.arraycopy(drawableState, i + 1, nonPressedState, i, length - i - 1);
                return nonPressedState;
            }
        }
    }
    return drawableState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The variable 'mTextIsSelectable' is replaced by a method call 'isTextSelectable()', which is a dependent API change, thus the code change type is 5.","As the method 'isTextSelectable()' could potentially return a different value to 'mTextIsSelectable', this can eventually lead to a different return from the 'onCreateDrawableState()' method, thus the CI type is 1."
226,<android.app.FragmentManagerImpl: Fragment findFragmentByTag(String)>,15,16,<android.app.FragmentManagerImpl: Fragment findFragmentByTag(String)>,<android.app.FragmentManagerImpl: Fragment findFragmentByTag(String)>,0,"{
    if (mActive != null && tag != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    return null;
}","{
    if (mAdded != null && tag != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    if (mActive != null && tag != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && tag.equals(f.mTag)) {
                return f;
            }
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The change in the control statement condition (from 'mActive != null && tag != null' to 'mAdded != null && tag != null', and 'mActive != null && tag != null'), signifies that there is a control dependency change.","Because of the change in the control condition 'if', the method may not return the same results for the same inputs as it previously did, thus introducing a compatibility issue of the type ""Compatibility Issue caused by potential different return values or types"" (type 1)."
227,"<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",15,16,"<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>","<android.view.inputmethod.InputMethodSubtype: CharSequence getDisplayName(Context,String,ApplicationInfo)>",0,"{
    final Locale locale = constructLocaleFromString(mSubtypeLocale);
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        return String.format(subtypeName.toString(), localeStr);
    } else {
        return localeStr;
    }
}","{
    final Locale locale = constructLocaleFromString(mSubtypeLocale);
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        final String replacementString = containsExtraValueKey(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) ? getExtraValueOf(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) : localeStr;
        try {
            return String.format(subtypeName.toString(), replacementString != null ? replacementString : """");
        } catch (IllegalFormatException e) {
            Slog.w(TAG, ""Found illegal format in subtype name("" + subtypeName + ""): "" + e);
            return """";
        }
    } else {
        return localeStr;
    }
}",1,"/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the IME
 * @param appInfo The application info of the IME
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * can have only one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method simply returns the string
 * specified by mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the
 * framework to generate an appropriate display name.
 */
","/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the IME
 * @param appInfo The application info of the IME
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * may have exactly one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method returns the string specified by
 * mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the framework to
 * generate an appropriate display name.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","In the new version, a new condition check using the function containsExtraValueKey() and getExtraValueOf() has been added to define the value of the 'replacementString', a variable that is returned after string formatting (Return statement changed: type 1). Also, a new exception handling for IllegalFormatException has been introduced (type 2). Therefore, the code change types are 1,2,3.","With the changes, there could be different return values based on the new condition check and the handling of a possible IllegalFormatException. If the exception is thrown, an empty String is returned instead of throwing the exception forward to be handled. This would lead to different behaviors in the API (type 1,2)."
228,"<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>",15,16,"<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>","<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>",0,"{
    try {
        return mPM.resolveContentProvider(name, flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.resolveContentProvider(name, flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"There is a change in the return statement from mPM.resolveContentProvider(name, flags) to mPM.resolveContentProvider(name, flags, UserId.myUserId()). Additionally, the dependent API (mPM.resolveContentProvider()) changed its parameter list by adding an extra parameter - UserId.myUserId(). So, the type of change is 1,5.","As a result of the updated return statement and the added parameter in the dependent API call, the method might return a different ProviderInfo in the new version if the UserId is different. Thus, this change could lead to a compatibility issue of type 1."
229,<android.webkit.WebViewDatabase: boolean hasHttpAuthUsernamePassword()>,15,16,<android.webkit.WebViewDatabase: boolean hasHttpAuthUsernamePassword()>,<android.webkit.WebViewDatabase: boolean hasHttpAuthUsernamePassword()>,0,"{
    synchronized (mHttpAuthLock) {
        return hasEntries(TABLE_HTTPAUTH_ID);
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Find out if there are any HTTP authentication passwords saved.
 *
 * @return TRUE if there are passwords saved
 */
","/**
 * Gets whether there are any HTTP authentication username/password combinations saved.
 *
 * @return true if there are any HTTP authentication username/passwords saved
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been completely replaced by a new statement throwing an exception, so the change type is 1,2.","Since the late version throws a new exception instead of returning a value and also removes the original return statement, it is a compatibility issue which is of type 1,2."
230,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,15,16,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float y = ev.getY(pointerIndex);
                final int yDiff = (int) Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The type of 'y' variable changed from 'float' to 'int'. There is a new statement 'parent.requestDisallowInterceptTouchEvent(true);' that changes the behavior of parents of this view and the statement 'invalidate();' has changed to 'postInvalidateOnAnimation();'. Hence the code change type is 3,4.","The condition of whether to initiate drag in 'ACTION_MOVE' case has changed and a postInvalidateOnAnimation() has been replaced with invalidate(). These changes potentially change the return value of the method, affect rendering and influence whether scroll event will be handled by this or its parent view. Therefore, the CI type is 1."
231,<android.webkit.WebSettings: int getDefaultFontSize()>,15,16,<android.webkit.WebSettings: int getDefaultFontSize()>,<android.webkit.WebSettings: int getDefaultFontSize()>,0,"{
    return mDefaultFontSize;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the default font size. The default is 16.
 * @return A non-negative integer between 1 and 72.
 */
","/**
 * Gets the default font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setDefaultFontSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been replaced by a new 'throw' statement in the late version, so the code change type is 1,2.","The removed return statement from the early version and the new exception handling in the late version implies that the method behaves significantly different. This would cause not only a different return, but also a different exception handling, and thus, the CI type is 1,2."
232,<android.webkit.WebHistoryItem: String getUrl()>,15,16,<android.webkit.WebHistoryItem: String getUrl()>,<android.webkit.WebHistoryItem: String getUrl()>,0,"{
    return mUrl;
}","{
    if (mNativeBridge == 0)
        return null;
    return nativeGetUrl(mNativeBridge);
}",1,"/**
 * Return the url of this history item. The url is the base url of this
 * history item. See getTargetUrl() for the url that is the actual target of
 * this history item.
 * @return The base url of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */
","/**
 * Return the url of this history item. The url is the base url of this
 * history item. See getTargetUrl() for the url that is the actual target of
 * this history item.
 * @return The base url of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement ""return mUrl;"" has been replaced by an ""if"" control statement and a new return statement ""return nativeGetUrl(mNativeBridge);"", so the code change type is 1,3 (Return statement changed, Control dependency changed).","Due to the insertion of an ""if"" control statement, the method can potentially return a null now which wasn't possible in the early version. This difference in return values leads to a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
233,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>",15,16,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>","<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>",0,"{
    return mContentProvider.openAssetFile(url, mode);
}","{
    try {
        return mContentProvider.openAssetFile(url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An additional try-catch block that throws ""DeadObjectException"" when calling ""mContentProvider.openAssetFile(url, mode);"" and an extra conditional statement are present in the newer version, so the code change type is 2,4.","In the later version of the API, as a new exception 'DeadObjectException' is introduced, which was not present in the early version, this may cause the API to behave differently. Hence, the CI type is 2."
234,"<android.widget.GridLayout: Alignment getAlignment(Alignment,boolean)>",15,16,"<android.widget.GridLayout: Alignment getAlignment(Alignment,boolean)>","<android.widget.GridLayout: Alignment getAlignment(Alignment,boolean)>",0,"{
    return (alignment != UNDEFINED_ALIGNMENT) ? alignment : (horizontal ? LEFT : BASELINE);
}","{
    return (alignment != UNDEFINED_ALIGNMENT) ? alignment : (horizontal ? START : BASELINE);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The condition of the ternary operation changed from (horizontal ? LEFT : BASELINE) to (horizontal ? START : BASELINE), so the code change type is 1.","Because of the modified return statement, the API potentially returns a different value, hence the CI type is 1."
235,<android.webkit.WebView: String getUrl()>,15,16,<android.webkit.WebView: String getUrl()>,<android.webkit.WebView: String getUrl()>,0,"{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getUrl() : null;
}","{
    checkThread();
    return mProvider.getUrl();
}",1,"/**
 * Get the url for the current page. This is not always the same as the url
 * passed to WebViewClient.onPageStarted because although the load for
 * that url has begun, the current page may not have changed.
 * @return The url for the current page.
 */
","/**
 * Gets the URL for the current page. This is not always the same as the URL
 * passed to WebViewClient.onPageStarted because although the load for
 * that URL has begun, the current page may not have changed.
 *
 * @return the URL for the current page
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return path has been changed by replacing the retrieval of the URL via mCallbackProxy.getBackForwardList().getCurrentItem().getUrl() with mProvider.getUrl(). This falls under both ""Return Statement Changed"" (1) and ""Other Statement Changed"" (4). ","Due to the change in return statement and how the URL value is retrieved, depending on the state of mProvider and mCallbackProxy, there could be potential differences in return values. Therefore, a CI exists categorized by ""Compatibility Issue caused by potential different return values or types"" (1)."
236,<android.nfc.NdefMessage: NdefRecord[] getRecords()>,15,16,<android.nfc.NdefMessage: NdefRecord[] getRecords()>,<android.nfc.NdefMessage: NdefRecord[] getRecords()>,0,"{
    return mRecords.clone();
}","{
    return mRecords;
}",1,"/**
 * Get the NDEF records inside this NDEF message.
 *
 * @return array of zero or more NDEF records.
 */
","/**
 * Get the NDEF Records inside this NDEF Message.<p>
 * An {@link NdefMessage} always has one or more NDEF Records: so the
 * following code to retrieve the first record is always safe
 * (no need to check for null or array length >= 1):
 * <pre>
 * NdefRecord firstRecord = ndefMessage.getRecords()[0];
 * </pre>
 *
 * @return array of one or more NDEF records.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning a cloned copy of mRecords array to returning the mRecords array directly. So, the change type is 1.","The late version of the method returns the mRecords array directly instead of its cloned copy. This change could potentially lead to different output (in terms of mutability of returned array), hence the CI type is 1."
237,"<android.view.GLES20Canvas: void drawPath(Path,Paint)>",15,16,"<android.view.GLES20Canvas: void drawPath(Path,Paint)>","<android.view.GLES20Canvas: void drawPath(Path,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    if (path.isSimplePath) {
        if (path.rects != null) {
            nDrawRects(mRenderer, path.rects.mNativeRegion, paint.mNativePaint);
        }
    } else {
        nDrawPath(mRenderer, path.mNativePath, paint.mNativePaint);
    }
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        if (path.isSimplePath) {
            if (path.rects != null) {
                nDrawRects(mRenderer, path.rects.mNativeRegion, paint.mNativePaint);
            }
        } else {
            nDrawPath(mRenderer, path.mNativePath, paint.mNativePaint);
        }
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,2",2,"The control dependency has changed due to addition of a 'try-finally' block and the exception handling statement also changed. Therefore, code change type is 3,2.","The late version introduced a 'try-finally' block that ensures nResetModifiers() is always executed even when an exception is thrown. This is different from the early version where nResetModifiers() would not be called if an exception is thrown from above code. This change in exception handling leads to potential different behaviors of the API, and therefore creates a compatibility issue of type 2."
243,<android.widget.TextView: void setKeyListener(KeyListener)>,15,16,<android.widget.TextView: void setKeyListener(KeyListener)>,<android.widget.TextView: void setKeyListener(KeyListener)>,0,"{
    setKeyListenerOnly(input);
    fixFocusableAndClickableSettings();
    if (input != null) {
        try {
            mInputType = mInput.getInputType();
        } catch (IncompatibleClassChangeError e) {
            mInputType = EditorInfo.TYPE_CLASS_TEXT;
        }
        // Change inputType, without affecting transformation.
        // No need to applySingleLine since mSingleLine is unchanged.
        setInputTypeSingleLine(mSingleLine);
    } else {
        mInputType = EditorInfo.TYPE_NULL;
    }
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null)
        imm.restartInput(this);
}","{
    setKeyListenerOnly(input);
    fixFocusableAndClickableSettings();
    if (input != null) {
        createEditorIfNeeded();
        try {
            mEditor.mInputType = mEditor.mKeyListener.getInputType();
        } catch (IncompatibleClassChangeError e) {
            mEditor.mInputType = EditorInfo.TYPE_CLASS_TEXT;
        }
        // Change inputType, without affecting transformation.
        // No need to applySingleLine since mSingleLine is unchanged.
        setInputTypeSingleLine(mSingleLine);
    } else {
        if (mEditor != null)
            mEditor.mInputType = EditorInfo.TYPE_NULL;
    }
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null)
        imm.restartInput(this);
}",1,"/**
 * Sets the key listener to be used with this TextView.  This can be null
 * to disallow user input.  Note that this method has significant and
 * subtle interactions with soft keyboards and other input method:
 * see {@link KeyListener#getInputType() KeyListener.getContentType()}
 * for important details.  Calling this method will replace the current
 * content type of the text view with the content type returned by the
 * key listener.
 * <p>
 * Be warned that if you want a TextView with a key listener or movement
 * method not to be focusable, or if you want a TextView without a
 * key listener or movement method to be focusable, you must call
 * {@link #setFocusable} again after calling this to get the focusability
 * back the way you want it.
 *
 * @attr ref android.R.styleable#TextView_numeric
 * @attr ref android.R.styleable#TextView_digits
 * @attr ref android.R.styleable#TextView_phoneNumber
 * @attr ref android.R.styleable#TextView_inputMethod
 * @attr ref android.R.styleable#TextView_capitalize
 * @attr ref android.R.styleable#TextView_autoText
 */
","/**
 * Sets the key listener to be used with this TextView.  This can be null
 * to disallow user input.  Note that this method has significant and
 * subtle interactions with soft keyboards and other input method:
 * see {@link KeyListener#getInputType() KeyListener.getContentType()}
 * for important details.  Calling this method will replace the current
 * content type of the text view with the content type returned by the
 * key listener.
 * <p>
 * Be warned that if you want a TextView with a key listener or movement
 * method not to be focusable, or if you want a TextView without a
 * key listener or movement method to be focusable, you must call
 * {@link #setFocusable} again after calling this to get the focusability
 * back the way you want it.
 *
 * @attr ref android.R.styleable#TextView_numeric
 * @attr ref android.R.styleable#TextView_digits
 * @attr ref android.R.styleable#TextView_phoneNumber
 * @attr ref android.R.styleable#TextView_inputMethod
 * @attr ref android.R.styleable#TextView_capitalize
 * @attr ref android.R.styleable#TextView_autoText
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The changes in the late version include method 'createEditorIfNeeded()' invocation and altering 'mInputType' from attribute to 'mEditor' object attribute. Therefore, the change is in types 4 and 5.","Even though changes were made in the implementation, these changes will not affect the potential behaviour of the API, meaning that it will not return a different value or throw a different exception. Therefore, no compatibility issue exists."
244,<android.database.sqlite.SQLiteDatabase: boolean inTransaction()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean inTransaction()>,<android.database.sqlite.SQLiteDatabase: boolean inTransaction()>,0,"{
    return mLock.getHoldCount() > 0 || mTransactionUsingExecSql;
}","{
    acquireReference();
    try {
        return getThreadSession().hasTransaction();
    } finally {
        releaseReference();
    }
}",1,"/**
 * return true if there is a transaction pending
 */
","/**
 * Returns true if the current thread has a transaction pending.
 *
 * @return True if the current thread is in a transaction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the late version is completely different from the early version. In the early version, the function returns whether the hold count of the lock is greater than 0 or a member variable mTransactionUsingExecSql is true. In the late version, the function acquires a reference and checks whether getThreadSession() has transaction and finally, it releases the reference. So the change type is 1,5.","As the return statement has been modified, the API could possibly return a different value. Therefore, the CI type is 1."
247,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,15,16,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,0,"{
    try {
        return sGlobals.mService.getHeightHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return 0;
    }
    try {
        return sGlobals.mService.getHeightHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}",1,"/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
","/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new return statement ""return 0"" is added under a new condition ""if (sGlobals.mService == null)"". Also there is a new logging statement ""Log.w(TAG, ""WallpaperService not running"")"". So the code change types are 1,3,4.","The introduction of the new condition that checks if ""sGlobals.mService == null"" and then returns 0 can cause the API to return a different value than before, thereby leading to a compatibility issue of type 1."
251,"<android.webkit.WebView: void addJavascriptInterface(Object,String)>",15,16,"<android.webkit.WebView: void addJavascriptInterface(Object,String)>","<android.webkit.WebView: void addJavascriptInterface(Object,String)>",0,"{
    checkThread();
    if (obj == null) {
        return;
    }
    WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();
    arg.mObject = obj;
    arg.mInterfaceName = interfaceName;
    mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg);
}","{
    checkThread();
    mProvider.addJavascriptInterface(object, name);
}",1,"/**
 * Use this function to bind an object to JavaScript so that the
 * methods can be accessed from JavaScript.
 * <p><strong>IMPORTANT:</strong>
 * <ul>
 * <li> Using addJavascriptInterface() allows JavaScript to control your
 * application. This can be a very useful feature or a dangerous security
 * issue. When the HTML in the WebView is untrustworthy (for example, part
 * or all of the HTML is provided by some person or process), then an
 * attacker could inject HTML that will execute your code and possibly any
 * code of the attacker's choosing.<br>
 * Do not use addJavascriptInterface() unless all of the HTML in this
 * WebView was written by you.</li>
 * <li> The Java object that is bound runs in another thread and not in
 * the thread that it was constructed in.</li>
 * </ul></p>
 * @param obj The class instance to bind to JavaScript, null instances are
 * ignored.
 * @param interfaceName The name to used to expose the instance in
 * JavaScript.
 */
","/**
 * Injects the supplied Java object into this WebView. The object is
 * injected into the JavaScript context of the main frame, using the
 * supplied name. This allows the Java object's public methods to be
 * accessed from JavaScript. Note that that injected objects will not
 * appear in JavaScript until the page is next (re)loaded. For example:
 * <pre> webView.addJavascriptInterface(new Object(), ""injectedObject"");
 * webView.loadData(""<!DOCTYPE html><title></title>"", ""text/html"", null);
 * webView.loadUrl(""javascript:alert(injectedObject.toString())"");</pre>
 * <p>
 * <strong>IMPORTANT:</strong>
 * <ul>
 * <li> This method can be used to allow JavaScript to control the host
 * application. This is a powerful feature, but also presents a security
 * risk, particularly as JavaScript could use reflection to access an
 * injected object's public fields. Use of this method in a WebView
 * containing untrusted content could allow an attacker to manipulate the
 * host application in unintended ways, executing Java code with the
 * permissions of the host application. Use extreme care when using this
 * method in a WebView which could contain untrusted content.</li>
 * <li> JavaScript interacts with Java object on a private, background
 * thread of this WebView. Care is therefore required to maintain thread
 * safety.</li>
 * </ul>
 *
 * @param object the Java object to inject into this WebView's JavaScript
 * context. Null values are ignored.
 * @param name the name used to expose the object in JavaScript
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"In the late version, a new return point has been introduced, the method implementation has been drastically simplified, and it relies on a new method (`mProvider.addJavascriptInterface`) which was not present in the earlier version, so the code change type is 1, 4, and 5.","Compatibility Issue arises here because due to these code changes, the method could return different point (early version can return null, late version won't) and due to the dependent API change, it may perform differently when executing ""addJavascriptInterface"", so the CI type is 1."
252,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",15,16,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>","<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",0,"{
    checkThread();
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadDataImpl(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mHistoryUrl = historyUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearHelpers();
}","{
    checkThread();
    mProvider.loadDataWithBaseURL(baseUrl, data, mimeType, encoding, historyUrl);
}",1,"/**
 * Load the given data into the WebView, using baseUrl as the base URL for
 * the content. The base URL is used both to resolve relative URLs and when
 * applying JavaScript's same origin policy. The historyUrl is used for the
 * history entry.
 * <p>
 * Note that content specified in this way can access local device files
 * (via 'file' scheme URLs) only if baseUrl specifies a scheme other than
 * 'http', 'https', 'ftp', 'ftps', 'about' or 'javascript'.
 * <p>
 * If the base URL uses the data scheme, this method is equivalent to
 * calling {@link #loadData(String,String,String) loadData()} and the
 * historyUrl is ignored.
 * @param baseUrl URL to use as the page's base URL. If null defaults to
 * 'about:blank'
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data, e.g. 'text/html'. If null,
 * defaults to 'text/html'.
 * @param encoding The encoding of the data.
 * @param historyUrl URL to use as the history entry, if null defaults to
 * 'about:blank'.
 */
","/**
 * Loads the given data into this WebView, using baseUrl as the base URL for
 * the content. The base URL is used both to resolve relative URLs and when
 * applying JavaScript's same origin policy. The historyUrl is used for the
 * history entry.
 * <p>
 * Note that content specified in this way can access local device files
 * (via 'file' scheme URLs) only if baseUrl specifies a scheme other than
 * 'http', 'https', 'ftp', 'ftps', 'about' or 'javascript'.
 * <p>
 * If the base URL uses the data scheme, this method is equivalent to
 * calling {@link #loadData(String,String,String) loadData()} and the
 * historyUrl is ignored.
 *
 * @param baseUrl the URL to use as the page's base URL. If null defaults to
 * 'about:blank'.
 * @param data a String of data in the given encoding
 * @param mimeType the MIMEType of the data, e.g. 'text/html'. If null,
 * defaults to 'text/html'.
 * @param encoding the encoding of the data
 * @param historyUrl the URL to use as the history entry. If null defaults
 * to 'about:blank'.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"All the statements inside the method were changed, especially the logic used by the function is migrated to another dependent method mProvider.loadDataWithBaseURL(). Hence, the change type is 4,5.","As the entire implementation of the method has changed, the behaviour of the function could logically be different in the later version as it's now dependent on a different method (mProvider.loadDataWithBaseURL()). It might return different results depending on the implementation of the dependent method. Hence, a compatibility issue might arise and the CI type is 1."
253,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryBroadcastReceivers(Intent,int)>",15,16,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryBroadcastReceivers(Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryBroadcastReceivers(Intent,int)>",0,"{
    try {
        return mPM.queryIntentReceivers(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.queryIntentReceivers(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method 'queryIntentReceivers' in the return statement is invoking with an additional argument 'UserId.myUserId()' in the later version, which is regarded as a change in the dependent API.","The additional argument passed in the method 'queryIntentReceivers' might cause a different return value depending on its return type and return value, thus causing a compatibility issue with potential differing return values or types. So, the CI type is 1."
254,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",15,16,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",0,"{
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, nativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The early and late versions differ in that the late version introduces an if statement for throwing an exception if the bitmap is recycled. Moreover, the drawing process is wrapped in a try-finally block, which modifies control dependencies. Thus, the code change type is 2,3.","The late version throws a new exception if the bitmap is recycled, which was not present in the early version. This indicates that exception handling has been modified in a way that could cause potential compatibility issues when migrating from the early to the late version. Therefore, the CI type is 2."
255,<android.net.Uri: String decode(String)>,15,16,<android.net.Uri: String decode(String)>,<android.net.Uri: String decode(String)>,0,"{
    if (s == null) {
        return null;
    }
    // Lazily-initialized buffers.
    StringBuilder decoded = null;
    ByteArrayOutputStream out = null;
    int oldLength = s.length();
    // This loop alternates between copying over normal characters and
    // escaping in chunks. This results in fewer method calls and
    // allocations than decoding one character at a time.
    int current = 0;
    while (current < oldLength) {
        // Start in ""copying"" mode where we copy over normal characters.
        // Find the next escape sequence.
        int nextEscape = s.indexOf('%', current);
        if (nextEscape == NOT_FOUND) {
            if (decoded == null) {
                // We didn't actually decode anything.
                return s;
            } else {
                // Append the remainder and return the decoded string.
                decoded.append(s, current, oldLength);
                return decoded.toString();
            }
        }
        // Prepare buffers.
        if (decoded == null) {
            // Looks like we're going to need the buffers...
            // We know the new string will be shorter. Using the old length
            // may overshoot a bit, but it will save us from resizing the
            // buffer.
            decoded = new StringBuilder(oldLength);
            out = new ByteArrayOutputStream(4);
        } else {
            // Clear decoding buffer.
            out.reset();
        }
        // Append characters leading up to the escape.
        if (nextEscape > current) {
            decoded.append(s, current, nextEscape);
            current = nextEscape;
        } else {
        // assert current == nextEscape
        }
        // ""%ab"" where % is literal and a and b are hex digits.
        try {
            do {
                if (current + 2 >= oldLength) {
                    // Truncated escape sequence.
                    out.write(REPLACEMENT);
                } else {
                    int a = Character.digit(s.charAt(current + 1), 16);
                    int b = Character.digit(s.charAt(current + 2), 16);
                    if (a == -1 || b == -1) {
                        // Non hex digits.
                        out.write(REPLACEMENT);
                    } else {
                        // Combine the hex digits into one byte and write.
                        out.write((a << 4) + b);
                    }
                }
                // Move passed the escape sequence.
                current += 3;
            } while (current < oldLength && s.charAt(current) == '%');
            // Decode UTF-8 bytes into a string and append it.
            decoded.append(out.toString(DEFAULT_ENCODING));
        } catch (UnsupportedEncodingException e) {
            throw new AssertionError(e);
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }
    // If we don't have a buffer, we didn't have to decode anything.
    return decoded == null ? s : decoded.toString();
}","{
    if (s == null) {
        return null;
    }
    return UriCodec.decode(s, false, Charsets.UTF_8, false);
}",1,"/**
 * Decodes '%'-escaped octets in the given string using the UTF-8 scheme.
 * Replaces invalid octets with the unicode replacement character
 * (""\\uFFFD"").
 *
 * @param s encoded string to decode
 * @return the given string with escaped octets decoded, or null if
 * s is null
 */
","/**
 * Decodes '%'-escaped octets in the given string using the UTF-8 scheme.
 * Replaces invalid octets with the unicode replacement character
 * (""\\uFFFD"").
 *
 * @param s encoded string to decode
 * @return the given string with escaped octets decoded, or null if
 * s is null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole function implementation has changed. The early version has a complex decoding process, but the late version simply calls a method from UriCodec to decode the string. Hence the code change type is 1,5.","After the change, the method could potentially return a different value because the decoding process has been altered from in-method to a call of UriCodec.decode(). Therefore, the CI type is 1."
256,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,15,16,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,<android.content.ClipData.Item: CharSequence coerceToText(Context)>,0,"{
    // If this Item has an explicit textual value, simply return that.
    if (mText != null) {
        return mText;
    }
    // If this Item has a URI value, try using that.
    if (mUri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(mUri, ""text/*"", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, ""UTF-8"");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w(""ClippedData"", ""Failure loading text"", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return mUri.toString();
    }
    // into text.  Not the most user-friendly thing, but it's something.
    if (mIntent != null) {
        return mIntent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}","{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, ""text/*"", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, ""UTF-8"");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w(""ClippedData"", ""Failure loading text"", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return """";
}",1,"// BEGIN_INCLUDE(coerceToText)
","// BEGIN_INCLUDE(coerceToText)
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed (from direct access to variables like 'mText', 'mUri', 'mIntent' to the calling of getter methods like getText(), getUri(), getIntent()). This means that the getting methods might change the original variable value or get the variable value through a different way. Additionally, the dependent API has changed from using class variables directly to calling their getter functions. Hence, the code change type is 1,4,5.","The changes in the return statements could potentially lead to the API returning different value since the variables 'mText', 'mUri', and 'mIntent' are accessed through the getter methods in the late version rather than directly in the early version. Therefore, the CI type is 1."
257,<android.webkit.WebSettings: void setPluginsEnabled(boolean)>,15,16,<android.webkit.WebSettings: void setPluginsEnabled(boolean)>,<android.webkit.WebSettings: void setPluginsEnabled(boolean)>,0,"{
    setPluginState(flag ? PluginState.ON : PluginState.OFF);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to enable plugins.
 * @param flag True if the WebView should load plugins.
 * @deprecated This method has been deprecated in favor of
 * {@link #setPluginState}
 */
","/**
 * Tells the WebView to enable plugins.
 *
 * @param flag true if the WebView should load plugins
 * @deprecated This method has been deprecated in favor of
 * {@link #setPluginState}
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement is replaced by a new throw statement in the later version, which introduced a new exception. Therefore, the change type is 1,2.","The late version of this API will always throw a new exception instead of executing the original logic. Therefore, this change alters the return value and introduces a new exception, leading to a compatibility issue type of 1,2."
258,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,15,16,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode + "" numPointers="" + ev.getPointerCount());
    }
    // to WebKit and back.
    if (ev.getPointerCount() > 1 && mPreventDefault != PREVENT_DEFAULT_NO) {
        passMultiTouchToWebKit(ev, mTouchEventQueue.nextTouchSequence());
    } else {
        mTouchEventQueue.enqueueTouchEvent(ev);
    }
    // Since all events are handled asynchronously, we always want the gesture stream.
    return true;
}","{
    return mProvider.getViewDelegate().onTouchEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire 'onTouchEvent(MotionEvent)' method's implementation has been changed. The method's implementation has been simplified to just return the result of 'mProvider.getViewDelegate().onTouchEvent(event)', which also implies a change in the dependent API (from the complex in-house logic to another external API call), so the change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
259,"<android.database.sqlite.SQLiteDatabase: Cursor query(boolean,String,String[],String,String[],String,String,String,String)>",15,16,"<android.database.sqlite.SQLiteDatabase: Cursor query(boolean,String,String[],String,String[],String,String,String,String)>","<android.database.sqlite.SQLiteDatabase: Cursor query(boolean,String,String[],String,String[],String,String,String,String)>",0,"{
    return queryWithFactory(null, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
}","{
    return queryWithFactory(null, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit, null);
}",1,"/**
 * Query the given URL, returning a {@link Cursor} over the result set.
 *
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param table The table name to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null
 * will return all rows for the given table.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in order that they
 * appear in the selection. The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * GROUP BY clause (excluding the GROUP BY itself). Passing null
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL HAVING
 * clause (excluding the HAVING itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
 * (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 * @see Cursor
 */
","/**
 * Query the given URL, returning a {@link Cursor} over the result set.
 *
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param table The table name to compile the query against.
 * @param columns A list of which columns to return. Passing null will
 * return all columns, which is discouraged to prevent reading
 * data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null
 * will return all rows for the given table.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in order that they
 * appear in the selection. The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formatted as an SQL
 * GROUP BY clause (excluding the GROUP BY itself). Passing null
 * will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,
 * if row grouping is being used, formatted as an SQL HAVING
 * clause (excluding the HAVING itself). Passing null will cause
 * all row groups to be included, and is required when row
 * grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause
 * (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 * @see Cursor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The code change involved in the 'query' method implementation is return statement change. The return statement has been changed from 'queryWithFactory(null, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);' to 'queryWithFactory(null, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit, null);'. In other words, there is a new parameter introduced in the 'queryWithFactory' method call. Therefore, according to the definition, this code change belongs to type 1 (Return statement changed) and 5 (Dependent API changed).","The invoked method 'queryWithFactory' in the return statement of the 'query' method now has an additional parameter compared to the early version. This change in the argument could potentially lead the method to return a different value in the late version, leading to a compatibility issue. Therefore, a compatibility issue does exist, and it is caused by potential different return values or types (type 1)."
260,"<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>",15,16,"<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>","<android.text.Layout: float getDesiredWidth(CharSequence,int,int,TextPaint)>",0,"{
    float need = 0;
    TextPaint workPaint = new TextPaint();
    int next;
    for (int i = start; i <= end; i = next) {
        next = TextUtils.indexOf(source, '\n', i, end);
        if (next < 0)
            next = end;
        // note, omits trailing paragraph char
        float w = measurePara(paint, workPaint, source, i, next);
        if (w > need)
            need = w;
        next++;
    }
    return need;
}","{
    float need = 0;
    int next;
    for (int i = start; i <= end; i = next) {
        next = TextUtils.indexOf(source, '\n', i, end);
        if (next < 0)
            next = end;
        // note, omits trailing paragraph char
        float w = measurePara(paint, source, i, next);
        if (w > need)
            need = w;
        next++;
    }
    return need;
}",1,"/**
 * Return how wide a layout must be in order to display the
 * specified text slice with one line per paragraph.
 */
","/**
 * Return how wide a layout must be in order to display the
 * specified text slice with one line per paragraph.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The instantiation of 'TextPaint workPaint' and the call to 'measurePara(paint, workPaint, source, i, next)' are removed, so the change type is 1,4,5. ","Without initialization of 'workPaint', the parameter of 'measurePara' method has decreased. The change may result in a different return value, thus the CI type is 1."
261,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",15,16,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new statement 's.setNpnProtocols(mNpnProtocols);' is introduced without changing the control flow and execution of the API method. Thus, the type of code change is 4.","The addition of this statement modifies the behavior of the created socket. It's setting the NpnProtocol of the socket that can potentially change the return value of the createSocket() method. Therefore, according to the definition, the Compatibility Issue type is 1."
262,<android.content.pm.PermissionGroupInfo: String toString()>,15,16,<android.content.pm.PermissionGroupInfo: String toString()>,<android.content.pm.PermissionGroupInfo: String toString()>,0,"{
    return ""PermissionGroupInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + name + ""}"";
}","{
    return ""PermissionGroupInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + name + "" flgs=0x"" + Integer.toHexString(flags) + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,The code change type is 1 because only the return statement has been modified. ,"The modification to the return statement could potentially lead to different return values in the late version, so the CI type is 1."
263,<android.webkit.WebSettings: void setFixedFontFamily(String)>,15,16,<android.webkit.WebSettings: void setFixedFontFamily(String)>,<android.webkit.WebSettings: void setFixedFontFamily(String)>,0,"{
    if (font != null && !font.equals(mFixedFontFamily)) {
        mFixedFontFamily = font;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the fixed font family name.
 * @param font A font family name.
 */
","/**
 * Sets the fixed font family name. The default is ""monospace"".
 *
 * @param font a font family name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version of the API has a condition statement and method invocations like 'postSync()', while in the late version, it throws a new exception 'MustOverrideException()'. Therefore, the change type is 1,2.","The exception thrown is new, indicating a different  handling of exceptions. Furthermore, due to the deletion of the 'postSync()' method, this could potentially return different values in the late version of the API compared to the original one. Thus, the compatibility issues are of type 1,2."
264,"<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap<String, String>)>",15,16,"<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap<String, String>)>","<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap<String, String>)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri earconUri = mEarcons.get(earcon);
            if (earconUri == null) {
                return ERROR;
            }
            return service.playAudio(getPackageName(), earconUri, queueMode, getParams(params));
        }
    }, ERROR, ""playEarcon"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri earconUri = mEarcons.get(earcon);
            if (earconUri == null) {
                return ERROR;
            }
            return service.playAudio(getCallerIdentity(), earconUri, queueMode, getParams(params));
        }
    }, ERROR, ""playEarcon"");
}",1,"/**
 * Plays the earcon using the specified queueing mode and parameters.
 * The earcon must already have been added with {@link #addEarcon(String, String)} or
 * {@link #addEarcon(String, String, int)}.
 *
 * @param earcon The earcon that should be played
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Plays the earcon using the specified queueing mode and parameters.
 * The earcon must already have been added with {@link #addEarcon(String, String)} or
 * {@link #addEarcon(String, String, int)}.
 *
 * @param earcon The earcon that should be played
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The function called inside the `service.playAudio()` method has changed from `getPackageName()` to `getCallerIdentity()`, therefore the change type is 1,5.","The change of function may cause a different return statement as the `service.playAudio()` method is impacted, therefore the CI type is 1."
265,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,15,16,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,0,"{
    enforceSealed();
    final int childAccessibilityViewId = mChildAccessibilityIds.get(index);
    if (!canPerformRequestOverConnection(childAccessibilityViewId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mAccessibilityWindowId, childAccessibilityViewId);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, FLAG_PREFETCH_DESCENDANTS);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,There are several changes between the two versions:,3. The return statement has different arguments in the call to `client.findAccessibilityNodeInfoByAccessibilityId()`;
266,"<android.view.FocusFinder: View findNextFocusFromRect(ViewGroup,Rect,int)>",15,16,"<android.view.FocusFinder: View findNextFocusFromRect(ViewGroup,Rect,int)>","<android.view.FocusFinder: View findNextFocusFromRect(ViewGroup,Rect,int)>",0,"{
    return findNextFocus(root, null, focusedRect, direction);
}","{
    mFocusedRect.set(focusedRect);
    return findNextFocus(root, null, mFocusedRect, direction);
}",1,"/**
 * Find the next view to take focus in root's descendants, searching from
 * a particular rectangle in root's coordinates.
 * @param root Contains focusedRect.
 * @param focusedRect The starting point of the search.
 * @param direction Direction to look.
 * @return The next focusable view, or null if none exists.
 */
","/**
 * Find the next view to take focus in root's descendants, searching from
 * a particular rectangle in root's coordinates.
 * @param root Contains focusedRect. Cannot be null.
 * @param focusedRect The starting point of the search.
 * @param direction Direction to look.
 * @return The next focusable view, or null if none exists.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method findNextFocus was called with 'focusedRect' as one of its arguments in the early version, but in the late version, 'mFocusedRect' is set to 'focusedRect' first, and then 'mFocusedRect' is passed as an argument to the findNextFocus method. This constitutes a return statement change (class type 1) as well as other statement change (class type 4).","The return statement change makes the API potentially return a different value, thus classifying it as Compatibility Issue caused by potential different return values (type 1)."
268,<android.accessibilityservice.AccessibilityServiceInfo: String feedbackTypeToString(int)>,15,16,<android.accessibilityservice.AccessibilityServiceInfo: String feedbackTypeToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String feedbackTypeToString(int)>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""["");
    while (feedbackType > 0) {
        final int feedbackTypeFlag = 1 << Integer.numberOfTrailingZeros(feedbackType);
        feedbackType &= ~feedbackTypeFlag;
        if (builder.length() > 1) {
            builder.append("", "");
        }
        switch(feedbackTypeFlag) {
            case FEEDBACK_AUDIBLE:
                builder.append(""FEEDBACK_AUDIBLE"");
                break;
            case FEEDBACK_HAPTIC:
                builder.append(""FEEDBACK_HAPTIC"");
                break;
            case FEEDBACK_GENERIC:
                builder.append(""FEEDBACK_GENERIC"");
                break;
            case FEEDBACK_SPOKEN:
                builder.append(""FEEDBACK_SPOKEN"");
                break;
            case FEEDBACK_VISUAL:
                builder.append(""FEEDBACK_VISUAL"");
                break;
        }
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""["");
    while (feedbackType != 0) {
        final int feedbackTypeFlag = 1 << Integer.numberOfTrailingZeros(feedbackType);
        feedbackType &= ~feedbackTypeFlag;
        switch(feedbackTypeFlag) {
            case FEEDBACK_AUDIBLE:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_AUDIBLE"");
                break;
            case FEEDBACK_HAPTIC:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_HAPTIC"");
                break;
            case FEEDBACK_GENERIC:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_GENERIC"");
                break;
            case FEEDBACK_SPOKEN:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_SPOKEN"");
                break;
            case FEEDBACK_VISUAL:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_VISUAL"");
                break;
        }
    }
    builder.append(""]"");
    return builder.toString();
}",1,"/**
 * Returns the string representation of a feedback type. For example,
 * {@link #FEEDBACK_SPOKEN} is represented by the string FEEDBACK_SPOKEN.
 *
 * @param feedbackType The feedback type.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a feedback type. For example,
 * {@link #FEEDBACK_SPOKEN} is represented by the string FEEDBACK_SPOKEN.
 *
 * @param feedbackType The feedback type.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The while loop's condition has been modified and the implementation sequence of if...else statements inside the switch statement has been changed. Therefore, the change types are 3 (control dependency) and 4 (other statements).","The change in the while loop condition and the sequence change of statements inside the switch-case could potentially modify the output of the returned string. This could possibly lead to different behaviors in the API, hence, a compatibility issue exists (CI type 1)."
269,"<android.app.ApplicationPackageManager: void clearApplicationUserData(String,IPackageDataObserver)>",15,16,"<android.app.ApplicationPackageManager: void clearApplicationUserData(String,IPackageDataObserver)>","<android.app.ApplicationPackageManager: void clearApplicationUserData(String,IPackageDataObserver)>",0,"{
    try {
        mPM.clearApplicationUserData(packageName, observer);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.clearApplicationUserData(packageName, observer, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The dependent method 'mPM.clearApplicationUserData' has changed with a new parameter 'UserId.myUserId()' added, so the code change type is 5.","The change in the dependent API call with an additional parameter could potentially affect the behavior of the method, leading to different return types/values. Thus the CI type is 1."
270,"<android.webkit.CacheManager: void saveCacheFile(String,long,CacheResult)>",15,16,"<android.webkit.CacheManager: void saveCacheFile(String,long,CacheResult)>","<android.webkit.CacheManager: void saveCacheFile(String,long,CacheResult)>",0,"{
    try {
        cacheRet.outStream.close();
    } catch (IOException e) {
        return;
    }
    if (JniUtil.useChromiumHttpStack()) {
        // compatibility' with the Android HTTP stack.
        assert false;
    }
    if (!cacheRet.outFile.exists()) {
        // the file in the cache directory can be removed by the system
        return;
    }
    boolean redirect = isCachableRedirect(cacheRet.httpStatusCode);
    if (redirect) {
        // location is in database, no need to keep the file
        cacheRet.contentLength = 0;
        cacheRet.localPath = """";
    }
    if ((redirect || cacheRet.contentLength == 0) && !cacheRet.outFile.delete()) {
        Log.e(LOGTAG, cacheRet.outFile.getPath() + "" delete failed."");
    }
    if (cacheRet.contentLength == 0) {
        return;
    }
    mDataBase.addCache(getDatabaseKey(url, postIdentifier), cacheRet);
    if (DebugFlags.CACHE_MANAGER) {
        Log.v(LOGTAG, ""saveCacheFile for url "" + url);
    }
}","{
    try {
        cacheRet.outStream.close();
    } catch (IOException e) {
        return;
    }
    // use, we should already have thrown an exception above.
    assert false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version of code has more control structures and states which are completely removed in the late version. This gives rise to a change in return statements, control dependencies, and other statements. This results in a code change type of 1,3,4.","The late version has removed some of the condition checks that were in the early version. This might cause the method to behave differently in different situations, potentially making the method return earlier than expected. Thus, the CI type is 1."
273,<android.webkit.WebSettings: boolean getJavaScriptCanOpenWindowsAutomatically()>,15,16,<android.webkit.WebSettings: boolean getJavaScriptCanOpenWindowsAutomatically()>,<android.webkit.WebSettings: boolean getJavaScriptCanOpenWindowsAutomatically()>,0,"{
    return mJavaScriptCanOpenWindowsAutomatically;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return true if javascript can open windows automatically. The default
 * is false.
 * @return True if javascript can open windows automatically during
 * window.open().
 */
","/**
 * Gets whether JavaScript can open windows automatically.
 *
 * @return true if JavaScript can open windows automatically during
 * window.open()
 * @see #setJavaScriptCanOpenWindowsAutomatically
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version returns a boolean value, while the late version throws an exception. Therefore, both return statement and exception handling statement have been changed. The code change type is 1,2.","In the early version, no exception was thrown. However, in the late version, an exception is thrown. Thus, the behavior of the function changes significantly, that potentially causes the compatibility issue. Therefore, both potential different return value and potential different exception handling CI exist. The CI type is 1,2."
274,<android.webkit.WebSettings: LayoutAlgorithm getLayoutAlgorithm()>,15,16,<android.webkit.WebSettings: LayoutAlgorithm getLayoutAlgorithm()>,<android.webkit.WebSettings: LayoutAlgorithm getLayoutAlgorithm()>,0,"{
    return mLayoutAlgorithm;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return the current layout algorithm. The default is NARROW_COLUMNS.
 * @return LayoutAlgorithm enum value describing the layout algorithm
 * being used.
 * @see WebSettings.LayoutAlgorithm
 */
","/**
 * Gets the current layout algorithm.
 *
 * @return a LayoutAlgorithm enum value describing the layout algorithm
 * being used
 * @see #setLayoutAlgorithm
 * @see WebSettings.LayoutAlgorithm
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late version, a new exception statement was introduced (throw new MustOverrideException()) and the original return statement was deleted, so the code change type is 1,2.","The late version potentially leads to different return values (null compared to the early version) and throws an unexpected exception, thus the CI type is 1,2."
276,<android.server.BluetoothAdapterStateMachine.WarmUp: boolean processMessage(Message)>,15,16,<android.server.BluetoothAdapterStateMachine.WarmUp: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.WarmUp: boolean processMessage(Message)>,0,"{
    log(""WarmUp process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SERVICE_RECORD_LOADED:
            removeMessages(PREPARE_BLUETOOTH_TIMEOUT);
            transitionTo(mHotOff);
            break;
        case PREPARE_BLUETOOTH_TIMEOUT:
            Log.e(TAG, ""Bluetooth adapter SDP failed to load"");
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        // handle this at HotOff state
        case USER_TURN_ON:
        // Once in HotOff state, continue turn bluetooth
        case TURN_ON_CONTINUE:
        // on to the BluetoothOn state
        case AIRPLANE_MODE_ON:
        case AIRPLANE_MODE_OFF:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
            deferMessage(message);
            break;
        case USER_TURN_OFF:
            Log.w(TAG, ""WarmUp received: "" + message.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""WarmUp process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case SERVICE_RECORD_LOADED:
            removeMessages(PREPARE_BLUETOOTH_TIMEOUT);
            transitionTo(mHotOff);
            if (mDelayBroadcastStateOff) {
                broadcastState(BluetoothAdapter.STATE_OFF);
                mDelayBroadcastStateOff = false;
            }
            break;
        case PREPARE_BLUETOOTH_TIMEOUT:
            Log.e(TAG, ""Bluetooth adapter SDP failed to load"");
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        // handle this at HotOff state
        case USER_TURN_ON:
        // Once in HotOff state, continue turn bluetooth
        case TURN_ON_CONTINUE:
        // on to the BluetoothOn state
        case AIRPLANE_MODE_ON:
        case AIRPLANE_MODE_OFF:
        case PER_PROCESS_TURN_ON:
        case PER_PROCESS_TURN_OFF:
            deferMessage(message);
            break;
        case USER_TURN_OFF:
            Log.w(TAG, ""WarmUp received: "" + message.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"Additional statements have been added inside the 'SERVICE_RECORD_LOADED' case block of the switch statement, thus the classification is type 3 for control dependency changed.","The change won't lead to a change in return output nor the exception handling as those introduced statements only change an instance variable and call a broadcasting method which do not affect the return value nor potentially rise any exception. Therefore, no compatibility issue exists (class 0)."
277,<android.nfc.tech.Ndef: boolean canMakeReadOnly()>,15,16,<android.nfc.tech.Ndef: boolean canMakeReadOnly()>,<android.nfc.tech.Ndef: boolean canMakeReadOnly()>,0,"{
    INfcTag tagService = mTag.getTagService();
    try {
        return tagService.canMakeReadOnly(mNdefType);
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return false;
    }
}","{
    INfcTag tagService = mTag.getTagService();
    if (tagService == null) {
        return false;
    }
    try {
        return tagService.canMakeReadOnly(mNdefType);
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return false;
    }
}",1,"/**
 * Indicates whether a tag can be made read-only with {@link #makeReadOnly()}.
 *
 * <p>Does not cause any RF activity and does not block.
 *
 * @return true if it is possible to make this tag read-only
 */
","/**
 * Indicates whether a tag can be made read-only with {@link #makeReadOnly()}.
 *
 * <p>Does not cause any RF activity and does not block.
 *
 * @return true if it is possible to make this tag read-only
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An 'if' control statement and accompanying 'return' statement were added to the late version. The change type is 3, which represents a control dependency change.","The new 'if' statement introduces a new return path, possibly causing the API to return a different value than in the previous version. This introduces a Compatibility Issue of type 1, signifying a potential difference in return values."
278,<android.webkit.WebSettings: void setDefaultZoom(ZoomDensity)>,15,16,<android.webkit.WebSettings: void setDefaultZoom(ZoomDensity)>,<android.webkit.WebSettings: void setDefaultZoom(ZoomDensity)>,0,"{
    if (mDefaultZoom != zoom) {
        mDefaultZoom = zoom;
        mWebView.adjustDefaultZoomDensity(zoom.value);
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the default zoom density of the page. This should be called from UI
 * thread.
 * @param zoom A ZoomDensity value
 * @see WebSettings.ZoomDensity
 */
","/**
 * Sets the default zoom density of the page. This should be called from UI
 * thread.
 *
 * @param zoom a ZoomDensity value
 * @see WebSettings.ZoomDensity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version implementation has completely been discarded and a new throw statement has been introduced in the late version, so the code change type is 1,2.","Because the early version's method of setting default zoom was replaced with an exception being thrown in the late version, the API will not return the same variable and will throw a different exception. Based on this, the CI type is 1,2."
280,<android.database.sqlite.SQLiteCursor: boolean requery()>,15,16,<android.database.sqlite.SQLiteCursor: boolean requery()>,<android.database.sqlite.SQLiteCursor: boolean requery()>,0,"{
    if (isClosed()) {
        return false;
    }
    long timeStart = 0;
    if (false) {
        timeStart = System.currentTimeMillis();
    }
    synchronized (this) {
        if (mWindow != null) {
            mWindow.clear();
        }
        mPos = -1;
        SQLiteDatabase db = null;
        try {
            db = mQuery.mDatabase.getDatabaseHandle(mQuery.mSql);
        } catch (IllegalStateException e) {
            // for backwards compatibility, just return false
            Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
            return false;
        }
        if (!db.equals(mQuery.mDatabase)) {
            // re-compile the query
            try {
                db.lock(mQuery.mSql);
            } catch (IllegalStateException e) {
                // for backwards compatibility, just return false
                Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
                return false;
            }
            try {
                // close the old mQuery object and open a new one
                mQuery.close();
                mQuery = new SQLiteQuery(db, mQuery);
            } catch (IllegalStateException e) {
                // for backwards compatibility, just return false
                Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
                return false;
            } finally {
                db.unlock();
            }
        }
        // This one will recreate the temp table, and get its count
        mDriver.cursorRequeried(this);
        mCount = NO_COUNT;
        try {
            mQuery.requery();
        } catch (IllegalStateException e) {
            // for backwards compatibility, just return false
            Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
            return false;
        }
    }
    if (false) {
        Log.v(""DatabaseWindow"", ""closing window in requery()"");
        Log.v(TAG, ""--- Requery()ed cursor "" + this + "": "" + mQuery);
    }
    boolean result = false;
    try {
        result = super.requery();
    } catch (IllegalStateException e) {
        // for backwards compatibility, just return false
        Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
    }
    if (false) {
        long timeEnd = System.currentTimeMillis();
        Log.v(TAG, ""requery ("" + (timeEnd - timeStart) + "" ms): "" + mDriver.toString());
    }
    return result;
}","{
    if (isClosed()) {
        return false;
    }
    synchronized (this) {
        if (!mQuery.getDatabase().isOpen()) {
            return false;
        }
        if (mWindow != null) {
            mWindow.clear();
        }
        mPos = -1;
        mCount = NO_COUNT;
        mDriver.cursorRequeried(this);
    }
    try {
        return super.requery();
    } catch (IllegalStateException e) {
        // for backwards compatibility, just return false
        Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
        return false;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","There are numerous significant changes between the two versions: various statements have been added, modified, or removed. Return statements have changed, exception handling has significantly changed, control dependency has been altered, and other miscellaneous statements have been changed. As a result, the code change type is 1,2,3,4.","Due to the changes in the return statements and handling of the exceptions, the API could potentially return different values/types and throw different exceptions between the two versions. This results in the CI type being 1,2."
282,"<com.google.android.mms.pdu.PduPersister: Uri persist(GenericPdu,Uri)>",15,16,"<com.google.android.mms.pdu.PduPersister: Uri persist(GenericPdu,Uri)>","<com.google.android.mms.pdu.PduPersister: Uri persist(GenericPdu,Uri)>",0,"{
    if (uri == null) {
        throw new MmsException(""Uri may not be null."");
    }
    Integer msgBox = MESSAGE_BOX_MAP.get(uri);
    if (msgBox == null) {
        throw new MmsException(""Bad destination, must be one of "" + ""content://mms/inbox, content://mms/sent, "" + ""content://mms/drafts, content://mms/outbox, "" + ""content://mms/temp."");
    }
    PDU_CACHE_INSTANCE.purge(uri);
    PduHeaders header = pdu.getPduHeaders();
    PduBody body = null;
    ContentValues values = new ContentValues();
    Set<Entry<Integer, String>> set;
    set = ENCODED_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int field = e.getKey();
        EncodedStringValue encodedString = header.getEncodedStringValue(field);
        if (encodedString != null) {
            String charsetColumn = CHARSET_COLUMN_NAME_MAP.get(field);
            values.put(e.getValue(), toIsoString(encodedString.getTextString()));
            values.put(charsetColumn, encodedString.getCharacterSet());
        }
    }
    set = TEXT_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        byte[] text = header.getTextString(e.getKey());
        if (text != null) {
            values.put(e.getValue(), toIsoString(text));
        }
    }
    set = OCTET_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int b = header.getOctet(e.getKey());
        if (b != 0) {
            values.put(e.getValue(), b);
        }
    }
    set = LONG_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        long l = header.getLongInteger(e.getKey());
        if (l != -1L) {
            values.put(e.getValue(), l);
        }
    }
    HashMap<Integer, EncodedStringValue[]> addressMap = new HashMap<Integer, EncodedStringValue[]>(ADDRESS_FIELDS.length);
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = null;
        if (addrType == PduHeaders.FROM) {
            EncodedStringValue v = header.getEncodedStringValue(addrType);
            if (v != null) {
                array = new EncodedStringValue[1];
                array[0] = v;
            }
        } else {
            array = header.getEncodedStringValues(addrType);
        }
        addressMap.put(addrType, array);
    }
    HashSet<String> recipients = new HashSet<String>();
    long threadId = DUMMY_THREAD_ID;
    int msgType = pdu.getMessageType();
    // this scope.
    if ((msgType == PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND) || (msgType == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) || (msgType == PduHeaders.MESSAGE_TYPE_SEND_REQ)) {
        EncodedStringValue[] array = null;
        switch(msgType) {
            case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
            case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
                array = addressMap.get(PduHeaders.FROM);
                break;
            case PduHeaders.MESSAGE_TYPE_SEND_REQ:
                array = addressMap.get(PduHeaders.TO);
                break;
        }
        if (array != null) {
            for (EncodedStringValue v : array) {
                if (v != null) {
                    recipients.add(v.getString());
                }
            }
        }
        threadId = Threads.getOrCreateThreadId(mContext, recipients);
    }
    values.put(Mms.THREAD_ID, threadId);
    // Save parts first to avoid inconsistent message is loaded
    // while saving the parts.
    // Dummy ID of the msg.
    long dummyId = System.currentTimeMillis();
    // Get body if the PDU is a RetrieveConf or SendReq.
    if (pdu instanceof MultimediaMessagePdu) {
        body = ((MultimediaMessagePdu) pdu).getBody();
        // Start saving parts if necessary.
        if (body != null) {
            int partsNum = body.getPartsNum();
            for (int i = 0; i < partsNum; i++) {
                PduPart part = body.getPart(i);
                persistPart(part, dummyId);
            }
        }
    }
    Uri res = SqliteWrapper.insert(mContext, mContentResolver, uri, values);
    if (res == null) {
        throw new MmsException(""persist() failed: return null."");
    }
    // Get the real ID of the PDU and update all parts which were
    // saved with the dummy ID.
    long msgId = ContentUris.parseId(res);
    values = new ContentValues(1);
    values.put(Part.MSG_ID, msgId);
    SqliteWrapper.update(mContext, mContentResolver, Uri.parse(""content://mms/"" + dummyId + ""/part""), values, null, null);
    // We should return the longest URI of the persisted PDU, for
    // example, if input URI is ""content://mms/inbox"" and the _ID of
    // persisted PDU is '8', we should return ""content://mms/inbox/8""
    // instead of ""content://mms/8"".
    // FIXME: Should the MmsProvider be responsible for this???
    res = Uri.parse(uri + ""/"" + msgId);
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = addressMap.get(addrType);
        if (array != null) {
            persistAddress(msgId, addrType, array);
        }
    }
    return res;
}","{
    if (uri == null) {
        throw new MmsException(""Uri may not be null."");
    }
    long msgId = -1;
    try {
        msgId = ContentUris.parseId(uri);
    } catch (NumberFormatException e) {
    // the uri ends with ""inbox"" or something else like that
    }
    boolean existingUri = msgId != -1;
    if (!existingUri && MESSAGE_BOX_MAP.get(uri) == null) {
        throw new MmsException(""Bad destination, must be one of "" + ""content://mms/inbox, content://mms/sent, "" + ""content://mms/drafts, content://mms/outbox, "" + ""content://mms/temp."");
    }
    synchronized (PDU_CACHE_INSTANCE) {
        // purging it.
        if (PDU_CACHE_INSTANCE.isUpdating(uri)) {
            if (LOCAL_LOGV) {
                Log.v(TAG, ""persist: "" + uri + "" blocked by isUpdating()"");
            }
            try {
                PDU_CACHE_INSTANCE.wait();
            } catch (InterruptedException e) {
                Log.e(TAG, ""persist1: "", e);
            }
        }
    }
    PDU_CACHE_INSTANCE.purge(uri);
    PduHeaders header = pdu.getPduHeaders();
    PduBody body = null;
    ContentValues values = new ContentValues();
    Set<Entry<Integer, String>> set;
    set = ENCODED_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int field = e.getKey();
        EncodedStringValue encodedString = header.getEncodedStringValue(field);
        if (encodedString != null) {
            String charsetColumn = CHARSET_COLUMN_NAME_MAP.get(field);
            values.put(e.getValue(), toIsoString(encodedString.getTextString()));
            values.put(charsetColumn, encodedString.getCharacterSet());
        }
    }
    set = TEXT_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        byte[] text = header.getTextString(e.getKey());
        if (text != null) {
            values.put(e.getValue(), toIsoString(text));
        }
    }
    set = OCTET_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int b = header.getOctet(e.getKey());
        if (b != 0) {
            values.put(e.getValue(), b);
        }
    }
    set = LONG_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        long l = header.getLongInteger(e.getKey());
        if (l != -1L) {
            values.put(e.getValue(), l);
        }
    }
    HashMap<Integer, EncodedStringValue[]> addressMap = new HashMap<Integer, EncodedStringValue[]>(ADDRESS_FIELDS.length);
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = null;
        if (addrType == PduHeaders.FROM) {
            EncodedStringValue v = header.getEncodedStringValue(addrType);
            if (v != null) {
                array = new EncodedStringValue[1];
                array[0] = v;
            }
        } else {
            array = header.getEncodedStringValues(addrType);
        }
        addressMap.put(addrType, array);
    }
    HashSet<String> recipients = new HashSet<String>();
    int msgType = pdu.getMessageType();
    // this scope.
    if ((msgType == PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND) || (msgType == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) || (msgType == PduHeaders.MESSAGE_TYPE_SEND_REQ)) {
        EncodedStringValue[] array = null;
        switch(msgType) {
            case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
            case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
                array = addressMap.get(PduHeaders.FROM);
                break;
            case PduHeaders.MESSAGE_TYPE_SEND_REQ:
                array = addressMap.get(PduHeaders.TO);
                break;
        }
        if (array != null) {
            for (EncodedStringValue v : array) {
                if (v != null) {
                    recipients.add(v.getString());
                }
            }
        }
        if (!recipients.isEmpty()) {
            long threadId = Threads.getOrCreateThreadId(mContext, recipients);
            values.put(Mms.THREAD_ID, threadId);
        }
    }
    // Save parts first to avoid inconsistent message is loaded
    // while saving the parts.
    // Dummy ID of the msg.
    long dummyId = System.currentTimeMillis();
    // Get body if the PDU is a RetrieveConf or SendReq.
    if (pdu instanceof MultimediaMessagePdu) {
        body = ((MultimediaMessagePdu) pdu).getBody();
        // Start saving parts if necessary.
        if (body != null) {
            int partsNum = body.getPartsNum();
            for (int i = 0; i < partsNum; i++) {
                PduPart part = body.getPart(i);
                persistPart(part, dummyId);
            }
        }
    }
    Uri res = null;
    if (existingUri) {
        res = uri;
        SqliteWrapper.update(mContext, mContentResolver, res, values, null, null);
    } else {
        res = SqliteWrapper.insert(mContext, mContentResolver, uri, values);
        if (res == null) {
            throw new MmsException(""persist() failed: return null."");
        }
        // Get the real ID of the PDU and update all parts which were
        // saved with the dummy ID.
        msgId = ContentUris.parseId(res);
    }
    values = new ContentValues(1);
    values.put(Part.MSG_ID, msgId);
    SqliteWrapper.update(mContext, mContentResolver, Uri.parse(""content://mms/"" + dummyId + ""/part""), values, null, null);
    // FIXME: Should the MmsProvider be responsible for this???
    if (!existingUri) {
        res = Uri.parse(uri + ""/"" + msgId);
    }
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = addressMap.get(addrType);
        if (array != null) {
            persistAddress(msgId, addrType, array);
        }
    }
    return res;
}",1,"/**
 * Persist a PDU object to specific location in the storage.
 *
 * @param pdu The PDU object to be stored.
 * @param uri Where to store the given PDU object.
 * @return A Uri which can be used to access the stored PDU.
 */
","/**
 * Persist a PDU object to specific location in the storage.
 *
 * @param pdu The PDU object to be stored.
 * @param uri Where to store the given PDU object.
 * @return A Uri which can be used to access the stored PDU.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
283,<android.webkit.URLUtil: boolean isContentUrl(String)>,15,16,<android.webkit.URLUtil: boolean isContentUrl(String)>,<android.webkit.URLUtil: boolean isContentUrl(String)>,0,"{
    return (null != url) && url.startsWith(""content:"");
}","{
    return (null != url) && url.startsWith(CONTENT_BASE);
}",1,"/**
 * @return True iff the url is a content: url.
 */
","/**
 * @return True iff the url is a content: url.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The string in the method 'startsWith()' has changed from a direct string ""content:"" to a variable CONTENT_BASE. There's not only an 'Other statement' changed (change of the parameter that `startsWith` takes), but a lot also a dependent API (the CONTENT_BASE has a different value from ""content:""), so the code change type is 1,5.",The change of the string may potentially lead to the change of the return value of function 'isContentUrl()'. Thus the compatibility issue type is 1.
284,<android.database.sqlite.SQLiteStatement: int executeUpdateDelete()>,15,16,<android.database.sqlite.SQLiteStatement: int executeUpdateDelete()>,<android.database.sqlite.SQLiteStatement: int executeUpdateDelete()>,0,"{
    try {
        saveSqlAsLastSqlStatement();
        acquireAndLock(WRITE);
        int numChanges = 0;
        if ((mStatementType & STATEMENT_DONT_PREPARE) > 0) {
            // since the statement doesn't have to be prepared,
            // call the following native method which will not prepare
            // the query plan
            native_executeSql(mSql);
        } else {
            numChanges = native_execute();
        }
        return numChanges;
    } finally {
        releaseAndUnlock();
    }
}","{
    acquireReference();
    try {
        return getSession().executeForChangedRowCount(getSql(), getBindArgs(), getConnectionFlags(), null);
    } catch (SQLiteDatabaseCorruptException ex) {
        onCorruption();
        throw ex;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Execute this SQL statement, if the the number of rows affected by execution of this SQL
 * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
 *
 * @return the number of rows affected by this SQL statement execution.
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement, if the the number of rows affected by execution of this SQL
 * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
 *
 * @return the number of rows affected by this SQL statement execution.
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The entire implementation changed - from a local mechanism of checking whether a query should be prepared or not, and acting accordingly to just calling getSession(). There are changes in return statements, exception handling, control dependency, other statements, and dependent API, therefore the change types are 1,2,3,4,5.","The return statement and exception handling have drastically changed with this update, so they can potentially lead to returning a different value or throwing a different exception. Therefore, the potential CI type is 1,2."
286,<android.app.WallpaperManager: void setStream(InputStream)>,15,16,<android.app.WallpaperManager: void setStream(InputStream)>,<android.app.WallpaperManager: void setStream(InputStream)>,0,"{
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An additional if condition statement has been added that checks if sGlobals.mService is null and returns if true. It is considered as a Control dependency change and therefore, belong to class 3.","The introduction of the new condition statement could potentially cause the API to return different behavior, as the execution of the method can be aborted earlier when sGlobals.mService is null - a new condition that didn't exist in the early version. The API could return without executing the remaining code if the new condition is met in the later version. Thus, this is a Compatibility Issue caused by potential different return values or behaviors(class 1)."
287,"<android.widget.HorizontalScrollView: void smoothScrollBy(int,int)>",15,16,"<android.widget.HorizontalScrollView: void smoothScrollBy(int,int)>","<android.widget.HorizontalScrollView: void smoothScrollBy(int,int)>",0,"{
    if (getChildCount() == 0) {
        // Nothing to do.
        return;
    }
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        final int width = getWidth() - mPaddingRight - mPaddingLeft;
        final int right = getChildAt(0).getWidth();
        final int maxX = Math.max(0, right - width);
        final int scrollX = mScrollX;
        dx = Math.max(0, Math.min(scrollX + dx, maxX)) - scrollX;
        mScroller.startScroll(scrollX, mScrollY, dx, 0);
        invalidate();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}","{
    if (getChildCount() == 0) {
        // Nothing to do.
        return;
    }
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        final int width = getWidth() - mPaddingRight - mPaddingLeft;
        final int right = getChildAt(0).getWidth();
        final int maxX = Math.max(0, right - width);
        final int scrollX = mScrollX;
        dx = Math.max(0, Math.min(scrollX + dx, maxX)) - scrollX;
        mScroller.startScroll(scrollX, mScrollY, dx, 0);
        postInvalidateOnAnimation();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}",1,"/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
","/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the method call 'invalidate()' has been changed to 'postInvalidateOnAnimation()', which is another statement, so the change type is 4.","The change is only about the method of rendering the view after a scroll. It won't cause any compatibility issues as it doesn't affect the return type/value, nor the thrown exceptions of the method. So the CI type is 0."
288,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",15,16,"<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    }
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisMessageParams token = null;
    synchronized (mStateLock) {
        if (mToken == null || mStopped) {
            return TextToSpeech.ERROR;
        }
        token = mToken;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    // Might block on mToken.this, if there are too many buffers waiting to
    // be consumed.
    token.addBuffer(bufferCopy);
    mAudioTrackHandler.enqueueSynthesisDataAvailable(token);
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}","{
    if (DBG) {
        Log.d(TAG, ""audioAvailable(byte["" + buffer.length + ""],"" + offset + "","" + length + "")"");
    }
    if (length > getMaxBufferSize() || length <= 0) {
        throw new IllegalArgumentException(""buffer is too large or of zero length ("" + +length + "" bytes)"");
    }
    SynthesisPlaybackQueueItem item = null;
    synchronized (mStateLock) {
        if (mItem == null || mStopped) {
            return TextToSpeech.ERROR;
        }
        item = mItem;
    }
    // Sigh, another copy.
    final byte[] bufferCopy = new byte[length];
    System.arraycopy(buffer, offset, bufferCopy, 0, length);
    // be consumed.
    try {
        item.put(bufferCopy);
    } catch (InterruptedException ie) {
        return TextToSpeech.ERROR;
    }
    mLogger.onEngineDataReceived();
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The statement in conditions has been changed. The token was replaced by item. The control statement in synchronized block has been changed and a new exception handling statement was introduced, therefore the code change type is 1,2,4,5.","New return statement under the condition of 'mItem == null || mStopped' case has been introduced and this condition was not in the early version. Also, a new exception handling statement was added and it returns different value when it catches an exception, therefore the CI type is 1,2."
289,<android.webkit.WebView: boolean canZoomIn()>,15,16,<android.webkit.WebView: boolean canZoomIn()>,<android.webkit.WebView: boolean canZoomIn()>,0,"{
    checkThread();
    return mZoomManager.canZoomIn();
}","{
    checkThread();
    return mProvider.canZoomIn();
}",1,"/**
 * @return TRUE if the WebView can be zoomed in.
 */
","/**
 * Gets whether this WebView can be zoomed in.
 *
 * @return true if this WebView can be zoomed in
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed, and the object calling method 'canZoomIn()' changed from 'mZoomManager' to 'mProvider', so the code change type is 1,5.","The return value of method 'canZoomIn()' called on different objects can be different, so the CI type is 1."
290,<android.widget.CalendarView: void setShowWeekNumber(boolean)>,15,16,<android.widget.CalendarView: void setShowWeekNumber(boolean)>,<android.widget.CalendarView: void setShowWeekNumber(boolean)>,0,"{
    if (mShowWeekNumber == showWeekNumber) {
        return;
    }
    mShowWeekNumber = showWeekNumber;
    mAdapter.notifyDataSetChanged();
    setUpHeader(DEFAULT_WEEK_DAY_TEXT_APPEARANCE_RES_ID);
}","{
    if (mShowWeekNumber == showWeekNumber) {
        return;
    }
    mShowWeekNumber = showWeekNumber;
    mAdapter.notifyDataSetChanged();
    setUpHeader();
}",1,"/**
 * Sets whether to show the week number.
 *
 * @param showWeekNumber True to show the week number.
 */
","/**
 * Sets whether to show the week number.
 *
 * @param showWeekNumber True to show the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The function setUpHeader(DEFAULT_WEEK_DAY_TEXT_APPEARANCE_RES_ID) has been updated to setUpHeader(), so the change type is 4,5.","The change in the function setUpHeader() to no longer receive a parameter may cause it to behave differently. As it's potential to affect the showing of the week number, thus the CI type is 1."
291,<android.widget.TextView: float getLeftFadingEdgeStrength()>,15,16,<android.widget.TextView: float getLeftFadingEdgeStrength()>,<android.widget.TextView: float getLeftFadingEdgeStrength()>,0,"{
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return 0.0f;
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                return marquee.mScroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}","{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                return marquee.mScroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The conditional statement checking if mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT and the corresponding return statement (return 0.0f) has been removed. Therefore, the code change type is 1. ","Since an initial check (if mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT) and associated return statement have been removed, the method now has the potential to return a different value, as the execution will continue into further checks and calculations which were previously bypassed when the condition was met. Therefore, the CI type is 1, indicating potential differences in return values."
292,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",15,16,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"An additional statement is introduced in the late version, 's.setNpnProtocols(mNpnProtocols);', which can be classified as 'Other statement changed'.",The introduced 's.setNpnProtocols(mNpnProtocols);' statement could potentially alter the behaviours of the created socket and hence could lead to possible difference in the returned Socket object. This falls into the category of 'Compatibility Issue caused by potential different return values or types'.
293,<android.view.GLES20Canvas: boolean clipRegion(Region)>,15,16,<android.view.GLES20Canvas: boolean clipRegion(Region)>,<android.view.GLES20Canvas: boolean clipRegion(Region)>,0,"{
    throw new UnsupportedOperationException();
}","{
    // TODO: Implement
    region.getBounds(mClipBounds);
    return nClipRect(mRenderer, mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom, Region.Op.INTERSECT.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The early version contains a throw statement, while the late version has a return statement plus other statements; the throw statement has been removed and a return statement has been introduced, so the code change type is 1,2,4.","The new implementation returns a boolean value and also handles a Region object which is not present in the early version. And replaced 'throw' statement in the early version can also make new version throw different exception. So, the CI type is 1,2."
295,<android.view.GLES20Canvas: boolean clipPath(Path)>,15,16,<android.view.GLES20Canvas: boolean clipPath(Path)>,<android.view.GLES20Canvas: boolean clipPath(Path)>,0,"{
    throw new UnsupportedOperationException();
}","{
    // TODO: Implement
    path.computeBounds(mPathBounds, true);
    return nClipRect(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom, Region.Op.INTERSECT.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The old implementation only throws an UnsupportedOperationException, while the new implementation actually performs an operation and returns a result. So, this change includes multiple types: 'Return statement changed', 'Exception handling statement changed' and 'Other statements changed', thus the change types are 1,2,4.","In terms of compatibility issue, the changes made in the newer version could lead to different behaviors since the late version does not throw an exception but actually performs an operation and returns a result which could vary. Thus, the CI types are 1,2."
296,<android.database.sqlite.SQLiteDatabase: ArrayList<DbStats> getDbStats()>,15,16,<android.database.sqlite.SQLiteDatabase: ArrayList<DbStats> getDbStats()>,<android.database.sqlite.SQLiteDatabase: ArrayList<DbStats> getDbStats()>,0,"{
    ArrayList<DbStats> dbStatsList = new ArrayList<DbStats>();
    // make a local copy of mActiveDatabases - so that this method is not competing
    // for synchronization lock on mActiveDatabases
    ArrayList<WeakReference<SQLiteDatabase>> tempList;
    synchronized (mActiveDatabases) {
        tempList = (ArrayList<WeakReference<SQLiteDatabase>>) mActiveDatabases.clone();
    }
    for (WeakReference<SQLiteDatabase> w : tempList) {
        SQLiteDatabase db = w.get();
        if (db == null || !db.isOpen()) {
            continue;
        }
        try {
            // get SQLITE_DBSTATUS_LOOKASIDE_USED for the db
            int lookasideUsed = db.native_getDbLookaside();
            // get the lastnode of the dbname
            String path = db.getPath();
            int indx = path.lastIndexOf(""/"");
            String lastnode = path.substring((indx != -1) ? ++indx : 0);
            // get list of attached dbs and for each db, get its size and pagesize
            List<Pair<String, String>> attachedDbs = db.getAttachedDbs();
            if (attachedDbs == null) {
                continue;
            }
            for (int i = 0; i < attachedDbs.size(); i++) {
                Pair<String, String> p = attachedDbs.get(i);
                long pageCount = DatabaseUtils.longForQuery(db, ""PRAGMA "" + p.first + "".page_count;"", null);
                // first entry in the attached db list is always the main database
                // don't worry about prefixing the dbname with ""main""
                String dbName;
                if (i == 0) {
                    dbName = lastnode;
                } else {
                    // lookaside is only relevant for the main db
                    lookasideUsed = 0;
                    dbName = ""  (attached) "" + p.first;
                    // if the attached db has a path, attach the lastnode from the path to above
                    if (p.second.trim().length() > 0) {
                        int idx = p.second.lastIndexOf(""/"");
                        dbName += "" : "" + p.second.substring((idx != -1) ? ++idx : 0);
                    }
                }
                if (pageCount > 0) {
                    dbStatsList.add(new DbStats(dbName, pageCount, db.getPageSize(), lookasideUsed, db.getCacheHitNum(), db.getCacheMissNum(), db.getCachesize()));
                }
            }
            // if there are pooled connections, return the cache stats for them also.
            // while we are trying to query the pooled connections for stats, some other thread
            // could be disabling conneciton pool. so, grab a reference to the connection pool.
            DatabaseConnectionPool connPool = db.mConnectionPool;
            if (connPool != null) {
                for (SQLiteDatabase pDb : connPool.getConnectionList()) {
                    dbStatsList.add(new DbStats(""(pooled # "" + pDb.mConnectionNum + "") "" + lastnode, 0, 0, 0, pDb.getCacheHitNum(), pDb.getCacheMissNum(), pDb.getCachesize()));
                }
            }
        } catch (SQLiteException e) {
        // ignore. we don't care about exceptions when we are taking adb
        // bugreport!
        }
    }
    return dbStatsList;
}","{
    ArrayList<DbStats> dbStatsList = new ArrayList<DbStats>();
    for (SQLiteDatabase db : getActiveDatabases()) {
        db.collectDbStats(dbStatsList);
    }
    return dbStatsList;
}",1,"/* package */
","/**
 * Collect statistics about all open databases in the current process.
 * Used by bug report.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation has significantly changed from manually iterating over each active database and collecting stats to simply invoking getActiveDatabases() and colllectDbStats() methods. Therefore, the code change type is 1,4.","The late version significantly simplifies the code and potentially changes the behaviour of the method getDbStats() because the collection of database stats is not the same as the previous one. So the return value of the method has changed, giving the CI type 1."
300,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getWritableDatabase()>,15,16,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getWritableDatabase()>,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getWritableDatabase()>,0,"{
    if (mDatabase != null) {
        if (!mDatabase.isOpen()) {
            // darn! the user closed the database by calling mDatabase.close()
            mDatabase = null;
        } else if (!mDatabase.isReadOnly()) {
            // The database is already open for business
            return mDatabase;
        }
    }
    if (mIsInitializing) {
        throw new IllegalStateException(""getWritableDatabase called recursively"");
    }
    // If we have a read-only database open, someone could be using it
    // (though they shouldn't), which would cause a lock to be held on
    // the file, and our attempts to open the database read-write would
    // fail waiting for the file lock.  To prevent that, we acquire the
    // lock on the read-only database, which shuts out other users.
    boolean success = false;
    SQLiteDatabase db = null;
    if (mDatabase != null)
        mDatabase.lock();
    try {
        mIsInitializing = true;
        if (mName == null) {
            db = SQLiteDatabase.create(null);
        } else {
            db = mContext.openOrCreateDatabase(mName, 0, mFactory, mErrorHandler);
        }
        int version = db.getVersion();
        if (version != mNewVersion) {
            db.beginTransaction();
            try {
                if (version == 0) {
                    onCreate(db);
                } else {
                    if (version > mNewVersion) {
                        onDowngrade(db, version, mNewVersion);
                    } else {
                        onUpgrade(db, version, mNewVersion);
                    }
                }
                db.setVersion(mNewVersion);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
        }
        onOpen(db);
        success = true;
        return db;
    } finally {
        mIsInitializing = false;
        if (success) {
            if (mDatabase != null) {
                try {
                    mDatabase.close();
                } catch (Exception e) {
                }
                mDatabase.unlock();
            }
            mDatabase = db;
        } else {
            if (mDatabase != null)
                mDatabase.unlock();
            if (db != null)
                db.close();
        }
    }
}","{
    synchronized (this) {
        return getDatabaseLocked(true);
    }
}",1,"/**
 * Create and/or open a database that will be used for reading and writing.
 * The first time this is called, the database will be opened and
 * {@link #onCreate}, {@link #onUpgrade} and/or {@link #onOpen} will be
 * called.
 *
 * <p>Once opened successfully, the database is cached, so you can
 * call this method every time you need to write to the database.
 * (Make sure to call {@link #close} when you no longer need the database.)
 * Errors such as bad permissions or a full disk may cause this method
 * to fail, but future attempts may succeed if the problem is fixed.</p>
 *
 * <p class=""caution"">Database upgrade may take a long time, you
 * should not call this method from the application main thread, including
 * from {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
 *
 * @throws SQLiteException if the database cannot be opened for writing
 * @return a read/write database object valid until {@link #close} is called
 */
","/**
 * Create and/or open a database that will be used for reading and writing.
 * The first time this is called, the database will be opened and
 * {@link #onCreate}, {@link #onUpgrade} and/or {@link #onOpen} will be
 * called.
 *
 * <p>Once opened successfully, the database is cached, so you can
 * call this method every time you need to write to the database.
 * (Make sure to call {@link #close} when you no longer need the database.)
 * Errors such as bad permissions or a full disk may cause this method
 * to fail, but future attempts may succeed if the problem is fixed.</p>
 *
 * <p class=""caution"">Database upgrade may take a long time, you
 * should not call this method from the application main thread, including
 * from {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
 *
 * @throws SQLiteException if the database cannot be opened for writing
 * @return a read/write database object valid until {@link #close} is called
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The getWritableDatabase() method has changed its function body in the latter version, involving return statement being changed and a method call (getDatabaseLocked()) being used, so the change type is 1,5.","The new implementation of the function directly calls getDatabaseLocked() and the return value is not certain in Late_Implementation compared with Early_Implementation due to the different behavior of the newly called method. It could potentially lead to a return of different object, hence the CI type is 1."
301,<android.webkit.WebView: boolean canZoomOut()>,15,16,<android.webkit.WebView: boolean canZoomOut()>,<android.webkit.WebView: boolean canZoomOut()>,0,"{
    checkThread();
    return mZoomManager.canZoomOut();
}","{
    checkThread();
    return mProvider.canZoomOut();
}",1,"/**
 * @return TRUE if the WebView can be zoomed out.
 */
","/**
 * Gets whether this WebView can be zoomed out.
 *
 * @return true if this WebView can be zoomed out
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'mZoomManager.canZoomOut()' to 'mProvider.canZoomOut()', and the API 'mZoomManager.canZoomOut()' that this method depends on has changed to 'mProvider.canZoomOut()', so the code change type is 1,5.","Different implementations of 'canZoomOut()' may return different values, so it may potentially lead to a compatibility issue - type 1."
303,<android.widget.GridLayout: LayoutParams getLayoutParams(View)>,15,16,<android.widget.GridLayout: LayoutParams getLayoutParams(View)>,<android.widget.GridLayout: LayoutParams getLayoutParams(View)>,0,"{
    if (!layoutParamsValid) {
        validateLayoutParams();
        layoutParamsValid = true;
    }
    return getLayoutParams1(c);
}","{
    return (LayoutParams) c.getLayoutParams();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method 'getLayoutParams1(c)' has been replaced by '(LayoutParams) c.getLayoutParams()'. Also, an 'if' statement block and an assignment statement have been deleted. Therefore, the change type is 1,4.","The removed 'if' block might result in different 'return' values for 'getLayoutParams1(c)' between the early and later versions. The later version will not validate and reassess layoutParamsValid while the early version does. This can lead different return values between the two versions. Thus, the CI type is 1."
304,"<android.widget.ActivityChooserView.Callbacks: void onItemClick(AdapterView<?>,View,int,long)>",15,16,"<android.widget.ActivityChooserView.Callbacks: void onItemClick(AdapterView<?>,View,int,long)>","<android.widget.ActivityChooserView.Callbacks: void onItemClick(AdapterView<?>,View,int,long)>",0,"{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        mContext.startActivity(launchIntent);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}","{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                        mContext.startActivity(launchIntent);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}",1,"// AdapterView#OnItemClickListener
","// AdapterView#OnItemClickListener
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's an addition of a new line in the late version where a flag (Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) is added to the launchIntent object. Therefore, the change type is 4 (Other statement changed).","Although a new statement was introduced, it doesn't affect the return value or the exception handling of the API, therefore there is no Compatibility Issue (CI type 0)."
305,<android.accounts.AccountManagerService.RemoveAccountSession: void onResult(Bundle)>,15,16,<android.accounts.AccountManagerService.RemoveAccountSession: void onResult(Bundle)>,<android.accounts.AccountManagerService.RemoveAccountSession: void onResult(Bundle)>,0,"{
    if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT) && !result.containsKey(AccountManager.KEY_INTENT)) {
        final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);
        if (removalAllowed) {
            removeAccountInternal(mAccount);
        }
        IAccountManagerResponse response = getResponseAndClose();
        if (response != null) {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
            }
            Bundle result2 = new Bundle();
            result2.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, removalAllowed);
            try {
                response.onResult(result2);
            } catch (RemoteException e) {
            // ignore
            }
        }
    }
    super.onResult(result);
}","{
    if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT) && !result.containsKey(AccountManager.KEY_INTENT)) {
        final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);
        if (removalAllowed) {
            removeAccountInternal(mAccounts, mAccount);
        }
        IAccountManagerResponse response = getResponseAndClose();
        if (response != null) {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
            }
            Bundle result2 = new Bundle();
            result2.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, removalAllowed);
            try {
                response.onResult(result2);
            } catch (RemoteException e) {
            // ignore
            }
        }
    }
    super.onResult(result);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"The method 'removeAccountInternal' changed its numbers and types of parameters. The calling statement has been updated according to the new parameters, therefore, types 1, 4 and 5 are detected here.",The change of the method 'removeAccountInternal' would not affect the outcome of 'onResult' method because the returned value and the exception handled in these two versions are the same. There is no compatibility issue detected here (type 0).
306,<android.view.View: int getSuggestedMinimumWidth()>,15,16,<android.view.View: int getSuggestedMinimumWidth()>,<android.view.View: int getSuggestedMinimumWidth()>,0,"{
    int suggestedMinWidth = mMinWidth;
    if (mBGDrawable != null) {
        final int bgMinWidth = mBGDrawable.getMinimumWidth();
        if (suggestedMinWidth < bgMinWidth) {
            suggestedMinWidth = bgMinWidth;
        }
    }
    return suggestedMinWidth;
}","{
    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}",1,"/**
 * Returns the suggested minimum width that the view should use. This
 * returns the maximum of the view's minimum width)
 * and the background's minimum width
 * ({@link android.graphics.drawable.Drawable#getMinimumWidth()}).
 * <p>
 * When being used in {@link #onMeasure(int, int)}, the caller should still
 * ensure the returned width is within the requirements of the parent.
 *
 * @return The suggested minimum width of the view.
 */
","/**
 * Returns the suggested minimum width that the view should use. This
 * returns the maximum of the view's minimum width)
 * and the background's minimum width
 * ({@link android.graphics.drawable.Drawable#getMinimumWidth()}).
 * <p>
 * When being used in {@link #onMeasure(int, int)}, the caller should still
 * ensure the returned width is within the requirements of the parent.
 *
 * @return The suggested minimum width of the view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The condition for determining the return value has been changed from comparison (`if (suggestedMinWidth < bgMinWidth)`) to a conditional operator (`(mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth())`). At the same time, the variable names also change (`mBGDrawable`->`mBackground`). So the code change type is 1,3,4.",The value returned by `getSuggestedMinimumWidth()` may be different between the early and late versions due to the changes in condition and the variables in use. Thus the CI type is 1.
307,<android.webkit.WebSettings: void setLightTouchEnabled(boolean)>,15,16,<android.webkit.WebSettings: void setLightTouchEnabled(boolean)>,<android.webkit.WebSettings: void setLightTouchEnabled(boolean)>,0,"{
    mLightTouchEnabled = enabled;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Enables using light touches to make a selection and activate mouseovers.
 */
","/**
 * Enables using light touches to make a selection and activate mouseovers.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"In the latest implementation, the method throw a new exception 'MustOverrideException' and the old implementation is removed. So, the code change type is 2.","Since the method is now throwing a new exception 'MustOverrideException', it brings a compatibility issue in the form of different exception handling. Therefore, the CI type is 2."
308,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>",15,16,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>",0,"{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), modeToMode(uri, mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null);
        } else {
            IContentProvider provider = acquireProvider(uri);
            if (provider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            try {
                AssetFileDescriptor fd = provider.openAssetFile(uri, mode);
                if (fd == null) {
                    // The provider will be released by the finally{} clause
                    return null;
                }
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), provider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                provider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // process shortly anyway if the depdendent ContentProvider dies.
                throw new FileNotFoundException(""Dead content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (provider != null) {
                    releaseProvider(provider);
                }
            }
        }
    }
}","{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), modeToMode(uri, mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                try {
                    fd = unstableProvider.openAssetFile(uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The conditions in the control statements and dependent APIs (unstableProviderDied, acquireUnstableProvider, releaseUnstableProvider, and acquireProvider) have changed significantly from the early version to the late version, so the code change type is 3,4,5.","These changes in the control structures and exception handling could affect the return value of the entire API as well as the exceptions thrown, so the CI type is 1,2."
309,"<android.webkit.WebView: boolean requestFocus(int,Rect)>",15,16,"<android.webkit.WebView: boolean requestFocus(int,Rect)>","<android.webkit.WebView: boolean requestFocus(int,Rect)>",0,"{
    // background window, it can steal focus.
    if (mFindIsUp)
        return false;
    boolean result = false;
    if (inEditingMode()) {
        result = mWebTextView.requestFocus(direction, previouslyFocusedRect);
    } else {
        result = super.requestFocus(direction, previouslyFocusedRect);
        if (mWebViewCore.getSettings().getNeedInitialFocus() && !isInTouchMode()) {
            // For cases such as GMail, where we gain focus from a direction,
            // we want to move to the first available link.
            // FIXME: If there are no visible links, we may not want to
            int fakeKeyDirection = 0;
            switch(direction) {
                case View.FOCUS_UP:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                    break;
                case View.FOCUS_DOWN:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                    break;
                case View.FOCUS_LEFT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                    break;
                case View.FOCUS_RIGHT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                    break;
                default:
                    return result;
            }
            if (mNativeClass != 0 && !nativeHasCursorNode()) {
                navHandledKey(fakeKeyDirection, 1, true, 0);
            }
        }
    }
    return result;
}","{
    return mProvider.getViewDelegate().requestFocus(direction, previouslyFocusedRect);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire logic of the method has been replaced with a direct return statement, where a different method call is made (mProvider.getViewDelegate().requestFocus(direction, previouslyFocusedRect)), so the code change type is 1,5.","The returned value is obtained through a different method, which means the API could return a different value, hence, the CI type is 1."
312,"<android.app.Activity: boolean onMenuItemSelected(int,MenuItem)>",15,16,"<android.app.Activity: boolean onMenuItemSelected(int,MenuItem)>","<android.app.Activity: boolean onMenuItemSelected(int,MenuItem)>",0,"{
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            // Put event logging here so it gets called even if subclass
            // doesn't call through to superclass's implmeentation of each
            // of these methods below
            EventLog.writeEvent(50000, 0, item.getTitleCondensed());
            if (onOptionsItemSelected(item)) {
                return true;
            }
            return mFragments.dispatchOptionsItemSelected(item);
        case Window.FEATURE_CONTEXT_MENU:
            EventLog.writeEvent(50000, 1, item.getTitleCondensed());
            if (onContextItemSelected(item)) {
                return true;
            }
            return mFragments.dispatchContextItemSelected(item);
        default:
            return false;
    }
}","{
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            // Put event logging here so it gets called even if subclass
            // doesn't call through to superclass's implmeentation of each
            // of these methods below
            EventLog.writeEvent(50000, 0, item.getTitleCondensed());
            if (onOptionsItemSelected(item)) {
                return true;
            }
            if (mFragments.dispatchOptionsItemSelected(item)) {
                return true;
            }
            if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
                if (mParent == null) {
                    return onNavigateUp();
                } else {
                    return mParent.onNavigateUpFromChild(this);
                }
            }
            return false;
        case Window.FEATURE_CONTEXT_MENU:
            EventLog.writeEvent(50000, 1, item.getTitleCondensed());
            if (onContextItemSelected(item)) {
                return true;
            }
            return mFragments.dispatchContextItemSelected(item);
        default:
            return false;
    }
}",1,"/**
 * Default implementation of
 * {@link android.view.Window.Callback#onMenuItemSelected}
 * for activities.  This calls through to the new
 * {@link #onOptionsItemSelected} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
","/**
 * Default implementation of
 * {@link android.view.Window.Callback#onMenuItemSelected}
 * for activities.  This calls through to the new
 * {@link #onOptionsItemSelected} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the 'case Window.FEATURE_OPTIONS_PANEL:' block, a new condition is added with a new return statement and the return statement 'return mFragments.dispatchOptionsItemSelected(item);' changes to 'if (mFragments.dispatchOptionsItemSelected(item)) {return true;}'. Therefore, the change type is 1,3,4.","The change of the return statement and control condition could cause the late version method to return different boolean values, so the CI type is 1."
314,<android.app.Fragment: void startActivity(Intent)>,15,16,<android.app.Fragment: void startActivity(Intent)>,<android.app.Fragment: void startActivity(Intent)>,0,"{
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    mActivity.startActivityFromFragment(this, intent, -1);
}","{
    startActivity(intent, null);
}",1,"/**
 * Call {@link Activity#startActivity(Intent)} on the fragment's
 * containing Activity.
 */
","/**
 * Call {@link Activity#startActivity(Intent)} on the fragment's
 * containing Activity.
 *
 * @param intent The intent to start.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The implementation has changed from calling startActivityFromFragment() to directly calling startActivity(). This changes the return statement of the method and also the dependent API, thus the change type is 1,5.","The removed exception handling and the changed API call may lead to a different return value or exception when the late version is invoked. Therefore, a compatibility issue could exist and the CI type is 1,2."
315,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,15,16,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    final float y = ev.getY();
    final float x = ev.getX();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            if (mIgnoreMultitouch) {
                // Multitouch event - abort.
                cancel();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            // Ending a multitouch gesture and going back to 1 finger
            if (mIgnoreMultitouch && ev.getPointerCount() == 2) {
                int index = (((action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT) == 0) ? 1 : 0;
                mLastMotionX = ev.getX(index);
                mLastMotionY = ev.getY(index);
                mVelocityTracker.recycle();
                mVelocityTracker = VelocityTracker.obtain();
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mLastMotionX = x;
            mLastMotionY = y;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || (mIgnoreMultitouch && ev.getPointerCount() > 1)) {
                break;
            }
            final float scrollX = mLastMotionX - x;
            final float scrollY = mLastMotionY - y;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (x - mCurrentDownEvent.getX());
                final int deltaY = (int) (y - mCurrentDownEvent.getY());
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mBiggerTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastMotionX = x;
                mLastMotionY = y;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity();
                final float velocityX = velocityTracker.getXVelocity();
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    final float y = ev.getY();
    final float x = ev.getX();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            if (mIgnoreMultitouch) {
                // Multitouch event - abort.
                cancel();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            // Ending a multitouch gesture and going back to 1 finger
            if (mIgnoreMultitouch && ev.getPointerCount() == 2) {
                int index = (((action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT) == 0) ? 1 : 0;
                mLastMotionX = ev.getX(index);
                mLastMotionY = ev.getY(index);
                mVelocityTracker.recycle();
                mVelocityTracker = VelocityTracker.obtain();
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mLastMotionX = x;
            mLastMotionY = y;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || (mIgnoreMultitouch && ev.getPointerCount() > 1)) {
                break;
            }
            final float scrollX = mLastMotionX - x;
            final float scrollY = mLastMotionY - y;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (x - mCurrentDownEvent.getX());
                final int deltaY = (int) (y - mCurrentDownEvent.getY());
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastMotionX = x;
                mLastMotionY = y;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity();
                final float velocityX = velocityTracker.getXVelocity();
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
317,<android.view.MotionEvent: void recycle()>,15,16,<android.view.MotionEvent: void recycle()>,<android.view.MotionEvent: void recycle()>,0,"{
    // Ensure recycle is only called once!
    if (TRACK_RECYCLED_LOCATION) {
        if (mRecycledLocation != null) {
            throw new RuntimeException(toString() + "" recycled twice!"", mRecycledLocation);
        }
        mRecycledLocation = new RuntimeException(""Last recycled here"");
    // Log.w(""MotionEvent"", ""Recycling event "" + this, mRecycledLocation);
    } else {
        if (mRecycled) {
            throw new RuntimeException(toString() + "" recycled twice!"");
        }
        mRecycled = true;
    }
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}","{
    super.recycle();
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}",1,"/**
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling
 * this function you must not ever touch the event again.
 */
","/**
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling
 * this function you must not ever touch the event again.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5","1,2","In the late version, the entire exception handling and condition checking part is removed and instead, the 'super.recycle()' method is being called.",#CI_description
319,<android.webkit.WebSettings: ZoomDensity getDefaultZoom()>,15,16,<android.webkit.WebSettings: ZoomDensity getDefaultZoom()>,<android.webkit.WebSettings: ZoomDensity getDefaultZoom()>,0,"{
    return mDefaultZoom;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the default zoom density of the page. This should be called from UI
 * thread.
 * @return A ZoomDensity value
 * @see WebSettings.ZoomDensity
 */
","/**
 * Gets the default zoom density of the page. This should be called from UI
 * thread.
 * @return a ZoomDensity value
 * @see WebSettings.ZoomDensity
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The return statement is replaced with a new Exception being thrown, so the code change type is 2.","As the new version throws an exception instead of returning a value as in previous version, it changes the behaviour of the method significantly and can cause compatibility issues in terms of exception handling. So, the CI type is 2."
322,<android.webkit.WebSettings: TextSize getTextSize()>,15,16,<android.webkit.WebSettings: TextSize getTextSize()>,<android.webkit.WebSettings: TextSize getTextSize()>,0,"{
    TextSize closestSize = null;
    int smallestDelta = Integer.MAX_VALUE;
    for (TextSize size : TextSize.values()) {
        int delta = Math.abs(mTextSize - size.value);
        if (delta == 0) {
            return size;
        }
        if (delta < smallestDelta) {
            smallestDelta = delta;
            closestSize = size;
        }
    }
    return closestSize != null ? closestSize : TextSize.NORMAL;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the text size of the page. If the text size was previously specified
 * in percent using {@link #setTextZoom(int)}, this will return
 * the closest matching {@link TextSize}.
 * @return A TextSize enum value describing the text size.
 * @see WebSettings.TextSize
 * @deprecated Use {@link #getTextZoom()} instead
 */
","/**
 * Gets the text size of the page. If the text size was previously specified
 * in percent using {@link #setTextZoom(int)}, this will return
 * the closest matching {@link TextSize}.
 *
 * @return a TextSize enum value describing the text size
 * @see WebSettings.TextSize
 * @deprecated Use {@link #getTextZoom()} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","All the statements of the early version method are deleted and a new throw statement is introduced in the late version, so the code change type is 1,2.","The introduced throw statement will make the API potentially throw a different exception, and the removal of all old return statements will make the API potentially return a different value or even not return a value at all, so the CI type is 1,2."
323,<android.view.HardwareRenderer.Gl20Renderer: void destroyHardwareResources(View)>,15,16,<android.view.HardwareRenderer.Gl20Renderer: void destroyHardwareResources(View)>,<android.view.HardwareRenderer.Gl20Renderer: void destroyHardwareResources(View)>,0,"{
    if (view != null) {
        boolean needsContext = true;
        if (isEnabled() && checkCurrent() != SURFACE_STATE_ERROR)
            needsContext = false;
        if (needsContext) {
            Gl20RendererEglContext managedContext = sEglContextStorage.get();
            if (managedContext == null)
                return;
            usePbufferSurface(managedContext.getContext());
        }
        destroyResources(view);
        GLES20Canvas.flushCaches(GLES20Canvas.FLUSH_CACHES_LAYERS);
    }
}","{
    if (view != null) {
        safelyRun(new Runnable() {

            @Override
            public void run() {
                destroyResources(view);
                GLES20Canvas.flushCaches(GLES20Canvas.FLUSH_CACHES_LAYERS);
            }
        });
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency and the implementation of the 'if' branch have both changed. In the earlier version, there are several checks and function calls before destroying resources and flushing caches. But in the late version, those were encapsulated into a new Runnable object. So the change types are 3,4.","Due to the changes in the control flow (condition and function calls), the behaviors of the API are potentially different, which could cause Compatibility Issue, so the CI type is 1."
327,"<android.widget.TextView: boolean setFrame(int,int,int,int)>",15,16,"<android.widget.TextView: boolean setFrame(int,int,int,int)>","<android.widget.TextView: boolean setFrame(int,int,int,int)>",0,"{
    boolean result = super.setFrame(l, t, r, b);
    if (mPopup != null) {
        TextView tv = (TextView) mPopup.getContentView();
        chooseSize(mPopup, mError, tv);
        mPopup.update(this, getErrorX(), getErrorY(), mPopup.getWidth(), mPopup.getHeight());
    }
    restartMarqueeIfNeeded();
    return result;
}","{
    boolean result = super.setFrame(l, t, r, b);
    if (mEditor != null)
        mEditor.setFrame();
    restartMarqueeIfNeeded();
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The original implementation includes calls to other methods and objects (mPopup, tv) which have been removed in the latter implementation - now calling setFrame() on object mEditor instead. Therefore, the change types are 4 and 5.","Though there's a call to a different method in the late version, the returned value 'result' of the API is not affected by this change. Therefore, no compatibility issue exists in this case."
329,"<android.webkit.CallbackProxy: boolean onSavePassword(String,String,String,Message)>",15,16,"<android.webkit.CallbackProxy: boolean onSavePassword(String,String,String,Message)>","<android.webkit.CallbackProxy: boolean onSavePassword(String,String,String,Message)>",0,"{
    // within the CallbackProxy.
    if (DebugFlags.CALLBACK_PROXY) {
        junit.framework.Assert.assertNull(resumeMsg);
    }
    resumeMsg = obtainMessage(NOTIFY);
    Message msg = obtainMessage(SAVE_PASSWORD, resumeMsg);
    Bundle bundle = msg.getData();
    bundle.putString(""host"", schemePlusHost);
    bundle.putString(""username"", username);
    bundle.putString(""password"", password);
    synchronized (this) {
        sendMessage(msg);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for onSavePassword"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    // Doesn't matter here
    return false;
}","{
    // within the CallbackProxy.
    if (DebugFlags.CALLBACK_PROXY) {
        junit.framework.Assert.assertNull(resumeMsg);
    }
    resumeMsg = obtainMessage(NOTIFY);
    Message msg = obtainMessage(SAVE_PASSWORD, resumeMsg);
    Bundle bundle = msg.getData();
    bundle.putString(""host"", schemePlusHost);
    bundle.putString(""username"", username);
    bundle.putString(""password"", password);
    sendMessageToUiThreadSync(msg);
    // Doesn't matter here
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is based on the replacement of the synchronized block and statements inside it with sendMessageToUiThreadSync(msg). It counts as other statement change, so the change type is 4.","The change does not affect the return type or value of this function, nor does it modify the exception handling behavior. Therefore, no Compatibility Issue exists, so the CI type is 0."
330,<android.view.View: boolean removeCallbacks(Runnable)>,15,16,<android.view.View: boolean removeCallbacks(Runnable)>,<android.view.View: boolean removeCallbacks(Runnable)>,0,"{
    Handler handler;
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        handler = attachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().removeCallbacks(action);
        return true;
    }
    handler.removeCallbacks(action);
    return true;
}","{
    if (action != null) {
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            attachInfo.mHandler.removeCallbacks(action);
            attachInfo.mViewRootImpl.mChoreographer.removeCallbacks(Choreographer.CALLBACK_ANIMATION, action, null);
        } else {
            // Assume that post will succeed later
            ViewRootImpl.getRunQueue().removeCallbacks(action);
        }
    }
    return true;
}",1,"/**
 * <p>Removes the specified Runnable from the message queue.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 */
","/**
 * <p>Removes the specified Runnable from the message queue.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 *
 * @see #post
 * @see #postDelayed
 * @see #postOnAnimation
 * @see #postOnAnimationDelayed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",0,The implementations differ between versions. The handling of the Runnable action has changed in the updated version. This includes the addition of a null check and removal of callbacks in the Choreographer of attachInfo.mViewRootImpl. These are classified as return statement change (1) and control dependency change (3).,"Despite the changes, the method still returns 'true'. Thus, no compatibility issue (0) exists between these two versions as they will not trigger different behaviors."
331,"<android.view.GLES20Canvas: int saveLayer(RectF,Paint,int)>",15,16,"<android.view.GLES20Canvas: int saveLayer(RectF,Paint,int)>","<android.view.GLES20Canvas: int saveLayer(RectF,Paint,int)>",0,"{
    if (bounds != null) {
        return saveLayer(bounds.left, bounds.top, bounds.right, bounds.bottom, paint, saveFlags);
    }
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    int count = nSaveLayer(mRenderer, nativePaint, saveFlags);
    if (modifier != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifier);
    return count;
}","{
    if (bounds != null) {
        return saveLayer(bounds.left, bounds.top, bounds.right, bounds.bottom, paint, saveFlags);
    }
    int count;
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        count = nSaveLayer(mRenderer, nativePaint, saveFlags);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
    return count;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",0,"The change is about adding 'try' and 'finally' block to exception handling and a new variable initialization is included, so the code change type is 2,3.","Despite the structural change, the potential behavior of the function remains the same. Regardless of whether an exception is thrown or not, the API will still execute the same statements and return the same value. Thus, no Compatibility Issue (CI) should exist, so the CI type is 0."
332,<android.database.sqlite.SQLiteStatement: ParcelFileDescriptor simpleQueryForBlobFileDescriptor()>,15,16,<android.database.sqlite.SQLiteStatement: ParcelFileDescriptor simpleQueryForBlobFileDescriptor()>,<android.database.sqlite.SQLiteStatement: ParcelFileDescriptor simpleQueryForBlobFileDescriptor()>,0,"{
    try {
        long timeStart = acquireAndLock(READ);
        ParcelFileDescriptor retValue = native_1x1_blob_ashmem();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } catch (IOException ex) {
        Log.e(TAG, ""simpleQueryForBlobFileDescriptor() failed"", ex);
        return null;
    } catch (SQLiteDoneException e) {
        throw new SQLiteDoneException(""expected 1 row from this query but query returned no data. check the query: "" + mSql);
    } finally {
        releaseAndUnlock();
    }
}","{
    acquireReference();
    try {
        return getSession().executeForBlobFileDescriptor(getSql(), getBindArgs(), getConnectionFlags(), null);
    } catch (SQLiteDatabaseCorruptException ex) {
        onCorruption();
        throw ex;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Executes a statement that returns a 1 by 1 table with a blob value.
 *
 * @return A read-only file descriptor for a copy of the blob value, or {@code null}
 * if the value is null or could not be read for some reason.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Executes a statement that returns a 1 by 1 table with a blob value.
 *
 * @return A read-only file descriptor for a copy of the blob value, or {@code null}
 * if the value is null or could not be read for some reason.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The method body has been completely refactored, native_1x1_blob_ashmem() and getSession().executeForBlobFileDescriptor() are the depended methods for the early and late versions that are different. Also, the whole try-catch block structure and its body statements including return and exception handling statements have been changed. Therefore, the change involves return change, exception change, control dependency change, dependent APIs change, and other statement change.","Given the significant changes in return and throw types, the behaviours of these two method versions could be differently, resulting in both different return values and exceptions, so both CI types 1 and 2 do exist."
333,<android.os.Handler: boolean hasMessages(int)>,15,16,<android.os.Handler: boolean hasMessages(int)>,<android.os.Handler: boolean hasMessages(int)>,0,"{
    return mQueue.removeMessages(this, what, null, false);
}","{
    return mQueue.hasMessages(this, what, null);
}",1,"/**
 * Check if there are any pending posts of messages with code 'what' in
 * the message queue.
 */
","/**
 * Check if there are any pending posts of messages with code 'what' in
 * the message queue.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mQueue.removeMessages(this, what, null, false) to mQueue.hasMessages(this, what, null) and the method called has changed, so the code change type is 1,5.",The change in return statement due to different method call could possibly lead to the API returning a different value which hence constitutes a compatibility issue of type 1.
334,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,15,16,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (hasSelectionController()) {
        getSelectionController().onTouchEvent(event);
    }
    if (action == MotionEvent.ACTION_DOWN) {
        mLastDownPositionX = event.getX();
        mLastDownPositionY = event.getY();
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mIgnoreActionUpEvent = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mDiscardNextActionUp = false;
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && !shouldIgnoreActionUpEvent() && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && mTextIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length != 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || mTextIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!mTextIsSelectable && mSoftInputShownOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            boolean selectAllGotFocus = mSelectAllOnFocus && didTouchFocusSelect();
            hideControllers();
            if (!selectAllGotFocus && mText.length() > 0) {
                if (mSpellChecker != null) {
                    // When the cursor moves, the word that was typed may need spell check
                    mSpellChecker.onSelectionChanged();
                }
                if (!extractedTextModeWillBeStarted()) {
                    if (isCursorInsideEasyCorrectionSpan()) {
                        showSuggestions();
                    } else if (hasInsertionController()) {
                        getInsertionController().show();
                    }
                }
            }
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (mEditor != null)
        mEditor.onTouchEvent(event);
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!textIsSelectable && mEditor.mShowSoftInputOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The condition statements as well as other statements (not return or exception handling statements) embedded within the if block have changed notably. Therefore, it's a mixed change of condition control dependency (3) and other statements (4).",The change led to the change in return part of the method and thus the method may output different results when invoked. Thus this change would cause a Compatibility Issue caused by potential different return values or types (1).
335,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int)>",15,16,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].setAllowFds(false);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    return getActivities(context, requestCode, intents, flags, null);
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The first Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The first Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation has multiple lines of code and in the late version it is replaced with a single call to the API 'getActivities'. Here,  the dependent API 'ActivityManagerNative.getDefault().getIntentSender()' is no longer used and a new dependent API 'getActivities' is used instead. So, the code change type is 1,5.","The change in the dependent API and the return statement may cause the API to return differently. Therefore, CI type is 1."
337,"<android.view.GLES20Canvas: void drawPicture(Picture,RectF)>",15,16,"<android.view.GLES20Canvas: void drawPicture(Picture,RectF)>","<android.view.GLES20Canvas: void drawPicture(Picture,RectF)>",0,"{
    throw new UnsupportedOperationException();
}","{
    if (picture.createdFromStream) {
        return;
    }
    save();
    translate(dst.left, dst.top);
    if (picture.getWidth() > 0 && picture.getHeight() > 0) {
        scale(dst.width() / picture.getWidth(), dst.height() / picture.getHeight());
    }
    drawPicture(picture);
    restore();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","In the early version, the method simply throws an UnsupportedOperationException. However, in the late version, exception handling statement (throw new UnsupportedOperationException();), has changed, control statements are introduced, new statements have been added, and potential return changes have been made. Therefore, the code change type is 1,2,3,4.","In the early version, the method invariably throws an UnsupportedOperationException. But in the late version, exception handling is different and the method returns different result which can either be void or not, depending on the if condition. Therefore, the CI types are 1,2."
338,<android.widget.ExpandableListConnector: boolean collapseGroup(int)>,15,16,<android.widget.ExpandableListConnector: boolean collapseGroup(int)>,<android.widget.ExpandableListConnector: boolean collapseGroup(int)>,0,"{
    PositionMetadata pm = getFlattenedPos(ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1));
    if (pm == null)
        return false;
    boolean retValue = collapseGroup(pm);
    pm.recycle();
    return retValue;
}","{
    ExpandableListPosition elGroupPos = ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1);
    PositionMetadata pm = getFlattenedPos(elGroupPos);
    elGroupPos.recycle();
    if (pm == null)
        return false;
    boolean retValue = collapseGroup(pm);
    pm.recycle();
    return retValue;
}",1,"/**
 * Collapse a group in the grouped list view
 *
 * @param groupPos position of the group to collapse
 */
","/**
 * Collapse a group in the grouped list view
 *
 * @param groupPos position of the group to collapse
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The instantiation of 'ExpandableListPosition' has been shifted out from the function call 'getFlattenedPos()' and is explicitly named as 'elGroupPos'. Plus, a new recycle() method has been called for 'elGroupPos'. So, the code change type is 4.","Given that the actual functionality and control flow hasn't been modified, and no significant changes have been made regarding exception handling or returning types/values, no Compatibility Issue (CI) exists."
341,<android.webkit.CallbackProxy: boolean uiOverrideUrlLoading(String)>,15,16,<android.webkit.CallbackProxy: boolean uiOverrideUrlLoading(String)>,<android.webkit.CallbackProxy: boolean uiOverrideUrlLoading(String)>,0,"{
    if (overrideUrl == null || overrideUrl.length() == 0) {
        return false;
    }
    boolean override = false;
    if (mWebViewClient != null) {
        override = mWebViewClient.shouldOverrideUrlLoading(mWebView, overrideUrl);
    } else {
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(overrideUrl));
        intent.addCategory(Intent.CATEGORY_BROWSABLE);
        // If another application is running a WebView and launches the
        // Browser through this Intent, we want to reuse the same window if
        // possible.
        intent.putExtra(Browser.EXTRA_APPLICATION_ID, mContext.getPackageName());
        try {
            mContext.startActivity(intent);
            override = true;
        } catch (ActivityNotFoundException ex) {
        // If no application can handle the URL, assume that the
        // browser can handle it.
        }
    }
    return override;
}","{
    if (overrideUrl == null || overrideUrl.length() == 0) {
        return false;
    }
    boolean override = false;
    if (mWebViewClient != null) {
        override = mWebViewClient.shouldOverrideUrlLoading(mWebView.getWebView(), overrideUrl);
    } else {
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(overrideUrl));
        intent.addCategory(Intent.CATEGORY_BROWSABLE);
        // If another application is running a WebView and launches the
        // Browser through this Intent, we want to reuse the same window if
        // possible.
        intent.putExtra(Browser.EXTRA_APPLICATION_ID, mContext.getPackageName());
        try {
            mContext.startActivity(intent);
            override = true;
        } catch (ActivityNotFoundException ex) {
        // If no application can handle the URL, assume that the
        // browser can handle it.
        }
    }
    return override;
}",1,"/**
 * Called by the UI side.  Calling overrideUrlLoading from the WebCore
 * side will post a message to call this method.
 */
","/**
 * Called by the UI side.  Calling overrideUrlLoading from the WebCore
 * side will post a message to call this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The invocation of `mWebView` has changed from `mWebView` to `mWebView.getWebView()`. This change belongs to both 'Other statement changed' (type 4) and 'Dependent API changed' (type 5).,"The additional method invocation `getWebView()` on `mWebView` may return different data, which can in turn affect the return result of `shouldOverrideUrlLoading()`. Therefore, the Compatibility Issue type is 1, indicating the potential for different return types or values."
342,"<android.app.Fragment: void startActivityForResult(Intent,int)>",15,16,"<android.app.Fragment: void startActivityForResult(Intent,int)>","<android.app.Fragment: void startActivityForResult(Intent,int)>",0,"{
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    mActivity.startActivityFromFragment(this, intent, requestCode);
}","{
    startActivityForResult(intent, requestCode, null);
}",1,"/**
 * Call {@link Activity#startActivityForResult(Intent, int)} on the fragment's
 * containing Activity.
 */
","/**
 * Call {@link Activity#startActivityForResult(Intent, int)} on the fragment's
 * containing Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",2,"The early version of the code includes a conditional statement that throws an exception if the condition is fulfilled, this exception handling has been removed in the late version. Additionally, the method called within the late version API has changed from mActivity.startActivityFromFragment(this, intent, requestCode); to startActivityForResult(intent, requestCode, null); So the code change type is 1,5.","The early version of the code includes a conditional statement that throws an exception if the condition is fulfilled, this exception handling has been removed in the late version, thus it could potentially throw different exceptions leading to Compatibility Issue of type 2."
343,<android.service.wallpaper.WallpaperService.Engine: void detach()>,15,16,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputChannel != null) {
                InputQueue.unregisterInputChannel(mInputChannel);
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"In the ""mCreated"" if block, the statements calling ""InputQueue.unregisterInputChannel(mInputChannel);"" and checking ""if (mInputChannel != null) {...}"" have been replaced with ""mInputEventReceiver.dispose();"" and ""mInputEventReceiver = null;"", respectively. Therefore, the change types are ""Return statement changed"" and ""Dependent API changed"".","Although the API has code changes, it doesn't affect the return type or throw any new exceptions. Therefore, there is no Compatibility Issue."
344,<android.webkit.WebSettings: void setLoadWithOverviewMode(boolean)>,15,16,<android.webkit.WebSettings: void setLoadWithOverviewMode(boolean)>,<android.webkit.WebSettings: void setLoadWithOverviewMode(boolean)>,0,"{
    mLoadWithOverviewMode = overview;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set whether the WebView loads a page with overview mode.
 */
","/**
 * Sets whether the WebView loads a page with overview mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2",The original implementation is removed and a new throw statement is introduced which throws a `MustOverrideException`. So the code change type is 1 (Return statement changed) and 2 (Exception handling statement changed).,"The deleted implementation results in a different return behaviour (from returning void to not returning) and the new Exception handling can also cause a different behaviour, so the CI type is 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)"
347,<android.app.FragmentManagerImpl: boolean dispatchContextItemSelected(MenuItem)>,15,16,<android.app.FragmentManagerImpl: boolean dispatchContextItemSelected(MenuItem)>,<android.app.FragmentManagerImpl: boolean dispatchContextItemSelected(MenuItem)>,0,"{
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden) {
                if (f.onContextItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mUserVisibleHint) {
                if (f.onContextItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The if condition in the late version has added an extra variable checking(mUserVisibleHint), so the code change type is 3.","The addition of the condition check 'f.mUserVisibleHint' has a direct influence on the execution flow of the function. This means it can potentially cause the function to return a different value due to this added check, hence the CI type is 1."
350,"<android.view.View: void measure(int,int)>",15,16,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    if ((mPrivateFlags & FORCE_LAYOUT) == FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~MEASURED_DIMENSION_SET;
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_MEASURE);
        }
        // measure ourselves, this should set the measured dimension flag back
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        // an exception to warn the developer
        if ((mPrivateFlags & MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}","{
    if ((mPrivateFlags & FORCE_LAYOUT) == FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~MEASURED_DIMENSION_SET;
        // measure ourselves, this should set the measured dimension flag back
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        // an exception to warn the developer
        if ((mPrivateFlags & MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual mesurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overriden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The deletion of the DEBUG related codes is the only change, so code change type is 4.","This change is just about removing the debug code, this does not change the behaviour of the original function, so no CI exists. The CI type is 0."
352,<android.database.sqlite.SQLiteClosable: void acquireReference()>,15,16,<android.database.sqlite.SQLiteClosable: void acquireReference()>,<android.database.sqlite.SQLiteClosable: void acquireReference()>,0,"{
    synchronized (this) {
        if (mReferenceCount <= 0) {
            throw new IllegalStateException(""attempt to re-open an already-closed object: "" + getObjInfo());
        }
        mReferenceCount++;
    }
}","{
    synchronized (this) {
        if (mReferenceCount <= 0) {
            throw new IllegalStateException(""attempt to re-open an already-closed object: "" + this);
        }
        mReferenceCount++;
    }
}",1,,"/**
 * Acquires a reference to the object.
 *
 * @throws IllegalStateException if the last reference to the object has already
 * been released.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,2,"The string attached in the error message of throw statement changes from getObjInfo() to ""this"", therefore, the code change type is 4.","The change in the error message of throw statement could potentially lead to different behaviours when the exception is thrown, which makes the CI type is 2."
353,<android.view.GLES20Canvas: void drawPicture(Picture)>,15,16,<android.view.GLES20Canvas: void drawPicture(Picture)>,<android.view.GLES20Canvas: void drawPicture(Picture)>,0,"{
    throw new UnsupportedOperationException();
}","{
    if (picture.createdFromStream) {
        return;
    }
    picture.endRecording();
// TODO: Implement rendering
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"In the late version, the throw statement is removed, and new statements are added to handle the operations on the picture. Hence, both exception handling statement and other statement have changed, so the code change class is 2,4.","In the early version, an UnsupportedOperationException is thrown whenever the function is called. However, in the late version, this exception handling is removed, which leads to different exception handling between the two versions. Hence, the Compatibility Issue exists, under class 2."
354,<android.webkit.WebSettings: void setUseDoubleTree(boolean)>,15,16,<android.webkit.WebSettings: void setUseDoubleTree(boolean)>,<android.webkit.WebSettings: void setUseDoubleTree(boolean)>,0,"{
    return;
}","{
// Specified to do nothing, so no need for derived classes to override.
}",1,"/**
 * @deprecated This setting controlled a rendering optimization
 * that is no longer present. Setting it now has no effect.
 */
","/**
 * Controlled a rendering optimization that is no longer present. Setting
 * it now has no effect.
 *
 * @deprecated This setting now has no effect.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change, only the comments in the implementation are different.","Since there is no actual change in the implementation, the API behavior stays the same. There won't be any compatibility issue between these two versions."
356,<android.webkit.WebView: SslCertificate getCertificate()>,15,16,<android.webkit.WebView: SslCertificate getCertificate()>,<android.webkit.WebView: SslCertificate getCertificate()>,0,"{
    checkThread();
    return mCertificate;
}","{
    checkThread();
    return mProvider.getCertificate();
}",1,"/**
 * @return The SSL certificate for the main top-level page or null if
 * there is no certificate (the site is not secure).
 */
","/**
 * Gets the SSL certificate for the main top-level page or null if there is
 * no certificate (the site is not secure).
 *
 * @return the SSL certificate for the main top-level page
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 5",1,"The return statement has been changed from returning `mCertificate` to returning `mProvider.getCertificate()`. Also, the dependent API `getCertificate()` has been introduced, which makes the classes of change 1 and 5.","The return statement has been changed, thus it could potentially return different variable type or value, therefore causing a compatibility issue of type 1."
357,<android.app.FragmentManagerImpl: Fragment findFragmentById(int)>,15,16,<android.app.FragmentManagerImpl: Fragment findFragmentById(int)>,<android.app.FragmentManagerImpl: Fragment findFragmentById(int)>,0,"{
    if (mActive != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    return null;
}","{
    if (mAdded != null) {
        // First look through added fragments.
        for (int i = mAdded.size() - 1; i >= 0; i--) {
            Fragment f = mAdded.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    if (mActive != null) {
        // Now for any known fragment.
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && f.mFragmentId == id) {
                return f;
            }
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The order and dependency of the 'for' loops in the early and late versions are different. In the early version, it firstly checks if 'mActive' is not null, then loops through 'mAdded' and 'mActive'. In the late version, it firstly checks if 'mAdded' is not null, then loops through 'mAdded', after that it checks if 'mActive' is not null and loops through 'mActive'. Therefore, the code change belongs to category 3 (Control dependency changed).","For the early version, if 'mActive' is null, it will directly return null without checking 'mAdded'; While for the late version, even if 'mActive' is null, it can still potentially return a Fragment by checking 'mAdded'. So, this may cause the method to potentially return different variables in the two versions. So it belongs to category 1 (Compatibility Issue caused by potential different return values or types)."
358,"<android.webkit.WebView: void onOverScrolled(int,int,boolean,boolean)>",15,16,"<android.webkit.WebView: void onOverScrolled(int,int,boolean,boolean)>","<android.webkit.WebView: void onOverScrolled(int,int,boolean,boolean)>",0,"{
    // updating.
    if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
        scrollLayerTo(scrollX, scrollY);
        return;
    }
    mInOverScrollMode = false;
    int maxX = computeMaxScrollX();
    int maxY = computeMaxScrollY();
    if (maxX == 0) {
        // do not over scroll x if the page just fits the screen
        scrollX = pinLocX(scrollX);
    } else if (scrollX < 0 || scrollX > maxX) {
        mInOverScrollMode = true;
    }
    if (scrollY < 0 || scrollY > maxY) {
        mInOverScrollMode = true;
    }
    int oldX = mScrollX;
    int oldY = mScrollY;
    super.scrollTo(scrollX, scrollY);
    if (mOverScrollGlow != null) {
        mOverScrollGlow.pullGlow(mScrollX, mScrollY, oldX, oldY, maxX, maxY);
    }
}","{
    mProvider.getViewDelegate().onOverScrolled(scrollX, scrollY, clampedX, clampedY);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire Early Implementation block has been replaced by a single line of code, so the statements and order of execution within the code has changed significantly. It also calls another API, hence the change type is 1,4,5.","From the late implementation, it can be seen that the current API implementation relies on another API, and that API alone will determine the API's behavior, so the behavior of the API could indeed be different, and the Compatibility Issue type is 1."
360,<android.app.LoadedApk.ReceiverDispatcher.Args: void run()>,15,16,<android.app.LoadedApk.ReceiverDispatcher.Args: void run()>,<android.app.LoadedApk.ReceiverDispatcher.Args: void run()>,0,"{
    final BroadcastReceiver receiver = mReceiver;
    final boolean ordered = mOrdered;
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
        Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
    }
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    final Intent intent = mCurIntent;
    mCurIntent = null;
    if (receiver == null || mForgotten) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        return;
    }
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        setExtrasClassLoader(cl);
        receiver.setPendingResult(this);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (receiver.getPendingResult() != null) {
        finish();
    }
}","{
    final BroadcastReceiver receiver = mReceiver;
    final boolean ordered = mOrdered;
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
        Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
    }
    final IActivityManager mgr = ActivityManagerNative.getDefault();
    final Intent intent = mCurIntent;
    mCurIntent = null;
    if (receiver == null || mForgotten) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        return;
    }
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        setExtrasClassLoader(cl);
        receiver.setPendingResult(this);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && ordered) {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
            sendFinished(mgr);
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (receiver.getPendingResult() != null) {
        finish();
    }
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The `Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");` and `Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);` have been added in the late version, which is not present in the early version, but these are tracing statements and do not affect the basic functionality of the method, hence the change type is 4.","The added trace statements in the late version merely trace the execution time and do not alter the behaviour of the method, so the CI type is 0, meaning no Compatibility Issue exists."
363,<android.webkit.WebSettings: boolean getDatabaseEnabled()>,15,16,<android.webkit.WebSettings: boolean getDatabaseEnabled()>,<android.webkit.WebSettings: boolean getDatabaseEnabled()>,0,"{
    return mDatabaseEnabled;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if database storage API is enabled.
 * @return True if the database storage API is enabled.
 */
","/**
 * Gets whether the database storage API is enabled.
 *
 * @return true if the database storage API is enabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version returned a boolean value from 'mDatabaseEnabled' but the late version throws an exception, making the code change type 2 (Exception handling statement changed) and 1 (Return statement changed).","The early version of the method didn't throw an exception, but the late version does, hence causing a compatibility issue (class 2). Also, the comparison of the returned true or false values with an exception thrown renders some potential issues, hence compatibility issue of class 1."
364,<android.widget.TextView: Bundle getInputExtras(boolean)>,15,16,<android.widget.TextView: Bundle getInputExtras(boolean)>,<android.widget.TextView: Bundle getInputExtras(boolean)>,0,"{
    if (mInputContentType == null) {
        if (!create)
            return null;
        mInputContentType = new InputContentType();
    }
    if (mInputContentType.extras == null) {
        if (!create)
            return null;
        mInputContentType.extras = new Bundle();
    }
    return mInputContentType.extras;
}","{
    if (mEditor == null && !create)
        return null;
    createEditorIfNeeded();
    if (mEditor.mInputContentType == null) {
        if (!create)
            return null;
        mEditor.createInputContentTypeIfNeeded();
    }
    if (mEditor.mInputContentType.extras == null) {
        if (!create)
            return null;
        mEditor.mInputContentType.extras = new Bundle();
    }
    return mEditor.mInputContentType.extras;
}",1,"/**
 * Retrieve the input extras currently associated with the text view, which
 * can be viewed as well as modified.
 *
 * @param create If true, the extras will be created if they don't already
 * exist.  Otherwise, null will be returned if none have been created.
 * @see #setInputExtras(int)
 * @see EditorInfo#extras
 * @attr ref android.R.styleable#TextView_editorExtras
 */
","/**
 * Retrieve the input extras currently associated with the text view, which
 * can be viewed as well as modified.
 *
 * @param create If true, the extras will be created if they don't already
 * exist.  Otherwise, null will be returned if none have been created.
 * @see #setInputExtras(int)
 * @see EditorInfo#extras
 * @attr ref android.R.styleable#TextView_editorExtras
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The 'if' condition checks and its associated statements have changed, as well as 'return' statements. Additionally, the depended API createEditorIfNeeded() and mEditor.createInputContentTypeIfNeeded() are new and the way the program interacts with mEditor has also changed. Hence the code change is classed as 1,3,4,5.","The creation and retrieval of 'extras' have changed, so it is possible for different 'extras' (or null) to be returned, which makes the API return a different value or type. Hence, the CI type is 1."
366,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,15,16,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,0,"{
    // Stop the current speech item unconditionally.
    SpeechItem current = setCurrentSpeechItem(null);
    if (current != null) {
        current.stop();
    }
    // Remove all other items from the queue.
    removeCallbacksAndMessages(null);
    // Remove all pending playback as well.
    mAudioPlaybackHandler.removeAllItems();
    return TextToSpeech.SUCCESS;
}","{
    // Stop the current speech item unconditionally.
    SpeechItem current = setCurrentSpeechItem(null);
    if (current != null) {
        current.stop();
    }
    // Remove all other items from the queue.
    removeCallbacksAndMessages(null);
    // Remove all pending playback as well.
    mAudioPlaybackHandler.stop();
    return TextToSpeech.SUCCESS;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The calling method removeAllItems() has changed to stop() on the 'mAudioPlaybackHandler' instance, so the code change type is 4.","Although the method call on 'mAudioPlaybackHandler' instance has changed, both methods seem to aim to stop all pending playback and the return statement is unchanged. So, there is no Compatibility Issue in the API. CI type is 0."
368,"<android.database.sqlite.SQLiteDatabase: Cursor rawQuery(String,String[])>",15,16,"<android.database.sqlite.SQLiteDatabase: Cursor rawQuery(String,String[])>","<android.database.sqlite.SQLiteDatabase: Cursor rawQuery(String,String[])>",0,"{
    return rawQueryWithFactory(null, sql, selectionArgs, null);
}","{
    return rawQueryWithFactory(null, sql, selectionArgs, null, null);
}",1,"/**
 * Runs the provided SQL and returns a {@link Cursor} over the result set.
 *
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
","/**
 * Runs the provided SQL and returns a {@link Cursor} over the result set.
 *
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"Dependent API 'rawQueryWithFactory' has added an extra parameter in its method signature, which falls under category 5 as a dependent API change.","Since an additional parameter is added to the dependent API, the API may behave differently thus potentially returning a different value. Therefore, we determine that a Compatibility Issue could occur and belongs to type 1, which is caused by potential different return values or types."
369,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",15,16,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (action == MotionEvent.ACTION_DOWN) {
            if (isSelecting(buffer)) {
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            if (isSelecting(buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isSelecting(buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            } else if (!widget.shouldIgnoreActionUpEvent()) {
                Selection.setSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (action == MotionEvent.ACTION_DOWN) {
            if (isSelecting(buffer)) {
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            if (isSelecting(buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isSelecting(buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The statement ""if (!widget.shouldIgnoreActionUpEvent()) {Selection.setSelection(buffer, offset);}"" has been removed in the late version from the if condition where action == MotionEvent.ACTION_UP in the ""if (widget.isFocused() && !widget.didTouchFocusSelect())"" condition, so the change type is 1.","Due to the removal of the previous statement, the return value of the method can potentially change, because the missing code could have potentially changed the value of `buffer` which in turn may affect the value of `handled`, which is finally returned by the function. Thus, the CI type is 1."
370,<android.webkit.WebIconDatabase: void close()>,15,16,<android.webkit.WebIconDatabase: void close()>,<android.webkit.WebIconDatabase: void close()>,0,"{
    mEventHandler.postMessage(Message.obtain(null, EventHandler.CLOSE));
}","{
    throw new MustOverrideException();
}",1,"/**
 * Close the shared instance of the icon database.
 */
","/**
 * Close the shared instance of the icon database.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"In the late version of the API, a new exception throw statement throw new MustOverrideException(); is added, replacing the statement mEventHandler.postMessage(Message.obtain(null, EventHandler.CLOSE));. Hence, the code change types are 2 (exception handling statement changed) and 4(other statement changed).","Due to the change, the late version of the API will throw a different exception compared to the early version, hence the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
371,<android.widget.TextView: void onDraw(Canvas)>,15,16,<android.widget.TextView: void onDraw(Canvas)>,<android.widget.TextView: void onDraw(Canvas)>,0,"{
    if (mPreDrawState == PREDRAW_DONE) {
        final ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnPreDrawListener(this);
        mPreDrawState = PREDRAW_NOT_REGISTERED;
    }
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return;
    restartMarqueeIfNeeded();
    // Draw the background for this view
    super.onDraw(canvas);
    final int compoundPaddingLeft = getCompoundPaddingLeft();
    final int compoundPaddingTop = getCompoundPaddingTop();
    final int compoundPaddingRight = getCompoundPaddingRight();
    final int compoundPaddingBottom = getCompoundPaddingBottom();
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    final int right = mRight;
    final int left = mLeft;
    final int bottom = mBottom;
    final int top = mTop;
    final Drawables dr = mDrawables;
    if (dr != null) {
        /*
             * Compound, not extended, because the icon is not clipped
             * if the text height is smaller.
             */
        int vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;
        int hspace = right - left - compoundPaddingRight - compoundPaddingLeft;
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableLeft != null) {
            canvas.save();
            canvas.translate(scrollX + mPaddingLeft, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / 2);
            dr.mDrawableLeft.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableRight != null) {
            canvas.save();
            canvas.translate(scrollX + right - left - mPaddingRight - dr.mDrawableSizeRight, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / 2);
            dr.mDrawableRight.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableTop != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthTop) / 2, scrollY + mPaddingTop);
            dr.mDrawableTop.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableBottom != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthBottom) / 2, scrollY + bottom - top - mPaddingBottom - dr.mDrawableSizeBottom);
            dr.mDrawableBottom.draw(canvas);
            canvas.restore();
        }
    }
    int color = mCurTextColor;
    if (mLayout == null) {
        assumeLayout();
    }
    Layout layout = mLayout;
    int cursorcolor = color;
    if (mHint != null && mText.length() == 0) {
        if (mHintTextColor != null) {
            color = mCurHintTextColor;
        }
        layout = mHintLayout;
    }
    mTextPaint.setColor(color);
    if (mCurrentAlpha != 255) {
        // If set, the alpha will override the color's alpha. Multiply the alphas.
        mTextPaint.setAlpha((mCurrentAlpha * Color.alpha(color)) / 255);
    }
    mTextPaint.drawableState = getDrawableState();
    canvas.save();
    /*  Would be faster if we didn't have to do this. Can we chop the
            (displayable) text so that we don't need to do this ever?
        */
    int extendedPaddingTop = getExtendedPaddingTop();
    int extendedPaddingBottom = getExtendedPaddingBottom();
    float clipLeft = compoundPaddingLeft + scrollX;
    float clipTop = extendedPaddingTop + scrollY;
    float clipRight = right - left - compoundPaddingRight + scrollX;
    float clipBottom = bottom - top - extendedPaddingBottom + scrollY;
    if (mShadowRadius != 0) {
        clipLeft += Math.min(0, mShadowDx - mShadowRadius);
        clipRight += Math.max(0, mShadowDx + mShadowRadius);
        clipTop += Math.min(0, mShadowDy - mShadowRadius);
        clipBottom += Math.max(0, mShadowDy + mShadowRadius);
    }
    canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);
    int voffsetText = 0;
    int voffsetCursor = 0;
    // translate in by our padding
    {
        /* shortcircuit calling getVerticaOffset() */
        if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
            voffsetText = getVerticalOffset(false);
            voffsetCursor = getVerticalOffset(true);
        }
        canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);
    }
    final int layoutDirection = getResolvedLayoutDirection();
    final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (!mSingleLine && getLineCount() == 1 && canMarquee() && (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) {
            canvas.translate(mLayout.getLineRight(0) - (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight()), 0.0f);
        }
        if (mMarquee != null && mMarquee.isRunning()) {
            canvas.translate(-mMarquee.mScroll, 0.0f);
        }
    }
    Path highlight = null;
    int selStart = -1, selEnd = -1;
    boolean drawCursor = false;
    // selection manually if it really wanted to.
    if (mMovement != null && (isFocused() || isPressed())) {
        selStart = getSelectionStart();
        selEnd = getSelectionEnd();
        if (selStart >= 0) {
            if (mHighlightPath == null)
                mHighlightPath = new Path();
            if (selStart == selEnd) {
                if (isCursorVisible() && (SystemClock.uptimeMillis() - mShowCursor) % (2 * BLINK) < BLINK) {
                    if (mHighlightPathBogus) {
                        mHighlightPath.reset();
                        mLayout.getCursorPath(selStart, mHighlightPath, mText);
                        updateCursorsPositions();
                        mHighlightPathBogus = false;
                    }
                    // XXX should pass to skin instead of drawing directly
                    mHighlightPaint.setColor(cursorcolor);
                    if (mCurrentAlpha != 255) {
                        mHighlightPaint.setAlpha((mCurrentAlpha * Color.alpha(cursorcolor)) / 255);
                    }
                    mHighlightPaint.setStyle(Paint.Style.STROKE);
                    highlight = mHighlightPath;
                    drawCursor = mCursorCount > 0;
                }
            } else if (textCanBeSelected()) {
                if (mHighlightPathBogus) {
                    mHighlightPath.reset();
                    mLayout.getSelectionPath(selStart, selEnd, mHighlightPath);
                    mHighlightPathBogus = false;
                }
                // XXX should pass to skin instead of drawing directly
                mHighlightPaint.setColor(mHighlightColor);
                if (mCurrentAlpha != 255) {
                    mHighlightPaint.setAlpha((mCurrentAlpha * Color.alpha(mHighlightColor)) / 255);
                }
                mHighlightPaint.setStyle(Paint.Style.FILL);
                highlight = mHighlightPath;
            }
        }
    }
    /*  Comment out until we decide what to do about animations
        boolean isLinearTextOn = false;
        if (currentTransformation != null) {
            isLinearTextOn = mTextPaint.isLinearTextOn();
            Matrix m = currentTransformation.getMatrix();
            if (!m.isIdentity()) {
                // mTextPaint.setLinearTextOn(true);
            }
        }
        */
    final InputMethodState ims = mInputMethodState;
    final int cursorOffsetVertical = voffsetCursor - voffsetText;
    if (ims != null && ims.mBatchEditNesting == 0) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            if (imm.isActive(this)) {
                boolean reported = false;
                if (ims.mContentChanged || ims.mSelectionModeChanged) {
                    // We are in extract mode and the content has changed
                    // in some way... just report complete new text to the
                    // input method.
                    reported = reportExtractedText();
                }
                if (!reported && highlight != null) {
                    int candStart = -1;
                    int candEnd = -1;
                    if (mText instanceof Spannable) {
                        Spannable sp = (Spannable) mText;
                        candStart = EditableInputConnection.getComposingSpanStart(sp);
                        candEnd = EditableInputConnection.getComposingSpanEnd(sp);
                    }
                    imm.updateSelection(this, selStart, selEnd, candStart, candEnd);
                }
            }
            if (imm.isWatchingCursor(this) && highlight != null) {
                highlight.computeBounds(ims.mTmpRectF, true);
                ims.mTmpOffset[0] = ims.mTmpOffset[1] = 0;
                canvas.getMatrix().mapPoints(ims.mTmpOffset);
                ims.mTmpRectF.offset(ims.mTmpOffset[0], ims.mTmpOffset[1]);
                ims.mTmpRectF.offset(0, cursorOffsetVertical);
                ims.mCursorRectInWindow.set((int) (ims.mTmpRectF.left + 0.5), (int) (ims.mTmpRectF.top + 0.5), (int) (ims.mTmpRectF.right + 0.5), (int) (ims.mTmpRectF.bottom + 0.5));
                imm.updateCursor(this, ims.mCursorRectInWindow.left, ims.mCursorRectInWindow.top, ims.mCursorRectInWindow.right, ims.mCursorRectInWindow.bottom);
            }
        }
    }
    if (mCorrectionHighlighter != null) {
        mCorrectionHighlighter.draw(canvas, cursorOffsetVertical);
    }
    if (drawCursor) {
        drawCursor(canvas, cursorOffsetVertical);
        // Rely on the drawable entirely, do not draw the cursor line.
        // Has to be done after the IMM related code above which relies on the highlight.
        highlight = null;
    }
    layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    if (mMarquee != null && mMarquee.shouldDrawGhost()) {
        canvas.translate((int) mMarquee.getGhostOffset(), 0.0f);
        layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    }
    /*  Comment out until we decide what to do about animations
        if (currentTransformation != null) {
            mTextPaint.setLinearTextOn(isLinearTextOn);
        }
        */
    canvas.restore();
}","{
    restartMarqueeIfNeeded();
    // Draw the background for this view
    super.onDraw(canvas);
    final int compoundPaddingLeft = getCompoundPaddingLeft();
    final int compoundPaddingTop = getCompoundPaddingTop();
    final int compoundPaddingRight = getCompoundPaddingRight();
    final int compoundPaddingBottom = getCompoundPaddingBottom();
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    final int right = mRight;
    final int left = mLeft;
    final int bottom = mBottom;
    final int top = mTop;
    final Drawables dr = mDrawables;
    if (dr != null) {
        /*
             * Compound, not extended, because the icon is not clipped
             * if the text height is smaller.
             */
        int vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;
        int hspace = right - left - compoundPaddingRight - compoundPaddingLeft;
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableLeft != null) {
            canvas.save();
            canvas.translate(scrollX + mPaddingLeft, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / 2);
            dr.mDrawableLeft.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableRight != null) {
            canvas.save();
            canvas.translate(scrollX + right - left - mPaddingRight - dr.mDrawableSizeRight, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / 2);
            dr.mDrawableRight.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableTop != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthTop) / 2, scrollY + mPaddingTop);
            dr.mDrawableTop.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableBottom != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthBottom) / 2, scrollY + bottom - top - mPaddingBottom - dr.mDrawableSizeBottom);
            dr.mDrawableBottom.draw(canvas);
            canvas.restore();
        }
    }
    int color = mCurTextColor;
    if (mLayout == null) {
        assumeLayout();
    }
    Layout layout = mLayout;
    if (mHint != null && mText.length() == 0) {
        if (mHintTextColor != null) {
            color = mCurHintTextColor;
        }
        layout = mHintLayout;
    }
    mTextPaint.setColor(color);
    mTextPaint.drawableState = getDrawableState();
    canvas.save();
    /*  Would be faster if we didn't have to do this. Can we chop the
            (displayable) text so that we don't need to do this ever?
        */
    int extendedPaddingTop = getExtendedPaddingTop();
    int extendedPaddingBottom = getExtendedPaddingBottom();
    final int vspace = mBottom - mTop - compoundPaddingBottom - compoundPaddingTop;
    final int maxScrollY = mLayout.getHeight() - vspace;
    float clipLeft = compoundPaddingLeft + scrollX;
    float clipTop = (scrollY == 0) ? 0 : extendedPaddingTop + scrollY;
    float clipRight = right - left - compoundPaddingRight + scrollX;
    float clipBottom = bottom - top + scrollY - ((scrollY == maxScrollY) ? 0 : extendedPaddingBottom);
    if (mShadowRadius != 0) {
        clipLeft += Math.min(0, mShadowDx - mShadowRadius);
        clipRight += Math.max(0, mShadowDx + mShadowRadius);
        clipTop += Math.min(0, mShadowDy - mShadowRadius);
        clipBottom += Math.max(0, mShadowDy + mShadowRadius);
    }
    canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);
    int voffsetText = 0;
    int voffsetCursor = 0;
    /* shortcircuit calling getVerticaOffset() */
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        voffsetText = getVerticalOffset(false);
        voffsetCursor = getVerticalOffset(true);
    }
    canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);
    final int layoutDirection = getResolvedLayoutDirection();
    final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (!mSingleLine && getLineCount() == 1 && canMarquee() && (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) {
            canvas.translate(mLayout.getLineRight(0) - (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight()), 0.0f);
        }
        if (mMarquee != null && mMarquee.isRunning()) {
            canvas.translate(-mMarquee.mScroll, 0.0f);
        }
    }
    final int cursorOffsetVertical = voffsetCursor - voffsetText;
    Path highlight = getUpdatedHighlightPath();
    if (mEditor != null) {
        mEditor.onDraw(canvas, layout, highlight, mHighlightPaint, cursorOffsetVertical);
    } else {
        layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    }
    if (mMarquee != null && mMarquee.shouldDrawGhost()) {
        canvas.translate((int) mMarquee.getGhostOffset(), 0.0f);
        layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    }
    canvas.restore();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
374,"<com.google.android.mms.pdu.PduPersister: void updateHeaders(Uri,SendReq)>",15,16,"<com.google.android.mms.pdu.PduPersister: void updateHeaders(Uri,SendReq)>","<com.google.android.mms.pdu.PduPersister: void updateHeaders(Uri,SendReq)>",0,"{
    PDU_CACHE_INSTANCE.purge(uri);
    ContentValues values = new ContentValues(10);
    byte[] contentType = sendReq.getContentType();
    if (contentType != null) {
        values.put(Mms.CONTENT_TYPE, toIsoString(contentType));
    }
    long date = sendReq.getDate();
    if (date != -1) {
        values.put(Mms.DATE, date);
    }
    int deliveryReport = sendReq.getDeliveryReport();
    if (deliveryReport != 0) {
        values.put(Mms.DELIVERY_REPORT, deliveryReport);
    }
    long expiry = sendReq.getExpiry();
    if (expiry != -1) {
        values.put(Mms.EXPIRY, expiry);
    }
    byte[] msgClass = sendReq.getMessageClass();
    if (msgClass != null) {
        values.put(Mms.MESSAGE_CLASS, toIsoString(msgClass));
    }
    int priority = sendReq.getPriority();
    if (priority != 0) {
        values.put(Mms.PRIORITY, priority);
    }
    int readReport = sendReq.getReadReport();
    if (readReport != 0) {
        values.put(Mms.READ_REPORT, readReport);
    }
    byte[] transId = sendReq.getTransactionId();
    if (transId != null) {
        values.put(Mms.TRANSACTION_ID, toIsoString(transId));
    }
    EncodedStringValue subject = sendReq.getSubject();
    if (subject != null) {
        values.put(Mms.SUBJECT, toIsoString(subject.getTextString()));
        values.put(Mms.SUBJECT_CHARSET, subject.getCharacterSet());
    } else {
        values.put(Mms.SUBJECT, """");
    }
    long messageSize = sendReq.getMessageSize();
    if (messageSize > 0) {
        values.put(Mms.MESSAGE_SIZE, messageSize);
    }
    PduHeaders headers = sendReq.getPduHeaders();
    HashSet<String> recipients = new HashSet<String>();
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = null;
        if (addrType == PduHeaders.FROM) {
            EncodedStringValue v = headers.getEncodedStringValue(addrType);
            if (v != null) {
                array = new EncodedStringValue[1];
                array[0] = v;
            }
        } else {
            array = headers.getEncodedStringValues(addrType);
        }
        if (array != null) {
            long msgId = ContentUris.parseId(uri);
            updateAddress(msgId, addrType, array);
            if (addrType == PduHeaders.TO) {
                for (EncodedStringValue v : array) {
                    if (v != null) {
                        recipients.add(v.getString());
                    }
                }
            }
        }
    }
    long threadId = Threads.getOrCreateThreadId(mContext, recipients);
    values.put(Mms.THREAD_ID, threadId);
    SqliteWrapper.update(mContext, mContentResolver, uri, values, null, null);
}","{
    synchronized (PDU_CACHE_INSTANCE) {
        // purging it.
        if (PDU_CACHE_INSTANCE.isUpdating(uri)) {
            if (LOCAL_LOGV) {
                Log.v(TAG, ""updateHeaders: "" + uri + "" blocked by isUpdating()"");
            }
            try {
                PDU_CACHE_INSTANCE.wait();
            } catch (InterruptedException e) {
                Log.e(TAG, ""updateHeaders: "", e);
            }
        }
    }
    PDU_CACHE_INSTANCE.purge(uri);
    ContentValues values = new ContentValues(10);
    byte[] contentType = sendReq.getContentType();
    if (contentType != null) {
        values.put(Mms.CONTENT_TYPE, toIsoString(contentType));
    }
    long date = sendReq.getDate();
    if (date != -1) {
        values.put(Mms.DATE, date);
    }
    int deliveryReport = sendReq.getDeliveryReport();
    if (deliveryReport != 0) {
        values.put(Mms.DELIVERY_REPORT, deliveryReport);
    }
    long expiry = sendReq.getExpiry();
    if (expiry != -1) {
        values.put(Mms.EXPIRY, expiry);
    }
    byte[] msgClass = sendReq.getMessageClass();
    if (msgClass != null) {
        values.put(Mms.MESSAGE_CLASS, toIsoString(msgClass));
    }
    int priority = sendReq.getPriority();
    if (priority != 0) {
        values.put(Mms.PRIORITY, priority);
    }
    int readReport = sendReq.getReadReport();
    if (readReport != 0) {
        values.put(Mms.READ_REPORT, readReport);
    }
    byte[] transId = sendReq.getTransactionId();
    if (transId != null) {
        values.put(Mms.TRANSACTION_ID, toIsoString(transId));
    }
    EncodedStringValue subject = sendReq.getSubject();
    if (subject != null) {
        values.put(Mms.SUBJECT, toIsoString(subject.getTextString()));
        values.put(Mms.SUBJECT_CHARSET, subject.getCharacterSet());
    } else {
        values.put(Mms.SUBJECT, """");
    }
    long messageSize = sendReq.getMessageSize();
    if (messageSize > 0) {
        values.put(Mms.MESSAGE_SIZE, messageSize);
    }
    PduHeaders headers = sendReq.getPduHeaders();
    HashSet<String> recipients = new HashSet<String>();
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = null;
        if (addrType == PduHeaders.FROM) {
            EncodedStringValue v = headers.getEncodedStringValue(addrType);
            if (v != null) {
                array = new EncodedStringValue[1];
                array[0] = v;
            }
        } else {
            array = headers.getEncodedStringValues(addrType);
        }
        if (array != null) {
            long msgId = ContentUris.parseId(uri);
            updateAddress(msgId, addrType, array);
            if (addrType == PduHeaders.TO) {
                for (EncodedStringValue v : array) {
                    if (v != null) {
                        recipients.add(v.getString());
                    }
                }
            }
        }
    }
    if (!recipients.isEmpty()) {
        long threadId = Threads.getOrCreateThreadId(mContext, recipients);
        values.put(Mms.THREAD_ID, threadId);
    }
    SqliteWrapper.update(mContext, mContentResolver, uri, values, null, null);
}",1,"/**
 * Update headers of a SendReq.
 *
 * @param uri The PDU which need to be updated.
 * @param pdu New headers.
 * @throws MmsException Bad URI or updating failed.
 */
","/**
 * Update headers of a SendReq.
 *
 * @param uri The PDU which need to be updated.
 * @param pdu New headers.
 * @throws MmsException Bad URI or updating failed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The changes in the late version include the addition of a synchronised block for handling updates and purges based on the PDU_CACHE_INSTANCE.isUpdating(uri) condition and also an extra condition statement checking whether the recipients are not empty before obtaining or creating the threadId. So the change type is 3, which is control dependency change.","Although there are changes in the method, these changes do not cause any compatibility issues. The extra conditions and synchronisation are just more careful handling of the data, but the return values and exception handling haven't changed. The condition added recipients.isEmpty() is to ensure that threadId isnt updated unless there are recipients, which doesn't impact the final behavior of the API. Therefore, a compatibility issue(CI) does not exist, and the CI type is 0."
375,"<android.widget.ShareActionProvider.ShareAcitivityChooserModelPolicy: boolean onChooseActivity(ActivityChooserModel,Intent)>",15,16,"<android.widget.ShareActionProvider.ShareAcitivityChooserModelPolicy: boolean onChooseActivity(ActivityChooserModel,Intent)>","<android.widget.ShareActionProvider.ShareAcitivityChooserModelPolicy: boolean onChooseActivity(ActivityChooserModel,Intent)>",0,"{
    if (mOnShareTargetSelectedListener != null) {
        return mOnShareTargetSelectedListener.onShareTargetSelected(ShareActionProvider.this, intent);
    }
    return false;
}","{
    if (mOnShareTargetSelectedListener != null) {
        mOnShareTargetSelectedListener.onShareTargetSelected(ShareActionProvider.this, intent);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,0,"The early version returns the result of 'mOnShareTargetSelectedListener.onShareTargetSelected(...)' but the late version doesn't, therefore, the type of change is 'Return statement changed' (1).","Although there is a difference in terms of 'return statement' between early and late implementation, this doesn't cause compatibility issue since regardless of the onShareTargetSelected function returns, the function 'onChooseActivity' will always return false ultimately in both implementations. Thus, there is no compatibility issue (0)."
376,"<android.view.KeyCharacterMap: int getDeadChar(int,int)>",15,16,"<android.view.KeyCharacterMap: int getDeadChar(int,int)>","<android.view.KeyCharacterMap: int getDeadChar(int,int)>",0,"{
    return DEAD.get((accent << 16) | c);
}","{
    int combining = sAccentToCombining.get(accent);
    if (combining == 0) {
        return 0;
    }
    final int combination = (combining << 16) | c;
    int combined;
    synchronized (sDeadKeyCache) {
        combined = sDeadKeyCache.get(combination, -1);
        if (combined == -1) {
            sDeadKeyBuilder.setLength(0);
            sDeadKeyBuilder.append((char) c);
            sDeadKeyBuilder.append((char) combining);
            String result = Normalizer.normalize(sDeadKeyBuilder, Normalizer.Form.NFC);
            combined = result.length() == 1 ? result.charAt(0) : 0;
            sDeadKeyCache.put(combination, combined);
        }
    }
    return combined;
}",1,"/**
 * Get the character that is produced by putting accent on the character c.
 * For example, getDeadChar('`', 'e') returns &egrave;.
 *
 * @param accent The accent character.  eg. '`'
 * @param c The basic character.
 * @return The combined character, or 0 if the characters cannot be combined.
 */
","/**
 * Get the character that is produced by putting accent on the character c.
 * For example, getDeadChar('`', 'e') returns &egrave;.
 *
 * @param accent The accent character.  eg. '`'
 * @param c The basic character.
 * @return The combined character, or 0 if the characters cannot be combined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statement has changed its structure and implementation and the control statements and other statements have also changed, so the code change type is 1,3,4.","Given the changes in both return statement and control statements, the API might potentially return a different value in the late version, so the CI type is 1."
377,<android.os.Looper: void loop()>,15,16,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    while (true) {
        // might block
        Message msg = queue.next();
        if (msg != null) {
            if (msg.target == null) {
                // No target is a magic identifier for the quit message.
                return;
            }
            long wallStart = 0;
            long threadStart = 0;
            // This must be in a local variable, in case a UI event sets the logger
            Printer logging = me.mLogging;
            if (logging != null) {
                logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
                wallStart = SystemClock.currentTimeMicro();
                threadStart = SystemClock.currentThreadTimeMicro();
            }
            msg.target.dispatchMessage(msg);
            if (logging != null) {
                long wallTime = SystemClock.currentTimeMicro() - wallStart;
                long threadTime = SystemClock.currentThreadTimeMicro() - threadStart;
                logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
                if (logging instanceof Profiler) {
                    ((Profiler) logging).profile(msg, wallStart, wallTime, threadStart, threadTime);
                }
            }
            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
            }
            msg.recycle();
        }
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycle();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are changes made to if condition block 'if (msg != null)' to 'if (msg == null)' and loop condition block 'while (true)' to 'for (;;)', this is classed as category 3 change. And printout statements like 'msg.target + "" "" + msg.callback + "": "" + msg.what' and 'msg.target + "" "" + msg.callback' are modified which do not return any return or exception handling statements, and this is classified as an other statement change i.e., category 4.",The changes in the condition block might lead the code execution into different paths and this might end up returning different variables generating compatibility issue of type 1.
378,"<com.google.android.mms.util.PduCache: boolean put(Uri,PduCacheEntry)>",15,16,"<com.google.android.mms.util.PduCache: boolean put(Uri,PduCacheEntry)>","<com.google.android.mms.util.PduCache: boolean put(Uri,PduCacheEntry)>",0,"{
    int msgBoxId = entry.getMessageBox();
    HashSet<Uri> msgBox = mMessageBoxes.get(msgBoxId);
    if (msgBox == null) {
        msgBox = new HashSet<Uri>();
        mMessageBoxes.put(msgBoxId, msgBox);
    }
    long threadId = entry.getThreadId();
    HashSet<Uri> thread = mThreads.get(threadId);
    if (thread == null) {
        thread = new HashSet<Uri>();
        mThreads.put(threadId, thread);
    }
    Uri finalKey = normalizeKey(uri);
    boolean result = super.put(finalKey, entry);
    if (result) {
        msgBox.add(finalKey);
        thread.add(finalKey);
    }
    return result;
}","{
    int msgBoxId = entry.getMessageBox();
    HashSet<Uri> msgBox = mMessageBoxes.get(msgBoxId);
    if (msgBox == null) {
        msgBox = new HashSet<Uri>();
        mMessageBoxes.put(msgBoxId, msgBox);
    }
    long threadId = entry.getThreadId();
    HashSet<Uri> thread = mThreads.get(threadId);
    if (thread == null) {
        thread = new HashSet<Uri>();
        mThreads.put(threadId, thread);
    }
    Uri finalKey = normalizeKey(uri);
    boolean result = super.put(finalKey, entry);
    if (result) {
        msgBox.add(finalKey);
        thread.add(finalKey);
    }
    setUpdating(uri, false);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional statement 'setUpdating(uri, false);' is introduced in the late version indicating a code change type of 1,4.","The new operation in the method can possibly change the behaviour of the method, which can result in a different return value between the two versions. Hence, the CI type is 1."
381,<android.nfc.tech.Ndef: NdefMessage getNdefMessage()>,15,16,<android.nfc.tech.Ndef: NdefMessage getNdefMessage()>,<android.nfc.tech.Ndef: NdefMessage getNdefMessage()>,0,"{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null) {
                int errorCode = tagService.getLastError(serviceHandle);
                switch(errorCode) {
                    case ErrorCodes.ERROR_IO:
                        throw new IOException();
                    case ErrorCodes.ERROR_INVALID_PARAM:
                        throw new FormatException();
                    default:
                        // Should not happen
                        throw new IOException();
                }
            }
            return msg;
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return null;
    }
}","{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException(""Mock tags don't support this operation."");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null && !tagService.isPresent(serviceHandle)) {
                throw new TagLostException();
            }
            return msg;
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return null;
    }
}",1,"/**
 * Read the current {@link android.nfc.NdefMessage} on this tag.
 *
 * <p>This always reads the current NDEF Message stored on the tag.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * @return the NDEF Message, never null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message on the tag is malformed
 */
","/**
 * Read the current {@link android.nfc.NdefMessage} on this tag.
 *
 * <p>This always reads the current NDEF Message stored on the tag.
 *
 * <p>Note that this method may return null if the tag was in the
 * INITIALIZED state as defined by NFC Forum, as in that state the
 * tag is formatted to support NDEF but does not contain a message yet.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return the NDEF Message, can be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message on the tag is malformed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The implementation changes involving return statements, exception handling statements, and control dependency. Specifically, the error handling part (a switch-case statement) from the early version has been removed, and two new exception-throwing statements, along with a new if-statement as control dependency, have been added in the late version. Thus, the change type is 1,2,3,4.","Due to the added exceptions (IOException and TagLostException) and removed one (IOException, FormatException) in the late version, the API potentially throws different exceptions. The presence of the new control dependency could also make the API return different values. Therefore, the CI type is 1,2."
383,<android.app.ContextImpl: void startActivity(Intent)>,15,16,<android.app.ContextImpl: void startActivity(Intent)>,<android.app.ContextImpl: void startActivity(Intent)>,0,"{
    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(""Calling startActivity() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivity(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1);
}","{
    startActivity(intent, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",2,"The entire content of the method has been replaced, with both an exception statement and an API method call removed and replaced with an alternative API call. Therefore, the change type is both 1 and 5.","Originally, the API would throw an exception if certain conditions were met. After the update, there is no such check and the API behaviour in those circumstances (when the flag is not set) could now be different. Thus the CI type is 2 because of potential change in exception handling."
384,<android.app.Instrumentation: void sendTrackballEventSync(MotionEvent)>,15,16,<android.app.Instrumentation: void sendTrackballEventSync(MotionEvent)>,<android.app.Instrumentation: void sendTrackballEventSync(MotionEvent)>,0,"{
    validateNotAppThread();
    try {
        (IWindowManager.Stub.asInterface(ServiceManager.getService(""window""))).injectTrackballEvent(event, true);
    } catch (RemoteException e) {
    }
}","{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_TRACKBALL) == 0) {
        event.setSource(InputDevice.SOURCE_TRACKBALL);
    }
    InputManager.getInstance().injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
}",1,"/**
 * Dispatch a trackball event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the trackball action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
","/**
 * Dispatch a trackball event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the trackball action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","There is a change in the return statement from 'IWindowManager.Stub.asInterface(ServiceManager.getService(""window""))).injectTrackballEvent(event, true);' to 'InputManager.getInstance().injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);'. Plus there is a new check using if statement and dependent APIs have been changed (i.e., different dependent APIs are invoked in the two versions), so the code change type is 1,4,5.","The return of the function 'injectInputEvent' could be different from the old 'injectTrackballEvent' which would potentially return different results. Also, the new if statement introduces another potential exception handling situation since 'setSource' function could cause an exception. Therefore, the CI type is 1,2."
385,<android.webkit.WebSettings: boolean getBlockNetworkLoads()>,15,16,<android.webkit.WebSettings: boolean getBlockNetworkLoads()>,<android.webkit.WebSettings: boolean getBlockNetworkLoads()>,0,"{
    return mBlockNetworkLoads;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return true if the WebView will block all network loads. The default is
 * false.
 * @return True if the WebView blocks all network loads.
 */
","/**
 * Gets whether the WebView does not load any resources from the network.
 *
 * @return true if the WebView does not load any resources from the network
 * @see #setBlockNetworkLoads
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement ""return mBlockNetworkLoads"" was replaced by an exception handling statement ""throw new MustOverrideException()"", so the change type is 1,2.","The behavior of the late version has totally changed as it only throws an exception now and no return of the boolean values any more, leading to the potential different return values/types and different exception handling situations. Thus, the CI type is 1,2."
387,<android.animation.LayoutTransition: TimeInterpolator getInterpolator(int)>,15,16,<android.animation.LayoutTransition: TimeInterpolator getInterpolator(int)>,<android.animation.LayoutTransition: TimeInterpolator getInterpolator(int)>,0,"{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingInterpolator;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingInterpolator;
        case APPEARING:
            return mAppearingInterpolator;
        case DISAPPEARING:
            return mDisappearingInterpolator;
    }
    // shouldn't reach here
    return null;
}","{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingInterpolator;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingInterpolator;
        case CHANGING:
            return mChangingInterpolator;
        case APPEARING:
            return mAppearingInterpolator;
        case DISAPPEARING:
            return mDisappearingInterpolator;
    }
    // shouldn't reach here
    return null;
}",1,"/**
 * Gets the interpolator on one of the animation objects used by this transition. The
 * <code>transitionType</code> parameter determines the animation whose interpolator
 * is returned.
 *
 * @param transitionType one of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #APPEARING}, or {@link #DISAPPEARING}, which determines the animation whose
 * duration is being set.
 * @return TimeInterpolator The interpolator that the specified animation uses.
 * @see Animator#setInterpolator(TimeInterpolator)
 */
","/**
 * Gets the interpolator on one of the animation objects used by this transition. The
 * <code>transitionType</code> parameter determines the animation whose interpolator
 * is returned.
 *
 * @param transitionType One of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #CHANGING}, {@link #APPEARING}, or {@link #DISAPPEARING}, which determines
 * the animation whose interpolator is being returned.
 * @return TimeInterpolator The interpolator that the specified animation uses.
 * @see Animator#setInterpolator(TimeInterpolator)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow (switch statement) has changed, as the case CHANGING with return mChangingInterpolator has been added in the Late Implementation, hence, the classification is 1,3 (Return statement changed and Control dependency changed).","Because of the additional switch case in the late implementation, it means there is a potential to return a different value depending upon the transitionType input parameter not handled in the early implementation, therefore a compatibility issue type 1 could occur (potential to return a different value)."
389,<android.animation.ValueAnimator: boolean animationFrame(long)>,15,16,<android.animation.ValueAnimator: boolean animationFrame(long)>,<android.animation.ValueAnimator: boolean animationFrame(long)>,0,"{
    boolean done = false;
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekTime < 0) {
            mStartTime = currentTime;
        } else {
            mStartTime = currentTime - mSeekTime;
            // Now that we're playing, reset the seek time
            mSeekTime = -1;
        }
    }
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = mPlayingBackwards ? false : true;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}","{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = mPlayingBackwards ? false : true;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}",1,"/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code> has been exceeded and the animation should be ended.
 */
","/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code> has been exceeded and the animation should be ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The if condition checking if (mPlayingState == STOPPED) and everything inside, including another nested if condition, assignment operations, and control statement has been removed in the late version. Therefore, the change types are 1 (Return statement changed) and 3 (Control dependency changed).","The removed block of code additionally influences the result of the final return statement by altering 'done' variable under certain conditions. Because this block of code has been removed, this might cause the program to return a different value. Therefore, a Compatibility Issue exists in type 1 (Potential different return values or types)."
390,<android.widget.TextView: void setRawInputType(int)>,15,16,<android.widget.TextView: void setRawInputType(int)>,<android.widget.TextView: void setRawInputType(int)>,0,"{
    mInputType = type;
}","{
    // TYPE_NULL is the default value
    if (type == InputType.TYPE_NULL && mEditor == null)
        return;
    createEditorIfNeeded();
    mEditor.mInputType = type;
}",1,"/**
 * Directly change the content type integer of the text view, without
 * modifying any other state.
 * @see #setInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
","/**
 * Directly change the content type integer of the text view, without
 * modifying any other state.
 * @see #setInputType(int)
 * @see android.text.InputType
 * @attr ref android.R.styleable#TextView_inputType
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",1,"The condition check 'if (type == InputType.TYPE_NULL && mEditor == null)' and 'createEditorIfNeeded();' statements are added in the late version and the assignment statement mEditor.mInputType = type; replaces the old assignment statement mInputType = type; thus the code change type is 3,4.","As the raise of the condition check 'if (type == InputType.TYPE_NULL && mEditor == null)' and the change of assignment statement could potentially cause different behaviours, for instance in early version the API may not have a return while in the new version it has potential to do an early return. Thus, there is a potential CI due to return value change, resulting in the CI type of 1."
391,"<android.view.View: boolean requestFocus(int,Rect)>",15,16,"<android.view.View: boolean requestFocus(int,Rect)>","<android.view.View: boolean requestFocus(int,Rect)>",0,"{
    // need to be focusable
    if ((mViewFlags & FOCUSABLE_MASK) != FOCUSABLE || (mViewFlags & VISIBILITY_MASK) != VISIBLE) {
        return false;
    }
    // need to be focusable in touch mode if in touch mode
    if (isInTouchMode() && (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags & FOCUSABLE_IN_TOUCH_MODE))) {
        return false;
    }
    // need to not have any parents blocking us
    if (hasAncestorThatBlocksDescendantFocus()) {
        return false;
    }
    handleFocusGainInternal(direction, previouslyFocusedRect);
    return true;
}","{
    return requestFocusNoSearch(direction, previouslyFocusedRect);
}",1,"/**
 * Call this to try to give focus to a specific view or to one of its descendants
 * and give it hints about the direction and a specific rectangle that the focus
 * is coming from.  The rectangle can help give larger views a finer grained hint
 * about where focus is coming from, and therefore, where to show selection, or
 * forward focus change internally.
 *
 * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns
 * false), or if it is focusable and it is not focusable in touch mode
 * ({@link #isFocusableInTouchMode}) while the device is in touch mode.
 *
 * A View will not take focus if it is not visible.
 *
 * A View will not take focus if one of its parents has
 * {@link android.view.ViewGroup#getDescendantFocusability()} equal to
 * {@link ViewGroup#FOCUS_BLOCK_DESCENDANTS}.
 *
 * See also {@link #focusSearch(int)}, which is what you call to say that you
 * have focus, and you want your parent to look for the next one.
 *
 * You may wish to override this method if your custom {@link View} has an internal
 * {@link View} that it wishes to forward the request to.
 *
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
 * @param previouslyFocusedRect The rectangle (in this View's coordinate system)
 * to give a finer grained hint about where focus is coming from.  May be null
 * if there is no hint.
 * @return Whether this view or one of its descendants actually took focus.
 */
","/**
 * Call this to try to give focus to a specific view or to one of its descendants
 * and give it hints about the direction and a specific rectangle that the focus
 * is coming from.  The rectangle can help give larger views a finer grained hint
 * about where focus is coming from, and therefore, where to show selection, or
 * forward focus change internally.
 *
 * A view will not actually take focus if it is not focusable ({@link #isFocusable} returns
 * false), or if it is focusable and it is not focusable in touch mode
 * ({@link #isFocusableInTouchMode}) while the device is in touch mode.
 *
 * A View will not take focus if it is not visible.
 *
 * A View will not take focus if one of its parents has
 * {@link android.view.ViewGroup#getDescendantFocusability()} equal to
 * {@link ViewGroup#FOCUS_BLOCK_DESCENDANTS}.
 *
 * See also {@link #focusSearch(int)}, which is what you call to say that you
 * have focus, and you want your parent to look for the next one.
 *
 * You may wish to override this method if your custom {@link View} has an internal
 * {@link View} that it wishes to forward the request to.
 *
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
 * @param previouslyFocusedRect The rectangle (in this View's coordinate system)
 * to give a finer grained hint about where focus is coming from.  May be null
 * if there is no hint.
 * @return Whether this view or one of its descendants actually took focus.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from a set of distinct boolean conditions and a final return true, to a single return with a method call requestFocusNoSearch. The dependent API has also changed, therefore the option is 1,5.","The change of the return statement will make the API potentially return a different value, so the CI type is 1."
396,<android.widget.TextView: Callback getCustomSelectionActionModeCallback()>,15,16,<android.widget.TextView: Callback getCustomSelectionActionModeCallback()>,<android.widget.TextView: Callback getCustomSelectionActionModeCallback()>,0,"{
    return mCustomSelectionActionModeCallback;
}","{
    return mEditor == null ? null : mEditor.mCustomSelectionActionModeCallback;
}",1,"/**
 * Retrieves the value set in {@link #setCustomSelectionActionModeCallback}. Default is null.
 *
 * @return The current custom selection callback.
 */
","/**
 * Retrieves the value set in {@link #setCustomSelectionActionModeCallback}. Default is null.
 *
 * @return The current custom selection callback.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The addition of the ternary condition leads to a control dependency change (type 3). This modification also changes the return statement (type 1).,"The return value of the method could potentially be different between the two versions due to the ternary condition added in the later version. This indicates a compatibility issue of type 1, as it may lead to different return values."
398,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>",15,16,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>","<android.content.res.Configuration: void writeToParcel(Parcel,int)>",0,"{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(textLayoutDirection);
    dest.writeInt(seq);
}","{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(layoutDirection);
    dest.writeInt(seq);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is an attribute name change, 'textLayoutDirection' variable has been renamed to 'layoutDirection', which fits in the category of 'Other statement changed' (category 4).","Due to the attribute name change, if developers that used 'textLayoutDirection' in the previous version do not adapt their code for the new version, it could potentially return a different value. Thus, this can be considered as a 'Compatibility Issue caused by potential different return values or types' (category 1)."
401,"<android.webkit.CallbackProxy: boolean onJsBeforeUnload(String,String)>",15,16,"<android.webkit.CallbackProxy: boolean onJsBeforeUnload(String,String)>","<android.webkit.CallbackProxy: boolean onJsBeforeUnload(String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return true;
    }
    JsResult result = new JsResult(this, true);
    Message confirm = obtainMessage(JS_UNLOAD, result);
    confirm.getData().putString(""message"", message);
    confirm.getData().putString(""url"", url);
    synchronized (this) {
        sendMessage(confirm);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for jsUnload"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    return result.getResult();
}","{
    // been set.
    if (mWebChromeClient == null) {
        return true;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message confirm = obtainMessage(JS_UNLOAD, result);
    confirm.getData().putString(""message"", message);
    confirm.getData().putString(""url"", url);
    sendMessageToUiThreadSync(confirm);
    return result.mJsResult.getResult();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"In the late implementation, 'JsResult this, true' and 'wait()' have been replaced by 'JsResultReceiver()' and 'sendMessageToUiThreadSync(confirm)', and 'result.getResult()' replaced by 'result.mJsResult.getResult()'. This represents different return types and other statement changes so the changes are of type 1,4,5.","The changes in the return type could possibly cause the API to return different data, hence it has a potential compatibility issue of type 1."
402,"<android.view.View: void setLayerType(int,Paint)>",15,16,"<android.view.View: void setLayerType(int,Paint)>","<android.view.View: void setLayerType(int,Paint)>",0,"{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    if (layerType == mLayerType) {
        if (layerType != LAYER_TYPE_NONE && paint != mLayerPaint) {
            mLayerPaint = paint == null ? new Paint() : paint;
            invalidateParentCaches();
            invalidate(true);
        }
        return;
    }
    // Destroy any previous software drawing cache if needed
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            destroyLayer();
        // fall through - non-accelerated views may use software layer mechanism instead
        case LAYER_TYPE_SOFTWARE:
            destroyDrawingCache();
            break;
        default:
            break;
    }
    mLayerType = layerType;
    final boolean layerDisabled = mLayerType == LAYER_TYPE_NONE;
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mLocalDirtyRect = layerDisabled ? null : new Rect();
    invalidateParentCaches();
    invalidate(true);
}","{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    if (layerType == mLayerType) {
        if (layerType != LAYER_TYPE_NONE && paint != mLayerPaint) {
            mLayerPaint = paint == null ? new Paint() : paint;
            invalidateParentCaches();
            invalidate(true);
        }
        return;
    }
    // Destroy any previous software drawing cache if needed
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            destroyLayer(false);
        // fall through - non-accelerated views may use software layer mechanism instead
        case LAYER_TYPE_SOFTWARE:
            destroyDrawingCache();
            break;
        default:
            break;
    }
    mLayerType = layerType;
    final boolean layerDisabled = mLayerType == LAYER_TYPE_NONE;
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mLocalDirtyRect = layerDisabled ? null : new Rect();
    invalidateParentCaches();
    invalidate(true);
}",1,"/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE disabled}, {@link #LAYER_TYPE_SOFTWARE software} or
 * {@link #LAYER_TYPE_HARDWARE hardware}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
 * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
 * equivalent to setting a hardware layer on this view and providing a paint with
 * the desired alpha value.<p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE disabled},
 * {@link #LAYER_TYPE_SOFTWARE software} and {@link #LAYER_TYPE_HARDWARE hardware}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The ype of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
","/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE disabled}, {@link #LAYER_TYPE_SOFTWARE software} or
 * {@link #LAYER_TYPE_HARDWARE hardware}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
 * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
 * equivalent to setting a hardware layer on this view and providing a paint with
 * the desired alpha value.<p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE disabled},
 * {@link #LAYER_TYPE_SOFTWARE software} and {@link #LAYER_TYPE_HARDWARE hardware}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The ype of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API 'destroyLayer()' has changed from no parameter to one parameter 'false', so the change type is 5.","Although dependent API has changed, this does not lead to compatibility issues since it does not alter the overall behavior of the program, no different return values or exceptions, so the CI type is 0."
403,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,15,16,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,<android.view.MenuInflater.InflatedOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,0,"{
    try {
        if (mMethod.getReturnType() == Boolean.TYPE) {
            return (Boolean) mMethod.invoke(mContext, item);
        } else {
            mMethod.invoke(mContext, item);
            return true;
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        if (mMethod.getReturnType() == Boolean.TYPE) {
            return (Boolean) mMethod.invoke(mRealOwner, item);
        } else {
            mMethod.invoke(mRealOwner, item);
            return true;
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method mMethod.invoke() has changed its reference variable from mContext to mRealOwner, so the code change types are 1 (as it potentially effects the return value of the method), and 5 (dependent API change).","Due to the change in referred object for mMethod.invoke() method which is used in return statements, the API can potentially return different values. Thus, the CI type is 1."
405,<android.text.TextUtils: String htmlEncode(String)>,15,16,<android.text.TextUtils: String htmlEncode(String)>,<android.text.TextUtils: String htmlEncode(String)>,0,"{
    StringBuilder sb = new StringBuilder();
    char c;
    for (int i = 0; i < s.length(); i++) {
        c = s.charAt(i);
        switch(c) {
            case '<':
                // $NON-NLS-1$
                sb.append(""&lt;"");
                break;
            case '>':
                // $NON-NLS-1$
                sb.append(""&gt;"");
                break;
            case '&':
                // $NON-NLS-1$
                sb.append(""&amp;"");
                break;
            case '\'':
                // $NON-NLS-1$
                sb.append(""&apos;"");
                break;
            case '""':
                // $NON-NLS-1$
                sb.append(""&quot;"");
                break;
            default:
                sb.append(c);
        }
    }
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    char c;
    for (int i = 0; i < s.length(); i++) {
        c = s.charAt(i);
        switch(c) {
            case '<':
                // $NON-NLS-1$
                sb.append(""&lt;"");
                break;
            case '>':
                // $NON-NLS-1$
                sb.append(""&gt;"");
                break;
            case '&':
                // $NON-NLS-1$
                sb.append(""&amp;"");
                break;
            case '\'':
                // http://www.w3.org/TR/xhtml1
                // The named character reference &apos; (the apostrophe, U+0027) was introduced in
                // XML 1.0 but does not appear in HTML. Authors should therefore use &#39; instead
                // of &apos; to work as expected in HTML 4 user agents.
                // $NON-NLS-1$
                sb.append(""&#39;"");
                break;
            case '""':
                // $NON-NLS-1$
                sb.append(""&quot;"");
                break;
            default:
                sb.append(c);
        }
    }
    return sb.toString();
}",1,"/**
 * Html-encode the string.
 * @param s the string to be encoded
 * @return the encoded string
 */
","/**
 * Html-encode the string.
 * @param s the string to be encoded
 * @return the encoded string
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The change is within the switch block, specifically in the case handling for the apostrophe character. In the early version, it appends ""&apos;"", while in the late version, it appends ""&#39;"", so the change type is 4.","This can cause a compatibility issue if the calling code is expecting the early version's output. Because the output string might be different when input contains an apostrophe character, the CI type is 1."
407,<android.inputmethodservice.KeyboardView: boolean onHoverEvent(MotionEvent)>,15,16,<android.inputmethodservice.KeyboardView: boolean onHoverEvent(MotionEvent)>,<android.inputmethodservice.KeyboardView: boolean onHoverEvent(MotionEvent)>,0,"{
    if (mAccessibilityManager.isTouchExplorationEnabled() && event.getPointerCount() == 1) {
        final int action = event.getAction();
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
            case MotionEvent.ACTION_HOVER_MOVE:
                final int touchX = (int) event.getX() - mPaddingLeft;
                int touchY = (int) event.getY() - mPaddingTop;
                if (touchY >= -mVerticalCorrection) {
                    touchY += mVerticalCorrection;
                }
                final int keyIndex = getKeyIndices(touchX, touchY, null);
                showPreview(keyIndex);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                showPreview(NOT_A_KEY);
                break;
        }
    }
    return true;
}","{
    if (mAccessibilityManager.isTouchExplorationEnabled() && event.getPointerCount() == 1) {
        final int action = event.getAction();
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                {
                    event.setAction(MotionEvent.ACTION_DOWN);
                }
                break;
            case MotionEvent.ACTION_HOVER_MOVE:
                {
                    event.setAction(MotionEvent.ACTION_MOVE);
                }
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                {
                    event.setAction(MotionEvent.ACTION_UP);
                }
                break;
        }
        return onTouchEvent(event);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The statements in the 'case' blocks of the 'switch' control statement have changed, so it belongs to change type 3. Additionally, a specific onTouchEvent(event) method call has been introduced which introduces the new behavior and can be considered as a type 4 change.","Despite the changes in method invocation and control flow, the return values are always true for both versions, and no new exceptions are introduced. Therefore, this change does not cause Compatibility Issue."
409,<android.widget.ProgressBar: void startAnimation()>,15,16,<android.widget.ProgressBar: void startAnimation()>,<android.widget.ProgressBar: void startAnimation()>,0,"{
    if (getVisibility() != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mAnimation = null;
    } else {
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        mTransformation = new Transformation();
        mAnimation = new AlphaAnimation(0.0f, 1.0f);
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
    }
    postInvalidate();
}","{
    if (getVisibility() != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mHasAnimation = false;
    } else {
        mHasAnimation = true;
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        if (mTransformation == null) {
            mTransformation = new Transformation();
        } else {
            mTransformation.clear();
        }
        if (mAnimation == null) {
            mAnimation = new AlphaAnimation(0.0f, 1.0f);
        } else {
            mAnimation.reset();
        }
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
    }
    postInvalidate();
}",1,"/**
 * <p>Start the indeterminate progress animation.</p>
 */
","/**
 * <p>Start the indeterminate progress animation.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new condition `mHasAnimation = false;` introduced and further conditions check is added such as `if (mTransformation == null)` and `if (mAnimation == null)`, so classify it as type 3,4 change.","Introducing new conditions, could potentially lead to a different execution flow which may result in changing return values, thus CI type is 1."
411,<android.webkit.WebView: WebSettings getSettings()>,15,16,<android.webkit.WebView: WebSettings getSettings()>,<android.webkit.WebView: WebSettings getSettings()>,0,"{
    checkThread();
    return (mWebViewCore != null) ? mWebViewCore.getSettings() : null;
}","{
    checkThread();
    return mProvider.getSettings();
}",1,"/**
 * Return the WebSettings object used to control the settings for this
 * WebView.
 * @return A WebSettings object that can be used to control this WebView's
 * settings.
 */
","/**
 * Gets the WebSettings object used to control the settings for this
 * WebView.
 *
 * @return a WebSettings object that can be used to control this WebView's
 * settings
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The returned value of the function is changed from (mWebViewCore != null) ? mWebViewCore.getSettings() : null to mProvider.getSettings(). It includes both a change in the dependent API (from mWebViewCore.getSettings() to mProvider.getSettings()) and the returned value, the code change type is 1,5.","The change in dependent API and in the returned value potentially makes the API return a different value; thus, causes Compatibility Issue typed as 1."
412,<android.hardware.Camera.Parameters: void getFocusDistances(float[])>,15,16,<android.hardware.Camera.Parameters: void getFocusDistances(float[])>,<android.hardware.Camera.Parameters: void getFocusDistances(float[])>,0,"{
    if (output == null || output.length != 3) {
        throw new IllegalArgumentException(""output must be an float array with three elements."");
    }
    splitFloat(get(KEY_FOCUS_DISTANCES), output);
}","{
    if (output == null || output.length != 3) {
        throw new IllegalArgumentException(""output must be a float array with three elements."");
    }
    splitFloat(get(KEY_FOCUS_DISTANCES), output);
}",1,"/**
 * <p>Gets the distances from the camera to where an object appears to be
 * in focus. The object is sharpest at the optimal focus distance. The
 * depth of field is the far focus distance minus near focus distance.</p>
 *
 * <p>Focus distances may change after calling {@link
 * #autoFocus(AutoFocusCallback)}, {@link #cancelAutoFocus}, or {@link
 * #startPreview()}. Applications can call {@link #getParameters()}
 * and this method anytime to get the latest focus distances. If the
 * focus mode is FOCUS_MODE_CONTINUOUS_VIDEO, focus distances may change
 * from time to time.</p>
 *
 * <p>This method is intended to estimate the distance between the camera
 * and the subject. After autofocus, the subject distance may be within
 * near and far focus distance. However, the precision depends on the
 * camera hardware, autofocus algorithm, the focus area, and the scene.
 * The error can be large and it should be only used as a reference.</p>
 *
 * <p>Far focus distance >= optimal focus distance >= near focus distance.
 * If the focus distance is infinity, the value will be
 * {@code Float.POSITIVE_INFINITY}.</p>
 *
 * @param output focus distances in meters. output must be a float
 * array with three elements. Near focus distance, optimal focus
 * distance, and far focus distance will be filled in the array.
 * @see #FOCUS_DISTANCE_NEAR_INDEX
 * @see #FOCUS_DISTANCE_OPTIMAL_INDEX
 * @see #FOCUS_DISTANCE_FAR_INDEX
 */
","/**
 * <p>Gets the distances from the camera to where an object appears to be
 * in focus. The object is sharpest at the optimal focus distance. The
 * depth of field is the far focus distance minus near focus distance.</p>
 *
 * <p>Focus distances may change after calling {@link
 * #autoFocus(AutoFocusCallback)}, {@link #cancelAutoFocus}, or {@link
 * #startPreview()}. Applications can call {@link #getParameters()}
 * and this method anytime to get the latest focus distances. If the
 * focus mode is FOCUS_MODE_CONTINUOUS_VIDEO, focus distances may change
 * from time to time.</p>
 *
 * <p>This method is intended to estimate the distance between the camera
 * and the subject. After autofocus, the subject distance may be within
 * near and far focus distance. However, the precision depends on the
 * camera hardware, autofocus algorithm, the focus area, and the scene.
 * The error can be large and it should be only used as a reference.</p>
 *
 * <p>Far focus distance >= optimal focus distance >= near focus distance.
 * If the focus distance is infinity, the value will be
 * {@code Float.POSITIVE_INFINITY}.</p>
 *
 * @param output focus distances in meters. output must be a float
 * array with three elements. Near focus distance, optimal focus
 * distance, and far focus distance will be filled in the array.
 * @see #FOCUS_DISTANCE_NEAR_INDEX
 * @see #FOCUS_DISTANCE_OPTIMAL_INDEX
 * @see #FOCUS_DISTANCE_FAR_INDEX
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in code is only a textual change in the exception message from ""an float array"" to ""a float array"". This doesn't affect the functionality or the API behavior, hence the change classification is 4 (Other statement changed).","Since there is no functional change in the API, it falls under case 0, indicating that there is no Compatibility Issue (CI). The API returns the same variable, and throws the same exception(s), even after the change in phrase of the exception message."
413,<android.database.sqlite.SQLiteProgram: void clearBindings()>,15,16,<android.database.sqlite.SQLiteProgram: void clearBindings()>,<android.database.sqlite.SQLiteProgram: void clearBindings()>,0,"{
    mBindArgs = null;
    if (this.nStatement == 0) {
        return;
    }
    mDatabase.verifyDbIsOpen();
    acquireReference();
    try {
        native_clear_bindings();
    } finally {
        releaseReference();
    }
}","{
    if (mBindArgs != null) {
        Arrays.fill(mBindArgs, null);
    }
}",1,"/**
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
","/**
 * Clears all existing bindings. Unset bindings are treated as NULL.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The entire return structure and condition statement and also the other statements has changed, therefore the code change type is 1,3,4.","As the whole implementation and the return structure has changed, it may result in different return values and lead to potentially different behaviors. So, the CI type is 1."
417,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",15,16,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>","<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",0,"{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        Log.v(TAG, String.format(""comment size %d; signature start %d"", commentSize, signatureStart));
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException(""signedData is null"");
        }
        Collection encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException(""encCerts is empty"");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
        } else {
            throw new SignatureException(""signature contains no certificates"");
        }
        List sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException(""no signer infos!"");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery *only* handles SHA1withRSA
        // signatures.  SignApk.java always uses SHA1withRSA, no
        // matter what the cert says to use.  Ignore
        // cert.getSigAlgName(), and instead use whatever
        // algorithm is used by the signature (which should be
        // SHA1withRSA).
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + ""with"" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}","{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException(""signedData is null"");
        }
        Collection encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException(""encCerts is empty"");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
        } else {
            throw new SignatureException(""signature contains no certificates"");
        }
        List sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException(""no signer infos!"");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery *only* handles SHA1withRSA
        // signatures.  SignApk.java always uses SHA1withRSA, no
        // matter what the cert says to use.  Ignore
        // cert.getSigAlgName(), and instead use whatever
        // algorithm is used by the signature (which should be
        // SHA1withRSA).
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + ""with"" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}",1,"/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
","/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
420,"<android.webkit.GeolocationPermissions: void getAllowed(String,ValueCallback<Boolean>)>",15,16,"<android.webkit.GeolocationPermissions: void getAllowed(String,ValueCallback<Boolean>)>","<android.webkit.GeolocationPermissions: void getAllowed(String,ValueCallback<Boolean>)>",0,"{
    if (callback == null) {
        return;
    }
    if (origin == null) {
        callback.onReceiveValue(null);
        return;
    }
    if (WebViewCore.THREAD_NAME.equals(Thread.currentThread().getName())) {
        boolean allowed = nativeGetAllowed(origin);
        callback.onReceiveValue(new Boolean(allowed));
    } else {
        Map values = new HashMap<String, Object>();
        values.put(ORIGIN, origin);
        values.put(CALLBACK, callback);
        postMessage(Message.obtain(null, GET_ALLOWED, values));
    }
}","{
// Must be a no-op for backward compatibility: see the hidden constructor for reason.
}",1,"/**
 * Gets the permission state for the specified origin.
 *
 * Callback is a ValueCallback object whose onReceiveValue method will be
 * called asynchronously with the permission state for the origin.
 */
","/**
 * Gets the Geolocation permission state for the specified origin.
 *
 * @param origin the origin for which Geolocation permission is requested
 * @param callback a {@link ValueCallback} to receive the result of this
 * request. This object's
 * {@link ValueCallback#onReceiveValue(T) onReceiveValue()}
 * method will be invoked asynchronously with a boolean
 * indicating whether or not the origin can use the
 * Geolocation API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4","1,2","The late version doesn't have any implementation as the early version, so the code change type is 1,4.","The late version doesn't return any values and doesn't throw any exceptions as the early version. Therefore, the CI type is 1,2."
421,"<android.webkit.CallbackProxy: void onReachedMaxAppCacheSize(long,long,QuotaUpdater)>",15,16,"<android.webkit.CallbackProxy: void onReachedMaxAppCacheSize(long,long,QuotaUpdater)>","<android.webkit.CallbackProxy: void onReachedMaxAppCacheSize(long,long,QuotaUpdater)>",0,"{
    if (mWebChromeClient == null) {
        quotaUpdater.updateQuota(0);
        return;
    }
    Message msg = obtainMessage(REACHED_APPCACHE_MAXSIZE);
    HashMap<String, Object> map = new HashMap();
    map.put(""spaceNeeded"", spaceNeeded);
    map.put(""totalUsedQuota"", totalUsedQuota);
    map.put(""quotaUpdater"", quotaUpdater);
    msg.obj = map;
    sendMessage(msg);
}","{
    if (mWebChromeClient == null) {
        // Native-side logic prevents the quota being updated to a smaller
        // value.
        quotaUpdater.updateQuota(quota);
        return;
    }
    Message msg = obtainMessage(REACHED_APPCACHE_MAXSIZE);
    HashMap<String, Object> map = new HashMap();
    map.put(""requiredStorage"", requiredStorage);
    map.put(""quota"", quota);
    map.put(""quotaUpdater"", quotaUpdater);
    msg.obj = map;
    sendMessage(msg);
}",1,"/**
 * Called by WebViewCore to inform the Java side that the appcache has
 * exceeded its max size.
 * @param spaceNeeded is the amount of disk space that would be needed
 * in order for the last appcache operation to succeed.
 * @param totalUsedQuota is the sum of all origins' quota.
 * @param quotaUpdater An instance of a class encapsulating a callback
 * to WebViewCore to run when the decision to allow or deny a bigger
 * app cache size has been made.
 */
","/**
 * Called by WebViewCore to inform the Java side that the appcache has
 * exceeded its max size.
 * @param requiredStorage is the amount of storage, in bytes, that would be
 * needed in order for the last appcache operation to succeed.
 * @param quota is the current quota (for all origins).
 * @param quotaUpdater An instance of a class encapsulating a callback
 * to WebViewCore to run when the decision to allow or deny a bigger
 * app cache size has been made.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the 'if' block, the first parameter of 'updateQuota' method changes from 0 to quota. Besides, inside the 'map', the key in 'put' method changes from ""spaceNeeded"" and ""totalUsedQuota"" parameters to ""requiredStorage"" and ""quota"", so the code change type is 1,4.","The values which passed to the 'updateQuota' method and being put into the 'map' have changed. This would make the method possible to return different values, thus the CI type is 1."
422,<android.webkit.WebSettings: boolean getAllowContentAccess()>,15,16,<android.webkit.WebSettings: boolean getAllowContentAccess()>,<android.webkit.WebSettings: boolean getAllowContentAccess()>,0,"{
    return mAllowContentAccess;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if this WebView supports content url access.
 */
","/**
 * Gets whether this WebView supports content URL access.
 *
 * @see #setAllowContentAccess
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been replaced by a throw statement in the implementation, so the code change type is 1,2.","As the late version implementation of the API throws an exception where it used to return a value previously, this change of behavior can potentially lead to different return values or cause an unexpected exception to be thrown. Thus, the CI type is 1,2."
423,"<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory,DatabaseErrorHandler)>",15,16,"<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory,DatabaseErrorHandler)>","<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory,DatabaseErrorHandler)>",0,"{
    File f = validateFilePath(name, true);
    SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(f.getPath(), factory, errorHandler);
    setFilePermissionsFromMode(f.getPath(), mode, 0);
    return db;
}","{
    File f = validateFilePath(name, true);
    int flags = SQLiteDatabase.CREATE_IF_NECESSARY;
    if ((mode & MODE_ENABLE_WRITE_AHEAD_LOGGING) != 0) {
        flags |= SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING;
    }
    SQLiteDatabase db = SQLiteDatabase.openDatabase(f.getPath(), factory, flags, errorHandler);
    setFilePermissionsFromMode(f.getPath(), mode, 0);
    return db;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method called to open database is changed from SQLiteDatabase.openOrCreateDatabase() to SQLiteDatabase.openDatabase(). Additionally, new flags are added for opening the database, changing the control flow. Therefore, the change type is 1,3,4,5.","The behavior of opening the database may differ due to the change in method and flags, leading to different return values. Hence, the CI type is 1."
425,<android.webkit.WebSettings: String getFantasyFontFamily()>,15,16,<android.webkit.WebSettings: String getFantasyFontFamily()>,<android.webkit.WebSettings: String getFantasyFontFamily()>,0,"{
    return mFantasyFontFamily;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the fantasy font family name. The default is ""fantasy"".
 * @return The fantasy font family name as a string.
 */
","/**
 * Gets the fantasy font family name.
 *
 * @return the fantasy font family name as a string
 * @see #setFantasyFontFamily
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The earlier version return statement 'mFantasyFontFamily' was replaced with an exception being thrown in the late version, so the code changes include both the return statement changed(1) and exception handling statement changed(2).","In the early version, this method is expected to return a value. But in the late version, an exception is thrown, which changes the behavior of the method. This could cause Compatibility Issues as the return values or types have changed(1) and also the exception handling mechanism differs(2)."
428,<android.app.ActivityThread.H: void handleMessage(Message)>,15,16,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + msg.what);
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
            }
            break;
        case PAUSE_ACTIVITY:
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            break;
        case PAUSE_ACTIVITY_FINISHING:
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            break;
        case STOP_ACTIVITY_SHOW:
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            break;
        case STOP_ACTIVITY_HIDE:
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            break;
        case SHOW_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, true);
            break;
        case HIDE_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, false);
            break;
        case RESUME_ACTIVITY:
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0);
            break;
        case SEND_RESULT:
            handleSendResult((ResultData) msg.obj);
            break;
        case DESTROY_ACTIVITY:
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            break;
        case BIND_APPLICATION:
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            handleNewIntent((NewIntentData) msg.obj);
            break;
        case RECEIVER:
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            break;
        case CREATE_SERVICE:
            handleCreateService((CreateServiceData) msg.obj);
            break;
        case BIND_SERVICE:
            handleBindService((BindServiceData) msg.obj);
            break;
        case UNBIND_SERVICE:
            handleUnbindService((BindServiceData) msg.obj);
            break;
        case SERVICE_ARGS:
            handleServiceArgs((ServiceArgsData) msg.obj);
            break;
        case STOP_SERVICE:
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            break;
        case REQUEST_THUMBNAIL:
            handleRequestThumbnail((IBinder) msg.obj);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj, null);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            handleLowMemory();
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            handleActivityConfigurationChanged((IBinder) msg.obj);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case DESTROY_BACKUP_AGENT:
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            completeRemoveProvider((IContentProvider) msg.obj);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            break;
        case SET_CORE_SETTINGS:
            handleSetCoreSettings((Bundle) msg.obj);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            handleTrimMemory(msg.arg1);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + msg.what);
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
429,<android.content.CursorLoader: Cursor loadInBackground()>,15,16,<android.content.CursorLoader: Cursor loadInBackground()>,<android.content.CursorLoader: Cursor loadInBackground()>,0,"{
    Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder);
    if (cursor != null) {
        // Ensure the cursor window is filled
        cursor.getCount();
        registerContentObserver(cursor, mObserver);
    }
    return cursor;
}","{
    synchronized (this) {
        if (isLoadInBackgroundCanceled()) {
            throw new OperationCanceledException();
        }
        mCancellationSignal = new CancellationSignal();
    }
    try {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder, mCancellationSignal);
        if (cursor != null) {
            // Ensure the cursor window is filled
            cursor.getCount();
            registerContentObserver(cursor, mObserver);
        }
        return cursor;
    } finally {
        synchronized (this) {
            mCancellationSignal = null;
        }
    }
}",1,"/* Runs on a worker thread */
","/* Runs on a worker thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3","1,2","There is a new control flow block 'if (isLoadInBackgroundCanceled()) throw new OperationCanceledException();' introduced. Also, there is a new variable used in the return statement 'mCancellationSignal', and a 'try'-'finally' block is used to handle exceptions, so the code change type is 1,2,3.","The newly inserted control flow block 'if (isLoadInBackgroundCanceled()) throw new OperationCanceledException();' allows for a new exception 'OperationCanceledException' to be potentially thrown, and the insertion of 'mCancellationSignal' in the return statement can potentially alter the returned cursor value. Therefore, the CI type is 1,2."
430,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,15,16,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    if (onCheckIsTextEditor() && isEnabled()) {
        if (mInputMethodState == null) {
            mInputMethodState = new InputMethodState();
        }
        outAttrs.inputType = mInputType;
        if (mInputContentType != null) {
            outAttrs.imeOptions = mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mInputContentType.imeActionLabel;
            outAttrs.actionId = mInputContentType.imeActionId;
            outAttrs.extras = mInputContentType.extras;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(mInputType);
            return ic;
        }
    }
    return null;
}","{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            return ic;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"Several things have been changed in the API implementation. First of all, creating the InputMethodState instance is now done by calling mEditor.createInputMethodStateIfNeeded() rather than directly on mInputMethodState. Needs values for the variables outAttrs inputType and outAttrs.imeOptions are now obtained by calling methods instead of retrieving object fields directly in the code (getInputType() replaces mInputType, mEditor.mInputContentType replaces mInputContentType etc.), and finally, the arguments in some functions changed (getInputType() replaces mInputType). Therefore, the change type is 3,4, and 5.","The change might lead the API to return a different variable. The API might behave differently because of changed control flow dependencies, changed other statements, and changed dependent APIs. So, the CI catogory is 1."
431,<android.view.View: void invalidate(boolean)>,15,16,<android.view.View: void invalidate(boolean)>,<android.view.View: void invalidate(boolean)>,0,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) || (mPrivateFlags & INVALIDATED) != INVALIDATED || isOpaque() != mLastIsOpaque) {
        mLastIsOpaque = isOpaque();
        mPrivateFlags &= ~DRAWN;
        mPrivateFlags |= DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= INVALIDATED;
            mPrivateFlags &= ~DRAWING_CACHE_VALID;
        }
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final Rect r = ai.mTmpInvalRect;
            r.set(0, 0, mRight - mLeft, mBottom - mTop);
            // Don't call invalidate -- we don't want to internally scroll
            // our own bounds
            p.invalidateChild(this, r);
        }
    }
}","{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) || (mPrivateFlags & INVALIDATED) != INVALIDATED || isOpaque() != mLastIsOpaque) {
        mLastIsOpaque = isOpaque();
        mPrivateFlags &= ~DRAWN;
        mPrivateFlags |= DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= INVALIDATED;
            mPrivateFlags &= ~DRAWING_CACHE_VALID;
        }
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final Rect r = ai.mTmpInvalRect;
            r.set(0, 0, mRight - mLeft, mBottom - mTop);
            // Don't call invalidate -- we don't want to internally scroll
            // our own bounds
            p.invalidateChild(this, r);
        }
    }
}",1,"/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be called with
 * invalidateCache set to false to skip that invalidation step for cases that do not
 * need it (for example, a component that remains at the same dimensions with the same
 * content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be invalidated as
 * well. This is usually true for a full invalidate, but may be set to false if the
 * View's contents or dimensions have not changed.
 */
","/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be called with
 * invalidateCache set to false to skip that invalidation step for cases that do not
 * need it (for example, a component that remains at the same dimensions with the same
 * content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be invalidated as
 * well. This is usually true for a full invalidate, but may be set to false if the
 * View's contents or dimensions have not changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the newer version, the entire block of code related to ViewDebug has been removed. This is classified as 'other statement changed' because the change is not related to return statements, exception handling statements, or control dependencies.","The removed code block was meant for debug tracing and did not manipulate return values or cause the method to throw any exceptions, as such it doesn't introduce any potential compatibility issues."
433,<android.webkit.WebView: boolean canGoForward()>,15,16,<android.webkit.WebView: boolean canGoForward()>,<android.webkit.WebView: boolean canGoForward()>,0,"{
    checkThread();
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() < l.getSize() - 1;
        }
    }
}","{
    checkThread();
    return mProvider.canGoForward();
}",1,"/**
 * Return true if this WebView has a forward history item.
 * @return True iff this Webview has a forward history item.
 */
","/**
 * Gets whether this WebView has a forward history item.
 *
 * @return true iff this Webview has a forward history item
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed. In the early version, it returns the condition l.getCurrentIndex() < l.getSize() - 1 or false based on if clearPending. In the late version, it returns the result of mProvider.canGoForward(). Also, the dependent API mCallbackProxy.getBackForwardList() in the early version is replaced by the API mProvider.canGoForward() in the late version. Therefore, it belongs to code change 1,5.","Since the return statement is changed, the function could potentially return a different value or boolean result. Therefore, the CI type is 1."
434,<android.webkit.WebSettings: void setPluginState(PluginState)>,15,16,<android.webkit.WebSettings: void setPluginState(PluginState)>,<android.webkit.WebSettings: void setPluginState(PluginState)>,0,"{
    if (mPluginState != state) {
        mPluginState = state;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to enable, disable, or have plugins on demand. On
 * demand mode means that if a plugin exists that can handle the embedded
 * content, a placeholder icon will be shown instead of the plugin. When
 * the placeholder is clicked, the plugin will be enabled.
 * @param state One of the PluginState values.
 */
","/**
 * Tells the WebView to enable, disable, or have plugins on demand. On
 * demand mode means that if a plugin exists that can handle the embedded
 * content, a placeholder icon will be shown instead of the plugin. When
 * the placeholder is clicked, the plugin will be enabled.
 *
 * @param state a PluginState value
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The early implementation had certain logic to control the plugin state, but the late version throws an exception. Hence, the change type is 2 (Exception handling statement changed). ","The late version will always throw a MustOverrideException, which is different from the early version, so the compatibility issue is caused by potential different exception handlings. The CI type is 2."
436,<android.view.accessibility.AccessibilityNodeInfo: int hashCode()>,15,16,<android.view.accessibility.AccessibilityNodeInfo: int hashCode()>,<android.view.accessibility.AccessibilityNodeInfo: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mAccessibilityViewId;
    result = prime * result + mAccessibilityWindowId;
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + getAccessibilityViewId(mSourceNodeId);
    result = prime * result + getVirtualDescendantId(mSourceNodeId);
    result = prime * result + mWindowId;
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in both early and late version are different. Moreover, the methods used to calculate result value in late version code are different from early version code (i.e., getAccessibilityViewId() and getVirtualDescendantId()) causing a dependent API change. So the code changes are of types 1 and 5.","Due to the changed calculation in return statement using different methods, the provided output might differ between the two versions, causing a compatibility issue of type 1."
437,<android.webkit.ZoomManager: float getReadingLevelScale()>,15,16,<android.webkit.ZoomManager: float getReadingLevelScale()>,<android.webkit.ZoomManager: float getReadingLevelScale()>,0,"{
    return mDisplayDensity * mDoubleTapZoomFactor;
}","{
    return computeScaleWithLimits(computeReadingLevelScale(getZoomOverviewScale()));
}",1,"/**
 * Returns the zoom scale used for reading text on a double-tap.
 */
","/**
 * Returns the zoom scale used for reading text on a double-tap.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from mDisplayDensity * mDoubleTapZoomFactor to computeScaleWithLimits(computeReadingLevelScale(getZoomOverviewScale())), so the code change type is 1.",The change of return statement will make the API potentially return a different value and so the CI type is 1.
438,<android.view.View: void postInvalidateDelayed(long)>,15,16,<android.view.View: void postInvalidateDelayed(long)>,<android.view.View: void postInvalidateDelayed(long)>,0,"{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        Message msg = Message.obtain();
        msg.what = AttachInfo.INVALIDATE_MSG;
        msg.obj = this;
        attachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds);
    }
}","{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);
    }
}",1,"/**
 * <p>Cause an invalidate to happen on a subsequent cycle through the event
 * loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 */
","/**
 * <p>Cause an invalidate to happen on a subsequent cycle through the event
 * loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 *
 * @see #invalidate()
 * @see #postInvalidate()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method in the late version has changed significantly. Instead of creating a new `Message` object and using the `sendMessageDelayed` method, the `dispatchInvalidateDelayed` method is called on the `mViewRootImpl` attribute of the `attachInfo` object. Thus, this change involves a different statement usage and a change in the dependent API call used, resulting in the categories 4,5 for the code changes.","Due to the change in the dependent API call, this could potentially cause the method to exhibit a different behavior when calling the late version of the API which might result in different return values in certain cases. Hence the CI type is 1."
439,<android.widget.AbsListView.FlingRunnable: void run()>,15,16,<android.widget.AbsListView.FlingRunnable: void run()>,<android.widget.AbsListView.FlingRunnable: void run()>,0,"{
    switch(mTouchMode) {
        default:
            endFling();
            return;
        case TOUCH_MODE_SCROLL:
            if (mScroller.isFinished()) {
                return;
            }
        // Fall through
        case TOUCH_MODE_FLING:
            {
                if (mDataChanged) {
                    layoutChildren();
                }
                if (mItemCount == 0 || getChildCount() == 0) {
                    endFling();
                    return;
                }
                final OverScroller scroller = mScroller;
                boolean more = scroller.computeScrollOffset();
                final int y = scroller.getCurrY();
                // Flip sign to convert finger direction to list items direction
                // (e.g. finger moving down means list is moving towards the top)
                int delta = mLastFlingY - y;
                // Pretend that each frame of a fling scroll is a touch scroll
                if (delta > 0) {
                    // List is moving towards the top. Use first view as mMotionPosition
                    mMotionPosition = mFirstPosition;
                    final View firstView = getChildAt(0);
                    mMotionViewOriginalTop = firstView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
                } else {
                    // List is moving towards the bottom. Use last view as mMotionPosition
                    int offsetToLast = getChildCount() - 1;
                    mMotionPosition = mFirstPosition + offsetToLast;
                    final View lastView = getChildAt(offsetToLast);
                    mMotionViewOriginalTop = lastView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
                }
                // Check to see if we have bumped into the scroll limit
                View motionView = getChildAt(mMotionPosition - mFirstPosition);
                int oldTop = 0;
                if (motionView != null) {
                    oldTop = motionView.getTop();
                }
                // Don't stop just because delta is zero (it could have been rounded)
                final boolean atEnd = trackMotionScroll(delta, delta) && (delta != 0);
                if (atEnd) {
                    if (motionView != null) {
                        // Tweak the scroll for how far we overshot
                        int overshoot = -(delta - (motionView.getTop() - oldTop));
                        overScrollBy(0, overshoot, 0, mScrollY, 0, 0, 0, mOverflingDistance, false);
                    }
                    if (more) {
                        edgeReached(delta);
                    }
                    break;
                }
                if (more && !atEnd) {
                    invalidate();
                    mLastFlingY = y;
                    post(this);
                } else {
                    endFling();
                    if (PROFILE_FLINGING) {
                        if (mFlingProfilingStarted) {
                            Debug.stopMethodTracing();
                            mFlingProfilingStarted = false;
                        }
                        if (mFlingStrictSpan != null) {
                            mFlingStrictSpan.finish();
                            mFlingStrictSpan = null;
                        }
                    }
                }
                break;
            }
        case TOUCH_MODE_OVERFLING:
            {
                final OverScroller scroller = mScroller;
                if (scroller.computeScrollOffset()) {
                    final int scrollY = mScrollY;
                    final int currY = scroller.getCurrY();
                    final int deltaY = currY - scrollY;
                    if (overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, mOverflingDistance, false)) {
                        final boolean crossDown = scrollY <= 0 && currY > 0;
                        final boolean crossUp = scrollY >= 0 && currY < 0;
                        if (crossDown || crossUp) {
                            int velocity = (int) scroller.getCurrVelocity();
                            if (crossUp)
                                velocity = -velocity;
                            // Don't flywheel from this; we're just continuing things.
                            scroller.abortAnimation();
                            start(velocity);
                        } else {
                            startSpringback();
                        }
                    } else {
                        invalidate();
                        post(this);
                    }
                } else {
                    endFling();
                }
                break;
            }
    }
}","{
    switch(mTouchMode) {
        default:
            endFling();
            return;
        case TOUCH_MODE_SCROLL:
            if (mScroller.isFinished()) {
                return;
            }
        // Fall through
        case TOUCH_MODE_FLING:
            {
                if (mDataChanged) {
                    layoutChildren();
                }
                if (mItemCount == 0 || getChildCount() == 0) {
                    endFling();
                    return;
                }
                final OverScroller scroller = mScroller;
                boolean more = scroller.computeScrollOffset();
                final int y = scroller.getCurrY();
                // Flip sign to convert finger direction to list items direction
                // (e.g. finger moving down means list is moving towards the top)
                int delta = mLastFlingY - y;
                // Pretend that each frame of a fling scroll is a touch scroll
                if (delta > 0) {
                    // List is moving towards the top. Use first view as mMotionPosition
                    mMotionPosition = mFirstPosition;
                    final View firstView = getChildAt(0);
                    mMotionViewOriginalTop = firstView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
                } else {
                    // List is moving towards the bottom. Use last view as mMotionPosition
                    int offsetToLast = getChildCount() - 1;
                    mMotionPosition = mFirstPosition + offsetToLast;
                    final View lastView = getChildAt(offsetToLast);
                    mMotionViewOriginalTop = lastView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
                }
                // Check to see if we have bumped into the scroll limit
                View motionView = getChildAt(mMotionPosition - mFirstPosition);
                int oldTop = 0;
                if (motionView != null) {
                    oldTop = motionView.getTop();
                }
                // Don't stop just because delta is zero (it could have been rounded)
                final boolean atEdge = trackMotionScroll(delta, delta);
                final boolean atEnd = atEdge && (delta != 0);
                if (atEnd) {
                    if (motionView != null) {
                        // Tweak the scroll for how far we overshot
                        int overshoot = -(delta - (motionView.getTop() - oldTop));
                        overScrollBy(0, overshoot, 0, mScrollY, 0, 0, 0, mOverflingDistance, false);
                    }
                    if (more) {
                        edgeReached(delta);
                    }
                    break;
                }
                if (more && !atEnd) {
                    if (atEdge)
                        invalidate();
                    mLastFlingY = y;
                    postOnAnimation(this);
                } else {
                    endFling();
                    if (PROFILE_FLINGING) {
                        if (mFlingProfilingStarted) {
                            Debug.stopMethodTracing();
                            mFlingProfilingStarted = false;
                        }
                        if (mFlingStrictSpan != null) {
                            mFlingStrictSpan.finish();
                            mFlingStrictSpan = null;
                        }
                    }
                }
                break;
            }
        case TOUCH_MODE_OVERFLING:
            {
                final OverScroller scroller = mScroller;
                if (scroller.computeScrollOffset()) {
                    final int scrollY = mScrollY;
                    final int currY = scroller.getCurrY();
                    final int deltaY = currY - scrollY;
                    if (overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, mOverflingDistance, false)) {
                        final boolean crossDown = scrollY <= 0 && currY > 0;
                        final boolean crossUp = scrollY >= 0 && currY < 0;
                        if (crossDown || crossUp) {
                            int velocity = (int) scroller.getCurrVelocity();
                            if (crossUp)
                                velocity = -velocity;
                            // Don't flywheel from this; we're just continuing things.
                            scroller.abortAnimation();
                            start(velocity);
                        } else {
                            startSpringback();
                        }
                    } else {
                        invalidate();
                        postOnAnimation(this);
                    }
                } else {
                    endFling();
                }
                break;
            }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change has occurred in a condition check statement ""if (more && !atEnd)"" where an additional condition ""atEdge"" is checked in the late version. In addition, a method invocation has changed from ""post(this)"" to ""postOnAnimation(this)"", so the change type is 3,4.","Since the change doesn't affect the outcomes of the 'run' method (no return values and exceptions), it does not qualify as a Compatibility Issue (CI)."
441,<android.webkit.CookieManager: void removeSessionCookie()>,15,16,<android.webkit.CookieManager: void removeSessionCookie()>,<android.webkit.CookieManager: void removeSessionCookie()>,0,"{
    signalCookieOperationsStart();
    if (JniUtil.useChromiumHttpStack()) {
        new AsyncTask<Void, Void, Void>() {

            protected Void doInBackground(Void... none) {
                nativeRemoveSessionCookie();
                signalCookieOperationsComplete();
                return null;
            }
        }.execute();
        return;
    }
    final Runnable clearCache = new Runnable() {

        public void run() {
            synchronized (CookieManager.this) {
                Collection<ArrayList<Cookie>> cookieList = mCookieMap.values();
                Iterator<ArrayList<Cookie>> listIter = cookieList.iterator();
                while (listIter.hasNext()) {
                    ArrayList<Cookie> list = listIter.next();
                    Iterator<Cookie> iter = list.iterator();
                    while (iter.hasNext()) {
                        Cookie cookie = iter.next();
                        if (cookie.expires == -1) {
                            iter.remove();
                        }
                    }
                }
                CookieSyncManager.getInstance().clearSessionCookies();
                signalCookieOperationsComplete();
            }
        }
    };
    new Thread(clearCache).start();
}","{
    throw new MustOverrideException();
}",1,"/**
 * Remove all session cookies, which are cookies without expiration date
 */
","/**
 * Removes all session cookies, which are cookies without an expiration
 * date.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The entire method implementation has changed. The original code has been removed, and a new exception throw statement is introduced in the late version. So the code change type is 1,2.","The deletion of old implementation and introduction of a throw new MustOverrideException() makes the API potentially return different values and throw a different exception Thus, the CI type is 1,2."
442,<android.app.Notification: Notification clone()>,15,16,<android.app.Notification: Notification clone()>,<android.app.Notification: Notification clone()>,0,"{
    Notification that = new Notification();
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    return that;
}","{
    Notification that = new Notification();
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    final String[] thiskind = this.kind;
    if (thiskind != null) {
        final int N = thiskind.length;
        final String[] thatkind = that.kind = new String[N];
        System.arraycopy(thiskind, 0, thatkind, 0, N);
    }
    if (this.extras != null) {
        that.extras = new Bundle(this.extras);
    }
    that.actions = new Action[this.actions.length];
    for (int i = 0; i < this.actions.length; i++) {
        that.actions[i] = this.actions[i].clone();
    }
    if (this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    return that;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"In the Late_Implementation, there are more lines of code that assign values to the new notification object (""that""). Variables such as ""priority"", ""kind"", ""extras"", ""actions"" and ""bigContentView"" are now also cloned. Thus, the return statement has effectively changed as the returned object ""that"" may have different properties filled in based on the original notification.","The changes made effectively means the method can potentially return a different object, even when called with the same input. This introduces a possible compatibility issue where the late version API could return different results compared to the early version API. Thus, the CI type is 1."
444,<android.widget.TextView: void onEditorAction(int)>,15,16,<android.widget.TextView: void onEditorAction(int)>,<android.widget.TextView: void onEditorAction(int)>,0,"{
    final InputContentType ict = mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_FORWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_FORWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_BACKWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_BACKWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            return;
        }
    }
    Handler h = getHandler();
    if (h != null) {
        long eventTime = SystemClock.uptimeMillis();
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
    }
}","{
    final Editor.InputContentType ict = mEditor == null ? null : mEditor.mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_FORWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_FORWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_BACKWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_BACKWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            return;
        }
    }
    ViewRootImpl viewRootImpl = getViewRootImpl();
    if (viewRootImpl != null) {
        long eventTime = SystemClock.uptimeMillis();
        viewRootImpl.dispatchKeyFromIme(new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION));
        viewRootImpl.dispatchKeyFromIme(new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION));
    }
}",1,"/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
","/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The way `ict` is initialized and the way messages are sent at the end of the method have been modified. Hence, the change type is 4,5.","With the change of code, the method can potentially return different results depending on the values of `onEditorActionListener()`, `focusSearch()`, and `dispatchKeyFromIme()`. Hence, the CI type is 1."
446,<android.widget.NumberPicker: void setValue(int)>,15,16,<android.widget.NumberPicker: void setValue(int)>,<android.widget.NumberPicker: void setValue(int)>,0,"{
    if (mValue == value) {
        return;
    }
    if (value < mMinValue) {
        value = mWrapSelectorWheel ? mMaxValue : mMinValue;
    }
    if (value > mMaxValue) {
        value = mWrapSelectorWheel ? mMinValue : mMaxValue;
    }
    mValue = value;
    initializeSelectorWheelIndices();
    updateInputTextView();
    updateIncrementAndDecrementButtonsVisibilityState();
    invalidate();
}","{
    setValueInternal(value, false);
}",1,"/**
 * Set the current value for the number picker.
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 *
 * @param value The current value.
 * @see #setWrapSelectorWheel(boolean)
 * @see #setMinValue(int)
 * @see #setMaxValue(int)
 */
","/**
 * Set the current value for the number picker.
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 *
 * @param value The current value.
 * @see #setWrapSelectorWheel(boolean)
 * @see #setMinValue(int)
 * @see #setMaxValue(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The returned value and entire functionality of `setValue()` method have been changed as the implementation has been moved to a dependent method `setValueInternal()` which is affecting the behavior of the method, hence the change type is 1,4,5.","The change in the method `setValue()` causes the API to potentially return a different value and might behave differently than the early version because all functionality moved to `setValueInternal()`, so the Compatibility Issue type is 1."
447,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",15,16,"<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>","<android.speech.tts.PlaybackSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    int channelConfig = AudioPlaybackHandler.getChannelConfig(channelCount);
    if (channelConfig == 0) {
        Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
        return TextToSpeech.ERROR;
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return TextToSpeech.ERROR;
        }
        SynthesisMessageParams params = new SynthesisMessageParams(mStreamType, sampleRateInHz, audioFormat, channelCount, mVolume, mPan, mDispatcher, mCallingApp, mLogger);
        mAudioTrackHandler.enqueueSynthesisStart(params);
        mToken = params;
    }
    return TextToSpeech.SUCCESS;
}","{
    if (DBG) {
        Log.d(TAG, ""start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    int channelConfig = BlockingAudioTrack.getChannelConfig(channelCount);
    if (channelConfig == 0) {
        Log.e(TAG, ""Unsupported number of channels :"" + channelCount);
        return TextToSpeech.ERROR;
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""stop() called before start(), returning."");
            return TextToSpeech.ERROR;
        }
        SynthesisPlaybackQueueItem item = new SynthesisPlaybackQueueItem(mStreamType, sampleRateInHz, audioFormat, channelCount, mVolume, mPan, mDispatcher, mCallerIdentity, mLogger);
        mAudioTrackHandler.enqueue(item);
        mItem = item;
    }
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The dependent API, getChannelConfig(int), called from a different class (from AudioPlaybackHandler to BlockingAudioTrack) and the instance of SynthesisMessageParams was replaced by a new instance of SynthesisPlaybackQueueItem. This is followed by changes in the parameter names and a method name changing from enqueueSynthesisStart(param) to enqueue(item), so the code change type is 1,4,5.","The returned object from the method call is changed (from enqueueSynthesisStart(param) to enqueue(item)), potentially affecting the return behaviour of the function hence leading to a different output. Therefore, the CI type is 1."
448,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,15,16,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,0,"{
    checkThread();
    WebBackForwardList returnList = null;
    if (inState == null) {
        return returnList;
    }
    if (inState.containsKey(""index"") && inState.containsKey(""history"")) {
        mCertificate = SslCertificate.restoreState(inState.getBundle(""certificate""));
        final WebBackForwardList list = mCallbackProxy.getBackForwardList();
        final int index = inState.getInt(""index"");
        // modifications.
        synchronized (list) {
            final List<byte[]> history = (List<byte[]>) inState.getSerializable(""history"");
            final int size = history.size();
            // restoring the history index.
            if (index < 0 || index >= size) {
                return null;
            }
            for (int i = 0; i < size; i++) {
                byte[] data = history.remove(0);
                if (data == null) {
                    // the item and thus our history list cannot be rebuilt.
                    return null;
                }
                WebHistoryItem item = new WebHistoryItem(data);
                list.addHistoryItem(item);
            }
            // Grab the most recent copy to return to the caller.
            returnList = copyBackForwardList();
            // Update the copy to have the correct index.
            returnList.setCurrentIndex(index);
        }
        // Restore private browsing setting.
        if (inState.getBoolean(""privateBrowsingEnabled"")) {
            getSettings().setPrivateBrowsingEnabled(true);
        }
        mZoomManager.restoreZoomState(inState);
        // Remove all pending messages because we are restoring previous
        // state.
        mWebViewCore.removeMessages();
        // Send a restore state message.
        mWebViewCore.sendMessage(EventHub.RESTORE_STATE, index);
    }
    return returnList;
}","{
    checkThread();
    return mProvider.restoreState(inState);
}",1,"/**
 * Restore the state of this WebView from the given map used in
 * {@link android.app.Activity#onRestoreInstanceState}. This method should
 * be called to restore the state of the WebView before using the object. If
 * it is called after the WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView. See {@link #savePicture} and {@link
 * #restorePicture} for saving and restoring the display data.
 * @param inState The incoming Bundle of state.
 * @return The restored back/forward list or null if restoreState failed.
 * @see #savePicture
 * @see #restorePicture
 */
","/**
 * Restores the state of this WebView from the given map used in
 * {@link android.app.Activity#onRestoreInstanceState}. This method should
 * be called to restore the state of this WebView before using the object. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView. See {@link #savePicture} and {@link
 * #restorePicture} for saving and restoring the display data.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 * @see #savePicture
 * @see #restorePicture
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole part of handling 'inState' within if statement has been extracted and contracted to a single line that is mProvider.restoreState(inState), which leads to 1 and 5 change type.","The returned results ""mProvider.restoreState(inState)"" and ""returnList"" might be different. Thus the Compatibility Issue type is 1."
450,<android.webkit.WebView: boolean overlayHorizontalScrollbar()>,15,16,<android.webkit.WebView: boolean overlayHorizontalScrollbar()>,<android.webkit.WebView: boolean overlayHorizontalScrollbar()>,0,"{
    checkThread();
    return mOverlayHorizontalScrollbar;
}","{
    checkThread();
    return mProvider.overlayHorizontalScrollbar();
}",1,"/**
 * Return whether horizontal scrollbar has overlay style
 * @return TRUE if horizontal scrollbar has overlay style.
 */
","/**
 * Gets whether horizontal scrollbar has overlay style.
 *
 * @return true if horizontal scrollbar has overlay style
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning a local variable (mOverlayHorizontalScrollbar) to returning the result of a method call (mProvider.overlayHorizontalScrollbar()), so the type of the code change is 1,5.","The change of the return statement can potentially cause the API to return a different value, so the CI type is 1."
452,"<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>",15,16,"<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>","<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>",0,"{
    SQLiteStatement statement = new SQLiteStatement(this, ""DELETE FROM "" + table + (!TextUtils.isEmpty(whereClause) ? "" WHERE "" + whereClause : """"), whereArgs);
    try {
        return statement.executeUpdateDelete();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        statement.close();
    }
}","{
    acquireReference();
    try {
        SQLiteStatement statement = new SQLiteStatement(this, ""DELETE FROM "" + table + (!TextUtils.isEmpty(whereClause) ? "" WHERE "" + whereClause : """"), whereArgs);
        try {
            return statement.executeUpdateDelete();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}",1,"/**
 * Convenience method for deleting rows in the database.
 *
 * @param table the table to delete from
 * @param whereClause the optional WHERE clause to apply when deleting.
 * Passing null will delete all rows.
 * @return the number of rows affected if a whereClause is passed in, 0
 * otherwise. To remove all rows and get a count pass ""1"" as the
 * whereClause.
 */
","/**
 * Convenience method for deleting rows in the database.
 *
 * @param table the table to delete from
 * @param whereClause the optional WHERE clause to apply when deleting.
 * Passing null will delete all rows.
 * @return the number of rows affected if a whereClause is passed in, 0
 * otherwise. To remove all rows and get a count pass ""1"" as the
 * whereClause.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Introduced method calls acquireReference() and releaseReference() are added. Also, added control statement `try...finally...` having `statement.close();`. So, the change types are 1,3,4.","The API now calls acquireReference() and releaseReference(), as well as statement.close(), so it could have a different return behaviour. Hence, one possible potential compatibility issue is 1."
453,<android.webkit.WebViewDatabase: void clearHttpAuthUsernamePassword()>,15,16,<android.webkit.WebViewDatabase: void clearHttpAuthUsernamePassword()>,<android.webkit.WebViewDatabase: void clearHttpAuthUsernamePassword()>,0,"{
    if (!checkInitialized()) {
        return;
    }
    synchronized (mHttpAuthLock) {
        mDatabase.delete(mTableNames[TABLE_HTTPAUTH_ID], null, null);
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Clear HTTP authentication password database
 */
","/**
 * Clears any HTTP authentication username/passwords that are saved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The original implementation has been entirely replaced by a new `throw` statement, so the code change type is 1 and 2.","The method previously doesn't throw any exceptions, but it now throws a `MustOverrideException` in the new version. More importantly, the original return (void return) has been exceptionally halted due to the introduced `throw` statement. Thus, the CI type is 1 and 2."
455,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,15,16,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,<android.content.AbstractThreadedSyncAdapter.SyncThread: void run()>,0,"{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    SyncResult syncResult = new SyncResult();
    ContentProviderClient provider = null;
    try {
        if (isCanceled()) {
            return;
        }
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
    } finally {
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        // that also synchronize accesses to mSyncThreads
        synchronized (mSyncThreadLock) {
            mSyncThreads.remove(mThreadsKey);
        }
    }
}","{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    // Trace this sync instance.  Note, conceptually this should be in
    // SyncStorageEngine.insertStartSyncEvent(), but the trace functions require unique
    // threads in order to track overlapping operations, so we'll do it here for now.
    Trace.traceBegin(Trace.TRACE_TAG_SYNC_MANAGER, mAuthority);
    SyncResult syncResult = new SyncResult();
    ContentProviderClient provider = null;
    try {
        if (isCanceled()) {
            return;
        }
        provider = mContext.getContentResolver().acquireContentProviderClient(mAuthority);
        if (provider != null) {
            AbstractThreadedSyncAdapter.this.onPerformSync(mAccount, mExtras, mAuthority, provider, syncResult);
        } else {
            syncResult.databaseError = true;
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYNC_MANAGER);
        if (provider != null) {
            provider.release();
        }
        if (!isCanceled()) {
            mSyncContext.onFinished(syncResult);
        }
        // that also synchronize accesses to mSyncThreads
        synchronized (mSyncThreadLock) {
            mSyncThreads.remove(mThreadsKey);
        }
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"In the late implementation, usage of Trace.traceBegin and Trace.traceEnd method is introduced, which was not present in the early implementation. Also, the API method getAuthority() used as an argument in traceBegin method and iSyncManager used as an argument in traceEnd method are newly introduced in the late version. So, the code change type is 4,5.","The introduced changes do not affect the return type or value and also do not lead to potential different exception handlings. Therefore, there is no Compatibility Issue (CI type 0)."
456,<android.view.View: boolean getLocalVisibleRect(Rect)>,15,16,<android.view.View: boolean getLocalVisibleRect(Rect)>,<android.view.View: boolean getLocalVisibleRect(Rect)>,0,"{
    Point offset = new Point();
    if (getGlobalVisibleRect(r, offset)) {
        // make r local
        r.offset(-offset.x, -offset.y);
        return true;
    }
    return false;
}","{
    final Point offset = mAttachInfo != null ? mAttachInfo.mPoint : new Point();
    if (getGlobalVisibleRect(r, offset)) {
        // make r local
        r.offset(-offset.x, -offset.y);
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The initialization of the Point object 'offset' has been changed from directly generating a new instance to generating a new instance conditionally based on the value of 'mAttachInfo'. So the code change type is 4.,"There is no Compatibility Issue as the changes do not affect the return values or the exception throwing of the method. Hence, CI type is 0."
458,<android.webkit.WebSettings: void setEnableSmoothTransition(boolean)>,15,16,<android.webkit.WebSettings: void setEnableSmoothTransition(boolean)>,<android.webkit.WebSettings: void setEnableSmoothTransition(boolean)>,0,"{
    mEnableSmoothTransition = enable;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set whether the WebView will enable smooth transition while panning or
 * zooming or while the window hosting the WebView does not have focus.
 * If it is true, WebView will choose a solution to maximize the performance.
 * e.g. the WebView's content may not be updated during the transition.
 * If it is false, WebView will keep its fidelity. The default value is false.
 */
","/**
 * Sets whether the WebView will enable smooth transition while panning or
 * zooming or while the window hosting the WebView does not have focus.
 * If it is true, WebView will choose a solution to maximize the performance.
 * e.g. the WebView's content may not be updated during the transition.
 * If it is false, WebView will keep its fidelity. The default value is false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The assignment statement is replaced by a new 'throw' statement in the implementation, so the code change type is 2.","As the assignment statement is replaced by throwing an exception statement, the way of error handling has changed dramatically. Hence, the CI type is 2."
459,<android.webkit.CallbackProxy: boolean onJsTimeout()>,15,16,<android.webkit.CallbackProxy: boolean onJsTimeout()>,<android.webkit.CallbackProxy: boolean onJsTimeout()>,0,"{
    // always interrupt timedout JS by default
    if (mWebChromeClient == null) {
        return true;
    }
    JsResult result = new JsResult(this, true);
    Message timeout = obtainMessage(JS_TIMEOUT, result);
    synchronized (this) {
        sendMessage(timeout);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for jsUnload"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    return result.getResult();
}","{
    // always interrupt timedout JS by default
    if (mWebChromeClient == null) {
        return true;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message timeout = obtainMessage(JS_TIMEOUT, result);
    sendMessageToUiThreadSync(timeout);
    return result.mJsResult.getResult();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"Several parts of the code has changed in the newer implementation. Firstly, the instance of JsResult is replaced with JsResultReceiver. Secondly, the way the Message is sent has also changed from sendMessage(timeout) to sendMessageToUiThreadSync(timeout). Finally, the return statement has been altered from getResult() to mJsResult.getResult(), therefore the code change type is 1,4,5.","The change in the return statement may lead to returning a different value depending on the new implementation. Therefore, the CI type is 1."
460,<android.webkit.WebSettings: boolean getSavePassword()>,15,16,<android.webkit.WebSettings: boolean getSavePassword()>,<android.webkit.WebSettings: boolean getSavePassword()>,0,"{
    return mSavePassword;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return whether the WebView is saving password.
 */
","/**
 * Gets whether the WebView is saving password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The only return statement get removed and replaced by a throw exception statement in the later version. So the change types are 1 (Return statement change), and 2 (Exception handling statement change).","The change in code from returning a value to directly throwing an exception will introduce a compatibility issue. The compatibility issue types are 1 (caused by potential different return values or types), and 2 (caused by potential different exception handlings)."
461,<android.webkit.WebSettings: boolean enableSmoothTransition()>,15,16,<android.webkit.WebSettings: boolean enableSmoothTransition()>,<android.webkit.WebSettings: boolean enableSmoothTransition()>,0,"{
    return mEnableSmoothTransition;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if the WebView enables smooth transition while panning or
 * zooming.
 */
","/**
 * Gets whether the WebView enables smooth transition while panning or
 * zooming.
 *
 * @see #setEnableSmoothTransition
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement ('return mEnableSmoothTransition;') in the early version is removed and replaced by 'throw new MustOverrideException();' in the late version, so the code change type is 1,2.","The change of return statement (throws MustOverrideException instead of return a boolean value) will cause the API to return a different variable and lead to potential extra exception handling. Thus, the CI type is 1,2."
463,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",15,16,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>","<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",0,"{
    if (msg.isInUse()) {
        throw new AndroidRuntimeException(msg + "" This message is already in use."");
    }
    if (msg.target == null && !mQuitAllowed) {
        throw new RuntimeException(""Main thread not allowed to quit"");
    }
    final boolean needWake;
    synchronized (this) {
        if (mQuiting) {
            RuntimeException e = new RuntimeException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            return false;
        } else if (msg.target == null) {
            mQuiting = true;
        }
        msg.when = when;
        // Log.d(""MessageQueue"", ""Enqueing: "" + msg);
        Message p = mMessages;
        if (p == null || when == 0 || when < p.when) {
            msg.next = p;
            mMessages = msg;
            // new head, might need to wake up
            needWake = mBlocked;
        } else {
            Message prev = null;
            while (p != null && p.when <= when) {
                prev = p;
                p = p.next;
            }
            msg.next = prev.next;
            prev.next = msg;
            // still waiting on head, no need to wake up
            needWake = false;
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}","{
    if (msg.isInUse()) {
        throw new AndroidRuntimeException(msg + "" This message is already in use."");
    }
    if (msg.target == null) {
        throw new AndroidRuntimeException(""Message must have a target."");
    }
    boolean needWake;
    synchronized (this) {
        if (mQuiting) {
            RuntimeException e = new RuntimeException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            return false;
        }
        msg.when = when;
        Message p = mMessages;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","Exception statements were changed (Second RuntimeException message was changed), and control dependencies were changed (the for loop in the ""else"" branch of the second synchronized block), and the return statement under the first condition in the first synchronized block was unchanged but the condition is changed (mQuiting), and the depending API isAsynchronous() is added. So, the change type is 1,2,3,5.","Different exceptions could be thrown in the two versions since the exception messages were changed. The return value could be different as a new condition (isAsynchronous) is added in the control statements. So the CI type is 1,2."
464,<android.webkit.CookieManager: void removeExpiredCookie()>,15,16,<android.webkit.CookieManager: void removeExpiredCookie()>,<android.webkit.CookieManager: void removeExpiredCookie()>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        nativeRemoveExpiredCookie();
        return;
    }
    final Runnable clearCache = new Runnable() {

        public void run() {
            synchronized (CookieManager.this) {
                long now = System.currentTimeMillis();
                Collection<ArrayList<Cookie>> cookieList = mCookieMap.values();
                Iterator<ArrayList<Cookie>> listIter = cookieList.iterator();
                while (listIter.hasNext()) {
                    ArrayList<Cookie> list = listIter.next();
                    Iterator<Cookie> iter = list.iterator();
                    while (iter.hasNext()) {
                        Cookie cookie = iter.next();
                        // negative means far future
                        if (cookie.expires > 0 && cookie.expires < now) {
                            iter.remove();
                        }
                    }
                }
                CookieSyncManager.getInstance().clearExpiredCookies(now);
            }
        }
    };
    new Thread(clearCache).start();
}","{
    throw new MustOverrideException();
}",1,"/**
 * Remove all expired cookies
 */
","/**
 * Removes all expired cookies.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The entire method implementation changed from a complex method with different operations to a single throw exception statement. Therefore, the code change type falls under both category 1 (return statement changed) and category 2 (exception handling statement changed).","The Compatibility Issue (CI) type is both 1 (changed return values/types) and 2 (changed exception handling). As the old version has numerous return stateents including 'return;' and 'start()', whereas the late version throws an exception which is a drastic change in behavior. The late version also throws an exception which did not exist in the early version."
465,<android.webkit.BrowserFrame: void handleMessage(Message)>,15,16,<android.webkit.BrowserFrame: void handleMessage(Message)>,<android.webkit.BrowserFrame: void handleMessage(Message)>,0,"{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.getScheme() + uri.getHost();
                        String[] up = mDatabase.getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                if (!JniUtil.useChromiumHttpStack()) {
                    WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_TRIM_CACHE);
                }
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                if (mOrientation != msg.arg1) {
                    mOrientation = msg.arg1;
                    nativeOrientationChanged(msg.arg1);
                }
                break;
            }
        default:
            break;
    }
}","{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.getScheme() + uri.getHost();
                        String[] up = WebViewDatabaseClassic.getInstance(mContext).getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                if (mOrientation != msg.arg1) {
                    mOrientation = msg.arg1;
                    nativeOrientationChanged(msg.arg1);
                }
                break;
            }
        default:
            break;
    }
}",1,"/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
","/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"In the FRAME_COMPLETED case part of the switch block, the way of getting the username-password pair (`up`) is changed from directly calling `mDatabase.getUsernamePassword(schemePlusHost)` to `WebViewDatabaseClassic.getInstance(mContext).getUsernamePassword(schemePlusHost)`. Hence the code change is of type 4. The change also involves a different API, so we have to classify it as type 5 as well.","Since the way the username-password pair (`up`) is obtained has been changed, and assuming that these two methods may not always fetch the same value, there is a possibility that the late version API may return a different `up` as compared to the early version. Therefore, the CI type is 1."
466,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,15,16,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,0,"{
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider);
    }
    return null;
}","{
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The construction of 'ContentProviderClient' has changed, because an additional boolean parameter ""true"" was added in the late version, so the code change type is 4.","The 'ContentProviderClient' with an explicit flag of 'true' might result in different behaviors from that without the flag. Hence, the API potentially returns a different value in late version in certain cases, so CI type is 1."
469,<android.webkit.WebHistoryItem: String getOriginalUrl()>,15,16,<android.webkit.WebHistoryItem: String getOriginalUrl()>,<android.webkit.WebHistoryItem: String getOriginalUrl()>,0,"{
    return mOriginalUrl;
}","{
    if (mNativeBridge == 0)
        return null;
    return nativeGetOriginalUrl(mNativeBridge);
}",1,"/**
 * Return the original url of this history item. This was the requested
 * url, the final url may be different as there might have been
 * redirects while loading the site.
 * @return The original url of this history item.
 */
","/**
 * Return the original url of this history item. This was the requested
 * url, the final url may be different as there might have been
 * redirects while loading the site.
 * @return The original url of this history item.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, an 'if' control structure and corresponding return statement have been added and the return statement has been changed from returning a member variable to return the result of a method call, so the code change type is 1,3.","The introduction of the 'if' control and new return statement can lead to potential different return values, thus Compatibility Issue type is 1."
470,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",15,16,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>","<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",0,"{
    verifyDbIsOpen();
    BlockGuard.getThreadPolicy().onReadFromDisk();
    SQLiteDatabase db = getDbConnection(sql);
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(db, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        releaseDbConnection(db);
    }
    return cursor;
}","{
    return rawQueryWithFactory(cursorFactory, sql, selectionArgs, editTable, null);
}",1,"/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
","/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the late version, the entire implementation has been replaced with a call to another method (rawQueryWithFactory). Thus, the change type is 1,5.","Given the change in implementation and the introduction of the another method call, it's possible that the type or value of returned variable (cursor) by the API could differ between the two versions. Therefore, the CI type is 1."
472,"<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>",15,16,"<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>","<android.widget.TextView: boolean onKeyMultiple(int,int,KeyEvent)>",0,"{
    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
    int which = doKeyDown(keyCode, down, event);
    if (which == 0) {
        // Go through default dispatching.
        return super.onKeyMultiple(keyCode, repeatCount, event);
    }
    if (which == -1) {
        // Consumed the whole thing.
        return true;
    }
    repeatCount--;
    // We are going to dispatch the remaining events to either the input
    // or movement method.  To do this, we will just send a repeated stream
    // of down and up events until we have done the complete repeatCount.
    // It would be nice if those interfaces had an onKeyMultiple() method,
    // but adding that is a more complicated change.
    KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
    if (which == 1) {
        mInput.onKeyUp(this, (Editable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mInput.onKeyDown(this, (Editable) mText, keyCode, down);
            mInput.onKeyUp(this, (Editable) mText, keyCode, up);
        }
        hideErrorIfUnchanged();
    } else if (which == 2) {
        mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mMovement.onKeyDown(this, (Spannable) mText, keyCode, down);
            mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        }
    }
    return true;
}","{
    KeyEvent down = KeyEvent.changeAction(event, KeyEvent.ACTION_DOWN);
    int which = doKeyDown(keyCode, down, event);
    if (which == 0) {
        // Go through default dispatching.
        return super.onKeyMultiple(keyCode, repeatCount, event);
    }
    if (which == -1) {
        // Consumed the whole thing.
        return true;
    }
    repeatCount--;
    // We are going to dispatch the remaining events to either the input
    // or movement method.  To do this, we will just send a repeated stream
    // of down and up events until we have done the complete repeatCount.
    // It would be nice if those interfaces had an onKeyMultiple() method,
    // but adding that is a more complicated change.
    KeyEvent up = KeyEvent.changeAction(event, KeyEvent.ACTION_UP);
    if (which == 1) {
        // mEditor and mEditor.mInput are not null from doKeyDown
        mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mEditor.mKeyListener.onKeyDown(this, (Editable) mText, keyCode, down);
            mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, up);
        }
        hideErrorIfUnchanged();
    } else if (which == 2) {
        // mMovement is not null from doKeyDown
        mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        while (--repeatCount > 0) {
            mMovement.onKeyDown(this, (Spannable) mText, keyCode, down);
            mMovement.onKeyUp(this, (Spannable) mText, keyCode, up);
        }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4, 5",1,"There has been an internal method change in the API between two versions. 'mInput' has been replaced with 'mEditor.mKeyListener', so the change falls under 'Other statements changed' and 'Dependent API changed'.","Due to the change 'mInput' to 'mEditor.mKeyListener', the method could potentially produce different return values, resulting in a compatibility issue of type 1."
473,<android.webkit.WebSettings: void setUserAgentString(String)>,15,16,<android.webkit.WebSettings: void setUserAgentString(String)>,<android.webkit.WebSettings: void setUserAgentString(String)>,0,"{
    if (ua == null || ua.length() == 0) {
        synchronized (sLockForLocaleSettings) {
            Locale currentLocale = Locale.getDefault();
            if (!sLocale.equals(currentLocale)) {
                sLocale = currentLocale;
                mAcceptLanguage = getCurrentAcceptLanguage();
            }
        }
        ua = getCurrentUserAgent();
        mUseDefaultUserAgent = true;
    } else {
        mUseDefaultUserAgent = false;
    }
    if (!ua.equals(mUserAgent)) {
        mUserAgent = ua;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the WebView's user-agent string. If the string ""ua"" is null or empty,
 * it will use the system default user-agent string.
 */
","/**
 * Sets the WebView's user-agent string. If the string ""ua"" is null or empty,
 * it will use the system default user-agent string.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late version, the whole logic has been replaced by throwing 'MustOverrideException()', so the code change type is 1,2.","The original code implementation in the early version could potentially return different values of 'mUserAgent'. However, in the late version, it will throw an exception, thus the return value and exception handling all change. Therefore, CI type is 1,2."
474,"<android.widget.AdapterViewAnimator: void showOnly(int,boolean)>",15,16,"<android.widget.AdapterViewAnimator: void showOnly(int,boolean)>","<android.widget.AdapterViewAnimator: void showOnly(int,boolean)>",0,"{
    if (mAdapter == null)
        return;
    final int adapterCount = getCount();
    if (adapterCount == 0)
        return;
    for (int i = 0; i < mPreviousViews.size(); i++) {
        View viewToRemove = mViewsMap.get(mPreviousViews.get(i)).view;
        mViewsMap.remove(mPreviousViews.get(i));
        viewToRemove.clearAnimation();
        if (viewToRemove instanceof ViewGroup) {
            ViewGroup vg = (ViewGroup) viewToRemove;
            vg.removeAllViewsInLayout();
        }
        // applyTransformForChildAtIndex here just allows for any cleanup
        // associated with this view that may need to be done by a subclass
        applyTransformForChildAtIndex(viewToRemove, -1);
        removeViewInLayout(viewToRemove);
    }
    mPreviousViews.clear();
    int newWindowStartUnbounded = childIndex - mActiveOffset;
    int newWindowEndUnbounded = newWindowStartUnbounded + getNumActiveViews() - 1;
    int newWindowStart = Math.max(0, newWindowStartUnbounded);
    int newWindowEnd = Math.min(adapterCount - 1, newWindowEndUnbounded);
    if (mLoopViews) {
        newWindowStart = newWindowStartUnbounded;
        newWindowEnd = newWindowEndUnbounded;
    }
    int rangeStart = modulo(newWindowStart, getWindowSize());
    int rangeEnd = modulo(newWindowEnd, getWindowSize());
    boolean wrap = false;
    if (rangeStart > rangeEnd) {
        wrap = true;
    }
    // newWindowEndUnbounded > adapterCount - 1
    for (Integer index : mViewsMap.keySet()) {
        boolean remove = false;
        if (!wrap && (index < rangeStart || index > rangeEnd)) {
            remove = true;
        } else if (wrap && (index > rangeEnd && index < rangeStart)) {
            remove = true;
        }
        if (remove) {
            View previousView = mViewsMap.get(index).view;
            int oldRelativeIndex = mViewsMap.get(index).relativeIndex;
            mPreviousViews.add(index);
            transformViewForTransition(oldRelativeIndex, -1, previousView, animate);
        }
    }
    // If the window has changed
    if (!(newWindowStart == mCurrentWindowStart && newWindowEnd == mCurrentWindowEnd && newWindowStartUnbounded == mCurrentWindowStartUnbounded)) {
        // Run through the indices in the new range
        for (int i = newWindowStart; i <= newWindowEnd; i++) {
            int index = modulo(i, getWindowSize());
            int oldRelativeIndex;
            if (mViewsMap.containsKey(index)) {
                oldRelativeIndex = mViewsMap.get(index).relativeIndex;
            } else {
                oldRelativeIndex = -1;
            }
            int newRelativeIndex = i - newWindowStartUnbounded;
            // If this item is in the current window, great, we just need to apply
            // the transform for it's new relative position in the window, and animate
            // between it's current and new relative positions
            boolean inOldRange = mViewsMap.containsKey(index) && !mPreviousViews.contains(index);
            if (inOldRange) {
                View view = mViewsMap.get(index).view;
                mViewsMap.get(index).relativeIndex = newRelativeIndex;
                applyTransformForChildAtIndex(view, newRelativeIndex);
                transformViewForTransition(oldRelativeIndex, newRelativeIndex, view, animate);
            // Otherwise this view is new to the window
            } else {
                // Get the new view from the adapter, add it and apply any transform / animation
                final int adapterPosition = modulo(i, adapterCount);
                View newView = mAdapter.getView(adapterPosition, null, this);
                long itemId = mAdapter.getItemId(adapterPosition);
                // We wrap the new view in a FrameLayout so as to respect the contract
                // with the adapter, that is, that we don't modify this view directly
                FrameLayout fl = getFrameForChild();
                // If the view from the adapter is null, we still keep an empty frame in place
                if (newView != null) {
                    fl.addView(newView);
                }
                mViewsMap.put(index, new ViewAndMetaData(fl, newRelativeIndex, adapterPosition, itemId));
                addChild(fl);
                applyTransformForChildAtIndex(fl, newRelativeIndex);
                transformViewForTransition(-1, newRelativeIndex, fl, animate);
            }
            mViewsMap.get(index).view.bringToFront();
        }
        mCurrentWindowStart = newWindowStart;
        mCurrentWindowEnd = newWindowEnd;
        mCurrentWindowStartUnbounded = newWindowStartUnbounded;
    }
    requestLayout();
    invalidate();
}","{
    if (mAdapter == null)
        return;
    final int adapterCount = getCount();
    if (adapterCount == 0)
        return;
    for (int i = 0; i < mPreviousViews.size(); i++) {
        View viewToRemove = mViewsMap.get(mPreviousViews.get(i)).view;
        mViewsMap.remove(mPreviousViews.get(i));
        viewToRemove.clearAnimation();
        if (viewToRemove instanceof ViewGroup) {
            ViewGroup vg = (ViewGroup) viewToRemove;
            vg.removeAllViewsInLayout();
        }
        // applyTransformForChildAtIndex here just allows for any cleanup
        // associated with this view that may need to be done by a subclass
        applyTransformForChildAtIndex(viewToRemove, -1);
        removeViewInLayout(viewToRemove);
    }
    mPreviousViews.clear();
    int newWindowStartUnbounded = childIndex - mActiveOffset;
    int newWindowEndUnbounded = newWindowStartUnbounded + getNumActiveViews() - 1;
    int newWindowStart = Math.max(0, newWindowStartUnbounded);
    int newWindowEnd = Math.min(adapterCount - 1, newWindowEndUnbounded);
    if (mLoopViews) {
        newWindowStart = newWindowStartUnbounded;
        newWindowEnd = newWindowEndUnbounded;
    }
    int rangeStart = modulo(newWindowStart, getWindowSize());
    int rangeEnd = modulo(newWindowEnd, getWindowSize());
    boolean wrap = false;
    if (rangeStart > rangeEnd) {
        wrap = true;
    }
    // newWindowEndUnbounded > adapterCount - 1
    for (Integer index : mViewsMap.keySet()) {
        boolean remove = false;
        if (!wrap && (index < rangeStart || index > rangeEnd)) {
            remove = true;
        } else if (wrap && (index > rangeEnd && index < rangeStart)) {
            remove = true;
        }
        if (remove) {
            View previousView = mViewsMap.get(index).view;
            int oldRelativeIndex = mViewsMap.get(index).relativeIndex;
            mPreviousViews.add(index);
            transformViewForTransition(oldRelativeIndex, -1, previousView, animate);
        }
    }
    // If the window has changed
    if (!(newWindowStart == mCurrentWindowStart && newWindowEnd == mCurrentWindowEnd && newWindowStartUnbounded == mCurrentWindowStartUnbounded)) {
        // Run through the indices in the new range
        for (int i = newWindowStart; i <= newWindowEnd; i++) {
            int index = modulo(i, getWindowSize());
            int oldRelativeIndex;
            if (mViewsMap.containsKey(index)) {
                oldRelativeIndex = mViewsMap.get(index).relativeIndex;
            } else {
                oldRelativeIndex = -1;
            }
            int newRelativeIndex = i - newWindowStartUnbounded;
            // If this item is in the current window, great, we just need to apply
            // the transform for it's new relative position in the window, and animate
            // between it's current and new relative positions
            boolean inOldRange = mViewsMap.containsKey(index) && !mPreviousViews.contains(index);
            if (inOldRange) {
                View view = mViewsMap.get(index).view;
                mViewsMap.get(index).relativeIndex = newRelativeIndex;
                applyTransformForChildAtIndex(view, newRelativeIndex);
                transformViewForTransition(oldRelativeIndex, newRelativeIndex, view, animate);
            // Otherwise this view is new to the window
            } else {
                // Get the new view from the adapter, add it and apply any transform / animation
                final int adapterPosition = modulo(i, adapterCount);
                View newView = mAdapter.getView(adapterPosition, null, this);
                long itemId = mAdapter.getItemId(adapterPosition);
                // We wrap the new view in a FrameLayout so as to respect the contract
                // with the adapter, that is, that we don't modify this view directly
                FrameLayout fl = getFrameForChild();
                // If the view from the adapter is null, we still keep an empty frame in place
                if (newView != null) {
                    fl.addView(newView);
                }
                mViewsMap.put(index, new ViewAndMetaData(fl, newRelativeIndex, adapterPosition, itemId));
                addChild(fl);
                applyTransformForChildAtIndex(fl, newRelativeIndex);
                transformViewForTransition(-1, newRelativeIndex, fl, animate);
            }
            mViewsMap.get(index).view.bringToFront();
        }
        mCurrentWindowStart = newWindowStart;
        mCurrentWindowEnd = newWindowEnd;
        mCurrentWindowStartUnbounded = newWindowStartUnbounded;
        if (mRemoteViewsAdapter != null) {
            int adapterStart = modulo(mCurrentWindowStart, adapterCount);
            int adapterEnd = modulo(mCurrentWindowEnd, adapterCount);
            mRemoteViewsAdapter.setVisibleRangeHint(adapterStart, adapterEnd);
        }
    }
    requestLayout();
    invalidate();
}",1,"/**
 * Shows only the specified child. The other displays Views exit the screen,
 * optionally with the with the {@link #getOutAnimation() out animation} and
 * the specified child enters the screen, optionally with the
 * {@link #getInAnimation() in animation}.
 *
 * @param childIndex The index of the child to be shown.
 * @param animate Whether or not to use the in and out animations, defaults
 * to true.
 */
","/**
 * Shows only the specified child. The other displays Views exit the screen,
 * optionally with the with the {@link #getOutAnimation() out animation} and
 * the specified child enters the screen, optionally with the
 * {@link #getInAnimation() in animation}.
 *
 * @param childIndex The index of the child to be shown.
 * @param animate Whether or not to use the in and out animations, defaults
 * to true.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method lightCall(""setVisibleRangeHint(adapterStart, adapterEnd)"") has been introduced, which doesn't belong to return statements, exception handling statements, and control dependency statements, so the code change type is 4. ","The newly introduced method call doesn't affect the return value or the exception handling of the API. So, it doesn't raise a compatibility issue. Therefore, the CI type is 0."
475,"<android.widget.AbsListView: View obtainView(int,boolean[])>",15,16,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getScrapView(position);
    View child;
    if (scrapView != null) {
        if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(scrapView, ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP, position, -1);
        }
        child = mAdapter.getView(position, scrapView, this);
        if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child, ViewDebug.RecyclerTraceType.BIND_VIEW, position, getChildCount());
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
            if (ViewDebug.TRACE_RECYCLER) {
                ViewDebug.trace(scrapView, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, position, -1);
            }
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
        if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child, ViewDebug.RecyclerTraceType.NEW_VIEW, position, getChildCount());
        }
    }
    return child;
}","{
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView != null) {
        return scrapView;
    }
    scrapView = mRecycler.getScrapView(position);
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        child.setAccessibilityDelegate(mAccessibilityDelegate);
    }
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The condition after the first 'if' changed the return, a lot of multiple statements inside and outside the if-else blocks have changed and new statements are added; hence the pred_change is 1,3,4.","The changes possibly make the API return different values for the same input. The introduction of the new return statement may lead to a different flow of the program. Therefore, the CI type is 1."
476,<android.webkit.WebSettings: int getMinimumFontSize()>,15,16,<android.webkit.WebSettings: int getMinimumFontSize()>,<android.webkit.WebSettings: int getMinimumFontSize()>,0,"{
    return mMinimumFontSize;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the minimum font size. The default is 8.
 * @return A non-negative integer between 1 and 72.
 */
","/**
 * Gets the minimum font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setMinimumFontSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the later version, a new exception being thrown was introduced, replacing the old return statement, so the code changes belong to categories 1 and 2. ","The change in the return statement and the addition of the exception throwing means that the behavior of the API can change significantly between versions. This leads to both potential different return values and different exception handlings, so the CI types are 1 and 2."
478,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>",15,16,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>",0,"{
    return openDatabase(path, factory, flags, new DefaultDatabaseErrorHandler());
}","{
    return openDatabase(path, factory, flags, null);
}",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from openDatabase(path, factory, flags, new DefaultDatabaseErrorHandler()) to openDatabase(path, factory, flags, null) and the parameter value of openDatabase() method has also changed from 'new DefaultDatabaseErrorHandler()' to 'null', so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
479,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",15,16,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + ""keyCode="" + keyCode + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // don't implement accelerator keys here; defer to host application
    if (event.isCtrlPressed()) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // to act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
        if (event.hasNoModifiers()) {
            pageUp(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageUp(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
        if (event.hasNoModifiers()) {
            pageDown(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageDown(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
        pageUp(true);
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
        pageDown(true);
        return true;
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), true, event.getMetaState());
            return true;
        }
        if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_UP:
                    pageUp(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_DOWN:
                    pageDown(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(0, mScrollY, true, 0);
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(mContentWidth, mScrollY, true, 0);
            }
        }
        if (mSelectingText) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        boolean wantsKeyEvents = nativeCursorNodePointer() == 0 || nativeCursorWantsKeyEvents();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            if (!wantsKeyEvents)
                return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        if (!wantsKeyEvents)
            return false;
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus.
        mWebViewCore.sendMessage(EventHub.FAKE_CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    return mProvider.getViewDelegate().onKeyDown(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire body of the method has been replaced from multiple complex operations to a simple single line which calls another method. So, the types of changes include Return statement and Dependent API.","Because the method has been entirely replaced it will perform differently than it did before. So, the potential different return values or even types can cause compatibility issues."
483,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>",15,16,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>","<android.webkit.WebView: boolean restorePicture(Bundle,File)>",0,"{
    checkThread();
    if (src == null || b == null) {
        return false;
    }
    if (!src.exists()) {
        return false;
    }
    try {
        final FileInputStream in = new FileInputStream(src);
        final Bundle copy = new Bundle(b);
        new Thread(new Runnable() {

            public void run() {
                try {
                    final Picture p = Picture.createFromStream(in);
                    if (p != null) {
                        // Post a runnable on the main thread to update the
                        // history picture fields.
                        mPrivateHandler.post(new Runnable() {

                            public void run() {
                                restoreHistoryPictureFields(p, copy);
                            }
                        });
                    }
                } finally {
                    try {
                        in.close();
                    } catch (Exception e) {
                    // Nothing we can do now.
                    }
                }
            }
        }).start();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    return true;
}","{
    checkThread();
    return mProvider.restorePicture(b, src);
}",1,"/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 *
 * Note that this will not work if the WebView is hardware accelerated.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 * @deprecated This method is now obsolete.
 */
","/**
 * Restores the display data that was saved in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}. Note that this will not work if
 * this WebView is hardware accelerated.
 *
 * @param b a Bundle containing the saved display data
 * @param src the file where the picture data was stored
 * @return true if the picture was successfully restored
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"In the early version, several statements and an exception handling statement exist, but they are all replaced with return mProvider.restorePicture(b, src) in the late version. Also, the API called in the return statement has changed from local implementation to mProvider's implementaion. Therefore, the change type is 1,5.","The change in return statement (mProvider.restorePicture(b, src)) makes the API potentially return a different value compared to early version, therefore the CI type is 1."
485,<android.widget.ListView: void layoutChildren()>,15,16,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
                if (ViewDebug.TRACE_RECYCLER) {
                    ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);
                }
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
486,<android.webkit.CallbackProxy: void handleMessage(Message)>,15,16,<android.webkit.CallbackProxy: void handleMessage(Message)>,<android.webkit.CallbackProxy: void handleMessage(Message)>,0,"{
    // 32-bit reads and writes.
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView, startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView, finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView, (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView, (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView, (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView, reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView, dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView, handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView, (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROCEEDED_AFTER_SSL_ERROR:
            if (mWebViewClient != null) {
                mWebViewClient.onProceededAfterSslError(mWebView, (SslError) msg.obj);
            }
            break;
        case CLIENT_CERT_REQUEST:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedClientCertRequest(mWebView, (ClientCertRequestHandler) map.get(""handler""), (String) map.get(""host_and_port""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView, mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView, (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView, (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView, msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView);
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow((WebView) msg.obj);
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView, (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long currentQuota = ((Long) map.get(""currentQuota"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                long estimatedSize = ((Long) map.get(""estimatedSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, currentQuota, estimatedSize, totalUsedQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long spaceNeeded = ((Long) map.get(""spaceNeeded"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(spaceNeeded, totalUsedQuota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsPromptResult res = (JsPromptResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView, url, message, defaultVal, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                res.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView, msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case SET_INSTALLABLE_WEBAPP:
            if (mWebChromeClient != null) {
                mWebChromeClient.setInstallableWebApp();
            }
            break;
        case NOTIFY_SEARCHBOX_LISTENERS:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                @SuppressWarnings(""unchecked"") List<String> suggestions = (List<String>) msg.obj;
                searchBox.handleSuggestions(msg.getData().getString(""query""), suggestions);
                break;
            }
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView, realm, account, args);
                }
                break;
            }
        case SEARCHBOX_IS_SUPPORTED_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean supported = (Boolean) msg.obj;
                searchBox.handleIsSupportedCallback(supported);
                break;
            }
        case SEARCHBOX_DISPATCH_COMPLETE_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean success = (Boolean) msg.obj;
                searchBox.handleDispatchCompleteCallback(msg.getData().getString(""function""), msg.getData().getInt(""id""), success);
                break;
            }
    }
}","{
    // 32-bit reads and writes.
    if (messagesBlocked())
        return;
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView.getWebView(), startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView.getWebView(), finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView.getWebView(), (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(), (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView.getWebView(), reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView.getWebView(), dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(), handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView.getWebView(), (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROCEEDED_AFTER_SSL_ERROR:
            if (mWebViewClient != null) {
                mWebViewClient.onProceededAfterSslError(mWebView.getWebView(), (SslError) msg.obj);
            }
            break;
        case CLIENT_CERT_REQUEST:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedClientCertRequest(mWebView.getWebView(), (ClientCertRequestHandler) map.get(""handler""), (String) map.get(""host_and_port""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView.getWebView(), mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(), (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(), msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView.getWebView());
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow(((WebViewClassic) msg.obj).getWebView());
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(), (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long quota = ((Long) map.get(""quota"")).longValue();
                long totalQuota = ((Long) map.get(""totalQuota"")).longValue();
                long estimatedDatabaseSize = ((Long) map.get(""estimatedDatabaseSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, quota, estimatedDatabaseSize, totalQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long requiredStorage = ((Long) map.get(""requiredStorage"")).longValue();
                long quota = ((Long) map.get(""quota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage, quota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsPromptResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(), url, message, defaultVal, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                receiver.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView.getWebView(), msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType(), data.getCapture());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case SET_INSTALLABLE_WEBAPP:
            if (mWebChromeClient != null) {
                mWebChromeClient.setInstallableWebApp();
            }
            break;
        case NOTIFY_SEARCHBOX_LISTENERS:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                @SuppressWarnings(""unchecked"") List<String> suggestions = (List<String>) msg.obj;
                searchBox.handleSuggestions(msg.getData().getString(""query""), suggestions);
                break;
            }
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(), realm, account, args);
                }
                break;
            }
        case SEARCHBOX_IS_SUPPORTED_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean supported = (Boolean) msg.obj;
                searchBox.handleIsSupportedCallback(supported);
                break;
            }
        case SEARCHBOX_DISPATCH_COMPLETE_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean success = (Boolean) msg.obj;
                searchBox.handleDispatchCompleteCallback(msg.getData().getString(""function""), msg.getData().getInt(""id""), success);
                break;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
487,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",15,16,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.add(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                InputQueue.registerInputChannel(mInputChannel, mInputHandler, Looper.myQueue());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerImpl.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.add(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerImpl.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
488,<android.webkit.WebSettings: void setTextSize(TextSize)>,15,16,<android.webkit.WebSettings: void setTextSize(TextSize)>,<android.webkit.WebSettings: void setTextSize(TextSize)>,0,"{
    setTextZoom(t.value);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the text size of the page.
 * @param t A TextSize value for increasing or decreasing the text.
 * @see WebSettings.TextSize
 * @deprecated Use {@link #setTextZoom(int)} instead
 */
","/**
 * Sets the text size of the page.
 *
 * @param t the TextSize value for increasing or decreasing the text
 * @see WebSettings.TextSize
 * @deprecated Use {@link #setTextZoom(int)} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The old implementation is replaced with a throw statement, so the change type is 2.","A new exception is introduced in the late version. This can potentially lead the API to have different exception handling behaviours, so the CI type is 2."
489,<android.view.ViewGroup: void removeAllViewsInLayout()>,15,16,<android.view.ViewGroup: void removeAllViewsInLayout()>,<android.view.ViewGroup: void removeAllViewsInLayout()>,0,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    View clearChildFocus = null;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.clearFocusForRemoval();
            clearChildFocus = view;
        }
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus != null) {
        clearChildFocus(clearChildFocus);
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    View clearChildFocus = null;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus();
            clearChildFocus = view;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus != null) {
        clearChildFocus(clearChildFocus);
        ensureInputFocusOnFirstFocusable();
    }
}",1,"/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 */
","/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The introduced new function calls like 'view.clearAccessibilityFocus()', 'cancelTouchTarget(view)', 'cancelHoverTarget(view)' and 'ensureInputFocusOnFirstFocus()', and the replacement of 'view.clearFocusForRemoval()' with 'view.unFocus()' indicate that the statements other than return, exception handling, and control dependency have changed, so the change type is 4.","Despite the addition and replacement of some function calls, these changes will not affect the return state of the function or throw an exception. Therefore, these modifications do not lead to a compatibility issue. The CI type is 0."
490,"<android.webkit.WebView: String[] getHttpAuthUsernamePassword(String,String)>",15,16,"<android.webkit.WebView: String[] getHttpAuthUsernamePassword(String,String)>","<android.webkit.WebView: String[] getHttpAuthUsernamePassword(String,String)>",0,"{
    checkThread();
    return mDatabase.getHttpAuthUsernamePassword(host, realm);
}","{
    checkThread();
    return mProvider.getHttpAuthUsernamePassword(host, realm);
}",1,"/**
 * Retrieve the HTTP authentication username and password for a given
 * host & realm pair
 *
 * @param host The host for which the credentials apply.
 * @param realm The realm for which the credentials apply.
 * @return String[] if found, String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
","/**
 * Retrieves the HTTP authentication username and password for a given
 * host and realm pair
 *
 * @param host the host for which the credentials apply
 * @param realm the realm for which the credentials apply
 * @return String[] if found. String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"Method mDatabase.getHttpAuthUsernamePassword(host, realm) has changed to mProvider.getHttpAuthUsernamePassword(host, realm), which implies that the return statements and the dependent APIs have been changed, so the code change type is 1,5.","The change in the return statement could potentially lead to different return value between two versions of API, due to the change of target API from mDatabase to mProvider, so the CI type is 1."
491,<android.view.InputDevice: KeyCharacterMap getKeyCharacterMap()>,15,16,<android.view.InputDevice: KeyCharacterMap getKeyCharacterMap()>,<android.view.InputDevice: KeyCharacterMap getKeyCharacterMap()>,0,"{
    return KeyCharacterMap.load(mId);
}","{
    return mKeyCharacterMap;
}",1,"/**
 * Gets the key character map associated with this input device.
 * @return The key character map.
 */
","/**
 * Gets the key character map associated with this input device.
 * @return The key character map.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"Return statement has been changed in the late version API, it now returns a member variable instead of calling a method to retrieve the key character map, hence the change type is 1.","Since the return statement has been changed, this may cause the API to potentially return different values, indicating a Compatibility Issue of type 1."
492,<android.app.WallpaperManager: void setResource(int)>,15,16,<android.app.WallpaperManager: void setResource(int)>,<android.app.WallpaperManager: void setResource(int)>,0,"{
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid));
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid));
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The Late implementation introduces a new condition which checks if 'sGlobals.mService' is null and if it is, a return statement is executed. So the code change types are 1 (because of new return statement) and 3 (for control dependency change).","The introduction of a new return statement can possibly change the behaviour of the API, making it return earlier than it did previously. Therefore, the CI type is 1."
493,<android.app.ContextImpl.ApplicationContentResolver: boolean releaseProvider(IContentProvider)>,15,16,<android.app.ContextImpl.ApplicationContentResolver: boolean releaseProvider(IContentProvider)>,<android.app.ContextImpl.ApplicationContentResolver: boolean releaseProvider(IContentProvider)>,0,"{
    return mMainThread.releaseProvider(provider);
}","{
    return mMainThread.releaseProvider(provider, true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method parameter in the return statement is changed, so the code change type is 1 and 5.","Since 'mMainThread.releaseProvider(provider)' has been altered to 'mMainThread.releaseProvider(provider, true)', the error handler may get a different boolean result, leading to CI type 1."
494,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,15,16,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,<android.webkit.WebView: boolean shouldDelayChildPressedState()>,0,"{
    return true;
}","{
    return mProvider.getViewDelegate().shouldDelayChildPressedState();
}",1,,,-1,[@Override],"[@Deprecated, @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from returning a constant true value to returning a method invocation, so the code change type is 1, A dependent API (mProvider.getViewDelegate().shouldDelayChildPressedState()) is called, bringing the change type is 5.","Since the return value of the method is potentially different than before, the CI type is 1."
495,<android.webkit.WebIconDatabase: void releaseIconForPageUrl(String)>,15,16,<android.webkit.WebIconDatabase: void releaseIconForPageUrl(String)>,<android.webkit.WebIconDatabase: void releaseIconForPageUrl(String)>,0,"{
    if (url != null) {
        mEventHandler.postMessage(Message.obtain(null, EventHandler.RELEASE_ICON, url));
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Release the icon for the given page url.
 * @param url The page's url.
 */
","/**
 * Release the icon for the given page url.
 * @param url The page's url.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,The entire function body has been replaced by a throw new MustOverrideException() statement. This means that the function has undergone a major change (change type 4) that introduces a new exception handling (change type 2).,"The change from performing an operation to throwing an exception is a major behavior alteration that is sure to cause compatibility issues in the context of error handling. The CI type is 2, representing a potential different exception handling."
496,<android.widget.NumberPicker: void setWrapSelectorWheel(boolean)>,15,16,<android.widget.NumberPicker: void setWrapSelectorWheel(boolean)>,<android.widget.NumberPicker: void setWrapSelectorWheel(boolean)>,0,"{
    if (wrapSelectorWheel && (mMaxValue - mMinValue) < mSelectorIndices.length) {
        throw new IllegalStateException(""Range less than selector items count."");
    }
    if (wrapSelectorWheel != mWrapSelectorWheel) {
        mWrapSelectorWheel = wrapSelectorWheel;
        updateIncrementAndDecrementButtonsVisibilityState();
    }
}","{
    final boolean wrappingAllowed = (mMaxValue - mMinValue) >= mSelectorIndices.length;
    if ((!wrapSelectorWheel || wrappingAllowed) && wrapSelectorWheel != mWrapSelectorWheel) {
        mWrapSelectorWheel = wrapSelectorWheel;
    }
}",1,"/**
 * Sets whether the selector wheel shown during flinging/scrolling should
 * wrap around the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getMaxValue()} values.
 * <p>
 * By default if the range (max - min) is more than five (the number of
 * items shown on the selector wheel) the selector wheel wrapping is
 * enabled.
 * </p>
 *
 * @param wrapSelectorWheel Whether to wrap.
 */
","/**
 * Sets whether the selector wheel shown during flinging/scrolling should
 * wrap around the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getMaxValue()} values.
 * <p>
 * By default if the range (max - min) is more than the number of items shown
 * on the selector wheel the selector wheel wrapping is enabled.
 * </p>
 * <p>
 * <strong>Note:</strong> If the number of items, i.e. the range (
 * {@link #getMaxValue()} - {@link #getMinValue()}) is less than
 * the number of items shown on the selector wheel, the selector wheel will
 * not wrap. Hence, in such a case calling this method is a NOP.
 * </p>
 *
 * @param wrapSelectorWheel Whether to wrap.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The control statement conditions in the method have changed significantly between the two versions and the exception handling statement in the early version is removed in the late version. Therefore, the change types are 3 and 4.","The Exception handling statement has been removed in the later version, therefore, the later version might behave differently than the early one when mMaxValue - mMinValue is less than mSelectorIndices.length leading to a compatibility issue situation of potential different exception handling, thus the CI type is 2."
497,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,15,16,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,0,"{
    return new int[] { EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 0, EGL_STENCIL_SIZE, 0, EGL_SURFACE_TYPE, EGL_WINDOW_BIT | (dirtyRegions ? EGL_SWAP_BEHAVIOR_PRESERVED_BIT : 0), EGL_NONE };
}","{
    return new int[] { EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 0, EGL_STENCIL_SIZE, GLES20Canvas.getStencilSize(), EGL_SURFACE_TYPE, EGL_WINDOW_BIT | (dirtyRegions ? EGL_SWAP_BEHAVIOR_PRESERVED_BIT : 0), EGL_NONE };
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The initialization of an array statement has been changed, so the change code type is 1. The parameter of EGL_STENCIL_SIZE in the array has changed from 0 to GLES20Canvas.getStencilSize(), which is a different dependent API. Therefore, the change type is also 5.","The value of the array that the method returns might be different due to the change of dependent API, so the CI type is 1."
500,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,15,16,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,0,"{
    if (mIME != null && mIME.onExtractTextContextMenuItem(id)) {
        return true;
    }
    return super.onTextContextMenuItem(id);
}","{
    if (mIME != null && mIME.onExtractTextContextMenuItem(id)) {
        // Cut and paste will change the text, which stops selection mode.
        if (id == android.R.id.copy)
            stopSelectionActionMode();
        return true;
    }
    return super.onTextContextMenuItem(id);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the code block under the 'if' statement, a new 'if' statement checking whether 'id' is equivalent to 'android.R.id.copy' is added, which counts as control dependency change (3). Also, there is a new other statement added 'stopSelectionActionMode();', which falls under other statements changed (4).","The introduction of new 'if' statement and 'stopSelectionActionMode();' can potentially change the internal states of the instance and thus may indirectly influence the results of 'super.onTextContextMenuItem(id);', which is invoked later, thus may lead to a different returned value, causing the CI type to be 1."
501,<android.webkit.WebIconDatabase: WebIconDatabase getInstance()>,15,16,<android.webkit.WebIconDatabase: WebIconDatabase getInstance()>,<android.webkit.WebIconDatabase: WebIconDatabase getInstance()>,0,"{
    // XXX: Must be created in the UI thread.
    if (sIconDatabase == null) {
        sIconDatabase = new WebIconDatabase();
    }
    return sIconDatabase;
}","{
    // XXX: Must be created in the UI thread.
    return WebViewFactory.getProvider().getWebIconDatabase();
}",1,"/**
 * Get the global instance of WebIconDatabase.
 * @return A single instance of WebIconDatabase. It will be the same
 * instance for the current process each time this method is
 * called.
 */
","/**
 * Get the global instance of WebIconDatabase.
 * @return A single instance of WebIconDatabase. It will be the same
 * instance for the current process each time this method is
 * called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from ""return sIconDatabase;"" to ""return WebViewFactory.getProvider().getWebIconDatabase();"", and the dependent API has also changed, so the code change type is classified as 1,5.","The return statement has changed, potentially causing the API to return a different value. This leads to a compatibility issue of type 1."
504,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",15,16,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>","<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",0,"{
    if (!speechItem.isValid()) {
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallingApp());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallingApp();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
}","{
    if (!speechItem.isValid()) {
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
}",1,"/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
","/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter of two function calls 'stopForApp()' and 'speechItem.getCallerIdentity()' have been changed, which is a change type of 5.",#CI_description
506,<android.os.MessageQueue: Message next()>,15,16,<android.os.MessageQueue: Message next()>,<android.os.MessageQueue: Message next()>,0,"{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            final Message msg = mMessages;
            if (msg != null) {
                final long when = msg.when;
                if (now >= when) {
                    mBlocked = false;
                    mMessages = msg.next;
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                } else {
                    nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);
                }
            } else {
                nextPollTimeoutMillis = -1;
            }
            // If first time, then get the number of idlers to run.
            if (pendingIdleHandlerCount < 0) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount == 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}","{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            if (mQuiting) {
                return null;
            }
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow in 'synchronized' statements has significantly changed from the early to the late version, including the addition of new if condition (if (mQuiting) { return null; }) and changes to existing conditions, resultantly changing return statements as well. Therefore, the code change type is 1,3.","These changes in statements under the synchronized block, specifically the new return null condition and modification in the message retrieval process, could potentially change the behaviour of the API resulting in different return values. Thus, the Compatibility Issue (CI) type is 1."
508,<android.view.View: void invalidate(Rect)>,15,16,<android.view.View: void invalidate(Rect)>,<android.view.View: void invalidate(Rect)>,0,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect r = ai.mTmpInvalRect;
            r.set(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY);
            mParent.invalidateChild(this, r);
        }
    }
}","{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect r = ai.mTmpInvalRect;
            r.set(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY);
            mParent.invalidateChild(this, r);
        }
    }
}",1,"/**
 * Mark the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some point
 * in the future. This must be called from a UI thread. To call from a non-UI
 * thread, call {@link #postInvalidate()}.
 *
 * WARNING: This method is destructive to dirty.
 * @param dirty the rectangle representing the bounds of the dirty region
 */
","/**
 * Mark the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some point
 * in the future. This must be called from a UI thread. To call from a non-UI
 * thread, call {@link #postInvalidate()}.
 *
 * WARNING: This method is destructive to dirty.
 * @param dirty the rectangle representing the bounds of the dirty region
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The early version contained an 'if' statement concerning the 'ViewDebug' class, which is absent in the late version. However, this is not affecting any returns, exception handling, control dependencies, or dependent APIs, so this is classed as an 'other statement' change (4).","The removal of the 'ViewDebug' tracing has no impact on the method's overall behaviour in terms of its returns or exception handling, so there is no compatibility issue (0)."
509,<android.app.DownloadManager.Request: ContentValues toContentValues(String)>,15,16,<android.app.DownloadManager.Request: ContentValues toContentValues(String)>,<android.app.DownloadManager.Request: ContentValues toContentValues(String)>,0,"{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}","{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}",1,"/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */
","/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"A new statement, values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed), is added which is a modification not related to return, exception handling and control dependencies, so the code change type is 1,4.","With the additional 'put' statement, the returned 'values' in the late version may contain one more entry which might cause a different behaviour. So, the CI type is 1."
510,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>",15,16,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>","<android.content.ContentProviderClient: int delete(Uri,String,String[])>",0,"{
    return mContentProvider.delete(url, selection, selectionArgs);
}","{
    try {
        return mContentProvider.delete(url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
","/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An exception handling statement is introduced and a try block is wrapped around the return statement, so the code change type is 2,3.","The new exception handling block may cause different exception throwing behavior while the wrapping of try block may lead to different return value under certain circumstances, so the CI type is 1,2."
511,<android.webkit.WebSettings: void setSupportMultipleWindows(boolean)>,15,16,<android.webkit.WebSettings: void setSupportMultipleWindows(boolean)>,<android.webkit.WebSettings: void setSupportMultipleWindows(boolean)>,0,"{
    if (mSupportMultipleWindows != support) {
        mSupportMultipleWindows = support;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView whether it supports multiple windows. TRUE means
 * that {@link WebChromeClient#onCreateWindow(WebView, boolean,
 * boolean, Message)} is implemented by the host application.
 */
","/**
 * Tells the WebView whether it supports multiple windows. TRUE means
 * that {@link WebChromeClient#onCreateWindow(WebView, boolean,
 * boolean, Message)} is implemented by the host application.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"In the late version, the entire function is replaced with a throw new MustOverrideException() statement. So, the change types are 2 (Exception handling statement changed) and 4 (Other statement changed).","The new throw statement could potentially lead to different behavior, like throwing a different exception in the late version. Therefore, the CI Type is 2 (Compatibility Issue caused by potential different exception handlings)."
512,<android.speech.tts.TextToSpeechService.SilenceSpeechItem: int playImpl()>,15,16,<android.speech.tts.TextToSpeechService.SilenceSpeechItem: int playImpl()>,<android.speech.tts.TextToSpeechService.SilenceSpeechItem: int playImpl()>,0,"{
    mToken = new SilenceMessageParams(this, getCallingApp(), mDuration);
    mAudioPlaybackHandler.enqueueSilence(mToken);
    return TextToSpeech.SUCCESS;
}","{
    mAudioPlaybackHandler.enqueue(new SilencePlaybackQueueItem(this, getCallerIdentity(), mDuration));
    return TextToSpeech.SUCCESS;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method arguments for enqueue() method have changed, and new SilencePlaybackQueueItem instance is being created instead of SilenceMessageParams, so the code change type is 4,5.",There is no compatibility issue because the return type and the exception type remain the same in both versions. It still returns TextToSpeech.SUCCESS and doesn't throw any new or different exceptions.
513,<android.webkit.WebSettings: void setUseWideViewPort(boolean)>,15,16,<android.webkit.WebSettings: void setUseWideViewPort(boolean)>,<android.webkit.WebSettings: void setUseWideViewPort(boolean)>,0,"{
    if (mUseWideViewport != use) {
        mUseWideViewport = use;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to use the wide viewport
 */
","/**
 * Tells the WebView to use the wide viewport.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The whole method body of setUseWideViewPort in the early version is removed and a throw statement is introduced in the late version, so the code change type is 1,2.","The introduced throw statement will make the late version of the API always throw an exception, which results in different behaviours when invoking the API in the two versions. Therefore the CI type is 1,2."
515,"<android.view.ViewGroup: boolean drawChild(Canvas,View,long)>",15,16,"<android.view.ViewGroup: boolean drawChild(Canvas,View,long)>","<android.view.ViewGroup: boolean drawChild(Canvas,View,long)>",0,"{
    boolean more = false;
    final int cl = child.mLeft;
    final int ct = child.mTop;
    final int cr = child.mRight;
    final int cb = child.mBottom;
    final boolean childHasIdentityMatrix = child.hasIdentityMatrix();
    final int flags = mGroupFlags;
    if ((flags & FLAG_CLEAR_TRANSFORMATION) == FLAG_CLEAR_TRANSFORMATION) {
        mChildTransformation.clear();
        mGroupFlags &= ~FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    Transformation invalidationTransform;
    final Animation a = child.getAnimation();
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = mDrawLayers ? child.getLayerType() : LAYER_TYPE_NONE;
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & FLAG_CHILDREN_DRAWN_WITH_CACHE) == FLAG_CHILDREN_DRAWN_WITH_CACHE || (flags & FLAG_ALWAYS_DRAWN_WITH_CACHE) == FLAG_ALWAYS_DRAWN_WITH_CACHE) {
        caching = true;
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    if (a != null) {
        final boolean initialized = a.isInitialized();
        if (!initialized) {
            a.initialize(cr - cl, cb - ct, getWidth(), getHeight());
            a.initializeInvalidateRegion(0, 0, cr - cl, cb - ct);
            child.onAnimationStart();
        }
        more = a.getTransformation(drawingTime, mChildTransformation, scalingRequired ? mAttachInfo.mApplicationScale : 1f);
        if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
            if (mInvalidationTransformation == null) {
                mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = mChildTransformation;
        }
        transformToApply = mChildTransformation;
        concatMatrix = a.willChangeTransformationMatrix();
        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) == FLAG_OPTIMIZE_INVALIDATE) {
                    mGroupFlags |= FLAG_INVALIDATE_REQUIRED;
                } else if ((flags & FLAG_INVALIDATE_REQUIRED) == 0) {
                    // The child need to draw an animation, potentially offscreen, so
                    // make sure we do not cancel invalidate requests
                    mPrivateFlags |= DRAW_ANIMATION;
                    invalidate(cl, ct, cr, cb);
                }
            } else {
                if (mInvalidateRegion == null) {
                    mInvalidateRegion = new RectF();
                }
                final RectF region = mInvalidateRegion;
                a.getInvalidateRegion(0, 0, cr - cl, cb - ct, region, invalidationTransform);
                // The child need to draw an animation, potentially offscreen, so
                // make sure we do not cancel invalidate requests
                mPrivateFlags |= DRAW_ANIMATION;
                final int left = cl + (int) region.left;
                final int top = ct + (int) region.top;
                invalidate(left, top, left + (int) (region.width() + .5f), top + (int) (region.height() + .5f));
            }
        }
    } else if ((flags & FLAG_SUPPORT_STATIC_TRANSFORMATIONS) == FLAG_SUPPORT_STATIC_TRANSFORMATIONS) {
        final boolean hasTransform = getChildStaticTransformation(child, mChildTransformation);
        if (hasTransform) {
            final int transformType = mChildTransformation.getTransformationType();
            transformToApply = transformType != Transformation.TYPE_IDENTITY ? mChildTransformation : null;
            concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    child.mPrivateFlags |= DRAWN;
    if (!concatMatrix && canvas.quickReject(cl, ct, cr, cb, Canvas.EdgeType.BW) && (child.mPrivateFlags & DRAW_ANIMATION) == 0) {
        return more;
    }
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        child.mRecreateDisplayList = (child.mPrivateFlags & INVALIDATED) == INVALIDATED;
        child.mPrivateFlags &= ~INVALIDATED;
    }
    child.computeScroll();
    final int sx = child.mScrollX;
    final int sy = child.mScrollY;
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                child.buildDrawingCache(true);
            }
            cache = child.getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    child.buildDrawingCache(true);
                    cache = child.getDrawingCache(true);
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = child.canHaveDisplayList();
                    break;
            }
        }
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    final int restoreTo = canvas.save();
    if (offsetForScroll) {
        canvas.translate(cl - sx, ct - sy);
    } else {
        canvas.translate(cl, ct);
        if (scalingRequired) {
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = child.getAlpha();
    if (transformToApply != null || alpha < 1.0f || !child.hasIdentityMatrix()) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    // Undo the scroll translation, apply the transformation matrix,
                    // then redo the scroll translate to get the correct result.
                    canvas.translate(-transX, -transY);
                    canvas.concat(transformToApply.getMatrix());
                    canvas.translate(transX, transY);
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1.0f) {
                    alpha *= transformToApply.getAlpha();
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix) {
                canvas.translate(-transX, -transY);
                canvas.concat(child.getMatrix());
                canvas.translate(transX, transY);
            }
        }
        if (alpha < 1.0f) {
            mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!child.onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    child.mPrivateFlags |= ALPHA_SET;
                }
            }
        }
    } else if ((child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
        child.onSetAlpha(255);
        child.mPrivateFlags &= ~ALPHA_SET;
    }
    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (cr - cl), sy + (cb - ct));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, cr - cl, cb - ct);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (hasDisplayList) {
        displayList = child.getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE) {
            final HardwareLayer layer = child.getHardwareLayer();
            if (layer != null && layer.isValid()) {
                child.mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, child.mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, child.mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((child.mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                    if (ViewDebug.TRACE_HIERARCHY) {
                        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
                    }
                    child.mPrivateFlags &= ~DIRTY_MASK;
                    child.dispatchDraw(canvas);
                } else {
                    child.draw(canvas);
                }
            } else {
                child.mPrivateFlags &= ~DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, cr - cl, cb - ct, null);
            }
        }
    } else if (cache != null) {
        child.mPrivateFlags &= ~DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                mCachePaint = cachePaint;
            }
            if (alpha < 1.0f) {
                cachePaint.setAlpha((int) (alpha * 255));
                mGroupFlags |= FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & FLAG_ALPHA_LOWER_THAN_ONE) == FLAG_ALPHA_LOWER_THAN_ONE) {
                cachePaint.setAlpha(255);
                mGroupFlags &= ~FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = child.mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    canvas.restoreToCount(restoreTo);
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            child.onSetAlpha(255);
        }
        finishAnimatingView(child, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        invalidate(true);
        if (a.hasAlpha() && (child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            child.invalidate(true);
        }
    }
    child.mRecreateDisplayList = false;
    return more;
}","{
    return child.draw(canvas, this, drawingTime);
}",1,"/**
 * Draw one child of this View Group. This method is responsible for getting
 * the canvas in the right state. This includes clipping, translating so
 * that the child's scrolled origin is at 0, 0, and applying any animation
 * transformations.
 *
 * @param canvas The canvas on which to draw the child
 * @param child Who to draw
 * @param drawingTime The time at which draw is occuring
 * @return True if an invalidate() was issued
 */
","/**
 * Draw one child of this View Group. This method is responsible for getting
 * the canvas in the right state. This includes clipping, translating so
 * that the child's scrolled origin is at 0, 0, and applying any animation
 * transformations.
 *
 * @param canvas The canvas on which to draw the child
 * @param child Who to draw
 * @param drawingTime The time at which draw is occurring
 * @return True if an invalidate() was issued
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
516,"<android.webkit.SelectActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",15,16,"<android.webkit.SelectActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>","<android.webkit.SelectActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",0,"{
    mode.getMenuInflater().inflate(com.android.internal.R.menu.webview_copy, menu);
    final Context context = mWebView.getContext();
    boolean allowText = context.getResources().getBoolean(com.android.internal.R.bool.config_allowActionMenuItemTextWithIcon);
    mode.setTitle(allowText ? context.getString(com.android.internal.R.string.textSelectionCABTitle) : null);
    if (!mode.isUiFocusable()) {
        // If the action mode UI we're running in isn't capable of taking window focus
        // the user won't be able to type into the find on page UI. Disable this functionality.
        // (Note that this should only happen in floating dialog windows.)
        // This can be removed once we can handle multiple focusable windows at a time
        // in a better way.
        final MenuItem findOnPageItem = menu.findItem(com.android.internal.R.id.find);
        if (findOnPageItem != null) {
            findOnPageItem.setVisible(false);
        }
    }
    mActionMode = mode;
    return true;
}","{
    mode.getMenuInflater().inflate(com.android.internal.R.menu.webview_copy, menu);
    final Context context = mWebView.getContext();
    mode.setTitle(context.getString(com.android.internal.R.string.textSelectionCABTitle));
    mode.setTitleOptionalHint(true);
    // If the action mode UI we're running in isn't capable of taking window focus
    // the user won't be able to type into the find on page UI. Disable this functionality.
    // (Note that this should only happen in floating dialog windows.)
    // This can be removed once we can handle multiple focusable windows at a time
    // in a better way.
    ClipboardManager cm = (ClipboardManager) (context.getSystemService(Context.CLIPBOARD_SERVICE));
    boolean isFocusable = mode.isUiFocusable();
    boolean isEditable = mWebView.focusCandidateIsEditableText();
    boolean canPaste = isEditable && cm.hasPrimaryClip() && isFocusable;
    boolean canFind = !isEditable && isFocusable;
    boolean canCut = isEditable && mIsTextSelected && isFocusable;
    boolean canCopy = mIsTextSelected;
    boolean canWebSearch = mIsTextSelected;
    setMenuVisibility(menu, canFind, com.android.internal.R.id.find);
    setMenuVisibility(menu, canPaste, com.android.internal.R.id.paste);
    setMenuVisibility(menu, canCut, com.android.internal.R.id.cut);
    setMenuVisibility(menu, canCopy, com.android.internal.R.id.copy);
    setMenuVisibility(menu, canWebSearch, com.android.internal.R.id.websearch);
    mActionMode = mode;
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There's a significant change in the method body implementation. Several new lines of code were added related to clipboard management and menu visibility setup. The lines related to the ""allowText"" variable in the early version were removed in the late version. None of the changes are related to returns, exceptions, control dependencies, or dependent APIs. Therefore, the change type is 4.","Even though there does exist a change, these changes do not cause a compatibility issue because the true return and the invoked APIs remained consistent between these two versions. Hence, the CI type is 0."
518,<android.view.View: void draw(Canvas)>,15,16,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
    }
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & DIRTY_MASK) == DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~DIRTY_MASK) | DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBGDrawable;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
}","{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & DIRTY_MASK) == DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~DIRTY_MASK) | DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBackground;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
519,<android.widget.TextView: float getRightFadingEdgeStrength()>,15,16,<android.widget.TextView: float getRightFadingEdgeStrength()>,<android.widget.TextView: float getRightFadingEdgeStrength()>,0,"{
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return 0.0f;
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            return (marquee.mMaxFadeScroll - marquee.mScroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}","{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            return (marquee.mMaxFadeScroll - marquee.mScroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The first 'if' statement and the associated return statement are removed in the late version, so the code change type is 1,3.","The change in the 'if' condition and the removal of the corresponding return statement could lead to a different return value, thus the CI type is 1."
520,<android.webkit.WebSettings: boolean getPluginsEnabled()>,15,16,<android.webkit.WebSettings: boolean getPluginsEnabled()>,<android.webkit.WebSettings: boolean getPluginsEnabled()>,0,"{
    return mPluginState == PluginState.ON;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return true if plugins are enabled.
 * @return True if plugins are enabled.
 * @deprecated This method has been replaced by {@link #getPluginState}
 */
","/**
 * Gets whether plugins are enabled.
 *
 * @return true if plugins are enabled
 * @deprecated This method has been replaced by {@link #getPluginState}
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement of the method has been replaced by a throw statement, so the code change type is 1,2.","The change from a return statement to a throw statement means that the potential behavior of the API has significantly changed, causing potential different return values or exceptions. Hence the Compatibility Issue type is 1,2."
523,<android.webkit.WebSettings: String getSerifFontFamily()>,15,16,<android.webkit.WebSettings: String getSerifFontFamily()>,<android.webkit.WebSettings: String getSerifFontFamily()>,0,"{
    return mSerifFontFamily;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the serif font family name. The default is ""serif"".
 * @return The serif font family name as a string.
 */
","/**
 * Gets the serif font family name. The default is ""serif"".
 *
 * @return the serif font family name as a string
 * @see #setSerifFontFamily
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been removed and replaced with an exception throw statement in the late version. Hence, the change type is 1,2.","As the return statement has been replaced, the late version API returns differently than the early version. Also, the late version throws an exception instead of returning a value. Therefore, the CI type is 1,2."
524,"<android.view.View: void invalidate(int,int,int,int)>",15,16,"<android.view.View: void invalidate(int,int,int,int)>","<android.view.View: void invalidate(int,int,int,int)>",0,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null && l < r && t < b) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect tmpr = ai.mTmpInvalRect;
            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
            p.invalidateChild(this, tmpr);
        }
    }
}","{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null && l < r && t < b) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect tmpr = ai.mTmpInvalRect;
            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
            p.invalidateChild(this, tmpr);
        }
    }
}",1,"/**
 * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.
 * The coordinates of the dirty rect are relative to the view.
 * If the view is visible, {@link #onDraw(android.graphics.Canvas)}
 * will be called at some point in the future. This must be called from
 * a UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
","/**
 * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.
 * The coordinates of the dirty rect are relative to the view.
 * If the view is visible, {@link #onDraw(android.graphics.Canvas)}
 * will be called at some point in the future. This must be called from
 * a UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The early version of code has two additional lines related to the ViewDebug trace. In the later version, these lines have been deleted. Therefore, the code change type is 4 for 'Other statement changed'.",The changes are purely debug-related and do not impact the execution or output of the function therefore no compatibility issue exists.
526,<android.view.ViewGroup: boolean dispatchPopulateAccessibilityEventInternal(AccessibilityEvent)>,15,16,<android.view.ViewGroup: boolean dispatchPopulateAccessibilityEventInternal(AccessibilityEvent)>,<android.view.ViewGroup: boolean dispatchPopulateAccessibilityEventInternal(AccessibilityEvent)>,0,"{
    boolean handled = super.dispatchPopulateAccessibilityEventInternal(event);
    if (handled) {
        return handled;
    }
    // Let our children have a shot in populating the event.
    for (int i = 0, count = getChildCount(); i < count; i++) {
        View child = getChildAt(i);
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
            handled = getChildAt(i).dispatchPopulateAccessibilityEvent(event);
            if (handled) {
                return handled;
            }
        }
    }
    return false;
}","{
    boolean handled = false;
    if (includeForAccessibility()) {
        handled = super.dispatchPopulateAccessibilityEventInternal(event);
        if (handled) {
            return handled;
        }
    }
    // Let our children have a shot in populating the event.
    ChildListForAccessibility children = ChildListForAccessibility.obtain(this, true);
    try {
        final int childCount = children.getChildCount();
        for (int i = 0; i < childCount; i++) {
            View child = children.getChildAt(i);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                handled = child.dispatchPopulateAccessibilityEvent(event);
                if (handled) {
                    return handled;
                }
            }
        }
    } finally {
        children.recycle();
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The variable initialization statement 'boolean handled = super.dispatchPopulateAccessibilityEventInternal(event);' has been changed to 'boolean handled = false;' and then this statement 'handled = super.dispatchPopulateAccessibilityEventInternal(event);' has been appended to 'if(includeForAccessibility())'. In addition, the for loop has changed including the iterable object and the variable assignment method. Furthermore, the late version involved the API 'ChildListForAccessibility.obtain(this, true)' which is not present in the early version. Therefore, the change type is 1,3,4,5.","Based on the change of the loop variable, the condition of the if statement and the new API usage, these changes may result in returning a different value from before. Therefore, the CI type is 1."
527,<android.webkit.WebSettings: void setAppCachePath(String)>,15,16,<android.webkit.WebSettings: void setAppCachePath(String)>,<android.webkit.WebSettings: void setAppCachePath(String)>,0,"{
    if (appCachePath != null && !appCachePath.equals(mAppCachePath)) {
        mAppCachePath = appCachePath;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set a custom path to the Application Caches files. The client
 * must ensure it exists before this call.
 * @param appCachePath String path to the directory containing Application
 * Caches files. The appCache path can be the empty string but should not
 * be null. Passing null for this parameter will result in a no-op.
 */
","/**
 * Sets a custom path to the Application Caches files. The client
 * must ensure it exists before this call.
 *
 * @param appCachePath a String path to the directory containing
 * Application Caches files. The appCache path can be
 * the empty string but should not be null. Passing
 * null for this parameter will result in a no-op.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The whole implementation of the function has been replaced by a new `throw` statement, leading to changes in both return statements (despite they are implicit before and after the change) and exception handling statements.","The late version of the API will always throw a `MustOverrideException`, making its behavior completely different from the early version. Thus, it can potentially return different values/types and throw different exceptions. Therefore, the CI situation is 1,2."
528,<android.webkit.CallbackProxy: boolean shouldOverrideUrlLoading(String)>,15,16,<android.webkit.CallbackProxy: boolean shouldOverrideUrlLoading(String)>,<android.webkit.CallbackProxy: boolean shouldOverrideUrlLoading(String)>,0,"{
    // We have a default behavior if no client exists so always send the
    // message.
    ResultTransport<Boolean> res = new ResultTransport<Boolean>(false);
    Message msg = obtainMessage(OVERRIDE_URL);
    msg.getData().putString(""url"", url);
    msg.obj = res;
    synchronized (this) {
        sendMessage(msg);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for overrideUrl"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    return res.getResult().booleanValue();
}","{
    // We have a default behavior if no client exists so always send the
    // message.
    ResultTransport<Boolean> res = new ResultTransport<Boolean>(false);
    Message msg = obtainMessage(OVERRIDE_URL);
    msg.getData().putString(""url"", url);
    msg.obj = res;
    sendMessageToUiThreadSync(msg);
    return res.getResult().booleanValue();
}",1,"/**
 * Called by the WebCore side
 */
","/**
 * Called by the WebCore side
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The synchronization block has been removed and replaced with the sendMessageToUiThreadSync(msg) method, which internally handles synchronization and waiting. Hence, the type of code change is 4 (Other statement changed).","In the early version, the execution of code blocks until the wait ends (either interrupted or notified). In the late version, sendMessageToUiThreadSync(msg) is added, which potentially might throw an exception and the value returned by the function could potentially change based on how the message is handled by the UI thread, hence the type of Compatibility Issue is 1."
530,"<android.server.BluetoothService: boolean notifyIncomingA2dpConnection(String,boolean)>",15,16,"<android.server.BluetoothService: boolean notifyIncomingA2dpConnection(String,boolean)>","<android.server.BluetoothService: boolean notifyIncomingA2dpConnection(String,boolean)>",0,"{
    BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
    if (state != null) {
        Message msg = new Message();
        if (rejected) {
            if (mHeadsetProxy.getPriority(getRemoteDevice(address)) >= BluetoothProfile.PRIORITY_ON) {
                msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
                msg.arg1 = BluetoothDeviceProfileState.CONNECT_HFP_OUTGOING;
                state.sendMessageDelayed(msg, BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
            }
        } else {
            msg.what = BluetoothDeviceProfileState.CONNECT_A2DP_INCOMING;
            state.sendMessage(msg);
        }
        return true;
    }
    return false;
}","{
    synchronized (this) {
        if (!mAllowConnect) {
            Log.d(TAG, ""Not allowing a2dp connection because of temporary BT on state."");
            return false;
        }
    }
    BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
    if (state != null) {
        Message msg = new Message();
        if (rejected) {
            if (mHeadsetProxy.getPriority(getRemoteDevice(address)) >= BluetoothProfile.PRIORITY_ON) {
                msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
                msg.arg1 = BluetoothDeviceProfileState.CONNECT_HFP_OUTGOING;
                state.sendMessageDelayed(msg, BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
            }
        } else {
            msg.what = BluetoothDeviceProfileState.CONNECT_A2DP_INCOMING;
            state.sendMessage(msg);
        }
        return true;
    }
    return false;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"An additional return statement 'return false' has been introduced in an early part of the function body within a synchronised block in the Late Implementation, so the pred_change is 1,3.","Due to the addition of the control block, the method can potentially terminate early and return a different value (false) depending on the condition '! mAllowConnect'. Thus the CI type is 1."
531,<android.webkit.WebSettings: boolean getBuiltInZoomControls()>,15,16,<android.webkit.WebSettings: boolean getBuiltInZoomControls()>,<android.webkit.WebSettings: boolean getBuiltInZoomControls()>,0,"{
    return mBuiltInZoomControls;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if the zoom mechanism built into WebView is being used.
 */
","/**
 * Gets whether the zoom mechanisms built into WebView are being used.
 *
 * @return true if the zoom mechanisms built into WebView are being used
 * @see #setBuiltInZoomControls
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the early version, it returns a boolean variable, while the late version throws a new exception (MustOverrideException). Hence, the code change type is 1,2.","In the early version of the implementation, no exceptions were thrown. However, in the late version, a MustOverrideException is thrown. Also, the return value changed from returning a boolean to not returning at all due to the new exception. Thus, the CI types are 1 (because the return statement changed substantially) and 2 (due to the introduction of a new exception throwing sequence)."
533,"<android.widget.RemoteViews: View apply(Context,ViewGroup)>",15,16,"<android.widget.RemoteViews: View apply(Context,ViewGroup)>","<android.widget.RemoteViews: View apply(Context,ViewGroup)>",0,"{
    View result;
    Context c = prepareContext(context);
    LayoutInflater inflater = (LayoutInflater) c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    inflater = inflater.cloneInContext(c);
    inflater.setFilter(this);
    result = inflater.inflate(mLayoutId, parent, false);
    performApply(result, parent);
    return result;
}","{
    return apply(context, parent, DEFAULT_ON_CLICK_HANDLER);
}",1,"/**
 * Inflates the view hierarchy represented by this object and applies
 * all of the actions.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param context Default context to use
 * @param parent Parent that the resulting view hierarchy will be attached to. This method
 * does <strong>not</strong> attach the hierarchy. The caller should do so when appropriate.
 * @return The inflated view hierarchy
 */
","/**
 * Inflates the view hierarchy represented by this object and applies
 * all of the actions.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param context Default context to use
 * @param parent Parent that the resulting view hierarchy will be attached to. This method
 * does <strong>not</strong> attach the hierarchy. The caller should do so when appropriate.
 * @return The inflated view hierarchy
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has completely changed between the early and late version, where the late version relies on another API method (apply(context, parent, DEFAULT_ON_CLICK_HANDLER)). Therefore, the code change types are 4,5.","The complete change of the implementation could potentially cause the method to return different result, even though the return type stays the same. Therefore, the CI type is 1."
534,"<android.view.GLES20Canvas: void drawRect(float,float,float,float,Paint)>",15,16,"<android.view.GLES20Canvas: void drawRect(float,float,float,float,Paint)>","<android.view.GLES20Canvas: void drawRect(float,float,float,float,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    nDrawRect(mRenderer, left, top, right, bottom, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    if (left == right || top == bottom)
        return;
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawRect(mRenderer, left, top, right, bottom, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The early version lacks an 'if' statement found in the late version, which checks if the rectangle's sides are equal. In addition, a 'try-finally' block has been added in the late version to ensure resetting of the modifiers. These constitute changes in control dependencies and exception handling. Another notable change is that the 'setupModifiers' method takes an extra parameter in the late version, with the parameter type of dependent API changing, so the code change type is 1,2,3,5.","Due to the addition of the 'if' statement, the late version of the API may return without executing `nDrawRect` and `nResetModifiers` if the rectangle's sides are identical. The introduction of the 'try-finally' block is also a change in exception handling. Thus, impacting the return type/value and potential exception handling, leading to CI of type 1,2."
535,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getReadableDatabase()>,15,16,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getReadableDatabase()>,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getReadableDatabase()>,0,"{
    if (mDatabase != null) {
        if (!mDatabase.isOpen()) {
            // darn! the user closed the database by calling mDatabase.close()
            mDatabase = null;
        } else {
            // The database is already open for business
            return mDatabase;
        }
    }
    if (mIsInitializing) {
        throw new IllegalStateException(""getReadableDatabase called recursively"");
    }
    try {
        return getWritableDatabase();
    } catch (SQLiteException e) {
        // Can't open a temp database read-only!
        if (mName == null)
            throw e;
        Log.e(TAG, ""Couldn't open "" + mName + "" for writing (will try read-only):"", e);
    }
    SQLiteDatabase db = null;
    try {
        mIsInitializing = true;
        String path = mContext.getDatabasePath(mName).getPath();
        db = SQLiteDatabase.openDatabase(path, mFactory, SQLiteDatabase.OPEN_READONLY, mErrorHandler);
        if (db.getVersion() != mNewVersion) {
            throw new SQLiteException(""Can't upgrade read-only database from version "" + db.getVersion() + "" to "" + mNewVersion + "": "" + path);
        }
        onOpen(db);
        Log.w(TAG, ""Opened "" + mName + "" in read-only mode"");
        mDatabase = db;
        return mDatabase;
    } finally {
        mIsInitializing = false;
        if (db != null && db != mDatabase)
            db.close();
    }
}","{
    synchronized (this) {
        return getDatabaseLocked(false);
    }
}",1,"/**
 * Create and/or open a database.  This will be the same object returned by
 * {@link #getWritableDatabase} unless some problem, such as a full disk,
 * requires the database to be opened read-only.  In that case, a read-only
 * database object will be returned.  If the problem is fixed, a future call
 * to {@link #getWritableDatabase} may succeed, in which case the read-only
 * database object will be closed and the read/write object will be returned
 * in the future.
 *
 * <p class=""caution"">Like {@link #getWritableDatabase}, this method may
 * take a long time to return, so you should not call it from the
 * application main thread, including from
 * {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
 *
 * @throws SQLiteException if the database cannot be opened
 * @return a database object valid until {@link #getWritableDatabase}
 * or {@link #close} is called.
 */
","/**
 * Create and/or open a database.  This will be the same object returned by
 * {@link #getWritableDatabase} unless some problem, such as a full disk,
 * requires the database to be opened read-only.  In that case, a read-only
 * database object will be returned.  If the problem is fixed, a future call
 * to {@link #getWritableDatabase} may succeed, in which case the read-only
 * database object will be closed and the read/write object will be returned
 * in the future.
 *
 * <p class=""caution"">Like {@link #getWritableDatabase}, this method may
 * take a long time to return, so you should not call it from the
 * application main thread, including from
 * {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
 *
 * @throws SQLiteException if the database cannot be opened
 * @return a database object valid until {@link #getWritableDatabase}
 * or {@link #close} is called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 4, 5","1,2","The whole body of this function has been replaced with return getDatabaseLocked(false). The return statement and exception handler in the early version implementation no longer exist in the late version implementation. Moreover, a call to the method getDatabaseLocked() replaces all previous code, so the dependent API changed.","In the late version, it directly calls getDatabaseLocked() function and returns its results. However, in the early version, the function first tries to return an open mDatabase if possible, otherwise to return a new readable database. The function may also throw an SQLiteException. Thus, the behavior of the function has been potentially changed, leading to a possible compatibility issue."
538,<android.webkit.WebSettings: String getDefaultTextEncodingName()>,15,16,<android.webkit.WebSettings: String getDefaultTextEncodingName()>,<android.webkit.WebSettings: String getDefaultTextEncodingName()>,0,"{
    return mDefaultTextEncoding;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the default text encoding name. The default is ""Latin-1"".
 * @return The default text encoding name as a string.
 */
","/**
 * Gets the default text encoding name.
 *
 * @return the default text encoding name as a string
 * @see #setDefaultTextEncodingName
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been replaced by a new throw statement, hence the code change types are both 1 and 2.","This API used to return mDefaultTextEncoding in version 15 but throws an exception in version 16 which makes the return value different and also introduces a new way to throw exception, so there are both kind of CI, type 1 and 2."
539,<android.webkit.WebSettings: void setNeedInitialFocus(boolean)>,15,16,<android.webkit.WebSettings: void setNeedInitialFocus(boolean)>,<android.webkit.WebSettings: void setNeedInitialFocus(boolean)>,0,"{
    if (mNeedInitialFocus != flag) {
        mNeedInitialFocus = flag;
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView whether it needs to set a node to have focus when
 * {@link WebView#requestFocus(int, android.graphics.Rect)} is called.
 *
 * @param flag
 */
","/**
 * Tells the WebView whether it needs to set a node to have focus when
 * {@link WebView#requestFocus(int, android.graphics.Rect)} is called.
 *
 * @param flag whether the WebView needs to set a node
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"In the late version, a new exception handling statement has been introduced (throw new MustOverrideException()), so the code change is type 2.","The newly introduced exception handling statement will make the API potentially throw a different exception in late version, so it is a Compatibility Issue (CI) and it is type 2, which is caused by the potential different exception handlings."
541,<android.widget.TextView: int getImeActionId()>,15,16,<android.widget.TextView: int getImeActionId()>,<android.widget.TextView: int getImeActionId()>,0,"{
    return mInputContentType != null ? mInputContentType.imeActionId : 0;
}","{
    return mEditor != null && mEditor.mInputContentType != null ? mEditor.mInputContentType.imeActionId : 0;
}",1,"/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
","/**
 * Get the IME action ID previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The condition in the return statement has been extended, now involves a check of the variable 'mEditor' in addition to the existing check of 'mInputContentType'. Therefore, the code change can be classified as type 1 (Return statement changed) and type 3 (Control dependency changed).","With the change in the condition for the return statement, the API could potentially return a different value depending on the state of 'mEditor' and 'mInputContentType'. Consequently, it leads to compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
543,<android.webkit.WebView: HitTestResult getHitTestResult()>,15,16,<android.webkit.WebView: HitTestResult getHitTestResult()>,<android.webkit.WebView: HitTestResult getHitTestResult()>,0,"{
    checkThread();
    return hitTestResult(mInitialHitTestResult);
}","{
    checkThread();
    return mProvider.getHitTestResult();
}",1,"/**
 * Return a HitTestResult based on the current cursor node. If a HTML::a tag
 * is found and the anchor has a non-JavaScript url, the HitTestResult type
 * is set to SRC_ANCHOR_TYPE and the url is set in the ""extra"" field. If the
 * anchor does not have a url or if it is a JavaScript url, the type will
 * be UNKNOWN_TYPE and the url has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the url is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a url that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
","/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the ""extra"" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'return hitTestResult(mInitialHitTestResult);' in the early version to 'return mProvider.getHitTestResult();' in the late version. In addition, the dependent method hitTestResult has been replaced by mProvider.getHitTestResult in the return statement, indicating that the dependent API has changed. Therefore, the types of code changes are 1 & 5.","The change in the return statement could potentially lead to the API returning a different value. Therefore, a compatibility issue exists due to the potential difference in returned values, making the type of compatibility issue 1."
544,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",15,16,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>","<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",0,"{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The dependent API mPM.setApplicationEnabledSetting has added a new parameter UserId.myUserId() in the late version. So the code change type is 5.,"Although the dependent API has changed, this does not alter the behavior of the method nor does it potentially cause the method to return different values or throw different exceptions. Therefore, there is no compatibility issue, and the CI type is 0."
545,"<android.app.ContextImpl: Context createPackageContext(String,int)>",15,16,"<android.app.ContextImpl: Context createPackageContext(String,int)>","<android.app.ContextImpl: Context createPackageContext(String,int)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(mMainThread.getSystemContext());
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags);
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources, mBasePackageName);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        final ContextImpl context = new ContextImpl(mMainThread.getSystemContext());
        context.mBasePackageName = mBasePackageName;
        return context;
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags);
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources, mBasePackageName);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"In the condition, where `packageName.equals(""system"")` or `packageName.equals(""android"")`, the return statement is changed, from returning a new `ContextImpl` object created only using `mMainThread.getSystemContext()` to adding another line `context.mBasePackageName = mBasePackageName;` which might modify the behavior of `context` returned. So the change type is 1,4.","Modification in `context.mBasePackageName = mBasePackageName;` could potentially lead to different return types/values defeating the expectation of the previous versions causing a Compatibility Issue. Hence, the CI type is 1."
546,"<android.webkit.CallbackProxy: void onExceededDatabaseQuota(String,String,long,long,long,QuotaUpdater)>",15,16,"<android.webkit.CallbackProxy: void onExceededDatabaseQuota(String,String,long,long,long,QuotaUpdater)>","<android.webkit.CallbackProxy: void onExceededDatabaseQuota(String,String,long,long,long,QuotaUpdater)>",0,"{
    if (mWebChromeClient == null) {
        quotaUpdater.updateQuota(currentQuota);
        return;
    }
    Message exceededQuota = obtainMessage(EXCEEDED_DATABASE_QUOTA);
    HashMap<String, Object> map = new HashMap();
    map.put(""databaseIdentifier"", databaseIdentifier);
    map.put(""url"", url);
    map.put(""currentQuota"", currentQuota);
    map.put(""estimatedSize"", estimatedSize);
    map.put(""totalUsedQuota"", totalUsedQuota);
    map.put(""quotaUpdater"", quotaUpdater);
    exceededQuota.obj = map;
    sendMessage(exceededQuota);
}","{
    if (mWebChromeClient == null) {
        // Native-side logic prevents the quota being updated to a smaller
        // value.
        quotaUpdater.updateQuota(quota);
        return;
    }
    Message exceededQuota = obtainMessage(EXCEEDED_DATABASE_QUOTA);
    HashMap<String, Object> map = new HashMap();
    map.put(""databaseIdentifier"", databaseIdentifier);
    map.put(""url"", url);
    map.put(""quota"", quota);
    map.put(""estimatedDatabaseSize"", estimatedDatabaseSize);
    map.put(""totalQuota"", totalQuota);
    map.put(""quotaUpdater"", quotaUpdater);
    exceededQuota.obj = map;
    sendMessage(exceededQuota);
}",1,"/**
 * Called by WebViewCore to inform the Java side that the current origin
 * has overflowed it's database quota. Called in the WebCore thread so
 * posts a message to the UI thread that will prompt the WebChromeClient
 * for what to do. On return back to C++ side, the WebCore thread will
 * sleep pending a new quota value.
 * @param url The URL that caused the quota overflow.
 * @param databaseIdentifier The identifier of the database that the
 * transaction that caused the overflow was running on.
 * @param currentQuota The current quota the origin is allowed.
 * @param estimatedSize The estimated size of the database.
 * @param totalUsedQuota is the sum of all origins' quota.
 * @param quotaUpdater An instance of a class encapsulating a callback
 * to WebViewCore to run when the decision to allow or deny more
 * quota has been made.
 */
","/**
 * Called by WebViewCore to inform the Java side that the current origin
 * has overflowed it's database quota. Called in the WebCore thread so
 * posts a message to the UI thread that will prompt the WebChromeClient
 * for what to do. On return back to C++ side, the WebCore thread will
 * sleep pending a new quota value.
 * @param url The URL that caused the quota overflow.
 * @param databaseIdentifier The identifier of the database that the
 * transaction that caused the overflow was running on.
 * @param quota The current quota the origin is allowed.
 * @param estimatedDatabaseSize The estimated size of the database.
 * @param totalQuota is the sum of all origins' quota.
 * @param quotaUpdater An instance of a class encapsulating a callback
 * to WebViewCore to run when the decision to allow or deny more
 * quota has been made.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed. The comments in the code and the names of the keys that are put into the ""map"" object have been modified, so the code change type is 4.","Even though the comments and the names of the keys in the map have been modified, these changes are not expected to lead to different API behavior. Therefore, no compatibility issue exists, so the CI type is 0."
548,<android.view.View: void getLocationInWindow(int[])>,15,16,<android.view.View: void getLocationInWindow(int[])>,<android.view.View: void getLocationInWindow(int[])>,0,"{
    // When the view is not attached to a window, this method does not make sense
    if (mAttachInfo == null)
        return;
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of two integers"");
    }
    float[] position = mAttachInfo.mTmpTransformLocation;
    position[0] = position[1] = 0.0f;
    if (!hasIdentityMatrix()) {
        getMatrix().mapPoints(position);
    }
    position[0] += mLeft;
    position[1] += mTop;
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        position[0] -= view.mScrollX;
        position[1] -= view.mScrollY;
        if (!view.hasIdentityMatrix()) {
            view.getMatrix().mapPoints(position);
        }
        position[0] += view.mLeft;
        position[1] += view.mTop;
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        position[1] -= vr.mCurScrollY;
    }
    location[0] = (int) (position[0] + 0.5f);
    location[1] = (int) (position[1] + 0.5f);
}","{
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of two integers"");
    }
    if (mAttachInfo == null) {
        // When the view is not attached to a window, this method does not make sense
        location[0] = location[1] = 0;
        return;
    }
    float[] position = mAttachInfo.mTmpTransformLocation;
    position[0] = position[1] = 0.0f;
    if (!hasIdentityMatrix()) {
        getMatrix().mapPoints(position);
    }
    position[0] += mLeft;
    position[1] += mTop;
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        position[0] -= view.mScrollX;
        position[1] -= view.mScrollY;
        if (!view.hasIdentityMatrix()) {
            view.getMatrix().mapPoints(position);
        }
        position[0] += view.mLeft;
        position[1] += view.mTop;
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        position[1] -= vr.mCurScrollY;
    }
    location[0] = (int) (position[0] + 0.5f);
    location[1] = (int) (position[1] + 0.5f);
}",1,"/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
","/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The order of some statements is rearranged, more specifically, error checking `if (location == null || location.length < 2)` is done earlier now. A return statement was changed, `location[0] = location[1] = 0; return;` is added in late version when `mAttachInfo == null`. This represents code change types 1, 3.",The rearrangement of error checking and the addition of a new return statement `location[0] = location[1] = 0; return;` when `mAttachInfo == null` will potentially lead to the API returning different values. This indicates CI type 1.
550,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,15,16,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,0,"{
    verifyLockOwner();
    try {
        if (mInnerTransactionIsSuccessful) {
            mInnerTransactionIsSuccessful = false;
        } else {
            mTransactionIsSuccessful = false;
        }
        if (mLock.getHoldCount() != 1) {
            return;
        }
        RuntimeException savedException = null;
        if (mTransactionListener != null) {
            try {
                if (mTransactionIsSuccessful) {
                    mTransactionListener.onCommit();
                } else {
                    mTransactionListener.onRollback();
                }
            } catch (RuntimeException e) {
                savedException = e;
                mTransactionIsSuccessful = false;
            }
        }
        if (mTransactionIsSuccessful) {
            execSQL(COMMIT_SQL);
            // but this is the slowest way to run sqlite with in write-ahead logging mode.
            if (this.mConnectionPool != null) {
                execSQL(""PRAGMA wal_checkpoint;"");
                if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
                    Log.i(TAG, ""PRAGMA wal_Checkpoint done"");
                }
            }
            // log the transaction time to the Eventlog.
            if (ENABLE_DB_SAMPLE) {
                logTimeStat(getLastSqlStatement(), mTransStartTime, COMMIT_SQL);
            }
        } else {
            try {
                execSQL(""ROLLBACK;"");
                if (savedException != null) {
                    throw savedException;
                }
            } catch (SQLException e) {
                if (false) {
                    Log.d(TAG, ""exception during rollback, maybe the DB previously "" + ""performed an auto-rollback"");
                }
            }
        }
    } finally {
        mTransactionListener = null;
        unlockForced();
        if (false) {
            Log.v(TAG, ""unlocked "" + Thread.currentThread() + "", holdCount is "" + mLock.getHoldCount());
        }
    }
}","{
    acquireReference();
    try {
        getThreadSession().endTransaction(null);
    } finally {
        releaseReference();
    }
}",1,"/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
","/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5","1,2","The whole implementation of the method has been reshaped, with the new version using getThreadSession().endTransaction(null) instead of the whole logic used in the early version. So the change type is 4,5.","As the complete logic of the method has been rewritten, off-course this will potentially behave differently concerning the returned value and the potential exception handling. Hence, the CI type is 1,2."
551,<android.widget.Toast: void cancel()>,15,16,<android.widget.Toast: void cancel()>,<android.widget.Toast: void cancel()>,0,"{
    mTN.hide();
// TODO this still needs to cancel the inflight notification if any
}","{
    mTN.hide();
    try {
        getService().cancelToast(mContext.getPackageName(), mTN);
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * Close the view if it's showing, or don't show it if it isn't showing yet.
 * You do not normally have to call this.  Normally view will disappear on its own
 * after the appropriate duration.
 */
","/**
 * Close the view if it's showing, or don't show it if it isn't showing yet.
 * You do not normally have to call this.  Normally view will disappear on its own
 * after the appropriate duration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"In the Late implementation, an exception handling statement has been introduced (RemoteException e) and the new servic has been added into the try block which was not there in the early version. Thus, the code change type is 2,4.","As a consequence of the introduced exception handling, the service call getService().cancelToast(mContext.getPackageName(), mTN) now handles potential RemoteException differently, which could change the behavioral outcome of this API, leading to a potential compatibility issue. The CI type is therefore 2."
552,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",15,16,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",0,"{
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    int left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        int left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3","1,2","In the latest version, the method now has a condition check to see if a bitmap is recycled. If the bitmap is recycled, an IllegalArgumentException is thrown, which wasn't the case in the earlier version. Also, a try-finally block has been added. Thus the change type is 2, 3.","This change potentially leads to a compatibility issue because in the earlier version no exception was thrown if a recycled bitmap was passed, whereas in the late version an IllegalArgumentException is thrown. Moreover, the try-finally block may change the behaviour of the function if an exception is thrown within the try-block. Hence the Compatibility Issue type is 1,2."
554,"<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>",15,16,"<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>","<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>",0,"{
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(packageName, flags);
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}","{
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(packageName, flags, UserId.myUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The actual parameter list of the method ""mPM.getApplicationInfo"" has changed. Also, a new return statement is introduced in later version, so the code change type is 1,5.","The change in the method call ""mPM.getApplicationInfo"" could lead to different return values, therefore causing a compatibility issue type 1."
555,<com.android.server.NetworkManagementSocketTagger: int kernelToTag(String)>,15,16,<com.android.server.NetworkManagementSocketTagger: int kernelToTag(String)>,<com.android.server.NetworkManagementSocketTagger: int kernelToTag(String)>,0,"{
    // TODO: migrate to direct integer instead of odd shifting
    return (int) (Long.decode(string) >> 32);
}","{
    int length = string.length();
    if (length > 10) {
        return Long.decode(string.substring(0, length - 8)).intValue();
    } else {
        return 0;
    }
}",1,"/**
 * Convert {@code /proc/} tag format to {@link Integer}. Assumes incoming
 * format like {@code 0x7fffffff00000000}.
 */
","/**
 * Convert {@code /proc/} tag format to {@link Integer}. Assumes incoming
 * format like {@code 0x7fffffff00000000}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The entire implementation logic has changed. Previously, a Long value was simply decoded from `string` and shifted, while in the late version, a substring operation is applied to the `string` first, and then it is decoded. Additionally, a if-else control structure was introduced in the late version. So the change is considered to be of type 1 and 3.","Since the return statement has been modified, it can potentially return a different integer value, leading to the CI type 1."
556,<android.nfc.tech.Ndef: boolean makeReadOnly()>,15,16,<android.nfc.tech.Ndef: boolean makeReadOnly()>,<android.nfc.tech.Ndef: boolean makeReadOnly()>,0,"{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService.isNdef(mTag.getServiceHandle())) {
            int errorCode = tagService.ndefMakeReadOnly(mTag.getServiceHandle());
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    return true;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    return false;
                default:
                    // Should not happen
                    throw new IOException();
            }
        } else {
            throw new IOException(""Tag is not ndef"");
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return false;
    }
}","{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            return false;
        }
        if (tagService.isNdef(mTag.getServiceHandle())) {
            int errorCode = tagService.ndefMakeReadOnly(mTag.getServiceHandle());
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    return true;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    return false;
                default:
                    // Should not happen
                    throw new IOException();
            }
        } else {
            throw new IOException(""Tag is not ndef"");
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return false;
    }
}",1,"/**
 * Make a tag read-only.
 *
 * <p>This sets the CC field to indicate the tag is read-only,
 * and where possible permanently sets the lock bits to prevent
 * any further modification of the memory.
 * <p>This is a one-way process and cannot be reverted!
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return true on success, false if it is not possible to make this tag read-only
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 */
","/**
 * Make a tag read-only.
 *
 * <p>This sets the CC field to indicate the tag is read-only,
 * and where possible permanently sets the lock bits to prevent
 * any further modification of the memory.
 * <p>This is a one-way process and cannot be reverted!
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return true on success, false if it is not possible to make this tag read-only
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"There is an introduction of a new 'if' control dependency statement that checks if 'tagService == null' in the later version, which then returns false. So the code change type is 3 (Control dependency changed).","This new check potentially changes the flow of control in the API. If tagService was null in the early version, it would have thrown an exception but now, in the late version, it just returns false. Therefore, the return of the function could potentially change and as such it falls into the category of CI type 1 (Compatibility Issue caused by potential different return values or types)."
557,"<android.widget.NumberPicker: void scrollBy(int,int)>",15,16,"<android.widget.NumberPicker: void scrollBy(int,int)>","<android.widget.NumberPicker: void scrollBy(int,int)>",0,"{
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {
        return;
    }
    int[] selectorIndices = mSelectorIndices;
    if (!mWrapSelectorWheel && y > 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    if (!mWrapSelectorWheel && y < 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    mCurrentScrollOffset += y;
    while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
        mCurrentScrollOffset -= mSelectorElementHeight;
        decrementSelectorIndices(selectorIndices);
        changeCurrent(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX]);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
    while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
        mCurrentScrollOffset += mSelectorElementHeight;
        incrementSelectorIndices(selectorIndices);
        changeCurrent(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX]);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
}","{
    int[] selectorIndices = mSelectorIndices;
    if (!mWrapSelectorWheel && y > 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    if (!mWrapSelectorWheel && y < 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    mCurrentScrollOffset += y;
    while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
        mCurrentScrollOffset -= mSelectorElementHeight;
        decrementSelectorIndices(selectorIndices);
        setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
    while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
        mCurrentScrollOffset += mSelectorElementHeight;
        incrementSelectorIndices(selectorIndices);
        setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The method call 'changeCurrent' is replaced by 'setValueInternal' with an extra boolean parameter in the while-loops. Also 'if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {return;}' is removed in the late version, so the code change type is 1,4.","This change does not affect the potential behavior of the API, because the internal logic and return behaviour have not changed, thus the CI type is 0."
558,<android.webkit.WebSettings: int getUserAgent()>,15,16,<android.webkit.WebSettings: int getUserAgent()>,<android.webkit.WebSettings: int getUserAgent()>,0,"{
    if (DESKTOP_USERAGENT.equals(mUserAgent)) {
        return 1;
    } else if (IPHONE_USERAGENT.equals(mUserAgent)) {
        return 2;
    } else if (mUseDefaultUserAgent) {
        return 0;
    }
    return -1;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return user-agent as int
 * @return int  0 if the WebView is using an Android user-agent string.
 * 1 if the WebView is using a desktop user-agent string.
 * -1 if the WebView is using user defined user-agent string.
 *
 * @deprecated Please use getUserAgentString instead.
 */
","/**
 * Gets the user-agent as an int.
 *
 * @return 0 if the WebView is using an Android user-agent string,
 * 1 if the WebView is using a desktop user-agent string,
 * -1 if the WebView is using user defined user-agent string
 * @deprecated Please use getUserAgentString instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late version, there's a new introduction of throw statement and all the previous return statements are removed, so the change type is 1,2.","There's a potential behavior change between the two versions, the early version normally works with several different outputs while the late version directly throws an exception which might cause breaking changes to some applications. So, the compatibility issue type is 1,2."
559,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",15,16,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = isColorDrawable ? sPreloadedColorDrawables.get(key) : sPreloadedDrawables.get(key);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, ""Loading framework drawable #"" + Integer.toHexString(id) + "": "" + name + "" at "" + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                if (isColorDrawable) {
                    sPreloadedColorDrawables.put(key, cs);
                } else {
                    sPreloadedDrawables.put(key, cs);
                }
            } else {
                synchronized (mTmpValue) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = isColorDrawable ? sPreloadedColorDrawables.get(key) : sPreloadedDrawables.get(key);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (isColorDrawable) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, ""Loading framework drawable #"" + Integer.toHexString(id) + "": "" + name + "" at "" + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                if (isColorDrawable) {
                    sPreloadedColorDrawables.put(key, cs);
                } else {
                    sPreloadedDrawables.put(key, cs);
                }
            } else {
                synchronized (mTmpValue) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation from the early version to the late version.,There is no compatibility issue as there is no difference between the two versions.
560,"<android.widget.GridLayout: Alignment getAlignment(int,boolean)>",15,16,"<android.widget.GridLayout: Alignment getAlignment(int,boolean)>","<android.widget.GridLayout: Alignment getAlignment(int,boolean)>",0,"{
    int mask = horizontal ? HORIZONTAL_GRAVITY_MASK : VERTICAL_GRAVITY_MASK;
    int shift = horizontal ? AXIS_X_SHIFT : AXIS_Y_SHIFT;
    int flags = (gravity & mask) >> shift;
    switch(flags) {
        case (AXIS_SPECIFIED | AXIS_PULL_BEFORE):
            return LEADING;
        case (AXIS_SPECIFIED | AXIS_PULL_AFTER):
            return TRAILING;
        case (AXIS_SPECIFIED | AXIS_PULL_BEFORE | AXIS_PULL_AFTER):
            return FILL;
        case AXIS_SPECIFIED:
            return CENTER;
        default:
            return UNDEFINED_ALIGNMENT;
    }
}","{
    int mask = horizontal ? HORIZONTAL_GRAVITY_MASK : VERTICAL_GRAVITY_MASK;
    int shift = horizontal ? AXIS_X_SHIFT : AXIS_Y_SHIFT;
    int flags = (gravity & mask) >> shift;
    switch(flags) {
        case (AXIS_SPECIFIED | AXIS_PULL_BEFORE):
            return horizontal ? LEFT : TOP;
        case (AXIS_SPECIFIED | AXIS_PULL_AFTER):
            return horizontal ? RIGHT : BOTTOM;
        case (AXIS_SPECIFIED | AXIS_PULL_BEFORE | AXIS_PULL_AFTER):
            return FILL;
        case AXIS_SPECIFIED:
            return CENTER;
        case (AXIS_SPECIFIED | AXIS_PULL_BEFORE | RELATIVE_LAYOUT_DIRECTION):
            return START;
        case (AXIS_SPECIFIED | AXIS_PULL_AFTER | RELATIVE_LAYOUT_DIRECTION):
            return END;
        default:
            return UNDEFINED_ALIGNMENT;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The change is witnessed in the switch-case construct under the return statements. The early version of the code returns fixed values of LEADING and TRAILING for certain cases, while the late version of the code has been modified to return conditional values depending on the 'horizontal' variable (LEFT : TOP and RIGHT : BOTTOM for certain cases). Also, there have been introduction of new switch cases, so the change types are 1 and 3.","The change in the return statements means that depending on the 'horizontal' variable, the function can now potentially return different values in the later version than it did in the earlier version. So, the Compatibility Issue exists and is caused by the potential different return values, and thus the CI type is 1."
561,<android.webkit.WebSettings: void setSupportZoom(boolean)>,15,16,<android.webkit.WebSettings: void setSupportZoom(boolean)>,<android.webkit.WebSettings: void setSupportZoom(boolean)>,0,"{
    mSupportZoom = support;
    mWebView.updateMultiTouchSupport(mContext);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set whether the WebView supports zoom
 */
","/**
 * Sets whether the WebView should support zooming using its on-screen zoom
 * controls and gestures. The particular zoom mechanisms that should be used
 * can be set with {@link #setBuiltInZoomControls}. This setting does not
 * affect zooming performed using the {@link WebView#zoomIn()} and
 * {@link WebView#zoomOut()} methods. The default is true.
 *
 * @param support whether the WebView should support zoom
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early implementation of the method has been completely replaced by a 'throw' statement in the later version, which means the change type is 1 and 2. ","In the latest version, the method always throws a 'MustOverrideException' and does not execute the prior functionality. Therefore, this alteration changes the return type/value and exception handling, causing the CI type to be 1 and 2."
564,<android.database.BulkCursorProxy: CursorWindow getWindow(int)>,15,16,<android.database.BulkCursorProxy: CursorWindow getWindow(int)>,<android.database.BulkCursorProxy: CursorWindow getWindow(int)>,0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        data.writeInt(startPos);
        mRemote.transact(GET_CURSOR_WINDOW_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        CursorWindow window = null;
        if (reply.readInt() == 1) {
            window = CursorWindow.newFromParcel(reply);
        }
        return window;
    } finally {
        data.recycle();
        reply.recycle();
    }
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        data.writeInt(position);
        mRemote.transact(GET_CURSOR_WINDOW_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        CursorWindow window = null;
        if (reply.readInt() == 1) {
            window = CursorWindow.newFromParcel(reply);
        }
        return window;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The parameter for the data.writeInt() function has been changed from startPos to position, a kind of other statement changes, so the change type is 4.","As the parameter for data.writeInt() method has been replaced, this potentially makes the reply from mRemote.transact() different. Therefore, the 'return window' can be different in two versions, and the CI type is 1."
565,<android.webkit.WebView: void findNext(boolean)>,15,16,<android.webkit.WebView: void findNext(boolean)>,<android.webkit.WebView: void findNext(boolean)>,0,"{
    checkThread();
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    nativeFindNext(forward);
}","{
    checkThread();
    mProvider.findNext(forward);
}",1,"/*
     * Highlight and scroll to the next occurance of String in findAll.
     * Wraps the page infinitely, and scrolls.  Must be called after
     * calling findAll.
     *
     * @param forward Direction to search.
     */
","/**
 * Highlights and scrolls to the next match found by {@link #findAll} or
 * {@link #findAllAsync}, wrapping around page boundaries as necessary.
 * Notifies any registered {@link FindListener}. If neither
 * {@link #findAll} nor {@link #findAllAsync(String)} has been called yet,
 * or if {@link #clearMatches} has been called since the last find
 * operation, this function does nothing.
 *
 * @param forward the direction to search
 * @see #setFindListener
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The control statement 'if (0 == mNativeClass)' and its return statement have been removed. The method call in 'nativeFindNext(forward)' has been replaced by 'mProvider.findNext(forward)'. The dependent APIs 'mNativeClass', 'nativeFindNext(forward)', and 'mProvider.findNext(forward)' are changed. Therefore, the code change type is 1,4,5.","As the return point 'return;' has been removed and the nativeFindNext(forward) is replaced by mProvider.findNext(forward), the later version can possibly return different results when invoked. So, the CI type is 1."
566,<android.webkit.WebSettings: void setStandardFontFamily(String)>,15,16,<android.webkit.WebSettings: void setStandardFontFamily(String)>,<android.webkit.WebSettings: void setStandardFontFamily(String)>,0,"{
    if (font != null && !font.equals(mStandardFontFamily)) {
        mStandardFontFamily = font;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the standard font family name.
 * @param font A font family name.
 */
","/**
 * Sets the standard font family name. The default is ""sans-serif"".
 *
 * @param font a font family name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The early implementation contains a condition and a setting for a variable, while the late implementation just throws an exception. Therefore, this change includes changes in return statements, exception handling statements, and other statements, leading to a code change type of 1,2,4.","In the later version, an exception is now always thrown, changing both the return value and the exception handling of the method. This is a compatibility issue as it changes the expected behavior of the method, leading to CI types of 1,2."
567,"<android.widget.AbsListView.PositionScroller: void startWithOffset(int,int,int)>",15,16,"<android.widget.AbsListView.PositionScroller: void startWithOffset(int,int,int)>","<android.widget.AbsListView.PositionScroller: void startWithOffset(int,int,int)>",0,"{
    stop();
    mTargetPos = position;
    mOffsetFromTop = offset;
    mBoundPos = INVALID_POSITION;
    mLastSeenPos = INVALID_POSITION;
    mMode = MOVE_OFFSET;
    final int firstPos = mFirstPosition;
    final int childCount = getChildCount();
    final int lastPos = firstPos + childCount - 1;
    int viewTravelCount;
    if (position < firstPos) {
        viewTravelCount = firstPos - position;
    } else if (position > lastPos) {
        viewTravelCount = position - lastPos;
    } else {
        // On-screen, just scroll.
        final int targetTop = getChildAt(position - firstPos).getTop();
        smoothScrollBy(targetTop - offset, duration);
        return;
    }
    // Estimate how many screens we should travel
    final float screenTravelCount = (float) viewTravelCount / childCount;
    mScrollDuration = screenTravelCount < 1 ? (int) (screenTravelCount * duration) : (int) (duration / screenTravelCount);
    mLastSeenPos = INVALID_POSITION;
    post(this);
}","{
    stop();
    if (mDataChanged) {
        // Wait until we're back in a stable state to try this.
        final int postOffset = offset;
        mPositionScrollAfterLayout = new Runnable() {

            @Override
            public void run() {
                startWithOffset(position, postOffset, duration);
            }
        };
        return;
    }
    final int childCount = getChildCount();
    if (childCount == 0) {
        // Can't scroll without children.
        return;
    }
    offset += getPaddingTop();
    mTargetPos = Math.max(0, Math.min(getCount() - 1, position));
    mOffsetFromTop = offset;
    mBoundPos = INVALID_POSITION;
    mLastSeenPos = INVALID_POSITION;
    mMode = MOVE_OFFSET;
    final int firstPos = mFirstPosition;
    final int lastPos = firstPos + childCount - 1;
    int viewTravelCount;
    if (mTargetPos < firstPos) {
        viewTravelCount = firstPos - mTargetPos;
    } else if (mTargetPos > lastPos) {
        viewTravelCount = mTargetPos - lastPos;
    } else {
        // On-screen, just scroll.
        final int targetTop = getChildAt(mTargetPos - firstPos).getTop();
        smoothScrollBy(targetTop - offset, duration, true);
        return;
    }
    // Estimate how many screens we should travel
    final float screenTravelCount = (float) viewTravelCount / childCount;
    mScrollDuration = screenTravelCount < 1 ? duration : (int) (duration / screenTravelCount);
    mLastSeenPos = INVALID_POSITION;
    postOnAnimation(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","In the late implementation, several new statements and control dependencies have been introduced such as mDataChanged, mPositionScrollAfterLayout, and modification to smoothScrollBy() method. Therefore, the code change type is 1,3,4.","Due to the introduction of new condition checks and changes, the exception handling and return values can be different in the late version. The CI caused by different return values is obvious due to changes in the return path depending on the conditions. Moreover, the newly introduced return can potentially throw exceptions in different way. Thus the Compatibility Issue type is 1,2."
569,<android.webkit.WebView: boolean zoomIn()>,15,16,<android.webkit.WebView: boolean zoomIn()>,<android.webkit.WebView: boolean zoomIn()>,0,"{
    checkThread();
    return mZoomManager.zoomIn();
}","{
    checkThread();
    return mProvider.zoomIn();
}",1,"/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
","/**
 * Performs zoom in in this WebView.
 *
 * @return true if zoom in succeeds, false if no zoom changes
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mZoomManager.zoomIn() to mProvider.zoomIn(), indicating a change in the dependent API, so the code change type is 1,5.","The change in return statement directly affects the result of the API call, potentially making the API return a different value, hence the CI type is 1."
571,"<android.app.ApplicationPackageManager: ServiceInfo getServiceInfo(ComponentName,int)>",15,16,"<android.app.ApplicationPackageManager: ServiceInfo getServiceInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ServiceInfo getServiceInfo(ComponentName,int)>",0,"{
    try {
        ServiceInfo si = mPM.getServiceInfo(className, flags);
        if (si != null) {
            return si;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ServiceInfo si = mPM.getServiceInfo(className, flags, UserId.myUserId());
        if (si != null) {
            return si;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called on 'mPM' has been changed in the late version, which includes an extra argument: 'UserId.myUserId()'. This change corresponds to a return statement changes (1) and a dependent API change (5).","The change in the dependent API method 'mPM.getServiceInfo()' with an extra parameter 'UserId.myUserId()' may produce different return values, hence a Compatibility Issue of type 1 might exist, which is caused by potential different return values or types."
572,<android.webkit.WebViewDatabase: boolean hasFormData()>,15,16,<android.webkit.WebViewDatabase: boolean hasFormData()>,<android.webkit.WebViewDatabase: boolean hasFormData()>,0,"{
    synchronized (mFormLock) {
        return hasEntries(TABLE_FORMURL_ID);
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Find out if there is form data saved.
 *
 * @return TRUE if there is form data in the database
 */
","/**
 * Gets whether there is any previously-entered form data saved.
 *
 * @return true if there is form data saved
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late version, a new exception statement is introduced; the return statement has been deleted from the early version. So, the code change type is 1,2.","In the late version, the function has changed to always throw an exception whereas the early version would have returned a boolean value. Thus, both returned value and exception handling are different between the two versions, so the CI type is 1,2."
573,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,15,16,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,0,"{
    if (f.mIndex >= 0) {
        return;
    }
    if (mAvailIndices == null || mAvailIndices.size() <= 0) {
        if (mActive == null) {
            mActive = new ArrayList<Fragment>();
        }
        f.setIndex(mActive.size());
        mActive.add(f);
    } else {
        f.setIndex(mAvailIndices.remove(mAvailIndices.size() - 1));
        mActive.set(f.mIndex, f);
    }
}","{
    if (f.mIndex >= 0) {
        return;
    }
    if (mAvailIndices == null || mAvailIndices.size() <= 0) {
        if (mActive == null) {
            mActive = new ArrayList<Fragment>();
        }
        f.setIndex(mActive.size());
        mActive.add(f);
    } else {
        f.setIndex(mAvailIndices.remove(mAvailIndices.size() - 1));
        mActive.set(f.mIndex, f);
    }
    if (DEBUG)
        Log.v(TAG, ""Allocated fragment index "" + f);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new debug log statement has been added at the end of the method, making the code change type 4.","As the added debug statement doesn't affect the behavior of the method, and no return value or exception handling is changed, so no compatibility issue exists here, thus the CI type is 0."
574,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,15,16,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,<android.app.backup.BackupManager: int requestRestore(RestoreObserver)>,0,"{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            session = new RestoreSession(mContext, binder);
            result = session.restorePackage(mContext.getPackageName(), observer);
        } catch (RemoteException e) {
            Log.w(TAG, ""restoreSelf() unable to contact service"");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}","{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""restoreSelf() unable to contact service"");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}",1,"/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */
","/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency changed with an additional 'if (binder != null)' condition, so the code change type is 3.","There is no compatibility issue because the behavior (return statement and exception handling) of the function is still the same. Even if 'binder' is null, the function will return the same initial value of 'result'. Therefore, the CI type is 0."
575,"<android.text.Layout: T[] getParagraphSpans(Spanned,int,int,Class<T>)>",15,16,"<android.text.Layout: T[] getParagraphSpans(Spanned,int,int,Class<T>)>","<android.text.Layout: T[] getParagraphSpans(Spanned,int,int,Class<T>)>",0,"{
    if (start == end && start > 0) {
        return (T[]) ArrayUtils.emptyArray(type);
    }
    return text.getSpans(start, end, type);
}","{
    if (start == end && start > 0) {
        return ArrayUtils.emptyArray(type);
    }
    return text.getSpans(start, end, type);
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the code(diff), it is observed that the return statement with typecasting ((T[]) ArrayUtils.emptyArray(type)) is changed to the return statement without typecasting (ArrayUtils.emptyArray(type)) in the latest version compared to the earlier version. However, both versions of the API meant to do the same thing, which is to return an empty array of the given type when the 'start' equals 'end' and 'start' is greater than '0'. Hence, the type of code change is 4.","After a careful comparison of the two versions of the APIs, we can conclude that there won't be any Compatibility Issues (CIs) between them. Even though the typecasting has been removed for the return statement in the latest version, it won't cause any CIs because the result of the 'emptyArray' function is already an object of the given 'type'. Therefore, the two versions of the APIs will behave the same way for any given inputs. Thus, the type of CI is 0."
576,<android.webkit.WebSettings: PluginState getPluginState()>,15,16,<android.webkit.WebSettings: PluginState getPluginState()>,<android.webkit.WebSettings: PluginState getPluginState()>,0,"{
    return mPluginState;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return the current plugin state.
 * @return A value corresponding to the enum PluginState.
 */
","/**
 * Gets the current plugin state.
 *
 * @return a value corresponding to the enum PluginState
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late version, the implementation of the method has significantly changed from returning a state to throwing an exception. Therefore, the types of the code change are 1 (Return statement changed) and 2 (Exception handling statement changed).","The change causes the API to behave significantly differently. Instead of returning a state, it will now always throw an exception. Thus, this can lead to types 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings) of compatibility issues."
578,"<android.view.ViewGroup: boolean requestSendAccessibilityEvent(View,AccessibilityEvent)>",15,16,"<android.view.ViewGroup: boolean requestSendAccessibilityEvent(View,AccessibilityEvent)>","<android.view.ViewGroup: boolean requestSendAccessibilityEvent(View,AccessibilityEvent)>",0,"{
    ViewParent parent = getParent();
    if (parent == null) {
        return false;
    }
    final boolean propagate = onRequestSendAccessibilityEvent(child, event);
    // noinspection SimplifiableIfStatement
    if (!propagate) {
        return false;
    }
    return parent.requestSendAccessibilityEvent(this, event);
}","{
    ViewParent parent = mParent;
    if (parent == null) {
        return false;
    }
    final boolean propagate = onRequestSendAccessibilityEvent(child, event);
    if (!propagate) {
        return false;
    }
    return parent.requestSendAccessibilityEvent(this, event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,4,1,"The affected part of the Code is the assignment of the variable ""parent"". It has been changed from getParent() to mParent. This does not change control structure, return or exception. Therefore correction type is 4 (Other statement).","The method used to assign the variable 'parent' has changed. If the return of getParent() and mParent are potentially different, the output of the whole method could be different, indicating a possible compatibility issue of a potential different return value (Type 1)."
579,<android.view.KeyCharacterMap: boolean deviceHasKey(int)>,15,16,<android.view.KeyCharacterMap: boolean deviceHasKey(int)>,<android.view.KeyCharacterMap: boolean deviceHasKey(int)>,0,"{
    int[] codeArray = new int[1];
    codeArray[0] = keyCode;
    boolean[] ret = deviceHasKeys(codeArray);
    return ret[0];
}","{
    return InputManager.getInstance().deviceHasKeys(new int[] { keyCode })[0];
}",1,"/**
 * Queries the framework about whether any physical keys exist on the
 * any keyboard attached to the device that are capable of producing the given key code.
 *
 * @param keyCode The key code to query.
 * @return True if at least one attached keyboard supports the specified key code.
 */
","/**
 * Queries the framework about whether any physical keys exist on the
 * any keyboard attached to the device that are capable of producing the given key code.
 *
 * @param keyCode The key code to query.
 * @return True if at least one attached keyboard supports the specified key code.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole method implementation has been replaced from using array codeArray and ret to directly invoking InputManager.getInstance().deviceHasKeys. The dependent API deviceHasKeys called has also changed, so the change types are 1 and 5.","As the replacement of method implementation and the change of dependent API could lead to different return values or types, the CI type is 1."
580,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",15,16,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>","<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final int key = (value.assetCookie << 24) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = mPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            mPreloadedColorStateLists.put(key, csl);
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = mPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            mPreloadedColorStateLists.put(key, csl);
        } else {
            synchronized (mTmpValue) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            sPreloadedColorStateLists.put(key, csl);
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            sPreloadedColorStateLists.put(key, csl);
        } else {
            synchronized (mTmpValue) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The type of variable 'key' has changed from int to long, which results a change in the calculation expression ((value.assetCookie << 24) to (((long) value.assetCookie) << 32)). Also, the names of a couple of variables used in the API changed but their functions kept the same (such as mPreloadedColorStateLists to sPreloadedColorStateLists). Therefore, the types of code changes are 1 and 4.","As the calculation expression for 'key' and the references for the preloaded color state lists have changed, this modification can potentially return a different color state list (or null), and thus the CI type is 1."
581,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",15,16,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>","<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",0,"{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String inputLocale = locale.toString();
            if (subtypeLocale.length() < 2 || inputLocale.length() < 2 || !subtypeLocale.substring(0, 2).equals(inputLocale.substring(0, 2))) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (localeStr.length() >= 2 && tempSubtypeLocale.length() >= 2 && localeStr.startsWith(tempSubtypeLocale)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}","{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String inputLocale = locale.toString();
            if (subtypeLocale.length() < 2 || inputLocale.length() < 2 || !subtypeLocale.substring(0, 2).equals(inputLocale.substring(0, 2))) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (localeStr.length() >= 2 && tempSubtypeLocale.length() >= 2 && localeStr.startsWith(tempSubtypeLocale)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}",1,"/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@param locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@param locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@param locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@param locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
","/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@param locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@param locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@param locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@param locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the 'new SpellCheckerSession' creation, an additional parameter 'subtypeInUse' is added in the late version, while the 'new SpellCheckerSession' return an instance of a new class (SpellCheckerSession), this statement does not affect the return value of the API. So the overall code change type should be 4.","Although the 'new SpellCheckerSession' statement has been changed, this would not result in a potential behaviour change of the current API, because no matter when the current API can finish running successfully, it will always return an instance of 'SpellCheckerSession' class without throwing any different exception. Thus, we conclude that no Compatibility Issue exists in this case (CI type is 0)."
583,<android.webkit.WebSettings: void setCacheMode(int)>,15,16,<android.webkit.WebSettings: void setCacheMode(int)>,<android.webkit.WebSettings: void setCacheMode(int)>,0,"{
    if (mode != mOverrideCacheMode) {
        mOverrideCacheMode = mode;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Override the way the cache is used. The way the cache is used is based
 * on the navigation option. For a normal page load, the cache is checked
 * and content is re-validated as needed. When navigating back, content is
 * not revalidated, instead the content is just pulled from the cache.
 * This function allows the client to override this behavior.
 * @param mode One of the LOAD_ values.
 */
","/**
 * Overrides the way the cache is used. The way the cache is used is based
 * on the navigation option. For a normal page load, the cache is checked
 * and content is re-validated as needed. When navigating back, content is
 * not revalidated, instead the content is just pulled from the cache.
 * This function allows the client to override this behavior.
 *
 * @param mode one of the LOAD_ values
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The new version implementation has introduced a new exception and removed all the previous implementation, so the code change type is 2.","In the late version, the API potentially throws a new exception, which could lead to different behavior when the API is invoked. Therefore, the CI type is 2."
584,<android.webkit.WebSettings: void setUserAgent(int)>,15,16,<android.webkit.WebSettings: void setUserAgent(int)>,<android.webkit.WebSettings: void setUserAgent(int)>,0,"{
    String uaString = null;
    if (ua == 1) {
        if (DESKTOP_USERAGENT.equals(mUserAgent)) {
            // do nothing
            return;
        } else {
            uaString = DESKTOP_USERAGENT;
        }
    } else if (ua == 2) {
        if (IPHONE_USERAGENT.equals(mUserAgent)) {
            // do nothing
            return;
        } else {
            uaString = IPHONE_USERAGENT;
        }
    } else if (ua != 0) {
        // do nothing
        return;
    }
    setUserAgentString(uaString);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView about user-agent string.
 * @param ua 0 if the WebView should use an Android user-agent string,
 * 1 if the WebView should use a desktop user-agent string.
 *
 * @deprecated Please use setUserAgentString instead.
 */
","/**
 * Tells the WebView about user-agent string.
 *
 * @param ua 0 if the WebView should use an Android user-agent string,
 * 1 if the WebView should use a desktop user-agent string
 * @deprecated Please use setUserAgentString instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2","1,2","The original implementation is completely replaced by a new 'throw' statement, which indicates changes in both the return statement and the exception handling, so the change type is 1,2.","The late version throws a new kind of exception which is different from the early version, and the return value of the API could also be different since the 'return' keyword is removed. Thus, the CI type is 1,2."
585,<android.nfc.NdefRecord: NdefRecord createUri(String)>,15,16,<android.nfc.NdefRecord: NdefRecord createUri(String)>,<android.nfc.NdefRecord: NdefRecord createUri(String)>,0,"{
    byte prefix = 0x0;
    for (int i = 1; i < URI_PREFIX_MAP.length; i++) {
        if (uriString.startsWith(URI_PREFIX_MAP[i])) {
            prefix = (byte) i;
            uriString = uriString.substring(URI_PREFIX_MAP[i].length());
            break;
        }
    }
    byte[] uriBytes = uriString.getBytes(Charsets.UTF_8);
    byte[] recordBytes = new byte[uriBytes.length + 1];
    recordBytes[0] = prefix;
    System.arraycopy(uriBytes, 0, recordBytes, 1, uriBytes.length);
    return new NdefRecord(TNF_WELL_KNOWN, RTD_URI, new byte[0], recordBytes);
}","{
    return createUri(Uri.parse(uriString));
}",1,"/**
 * Creates an NDEF record of well known type URI.
 */
","/**
 * Create a new NDEF Record containing a URI.<p>
 * Use this method to encode a URI (or URL) into an NDEF Record.<p>
 * Uses the well known URI type representation: {@link #TNF_WELL_KNOWN}
 * and {@link #RTD_URI}. This is the most efficient encoding
 * of a URI into NDEF.<p>
 * The uriString parameter will be normalized with
 * {@link Uri#normalizeScheme} to set the scheme to lower case to
 * follow Android best practices for intent filtering.
 * However the unchecked exception
 * {@link IllegalArgumentException} may be thrown if the uriString
 * parameter has serious problems, for example if it is empty, so always
 * catch this exception if you are passing user-generated data into this
 * method.<p>
 *
 * Reference specification: NFCForum-TS-RTD_URI_1.0
 *
 * @param uriString string URI to encode.
 * @return an NDEF Record containing the URI
 * @throws IllegalArugmentException if the uriString is empty or invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has significantly changed from more complex operation to a simple return of createUri(Uri.parse(uriString)). Also the dependent API changes from original custom implementation to use Uri.parse() and createUri() APIs. Thus, the type of change is 1,5.","With the new implementation, the return value of the API may potentially change and cause compatibility issues. Hence, the CI type is 1."
587,"<android.text.Layout: void draw(Canvas,Path,Paint,int)>",15,16,"<android.text.Layout: void draw(Canvas,Path,Paint,int)>","<android.text.Layout: void draw(Canvas,Path,Paint,int)>",0,"{
    int dtop, dbottom;
    synchronized (sTempRect) {
        if (!c.getClipBounds(sTempRect)) {
            return;
        }
        dtop = sTempRect.top;
        dbottom = sTempRect.bottom;
    }
    int top = 0;
    int bottom = getLineTop(getLineCount());
    if (dtop > top) {
        top = dtop;
    }
    if (dbottom < bottom) {
        bottom = dbottom;
    }
    int first = getLineForVertical(top);
    int last = getLineForVertical(bottom);
    int previousLineBottom = getLineTop(first);
    int previousLineEnd = getLineStart(first);
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    int width = mWidth;
    boolean spannedText = mSpannedText;
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    int textLength = 0;
    // They are evaluated at each line.
    if (spannedText) {
        Spanned sp = (Spanned) buf;
        textLength = buf.length();
        for (int i = first; i <= last; i++) {
            int start = previousLineEnd;
            int end = getLineStart(i + 1);
            previousLineEnd = end;
            int ltop = previousLineBottom;
            int lbottom = getLineTop(i + 1);
            previousLineBottom = lbottom;
            int lbaseline = lbottom - getLineDescent(i);
            if (start >= spanEnd) {
                // These should be infrequent, so we'll use this so that
                // we don't have to check as often.
                spanEnd = sp.nextSpanTransition(start, textLength, LineBackgroundSpan.class);
                // All LineBackgroundSpans on a line contribute to its
                // background.
                spans = getParagraphSpans(sp, start, end, LineBackgroundSpan.class);
            }
            for (int n = 0; n < spans.length; n++) {
                LineBackgroundSpan back = (LineBackgroundSpan) spans[n];
                back.drawBackground(c, paint, 0, width, ltop, lbaseline, lbottom, buf, start, end, i);
            }
        }
        // reset to their original values
        spanEnd = 0;
        previousLineBottom = getLineTop(first);
        previousLineEnd = getLineStart(first);
        spans = NO_PARA_SPANS;
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0) {
            c.translate(0, cursorOffsetVertical);
        }
        c.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0) {
            c.translate(0, -cursorOffsetVertical);
        }
    }
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // line's descent.
    for (int i = first; i <= last; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (spannedText) {
            Spanned sp = (Spanned) buf;
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == first || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    boolean useFirstLineMargin = isFirstParaLine;
                    if (margin instanceof LeadingMarginSpan2) {
                        int count = ((LeadingMarginSpan2) margin).getLeadingMarginLineCount();
                        int startLine = getLineForOffset(sp.getSpanStart(margin));
                        useFirstLineMargin = i < startLine + count;
                    }
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(c, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(c, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !spannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            c.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(c, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}","{
    final long lineRange = getLineRangeForDraw(canvas);
    int firstLine = TextUtils.unpackRangeStartFromLong(lineRange);
    int lastLine = TextUtils.unpackRangeEndFromLong(lineRange);
    if (lastLine < 0)
        return;
    drawBackground(canvas, highlight, highlightPaint, cursorOffsetVertical, firstLine, lastLine);
    drawText(canvas, firstLine, lastLine);
}",1,"/**
 * Draw this Layout on the specified canvas, with the highlight path drawn
 * between the background and the text.
 *
 * @param c the canvas
 * @param highlight the path of the highlight or cursor; can be null
 * @param highlightPaint the paint for the highlight
 * @param cursorOffsetVertical the amount to temporarily translate the
 * canvas while rendering the highlight
 */
","/**
 * Draw this Layout on the specified canvas, with the highlight path drawn
 * between the background and the text.
 *
 * @param canvas the canvas
 * @param highlight the path of the highlight or cursor; can be null
 * @param highlightPaint the paint for the highlight
 * @param cursorOffsetVertical the amount to temporarily translate the
 * canvas while rendering the highlight
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The whole implementation has changed completely with new methods drawBackground, drawText invoked in the late version and various computations in the early version removed. This implies a change in the return statements, control dependencies and other statements.","As all the statements have been changed, it might lead to different behavior when the late version API is invoked, thus the compatibility issue type is 1."
589,"<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>",15,16,"<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>","<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    if (getBluetoothStateInternal() != BluetoothAdapter.STATE_ON) {
        return;
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.PAN);
    dumpKnownDevices(pw);
    dumpAclConnectedDevices(pw);
    dumpHeadsetService(pw);
    dumpInputDeviceProfile(pw);
    dumpPanProfile(pw);
    dumpApplicationServiceRecords(pw);
    dumpProfileState(pw);
}","{
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (getBluetoothStateInternal() != BluetoothAdapter.STATE_ON) {
        return;
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.PAN);
    dumpKnownDevices(pw);
    dumpAclConnectedDevices(pw);
    dumpHeadsetService(pw);
    dumpInputDeviceProfile(pw);
    dumpPanProfile(pw);
    dumpApplicationServiceRecords(pw);
    dumpProfileState(pw);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The addition of the permission check 'mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);' represents a statement change that is not classified as a return, exception handling, or control dependency change. Therefore, the code change type is 4.","Though a new line of code has been introduced, it doesn't affect the method's return values or the exceptions it might throw. So, it doesn't pose a compatibility issue, and the CI type is 0."
592,<android.webkit.WebSettings: boolean getAllowFileAccess()>,15,16,<android.webkit.WebSettings: boolean getAllowFileAccess()>,<android.webkit.WebSettings: boolean getAllowFileAccess()>,0,"{
    return mAllowFileAccess;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if this WebView supports file access.
 */
","/**
 * Gets whether this WebView supports file access.
 *
 * @see #setAllowFileAccess
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been replaced with an exception throw statement, so the code change type is 1,2.","The change of return statement and the introduction of exception throwing could make the API potentially return a different value or throw an unexpected exception in the late version, so the CI type is 1,2."
593,"<android.webkit.CallbackProxy: BrowserFrame createWindow(boolean,boolean)>",15,16,"<android.webkit.CallbackProxy: BrowserFrame createWindow(boolean,boolean)>","<android.webkit.CallbackProxy: BrowserFrame createWindow(boolean,boolean)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return null;
    }
    WebView.WebViewTransport transport = mWebView.new WebViewTransport();
    final Message msg = obtainMessage(NOTIFY);
    msg.obj = transport;
    synchronized (this) {
        sendMessage(obtainMessage(CREATE_WINDOW, dialog ? 1 : 0, userGesture ? 1 : 0, msg));
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for createWindow"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    WebView w = transport.getWebView();
    if (w != null) {
        WebViewCore core = w.getWebViewCore();
        // initialization in that case and return null.
        if (core != null) {
            core.initializeSubwindow();
            return core.getBrowserFrame();
        }
    }
    return null;
}","{
    // been set.
    if (mWebChromeClient == null) {
        return null;
    }
    WebView.WebViewTransport transport = mWebView.getWebView().new WebViewTransport();
    final Message msg = obtainMessage(NOTIFY);
    msg.obj = transport;
    sendMessageToUiThreadSync(obtainMessage(CREATE_WINDOW, dialog ? 1 : 0, userGesture ? 1 : 0, msg));
    WebViewClassic w = WebViewClassic.fromWebView(transport.getWebView());
    if (w != null) {
        WebViewCore core = w.getWebViewCore();
        // initialization in that case and return null.
        if (core != null) {
            core.initializeSubwindow();
            return core.getBrowserFrame();
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The initial implementation of WebView.WebViewTransport changed from mWebView.new WebViewTransport() to mWebView.getWebView().new WebViewTransport(), indicating a change in how this object is constructed. Additionally, the sendMessage() call was changed to sendMessageToUiThreadSync(), a different method call, which is classified as static API change. Lastly, WebView w has been replaced by WebViewClassic w = WebViewClassic.fromWebView(transport.getWebView()).","Changes in the initialization of WebViewTransport, different method invocations and the class change from WebView to WebViewClassic might potentially cause changes in return values of this method and subsequently affecting the API's overall behaviour, thus causing a compatibility issue (class 1)."
596,"<android.database.sqlite.SQLiteProgram: void bindString(int,String)>",15,16,"<android.database.sqlite.SQLiteProgram: void bindString(int,String)>","<android.database.sqlite.SQLiteProgram: void bindString(int,String)>",0,"{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    bind(Cursor.FIELD_TYPE_STRING, index, value);
}","{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    bind(index, value);
}",1,"/**
 * Bind a String value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
","/**
 * Bind a String value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind, must not be null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The function called inside the bindString() method has been changed from bind(Cursor.FIELD_TYPE_STRING, index, value) to bind(index, value), and due to this the dependent API and return statement has been changed. Therefore, the change type is 1,5.","Since the implementation of bind() method has been modified, this could potentially lead the `bindString()` method to behave differently and return a different value. Hence, the CI is 1."
601,"<android.app.TimePickerDialog: void onClick(DialogInterface,int)>",15,16,"<android.app.TimePickerDialog: void onClick(DialogInterface,int)>","<android.app.TimePickerDialog: void onClick(DialogInterface,int)>",0,"{
    if (mCallback != null) {
        mTimePicker.clearFocus();
        mCallback.onTimeSet(mTimePicker, mTimePicker.getCurrentHour(), mTimePicker.getCurrentMinute());
    }
}","{
    tryNotifyTimeSet();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1, 4, 5",1,"The original code makes callback focus on mTimePicker, while the late version uses a new method 'tryNotifyTimeSet'.  The method 'tryNotifyTimeSet' has been introduced in the late version, and content inside it is unknown. It's also a type of dependent API change as it implies the use of a dependent API method that is potentially altered. Hence, the change types are 1, 4 and 5.","Due to the introduction of new method and the removal of previous handling method, the return variable (implicit) type or value could be potentially different between the two versions in some invocation scenarios. So, there is a Compatibility Issue of type 1."
602,<android.widget.TextView: boolean isTextSelectable()>,15,16,<android.widget.TextView: boolean isTextSelectable()>,<android.widget.TextView: boolean isTextSelectable()>,0,"{
    return mTextIsSelectable;
}","{
    return mEditor == null ? false : mEditor.mTextIsSelectable;
}",1,"/**
 * When a TextView is used to display a useful piece of information to the user (such as a
 * contact's address), it should be made selectable, so that the user can select and copy this
 * content.
 *
 * Use {@link #setTextIsSelectable(boolean)} or the
 * {@link android.R.styleable#TextView_textIsSelectable} XML attribute to make this TextView
 * selectable (text is not selectable by default).
 *
 * Note that this method simply returns the state of this flag. Although this flag has to be set
 * in order to select text in non-editable TextView, the content of an {@link EditText} can
 * always be selected, independently of the value of this flag.
 *
 * @return True if the text displayed in this TextView can be selected by the user.
 *
 * @attr ref android.R.styleable#TextView_textIsSelectable
 */
","/**
 * When a TextView is used to display a useful piece of information to the user (such as a
 * contact's address), it should be made selectable, so that the user can select and copy this
 * content.
 *
 * Use {@link #setTextIsSelectable(boolean)} or the
 * {@link android.R.styleable#TextView_textIsSelectable} XML attribute to make this TextView
 * selectable (text is not selectable by default).
 *
 * Note that this method simply returns the state of this flag. Although this flag has to be set
 * in order to select text in non-editable TextView, the content of an {@link EditText} can
 * always be selected, independently of the value of this flag.
 *
 * @return True if the text displayed in this TextView can be selected by the user.
 *
 * @attr ref android.R.styleable#TextView_textIsSelectable
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mTextIsSelectable' to 'return mEditor == null ? false : mEditor.mTextIsSelectable', so the return values of the API might change. Therefore, the code change type is 1.","The changed return statement may cause the API to return different results under certain conditions, hence the Compatibility Issue type is 1 (due to potential differences in return values or types)."
603,"<android.app.Instrumentation: void checkStartActivityResult(int,Object)>",15,16,"<android.app.Instrumentation: void checkStartActivityResult(int,Object)>","<android.app.Instrumentation: void checkStartActivityResult(int,Object)>",0,"{
    if (res >= IActivityManager.START_SUCCESS) {
        return;
    }
    switch(res) {
        case IActivityManager.START_INTENT_NOT_RESOLVED:
        case IActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException(""Unable to find explicit activity class "" + ((Intent) intent).getComponent().toShortString() + ""; have you declared this activity in your AndroidManifest.xml?"");
            throw new ActivityNotFoundException(""No Activity found to handle "" + intent);
        case IActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException(""Not allowed to start activity "" + intent);
        case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException(""FORWARD_RESULT_FLAG used while also requesting a result"");
        case IActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException(""PendingIntent is not an activity"");
        default:
            throw new AndroidRuntimeException(""Unknown error code "" + res + "" when starting "" + intent);
    }
}","{
    if (res >= ActivityManager.START_SUCCESS) {
        return;
    }
    switch(res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException(""Unable to find explicit activity class "" + ((Intent) intent).getComponent().toShortString() + ""; have you declared this activity in your AndroidManifest.xml?"");
            throw new ActivityNotFoundException(""No Activity found to handle "" + intent);
        case ActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException(""Not allowed to start activity "" + intent);
        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException(""FORWARD_RESULT_FLAG used while also requesting a result"");
        case ActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException(""PendingIntent is not an activity"");
        default:
            throw new AndroidRuntimeException(""Unknown error code "" + res + "" when starting "" + intent);
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The constants from IActivityManager are switched to use ActivityManager. No functionality changes are made, only the object from which the constants are taken has changed. This is classified as Dependent API changed.","No Compatibility issues are detected since although the object from which the constants are taken has changed, the constants themselves and their values remain the same. There are no changes in the flow of the method, the return type, or any exception handling which would cause a different behavior."
605,"<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient,int)>",15,16,"<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient,int)>","<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient,int)>",0,"{
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
    }
    if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || mHTML5VideoView.surfaceTextureDeleted()) {
        // inside the HTML5VideoView.
        if (mHTML5VideoView != null) {
            if (!backFromFullScreenMode) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
            }
            // release the media player to avoid finalize error
            mHTML5VideoView.release();
        }
        mCurrentProxy = proxy;
        mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, false);
        mHTML5VideoView.setVideoURI(url, mCurrentProxy);
        mHTML5VideoView.prepareDataAndDisplayMode(proxy);
    } else if (mCurrentProxy == proxy) {
        // Here, we handle the case when we keep playing with one video
        if (!mHTML5VideoView.isPlaying()) {
            mHTML5VideoView.seekTo(time);
            mHTML5VideoView.start();
        }
    } else if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that
        // its playback ended.
        proxy.dispatchOnEnded();
    }
}","{
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
        // and play the video after prepared.
        if (mHTML5VideoView.isFullScreenMode() && !backFromFullScreenMode && currentVideoLayerId != videoLayerId && mCurrentProxy != proxy) {
            mCurrentProxy = proxy;
            mHTML5VideoView.setStartWhenPrepared(true);
            mHTML5VideoView.setVideoURI(url, proxy);
            mHTML5VideoView.reprepareData(proxy);
            return;
        }
    }
    if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || mHTML5VideoView.surfaceTextureDeleted()) {
        // inside the HTML5VideoView.
        if (mHTML5VideoView != null) {
            if (!backFromFullScreenMode) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
            }
            mHTML5VideoView.reset();
        }
        mCurrentProxy = proxy;
        mHTML5VideoView = new HTML5VideoInline(videoLayerId, time);
        mHTML5VideoView.setVideoURI(url, mCurrentProxy);
        mHTML5VideoView.prepareDataAndDisplayMode(proxy);
    } else if (mCurrentProxy == proxy) {
        // Here, we handle the case when we keep playing with one video
        if (!mHTML5VideoView.isPlaying()) {
            mHTML5VideoView.seekTo(time);
            mHTML5VideoView.start();
        }
    } else if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that
        // its playback ended.
        proxy.dispatchOnEnded();
    }
}",1,"// still the same video by using videoLayerId and treat it differently.
","// still the same video by using videoLayerId and treat it differently.
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are changes to the conditionals/if statements and a return statement is introduced in the late version. Also, there are changes related to the parameters of functions that are part of the dependent API. So, the code change type is 1,3,4.","As there is an introduction of a return statement, this may potentially lead the API to terminate execution and return control earlier than in the early version. This affects the sequence in which the subsequent methods are invoked and can cause a different behavior. Thus, the CI type is 1."
606,<android.app.FragmentState: Fragment instantiate(Activity)>,15,16,<android.app.FragmentState: Fragment instantiate(Activity)>,<android.app.FragmentState: Fragment instantiate(Activity)>,0,"{
    if (mInstance != null) {
        return mInstance;
    }
    if (mArguments != null) {
        mArguments.setClassLoader(activity.getClassLoader());
    }
    mInstance = Fragment.instantiate(activity, mClassName, mArguments);
    if (mSavedFragmentState != null) {
        mSavedFragmentState.setClassLoader(activity.getClassLoader());
        mInstance.mSavedFragmentState = mSavedFragmentState;
    }
    mInstance.setIndex(mIndex);
    mInstance.mFromLayout = mFromLayout;
    mInstance.mRestored = true;
    mInstance.mFragmentId = mFragmentId;
    mInstance.mContainerId = mContainerId;
    mInstance.mTag = mTag;
    mInstance.mRetainInstance = mRetainInstance;
    mInstance.mDetached = mDetached;
    mInstance.mFragmentManager = activity.mFragments;
    return mInstance;
}","{
    if (mInstance != null) {
        return mInstance;
    }
    if (mArguments != null) {
        mArguments.setClassLoader(activity.getClassLoader());
    }
    mInstance = Fragment.instantiate(activity, mClassName, mArguments);
    if (mSavedFragmentState != null) {
        mSavedFragmentState.setClassLoader(activity.getClassLoader());
        mInstance.mSavedFragmentState = mSavedFragmentState;
    }
    mInstance.setIndex(mIndex);
    mInstance.mFromLayout = mFromLayout;
    mInstance.mRestored = true;
    mInstance.mFragmentId = mFragmentId;
    mInstance.mContainerId = mContainerId;
    mInstance.mTag = mTag;
    mInstance.mRetainInstance = mRetainInstance;
    mInstance.mDetached = mDetached;
    mInstance.mFragmentManager = activity.mFragments;
    if (FragmentManagerImpl.DEBUG)
        Log.v(FragmentManagerImpl.TAG, ""Instantiated fragment "" + mInstance);
    return mInstance;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code between the two versions is the addition of an if clause with a print statement, so the change type is 4.","The change i.e., the if clause relates to debugging and log statement and is not likely to lead to any change in the actual working or behavior of the API; hence there is no compatibility issue."
609,<android.app.FragmentManagerImpl: ArrayList<Fragment> retainNonConfig()>,15,16,<android.app.FragmentManagerImpl: ArrayList<Fragment> retainNonConfig()>,<android.app.FragmentManagerImpl: ArrayList<Fragment> retainNonConfig()>,0,"{
    ArrayList<Fragment> fragments = null;
    if (mActive != null) {
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mRetainInstance) {
                if (fragments == null) {
                    fragments = new ArrayList<Fragment>();
                }
                fragments.add(f);
                f.mRetaining = true;
                f.mTargetIndex = f.mTarget != null ? f.mTarget.mIndex : -1;
            }
        }
    }
    return fragments;
}","{
    ArrayList<Fragment> fragments = null;
    if (mActive != null) {
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mRetainInstance) {
                if (fragments == null) {
                    fragments = new ArrayList<Fragment>();
                }
                fragments.add(f);
                f.mRetaining = true;
                f.mTargetIndex = f.mTarget != null ? f.mTarget.mIndex : -1;
                if (DEBUG)
                    Log.v(TAG, ""retainNonConfig: keeping retained "" + f);
            }
        }
    }
    return fragments;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A debug log statement has been added in the late implementation during the 'for' loop, so the code change type is 4.","Adding a debug log doesn't change the behaviour or return value of the API; nor does it cause the API to throw a different exception. Therefore, there is no CI issue."
610,<android.app.FragmentManagerImpl: void performPendingDeferredStart(Fragment)>,15,16,<android.app.FragmentManagerImpl: void performPendingDeferredStart(Fragment)>,<android.app.FragmentManagerImpl: void performPendingDeferredStart(Fragment)>,0,"{
    if (f.mDeferStart) {
        if (mExecutingActions) {
            // Wait until we're done executing our pending transactions
            mHavePendingDeferredStart = true;
            return;
        }
        f.mDeferStart = false;
        moveToState(f, mCurState, 0, 0);
    }
}","{
    if (f.mDeferStart) {
        if (mExecutingActions) {
            // Wait until we're done executing our pending transactions
            mHavePendingDeferredStart = true;
            return;
        }
        f.mDeferStart = false;
        moveToState(f, mCurState, 0, 0, false);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method moveToState() call within the function has changed. Specifically, the function call has gained an extra argument 'false', so the code change type is 1,5.","The moveToState() function is now called with an extra argument, which could alter the functionality and therefore lead to a change in return value under certain conditions. Therefore, the CI type is 1."
612,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,15,16,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    int keyCode = event.getKeyCode();
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER || keyCode == KeyEvent.KEYCODE_ENTER) {
        removeAllCallbacks();
    }
    return super.dispatchKeyEvent(event);
}","{
    final int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            removeAllCallbacks();
            break;
    }
    return super.dispatchKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,The conditional `if` block is changed to a `switch` statement in the late version.,The change of the control flow from `if` to `switch` does not change the potential behaviour of the method since the final output of the method is still returning the result of `super.dispatchKeyEvent(event)`. So there is no compatibility issue.
614,<android.database.sqlite.SQLiteDatabase: String getPath()>,15,16,<android.database.sqlite.SQLiteDatabase: String getPath()>,<android.database.sqlite.SQLiteDatabase: String getPath()>,0,"{
    return mPath;
}","{
    synchronized (mLock) {
        return mConfigurationLocked.path;
    }
}",1,"/**
 * Getter for the path to the database file.
 *
 * @return the path to our database file.
 */
","/**
 * Gets the path to the database file.
 *
 * @return The path to the database file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The API has been altered from returning 'mPath' to returning 'mConfigurationLocked.path' inside a synchronized block which refers to the 'mLock' object. Hence, the change type is 'Other statement changed (4)'.","The transition in the return from 'mPath' to 'mConfigurationLocked.path' suggests a potential change in the return value or type especially if 'mPath' and 'mConfigurationLocked.path' hold different values or types. Consequently, this indicates a 'Compatibility Issue caused by potential different return values or types (1)'."
615,<android.view.View: void setLayoutParams(LayoutParams)>,15,16,<android.view.View: void setLayoutParams(LayoutParams)>,<android.view.View: void setLayoutParams(LayoutParams)>,0,"{
    if (params == null) {
        throw new NullPointerException(""Layout parameters cannot be null"");
    }
    mLayoutParams = params;
    requestLayout();
}","{
    if (params == null) {
        throw new NullPointerException(""Layout parameters cannot be null"");
    }
    mLayoutParams = params;
    if (mParent instanceof ViewGroup) {
        ((ViewGroup) mParent).onSetLayoutParams(this, params);
    }
    requestLayout();
}",1,"/**
 * Set the layout parameters associated with this view. These supply
 * parameters to the <i>parent</i> of this view specifying how it should be
 * arranged. There are many subclasses of ViewGroup.LayoutParams, and these
 * correspond to the different subclasses of ViewGroup that are responsible
 * for arranging their children.
 *
 * @param params The layout parameters for this view, cannot be null
 */
","/**
 * Set the layout parameters associated with this view. These supply
 * parameters to the <i>parent</i> of this view specifying how it should be
 * arranged. There are many subclasses of ViewGroup.LayoutParams, and these
 * correspond to the different subclasses of ViewGroup that are responsible
 * for arranging their children.
 *
 * @param params The layout parameters for this view, cannot be null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change type is 3 and 4 because a new block of code was added within an 'if' conditional statement, which represents a change in the control dependency and also an additional functional statement.","Despite the code change, there is no Compatibility Issue because the additional code does not alter the API's behavior in a way that leads to potential different return values, types or exception handling."
617,"<android.app.ApplicationPackageManager: ResolveInfo resolveActivity(Intent,int)>",15,16,"<android.app.ApplicationPackageManager: ResolveInfo resolveActivity(Intent,int)>","<android.app.ApplicationPackageManager: ResolveInfo resolveActivity(Intent,int)>",0,"{
    try {
        return mPM.resolveIntent(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.resolveIntent(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"Parameter of mPM.resolveIntent function changed due to the addition of UserId.myUserId() aggregate function, which set change types to 1 and 5.","Changes made to the return statement can potentially cause this API to return different values, therefore the CI type is 1."
618,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",15,16,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The method of ActivityManagerNative.getDefault().broadcastIntent() has one additional parameter in the late version. So the type of code change is 5.,"Adding a new parameter to the dependent API does not change the behavior of the current API, so no Compatibility Issue exists. The result is 0."
619,<android.webkit.WebView: boolean pageUp(boolean)>,15,16,<android.webkit.WebView: boolean pageUp(boolean)>,<android.webkit.WebView: boolean pageUp(boolean)>,0,"{
    checkThread();
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (top) {
        // go to the top of the document
        return pinScrollTo(mScrollX, 0, true, 0);
    }
    // Page up
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = -h + PAGE_SCROLL_OVERLAP;
    } else {
        y = -h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}","{
    checkThread();
    return mProvider.pageUp(top);
}",1,"/**
 * Scroll the contents of the view up by half the view size
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView up by half the view size.
 *
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, instead of many conditional statements and calculations, now it simply return the result of 'mProvider.pageUp(top)', and also dependent API has changed, so the change type is 1,5.","The old implementation has multiple control paths with potentially different return values, whereas the new one standardize to one single return statement 'mProvider.pageUp(top)', meaning the potential return value is highly likely different, hence the CI type is 1."
620,<android.webkit.WebHistoryItem: byte[] getFlattenedData()>,15,16,<android.webkit.WebHistoryItem: byte[] getFlattenedData()>,<android.webkit.WebHistoryItem: byte[] getFlattenedData()>,0,"{
    return mFlattenedData;
}","{
    if (mNativeBridge != 0) {
        return nativeGetFlattenedData(mNativeBridge);
    }
    return mFlattenedData;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement and 'if' statement have been added in the late version, so the code change type is 1,3.","Due to the introduction of a new return statement and a new 'if' condition, the returned value could potentially be different in the late version. Thus, the CI type is 1."
621,"<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>",15,16,"<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>","<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    nDrawPoints(mRenderer, pts, offset, count, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawPoints(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The modifier setup has added in the parameters and there's a new try/finally block in the code. Hence, there are changes in control dependency and other statements, marked as 3 and 4 respectively.","Even though these changes occurred, they do not lead to a compatibility issue, since the return value and exceptions thrown remain unchanged. The finalized block ensures that the mRenderer modifiers are reset, hence maintaining the same behavior. Hence the code changes do not cause a compatibility issue, marked as 0."
622,<android.database.sqlite.SQLiteDatabase: boolean isReadOnly()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean isReadOnly()>,<android.database.sqlite.SQLiteDatabase: boolean isReadOnly()>,0,"{
    return (mFlags & OPEN_READ_MASK) == OPEN_READONLY;
}","{
    synchronized (mLock) {
        return isReadOnlyLocked();
    }
}",1,"/**
 * return whether the DB is opened as read only.
 * @return true if DB is opened as read only
 */
","/**
 * Returns true if the database is opened as read only.
 *
 * @return True if database is opened as read only.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statement has changed from a calculation result of bitwise operations to the result of function 'isReadOnlyLocked()', and a new control structure 'synchronized' has been added, thus the code change type is 1,3,4.","Since the return statement has changed and the new return statedment is affected by a new control structure, the returned values of the function could be different, hence causing a Compatibility Issue of type 1."
623,"<android.widget.ListView: void setSelectionFromTop(int,int)>",15,16,"<android.widget.ListView: void setSelectionFromTop(int,int)>","<android.widget.ListView: void setSelectionFromTop(int,int)>",0,"{
    if (mAdapter == null) {
        return;
    }
    if (!isInTouchMode()) {
        position = lookForSelectablePosition(position, true);
        if (position >= 0) {
            setNextSelectedPositionInt(position);
        }
    } else {
        mResurrectToPosition = position;
    }
    if (position >= 0) {
        mLayoutMode = LAYOUT_SPECIFIC;
        mSpecificTop = mListPadding.top + y;
        if (mNeedSync) {
            mSyncPosition = position;
            mSyncRowId = mAdapter.getItemId(position);
        }
        requestLayout();
    }
}","{
    if (mAdapter == null) {
        return;
    }
    if (!isInTouchMode()) {
        position = lookForSelectablePosition(position, true);
        if (position >= 0) {
            setNextSelectedPositionInt(position);
        }
    } else {
        mResurrectToPosition = position;
    }
    if (position >= 0) {
        mLayoutMode = LAYOUT_SPECIFIC;
        mSpecificTop = mListPadding.top + y;
        if (mNeedSync) {
            mSyncPosition = position;
            mSyncRowId = mAdapter.getItemId(position);
        }
        if (mPositionScroller != null) {
            mPositionScroller.stop();
        }
        requestLayout();
    }
}",1,"/**
 * Sets the selected item and positions the selection y pixels from the top edge
 * of the ListView. (If in touch mode, the item will not be selected but it will
 * still be positioned appropriately.)
 *
 * @param position Index (starting at 0) of the data item to be selected.
 * @param y The distance from the top edge of the ListView (plus padding) that the
 * item will be positioned.
 */
","/**
 * Sets the selected item and positions the selection y pixels from the top edge
 * of the ListView. (If in touch mode, the item will not be selected but it will
 * still be positioned appropriately.)
 *
 * @param position Index (starting at 0) of the data item to be selected.
 * @param y The distance from the top edge of the ListView (plus padding) that the
 * item will be positioned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Another statement is added in the late implementation, that is ""if (mPositionScroller != null) { mPositionScroller.stop(); }"". So the code change type is 4.",There is no Compatibility Issue here because adding a 'stop' operation for mPositionScroller does not impact on how this method potentially return a variable or throws the exception. So the compatibility issue type is 0.
624,<android.webkit.WebView: String getOriginalUrl()>,15,16,<android.webkit.WebView: String getOriginalUrl()>,<android.webkit.WebView: String getOriginalUrl()>,0,"{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getOriginalUrl() : null;
}","{
    checkThread();
    return mProvider.getOriginalUrl();
}",1,"/**
 * Get the original url for the current page. This is not always the same
 * as the url passed to WebViewClient.onPageStarted because although the
 * load for that url has begun, the current page may not have changed.
 * Also, there may have been redirects resulting in a different url to that
 * originally requested.
 * @return The url that was originally requested for the current page.
 */
","/**
 * Gets the original URL for the current page. This is not always the same
 * as the URL passed to WebViewClient.onPageStarted because although the
 * load for that URL has begun, the current page may not have changed.
 * Also, there may have been redirects resulting in a different URL to that
 * originally requested.
 *
 * @return the URL that was originally requested for the current page
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The returned value of the method has changed from returning a value from a history item (h.getOriginalUrl()) to returning a value from a provider (mProvider.getOriginalUrl()). Therefore, the change is classified as 'Return statement changed' and 'Other statements changed'.","As the origin of the returned value has changed, this could lead to potentially different return values for the method between the two versions. Therefore, there is a 'Compatibility Issue caused by potential different return values or types'."
627,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,15,16,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled() || !mFlingable) {
        return false;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mLastMotionEventY = mLastDownEventY = event.getY();
            removeAllCallbacks();
            mShowInputControlsAnimator.cancel();
            mDimSelectorWheelAnimator.cancel();
            mBeginEditOnUpEvent = false;
            mAdjustScrollerOnUpEvent = true;
            if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {
                mSelectorWheelPaint.setAlpha(SELECTOR_WHEEL_BRIGHT_ALPHA);
                boolean scrollersFinished = mFlingScroller.isFinished() && mAdjustScroller.isFinished();
                if (!scrollersFinished) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mBeginEditOnUpEvent = scrollersFinished;
                mAdjustScrollerOnUpEvent = true;
                hideInputControls();
                return true;
            }
            if (isEventInVisibleViewHitRect(event, mIncrementButton) || isEventInVisibleViewHitRect(event, mDecrementButton)) {
                return false;
            }
            mAdjustScrollerOnUpEvent = false;
            setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
            hideInputControls();
            return true;
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = event.getY();
            int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
            if (deltaDownY > mTouchSlop) {
                mBeginEditOnUpEvent = false;
                onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
                hideInputControls();
                return true;
            }
            break;
    }
    return false;
}","{
    if (!mHasSelectorWheel || !isEnabled()) {
        return false;
    }
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                removeAllCallbacks();
                mInputText.setVisibility(View.INVISIBLE);
                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
                mLastDownEventTime = event.getEventTime();
                mIngonreMoveEvents = false;
                mShowSoftInputOnTap = false;
                // Handle pressed state before any state change.
                if (mLastDownEventY < mTopSelectionDividerTop) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_DECREMENT);
                    }
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
                        mPressedStateHelper.buttonPressDelayed(PressedStateHelper.BUTTON_INCREMENT);
                    }
                }
                // Make sure we support flinging inside scrollables.
                getParent().requestDisallowInterceptTouchEvent(true);
                if (!mFlingScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                } else if (!mAdjustScroller.isFinished()) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                } else if (mLastDownEventY < mTopSelectionDividerTop) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
                    hideSoftInput();
                    postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                } else {
                    mShowSoftInputOnTap = true;
                    postBeginSoftInputOnLongPressCommand();
                }
                return true;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"Numerous elements in the code has been changed, including control dependency, other statements and return statements. The condition in the first 'if' statement, the content within the 'switch' case, and multiple return statements and their conditions have been altered. Therefore, the change type is 1,3,4.","Due to the massive changes in statements and control dependencies, these modifications might alter the return values of the API and subsequently its behavior. Therefore, the CI type is classified as 1."
628,<android.webkit.WebSettings: String getCursiveFontFamily()>,15,16,<android.webkit.WebSettings: String getCursiveFontFamily()>,<android.webkit.WebSettings: String getCursiveFontFamily()>,0,"{
    return mCursiveFontFamily;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the cursive font family name. The default is ""cursive"".
 * @return The cursive font family name as a string.
 */
","/**
 * Gets the cursive font family name.
 *
 * @return the cursive font family name as a string
 * @see #setCursiveFontFamily
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version of this method returns the value of 'mCursiveFontFamily', but in the late version, it throws a new exception, so this is a change in both return and exception handling statements, therefore the change types are 1,2.","The early version API will return a value while the late version API will throw an exception instead. This change will definitely lead to different behaviors, thus causing a compatibility issue. CI types are 1 (for the return value change) and 2 (for the exception handling change)."
630,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,15,16,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,0,"{
    long earliestFuturePollTime = Long.MAX_VALUE;
    long nextPendingSyncTime = Long.MAX_VALUE;
    // to have the most recent value used.
    try {
        waitUntilReadyToRun();
        mDataConnectionIsConnected = readDataConnectionState();
        mSyncManagerWakeLock.acquire();
        // Always do this first so that we be sure that any periodic syncs that
        // are ready to run have been converted into pending syncs. This allows the
        // logic that considers the next steps to take based on the set of pending syncs
        // to also take into account the periodic syncs.
        earliestFuturePollTime = scheduleReadyPeriodicSyncs();
        switch(msg.what) {
            case SyncHandler.MESSAGE_CANCEL:
                {
                    Pair<Account, String> payload = (Pair<Account, String>) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_CANCEL: "" + payload.first + "", "" + payload.second);
                    }
                    cancelActiveSyncLocked(payload.first, payload.second);
                    nextPendingSyncTime = maybeStartNextSyncLocked();
                    break;
                }
            case SyncHandler.MESSAGE_SYNC_FINISHED:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED"");
                }
                SyncHandlerMessagePayload payload = (SyncHandlerMessagePayload) msg.obj;
                if (!isSyncStillActive(payload.activeSyncContext)) {
                    Log.d(TAG, ""handleSyncHandlerMessage: dropping since the "" + ""sync is no longer active: "" + payload.activeSyncContext);
                    break;
                }
                runSyncFinishedOrCanceledLocked(payload.syncResult, payload.activeSyncContext);
                // since a sync just finished check if it is time to start a new sync
                nextPendingSyncTime = maybeStartNextSyncLocked();
                break;
            case SyncHandler.MESSAGE_SERVICE_CONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: "" + msgData.activeSyncContext);
                    }
                    // check that this isn't an old message
                    if (isSyncStillActive(msgData.activeSyncContext)) {
                        runBoundToSyncAdapter(msgData.activeSyncContext, msgData.syncAdapter);
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
                {
                    final ActiveSyncContext currentSyncContext = ((ServiceConnectionData) msg.obj).activeSyncContext;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: "" + currentSyncContext);
                    }
                    // check that this isn't an old message
                    if (isSyncStillActive(currentSyncContext)) {
                        // outstanding
                        if (currentSyncContext.mSyncAdapter != null) {
                            try {
                                currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
                            } catch (RemoteException e) {
                            // we don't need to retry this in this case
                            }
                        }
                        // pretend that the sync failed with an IOException,
                        // which is a soft error
                        SyncResult syncResult = new SyncResult();
                        syncResult.stats.numIoExceptions++;
                        runSyncFinishedOrCanceledLocked(syncResult, currentSyncContext);
                        // since a sync just finished check if it is time to start a new sync
                        nextPendingSyncTime = maybeStartNextSyncLocked();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SYNC_ALARM:
                {
                    boolean isLoggable = Log.isLoggable(TAG, Log.VERBOSE);
                    if (isLoggable) {
                        Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_ALARM"");
                    }
                    mAlarmScheduleTime = null;
                    try {
                        nextPendingSyncTime = maybeStartNextSyncLocked();
                    } finally {
                        mHandleAlarmWakeLock.release();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_CHECK_ALARMS:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS"");
                }
                nextPendingSyncTime = maybeStartNextSyncLocked();
                break;
        }
    } finally {
        manageSyncNotificationLocked();
        manageSyncAlarmLocked(earliestFuturePollTime, nextPendingSyncTime);
        mSyncTimeTracker.update();
        mSyncManagerWakeLock.release();
    }
}","{
    long earliestFuturePollTime = Long.MAX_VALUE;
    long nextPendingSyncTime = Long.MAX_VALUE;
    // to have the most recent value used.
    try {
        waitUntilReadyToRun();
        mDataConnectionIsConnected = readDataConnectionState();
        mSyncManagerWakeLock.acquire();
        // Always do this first so that we be sure that any periodic syncs that
        // are ready to run have been converted into pending syncs. This allows the
        // logic that considers the next steps to take based on the set of pending syncs
        // to also take into account the periodic syncs.
        earliestFuturePollTime = scheduleReadyPeriodicSyncs();
        switch(msg.what) {
            case SyncHandler.MESSAGE_CANCEL:
                {
                    Pair<Account, String> payload = (Pair<Account, String>) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_CANCEL: "" + payload.first + "", "" + payload.second);
                    }
                    cancelActiveSyncLocked(payload.first, msg.arg1, payload.second);
                    nextPendingSyncTime = maybeStartNextSyncLocked();
                    break;
                }
            case SyncHandler.MESSAGE_SYNC_FINISHED:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED"");
                }
                SyncHandlerMessagePayload payload = (SyncHandlerMessagePayload) msg.obj;
                if (!isSyncStillActive(payload.activeSyncContext)) {
                    Log.d(TAG, ""handleSyncHandlerMessage: dropping since the "" + ""sync is no longer active: "" + payload.activeSyncContext);
                    break;
                }
                runSyncFinishedOrCanceledLocked(payload.syncResult, payload.activeSyncContext);
                // since a sync just finished check if it is time to start a new sync
                nextPendingSyncTime = maybeStartNextSyncLocked();
                break;
            case SyncHandler.MESSAGE_SERVICE_CONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: "" + msgData.activeSyncContext);
                    }
                    // check that this isn't an old message
                    if (isSyncStillActive(msgData.activeSyncContext)) {
                        runBoundToSyncAdapter(msgData.activeSyncContext, msgData.syncAdapter);
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
                {
                    final ActiveSyncContext currentSyncContext = ((ServiceConnectionData) msg.obj).activeSyncContext;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: "" + currentSyncContext);
                    }
                    // check that this isn't an old message
                    if (isSyncStillActive(currentSyncContext)) {
                        // outstanding
                        if (currentSyncContext.mSyncAdapter != null) {
                            try {
                                currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
                            } catch (RemoteException e) {
                            // we don't need to retry this in this case
                            }
                        }
                        // pretend that the sync failed with an IOException,
                        // which is a soft error
                        SyncResult syncResult = new SyncResult();
                        syncResult.stats.numIoExceptions++;
                        runSyncFinishedOrCanceledLocked(syncResult, currentSyncContext);
                        // since a sync just finished check if it is time to start a new sync
                        nextPendingSyncTime = maybeStartNextSyncLocked();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SYNC_ALARM:
                {
                    boolean isLoggable = Log.isLoggable(TAG, Log.VERBOSE);
                    if (isLoggable) {
                        Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_ALARM"");
                    }
                    mAlarmScheduleTime = null;
                    try {
                        nextPendingSyncTime = maybeStartNextSyncLocked();
                    } finally {
                        mHandleAlarmWakeLock.release();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_CHECK_ALARMS:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS"");
                }
                nextPendingSyncTime = maybeStartNextSyncLocked();
                break;
        }
    } finally {
        manageSyncNotificationLocked();
        manageSyncAlarmLocked(earliestFuturePollTime, nextPendingSyncTime);
        mSyncTimeTracker.update();
        mSyncManagerWakeLock.release();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"In the MESSAGE_CANCEL case of the switch statement, the method cancelActiveSyncLocked() has additional parameter in the late version (cancelActiveSyncLocked(payload.first, msg.arg1, payload.second);), so the code change type is 5.","Because a new parameter has been introduced in the late version of cancelActiveSyncLocked method, the behavior of this method might change and cause different side effects or returned results. Therefore, the CI type is 1."
631,<android.database.sqlite.SQLiteQuery: String toString()>,15,16,<android.database.sqlite.SQLiteQuery: String toString()>,<android.database.sqlite.SQLiteQuery: String toString()>,0,"{
    return ""SQLiteQuery: "" + mSql;
}","{
    return ""SQLiteQuery: "" + getSql();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from ""SQLiteQuery: "" + mSql; to ""SQLiteQuery: "" + getSql(); and the method changed from member variable to a method call, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
633,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,15,16,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,0,"{
    try {
        return sGlobals.mService.getWidthHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return 0;
    }
    try {
        return sGlobals.mService.getWidthHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}",1,"/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
","/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency has been changed due to the introduction of an 'if' statement. Additionally, other statements or logging instructions have been added.","The newly introduced ""if"" control construct may lead to different return values. If condition `sGlobals.mService == null` is true, the API now returns 0 immediately without executing further implementation as in the previous version."
634,"<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory)>",15,16,"<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory)>","<android.app.ContextImpl: SQLiteDatabase openOrCreateDatabase(String,int,CursorFactory)>",0,"{
    File f = validateFilePath(name, true);
    SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(f, factory);
    setFilePermissionsFromMode(f.getPath(), mode, 0);
    return db;
}","{
    return openOrCreateDatabase(name, mode, factory, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the API has been entirely rewritten which directly affects the return statement and the calls of other dependent APIs. Thus, the code change type is 1,5.","The function openOrCreateDatabase() is now called with different arguments. This could potentially lead to different return values. Thus, the CI type is 1."
635,<android.webkit.WebView: boolean onHoverEvent(MotionEvent)>,15,16,<android.webkit.WebView: boolean onHoverEvent(MotionEvent)>,<android.webkit.WebView: boolean onHoverEvent(MotionEvent)>,0,"{
    if (mNativeClass == 0) {
        return false;
    }
    WebViewCore.CursorData data = cursorDataNoPosition();
    data.mX = viewToContentX((int) event.getX() + mScrollX);
    data.mY = viewToContentY((int) event.getY() + mScrollY);
    mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
    return true;
}","{
    return mProvider.getViewDelegate().onHoverEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The early version has its own implementation logic while the late_version returns the result of mProvider.getViewDelegate().onHoverEvent(event). The method name and argument have all changed, so the code change type is 1 and 5.","Since the logic and the dependent API have changed, the return result of the method may differ between the two versions, which can cause a compatibility issue. Therefore, the CI type is 1."
637,<android.webkit.WebSettings: int getDefaultFixedFontSize()>,15,16,<android.webkit.WebSettings: int getDefaultFixedFontSize()>,<android.webkit.WebSettings: int getDefaultFixedFontSize()>,0,"{
    return mDefaultFixedFontSize;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the default fixed font size. The default is 16.
 * @return A non-negative integer between 1 and 72.
 */
","/**
 * Gets the default fixed font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setDefaultFixedFontSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement in the early version is replaced by a throw statement. So, the code change type includes 1) the ""Return statement changed"" and 2) the ""Exception handling statement changed"".","The change means the method behavior has changed, potentially returning a new Exception type instead of the expected return value. This would cause compatibility issues, namely: ""Compatibility Issue caused by potential different return values or types"" and ""Compatibility Issue caused by potential different exception handlings"". So, the CI type is 1,2."
638,"<android.webkit.ZoomManager: boolean startZoomAnimation(float,boolean)>",15,16,"<android.webkit.ZoomManager: boolean startZoomAnimation(float,boolean)>","<android.webkit.ZoomManager: boolean startZoomAnimation(float,boolean)>",0,"{
    mInitialZoomOverview = false;
    float oldScale = mActualScale;
    mInitialScrollX = mWebView.getScrollX();
    mInitialScrollY = mWebView.getScrollY();
    // snap to reading level scale if it is close
    if (!exceedsMinScaleIncrement(scale, getReadingLevelScale())) {
        scale = getReadingLevelScale();
    }
    if (mHardwareAccelerated) {
        mInHWAcceleratedZoom = true;
    }
    setZoomScale(scale, reflowText);
    if (oldScale != mActualScale) {
        // use mZoomPickerScale to see zoom preview first
        mZoomStart = SystemClock.uptimeMillis();
        mInvInitialZoomScale = 1.0f / oldScale;
        mInvFinalZoomScale = 1.0f / mActualScale;
        mZoomScale = mActualScale;
        mWebView.onFixedLengthZoomAnimationStart();
        mWebView.invalidate();
        return true;
    } else {
        return false;
    }
}","{
    mInitialZoomOverview = false;
    float oldScale = mActualScale;
    mInitialScrollX = mWebView.getScrollX();
    mInitialScrollY = mWebView.getScrollY();
    // snap to reading level scale if it is close
    if (!exceedsMinScaleIncrement(scale, getReadingLevelScale())) {
        scale = getReadingLevelScale();
    }
    setZoomScale(scale, reflowText);
    if (oldScale != mActualScale) {
        if (mHardwareAccelerated) {
            mInHWAcceleratedZoom = true;
        }
        // use mZoomPickerScale to see zoom preview first
        mZoomStart = SystemClock.uptimeMillis();
        mInvInitialZoomScale = 1.0f / oldScale;
        mInvFinalZoomScale = 1.0f / mActualScale;
        mZoomScale = mActualScale;
        mWebView.onFixedLengthZoomAnimationStart();
        mWebView.invalidate();
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Initiates an animated zoom of the WebView.
 *
 * @return true if the new scale triggered an animation and false otherwise.
 */
","/**
 * Initiates an animated zoom of the WebView.
 *
 * @return true if the new scale triggered an animation and false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The placement of 'if (mHardwareAccelerated)' block has been shifted to inside another 'if' block in the late implementation, thus, the control dependency has been changed. Therefore, the code change type is 3.","As the change in the code doesn't cause potentially different return values/types or potentially different exception handlings, no compatibility issues exist, thus the CI type is 0."
639,<android.content.ContentProviderClient: String getType(Uri)>,15,16,<android.content.ContentProviderClient: String getType(Uri)>,<android.content.ContentProviderClient: String getType(Uri)>,0,"{
    return mContentProvider.getType(url);
}","{
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
","/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"A new exception handling statement has been introduced (throw e), so the code change type is 2.","The newly introduced exception handling could lead to different bahaviour (throws a different exception) when the late version API is invoked, thus the CI type is 2."
640,<android.webkit.WebSettings: void setSansSerifFontFamily(String)>,15,16,<android.webkit.WebSettings: void setSansSerifFontFamily(String)>,<android.webkit.WebSettings: void setSansSerifFontFamily(String)>,0,"{
    if (font != null && !font.equals(mSansSerifFontFamily)) {
        mSansSerifFontFamily = font;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the sans-serif font family name.
 * @param font A font family name.
 */
","/**
 * Sets the sans-serif font family name.
 *
 * @param font a font family name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The whole previous API implementation has been replaced with a single throw statement, so the code change type is 1,2.","After the change, the API will always throw an exception instead of performing its original task, which leads to a completely different behaviour. Hence, the CI type is 1,2."
644,<android.webkit.WebView: int computeHorizontalScrollRange()>,15,16,<android.webkit.WebView: int computeHorizontalScrollRange()>,<android.webkit.WebView: int computeHorizontalScrollRange()>,0,"{
    int range = computeRealHorizontalScrollRange();
    // Adjust reported range if overscrolled to compress the scroll bars
    final int scrollX = mScrollX;
    final int overscrollRight = computeMaxScrollX();
    if (scrollX < 0) {
        range -= scrollX;
    } else if (scrollX > overscrollRight) {
        range += scrollX - overscrollRight;
    }
    return range;
}","{
    return mProvider.getScrollDelegate().computeHorizontalScrollRange();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The complete body of the function changes from a detailed implementation to just calling another function, the code change type is 1,5 because both the return statement and dependent API are altered.","The return statement changed, which could cause potential different return values. Therefore, the compatibility issue type is 1."
647,<android.webkit.CookieManager: void removeAllCookie()>,15,16,<android.webkit.CookieManager: void removeAllCookie()>,<android.webkit.CookieManager: void removeAllCookie()>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        nativeRemoveAllCookie();
        return;
    }
    final Runnable clearCache = new Runnable() {

        public void run() {
            synchronized (CookieManager.this) {
                mCookieMap = new LinkedHashMap<String, ArrayList<Cookie>>(MAX_DOMAIN_COUNT, 0.75f, true);
                CookieSyncManager.getInstance().clearAllCookies();
            }
        }
    };
    new Thread(clearCache).start();
}","{
    throw new MustOverrideException();
}",1,"/**
 * Remove all cookies
 */
","/**
 * Removes all cookies.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The original implementation was completly removed and a new exception handling statement (throw new MustOverrideException()) was introduced, so the code change type is 2,4.","The new implementation is throwing an exception, thus making the function behave differently which is a compatibility issue and the CI type is 2."
650,<android.app.Activity: boolean startNextMatchingActivity(Intent)>,15,16,<android.app.Activity: boolean startNextMatchingActivity(Intent)>,<android.app.Activity: boolean startNextMatchingActivity(Intent)>,0,"{
    if (mParent == null) {
        try {
            intent.setAllowFds(false);
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    return startNextMatchingActivity(intent, null);
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Same as calling {@link #startNextMatchingActivity(Intent, Bundle)} with
 * no options.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the early version has been replaced with a new one call, while the exception statements and condition statements have been removed. This is a change in the return statement and dependent API, so the code change type is 1,5.","The late version is calling another API which potentially changes the behavior from the early version. As the return statement has changed, the API potentially returns a different value, so the CI type is 1."
653,<android.widget.SpellChecker.SpellParser: void parse()>,15,16,<android.widget.SpellChecker.SpellParser: void parse()>,<android.widget.SpellChecker.SpellParser: void parse()>,0,"{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start = editable.getSpanStart(mRange);
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        editable.removeSpan(mRange);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    while (wordStart <= end) {
        if (wordEnd >= start && wordEnd > wordStart) {
            if (wordCount >= MAX_NUMBER_OF_WORDS) {
                scheduleOtherSpellCheck = true;
                break;
            }
            // Previous spans (ended on start / started on end) removed, not valid anymore
            if (wordStart < start && wordEnd > start) {
                removeSpansAt(editable, start, spellCheckSpans);
                removeSpansAt(editable, start, suggestionSpans);
            }
            if (wordStart < end && wordEnd > end) {
                removeSpansAt(editable, end, spellCheckSpans);
                removeSpansAt(editable, end, suggestionSpans);
            }
            // Do not create new boundary spans if they already exist
            boolean createSpellCheckSpan = true;
            if (wordEnd == start) {
                for (int i = 0; i < spellCheckSpans.length; i++) {
                    final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                    if (spanEnd == start) {
                        createSpellCheckSpan = false;
                        break;
                    }
                }
            }
            if (wordStart == end) {
                for (int i = 0; i < spellCheckSpans.length; i++) {
                    final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                    if (spanStart == end) {
                        createSpellCheckSpan = false;
                        break;
                    }
                }
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, wordStart, wordEnd);
            }
            wordCount++;
        }
        // iterate word by word
        int originalWordEnd = wordEnd;
        wordEnd = mWordIterator.following(wordEnd);
        if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
            wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
            mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
            wordEnd = mWordIterator.following(originalWordEnd);
        }
        if (wordEnd == BreakIterator.DONE)
            break;
        wordStart = mWordIterator.getBeginning(wordEnd);
        if (wordStart == BreakIterator.DONE) {
            break;
        }
    }
    if (scheduleOtherSpellCheck) {
        editable.setSpan(mRange, wordStart, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    } else {
        editable.removeSpan(mRange);
    }
    spellCheck();
}","{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start;
    if (mIsSentenceSpellCheckSupported) {
        // TODO: Find the start position of the sentence.
        // Set span with the context
        start = Math.max(0, editable.getSpanStart(mRange) - MIN_SENTENCE_LENGTH);
    } else {
        start = editable.getSpanStart(mRange);
    }
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        if (DBG) {
            Log.i(TAG, ""No more spell check."");
        }
        removeRangeSpan(editable);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    if (mIsSentenceSpellCheckSupported) {
        if (wordIteratorWindowEnd < end) {
            if (DBG) {
                Log.i(TAG, ""schedule other spell check."");
            }
            // Several batches needed on that region. Cut after last previous word
            scheduleOtherSpellCheck = true;
        }
        int spellCheckEnd = mWordIterator.preceding(wordIteratorWindowEnd);
        boolean correct = spellCheckEnd != BreakIterator.DONE;
        if (correct) {
            spellCheckEnd = mWordIterator.getEnd(spellCheckEnd);
            correct = spellCheckEnd != BreakIterator.DONE;
        }
        if (!correct) {
            if (DBG) {
                Log.i(TAG, ""Incorrect range span."");
            }
            removeRangeSpan(editable);
            return;
        }
        do {
            // TODO: Find the start position of the sentence.
            int spellCheckStart = wordStart;
            boolean createSpellCheckSpan = true;
            // Cancel or merge overlapped spell check spans
            for (int i = 0; i < mLength; ++i) {
                final SpellCheckSpan spellCheckSpan = mSpellCheckSpans[i];
                if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
                    continue;
                }
                final int spanStart = editable.getSpanStart(spellCheckSpan);
                final int spanEnd = editable.getSpanEnd(spellCheckSpan);
                if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
                    // No need to merge
                    continue;
                }
                if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
                    // There is a completely overlapped spell check span
                    // skip this span
                    createSpellCheckSpan = false;
                    if (DBG) {
                        Log.i(TAG, ""The range is overrapped. Skip spell check."");
                    }
                    break;
                }
                // This spellCheckSpan is replaced by the one we are creating
                editable.removeSpan(spellCheckSpan);
                spellCheckStart = Math.min(spanStart, spellCheckStart);
                spellCheckEnd = Math.max(spanEnd, spellCheckEnd);
            }
            if (DBG) {
                Log.d(TAG, ""addSpellCheckSpan: "" + "", End = "" + spellCheckEnd + "", Start = "" + spellCheckStart + "", next = "" + scheduleOtherSpellCheck + ""\n"" + editable.subSequence(spellCheckStart, spellCheckEnd));
            }
            // Stop spell checking when there are no characters in the range.
            if (spellCheckEnd < start) {
                break;
            }
            if (spellCheckEnd <= spellCheckStart) {
                Log.w(TAG, ""Trying to spellcheck invalid region, from "" + start + "" to "" + end);
                break;
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, spellCheckStart, spellCheckEnd);
            }
        } while (false);
        wordStart = spellCheckEnd;
    } else {
        while (wordStart <= end) {
            if (wordEnd >= start && wordEnd > wordStart) {
                if (wordCount >= MAX_NUMBER_OF_WORDS) {
                    scheduleOtherSpellCheck = true;
                    break;
                }
                // not valid anymore and must be removed.
                if (wordStart < start && wordEnd > start) {
                    removeSpansAt(editable, start, spellCheckSpans);
                    removeSpansAt(editable, start, suggestionSpans);
                }
                if (wordStart < end && wordEnd > end) {
                    removeSpansAt(editable, end, spellCheckSpans);
                    removeSpansAt(editable, end, suggestionSpans);
                }
                // Do not create new boundary spans if they already exist
                boolean createSpellCheckSpan = true;
                if (wordEnd == start) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                        if (spanEnd == start) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (wordStart == end) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                        if (spanStart == end) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (createSpellCheckSpan) {
                    addSpellCheckSpan(editable, wordStart, wordEnd);
                }
                wordCount++;
            }
            // iterate word by word
            int originalWordEnd = wordEnd;
            wordEnd = mWordIterator.following(wordEnd);
            if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
                wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
                mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
                wordEnd = mWordIterator.following(originalWordEnd);
            }
            if (wordEnd == BreakIterator.DONE)
                break;
            wordStart = mWordIterator.getBeginning(wordEnd);
            if (wordStart == BreakIterator.DONE) {
                break;
            }
        }
    }
    if (scheduleOtherSpellCheck) {
        // Update range span: start new spell check from last wordStart
        setRangeSpan(editable, wordStart, end);
    } else {
        removeRangeSpan(editable);
    }
    spellCheck();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is added a conditional statement (if (mIsSentenceSpellCheckSupported)) and new logical processing including a few added and removed lines of code, so the code change type is 3,4.","The changes in control structure and statements can lead to different behaviors from the API, including possibly returning different variables or values, therefore the Compatibility Issue type is 1."
654,<android.webkit.WebSettings: void setDisplayZoomControls(boolean)>,15,16,<android.webkit.WebSettings: void setDisplayZoomControls(boolean)>,<android.webkit.WebSettings: void setDisplayZoomControls(boolean)>,0,"{
    mDisplayZoomControls = enabled;
    mWebView.updateMultiTouchSupport(mContext);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Sets whether the on screen zoom buttons are used.
 * A combination of built in zoom controls enabled
 * and on screen zoom controls disabled allows for pinch to zoom
 * to work without the on screen controls
 */
","/**
 * Sets whether the WebView should display on-screen zoom controls when
 * using the built-in zoom mechanisms. See {@link #setBuiltInZoomControls}.
 * The default is true.
 *
 * @param enabled whether the WebView should display on-screen zoom controls
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the early version, the method updated the variables while the late version throws an exception, involves two types of change: return statement changed, and exception handling statement changed. Therefore the code change type is 1,2.","The late version of the API throws an exception, which leads to potentially different behaviours (returns a different value or raises a different exception), so the CI type is 1,2."
657,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",15,16,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",0,"{
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, matrix.native_instance, nativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, matrix.native_instance, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3","1,2","An extra condition block 'bitmap.isRecycled()' has been introduced, and an exception statement 'throw new IllegalArgumentException(""Cannot draw recycled bitmaps"")' has been added. Besides, the rest codes are enveloped by a try-finally block. Therefore, the changes are of type 2,3.","If the bitmap is recycled, an IllegalArgumentException would be thrown, which is a new behaviour for this method. Additionally, due to the change of control dependencies, the parameters passed to the method 'nDrawBitmap()' might be different when exception occurs, thus causing the method to return different results. Therefore, both Compatibility Issue types 1 and 2 are present."
658,<android.webkit.WebStorage: WebStorage getInstance()>,15,16,<android.webkit.WebStorage: WebStorage getInstance()>,<android.webkit.WebStorage: WebStorage getInstance()>,0,"{
    if (sWebStorage == null) {
        sWebStorage = new WebStorage();
    }
    return sWebStorage;
}","{
    return WebViewFactory.getProvider().getWebStorage();
}",1,"/**
 * Get the global instance of WebStorage.
 * @return A single instance of WebStorage.
 */
","/**
 * Gets the singleton instance of this class.
 *
 * @return the singleton {@link WebStorage} instance
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement and the dependent API has changed from ""sWebStorage"" and ""new WebStorage()"" in the early version to ""WebViewFactory.getProvider().getWebStorage()"" in the late version. Therefore, the code change type is 1,5.","Due to the changes in the return statement and dependent API, the API potentially returns a different value in the late version. Thus, the CI type is 1."
659,<android.webkit.WebSettings: void setAllowContentAccess(boolean)>,15,16,<android.webkit.WebSettings: void setAllowContentAccess(boolean)>,<android.webkit.WebSettings: void setAllowContentAccess(boolean)>,0,"{
    mAllowContentAccess = allow;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Enable or disable content url access within WebView.  Content url access
 * allows WebView to load content from a content provider installed in the
 * system.  The default is enabled.
 */
","/**
 * Enables or disables content URL access within WebView.  Content URL
 * access allows WebView to load content from a content provider installed
 * in the system. The default is enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The API implementation has been completely changed from allowing the change of content access status to throwing a MustOverrideException, which is an exception handling change, so the code change type is 2.","Given the new throw statement (MustOverrideException), it is clear that in the new version, the API will behave differently, throwing an exception instead of executing the original function. This leads to the conclusion that the Compatibility Issue (CI) type is 2."
662,<android.webkit.WebView: boolean pageDown(boolean)>,15,16,<android.webkit.WebView: boolean pageDown(boolean)>,<android.webkit.WebView: boolean pageDown(boolean)>,0,"{
    checkThread();
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (bottom) {
        return pinScrollTo(mScrollX, computeRealVerticalScrollRange(), true, 0);
    }
    // Page down.
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = h - PAGE_SCROLL_OVERLAP;
    } else {
        y = h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}","{
    checkThread();
    return mProvider.pageDown(bottom);
}",1,"/**
 * Scroll the contents of the view down by half the page size
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView down by half the page size.
 *
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation of the method consists of several statements including conditional checks, native methods, and calculations for the variable 'y'. However, in the late impersonation, the method implementation has been replaced by just one method call 'mProvider.pageDown(bottom);'. So the change types are 1,5.","As the implementation of the method has drastically changed to a new provider method, it is highly possible that it will return different values compared to the early version. So the Compatibility Issue type is 1."
665,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",15,16,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>","<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",0,"{
    try {
        sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
","/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The new version of the API adds a condition check before calling the setDimensionHints method. Thus, the change type is 3 (Control dependency changed).","Even though there's an added conditional check in the late version, it doesn't affect the API's return value or potential exceptions because the method doesn't return a value and the handling of the RemoteException hasn't changed. So there is no Compatibility Issue (CI type: 0)."
667,<android.webkit.WebSettings: void setDefaultFontSize(int)>,15,16,<android.webkit.WebSettings: void setDefaultFontSize(int)>,<android.webkit.WebSettings: void setDefaultFontSize(int)>,0,"{
    size = pin(size);
    if (mDefaultFontSize != size) {
        mDefaultFontSize = size;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the default font size.
 * @param size A non-negative integer between 1 and 72.
 * Any number outside the specified range will be pinned.
 */
","/**
 * Sets the default font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2",2,"The original method implementation has been replaced by a throw statement, so the code change type is 1 and 2.","The API now throws a new exception, which makes the behaviour of the API different in the later version, therefore Compatibility Issue type is specifically 2."
669,"<android.hardware.SensorManager: void unregisterListener(SensorEventListener,Sensor)>",15,16,"<android.hardware.SensorManager: void unregisterListener(SensorEventListener,Sensor)>","<android.hardware.SensorManager: void unregisterListener(SensorEventListener,Sensor)>",0,"{
    unregisterListener((Object) listener, sensor);
}","{
    if (listener == null || sensor == null) {
        return;
    }
    unregisterListenerImpl(listener, sensor);
}",1,"/**
 * Unregisters a listener for the sensors with which it is registered.
 *
 * @param listener
 * a SensorEventListener object
 *
 * @param sensor
 * the sensor to unregister from
 *
 * @see #unregisterListener(SensorEventListener)
 * @see #registerListener(SensorEventListener, Sensor, int)
 */
","/**
 * Unregisters a listener for the sensors with which it is registered.
 *
 * @param listener
 * a SensorEventListener object
 *
 * @param sensor
 * the sensor to unregister from
 *
 * @see #unregisterListener(SensorEventListener)
 * @see #registerListener(SensorEventListener, Sensor, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are new condition statements added in the late version and the original unregisterListener changed to unregisterListenerImpl. So, code change type is 3,4.","No compatibility issue(CI) was detected. The changes made are improvements to the code and does not have the potential to change the behavior of the API. There may be a difference in behavior when a null value is provided in the late version, but it was incorrect usage in the earlier version and does not imply a compatibility issue."
670,<android.inputmethodservice.InputMethodService: void onConfigurationChanged(Configuration)>,15,16,<android.inputmethodservice.InputMethodService: void onConfigurationChanged(Configuration)>,<android.inputmethodservice.InputMethodService: void onConfigurationChanged(Configuration)>,0,"{
    super.onConfigurationChanged(newConfig);
    boolean visible = mWindowVisible;
    int showFlags = mShowInputFlags;
    boolean showingInput = mShowInputRequested;
    CompletionInfo[] completions = mCurCompletions;
    initViews();
    mInputViewStarted = false;
    mCandidatesViewStarted = false;
    if (mInputStarted) {
        doStartInput(getCurrentInputConnection(), getCurrentInputEditorInfo(), true);
    }
    if (visible) {
        if (showingInput) {
            // If we were last showing the soft keyboard, try to do so again.
            if (onShowInputRequested(showFlags, true)) {
                showWindow(true);
                if (completions != null) {
                    mCurCompletions = completions;
                    onDisplayCompletions(completions);
                }
            } else {
                hideWindow();
            }
        } else if (mCandidatesVisibility == View.VISIBLE) {
            // If the candidates are currently visible, make sure the
            // window is shown for them.
            showWindow(false);
        } else {
            // Otherwise hide the window.
            hideWindow();
        }
        // If user uses hard keyboard, IME button should always be shown.
        boolean showing = onEvaluateInputViewShown();
        mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    }
}","{
    super.onConfigurationChanged(newConfig);
    boolean visible = mWindowVisible;
    int showFlags = mShowInputFlags;
    boolean showingInput = mShowInputRequested;
    CompletionInfo[] completions = mCurCompletions;
    initViews();
    mInputViewStarted = false;
    mCandidatesViewStarted = false;
    if (mInputStarted) {
        doStartInput(getCurrentInputConnection(), getCurrentInputEditorInfo(), true);
    }
    if (visible) {
        if (showingInput) {
            // If we were last showing the soft keyboard, try to do so again.
            if (onShowInputRequested(showFlags, true)) {
                showWindow(true);
                if (completions != null) {
                    mCurCompletions = completions;
                    onDisplayCompletions(completions);
                }
            } else {
                doHideWindow();
            }
        } else if (mCandidatesVisibility == View.VISIBLE) {
            // If the candidates are currently visible, make sure the
            // window is shown for them.
            showWindow(false);
        } else {
            // Otherwise hide the window.
            doHideWindow();
        }
        // If user uses hard keyboard, IME button should always be shown.
        boolean showing = onEvaluateInputViewShown();
        mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    }
}",1,"/**
 * Take care of handling configuration changes.  Subclasses of
 * InputMethodService generally don't need to deal directly with
 * this on their own; the standard implementation here takes care of
 * regenerating the input method UI as a result of the configuration
 * change, so you can rely on your {@link #onCreateInputView} and
 * other methods being called as appropriate due to a configuration change.
 *
 * <p>When a configuration change does happen,
 * {@link #onInitializeInterface()} is guaranteed to be called the next
 * time prior to any of the other input or UI creation callbacks.  The
 * following will be called immediately depending if appropriate for current
 * state: {@link #onStartInput} if input is active, and
 * {@link #onCreateInputView} and {@link #onStartInputView} and related
 * appropriate functions if the UI is displayed.
 */
","/**
 * Take care of handling configuration changes.  Subclasses of
 * InputMethodService generally don't need to deal directly with
 * this on their own; the standard implementation here takes care of
 * regenerating the input method UI as a result of the configuration
 * change, so you can rely on your {@link #onCreateInputView} and
 * other methods being called as appropriate due to a configuration change.
 *
 * <p>When a configuration change does happen,
 * {@link #onInitializeInterface()} is guaranteed to be called the next
 * time prior to any of the other input or UI creation callbacks.  The
 * following will be called immediately depending if appropriate for current
 * state: {@link #onStartInput} if input is active, and
 * {@link #onCreateInputView} and {@link #onStartInputView} and related
 * appropriate functions if the UI is displayed.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method calls from hideWindow() has been altered to doHideWindow(). This is an example of dependent API changing alongside another statement changing, resulting in code change types 4 and 5.","There is no compatibility issue encountered in this change as the new method, doHideWindow(), is likely to perform the same functionality as the previous method, hideWindow(). Therefore, the behaviours when invoking the method wouldn't change and no compatibility issue exists. Thus, the CI type is 0."
671,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,15,16,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,0,"{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = mProperty.get(target);
            for (Keyframe kf : mKeyframeSet.mKeyframes) {
                if (!kf.hasValue()) {
                    kf.setValue(mProperty.get(target));
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.e(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    for (Keyframe kf : mKeyframeSet.mKeyframes) {
        if (!kf.hasValue()) {
            if (mGetter == null) {
                setupGetter(targetClass);
            }
            try {
                kf.setValue(mGetter.invoke(target));
            } catch (InvocationTargetException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            } catch (IllegalAccessException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            }
        }
    }
}","{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = mProperty.get(target);
            for (Keyframe kf : mKeyframeSet.mKeyframes) {
                if (!kf.hasValue()) {
                    kf.setValue(mProperty.get(target));
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    for (Keyframe kf : mKeyframeSet.mKeyframes) {
        if (!kf.hasValue()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                kf.setValue(mGetter.invoke(target));
            } catch (InvocationTargetException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            } catch (IllegalAccessException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            }
        }
    }
}",1,"/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
","/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 1",1,"It's checked for mGetter being null after the setupGetter(targetClass) call with an added return statement, leading to that part of the loop being skipped over which is a control dependency change, and the change of the return statement type is 3 and 1.","The change in the return statements due to the addition of a new return statement after the check of mGetter being null could possibly cause the method to exit before all mKeyframeSet.mKeyframes have been set with a value thus changing the behaviour of the method, leading to a Compatibility Issue of type 1."
673,<android.animation.AnimatorSet: AnimatorSet setDuration(long)>,15,16,<android.animation.AnimatorSet: AnimatorSet setDuration(long)>,<android.animation.AnimatorSet: AnimatorSet setDuration(long)>,0,"{
    if (duration < 0) {
        throw new IllegalArgumentException(""duration must be a value of zero or greater"");
    }
    for (Node node : mNodes) {
        // TODO: don't set the duration of the timing-only nodes created by AnimatorSet to
        // insert ""play-after"" delays
        node.animation.setDuration(duration);
    }
    mDuration = duration;
    return this;
}","{
    if (duration < 0) {
        throw new IllegalArgumentException(""duration must be a value of zero or greater"");
    }
    // Just record the value for now - it will be used later when the AnimatorSet starts
    mDuration = duration;
    return this;
}",1,"/**
 * Sets the length of each of the current child animations of this AnimatorSet. By default,
 * each child animation will use its own duration. If the duration is set on the AnimatorSet,
 * then each child animation inherits this duration.
 *
 * @param duration The length of the animation, in milliseconds, of each of the child
 * animations of this AnimatorSet.
 */
","/**
 * Sets the length of each of the current child animations of this AnimatorSet. By default,
 * each child animation will use its own duration. If the duration is set on the AnimatorSet,
 * then each child animation inherits this duration.
 *
 * @param duration The length of the animation, in milliseconds, of each of the child
 * animations of this AnimatorSet.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The code inside the 'for' loop has been deleted in the late version, and this change doesn't belong to the return statement, exception handling statement, and control dependency. Thus, the code change type is 4.","The 'setDuration' function of 'node.animation' that was present in the 'for' loop of the initial version has been deleted in the later version. This means that the duration is not being set for 'node.animation' in the later version anymore, which potentially changes the behaviour of the API. This change could lead to the API returning a different value, which means there is a Compatibility Issue. Thus, the CI type is 1."
674,<android.webkit.WebView: boolean onGenericMotionEvent(MotionEvent)>,15,16,<android.webkit.WebView: boolean onGenericMotionEvent(MotionEvent)>,<android.webkit.WebView: boolean onGenericMotionEvent(MotionEvent)>,0,"{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                {
                    final float vscroll;
                    final float hscroll;
                    if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
                        vscroll = 0;
                        hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                    } else {
                        vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                    }
                    if (hscroll != 0 || vscroll != 0) {
                        final int vdelta = (int) (vscroll * getVerticalScrollFactor());
                        final int hdelta = (int) (hscroll * getHorizontalScrollFactor());
                        if (pinScrollBy(hdelta, vdelta, false, 0)) {
                            return true;
                        }
                    }
                }
        }
    }
    return super.onGenericMotionEvent(event);
}","{
    return mProvider.getViewDelegate().onGenericMotionEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The whole method implementation has changed from a detailed step-by-step implementation to a single line API invocation `mProvider.getViewDelegate().onGenericMotionEvent(event)`. The implementation after 'return' has changed, so the code change type is 1. In addition, the dependent API (`mProvider.getViewDelegate().onGenericMotionEvent(event)`) changed, making the code change type 5 as well.","The functionality of the API potentially changed significantly due to the implementation change, making it potentially able to return different values and therefore resulting in CI type 1."
675,<android.net.Uri: String getQueryParameter(String)>,15,16,<android.net.Uri: String getQueryParameter(String)>,<android.net.Uri: String getQueryParameter(String)>,0,"{
    if (isOpaque()) {
        throw new UnsupportedOperationException(NOT_HIERARCHICAL);
    }
    if (key == null) {
        throw new NullPointerException(""key"");
    }
    final String query = getEncodedQuery();
    if (query == null) {
        return null;
    }
    final String encodedKey = encode(key, null);
    final int length = query.length();
    int start = 0;
    do {
        int nextAmpersand = query.indexOf('&', start);
        int end = nextAmpersand != -1 ? nextAmpersand : length;
        int separator = query.indexOf('=', start);
        if (separator > end || separator == -1) {
            separator = end;
        }
        if (separator - start == encodedKey.length() && query.regionMatches(start, encodedKey, 0, encodedKey.length())) {
            if (separator == end) {
                return """";
            } else {
                return decode(query.substring(separator + 1, end));
            }
        }
        // Move start to end of name.
        if (nextAmpersand != -1) {
            start = nextAmpersand + 1;
        } else {
            break;
        }
    } while (true);
    return null;
}","{
    if (isOpaque()) {
        throw new UnsupportedOperationException(NOT_HIERARCHICAL);
    }
    if (key == null) {
        throw new NullPointerException(""key"");
    }
    final String query = getEncodedQuery();
    if (query == null) {
        return null;
    }
    final String encodedKey = encode(key, null);
    final int length = query.length();
    int start = 0;
    do {
        int nextAmpersand = query.indexOf('&', start);
        int end = nextAmpersand != -1 ? nextAmpersand : length;
        int separator = query.indexOf('=', start);
        if (separator > end || separator == -1) {
            separator = end;
        }
        if (separator - start == encodedKey.length() && query.regionMatches(start, encodedKey, 0, encodedKey.length())) {
            if (separator == end) {
                return """";
            } else {
                String encodedValue = query.substring(separator + 1, end);
                return UriCodec.decode(encodedValue, true, Charsets.UTF_8, false);
            }
        }
        // Move start to end of name.
        if (nextAmpersand != -1) {
            start = nextAmpersand + 1;
        } else {
            break;
        }
    } while (true);
    return null;
}",1,"/**
 * Searches the query string for the first value with the given key.
 *
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
","/**
 * Searches the query string for the first value with the given key.
 *
 * <p><strong>Warning:</strong> Prior to Ice Cream Sandwich, this decoded
 * the '+' character as '+' rather than ' '.
 *
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from decode(query.substring(separator + 1, end)) to UriCodec.decode(encodedValue, true, Charsets.UTF_8, false), and the method name 'decode' has changed which is a dependent API. So the change type is 1,5.","Due to the change in the 'decode' method, the returned value from getQueryParameter can potentially be different causing it to have a Compatibility Issue type of 1."
676,<android.os.AsyncTask: boolean isCancelled()>,15,16,<android.os.AsyncTask: boolean isCancelled()>,<android.os.AsyncTask: boolean isCancelled()>,0,"{
    return mFuture.isCancelled();
}","{
    return mCancelled.get();
}",1,"/**
 * Returns <tt>true</tt> if this task was cancelled before it completed
 * normally. If you are calling {@link #cancel(boolean)} on the task,
 * the value returned by this method should be checked periodically from
 * {@link #doInBackground(Object[])} to end the task as soon as possible.
 *
 * @return <tt>true</tt> if task was cancelled before it completed
 *
 * @see #cancel(boolean)
 */
","/**
 * Returns <tt>true</tt> if this task was cancelled before it completed
 * normally. If you are calling {@link #cancel(boolean)} on the task,
 * the value returned by this method should be checked periodically from
 * {@link #doInBackground(Object[])} to end the task as soon as possible.
 *
 * @return <tt>true</tt> if task was cancelled before it completed
 *
 * @see #cancel(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mFuture.isCancelled() to mCancelled.get() and the dependent API has undergone changes, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
677,<android.nfc.Tag: Tag rediscover()>,15,16,<android.nfc.Tag: Tag rediscover()>,<android.nfc.Tag: Tag rediscover()>,0,"{
    if (getConnectedTechnology() != -1) {
        throw new IllegalStateException(""Close connection to the technology first!"");
    }
    try {
        Tag newTag = mTagService.rediscover(getServiceHandle());
        if (newTag != null) {
            return newTag;
        } else {
            throw new IOException(""Failed to rediscover tag"");
        }
    } catch (RemoteException e) {
        throw new IOException(""NFC service dead"");
    }
}","{
    if (getConnectedTechnology() != -1) {
        throw new IllegalStateException(""Close connection to the technology first!"");
    }
    if (mTagService == null) {
        throw new IOException(""Mock tags don't support this operation."");
    }
    try {
        Tag newTag = mTagService.rediscover(getServiceHandle());
        if (newTag != null) {
            return newTag;
        } else {
            throw new IOException(""Failed to rediscover tag"");
        }
    } catch (RemoteException e) {
        throw new IOException(""NFC service dead"");
    }
}",1,"// implementation.
","// implementation.
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","A new exception statement (throw new IOException(""Mock tags don't support this operation"")) is introduced and also the control flow has changed because of the introduction of a new 'if' condition, it matches to the code change types 2,3.","The introduced new exception throwing statement causes this API to follow a new path which is not in the previous version, hence it may lead to a different return or may throw an exception which was not expected in the previous version. This leads to the CI types 1,2."
678,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,15,16,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,0,"{
    final boolean log = mOrientationListener.mLogEnabled;
    // The vector given in the SensorEvent points straight up (towards the sky) under ideal
    // conditions (the phone is not accelerating).  I'll call this up vector elsewhere.
    float x = event.values[ACCELEROMETER_DATA_X];
    float y = event.values[ACCELEROMETER_DATA_Y];
    float z = event.values[ACCELEROMETER_DATA_Z];
    if (log) {
        Slog.v(TAG, ""Raw acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z);
    }
    // Apply a low-pass filter to the acceleration up vector in cartesian space.
    // Reset the orientation listener state if the samples are too far apart in time
    // or when we see values of (0, 0, 0) which indicates that we polled the
    // accelerometer too soon after turning it on and we don't have any data yet.
    final long now = event.timestamp;
    final float timeDeltaMS = (now - mLastTimestamp) * 0.000001f;
    boolean skipSample;
    if (timeDeltaMS <= 0 || timeDeltaMS > MAX_FILTER_DELTA_TIME_MS || (x == 0 && y == 0 && z == 0)) {
        if (log) {
            Slog.v(TAG, ""Resetting orientation listener."");
        }
        clearProposal();
        skipSample = true;
    } else {
        final float alpha = timeDeltaMS / (FILTER_TIME_CONSTANT_MS + timeDeltaMS);
        x = alpha * (x - mLastFilteredX) + mLastFilteredX;
        y = alpha * (y - mLastFilteredY) + mLastFilteredY;
        z = alpha * (z - mLastFilteredZ) + mLastFilteredZ;
        if (log) {
            Slog.v(TAG, ""Filtered acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z);
        }
        skipSample = false;
    }
    mLastTimestamp = now;
    mLastFilteredX = x;
    mLastFilteredY = y;
    mLastFilteredZ = z;
    final int oldProposedRotation = getProposedRotation();
    if (!skipSample) {
        // Calculate the magnitude of the acceleration vector.
        final float magnitude = (float) Math.sqrt(x * x + y * y + z * z);
        if (magnitude < MIN_ACCELERATION_MAGNITUDE || magnitude > MAX_ACCELERATION_MAGNITUDE) {
            if (log) {
                Slog.v(TAG, ""Ignoring sensor data, magnitude out of range: "" + ""magnitude="" + magnitude);
            }
            clearProposal();
        } else {
            // Calculate the tilt angle.
            // This is the angle between the up vector and the x-y plane (the plane of
            // the screen) in a range of [-90, 90] degrees.
            // -90 degrees: screen horizontal and facing the ground (overhead)
            // 0 degrees: screen vertical
            // 90 degrees: screen horizontal and facing the sky (on table)
            final int tiltAngle = (int) Math.round(Math.asin(z / magnitude) * RADIANS_TO_DEGREES);
            // the orientation angle of the screen.
            if (Math.abs(tiltAngle) > MAX_TILT) {
                if (log) {
                    Slog.v(TAG, ""Ignoring sensor data, tilt angle too high: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle);
                }
                clearProposal();
            } else {
                // Calculate the orientation angle.
                // This is the angle between the x-y projection of the up vector onto
                // the +y-axis, increasing clockwise in a range of [0, 360] degrees.
                int orientationAngle = (int) Math.round(-Math.atan2(-x, y) * RADIANS_TO_DEGREES);
                if (orientationAngle < 0) {
                    // atan2 returns [-180, 180]; normalize to [0, 360]
                    orientationAngle += 360;
                }
                // Find the nearest rotation.
                int nearestRotation = (orientationAngle + 45) / 90;
                if (nearestRotation == 4) {
                    nearestRotation = 0;
                }
                // angle, tilt and magnitude of the proposed orientation.
                if (!isTiltAngleAcceptable(nearestRotation, tiltAngle) || !isOrientationAngleAcceptable(nearestRotation, orientationAngle)) {
                    if (log) {
                        Slog.v(TAG, ""Ignoring sensor data, no proposal: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle);
                    }
                    clearProposal();
                } else {
                    if (log) {
                        Slog.v(TAG, ""Proposal: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle + "", proposalRotation="" + mProposalRotation);
                    }
                    updateProposal(nearestRotation, now / 1000000L, magnitude, tiltAngle, orientationAngle);
                }
            }
        }
    }
    // Write final statistics about where we are in the orientation detection process.
    final int proposedRotation = getProposedRotation();
    if (log) {
        final float proposalConfidence = Math.min(mProposalAgeMS * 1.0f / SETTLE_TIME_MS, 1.0f);
        Slog.v(TAG, ""Result: currentRotation="" + mOrientationListener.mCurrentRotation + "", proposedRotation="" + proposedRotation + "", timeDeltaMS="" + timeDeltaMS + "", proposalRotation="" + mProposalRotation + "", proposalAgeMS="" + mProposalAgeMS + "", proposalConfidence="" + proposalConfidence);
    }
    // Tell the listener.
    if (proposedRotation != oldProposedRotation && proposedRotation >= 0) {
        if (log) {
            Slog.v(TAG, ""Proposed rotation changed!  proposedRotation="" + proposedRotation + "", oldProposedRotation="" + oldProposedRotation);
        }
        mOrientationListener.onProposedRotationChanged(proposedRotation);
    }
}","{
    // The vector given in the SensorEvent points straight up (towards the sky) under ideal
    // conditions (the phone is not accelerating).  I'll call this up vector elsewhere.
    float x = event.values[ACCELEROMETER_DATA_X];
    float y = event.values[ACCELEROMETER_DATA_Y];
    float z = event.values[ACCELEROMETER_DATA_Z];
    if (LOG) {
        Slog.v(TAG, ""Raw acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z + "", magnitude="" + FloatMath.sqrt(x * x + y * y + z * z));
    }
    // Apply a low-pass filter to the acceleration up vector in cartesian space.
    // Reset the orientation listener state if the samples are too far apart in time
    // or when we see values of (0, 0, 0) which indicates that we polled the
    // accelerometer too soon after turning it on and we don't have any data yet.
    final long now = event.timestamp;
    final long then = mLastFilteredTimestampNanos;
    final float timeDeltaMS = (now - then) * 0.000001f;
    final boolean skipSample;
    if (now < then || now > then + MAX_FILTER_DELTA_TIME_NANOS || (x == 0 && y == 0 && z == 0)) {
        if (LOG) {
            Slog.v(TAG, ""Resetting orientation listener."");
        }
        reset();
        skipSample = true;
    } else {
        final float alpha = timeDeltaMS / (FILTER_TIME_CONSTANT_MS + timeDeltaMS);
        x = alpha * (x - mLastFilteredX) + mLastFilteredX;
        y = alpha * (y - mLastFilteredY) + mLastFilteredY;
        z = alpha * (z - mLastFilteredZ) + mLastFilteredZ;
        if (LOG) {
            Slog.v(TAG, ""Filtered acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z + "", magnitude="" + FloatMath.sqrt(x * x + y * y + z * z));
        }
        skipSample = false;
    }
    mLastFilteredTimestampNanos = now;
    mLastFilteredX = x;
    mLastFilteredY = y;
    mLastFilteredZ = z;
    boolean isAccelerating = false;
    boolean isFlat = false;
    boolean isSwinging = false;
    if (!skipSample) {
        // Calculate the magnitude of the acceleration vector.
        final float magnitude = FloatMath.sqrt(x * x + y * y + z * z);
        if (magnitude < NEAR_ZERO_MAGNITUDE) {
            if (LOG) {
                Slog.v(TAG, ""Ignoring sensor data, magnitude too close to zero."");
            }
            clearPredictedRotation();
        } else {
            // Determine whether the device appears to be undergoing external acceleration.
            if (isAccelerating(magnitude)) {
                isAccelerating = true;
                mAccelerationTimestampNanos = now;
            }
            // Calculate the tilt angle.
            // This is the angle between the up vector and the x-y plane (the plane of
            // the screen) in a range of [-90, 90] degrees.
            // -90 degrees: screen horizontal and facing the ground (overhead)
            // 0 degrees: screen vertical
            // 90 degrees: screen horizontal and facing the sky (on table)
            final int tiltAngle = (int) Math.round(Math.asin(z / magnitude) * RADIANS_TO_DEGREES);
            addTiltHistoryEntry(now, tiltAngle);
            // Determine whether the device appears to be flat or swinging.
            if (isFlat(now)) {
                isFlat = true;
                mFlatTimestampNanos = now;
            }
            if (isSwinging(now, tiltAngle)) {
                isSwinging = true;
                mSwingTimestampNanos = now;
            }
            // the orientation angle of the screen.
            if (Math.abs(tiltAngle) > MAX_TILT) {
                if (LOG) {
                    Slog.v(TAG, ""Ignoring sensor data, tilt angle too high: "" + ""tiltAngle="" + tiltAngle);
                }
                clearPredictedRotation();
            } else {
                // Calculate the orientation angle.
                // This is the angle between the x-y projection of the up vector onto
                // the +y-axis, increasing clockwise in a range of [0, 360] degrees.
                int orientationAngle = (int) Math.round(-Math.atan2(-x, y) * RADIANS_TO_DEGREES);
                if (orientationAngle < 0) {
                    // atan2 returns [-180, 180]; normalize to [0, 360]
                    orientationAngle += 360;
                }
                // Find the nearest rotation.
                int nearestRotation = (orientationAngle + 45) / 90;
                if (nearestRotation == 4) {
                    nearestRotation = 0;
                }
                // Determine the predicted orientation.
                if (isTiltAngleAcceptable(nearestRotation, tiltAngle) && isOrientationAngleAcceptable(nearestRotation, orientationAngle)) {
                    updatePredictedRotation(now, nearestRotation);
                    if (LOG) {
                        Slog.v(TAG, ""Predicted: "" + ""tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle + "", predictedRotation="" + mPredictedRotation + "", predictedRotationAgeMS="" + ((now - mPredictedRotationTimestampNanos) * 0.000001f));
                    }
                } else {
                    if (LOG) {
                        Slog.v(TAG, ""Ignoring sensor data, no predicted rotation: "" + ""tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle);
                    }
                    clearPredictedRotation();
                }
            }
        }
    }
    // Determine new proposed rotation.
    final int oldProposedRotation = mProposedRotation;
    if (mPredictedRotation < 0 || isPredictedRotationAcceptable(now)) {
        mProposedRotation = mPredictedRotation;
    }
    // Write final statistics about where we are in the orientation detection process.
    if (LOG) {
        Slog.v(TAG, ""Result: currentRotation="" + mOrientationListener.mCurrentRotation + "", proposedRotation="" + mProposedRotation + "", predictedRotation="" + mPredictedRotation + "", timeDeltaMS="" + timeDeltaMS + "", isAccelerating="" + isAccelerating + "", isFlat="" + isFlat + "", isSwinging="" + isSwinging + "", timeUntilSettledMS="" + remainingMS(now, mPredictedRotationTimestampNanos + PROPOSAL_SETTLE_TIME_NANOS) + "", timeUntilAccelerationDelayExpiredMS="" + remainingMS(now, mAccelerationTimestampNanos + PROPOSAL_MIN_TIME_SINCE_ACCELERATION_ENDED_NANOS) + "", timeUntilFlatDelayExpiredMS="" + remainingMS(now, mFlatTimestampNanos + PROPOSAL_MIN_TIME_SINCE_FLAT_ENDED_NANOS) + "", timeUntilSwingDelayExpiredMS="" + remainingMS(now, mSwingTimestampNanos + PROPOSAL_MIN_TIME_SINCE_SWING_ENDED_NANOS));
    }
    // Tell the listener.
    if (mProposedRotation != oldProposedRotation && mProposedRotation >= 0) {
        if (LOG) {
            Slog.v(TAG, ""Proposed rotation changed!  proposedRotation="" + mProposedRotation + "", oldProposedRotation="" + oldProposedRotation);
        }
        mOrientationListener.onProposedRotationChanged(mProposedRotation);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
679,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>",15,16,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>","<android.view.View: void addFocusables(ArrayList<View>,int,int)>",0,"{
    if (!isFocusable()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {
        return;
    }
    if (views != null) {
        views.add(this);
    }
}","{
    if (views == null) {
        return;
    }
    if ((focusableMode & FOCUSABLES_ACCESSIBILITY) == FOCUSABLES_ACCESSIBILITY) {
        if (isAccessibilityFocusable()) {
            views.add(this);
            return;
        }
    }
    if (!isFocusable()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);
}",1,"/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode depending on
 * the focusable mode paramater.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
","/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode or
 * only views that can take accessibility focus if accessibility is enabeld
 * depending on the focusable mode paramater.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The change consists of a new check for null values at the beginning, checks for different condition and introduction of a new block of 'if', so the change types are 3,4.","Due to the changes in condition checks and the introduction of a new 'if' block, the order and condition of 'return' and 'views.add(this)' statements have been changed, which could potentially lead to different behaviors and thus the CI type is 1."
680,<android.database.sqlite.SQLiteStatement: long executeInsert()>,15,16,<android.database.sqlite.SQLiteStatement: long executeInsert()>,<android.database.sqlite.SQLiteStatement: long executeInsert()>,0,"{
    try {
        saveSqlAsLastSqlStatement();
        acquireAndLock(WRITE);
        return native_executeInsert();
    } finally {
        releaseAndUnlock();
    }
}","{
    acquireReference();
    try {
        return getSession().executeForLastInsertedRowId(getSql(), getBindArgs(), getConnectionFlags(), null);
    } catch (SQLiteDatabaseCorruptException ex) {
        onCorruption();
        throw ex;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Execute this SQL statement and return the ID of the row inserted due to this call.
 * The SQL statement should be an INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement and return the ID of the row inserted due to this call.
 * The SQL statement should be an INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","In the given two versions, both return and exception handling statements have changed. And also there are changes in dependent APIs (saveSqlAsLastSqlStatement(), acquireAndLock(), native_executeInsert(), releaseAndUnlock() methods replaced with getSession(), executeForLastInsertedRowId(), getSql(), getBindArgs(), getConnectionFlags(), onCorruption() etc.). So, the code change type is 1,2,4,5.","As both return and exception handling statements have changed, this change could potentially lead towards different return values or different exceptions being thrown. Thus, the Compatibility Issue type is 1,2."
682,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",15,16,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>","<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",0,"{
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    mShowCursor = SystemClock.uptimeMillis();
    ensureEndedBatchEdit();
    if (focused) {
        int selStart = getSelectionStart();
        int selEnd = getSelectionEnd();
        // SelectAllOnFocus fields are highlighted and not selected. Do not start text selection
        // mode for these, unless there was a specific selection already started.
        final boolean isFocusHighlighted = mSelectAllOnFocus && selStart == 0 && selEnd == mText.length();
        mCreatedWithASelection = mFrozenWithFocus && hasSelection() && !isFocusHighlighted;
        if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
            // If a tap was used to give focus to that view, move cursor at tap position.
            // Has to be done before onTakeFocus, which can be overloaded.
            final int lastTapPosition = getLastTapPosition();
            if (lastTapPosition >= 0) {
                Selection.setSelection((Spannable) mText, lastTapPosition);
            }
            if (mMovement != null) {
                mMovement.onTakeFocus(this, (Spannable) mText, direction);
            }
            // It would be better to know why the DecorView does not have focus at that time.
            if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
                /*
                     * Someone intentionally set the selection, so let them
                     * do whatever it is that they wanted to do instead of
                     * the default on-focus behavior.  We reset the selection
                     * here instead of just skipping the onTakeFocus() call
                     * because some movement methods do something other than
                     * just setting the selection in theirs and we still
                     * need to go through that path.
                     */
                Selection.setSelection((Spannable) mText, selStart, selEnd);
            }
            if (mSelectAllOnFocus) {
                selectAll();
            }
            mTouchFocusSelected = true;
        }
        mFrozenWithFocus = false;
        mSelectionMoved = false;
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
        makeBlink();
        if (mError != null) {
            showError();
        }
    } else {
        if (mError != null) {
            hideError();
        }
        // Don't leave us in the middle of a batch edit.
        onEndBatchEdit();
        if (this instanceof ExtractEditText) {
            // terminateTextSelectionMode removes selection, which we want to keep when
            // ExtractEditText goes out of focus.
            final int selStart = getSelectionStart();
            final int selEnd = getSelectionEnd();
            hideControllers();
            Selection.setSelection((Spannable) mText, selStart, selEnd);
        } else {
            hideControllers();
            downgradeEasyCorrectionSpans();
        }
        // No need to create the controller
        if (mSelectionModifierCursorController != null) {
            mSelectionModifierCursorController.resetTouchOffsets();
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}","{
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    if (mEditor != null)
        mEditor.onFocusChanged(focused, direction);
    if (focused) {
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Most of the method has been replaced in the late version, and the method 'mEditor.onFocusChanged(focused, direction)' is introduced in the late version. Thus, change type is 1 and 4.","With largely changed structure and added method 'mEditor.onFocusChanged(focused, direction)', it potentially leads to a different return and could also throw different exceptions. Therefore, CI type is 1."
684,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,15,16,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,0,"{
    Looper looper = Looper.myLooper();
    // go into this immediate mode?
    if (looper == null || (info.policy & THREAD_PENALTY_MASK) == PENALTY_DEATH) {
        // unknown (redundant, already set)
        info.durationMillis = -1;
        handleViolation(info);
        return;
    }
    final ArrayList<ViolationInfo> records = violationsBeingTimed.get();
    if (records.size() >= MAX_OFFENSES_PER_LOOP) {
        // Not worth measuring.  Too many offenses in one loop.
        return;
    }
    records.add(info);
    if (records.size() > 1) {
        // at the end of this Looper's loop.
        return;
    }
    final IWindowManager windowManager = (info.policy & PENALTY_FLASH) != 0 ? sWindowManager.get() : null;
    if (windowManager != null) {
        try {
            windowManager.showStrictModeViolation(true);
        } catch (RemoteException unused) {
        }
    }
    // We post a runnable to a Handler (== delay 0 ms) for
    // measuring the end time of a violation instead of using
    // an IdleHandler (as was previously used) because an
    // IdleHandler may not run for quite a long period of time
    // if an ongoing animation is happening and continually
    // posting ASAP (0 ms) animation steps.  Animations are
    // throttled back to 60fps via SurfaceFlinger/View
    // invalidates, _not_ by posting frame updates every 16
    // milliseconds.
    threadHandler.get().post(new Runnable() {

        public void run() {
            long loopFinishTime = SystemClock.uptimeMillis();
            // to keep the red border on.
            if (windowManager != null) {
                try {
                    windowManager.showStrictModeViolation(false);
                } catch (RemoteException unused) {
                }
            }
            for (int n = 0; n < records.size(); ++n) {
                ViolationInfo v = records.get(n);
                v.violationNumThisLoop = n + 1;
                v.durationMillis = (int) (loopFinishTime - v.violationUptimeMillis);
                handleViolation(v);
            }
            records.clear();
        }
    });
}","{
    Looper looper = Looper.myLooper();
    // go into this immediate mode?
    if (looper == null || (info.policy & THREAD_PENALTY_MASK) == PENALTY_DEATH) {
        // unknown (redundant, already set)
        info.durationMillis = -1;
        handleViolation(info);
        return;
    }
    final ArrayList<ViolationInfo> records = violationsBeingTimed.get();
    if (records.size() >= MAX_OFFENSES_PER_LOOP) {
        // Not worth measuring.  Too many offenses in one loop.
        return;
    }
    records.add(info);
    if (records.size() > 1) {
        // at the end of this Looper's loop.
        return;
    }
    final IWindowManager windowManager = (info.policy & PENALTY_FLASH) != 0 ? sWindowManager.get() : null;
    if (windowManager != null) {
        try {
            windowManager.showStrictModeViolation(true);
        } catch (RemoteException unused) {
        }
    }
    // We post a runnable to a Handler (== delay 0 ms) for
    // measuring the end time of a violation instead of using
    // an IdleHandler (as was previously used) because an
    // IdleHandler may not run for quite a long period of time
    // if an ongoing animation is happening and continually
    // posting ASAP (0 ms) animation steps.  Animations are
    // throttled back to 60fps via SurfaceFlinger/View
    // invalidates, _not_ by posting frame updates every 16
    // milliseconds.
    threadHandler.get().postAtFrontOfQueue(new Runnable() {

        public void run() {
            long loopFinishTime = SystemClock.uptimeMillis();
            // to keep the red border on.
            if (windowManager != null) {
                try {
                    windowManager.showStrictModeViolation(false);
                } catch (RemoteException unused) {
                }
            }
            for (int n = 0; n < records.size(); ++n) {
                ViolationInfo v = records.get(n);
                v.violationNumThisLoop = n + 1;
                v.durationMillis = (int) (loopFinishTime - v.violationUptimeMillis);
                handleViolation(v);
            }
            records.clear();
        }
    });
}",1,"// the next epoll_wait)
","// the next epoll_wait)
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method threadHandler.get().post() is changed to threadHandler.get().postAtFrontOfQueue(), so the change type is 4 (Other statement changed).","This change only alter the order to put the Runnable into the queue. It won't change the returned value of the method or the potential exceptions, so there is no Compatibility Issue (type 0)."
685,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",15,16,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>","<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",0,"{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child, position);
                    if (ViewDebug.TRACE_RECYCLER) {
                        ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                    }
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child, position);
                    if (ViewDebug.TRACE_RECYCLER) {
                        ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                    }
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    invalidate();
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    awakenScrollBars();
    return false;
}","{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}",1,"/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
","/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are some other statements changed such as the detaching views from parent synchronous mechanism, scroll bar awakening approach, and the invalidate procedure.","Despite the changes, none of them has the potential to alter what the API returns or how it handles exceptions. Thus, we can consider that no Compatibility Issue exists."
687,<android.webkit.WebView: int getContentHeight()>,15,16,<android.webkit.WebView: int getContentHeight()>,<android.webkit.WebView: int getContentHeight()>,0,"{
    checkThread();
    return mContentHeight;
}","{
    checkThread();
    return mProvider.getContentHeight();
}",1,"/**
 * @return the height of the HTML content.
 */
","/**
 * Gets the height of the HTML content.
 *
 * @return the height of the HTML content
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'return mContentHeight' to 'return mProvider.getContentHeight()'. The dependent method 'getContentHeight' from 'mProvider' object was referenced in the latest version. Hence, the code change type is 1,5.","Due to the change in the return statement, the API potentially returns a different value in the late version compared to the early version, leading the CI type to 1."
689,"<android.app.AlarmManager: void setInexactRepeating(int,long,long,PendingIntent)>",15,16,"<android.app.AlarmManager: void setInexactRepeating(int,long,long,PendingIntent)>","<android.app.AlarmManager: void setInexactRepeating(int,long,long,PendingIntent)>",0,"{
    try {
        mService.setInexactRepeating(type, triggerAtTime, interval, operation);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mService.setInexactRepeating(type, triggerAtMillis, intervalMillis, operation);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Schedule a repeating alarm that has inexact trigger time requirements;
 * for example, an alarm that repeats every hour, but not necessarily at
 * the top of every hour.  These alarms are more power-efficient than
 * the strict recurrences supplied by {@link #setRepeating}, since the
 * system can adjust alarms' phase to cause them to fire simultaneously,
 * avoiding waking the device from sleep more than necessary.
 *
 * <p>Your alarm's first trigger will not be before the requested time,
 * but it might not occur for almost a full interval after that time.  In
 * addition, while the overall period of the repeating alarm will be as
 * requested, the time between any two successive firings of the alarm
 * may vary.  If your application demands very low jitter, use
 * {@link #setRepeating} instead.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtTime Time the alarm should first go off, using the
 * appropriate clock (depending on the alarm type).  This
 * is inexact: the alarm will not fire before this time,
 * but there may be a delay of almost an entire alarm
 * interval before the first invocation of the alarm.
 * @param interval Interval between subsequent repeats of the alarm.  If
 * this is one of INTERVAL_FIFTEEN_MINUTES, INTERVAL_HALF_HOUR,
 * INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY then the
 * alarm will be phase-aligned with other alarms to reduce
 * the number of wakeups.  Otherwise, the alarm will be set
 * as though the application had called {@link #setRepeating}.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 * @see #INTERVAL_FIFTEEN_MINUTES
 * @see #INTERVAL_HALF_HOUR
 * @see #INTERVAL_HOUR
 * @see #INTERVAL_HALF_DAY
 * @see #INTERVAL_DAY
 */
","/**
 * Schedule a repeating alarm that has inexact trigger time requirements;
 * for example, an alarm that repeats every hour, but not necessarily at
 * the top of every hour.  These alarms are more power-efficient than
 * the strict recurrences supplied by {@link #setRepeating}, since the
 * system can adjust alarms' phase to cause them to fire simultaneously,
 * avoiding waking the device from sleep more than necessary.
 *
 * <p>Your alarm's first trigger will not be before the requested time,
 * but it might not occur for almost a full interval after that time.  In
 * addition, while the overall period of the repeating alarm will be as
 * requested, the time between any two successive firings of the alarm
 * may vary.  If your application demands very low jitter, use
 * {@link #setRepeating} instead.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).  This
 * is inexact: the alarm will not fire before this time, but there may be a
 * delay of almost an entire alarm interval before the first invocation of
 * the alarm.
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.  If this is one of INTERVAL_FIFTEEN_MINUTES,
 * INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
 * then the alarm will be phase-aligned with other alarms to reduce the
 * number of wakeups.  Otherwise, the alarm will be set as though the
 * application had called {@link #setRepeating}.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 * @see #INTERVAL_FIFTEEN_MINUTES
 * @see #INTERVAL_HALF_HOUR
 * @see #INTERVAL_HOUR
 * @see #INTERVAL_HALF_DAY
 * @see #INTERVAL_DAY
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The names of the parameters sent to method setInexactRepeating() in mService class have been changed, which qualifies as an Other statement changed (type 4). Also, it might imply a change in the dependent API that this method call relies upon, since the parameter names typically match the ones declared in the method signature, which qualifies as Dependent API changed (type 5).","The changes identified do not directly appear to impact the potential return value or exception handling behaviour of the API setInexactRepeating(), given that its functional behaviour doesn't depend on the names of local variables. It is expected to perform its functionality based on the values passed, not their variable names. Therefore, there aren't any compatibility issues identified (type 0)."
690,<android.webkit.WebSettings: boolean getDisplayZoomControls()>,15,16,<android.webkit.WebSettings: boolean getDisplayZoomControls()>,<android.webkit.WebSettings: boolean getDisplayZoomControls()>,0,"{
    return mDisplayZoomControls;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if the on screen zoom buttons are being used.
 */
","/**
 * Gets whether the WebView displays on-screen zoom controls when using
 * the built-in zoom mechanisms.
 *
 * @return true if the WebView displays on-screen zoom controls when using
 * the built-in zoom mechanisms
 * @see #setDisplayZoomControls
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version returns a boolean value from the variable mDisplayZoomControls, while the late version throws a MustOverrideException. This is a change in the return and exception handling statement, so the code change type is 1,2.","In the early version, the API returns a boolean value, but in the late version, it throws an exception. This change can potentially lead to a different return value or an unexpected exception, thus the CI type is 1,2."
691,<android.webkit.WebSettings: boolean getUseDoubleTree()>,15,16,<android.webkit.WebSettings: boolean getUseDoubleTree()>,<android.webkit.WebSettings: boolean getUseDoubleTree()>,0,"{
    return false;
}","{
    // Returns false unconditionally, so no need for derived classes to override.
    return false;
}",1,"/**
 * @deprecated This setting controlled a rendering optimization
 * that is no longer present. Setting it now has no effect.
 */
","/**
 * Controlled a rendering optimization that is no longer present. Setting
 * it now has no effect.
 *
 * @deprecated This setting now has no effect.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,"No actual logic or return statements have been altered. Only comments have been added for more clarity in the Late Implementation version. Therefore, no code change is detected.","Because there are no changes in the actual implementation of the API, there are also no Compatibility Issues."
692,"<android.view.ViewGroup: View focusSearch(View,int)>",15,16,"<android.view.ViewGroup: View focusSearch(View,int)>","<android.view.ViewGroup: View focusSearch(View,int)>",0,"{
    if (isRootNamespace()) {
        // into other tabs.  see LocalActivityManager and TabHost for more info
        return FocusFinder.getInstance().findNextFocus(this, focused, direction);
    } else if (mParent != null) {
        return mParent.focusSearch(focused, direction);
    }
    return null;
}","{
    // the screen.
    if (isRootNamespace() && (direction & FOCUS_ACCESSIBILITY) == 0) {
        // into other tabs.  see LocalActivityManager and TabHost for more info
        return FocusFinder.getInstance().findNextFocus(this, focused, direction);
    } else if (mParent != null) {
        return mParent.focusSearch(focused, direction);
    }
    return null;
}",1,"/**
 * Find the nearest view in the specified direction that wants to take
 * focus.
 *
 * @param focused The view that currently has focus
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
 * FOCUS_RIGHT, or 0 for not applicable.
 */
","/**
 * Find the nearest view in the specified direction that wants to take
 * focus.
 *
 * @param focused The view that currently has focus
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
 * FOCUS_RIGHT, or 0 for not applicable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement 'if (isRootNamespace())' has been changed to be 'if (isRootNamespace() && (direction & FOCUS_ACCESSIBILITY) == 0)', so the code change type is 3.","The change in the condition statement can potentially alter the return statement when the direction does not meet the newly added condition. Therefore, the API could potentially return different values, so the CI type is 1."
694,<android.webkit.WebView: int getVisibleTitleHeight()>,15,16,<android.webkit.WebView: int getVisibleTitleHeight()>,<android.webkit.WebView: int getVisibleTitleHeight()>,0,"{
    checkThread();
    return getVisibleTitleHeightImpl();
}","{
    checkThread();
    return mProvider.getVisibleTitleHeight();
}",1,"/**
 * Return the amount of the titlebarview (if any) that is visible
 *
 * @deprecated This method is now obsolete.
 */
","/**
 * Gets the visible height (in pixels) of the embedded title bar (if any).
 *
 * @deprecated This method is now obsolete.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getVisibleTitleHeightImpl() to mProvider.getVisibleTitleHeight(). The method 'getVisibleTitleHeightImpl()' called in the early version has been replaced by a method in an object of 'mProvider' class in the late version, thus change type is 1,5.","The return statement modification may lead to returning a different value. In the early version, the value returned is fetched by 'getVisibleTitleHeightImpl()' method but in the late version, the value is attained from 'mProvider.getVisibleTitleHeight()', hence a compatibility issue of type 1 could occur."
695,<android.widget.TextView: int getImeOptions()>,15,16,<android.widget.TextView: int getImeOptions()>,<android.widget.TextView: int getImeOptions()>,0,"{
    return mInputContentType != null ? mInputContentType.imeOptions : EditorInfo.IME_NULL;
}","{
    return mEditor != null && mEditor.mInputContentType != null ? mEditor.mInputContentType.imeOptions : EditorInfo.IME_NULL;
}",1,"/**
 * Get the type of the IME editor.
 *
 * @see #setImeOptions(int)
 * @see android.view.inputmethod.EditorInfo
 */
","/**
 * Get the type of the IME editor.
 *
 * @see #setImeOptions(int)
 * @see android.view.inputmethod.EditorInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the early version, the return statement is dependent on whether `mInputContentType` is null or not, while in the late version, the logic has changed to also include a check for `mEditor`. This represents a Control Dependency Change (type 3). Also, the return statement is changed between the two versions, hence it also falls under the Return Statement Changed category (type 1).","The new condition introduces a new possible branch in the logic of the method, which can potentially result in a different return value, thus leading to Compatibility Issue of type 1."
696,<android.webkit.WebView: boolean canGoBack()>,15,16,<android.webkit.WebView: boolean canGoBack()>,<android.webkit.WebView: boolean canGoBack()>,0,"{
    checkThread();
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() > 0;
        }
    }
}","{
    checkThread();
    return mProvider.canGoBack();
}",1,"/**
 * Return true if this WebView has a back history item.
 * @return True iff this WebView has a back history item.
 */
","/**
 * Gets whether this WebView has a back history item.
 *
 * @return true iff this WebView has a back history item
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"This API's implementation has significant changes from the early version to the late version. In the early version, the method executes some conditional clauses and access the 'l' object. However, in the late version, it simply returns the result from the method 'mProvider.canGoBack()'. Thus, the code changes belong to categories 1 and 5.","Due to the change of the returned result directly from 'mProvider.canGoBack()' instead of evaluating some conditions and manipulating the 'l' object, the late version of the method could potentially yield a different return value compared to the early version. Consequently, a compatibility issue of type 1 arises."
697,<android.webkit.WebView: int findAll(String)>,15,16,<android.webkit.WebView: int findAll(String)>,<android.webkit.WebView: int findAll(String)>,0,"{
    checkThread();
    // client isn't initialized
    if (0 == mNativeClass)
        return 0;
    int result = find != null ? nativeFindAll(find.toLowerCase(), find.toUpperCase(), find.equalsIgnoreCase(mLastFind)) : 0;
    invalidate();
    mLastFind = find;
    return result;
}","{
    checkThread();
    StrictMode.noteSlowCall(""findAll blocks UI: prefer findAllAsync"");
    return mProvider.findAll(find);
}",1,"/*
     * Find all instances of find on the page and highlight them.
     * @param find  String to find.
     * @return int  The number of occurances of the String ""find""
     *              that were found.
     */
","/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String ""find"" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"Multiple statements have been deleted (like logic to deal with mNativeClass and find, mLastFind assignments, etc) and a new return statement (mProvider.findAll(find)) has appeared. Additionally, the dependent API has also changed to mProvider.findAll(find) instead of nativeFindAll() and invalidate(), hence the change is classified as type 1,4,5.","The new return statement will potentially make the API return different values; thus, the compatibility issue is classified as type 1."
698,<android.content.ContentProviderClient: boolean release()>,15,16,<android.content.ContentProviderClient: boolean release()>,<android.content.ContentProviderClient: boolean release()>,0,"{
    return mContentResolver.releaseProvider(mContentProvider);
}","{
    synchronized (this) {
        if (mReleased) {
            throw new IllegalStateException(""Already released"");
        }
        mReleased = true;
        if (mStable) {
            return mContentResolver.releaseProvider(mContentProvider);
        } else {
            return mContentResolver.releaseUnstableProvider(mContentProvider);
        }
    }
}",1,"/**
 * Call this to indicate to the system that the associated {@link ContentProvider} is no
 * longer needed by this {@link ContentProviderClient}.
 * @return true if this was release, false if it was already released
 */
","/**
 * Call this to indicate to the system that the associated {@link ContentProvider} is no
 * longer needed by this {@link ContentProviderClient}.
 * @return true if this was release, false if it was already released
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","In the late version, additional if else control statements are added, and the return statements inside the if else blocks are changed, so the code change type is 1,3.","The newly added control statements will affect the return value of the function, potentially making it return a different value, thus the CI type is 1. In addition, the late version introduces a new throw statement, which may cause different exception handling, making the CI type also include 2."
700,<android.app.ApplicationPackageManager: int getComponentEnabledSetting(ComponentName)>,15,16,<android.app.ApplicationPackageManager: int getComponentEnabledSetting(ComponentName)>,<android.app.ApplicationPackageManager: int getComponentEnabledSetting(ComponentName)>,0,"{
    try {
        return mPM.getComponentEnabledSetting(componentName);
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}","{
    try {
        return mPM.getComponentEnabledSetting(componentName, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement which calls mPM.getComponentEnabledSetting(componentName) has been modified to mPM.getComponentEnabledSetting(componentName, UserId.myUserId()),  which indicates the dependent API has changed. Therefore, the predicted change type is 1,5.","Due to the dependent API change as a new parameter is introduced, the outcome returned could potentially be different than the previous version, hence the CI type is 1."
703,<android.widget.GridView: void layoutChildren()>,15,16,<android.widget.GridView: void layoutChildren()>,<android.widget.GridView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : 0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(INVALID_POSITION, sel);
            mSelectedTop = sel.getTop();
        } else if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
            View child = getChildAt(mMotionPosition - mFirstPosition);
            if (child != null)
                positionSelector(mMotionPosition, child);
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : 0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(mAdapter == null || isInTouchMode() ? INVALID_POSITION : last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(INVALID_POSITION, sel);
            mSelectedTop = sel.getTop();
        } else if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
            View child = getChildAt(mMotionPosition - mFirstPosition);
            if (child != null)
                positionSelector(mMotionPosition, child);
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",1,"Two new method calls are introduced, recycleBin.removeSkippedScrap() and post(mPositionScrollAfterLayout). Additionally, the member variable mPositionScrollAfterLayout is set to null in the Late Version. Control dependency also changes with these additions. Thus, the change types include 3 and 4.","The added method calls and changes in member variables potentially modify the behavior of the method. The method could thus return different results in the two versions. Hence, a compatibility issue of type 1 is identified."
704,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,15,16,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mAccessibilityViewId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByViewText(mConnectionId, text, mAccessibilityWindowId, mAccessibilityViewId);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByText(mConnectionId, mWindowId, mSourceNodeId, text);
}",1,"/**
 * Finds {@link AccessibilityNodeInfo}s by text. The match is case
 * insensitive containment. The search is relative to this info i.e.
 * this info is the root of the traversed tree.
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param text The searched text.
 * @return A list of node info.
 */
","/**
 * Finds {@link AccessibilityNodeInfo}s by text. The match is case
 * insensitive containment. The search is relative to this info i.e.
 * this info is the root of the traversed tree.
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param text The searched text.
 * @return A list of node info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"There's a major change in the parameters used in ""canPerformRequestOverConnection"" and ""findAccessibilityNodeInfosByText"" methods, in addition, the return value is impacted by those changes, hence the code change types are 1,5.","Given that the change to the parameters in ""canPerformRequestOverConnection"" and ""findAccessibilityNodeInfosByText"" methods, the return statement now becomes dependent on a different set of parameters. Thus, this may lead the API to return different types or values, causing a CI of type 1."
705,<android.database.sqlite.SQLiteDatabase: boolean isDatabaseIntegrityOk()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean isDatabaseIntegrityOk()>,<android.database.sqlite.SQLiteDatabase: boolean isDatabaseIntegrityOk()>,0,"{
    verifyDbIsOpen();
    List<Pair<String, String>> attachedDbs = null;
    try {
        attachedDbs = getAttachedDbs();
        if (attachedDbs == null) {
            throw new IllegalStateException(""databaselist for: "" + getPath() + "" couldn't "" + ""be retrieved. probably because the database is closed"");
        }
    } catch (SQLiteException e) {
        // can't get attachedDb list. do integrity check on the main database
        attachedDbs = new ArrayList<Pair<String, String>>();
        attachedDbs.add(new Pair<String, String>(""main"", this.mPath));
    }
    for (int i = 0; i < attachedDbs.size(); i++) {
        Pair<String, String> p = attachedDbs.get(i);
        SQLiteStatement prog = null;
        try {
            prog = compileStatement(""PRAGMA "" + p.first + "".integrity_check(1);"");
            String rslt = prog.simpleQueryForString();
            if (!rslt.equalsIgnoreCase(""ok"")) {
                // integrity_checker failed on main or attached databases
                Log.e(TAG, ""PRAGMA integrity_check on "" + p.second + "" returned: "" + rslt);
                return false;
            }
        } finally {
            if (prog != null)
                prog.close();
        }
    }
    return true;
}","{
    acquireReference();
    try {
        List<Pair<String, String>> attachedDbs = null;
        try {
            attachedDbs = getAttachedDbs();
            if (attachedDbs == null) {
                throw new IllegalStateException(""databaselist for: "" + getPath() + "" couldn't "" + ""be retrieved. probably because the database is closed"");
            }
        } catch (SQLiteException e) {
            // can't get attachedDb list. do integrity check on the main database
            attachedDbs = new ArrayList<Pair<String, String>>();
            attachedDbs.add(new Pair<String, String>(""main"", getPath()));
        }
        for (int i = 0; i < attachedDbs.size(); i++) {
            Pair<String, String> p = attachedDbs.get(i);
            SQLiteStatement prog = null;
            try {
                prog = compileStatement(""PRAGMA "" + p.first + "".integrity_check(1);"");
                String rslt = prog.simpleQueryForString();
                if (!rslt.equalsIgnoreCase(""ok"")) {
                    // integrity_checker failed on main or attached databases
                    Log.e(TAG, ""PRAGMA integrity_check on "" + p.second + "" returned: "" + rslt);
                    return false;
                }
            } finally {
                if (prog != null)
                    prog.close();
            }
        }
    } finally {
        releaseReference();
    }
    return true;
}",1,"/**
 * Runs 'pragma integrity_check' on the given database (and all the attached databases)
 * and returns true if the given database (and all its attached databases) pass integrity_check,
 * false otherwise.
 * <p>
 * If the result is false, then this method logs the errors reported by the integrity_check
 * command execution.
 * <p>
 * Note that 'pragma integrity_check' on a database can take a long time.
 *
 * @return true if the given database (and all its attached databases) pass integrity_check,
 * false otherwise.
 */
","/**
 * Runs 'pragma integrity_check' on the given database (and all the attached databases)
 * and returns true if the given database (and all its attached databases) pass integrity_check,
 * false otherwise.
 * <p>
 * If the result is false, then this method logs the errors reported by the integrity_check
 * command execution.
 * <p>
 * Note that 'pragma integrity_check' on a database can take a long time.
 *
 * @return true if the given database (and all its attached databases) pass integrity_check,
 * false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"The late version introduced some new methods: 'acquireReference()' at the beginning and 'releaseReference()' at the end which were not in the early version. The 'verifyDbIsOpen()' method in the early version was removed in the late version. There's also a minor change in the addition of the pair object in the catch clause, where 'this.mPath' is replaced by 'getPath()'. Thus the change type is 1,4.","Although there are several changes in the code implementation, these changes won't cause the method to return different results or throw different exceptions under the same condition. Therefore, no compatibility issue exists."
706,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,15,16,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,0,"{
    if (DEBUG)
        Slog.v(TAG, this + "" >>> doInBackground"");
    result = AsyncTaskLoader.this.onLoadInBackground();
    if (DEBUG)
        Slog.v(TAG, this + ""  <<< doInBackground"");
    return result;
}","{
    if (DEBUG)
        Slog.v(TAG, this + "" >>> doInBackground"");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground"");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground (was canceled)"");
        return null;
    }
}",1,"/* Runs on a worker thread */
","/* Runs on a worker thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,2","1,2","The result of the return statement in the early version is changed to data in the late version. An 'if' control statement and a 'try-catch' block have been inserted in the late implementation, so the change type is 1,3,2.","The variable that is returned has changed, which may result in the API returning a different value or type. Also, the introduced 'try-catch' block can potentially change the way the function handles exceptions, thus leading to a different behavior. Therefore, the CI type is 1,2."
707,<android.os.AsyncTask: boolean cancel(boolean)>,15,16,<android.os.AsyncTask: boolean cancel(boolean)>,<android.os.AsyncTask: boolean cancel(boolean)>,0,"{
    return mFuture.cancel(mayInterruptIfRunning);
}","{
    mCancelled.set(true);
    return mFuture.cancel(mayInterruptIfRunning);
}",1,"/**
 * <p>Attempts to cancel execution of this task.  This attempt will
 * fail if the task has already completed, already been cancelled,
 * or could not be cancelled for some other reason. If successful,
 * and this task has not started when <tt>cancel</tt> is called,
 * this task should never run. If the task has already started,
 * then the <tt>mayInterruptIfRunning</tt> parameter determines
 * whether the thread executing this task should be interrupted in
 * an attempt to stop the task.</p>
 *
 * <p>Calling this method will result in {@link #onCancelled(Object)} being
 * invoked on the UI thread after {@link #doInBackground(Object[])}
 * returns. Calling this method guarantees that {@link #onPostExecute(Object)}
 * is never invoked. After invoking this method, you should check the
 * value returned by {@link #isCancelled()} periodically from
 * {@link #doInBackground(Object[])} to finish the task as early as
 * possible.</p>
 *
 * @param mayInterruptIfRunning <tt>true</tt> if the thread executing this
 * task should be interrupted; otherwise, in-progress tasks are allowed
 * to complete.
 *
 * @return <tt>false</tt> if the task could not be cancelled,
 * typically because it has already completed normally;
 * <tt>true</tt> otherwise
 *
 * @see #isCancelled()
 * @see #onCancelled(Object)
 */
","/**
 * <p>Attempts to cancel execution of this task.  This attempt will
 * fail if the task has already completed, already been cancelled,
 * or could not be cancelled for some other reason. If successful,
 * and this task has not started when <tt>cancel</tt> is called,
 * this task should never run. If the task has already started,
 * then the <tt>mayInterruptIfRunning</tt> parameter determines
 * whether the thread executing this task should be interrupted in
 * an attempt to stop the task.</p>
 *
 * <p>Calling this method will result in {@link #onCancelled(Object)} being
 * invoked on the UI thread after {@link #doInBackground(Object[])}
 * returns. Calling this method guarantees that {@link #onPostExecute(Object)}
 * is never invoked. After invoking this method, you should check the
 * value returned by {@link #isCancelled()} periodically from
 * {@link #doInBackground(Object[])} to finish the task as early as
 * possible.</p>
 *
 * @param mayInterruptIfRunning <tt>true</tt> if the thread executing this
 * task should be interrupted; otherwise, in-progress tasks are allowed
 * to complete.
 *
 * @return <tt>false</tt> if the task could not be cancelled,
 * typically because it has already completed normally;
 * <tt>true</tt> otherwise
 *
 * @see #isCancelled()
 * @see #onCancelled(Object)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"An additional statement ""mCancelled.set(true);"" is added to the late version. However, the return statement in both versions remains unchanged and it's only predicated on the mFuture.cancel(mayInterruptIfRunning) outcome. Thus the code change type is 1(for return statement is part of the method) and 4(for the newly added statement).","Even though a new assignment statement has been introduced, it wouldn't cause the method to return a different value or type. The 'cancel' method still returns the result of the 'mFuture.cancel(mayInterruptIfRunning)' expression in both versions. Hence, no compatibility issue exists."
708,<android.view.ViewStub: View inflate()>,15,16,<android.view.ViewStub: View inflate()>,<android.view.ViewStub: View inflate()>,0,"{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory = LayoutInflater.from(mContext);
            final View view = factory.inflate(mLayoutResource, parent, false);
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
            }
            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }
            mInflatedViewRef = new WeakReference<View>(view);
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}","{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory;
            if (mInflater != null) {
                factory = mInflater;
            } else {
                factory = LayoutInflater.from(mContext);
            }
            final View view = factory.inflate(mLayoutResource, parent, false);
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
            }
            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }
            mInflatedViewRef = new WeakReference<View>(view);
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}",1,"/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
","/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API `LayoutInflater.from(mContext)` is replaced by a new condition block that may return `mInflater` instead. Thus, the categories of change are 4 and 5.","Even though the inflater source is different (either `LayoutInflater.from(mContext)` or `mInflater`), this doesn't really affect the return value from the `inflate()` method as both ways will create LayoutInflater instances. It doesn't affect the exceptions this method may throw neither. Therefore, there are no Compatibility Issues."
709,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,15,16,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket();
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket();
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,"/**
 * Creates a new socket which is not connected to any remote host.
 * You must use {@link Socket#connect} to connect the socket.
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * Creates a new socket which is not connected to any remote host.
 * You must use {@link Socket#connect} to connect the socket.
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"An extra statement setting the NpnProtocols of the OpenSSLSocketImpl instance is introduced in the late version. Hence, the code change type is 4.","The introduction of the setting of NpnProtocols in the late version could potentially impact the behavior of the Socket returned by the API, leading to different outcomes when invoking this API. Thus, the CI type is 1."
711,<android.speech.tts.AudioPlaybackHandler.MessageLoop: void run()>,15,16,<android.speech.tts.AudioPlaybackHandler.MessageLoop: void run()>,<android.speech.tts.AudioPlaybackHandler.MessageLoop: void run()>,0,"{
    while (true) {
        ListEntry entry = null;
        try {
            entry = mQueue.take();
        } catch (InterruptedException ie) {
            return;
        }
        if (entry.mWhat == SHUTDOWN) {
            if (DBG)
                Log.d(TAG, ""MessageLoop : Shutting down"");
            return;
        }
        if (DBG) {
            Log.d(TAG, ""MessageLoop : Handling message :"" + entry.mWhat + "" ,seqId : "" + entry.mSequenceId);
        }
        setCurrentParams(entry.mMessage);
        handleMessage(entry);
        setCurrentParams(null);
    }
}","{
    while (true) {
        PlaybackQueueItem item = null;
        try {
            item = mQueue.take();
        } catch (InterruptedException ie) {
            if (DBG)
                Log.d(TAG, ""MessageLoop : Shutting down (interrupted)"");
            return;
        }
        // If stop() or stopForApp() are called between mQueue.take()
        // returning and mCurrentWorkItem being set, the current work item
        // will be run anyway.
        mCurrentWorkItem = item;
        item.run();
        mCurrentWorkItem = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, a new variable 'item' is introduced and assigned with mQueue.take(); Also, a new statement 'item.run()' is introduced while corresponding 'handleMessage(entry);' and 'setCurrentParams(null);' are removed; Moreover, control statements 'while' has also been changed compared with the early version. Therefore, the change type is 1,3,4.","Given that the methods 'setCurrentParams(entry.mMessage);', 'handleMessage(entry);', and 'setCurrentParams(null);' are replaced by the new statements, and the new variable 'item' and its run() method are introduced, the API can potentially return different results. Thus, the CI type is 1."
712,<android.webkit.WebView: void onDraw(Canvas)>,15,16,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"{
    // initialized. In either case, just draw the background color and return
    if (mNativeClass == 0) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    if (canvas.isHardwareAccelerated()) {
        if (mIncrementEGLContextHack == false) {
            mIncrementEGLContextHack = true;
            EGL10 egl = (EGL10) EGLContext.getEGL();
            EGLDisplay eglDisplay = egl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            int[] version = new int[2];
            egl.eglInitialize(eglDisplay, version);
        }
        mZoomManager.setHardwareAccelerated();
    }
    int saveCount = canvas.save();
    if (mInOverScrollMode && !getSettings().getUseWebViewBackgroundForOverscrollBackground()) {
        drawOverScrollBackground(canvas);
    }
    if (mTitleBar != null) {
        canvas.translate(0, getTitleHeight());
    }
    boolean drawJavaRings = !mTouchHighlightRegion.isEmpty() && (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_DONE_MODE);
    boolean drawNativeRings = !drawJavaRings;
    if (USE_WEBKIT_RINGS) {
        drawNativeRings = !drawJavaRings && !isInTouchMode();
    }
    drawContent(canvas, drawNativeRings);
    canvas.restoreToCount(saveCount);
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    mWebViewCore.signalRepaintDone();
    if (mOverScrollGlow != null && mOverScrollGlow.drawEdgeGlows(canvas)) {
        invalidate();
    }
    // paint the highlight in the end
    if (drawJavaRings) {
        long delay = System.currentTimeMillis() - mTouchHighlightRequested;
        if (delay < ViewConfiguration.getTapTimeout()) {
            Rect r = mTouchHighlightRegion.getBounds();
            postInvalidateDelayed(delay, r.left, r.top, r.right, r.bottom);
        } else {
            if (mTouchHightlightPaint == null) {
                mTouchHightlightPaint = new Paint();
                mTouchHightlightPaint.setColor(HIGHLIGHT_COLOR);
            }
            RegionIterator iter = new RegionIterator(mTouchHighlightRegion);
            Rect r = new Rect();
            while (iter.next(r)) {
                canvas.drawRect(r, mTouchHightlightPaint);
            }
        }
    }
    if (DEBUG_TOUCH_HIGHLIGHT) {
        if (getSettings().getNavDump()) {
            if ((mTouchHighlightX | mTouchHighlightY) != 0) {
                if (mTouchCrossHairColor == null) {
                    mTouchCrossHairColor = new Paint();
                    mTouchCrossHairColor.setColor(Color.RED);
                }
                canvas.drawLine(mTouchHighlightX - mNavSlop, mTouchHighlightY - mNavSlop, mTouchHighlightX + mNavSlop + 1, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
                canvas.drawLine(mTouchHighlightX + mNavSlop + 1, mTouchHighlightY - mNavSlop, mTouchHighlightX - mNavSlop, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
            }
        }
    }
}","{
    mProvider.getViewDelegate().onDraw(canvas);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of onDraw method has been replaced with a method call to mProvider.getViewDelegate().onDraw(canvas). Therefore, the types of change are 1) return statement and 5) dependent API changed.","Due to the complete change to the implementation, this API might return different values or behave differently from the previous version entirely. Hence, there's a Compatibility Issue caused by potential different return values."
713,<android.view.View: boolean fitSystemWindows(Rect)>,15,16,<android.view.View: boolean fitSystemWindows(Rect)>,<android.view.View: boolean fitSystemWindows(Rect)>,0,"{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mPaddingLeft = insets.left;
        mPaddingTop = insets.top;
        mPaddingRight = insets.right;
        mPaddingBottom = insets.bottom;
        requestLayout();
        return true;
    }
    return false;
}","{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = -1;
        mUserPaddingEnd = -1;
        mUserPaddingRelative = false;
        if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || (mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0) {
            internalSetPadding(insets.left, insets.top, insets.right, insets.bottom);
            return true;
        } else {
            internalSetPadding(0, 0, 0, 0);
            return false;
        }
    }
    return false;
}",1,"/**
 * Apply the insets for system windows to this view, if the FITS_SYSTEM_WINDOWS flag
 * is set
 *
 * @param insets Insets for system windows
 *
 * @return True if this view applied the insets, false otherwise
 */
","/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * inset's to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return Return true if this view applied the insets and it should not
 * continue propagating further down the hierarchy, false otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows()
 * @see #setSystemUiVisibility(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, first, statements that set different padding values have been added and old ones were removed. Second, the control dependency (the if and else statements) got changed with a new condition "" (mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || (mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0"". Third, there are introduced 'internalSetPadding()' statements which are not related to return statements, exception handling statements, or control dependencies. So, the code change type is 1,3,4.","Depending on the new condition introduced in the late version, different variables ('insets.left', 'insets.top', etc. for 'true' or 0s for 'false') can be returned, which makes this a potential compatibility issue of type 1."
714,<android.view.HardwareRenderer.GlRenderer: void invalidate(SurfaceHolder)>,15,16,<android.view.HardwareRenderer.GlRenderer: void invalidate(SurfaceHolder)>,<android.view.HardwareRenderer.GlRenderer: void invalidate(SurfaceHolder)>,0,"{
    // Cancels any existing buffer to ensure we'll get a buffer
    // of the right size before we call eglSwapBuffers
    sEgl.eglMakeCurrent(sEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    if (mEglSurface != null && mEglSurface != EGL_NO_SURFACE) {
        sEgl.eglDestroySurface(sEglDisplay, mEglSurface);
        mEglSurface = null;
        setEnabled(false);
    }
    if (holder.getSurface().isValid()) {
        if (!createSurface(holder)) {
            return;
        }
        if (mCanvas != null) {
            setEnabled(true);
        }
    }
}","{
    // Cancels any existing buffer to ensure we'll get a buffer
    // of the right size before we call eglSwapBuffers
    sEgl.eglMakeCurrent(sEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    if (mEglSurface != null && mEglSurface != EGL_NO_SURFACE) {
        sEgl.eglDestroySurface(sEglDisplay, mEglSurface);
        mEglSurface = null;
        setEnabled(false);
    }
    if (holder.getSurface().isValid()) {
        if (!createSurface(holder)) {
            return;
        }
        mUpdateDirtyRegions = true;
        if (mCanvas != null) {
            setEnabled(true);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,There is a new assignment statement 'mUpdateDirtyRegions = true' introduced in the late version. So the change type is 4.,The introduction of a new assignment 'mUpdateDirtyRegions = true' will only change the value of 'mUpdateDirtyRegions' within the API and has no effect on the API's behavior from the caller's perspective. Thus no Compatibility Issue exists.
715,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: AbstractSynthesisCallback createSynthesisCallback()>,15,16,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: AbstractSynthesisCallback createSynthesisCallback()>,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: AbstractSynthesisCallback createSynthesisCallback()>,0,"{
    return new PlaybackSynthesisCallback(getStreamType(), getVolume(), getPan(), mAudioPlaybackHandler, this, getCallingApp(), mEventLogger);
}","{
    return new PlaybackSynthesisCallback(getStreamType(), getVolume(), getPan(), mAudioPlaybackHandler, this, getCallerIdentity(), mEventLogger);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the implementation has changed from createSynthesisCallback() to getCallerIdentity(), also the dependent API getCallingApp() changed to getCallerIdentity(), so the code change type is 1,5.","The change of dependent API and return statement may make the API potentially return a different value, so the CI type is 1."
718,"<android.widget.GridLayout: int getMeasurementIncludingMargin(View,boolean)>",15,16,"<android.widget.GridLayout: int getMeasurementIncludingMargin(View,boolean)>","<android.widget.GridLayout: int getMeasurementIncludingMargin(View,boolean)>",0,"{
    if (isGone(c)) {
        return 0;
    }
    return getMeasurement(c, horizontal) + getTotalMargin(c, horizontal);
}","{
    if (c.getVisibility() == View.GONE) {
        return 0;
    }
    return getMeasurement(c, horizontal) + getTotalMargin(c, horizontal);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"In the code, the condition for the if statement has changed from ""isGone(c)"" to ""c.getVisibility() == View.GONE"", so the code change type is 4.","The change of condition in if statement could potentially lead to different returned value. Hence, the potential Compatibility Issue type is 1."
719,"<android.view.View: boolean awakenScrollBars(int,boolean)>",15,16,"<android.view.View: boolean awakenScrollBars(int,boolean)>","<android.view.View: boolean awakenScrollBars(int,boolean)>",0,"{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            invalidate(true);
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}","{
    final ScrollabilityCache scrollCache = mScrollCache;
    if (scrollCache == null || !scrollCache.fadeScrollBars) {
        return false;
    }
    if (scrollCache.scrollBar == null) {
        scrollCache.scrollBar = new ScrollBarDrawable();
    }
    if (isHorizontalScrollBarEnabled() || isVerticalScrollBarEnabled()) {
        if (invalidate) {
            // Invalidate to show the scrollbars
            postInvalidateOnAnimation();
        }
        if (scrollCache.state == ScrollabilityCache.OFF) {
            // FIXME: this is copied from WindowManagerService.
            // We should get this value from the system when it
            // is possible to do so.
            final int KEY_REPEAT_FIRST_DELAY = 750;
            startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
        }
        // Tell mScrollCache when we should start fading. This may
        // extend the fade start time if one was already scheduled
        long fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
        scrollCache.fadeStartTime = fadeStartTime;
        scrollCache.state = ScrollabilityCache.ON;
        // Schedule our fader to run, unscheduling any old ones first
        if (mAttachInfo != null) {
            mAttachInfo.mHandler.removeCallbacks(scrollCache);
            mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
        }
        return true;
    }
    return false;
}",1,"/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked everytime a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Wheter this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
","/**
 * <p>
 * Trigger the scrollbars to draw. When invoked this method starts an
 * animation to fade the scrollbars out after a fixed delay. If a subclass
 * provides animated scrolling, the start delay should equal the duration of
 * the scrolling animation.
 * </p>
 *
 * <p>
 * The animation starts only if at least one of the scrollbars is enabled,
 * as specified by {@link #isHorizontalScrollBarEnabled()} and
 * {@link #isVerticalScrollBarEnabled()}. When the animation is started,
 * this method returns true, and false otherwise. If the animation is
 * started, this method calls {@link #invalidate()} if the invalidate parameter
 * is set to true; in that case the caller
 * should not call {@link #invalidate()}.
 * </p>
 *
 * <p>
 * This method should be invoked everytime a subclass directly updates the
 * scroll parameters.
 * </p>
 *
 * @param startDelay the delay, in milliseconds, after which the animation
 * should start; when the delay is 0, the animation starts
 * immediately
 *
 * @param invalidate Wheter this method should call invalidate
 *
 * @return true if the animation is played, false otherwise
 *
 * @see #scrollBy(int, int)
 * @see #scrollTo(int, int)
 * @see #isHorizontalScrollBarEnabled()
 * @see #isVerticalScrollBarEnabled()
 * @see #setHorizontalScrollBarEnabled(boolean)
 * @see #setVerticalScrollBarEnabled(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The 'invalidate(true);' statement has changed to 'postInvalidateOnAnimation();', so the code change type is 4.","The change is an internal implementation detail that does not affect the output or exceptions of the function, therefore, no compatibility issue exist."
721,<android.webkit.CookieManager: void setAcceptCookie(boolean)>,15,16,<android.webkit.CookieManager: void setAcceptCookie(boolean)>,<android.webkit.CookieManager: void setAcceptCookie(boolean)>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        nativeSetAcceptCookie(accept);
        return;
    }
    mAcceptCookie = accept;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Control whether cookie is enabled or disabled
 * @param accept TRUE if accept cookie
 */
","/**
 * Sets whether the application's {@link WebView} instances should send and
 * accept cookies.
 *
 * @param accept whether {@link WebView} instances should send and accept
 * cookies
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The entire function implementation has been replaced with a throw statement, so the code change type is 1,2.","In the early version, the function setAcceptCookie will execute some logic based on the condition. However, in the late version, no matter what, a MustOverrideException is going to be thrown. Therefore, the method has the potential to return different results and throw different exceptions, and the CI type is 1,2."
722,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,15,16,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>,0,"{
    mBuiltInZoomControls = enabled;
    mWebView.updateMultiTouchSupport(mContext);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Sets whether the zoom mechanism built into WebView is used.
 */
","// {@link WebView#getZoomControls}, which is now hidden.
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The previous implementation is replaced with an exception throw 'throw new MustOverrideException()', so the change type is 2.","The late version API can always throw an exception which is different than the early version API. Thus, the CI type is 2."
724,<android.nfc.NdefRecord: NdefRecord createUri(Uri)>,15,16,<android.nfc.NdefRecord: NdefRecord createUri(Uri)>,<android.nfc.NdefRecord: NdefRecord createUri(Uri)>,0,"{
    return createUri(uri.toString());
}","{
    if (uri == null)
        throw new NullPointerException(""uri is null"");
    uri = uri.normalizeScheme();
    String uriString = uri.toString();
    if (uriString.length() == 0)
        throw new IllegalArgumentException(""uri is empty"");
    byte prefix = 0;
    for (int i = 1; i < URI_PREFIX_MAP.length; i++) {
        if (uriString.startsWith(URI_PREFIX_MAP[i])) {
            prefix = (byte) i;
            uriString = uriString.substring(URI_PREFIX_MAP[i].length());
            break;
        }
    }
    byte[] uriBytes = uriString.getBytes(Charsets.UTF_8);
    byte[] recordBytes = new byte[uriBytes.length + 1];
    recordBytes[0] = prefix;
    System.arraycopy(uriBytes, 0, recordBytes, 1, uriBytes.length);
    return new NdefRecord(TNF_WELL_KNOWN, RTD_URI, null, recordBytes);
}",1,"/**
 * Creates an NDEF record of well known type URI.
 */
","/**
 * Create a new NDEF Record containing a URI.<p>
 * Use this method to encode a URI (or URL) into an NDEF Record.<p>
 * Uses the well known URI type representation: {@link #TNF_WELL_KNOWN}
 * and {@link #RTD_URI}. This is the most efficient encoding
 * of a URI into NDEF.<p>
 * The uri parameter will be normalized with
 * {@link Uri#normalizeScheme} to set the scheme to lower case to
 * follow Android best practices for intent filtering.
 * However the unchecked exception
 * {@link IllegalArgumentException} may be thrown if the uri
 * parameter has serious problems, for example if it is empty, so always
 * catch this exception if you are passing user-generated data into this
 * method.<p>
 *
 * Reference specification: NFCForum-TS-RTD_URI_1.0
 *
 * @param uri URI to encode.
 * @return an NDEF Record containing the URI
 * @throws IllegalArugmentException if the uri is empty or invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","In the late version, several more checks and operations on the input uri are introduced before the return statement and exception statements are introduced in case uri is null or empty. So, the code change type includes all types: 1(return statement changed), 2(exception handling changed), 3(control dependency changed), and 4(other statement changed).","The added error checkings and normalizations on the 'uri' object can throw different exceptions and return different records based on the same input compared to the early version, thus the compatibility issue type is 1,2."
727,<android.widget.TextView: void setCursorVisible(boolean)>,15,16,<android.widget.TextView: void setCursorVisible(boolean)>,<android.widget.TextView: void setCursorVisible(boolean)>,0,"{
    if (mCursorVisible != visible) {
        mCursorVisible = visible;
        invalidate();
        makeBlink();
        // InsertionPointCursorController depends on mCursorVisible
        prepareCursorControllers();
    }
}","{
    // visible is the default value with no edit data
    if (visible && mEditor == null)
        return;
    createEditorIfNeeded();
    if (mEditor.mCursorVisible != visible) {
        mEditor.mCursorVisible = visible;
        invalidate();
        mEditor.makeBlink();
        // InsertionPointCursorController depends on mCursorVisible
        mEditor.prepareCursorControllers();
    }
}",1,"/**
 * Set whether the cursor is visible.  The default is true.
 *
 * @attr ref android.R.styleable#TextView_cursorVisible
 */
","/**
 * Set whether the cursor is visible. The default is true. Note that this property only
 * makes sense for editable TextView.
 *
 * @see #isCursorVisible()
 *
 * @attr ref android.R.styleable#TextView_cursorVisible
 */
",-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early implementation checks for inequality between mCursorVisible and visible, if not equal, assigns mCursorVisible to visible and carries out operations after it. On the other hand, the late version added an extra check on mEditor before performing a similar operation but the operation is performed on mEditor object and new return statement was introduced, so the code change type is 1,3,4.","The introduction of a new return statement and change in the condition statement and several other statements make the late version of API potentially have different behavior. This may cause it to return a different value, so the CI type is 1."
729,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,15,16,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>,0,"{
    if (mJavaScriptCanOpenWindowsAutomatically != flag) {
        mJavaScriptCanOpenWindowsAutomatically = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell javascript to open windows automatically. This applies to the
 * javascript function window.open().
 * @param flag True if javascript can open windows automatically.
 */
","/**
 * Tells JavaScript to open windows automatically. This applies to the
 * JavaScript function window.open(). The default is false.
 *
 * @param flag true if JavaScript can open windows automatically
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the Early_Implementation, setJavaScriptCanOpenWindowsAutomatically() was a functioning method, but in the Late_Implementation, it has been changed to throw a MustOverrideException(). Hence, the change type is 1,2.","The change of behavior from operating normally to throwing an exception could definitely result in a compatibility issue. Regardless of the input, the late version of this API will always throw a 'MustOverrideException' while the early version won't. Therefore, the CI type is 1,2."
730,"<android.os.Handler: boolean hasMessages(int,Object)>",15,16,"<android.os.Handler: boolean hasMessages(int,Object)>","<android.os.Handler: boolean hasMessages(int,Object)>",0,"{
    return mQueue.removeMessages(this, what, object, false);
}","{
    return mQueue.hasMessages(this, what, object);
}",1,"/**
 * Check if there are any pending posts of messages with code 'what' and
 * whose obj is 'object' in the message queue.
 */
","/**
 * Check if there are any pending posts of messages with code 'what' and
 * whose obj is 'object' in the message queue.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 5",1,"The return statement and dependent API has changed from mQueue.removeMessages(this, what, object, false) to mQueue.hasMessages(this, what, object), so the code change type is 1, 5.",The change in the return statement and the method change from removeMessages to hasMessages might potentially lead this API to return a different value. Meaning the compatibility issue type is 1.
734,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,15,16,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    int action = ev.getAction();
    View v;
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded(y)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}","{
    int action = ev.getAction();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!mIsAttached) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded(y)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The conditional statement 'if (mPositionScroller != null)' and 'if (!mIsAttached)' have been added and the statement 'mPositionScroller.stop();' has been introduced in the later version. Hence, the change type is 3,4.","By adding new conditional statements and statements, the execution flow of the program is affected, and this could potentially lead to changes in the return value. Therefore, the CI is potentially caused by different return values, assisting to a CI type 1."
737,<android.animation.ValueAnimator: long getStartDelay()>,15,16,<android.animation.ValueAnimator: long getStartDelay()>,<android.animation.ValueAnimator: long getStartDelay()>,0,"{
    return mStartDelay;
}","{
    return mUnscaledStartDelay;
}",1,"/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called.
 *
 * @return the number of milliseconds to delay running the animation
 */
","/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called.
 *
 * @return the number of milliseconds to delay running the animation
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mStartDelay;' to 'return mUnscaledStartDelay;', so the code change type is 1.","The change of the return statement may cause the API to return a different value in the later version, so the CI type is 1."
740,<android.widget.NumberPicker: void setMinValue(int)>,15,16,<android.widget.NumberPicker: void setMinValue(int)>,<android.widget.NumberPicker: void setMinValue(int)>,0,"{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
}","{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}",1,"/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value.
 */
","/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new line 'invalidate()' added at the end of the method in the Late implementation, which indicates that the class type is 4 (Other statement changed).","The added method 'invalidate()' in the late version does not affect the return value nor exceptions thrown by the method. So, it falls into the category 0 (No Compatibility Issue exists)."
741,<android.webkit.WebSettings: void setFantasyFontFamily(String)>,15,16,<android.webkit.WebSettings: void setFantasyFontFamily(String)>,<android.webkit.WebSettings: void setFantasyFontFamily(String)>,0,"{
    if (font != null && !font.equals(mFantasyFontFamily)) {
        mFantasyFontFamily = font;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the fantasy font family name.
 * @param font A font family name.
 */
","/**
 * Sets the fantasy font family name. The default is ""fantasy"".
 *
 * @param font a font family name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","All of the original implementation in early version has been removed and replaced by a new exception statement in later version, hence the change type includes 1 and 2.","The newly introduced `throw new MustOverrideException();` statement will cause a different behavior. Moreover, considering this API will no longer return the same value, hence compatibility issues of types  1 and 2 exist."
742,<android.os.Parcel: ParcelFileDescriptor readFileDescriptor()>,15,16,<android.os.Parcel: ParcelFileDescriptor readFileDescriptor()>,<android.os.Parcel: ParcelFileDescriptor readFileDescriptor()>,0,"{
    FileDescriptor fd = internalReadFileDescriptor();
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}","{
    FileDescriptor fd = nativeReadFileDescriptor(mNativePtr);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}",1,"/**
 * Read a FileDescriptor from the parcel at the current dataPosition().
 */
","/**
 * Read a FileDescriptor from the parcel at the current dataPosition().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The internal API used inside the function changed from internalReadFileDescriptor() to nativeReadFileDescriptor(mNativePtr), so the code change type is 4,5.","Since the internal API used changed, this could potentially lead to different return values, so the Compatibility Issue (CI) type is 1."
744,"<android.view.inputmethod.InputConnectionWrapper: boolean deleteSurroundingText(int,int)>",15,16,"<android.view.inputmethod.InputConnectionWrapper: boolean deleteSurroundingText(int,int)>","<android.view.inputmethod.InputConnectionWrapper: boolean deleteSurroundingText(int,int)>",0,"{
    return mTarget.deleteSurroundingText(leftLength, rightLength);
}","{
    return mTarget.deleteSurroundingText(beforeLength, afterLength);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The parameters of the method deleteSurroundingText() have been changed, leading the code change type to be classified as 1,5.","The CI comes from the altered parameters in the deleteSurroundingText() method, potentially causing the return value to be different and implying that the CI type is 1."
745,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,15,16,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mIsBeingDragged = getChildCount() != 0;
                if (!mIsBeingDragged) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float x = ev.getX(activePointerIndex);
                final int deltaX = (int) (mLastMotionX - x);
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The conditions under the MotionEvent.ACTION_DOWN and MotionEvent.ACTION_MOVE have been changed, that's the reason for classifying it under control dependency changed (3). Additionally, method calls to invalidate() in the early implementation have been changed to postInvalidateOnAnimation() in the late implementation, which does not fall into any other specific category; hence, this is classified as Other statement changed (4).","The change in control dependencies and other statements could potentially affect the behavior of the API, especially since the late version includes difference in view invalidation and motion event processing, which could result in different return values on execution, hence causing it to fall under Compatibility Issue caused by potential different return values or types (1)."
746,"<android.webkit.CacheManager: CacheResult getCacheFile(String,long,Map<String, String>)>",15,16,"<android.webkit.CacheManager: CacheResult getCacheFile(String,long,Map<String, String>)>","<android.webkit.CacheManager: CacheResult getCacheFile(String,long,Map<String, String>)>",0,"{
    if (mDisabled) {
        return null;
    }
    if (JniUtil.useChromiumHttpStack()) {
        CacheResult result = nativeGetCacheResult(url);
        if (result == null) {
            return null;
        }
        // A temporary local file will have been created native side and localPath set
        // appropriately.
        File src = new File(mBaseDir, result.localPath);
        try {
            // Open the file here so that even if it is deleted, the content
            // is still readable by the caller until close() is called.
            result.inStream = new FileInputStream(src);
        } catch (FileNotFoundException e) {
            Log.v(LOGTAG, ""getCacheFile(): Failed to open file: "" + e);
            // system. If it is gone, what should we do?
            return null;
        }
        return result;
    }
    String databaseKey = getDatabaseKey(url, postIdentifier);
    CacheResult result = mDataBase.getCache(databaseKey);
    if (result == null) {
        return null;
    }
    if (result.contentLength == 0) {
        if (!isCachableRedirect(result.httpStatusCode)) {
            // This should not happen. If it does, remove it.
            mDataBase.removeCache(databaseKey);
            return null;
        }
    } else {
        File src = new File(mBaseDir, result.localPath);
        try {
            // Open the file here so that even if it is deleted, the content
            // is still readable by the caller until close() is called.
            result.inStream = new FileInputStream(src);
        } catch (FileNotFoundException e) {
            // The files in the cache directory can be removed by the
            // system. If it is gone, clean up the database.
            mDataBase.removeCache(databaseKey);
            return null;
        }
    }
    // Note that a negative expires value means a time in the far future.
    if (headers != null && result.expires >= 0 && result.expires <= System.currentTimeMillis()) {
        if (result.lastModified == null && result.etag == null) {
            return null;
        }
        // for requesting validation.
        if (result.etag != null) {
            headers.put(HEADER_KEY_IFNONEMATCH, result.etag);
        }
        if (result.lastModified != null) {
            headers.put(HEADER_KEY_IFMODIFIEDSINCE, result.lastModified);
        }
    }
    if (DebugFlags.CACHE_MANAGER) {
        Log.v(LOGTAG, ""getCacheFile for url "" + url);
    }
    return result;
}","{
    CacheResult result = nativeGetCacheResult(url);
    if (result == null) {
        return null;
    }
    // A temporary local file will have been created native side and localPath set
    // appropriately.
    File src = new File(mBaseDir, result.localPath);
    try {
        // Open the file here so that even if it is deleted, the content
        // is still readable by the caller until close() is called.
        result.inStream = new FileInputStream(src);
    } catch (FileNotFoundException e) {
        Log.v(LOGTAG, ""getCacheFile(): Failed to open file: "" + e);
        // system. If it is gone, what should we do?
        return null;
    }
    // Note that a negative expires value means a time in the far future.
    if (headers != null && result.expires >= 0 && result.expires <= System.currentTimeMillis()) {
        if (result.lastModified == null && result.etag == null) {
            return null;
        }
        // for requesting validation.
        if (result.etag != null) {
            headers.put(HEADER_KEY_IFNONEMATCH, result.etag);
        }
        if (result.lastModified != null) {
            headers.put(HEADER_KEY_IFMODIFIEDSINCE, result.lastModified);
        }
    }
    if (DebugFlags.CACHE_MANAGER) {
        Log.v(LOGTAG, ""getCacheFile for url "" + url);
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Several code blocks have been deleted which changed the control flow as well as the return statement, so the change types are 1,3,4.","The removal of certain code blocks will mean that the function may not behave as previously, potentially returning a different value (different control dependence and return statement), hence the CI type is 1."
747,<android.webkit.WebIconDatabase: void removeAllIcons()>,15,16,<android.webkit.WebIconDatabase: void removeAllIcons()>,<android.webkit.WebIconDatabase: void removeAllIcons()>,0,"{
    mEventHandler.postMessage(Message.obtain(null, EventHandler.REMOVE_ALL));
}","{
    throw new MustOverrideException();
}",1,"/**
 * Removes all the icons in the database.
 */
","/**
 * Removes all the icons in the database.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The function in the early version is removed and replaced by a new throw statement, which is regarded as an exception handling statement change and an other statement change. So, the code change type is 2,4.","The change from normal function behavior to an exception thrown situation would lead to different behaviors of the function between early version and late version, making it potentially throws different exceptions. So, the CI type is 2."
748,"<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>",15,16,"<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>","<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>",0,"{
    if (mNativeClass == 0) {
        return false;
    }
    // the necessary components (e.g., WebTextView if it is in editing mode)
    if (mZoomManager.isFixedLengthAnimationInProgress()) {
        return false;
    }
    rect.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
    Rect content = new Rect(viewToContentX(mScrollX), viewToContentY(mScrollY), viewToContentX(mScrollX + getWidth() - getVerticalScrollbarWidth()), viewToContentY(mScrollY + getViewHeightWithTitle()));
    content = nativeSubtractLayers(content);
    int screenTop = contentToViewY(content.top);
    int screenBottom = contentToViewY(content.bottom);
    int height = screenBottom - screenTop;
    int scrollYDelta = 0;
    if (rect.bottom > screenBottom) {
        int oneThirdOfScreenHeight = height / 3;
        if (rect.height() > 2 * oneThirdOfScreenHeight) {
            // If the rectangle is too tall to fit in the bottom two thirds
            // of the screen, place it at the top.
            scrollYDelta = rect.top - screenTop;
        } else {
            // If the rectangle will still fit on screen, we want its
            // top to be in the top third of the screen.
            scrollYDelta = rect.top - (screenTop + oneThirdOfScreenHeight);
        }
    } else if (rect.top < screenTop) {
        scrollYDelta = rect.top - screenTop;
    }
    int screenLeft = contentToViewX(content.left);
    int screenRight = contentToViewX(content.right);
    int width = screenRight - screenLeft;
    int scrollXDelta = 0;
    if (rect.right > screenRight && rect.left > screenLeft) {
        if (rect.width() > width) {
            scrollXDelta += (rect.left - screenLeft);
        } else {
            scrollXDelta += (rect.right - screenRight);
        }
    } else if (rect.left < screenLeft) {
        scrollXDelta -= (screenLeft - rect.left);
    }
    if ((scrollYDelta | scrollXDelta) != 0) {
        return pinScrollBy(scrollXDelta, scrollYDelta, !immediate, 0);
    }
    return false;
}","{
    return mProvider.getViewDelegate().requestChildRectangleOnScreen(child, rect, immediate);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of this API has completely changed. In the early version, it includes a bunch of calculations and calls to different methods of this class, but in the late version, it directly calls a method of the `mProvider.getViewDelegate()` object. The return statements, the API dependent methods and other statements have all changed so the code change type is 1,4,5.","As the implementation entirely changed from manual calculations to a dependent API call and the return statement also changed, the API potentially returns a different boolean value between two continuous versions. Therefore, the CI type is 1."
750,<android.webkit.GeolocationPermissions: GeolocationPermissions getInstance()>,15,16,<android.webkit.GeolocationPermissions: GeolocationPermissions getInstance()>,<android.webkit.GeolocationPermissions: GeolocationPermissions getInstance()>,0,"{
    if (sInstance == null) {
        sInstance = new GeolocationPermissions();
    }
    return sInstance;
}","{
    return WebViewFactory.getProvider().getGeolocationPermissions();
}",1,"/**
 * Gets the singleton instance of the class.
 */
","/**
 * Gets the singleton instance of this class.
 *
 * @return the singleton {@link GeolocationPermissions} instance
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement change from the early version to the late version causes the code to be detected as change type 1 and 5 which is return statement changed and dependent API changed. The earlier version uses sInstance variable for maintaining singleton instance of class whereas, in the late version, uses the getProvider().getGeolocationPermissions() method from the WebViewFactory API.","As the late version now uses a method that potentially can return different data based on implementation, the API could return a different value. Therefore, the Compatibility Issue (CI) type is 1."
753,<android.widget.TextView: boolean onPreDraw()>,15,16,<android.widget.TextView: boolean onPreDraw()>,<android.widget.TextView: boolean onPreDraw()>,0,"{
    if (mPreDrawState != PREDRAW_PENDING) {
        return true;
    }
    if (mLayout == null) {
        assumeLayout();
    }
    boolean changed = false;
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mSelectionModifierCursorController != null && mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            changed = bringPointIntoView(curs);
        }
    } else {
        changed = bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mCreatedWithASelection) {
        startSelectionActionMode();
        mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection()) {
        startSelectionActionMode();
    }
    mPreDrawState = PREDRAW_DONE;
    return !changed;
}","{
    if (mLayout == null) {
        assumeLayout();
    }
    boolean changed = false;
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            changed = bringPointIntoView(curs);
        }
    } else {
        changed = bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    getViewTreeObserver().removeOnPreDrawListener(this);
    mPreDrawRegistered = false;
    return !changed;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,There are multiple changes in the code:,"3) At the end, two new lines `getViewTreeObserver().removeOnPreDrawListener(this);` and `mPreDrawRegistered = false;` have been added."
754,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",15,16,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    try {
        AssetFileDescriptor fd = provider.openTypedAssetFile(uri, mimeType, opts);
        if (fd == null) {
            // The provider will be released by the finally{} clause
            return null;
        }
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), provider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        provider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        throw new FileNotFoundException(""Dead content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (provider != null) {
            releaseProvider(provider);
        }
    }
}","{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        try {
            fd = unstableProvider.openTypedAssetFile(uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","In both versions, the return statements, and try-catch blocks have changed significantly, including the methods called within the try block and the exceptions thrown within the catch blocks. Moreover, the control flow in the try-catch block has also been modified, such as the introduction of a new catch block for 'DeadObjectException'. Finally, changes in the dependent APIs like releaseProvider and acquireProvider also exist. Therefore, the code change type is classified as 1,2,3,4,5.","Changes to the catch statements might result in this method throwing different exceptions in different versions. The introduction of a new return null statement under two branches in the second version may also result in this method returning different values in different versions. Hence, the Compatibility Issue (CI) type is classified as 1,2, covering both potential differences in return values/types and potential differences in exception handlings."
755,<android.view.View: void buildDrawingCache(boolean)>,15,16,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !use32BitCache ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !use32BitCache ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation of the API between the early version and the late version.,There are no compatibility issues since there are no changes in the API implementation.
756,<android.webkit.WebSettings: boolean getUseWebViewBackgroundForOverscrollBackground()>,15,16,<android.webkit.WebSettings: boolean getUseWebViewBackgroundForOverscrollBackground()>,<android.webkit.WebSettings: boolean getUseWebViewBackgroundForOverscrollBackground()>,0,"{
    return mUseWebViewBackgroundForOverscroll;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if this WebView uses WebView's background instead of
 * internal pattern for over scroll background.
 * @deprecated This method is now obsolete.
 */
","/**
 * Gets whether this WebView uses WebView's background instead of
 * internal pattern for over scroll background.
 *
 * @see #setUseWebViewBackgroundForOverscrollBackground
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2","1,2","The early implementation of this method returns a boolean value but in the late version, it throws a new exception which indicates a change in both return and exception handling statements; thus, the code change types are 1 and 2.","The change from returning a value to throwing an exception is a drastic behavior change. Hence, this would lead to both types of compatibility issues: Compatibility Issue caused by potential different return values or types and Compatibility Issue caused by potential different exception handlings. Therefore, the CI types are 1 and 2."
757,<android.nfc.NdefMessage: byte[] toByteArray()>,15,16,<android.nfc.NdefMessage: byte[] toByteArray()>,<android.nfc.NdefMessage: byte[] toByteArray()>,0,"{
    // TODO: process MB and ME flags outside loop
    if ((mRecords == null) || (mRecords.length == 0))
        return new byte[0];
    byte[] msg = {};
    for (int i = 0; i < mRecords.length; i++) {
        byte[] record = mRecords[i].toByteArray();
        byte[] tmp = new byte[msg.length + record.length];
        /* Make sure the Message Begin flag is set only for the first record */
        if (i == 0) {
            record[0] |= FLAG_MB;
        } else {
            record[0] &= ~FLAG_MB;
        }
        /* Make sure the Message End flag is set only for the last record */
        if (i == (mRecords.length - 1)) {
            record[0] |= FLAG_ME;
        } else {
            record[0] &= ~FLAG_ME;
        }
        System.arraycopy(msg, 0, tmp, 0, msg.length);
        System.arraycopy(record, 0, tmp, msg.length, record.length);
        msg = tmp;
    }
    return msg;
}","{
    int length = getByteArrayLength();
    ByteBuffer buffer = ByteBuffer.allocate(length);
    for (int i = 0; i < mRecords.length; i++) {
        // first record
        boolean mb = (i == 0);
        // last record
        boolean me = (i == mRecords.length - 1);
        mRecords[i].writeToByteBuffer(buffer, mb, me);
    }
    return buffer.array();
}",1,"/**
 * Returns a byte array representation of this entire NDEF message.
 */
","/**
 * Return this NDEF Message as raw bytes.<p>
 * The NDEF Message is formatted as per the NDEF 1.0 specification,
 * and the byte array is suitable for network transmission or storage
 * in an NFC Forum NDEF compatible tag.<p>
 * This method will not chunk any records, and will always use the
 * short record (SR) format and omit the identifier field when possible.
 *
 * @return NDEF Message in binary format
 * @see getByteArrayLength
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The statements inside the 'for' loop, including return message, have changed from manually handling the byte array to using ByteBuffer, hence the change type is 1,4.","Because of the changes inside the 'for' loop, the returned byte array may have different contents between the two implementations, indicating a compatibility issue. Thus, the CI type is 1."
758,<android.server.BluetoothService: boolean enable()>,15,16,<android.server.BluetoothService: boolean enable()>,<android.server.BluetoothService: boolean enable()>,0,"{
    return enable(true);
}","{
    return enable(true, true);
}",1,"/**
 * Bring up BT and persist BT on in settings
 */
","/**
 * Bring up BT and persist BT on in settings
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from enable(true) to enable(true, true) and the parameter type of enable() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
761,<android.webkit.WebSettings: void setLoadsImagesAutomatically(boolean)>,15,16,<android.webkit.WebSettings: void setLoadsImagesAutomatically(boolean)>,<android.webkit.WebSettings: void setLoadsImagesAutomatically(boolean)>,0,"{
    if (mLoadsImagesAutomatically != flag) {
        mLoadsImagesAutomatically = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to load image resources automatically.
 * @param flag True if the WebView should load images automatically.
 */
","/**
 * Sets whether the WebView should load image resources. Note that this method
 * controls loading of all images, including those embedded using the data
 * URI scheme. Use {@link #setBlockNetworkImage} to control loading only
 * of images specified using network URI schemes. Note that if the value of this
 * setting is changed from false to true, all images resources referenced
 * by content currently displayed by the WebView are loaded automatically.
 * The default is true.
 *
 * @param flag whether the WebView should load image resources
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The early version implementation of the method has been replaced with a 'throw new MustOverrideException()' in the late version. This is a change in the exception handling statement, hence the code change type is 2.","Since the late version of the method introduces a new exception throwing statement, if the late version is invoked, it would throw 'MustOverrideException' while the early version does not. This leads to a significant difference in behavior, hence a compatibility issue exists. The CI type is 2."
764,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",15,16,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>","<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",0,"{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate;
    if (timeZone != null) {
        startDate = new Time(timeZone);
    } else if (useUTC) {
        startDate = new Time(Time.TIMEZONE_UTC);
    } else {
        startDate = new Time();
    }
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endDate = new Time(timeZone);
        } else if (useUTC) {
            endDate = new Time(Time.TIMEZONE_UTC);
        } else {
            endDate = new Time();
        }
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    // adjust the date.
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}","{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate;
    if (timeZone != null) {
        startDate = new Time(timeZone);
    } else if (useUTC) {
        startDate = new Time(Time.TIMEZONE_UTC);
    } else {
        startDate = new Time();
    }
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endDate = new Time(timeZone);
        } else if (useUTC) {
            endDate = new Time(Time.TIMEZONE_UTC);
        } else {
            endDate = new Time();
        }
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}",1,"/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
","/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * <p>
 * If the end date ends at 12:00am at the beginning of a day, it is
 * formatted as the end of the previous day in two scenarios:
 * <ul>
 * <li>For single day events. This results in ""8pm - midnight"" instead of
 * ""Nov 10, 8pm - Nov 11, 12am"".</li>
 * <li>When the time is not displayed. This results in ""Nov 10 - 11"" for
 * an event with a start date of Nov 10 and an end date of Nov 12 at
 * 00:00.</li>
 * </ul>
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
765,<android.database.sqlite.SQLiteDatabase: boolean enableWriteAheadLogging()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean enableWriteAheadLogging()>,<android.database.sqlite.SQLiteDatabase: boolean enableWriteAheadLogging()>,0,"{
    // make sure the database is not READONLY. WAL doesn't make sense for readonly-databases.
    if (isReadOnly()) {
        return false;
    }
    // acquire lock - no that no other thread is enabling WAL at the same time
    lock();
    try {
        if (mConnectionPool != null) {
            // already enabled
            return true;
        }
        if (mPath.equalsIgnoreCase(MEMORY_DB_PATH)) {
            Log.i(TAG, ""can't enable WAL for memory databases."");
            return false;
        }
        // doesn't work for databases with attached databases
        if (mHasAttachedDbs) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, ""this database: "" + mPath + "" has attached databases. can't  enable WAL."");
            }
            return false;
        }
        mConnectionPool = new DatabaseConnectionPool(this);
        setJournalMode(mPath, ""WAL"");
        return true;
    } finally {
        unlock();
    }
}","{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        if ((mConfigurationLocked.openFlags & ENABLE_WRITE_AHEAD_LOGGING) != 0) {
            return true;
        }
        if (isReadOnlyLocked()) {
            // TODO: True, but connection pooling does still make sense...
            return false;
        }
        if (mConfigurationLocked.isInMemoryDb()) {
            Log.i(TAG, ""can't enable WAL for memory databases."");
            return false;
        }
        // doesn't work for databases with attached databases
        if (mHasAttachedDbsLocked) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, ""this database: "" + mConfigurationLocked.label + "" has attached databases. can't  enable WAL."");
            }
            return false;
        }
        mConfigurationLocked.openFlags |= ENABLE_WRITE_AHEAD_LOGGING;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
            throw ex;
        }
    }
    return true;
}",1,"/**
 * This method enables parallel execution of queries from multiple threads on the same database.
 * It does this by opening multiple handles to the database and using a different
 * database handle for each query.
 * <p>
 * If a transaction is in progress on one connection handle and say, a table is updated in the
 * transaction, then query on the same table on another connection handle will block for the
 * transaction to complete. But this method enables such queries to execute by having them
 * return old version of the data from the table. Most often it is the data that existed in the
 * table prior to the above transaction updates on that table.
 * <p>
 * Maximum number of simultaneous handles used to execute queries in parallel is
 * dependent upon the device memory and possibly other properties.
 * <p>
 * After calling this method, execution of queries in parallel is enabled as long as this
 * database handle is open. To disable execution of queries in parallel, database should
 * be closed and reopened.
 * <p>
 * If a query is part of a transaction, then it is executed on the same database handle the
 * transaction was begun.
 * <p>
 * If the database has any attached databases, then execution of queries in paralel is NOT
 * possible. In such cases, a message is printed to logcat and false is returned.
 * <p>
 * This feature is not available for :memory: databases. In such cases,
 * a message is printed to logcat and false is returned.
 * <p>
 * A typical way to use this method is the following:
 * <pre>
 * SQLiteDatabase db = SQLiteDatabase.openDatabase(""db_filename"", cursorFactory,
 * CREATE_IF_NECESSARY, myDatabaseErrorHandler);
 * db.enableWriteAheadLogging();
 * </pre>
 * <p>
 * Writers should use {@link #beginTransactionNonExclusive()} or
 * {@link #beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)}
 * to start a trsnsaction.
 * Non-exclusive mode allows database file to be in readable by threads executing queries.
 * </p>
 *
 * @return true if write-ahead-logging is set. false otherwise
 */
","/**
 * This method enables parallel execution of queries from multiple threads on the
 * same database.  It does this by opening multiple connections to the database
 * and using a different database connection for each query.  The database
 * journal mode is also changed to enable writes to proceed concurrently with reads.
 * <p>
 * When write-ahead logging is not enabled (the default), it is not possible for
 * reads and writes to occur on the database at the same time.  Before modifying the
 * database, the writer implicitly acquires an exclusive lock on the database which
 * prevents readers from accessing the database until the write is completed.
 * </p><p>
 * In contrast, when write-ahead logging is enabled (by calling this method), write
 * operations occur in a separate log file which allows reads to proceed concurrently.
 * While a write is in progress, readers on other threads will perceive the state
 * of the database as it was before the write began.  When the write completes, readers
 * on other threads will then perceive the new state of the database.
 * </p><p>
 * It is a good idea to enable write-ahead logging whenever a database will be
 * concurrently accessed and modified by multiple threads at the same time.
 * However, write-ahead logging uses significantly more memory than ordinary
 * journaling because there are multiple connections to the same database.
 * So if a database will only be used by a single thread, or if optimizing
 * concurrency is not very important, then write-ahead logging should be disabled.
 * </p><p>
 * After calling this method, execution of queries in parallel is enabled as long as
 * the database remains open.  To disable execution of queries in parallel, either
 * call {@link #disableWriteAheadLogging} or close the database and reopen it.
 * </p><p>
 * The maximum number of connections used to execute queries in parallel is
 * dependent upon the device memory and possibly other properties.
 * </p><p>
 * If a query is part of a transaction, then it is executed on the same database handle the
 * transaction was begun.
 * </p><p>
 * Writers should use {@link #beginTransactionNonExclusive()} or
 * {@link #beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)}
 * to start a transaction.  Non-exclusive mode allows database file to be in readable
 * by other threads executing queries.
 * </p><p>
 * If the database has any attached databases, then execution of queries in parallel is NOT
 * possible.  Likewise, write-ahead logging is not supported for read-only databases
 * or memory databases.  In such cases, {@link #enableWriteAheadLogging} returns false.
 * </p><p>
 * The best way to enable write-ahead logging is to pass the
 * {@link #ENABLE_WRITE_AHEAD_LOGGING} flag to {@link #openDatabase}.  This is
 * more efficient than calling {@link #enableWriteAheadLogging}.
 * <code><pre>
 * SQLiteDatabase db = SQLiteDatabase.openDatabase(""db_filename"", cursorFactory,
 * SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING,
 * myDatabaseErrorHandler);
 * db.enableWriteAheadLogging();
 * </pre></code>
 * </p><p>
 * Another way to enable write-ahead logging is to call {@link #enableWriteAheadLogging}
 * after opening the database.
 * <code><pre>
 * SQLiteDatabase db = SQLiteDatabase.openDatabase(""db_filename"", cursorFactory,
 * SQLiteDatabase.CREATE_IF_NECESSARY, myDatabaseErrorHandler);
 * db.enableWriteAheadLogging();
 * </pre></code>
 * </p><p>
 * See also <a href=""http://sqlite.org/wal.html"">SQLite Write-Ahead Logging</a> for
 * more details about how write-ahead logging works.
 * </p>
 *
 * @return True if write-ahead logging is enabled.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #ENABLE_WRITE_AHEAD_LOGGING
 * @see #disableWriteAheadLogging
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The code change type is 1,2,3,5 as the return statements have been modified: each branch potentially returns a different result now. Also, the exception handling method has changed: an additional 'throw ex' is introduced in the 'catch' block of late implementation that could cause a potential change of the API's behavior. The control dependency has changed, as the control structure 'synchronized(mLock)' is added. Also, the dependent APIs, such as isReadOnlyLocked() and reconfigure(), are changed.","The CI type is 1 and 2. The modification of return statements and exception handling could lead to a different value being returned or an exception being thrown, which could make the behaviors of the APIs different."
767,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,15,16,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,0,"{
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash STARTS"");
    }
    CookieManager manager = CookieManager.getInstance();
    if (!manager.acceptCookie()) {
        return;
    }
    if (JniUtil.useChromiumHttpStack()) {
        manager.flushCookieStore();
    } else {
        ArrayList<Cookie> cookieList = manager.getUpdatedCookiesSince(mLastUpdate);
        mLastUpdate = System.currentTimeMillis();
        syncFromRamToFlash(cookieList);
        ArrayList<Cookie> lruList = manager.deleteLRUDomain();
        syncFromRamToFlash(lruList);
    }
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash DONE"");
    }
}","{
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash STARTS"");
    }
    CookieManager manager = CookieManager.getInstance();
    if (!manager.acceptCookie()) {
        return;
    }
    manager.flushCookieStore();
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash DONE"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The changes include the removal of the 'if (JniUtil.useChromiumHttpStack())' block and the consequent lines of code inside it which are now replaced by simply 'manager.flushCookieStore();'. So the code changes are classified into return statement changed (1), Dependency Control Change (3) and other statements changed (4).","The change in control structure and implementation statements means that the function could potentially behave differently like returning different values from before due to the different implementation. Hence, it's regarded as a compatibility issue caused by potential different return values (1)."
769,<android.app.Notification.Builder: Notification getNotification()>,15,16,<android.app.Notification.Builder: Notification getNotification()>,<android.app.Notification.Builder: Notification getNotification()>,0,"{
    Notification n = new Notification();
    n.when = mWhen;
    n.icon = mSmallIcon;
    n.iconLevel = mSmallIconLevel;
    n.number = mNumber;
    n.contentView = makeContentView();
    n.contentIntent = mContentIntent;
    n.deleteIntent = mDeleteIntent;
    n.fullScreenIntent = mFullScreenIntent;
    n.tickerText = mTickerText;
    n.tickerView = makeTickerView();
    n.largeIcon = mLargeIcon;
    n.sound = mSound;
    n.audioStreamType = mAudioStreamType;
    n.vibrate = mVibrate;
    n.ledARGB = mLedArgb;
    n.ledOnMS = mLedOnMs;
    n.ledOffMS = mLedOffMs;
    n.defaults = mDefaults;
    n.flags = mFlags;
    if (mLedOnMs != 0 && mLedOffMs != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if ((mDefaults & DEFAULT_LIGHTS) != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    return n;
}","{
    return build();
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * @deprecated Use {@link #build()} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire method body is replaced by a single return statement making a call to the `build()` function, therefor change types is 1,5.","As the whole implementation of the method was changed, it is extremely likely that the function will return a different result, thus the CI type is 1."
770,<android.nfc.NdefRecord: NdefRecord createApplicationRecord(String)>,15,16,<android.nfc.NdefRecord: NdefRecord createApplicationRecord(String)>,<android.nfc.NdefRecord: NdefRecord createApplicationRecord(String)>,0,"{
    return new NdefRecord(TNF_EXTERNAL_TYPE, RTD_ANDROID_APP, new byte[] {}, packageName.getBytes(Charsets.US_ASCII));
}","{
    if (packageName == null)
        throw new NullPointerException(""packageName is null"");
    if (packageName.length() == 0)
        throw new IllegalArgumentException(""packageName is empty"");
    return new NdefRecord(TNF_EXTERNAL_TYPE, RTD_ANDROID_APP, null, packageName.getBytes(Charsets.UTF_8));
}",1,"/**
 * Creates an Android application NDEF record.
 * <p>
 * This record indicates to other Android devices the package
 * that should be used to handle the rest of the NDEF message.
 * You can embed this record anywhere into your NDEF message
 * to ensure that the intended package receives the message.
 * <p>
 * When an Android device dispatches an {@link NdefMessage}
 * containing one or more Android application records,
 * the applications contained in those records will be the
 * preferred target for the NDEF_DISCOVERED intent, in
 * the order in which they appear in the {@link NdefMessage}.
 * This dispatch behavior was first added to Android in
 * Ice Cream Sandwich.
 * <p>
 * If none of the applications are installed on the device,
 * a Market link will be opened to the first application.
 * <p>
 * Note that Android application records do not overrule
 * applications that have called
 * {@link NfcAdapter#enableForegroundDispatch}.
 *
 * @param packageName Android package name
 * @return Android application NDEF record
 */
","/**
 * Create a new Android Application Record (AAR).
 * <p>
 * This record indicates to other Android devices the package
 * that should be used to handle the entire NDEF message.
 * You can embed this record anywhere into your message
 * to ensure that the intended package receives the message.
 * <p>
 * When an Android device dispatches an {@link NdefMessage}
 * containing one or more Android application records,
 * the applications contained in those records will be the
 * preferred target for the {@link NfcAdapter#ACTION_NDEF_DISCOVERED}
 * intent, in the order in which they appear in the message.
 * This dispatch behavior was first added to Android in
 * Ice Cream Sandwich.
 * <p>
 * If none of the applications have a are installed on the device,
 * a Market link will be opened to the first application.
 * <p>
 * Note that Android application records do not overrule
 * applications that have called
 * {@link NfcAdapter#enableForegroundDispatch}.
 *
 * @param packageName Android package name
 * @return Android application NDEF record
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","Two throw statements are introduced in the late version, and the code inside the return statement has changed as well (null in place of new byte[] {}). Also, the condition 'if' statements are added in the late version. Thus, the change type is 1,2,3.","The introduction of new exception conditions can potentially lead to different exception handlings. Plus, the changes in the return statement (different object creation and different encoding in 'getBytes()') may result in different return values. Therefore, the CI type is 1,2."
774,<android.widget.ExpandableListConnector: int getItemViewType(int)>,15,16,<android.widget.ExpandableListConnector: int getItemViewType(int)>,<android.widget.ExpandableListConnector: int getItemViewType(int)>,0,"{
    final ExpandableListPosition pos = getUnflattenedPos(flatListPos).position;
    int retValue;
    if (mExpandableListAdapter instanceof HeterogeneousExpandableList) {
        HeterogeneousExpandableList adapter = (HeterogeneousExpandableList) mExpandableListAdapter;
        if (pos.type == ExpandableListPosition.GROUP) {
            retValue = adapter.getGroupType(pos.groupPos);
        } else {
            final int childType = adapter.getChildType(pos.groupPos, pos.childPos);
            retValue = adapter.getGroupTypeCount() + childType;
        }
    } else {
        if (pos.type == ExpandableListPosition.GROUP) {
            retValue = 0;
        } else {
            retValue = 1;
        }
    }
    pos.recycle();
    return retValue;
}","{
    final PositionMetadata metadata = getUnflattenedPos(flatListPos);
    final ExpandableListPosition pos = metadata.position;
    int retValue;
    if (mExpandableListAdapter instanceof HeterogeneousExpandableList) {
        HeterogeneousExpandableList adapter = (HeterogeneousExpandableList) mExpandableListAdapter;
        if (pos.type == ExpandableListPosition.GROUP) {
            retValue = adapter.getGroupType(pos.groupPos);
        } else {
            final int childType = adapter.getChildType(pos.groupPos, pos.childPos);
            retValue = adapter.getGroupTypeCount() + childType;
        }
    } else {
        if (pos.type == ExpandableListPosition.GROUP) {
            retValue = 0;
        } else {
            retValue = 1;
        }
    }
    metadata.recycle();
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"In the first line, the method getUnflattenedPos(flatListPos) returns different object types (ExpandableListPosition vs PositionMetadata) between two versions. Also, the dependent API recycle() is called on a completely different object (pos vs metadata). So the code change type is 4,5.","The first line of the function - where getUnflattenedPos(flatListPos) returns different types in the two versions - could potentially influence the values that the return statement returns. Therefore, the CI type is 1."
775,<android.text.TextDirectionHeuristics.TextDirectionHeuristicLocale: boolean defaultIsRtl()>,15,16,<android.text.TextDirectionHeuristics.TextDirectionHeuristicLocale: boolean defaultIsRtl()>,<android.text.TextDirectionHeuristics.TextDirectionHeuristicLocale: boolean defaultIsRtl()>,0,"{
    final int dir = LocaleUtil.getLayoutDirectionFromLocale(java.util.Locale.getDefault());
    return (dir == LocaleUtil.TEXT_LAYOUT_DIRECTION_RTL_DO_NOT_USE);
}","{
    final int dir = LocaleUtil.getLayoutDirectionFromLocale(java.util.Locale.getDefault());
    return (dir == View.LAYOUT_DIRECTION_RTL);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"In the return statement, LocaleUtil.TEXT_LAYOUT_DIRECTION_RTL_DO_NOT_USE is replaced with View.LAYOUT_DIRECTION_RTL, indicating a dependent API has changed, hence the change type is 1,5.","Since the return statement has changed, it could potentially result in a different boolean return value when the late version of the API is invoked. Therefore, the CI type is 1."
776,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",15,16,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port, localAddr, localPort);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"A new statement s.setNpnProtocols(mNpnProtocols); has been added in the Late version, so this could be categorized into both return statement changed (1) and other statement changed (4).","Since the newly added statement s.setNpnProtocols(mNpnProtocols); could potentially affect the behavior or state of the created Socket 's', it may potentially cause the API to return a different value, thus causing a compatibility issue of type 1."
777,<android.widget.TextView: void getFocusedRect(Rect)>,15,16,<android.widget.TextView: void getFocusedRect(Rect)>,<android.widget.TextView: void getFocusedRect(Rect)>,0,"{
    if (mLayout == null) {
        super.getFocusedRect(r);
        return;
    }
    int selEnd = getSelectionEnd();
    if (selEnd < 0) {
        super.getFocusedRect(r);
        return;
    }
    int selStart = getSelectionStart();
    if (selStart < 0 || selStart >= selEnd) {
        int line = mLayout.getLineForOffset(selEnd);
        r.top = mLayout.getLineTop(line);
        r.bottom = mLayout.getLineBottom(line);
        r.left = (int) mLayout.getPrimaryHorizontal(selEnd) - 2;
        r.right = r.left + 4;
    } else {
        int lineStart = mLayout.getLineForOffset(selStart);
        int lineEnd = mLayout.getLineForOffset(selEnd);
        r.top = mLayout.getLineTop(lineStart);
        r.bottom = mLayout.getLineBottom(lineEnd);
        if (lineStart == lineEnd) {
            r.left = (int) mLayout.getPrimaryHorizontal(selStart);
            r.right = (int) mLayout.getPrimaryHorizontal(selEnd);
        } else {
            // rect covers the entire width.
            if (mHighlightPath == null)
                mHighlightPath = new Path();
            if (mHighlightPathBogus) {
                mHighlightPath.reset();
                mLayout.getSelectionPath(selStart, selEnd, mHighlightPath);
                mHighlightPathBogus = false;
            }
            synchronized (sTempRect) {
                mHighlightPath.computeBounds(sTempRect, true);
                r.left = (int) sTempRect.left - 1;
                r.right = (int) sTempRect.right + 1;
            }
        }
    }
    // Adjust for padding and gravity.
    int paddingLeft = getCompoundPaddingLeft();
    int paddingTop = getExtendedPaddingTop();
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        paddingTop += getVerticalOffset(false);
    }
    r.offset(paddingLeft, paddingTop);
}","{
    if (mLayout == null) {
        super.getFocusedRect(r);
        return;
    }
    int selEnd = getSelectionEnd();
    if (selEnd < 0) {
        super.getFocusedRect(r);
        return;
    }
    int selStart = getSelectionStart();
    if (selStart < 0 || selStart >= selEnd) {
        int line = mLayout.getLineForOffset(selEnd);
        r.top = mLayout.getLineTop(line);
        r.bottom = mLayout.getLineBottom(line);
        r.left = (int) mLayout.getPrimaryHorizontal(selEnd) - 2;
        r.right = r.left + 4;
    } else {
        int lineStart = mLayout.getLineForOffset(selStart);
        int lineEnd = mLayout.getLineForOffset(selEnd);
        r.top = mLayout.getLineTop(lineStart);
        r.bottom = mLayout.getLineBottom(lineEnd);
        if (lineStart == lineEnd) {
            r.left = (int) mLayout.getPrimaryHorizontal(selStart);
            r.right = (int) mLayout.getPrimaryHorizontal(selEnd);
        } else {
            // rect cover the entire width.
            if (mHighlightPathBogus) {
                if (mHighlightPath == null)
                    mHighlightPath = new Path();
                mHighlightPath.reset();
                mLayout.getSelectionPath(selStart, selEnd, mHighlightPath);
                mHighlightPathBogus = false;
            }
            synchronized (TEMP_RECTF) {
                mHighlightPath.computeBounds(TEMP_RECTF, true);
                r.left = (int) TEMP_RECTF.left - 1;
                r.right = (int) TEMP_RECTF.right + 1;
            }
        }
    }
    // Adjust for padding and gravity.
    int paddingLeft = getCompoundPaddingLeft();
    int paddingTop = getExtendedPaddingTop();
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        paddingTop += getVerticalOffset(false);
    }
    r.offset(paddingLeft, paddingTop);
    int paddingBottom = getExtendedPaddingBottom();
    r.bottom += paddingBottom;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 4",1,"A new line of statement, which is `int paddingBottom = getExtendedPaddingBottom(); r.bottom += paddingBottom;`, has been added, and the order of execution for existing statements has been changed. Therefore, the code change type is 1 and 4.","Because the newly added line alters the return value of r.bottom, the type of CI is 1, which means the API potentially returns a different value."
778,<android.webkit.WebView: boolean isPrivateBrowsingEnabled()>,15,16,<android.webkit.WebView: boolean isPrivateBrowsingEnabled()>,<android.webkit.WebView: boolean isPrivateBrowsingEnabled()>,0,"{
    checkThread();
    return getSettings().isPrivateBrowsingEnabled();
}","{
    checkThread();
    return mProvider.isPrivateBrowsingEnabled();
}",1,"/**
 * Returns true if private browsing is enabled in this WebView.
 */
","/**
 * Gets whether private browsing is enabled in this WebView.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from getSettings().isPrivateBrowsingEnabled() to mProvider.isPrivateBrowsingEnabled(), so the code change is type 1.","Because the return value could be different when calling mProvider.isPrivateBrowsingEnabled() as compared to getSettings().isPrivateBrowsingEnabled(), thus the CI type is 1."
781,<android.webkit.WebSettings: String getStandardFontFamily()>,15,16,<android.webkit.WebSettings: String getStandardFontFamily()>,<android.webkit.WebSettings: String getStandardFontFamily()>,0,"{
    return mStandardFontFamily;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the standard font family name. The default is ""sans-serif"".
 * @return The standard font family name as a string.
 */
","/**
 * Gets the standard font family name.
 *
 * @return the standard font family name as a string
 * @see #setStandardFontFamily
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been replaced with a throw statement in the late version, which indicates a significant change in the API behavior. Therefore, the change category is characterized by both 1 (Return Statement Changed) and 2 (Exception Handling Statement Changed).","The original API is intended to return a standard font family but in the updated version, it throws an exception instead. This corresponds to a change both in return value and potential exception handling, causing compatibility issues of type 1 (potential different return values or types) and 2 (potential different exception handlings)."
782,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,15,16,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,0,"{
    // created or upgraded.
    if (mBaseDir == null) {
        // chrome http stack
        assert !JniUtil.useChromiumHttpStack();
        // Init() has not been called yet, so just flag that
        // we need to clear the cache when init() is called.
        mClearCacheOnInit = true;
        return true;
    }
    // delete rows in the cache database
    if (!JniUtil.useChromiumHttpStack())
        WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_CLEAR_CACHE);
    // delete cache files in a separate thread to not block UI.
    final Runnable clearCache = new Runnable() {

        public void run() {
            // delete all cache files
            try {
                String[] files = mBaseDir.list();
                // if mBaseDir doesn't exist, files can be null.
                if (files != null) {
                    for (int i = 0; i < files.length; i++) {
                        File f = new File(mBaseDir, files[i]);
                        if (!f.delete()) {
                            Log.e(LOGTAG, f.getPath() + "" delete failed."");
                        }
                    }
                }
            } catch (SecurityException e) {
            // Ignore SecurityExceptions.
            }
        }
    };
    new Thread(clearCache).start();
    return true;
}","{
    // delete cache files in a separate thread to not block UI.
    final Runnable clearCache = new Runnable() {

        public void run() {
            // delete all cache files
            try {
                String[] files = mBaseDir.list();
                // if mBaseDir doesn't exist, files can be null.
                if (files != null) {
                    for (int i = 0; i < files.length; i++) {
                        File f = new File(mBaseDir, files[i]);
                        if (!f.delete()) {
                            Log.e(LOGTAG, f.getPath() + "" delete failed."");
                        }
                    }
                }
            } catch (SecurityException e) {
            // Ignore SecurityExceptions.
            }
        }
    };
    new Thread(clearCache).start();
    return true;
}",1,"/**
 * Remove all cache files.
 *
 * @return Whether the removal succeeded.
 */
","/**
 * Removes all cache files.
 *
 * @return whether the removal succeeded
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early version checks if mBaseDir is null and sets mClearCacheOnInit. Moreover, it verifies if JniUtil.useChromiumHttpStack() is false then sends an empty message to WebViewWorker. All these statements are removed in the late version, which indicates that there is a control dependency change and other statements change; thus, the code change type is 3,4.","Despite these changes, the return value in all conditions remains the same (always return true), and no exception handle changes. Therefore, there is no Compatibility Issue, and the CI type is 0."
783,<android.view.View: boolean onTouchEvent(MotionEvent)>,15,16,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PRESSED) != 0) {
            mPrivateFlags &= ~PRESSED;
            refreshDrawableState();
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;
                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        mPrivateFlags |= PRESSED;
                        refreshDrawableState();
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    mPrivateFlags |= PRESSED;
                    refreshDrawableState();
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mPrivateFlags &= ~PRESSED;
                refreshDrawableState();
                removeTapCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        // Need to switch from pressed to not pressed
                        mPrivateFlags &= ~PRESSED;
                        refreshDrawableState();
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;
                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true);
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"In the early version, the method uses the statements mPrivateFlags &= ~PRESSED; refreshDrawableState(); to change the state, but in the late version, it uses a distinguished API method setPressed(false); and also setPressed(true);. This API does the same thing internally. Thus the change types are 4 and 5.","Even though the implementation has changed, it doesn't alter how the code behaves. This means that there are no Compatibility Issues as the API return value and exception handling remain identical in both versions. So, CI type is 0."
784,<android.app.Notification: String toString()>,15,16,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",sound="");
    if (this.sound != null) {
        sb.append(this.sound.toString());
    } else if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("",flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    if ((this.flags & FLAG_HIGH_PRIORITY) != 0) {
        sb.append(""!!!1!one!"");
    }
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    // TODO(dsandler): defaults take precedence over local values, so reorder the branches below
    sb.append("" vibrate="");
    if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if (this.sound != null) {
        sb.append(this.sound.toString());
    } else if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append("" kind=["");
    if (this.kind == null) {
        sb.append(""null"");
    } else {
        for (int i = 0; i < this.kind.length; i++) {
            if (i > 0)
                sb.append("","");
            sb.append(this.kind[i]);
        }
    }
    sb.append(""]"");
    if (actions != null) {
        sb.append("" "");
        sb.append(actions.length);
        sb.append("" action"");
        if (actions.length > 1)
            sb.append(""s"");
    }
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The implementation of the method `toString()` is changed from the first one to the second one. The changes introduce different appended values into the `StringBuilder sb`, which in turn changes the output string returned when calling `toString()`. Therefore, the code change type is 1.","Because the changes in the method implementation affect the output string of the method `toString()`, a different string can be returned when calling this method across the two versions of the implementation. Thus the Compatibility Issue (CI) type is 1, indicating the potential for different return values or types."
785,<android.hardware.SensorManager: List<Sensor> getSensorList(int)>,15,16,<android.hardware.SensorManager: List<Sensor> getSensorList(int)>,<android.hardware.SensorManager: List<Sensor> getSensorList(int)>,0,"{
    // cache the returned lists the first time
    List<Sensor> list;
    final ArrayList<Sensor> fullList = sFullSensorsList;
    synchronized (fullList) {
        list = sSensorListByType.get(type);
        if (list == null) {
            if (type == Sensor.TYPE_ALL) {
                list = fullList;
            } else {
                list = new ArrayList<Sensor>();
                for (Sensor i : fullList) {
                    if (i.getType() == type)
                        list.add(i);
                }
            }
            list = Collections.unmodifiableList(list);
            sSensorListByType.append(type, list);
        }
    }
    return list;
}","{
    // cache the returned lists the first time
    List<Sensor> list;
    final List<Sensor> fullList = getFullSensorList();
    synchronized (mSensorListByType) {
        list = mSensorListByType.get(type);
        if (list == null) {
            if (type == Sensor.TYPE_ALL) {
                list = fullList;
            } else {
                list = new ArrayList<Sensor>();
                for (Sensor i : fullList) {
                    if (i.getType() == type)
                        list.add(i);
                }
            }
            list = Collections.unmodifiableList(list);
            mSensorListByType.append(type, list);
        }
    }
    return list;
}",1,"/**
 * Use this method to get the list of available sensors of a certain type.
 * Make multiple calls to get sensors of different types or use
 * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all the
 * sensors.
 *
 * @param type
 * of sensors requested
 *
 * @return a list of sensors matching the asked type.
 *
 * @see #getDefaultSensor(int)
 * @see Sensor
 */
","/**
 * Use this method to get the list of available sensors of a certain type.
 * Make multiple calls to get sensors of different types or use
 * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all the
 * sensors.
 *
 * @param type
 * of sensors requested
 *
 * @return a list of sensors matching the asked type.
 *
 * @see #getDefaultSensor(int)
 * @see Sensor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"Both the variable names and the methods they call have changed, so the code change type is 4,5. ","The change in accessed methods and variables could potentially affect the values that are returned by this API, so the CI type is 1."
786,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,15,16,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner();
}","{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(null, 0, 0, 0);
}",1,"/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
","/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"There is a change in the API method call 'startInputInner()' as parameters have been introduced in the latest version. This corresponds to a change in other statement and dependant API. So, the change type is 4,5.","'startInputInner()' method now executes differentially in two versions. Specifically, it executes without any parameters in the early version, but executes with four parameters in the late version. Hence, the behaviours of the two versions could be different and therefore, potentially result in different return values. So, the CI type is 1."
790,"<android.webkit.FindActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",15,16,"<android.webkit.FindActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>","<android.webkit.FindActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",0,"{
    if (mWebView == null) {
        throw new AssertionError(""No WebView for FindActionModeCallback::onActionItemClicked"");
    }
    mInput.hideSoftInputFromWindow(mWebView.getWindowToken(), 0);
    switch(item.getItemId()) {
        case com.android.internal.R.id.find_prev:
            findNext(false);
            break;
        case com.android.internal.R.id.find_next:
            findNext(true);
            break;
        default:
            return false;
    }
    return true;
}","{
    if (mWebView == null) {
        throw new AssertionError(""No WebView for FindActionModeCallback::onActionItemClicked"");
    }
    mInput.hideSoftInputFromWindow(mWebView.getWebView().getWindowToken(), 0);
    switch(item.getItemId()) {
        case com.android.internal.R.id.find_prev:
            findNext(false);
            break;
        case com.android.internal.R.id.find_next:
            findNext(true);
            break;
        default:
            return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The mWebView.getWindowToken() in the early version has been revised to mWebView.getWebView().getWindowToken() in the late version, which is an other syntax change (type=4) but also changes the dependent API (type=5).","The changes in the dependent API 'getWindowToken()' could potentially change the return result of 'onActionItemClicked()' since it could change the behavior of 'hideSoftInputFromWindow()', potentially affecting the final result of 'onActionItemClicked()'. Thus, it's classified under Compatibility Issue caused by potential different return values (type=1)."
792,"<android.database.sqlite.SQLiteDatabase: List<Pair<String, String>> getAttachedDbs()>",15,16,"<android.database.sqlite.SQLiteDatabase: List<Pair<String, String>> getAttachedDbs()>","<android.database.sqlite.SQLiteDatabase: List<Pair<String, String>> getAttachedDbs()>",0,"{
    if (!isOpen()) {
        return null;
    }
    ArrayList<Pair<String, String>> attachedDbs = new ArrayList<Pair<String, String>>();
    if (!mHasAttachedDbs) {
        // No attached databases.
        // There is a small window where attached databases exist but this flag is not set yet.
        // This can occur when this thread is in a race condition with another thread
        // that is executing the SQL statement: ""attach database <blah> as <foo>""
        // If this thread is NOT ok with such a race condition (and thus possibly not receive
        // the entire list of attached databases), then the caller should ensure that no thread
        // is executing any SQL statements while a thread is calling this method.
        // Typically, this method is called when 'adb bugreport' is done or the caller wants to
        // collect stats on the database and all its attached databases.
        attachedDbs.add(new Pair<String, String>(""main"", mPath));
        return attachedDbs;
    }
    // has attached databases. query sqlite to get the list of attached databases.
    Cursor c = null;
    try {
        c = rawQuery(""pragma database_list;"", null);
        while (c.moveToNext()) {
            // sqlite returns a row for each database in the returned list of databases.
            // in each row,
            // 1st column is the database name such as main, or the database
            // name specified on the ""ATTACH"" command
            // 2nd column is the database file path.
            attachedDbs.add(new Pair<String, String>(c.getString(1), c.getString(2)));
        }
    } finally {
        if (c != null) {
            c.close();
        }
    }
    return attachedDbs;
}","{
    ArrayList<Pair<String, String>> attachedDbs = new ArrayList<Pair<String, String>>();
    synchronized (mLock) {
        if (mConnectionPoolLocked == null) {
            // not open
            return null;
        }
        if (!mHasAttachedDbsLocked) {
            // No attached databases.
            // There is a small window where attached databases exist but this flag is not
            // set yet.  This can occur when this thread is in a race condition with another
            // thread that is executing the SQL statement: ""attach database <blah> as <foo>""
            // If this thread is NOT ok with such a race condition (and thus possibly not
            // receivethe entire list of attached databases), then the caller should ensure
            // that no thread is executing any SQL statements while a thread is calling this
            // method.  Typically, this method is called when 'adb bugreport' is done or the
            // caller wants to collect stats on the database and all its attached databases.
            attachedDbs.add(new Pair<String, String>(""main"", mConfigurationLocked.path));
            return attachedDbs;
        }
        acquireReference();
    }
    try {
        // has attached databases. query sqlite to get the list of attached databases.
        Cursor c = null;
        try {
            c = rawQuery(""pragma database_list;"", null);
            while (c.moveToNext()) {
                // sqlite returns a row for each database in the returned list of databases.
                // in each row,
                // 1st column is the database name such as main, or the database
                // name specified on the ""ATTACH"" command
                // 2nd column is the database file path.
                attachedDbs.add(new Pair<String, String>(c.getString(1), c.getString(2)));
            }
        } finally {
            if (c != null) {
                c.close();
            }
        }
        return attachedDbs;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns list of full pathnames of all attached databases including the main database
 * by executing 'pragma database_list' on the database.
 *
 * @return ArrayList of pairs of (database name, database file path) or null if the database
 * is not open.
 */
","/**
 * Returns list of full pathnames of all attached databases including the main database
 * by executing 'pragma database_list' on the database.
 *
 * @return ArrayList of pairs of (database name, database file path) or null if the database
 * is not open.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, the checking condition for 'isOpen()' has been removed and they added a synchronized block for 'mLock'. They also changed the usage of 'mPath' to 'mConfigurationLocked.path'. Hence, the change type is Control dependency change(3) and other statements changed(4).","The removal of isOpen() check, the addition of a synchronized block and the substitution of 'mPath' with 'mConfigurationLocked.path' might affect the return value of the method, which could introduce a Compatibility Issue caused by potential different return values or types, so the CI type is 1."
793,<android.database.sqlite.SQLiteCursor: SQLiteDatabase getDatabase()>,15,16,<android.database.sqlite.SQLiteCursor: SQLiteDatabase getDatabase()>,<android.database.sqlite.SQLiteCursor: SQLiteDatabase getDatabase()>,0,"{
    synchronized (this) {
        return mQuery.mDatabase;
    }
}","{
    return mQuery.getDatabase();
}",1,"/**
 * @return the SQLiteDatabase that this cursor is associated with.
 */
","/**
 * Get the database that this cursor is associated with.
 * @return the SQLiteDatabase that this cursor is associated with.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of getDatabase() has changed from returning mQuery.mDatabase to mQuery.getDatabase() and also the synchronized block has been removed. Hence, the change type is 1,5.","The change in how the database is retrieved could potentially make the returned value of the API different. Thus, the Compatibility Issue type is 1."
794,"<android.os.Parcel: void writeByteArray(byte[],int,int)>",15,16,"<android.os.Parcel: void writeByteArray(byte[],int,int)>","<android.os.Parcel: void writeByteArray(byte[],int,int)>",0,"{
    if (b == null) {
        writeInt(-1);
        return;
    }
    Arrays.checkOffsetAndCount(b.length, offset, len);
    writeNative(b, offset, len);
}","{
    if (b == null) {
        writeInt(-1);
        return;
    }
    Arrays.checkOffsetAndCount(b.length, offset, len);
    nativeWriteByteArray(mNativePtr, b, offset, len);
}",1,"/**
 * Write an byte array into the parcel at the current {@link #dataPosition},
 * growing {@link #dataCapacity} if needed.
 * @param b Bytes to place into the parcel.
 * @param offset Index of first byte to be written.
 * @param len Number of bytes to write.
 */
","/**
 * Write a byte array into the parcel at the current {@link #dataPosition},
 * growing {@link #dataCapacity} if needed.
 * @param b Bytes to place into the parcel.
 * @param offset Index of first byte to be written.
 * @param len Number of bytes to write.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The statement 'writeNative(b, offset, len)' has been changed to 'nativeWriteByteArray(mNativePtr, b, offset, len)'. This change indicates that the method name has changed and a new parameter 'mNativePtr' is introduced in the method 'nativeWriteByteArray', so the code change type is 1,5.","Since the function 'writeNative' is replaced by 'nativeWriteByteArray', this change might lead the API to return a different value or type, thus a compatibility issue could exist due to potential different return values or types, and the CI type is 1."
795,"<android.app.ActivityThread.Profiler: void setProfiler(String,ParcelFileDescriptor)>",15,16,"<android.app.ActivityThread.Profiler: void setProfiler(String,ParcelFileDescriptor)>","<android.app.ActivityThread.Profiler: void setProfiler(String,ParcelFileDescriptor)>",0,"{
    if (profiling) {
        if (fd != null) {
            try {
                fd.close();
            } catch (IOException e) {
            }
        }
        return;
    }
    if (profileFd != null) {
        try {
            profileFd.close();
        } catch (IOException e) {
        }
    }
    profileFile = file;
    profileFd = fd;
}","{
    if (profiling) {
        if (fd != null) {
            try {
                fd.close();
            } catch (IOException e) {
            // Ignore
            }
        }
        return;
    }
    if (profileFd != null) {
        try {
            profileFd.close();
        } catch (IOException e) {
        // Ignore
        }
    }
    profileFile = file;
    profileFd = fd;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no key changes happened in the implementation of this API method between the two versions, only comments were added.","Because there are no changes in this method's implementation between the two versions, there is no compatibility issue happening between these versions."
797,<android.view.accessibility.AccessibilityNodeInfo: int getChildCount()>,15,16,<android.view.accessibility.AccessibilityNodeInfo: int getChildCount()>,<android.view.accessibility.AccessibilityNodeInfo: int getChildCount()>,0,"{
    return mChildAccessibilityIds.size();
}","{
    return mChildNodeIds.size();
}",1,"/**
 * Gets the number of children.
 *
 * @return The child count.
 */
","/**
 * Gets the number of children.
 *
 * @return The child count.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The method that is invoked in the return statement has been changed from mChildAccessibilityIds.size() to mChildNodeIds.size(). This belongs to the code change types 1 (Return statement changed) and 5 (Dependent API changed).,"Different methods have been used in the implementation of the API in the two versions which refers to different variables. As the method changes, the returned value may be different when the API is invoked, leading to a potential compatibility issue with type 1 (Compatibility Issue caused by potential different return values or types)."
800,<android.widget.ExpandableListConnector: boolean isEnabled(int)>,15,16,<android.widget.ExpandableListConnector: boolean isEnabled(int)>,<android.widget.ExpandableListConnector: boolean isEnabled(int)>,0,"{
    final ExpandableListPosition pos = getUnflattenedPos(flatListPos).position;
    boolean retValue;
    if (pos.type == ExpandableListPosition.CHILD) {
        retValue = mExpandableListAdapter.isChildSelectable(pos.groupPos, pos.childPos);
    } else {
        // Groups are always selectable
        retValue = true;
    }
    pos.recycle();
    return retValue;
}","{
    final PositionMetadata metadata = getUnflattenedPos(flatListPos);
    final ExpandableListPosition pos = metadata.position;
    boolean retValue;
    if (pos.type == ExpandableListPosition.CHILD) {
        retValue = mExpandableListAdapter.isChildSelectable(pos.groupPos, pos.childPos);
    } else {
        // Groups are always selectable
        retValue = true;
    }
    metadata.recycle();
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"In the code, 'getUnflattenedPos(flatListPos).position' (early version) is replaced by 'getUnflattenedPos(flatListPos)' (late version) and new variable 'metadata' is introduced in the late version. That indicates the change type is 4 (Other statement changed) and 5 (Dependent API changed).","The changes result, in the late version, in the recycling of 'metadata' instead of 'pos'. Plus, different method is called to get 'pos' which may return a different result. This leads to potential changes in return value 'retValue', therefore the potential compatibility issue type is 1."
801,<android.webkit.WebSettings: void setDatabasePath(String)>,15,16,<android.webkit.WebSettings: void setDatabasePath(String)>,<android.webkit.WebSettings: void setDatabasePath(String)>,0,"{
    if (databasePath != null && !mDatabasePathHasBeenSet) {
        mDatabasePath = databasePath;
        mDatabasePathHasBeenSet = true;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the path to where database storage API databases should be saved.
 * Nota that the WebCore Database Tracker only allows the path to be set once.
 * This will update WebCore when the Sync runs in the C++ side.
 * @param databasePath String path to the directory where databases should
 * be saved. May be the empty string but should never be null.
 */
","// This will update WebCore when the Sync runs in the C++ side.
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version API has several statements including the 'if' statement, while the late version API throws a new exception. So, the code change type is 1,2.","The implementation completely changes from setting a database path to throwing an exception always in the late version API. So the CI type is 1,2."
802,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,15,16,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,0,"{
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                if (f.onOptionsItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                if (f.onOptionsItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change between the two versions.,"As there is no code change, thus no compatibility issue arises."
803,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,15,16,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,0,"{
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    mView.invalidateParentCaches();
    float fraction = animation.getAnimatedFraction();
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidate(false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        // force another invalidation
        mView.mPrivateFlags |= View.DRAWN;
    }
    // invalidate(false) in all cases except if alphaHandled gets set to true
    // via the call to setAlphaNoInvalidation(), above
    mView.invalidate(alphaHandled);
}","{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
}",1,"/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
","/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The 'if' condition at the start of the method changed from not existing to checking if propertyBundle == null. If true, the method now early returns. Also, there is a new boolean 'useDisplayListProperties' this changes the conditions on which 'mView.invalidateParentCaches();' and 'mView.mPrivateFlags |= View.DRAWN;' are called and changes the invalidation calls to 'mView.invalidateViewProperty(false, false);'. These all correspond to changes in control statements (3), return statements (1), and other statements (4). Also, there is a change in how the exception is handled. In the early version, there is no exception handling for the case where 'propertyBundle' is 'null'. In the late version, there is a catch where it simply returns, it constitutes an exception handling change (2).","As there is an early return in the late version if 'propertyBundle' is null, this will cause the method to potentially return nothing whereas before it would throw a NullPointException. Thus compatibility issue type 1 (different return values) applies. The changes in the invalidation conditions and what methods are called with potentially lead to different application states being produced as a side effect of this method, this corresponds with compatibility issue type 2 (different exception handling)."
804,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,15,16,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,0,"{
    try {
        long timeStart = acquireAndLock(READ);
        long retValue = native_1x1_long();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } catch (SQLiteDoneException e) {
        throw new SQLiteDoneException(""expected 1 row from this query but query returned no data. check the query: "" + mSql);
    } finally {
        releaseAndUnlock();
    }
}","{
    acquireReference();
    try {
        return getSession().executeForLong(getSql(), getBindArgs(), getConnectionFlags(), null);
    } catch (SQLiteDatabaseCorruptException ex) {
        onCorruption();
        throw ex;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The early version uses native_1x1_long() to execute the query while the late version uses a completely different method getSession().executeForLong(). The query execution and Exception handling have both changed. Also, acquireReference(), releaseReference() and onCorruption() are added in the new version. Therefore, the code changes are categoried into 1 (Return statement changed), 2 (Exception handling statement changed), 4 (Other statement changed), and 5 (Dependent API changed).","Since the method for executing the query has been altered, and the exception type that is being caught has changed from SQLiteDoneException to SQLiteDatabaseCorruptException, the API will potentially return different values and handle different exceptions. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
805,<android.animation.LayoutTransition: long getStartDelay(int)>,15,16,<android.animation.LayoutTransition: long getStartDelay(int)>,<android.animation.LayoutTransition: long getStartDelay(int)>,0,"{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingDuration;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingDuration;
        case APPEARING:
            return mAppearingDuration;
        case DISAPPEARING:
            return mDisappearingDuration;
    }
    // shouldn't reach here
    return 0;
}","{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingDelay;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingDelay;
        case CHANGING:
            return mChangingDelay;
        case APPEARING:
            return mAppearingDelay;
        case DISAPPEARING:
            return mDisappearingDelay;
    }
    // shouldn't reach here
    return 0;
}",1,"/**
 * Gets the start delay on one of the animation objects used by this transition. The
 * <code>transitionType</code> parameter determines the animation whose start delay
 * is returned.
 *
 * @param transitionType one of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #APPEARING}, or {@link #DISAPPEARING}, which determines the animation whose start
 * delay is returned.
 * @return long The start delay of the specified animation.
 * @see Animator#getStartDelay()
 */
","/**
 * Gets the start delay on one of the animation objects used by this transition. The
 * <code>transitionType</code> parameter determines the animation whose start delay
 * is returned.
 *
 * @param transitionType One of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #CHANGING}, {@link #APPEARING}, or {@link #DISAPPEARING}, which determines
 * the animation whose start delay is returned.
 * @return long The start delay of the specified animation.
 * @see Animator#getStartDelay()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statements inside the 'switch' condition have been changed, and the elements of the 'switch' control also have different cases, so the code change type is 1,3.","As the return statements in the 'switch' condition has changed, it may lead to the return of different values by the API during execution, so the CI type is 1."
806,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,15,16,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,0,"{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: "" + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        if (mServedInputConnection != null) {
            // We need to tell the previously served view that it is no
            // longer the input target, so it can reset its state.  Schedule
            // this call on its window's Handler so it will be on the correct
            // thread and outside of our lock.
            Handler vh = mServedView.getHandler();
            if (vh != null) {
                // This will result in a call to reportFinishInputConnection()
                // below.
                vh.sendMessage(vh.obtainMessage(ViewRootImpl.FINISH_INPUT_CONNECTION, mServedInputConnection));
            }
        }
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}","{
    mCurRootView = null;
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: "" + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        notifyInputConnectionFinished();
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}",1,"/**
 * Disconnect any existing input connection, clearing the served view.
 */
","/**
 * Disconnect any existing input connection, clearing the served view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,3",0,"In the later version, a new variable 'mCurRootView' is added and a method call 'notifyInputConnectionFinished()' replaces the entire 'if (mServedInputConnection != null)' block. This is classified as other statements changed (4). Furthermore, the control statements (the if block) has changed, which corresponds to control dependency change (3).","These changes all happen within the method implementation and they do not affect the possible output values of the function or exceptions it may throw, meaning that both versions should behave the same for any given input. Hence, no compatibility issue is detected."
807,"<android.database.sqlite.SQLiteProgram: void bindBlob(int,byte[])>",15,16,"<android.database.sqlite.SQLiteProgram: void bindBlob(int,byte[])>","<android.database.sqlite.SQLiteProgram: void bindBlob(int,byte[])>",0,"{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    bind(Cursor.FIELD_TYPE_BLOB, index, value);
}","{
    if (value == null) {
        throw new IllegalArgumentException(""the bind value at index "" + index + "" is null"");
    }
    bind(index, value);
}",1,"/**
 * Bind a byte array value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind
 */
","/**
 * Bind a byte array value to this statement. The value remains bound until
 * {@link #clearBindings} is called.
 *
 * @param index The 1-based index to the parameter to bind
 * @param value The value to bind, must not be null
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method called in the implementation has changed from bind(Cursor.FIELD_TYPE_BLOB, index, value) to bind(index, value), the parameters' type has been altered, so the code change type is 5.","Despite the change in the dependent method, this change does not alter the behaviour of the current API as it does not potentially cause the API to return a different variable or throw an exception differently. So there is no Compatibility Issue."
808,<android.webkit.WebSettings: String getFixedFontFamily()>,15,16,<android.webkit.WebSettings: String getFixedFontFamily()>,<android.webkit.WebSettings: String getFixedFontFamily()>,0,"{
    return mFixedFontFamily;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the fixed font family name. The default is ""monospace"".
 * @return The fixed font family name as a string.
 */
","/**
 * Gets the fixed font family name.
 *
 * @return the fixed font family name as a string
 * @see #setFixedFontFamily
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement in version 15 was replaced with a throw statement in version 16, hence this is categorized as types 1,2 in code change.","As the return and throw statments were replaced, the function will not return the expected variable and will always throw an exception resulting in different behavior in version 16 of the API. Therefore, this is a Compatibility Issue of types 1,2."
811,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",15,16,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    IServiceConnection sd;
    if (mPackageInfo != null) {
        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags);
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
    try {
        IBinder token = getActivityToken();
        if (token == null && (flags & BIND_AUTO_CREATE) == 0 && mPackageInfo != null && mPackageInfo.getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
            flags |= BIND_WAIVE_PRIORITY;
        }
        service.setAllowFds(false);
        int res = ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags);
        if (res < 0) {
            throw new SecurityException(""Not allowed to bind to service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    return bindService(service, conn, flags, UserId.getUserId(Process.myUid()));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5","1,2","The entire implementation in the early version got replaced by a single line of return statement, which calls a new API bindService with different parameters. Accordingly, the change type covers both Return statement changed (1) and Dependent API changed (5).","Since the implementation has completely changed, it is very likely that the returned values and exceptions thrown will be different, thus the Compatibility Issue involves both potential different return values (1) and potential different exception handlings (2)."
814,<android.os.Parcel: void recycle()>,15,16,<android.os.Parcel: void recycle()>,<android.os.Parcel: void recycle()>,0,"{
    if (DEBUG_RECYCLE)
        mStack = null;
    freeBuffer();
    final Parcel[] pool = mOwnObject != 0 ? sOwnedPool : sHolderPool;
    synchronized (pool) {
        for (int i = 0; i < POOL_SIZE; i++) {
            if (pool[i] == null) {
                pool[i] = this;
                return;
            }
        }
    }
}","{
    if (DEBUG_RECYCLE)
        mStack = null;
    freeBuffer();
    final Parcel[] pool;
    if (mOwnsNativeParcelObject) {
        pool = sOwnedPool;
    } else {
        mNativePtr = 0;
        pool = sHolderPool;
    }
    synchronized (pool) {
        for (int i = 0; i < POOL_SIZE; i++) {
            if (pool[i] == null) {
                pool[i] = this;
                return;
            }
        }
    }
}",1,"/**
 * Put a Parcel object back into the pool.  You must not touch
 * the object after this call.
 */
","/**
 * Put a Parcel object back into the pool.  You must not touch
 * the object after this call.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",No Compatibility Issue exist,"The assignment of 'pool' has changed from a conditional expression to an if...else branch. Adding the statement `mNativePtr = 0;` in the else branch. This is a change in control dependency and other statements. Therefore, the code change types are 3 and 4.","Although there is a change in the assignment of 'pool' and the addition of 'mNativePtr = 0;', the change does not affect the behavior of the method. The method always executes `freeBuffer()`, and then puts itself to `sOwnedPool` or `sHolderPool` There is no new method invocation or change in exception handling and returned variables. Therefore, no compatibility issue arises."
815,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,15,16,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,0,"{
    boolean show = false;
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onPrepareOptionsMenu(menu);
            }
        }
    }
    return show;
}","{
    boolean show = false;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onPrepareOptionsMenu(menu);
            }
        }
    }
    return show;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change between the early version and the late version.,No Compatibility Issue exist as there is no code change between the early version and the late version.
816,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",15,16,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>","<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",0,"{
    return mContentProvider.getStreamTypes(url, mimeTypeFilter);
}","{
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
","/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The return statement has a wrapping try-catch block added. Also, a new exception handling statement has been introduced which throws DeadObjectException. There has been a control dependency change introduced with the 'try-catch' block, so the code type change is 1,2,3.","Due to the exception handling statement addition, the potential behaviour of the API has changed. It may now throw an exception where it did not previously. The addition of the try-catch bloc can also potentially affect the return value of the API. Therefore, the CI type is 1,2."
818,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",15,16,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>","<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",0,"{
    final GLES20Layer glLayer = (GLES20Layer) layer;
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint);
    if (modifier != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifier);
}","{
    final GLES20Layer glLayer = (GLES20Layer) layer;
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",0,"The change type is 2 and 3, as there's a new 'try-finally' block introduced: code involving nativePaint assignment and nDrawLayer method invocation is now enclosed in a 'try', and the conditional code involving nResetModifiers method invocation is in 'finally'.","This change will not cause a Compatibility Issue. The change is simply an enhancement of exception handling, ensuring that no matter what happens during the 'try' block, the 'finally' block is executed. It does not alter the behavior of the API with respect to return values or exception handling."
819,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>",15,16,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>",0,"{
    return mMainThread.acquireExistingProvider(context, name);
}","{
    return mMainThread.acquireExistingProvider(context, name, true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"There is an extra boolean parameter true in the call to mMainThread.acquireExistingProvider in the later version. So the change is in return statement, and also the dependent API has changed. The code change type is 1,5.",The added parameter may affect the return value of acquireExistingProvider(). This change could potentially make the API return different values. Thus the CI type is 1.
821,<android.animation.LayoutTransition: long getDuration(int)>,15,16,<android.animation.LayoutTransition: long getDuration(int)>,<android.animation.LayoutTransition: long getDuration(int)>,0,"{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingDuration;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingDuration;
        case APPEARING:
            return mAppearingDuration;
        case DISAPPEARING:
            return mDisappearingDuration;
    }
    // shouldn't reach here
    return 0;
}","{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingDuration;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingDuration;
        case CHANGING:
            return mChangingDuration;
        case APPEARING:
            return mAppearingDuration;
        case DISAPPEARING:
            return mDisappearingDuration;
    }
    // shouldn't reach here
    return 0;
}",1,"/**
 * Gets the duration on one of the animation objects used by this transition. The
 * <code>transitionType</code> parameter determines the animation whose duration
 * is returned.
 *
 * @param transitionType one of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #APPEARING}, or {@link #DISAPPEARING}, which determines the animation whose
 * duration is returned.
 * @return long The duration of the specified animation.
 * @see Animator#getDuration()
 */
","/**
 * Gets the duration on one of the animation objects used by this transition. The
 * <code>transitionType</code> parameter determines the animation whose duration
 * is returned.
 *
 * @param transitionType One of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING},
 * {@link #CHANGING}, {@link #APPEARING}, or {@link #DISAPPEARING}, which determines
 * the animation whose duration is returned.
 * @return long The duration of the specified animation.
 * @see Animator#getDuration()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The switch block has been modified with the addition of a new case 'CHANGING'. This change manifests both as a 'Return Statement changed' and a 'Control dependency change'. Hence, change types are 1,3.","The addition of a new case 'CHANGING' in switch block may potentially lead to different return values. Therefore, it will cause Compatibility Issue type 1."
822,"<android.server.BluetoothA2dpService: void dump(FileDescriptor,PrintWriter,String[])>",15,16,"<android.server.BluetoothA2dpService: void dump(FileDescriptor,PrintWriter,String[])>","<android.server.BluetoothA2dpService: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    if (mAudioDevices.isEmpty())
        return;
    pw.println(""Cached audio devices:"");
    for (BluetoothDevice device : mAudioDevices.keySet()) {
        int state = mAudioDevices.get(device);
        pw.println(device + "" "" + BluetoothA2dp.stateToString(state));
    }
}","{
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (mAudioDevices.isEmpty())
        return;
    pw.println(""Cached audio devices:"");
    for (BluetoothDevice device : mAudioDevices.keySet()) {
        int state = mAudioDevices.get(device);
        pw.println(device + "" "" + BluetoothA2dp.stateToString(state));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A permission check statement has been added at the beginning of the API in the late version, which contributes to the ""Control dependency change"". There is also another statement introduced `mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);` which is classified as ""Other statement changed"". So, the code change type is 3,4.","This change is mainly about security enhancement, no change is made for the nature behavior of the API which will possibly cause different return values/types or exception handlings. Thus, there is no Compatibility Issue exist."
823,<android.webkit.CookieManager: boolean acceptCookie()>,15,16,<android.webkit.CookieManager: boolean acceptCookie()>,<android.webkit.CookieManager: boolean acceptCookie()>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        return nativeAcceptCookie();
    }
    return mAcceptCookie;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return whether cookie is enabled
 * @return TRUE if accept cookie
 */
","/**
 * Gets whether the application's {@link WebView} instances send and accept
 * cookies.
 *
 * @return true if {@link WebView} instances send and accept cookies
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The entire body of the method is changed from a conditional return statement to a single throw statement, so it falls under categories 1 (return statement changed), 2 (exception handling statement changed), and 3 (control dependency changed).","Since the entire behavior of the method is altered in the new version, it would clearly cause different behavior when the API is invoked, thus it falls under categories 1 (different return values) and 2 (different exception handlings)."
824,<android.widget.RemoteViews: RemoteViews clone()>,15,16,<android.widget.RemoteViews: RemoteViews clone()>,<android.widget.RemoteViews: RemoteViews clone()>,0,"{
    final RemoteViews that = new RemoteViews(mPackage, mLayoutId);
    if (mActions != null) {
        that.mActions = (ArrayList<Action>) mActions.clone();
    }
    // update the memory usage stats of the cloned RemoteViews
    that.recalculateMemoryUsage();
    return that;
}","{
    RemoteViews that;
    if (!hasLandscapeAndPortraitLayouts()) {
        that = new RemoteViews(mPackage, mLayoutId);
        if (mActions != null) {
            that.mActions = (ArrayList<Action>) mActions.clone();
        }
    } else {
        RemoteViews land = mLandscape.clone();
        RemoteViews port = mPortrait.clone();
        that = new RemoteViews(land, port);
    }
    // update the memory usage stats of the cloned RemoteViews
    that.recalculateMemoryUsage();
    return that;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The condition statement 'if (!hasLandscapeAndPortraitLayouts())' has been introduced into the late version and the return statement has been changed from 'new RemoteViews(mPackage, mLayoutId)' to a new way of creating an object of RemoteViews. So, the code change type is 1,3.","Depending on the conditions, this late version can return a different RemoteViews object. That leads to the Compatibility Issue and its type is 1."
828,"<android.view.animation.Animation: boolean getTransformation(long,Transformation)>",15,16,"<android.view.animation.Animation: boolean getTransformation(long,Transformation)>","<android.view.animation.Animation: boolean getTransformation(long,Transformation)>",0,"{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f;
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            if (mListener != null) {
                mListener.onAnimationStart(this);
            }
            mStarted = true;
            if (USE_CLOSEGUARD) {
                guard.open(""cancel or detach or getTransformation"");
            }
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        applyTransformation(interpolatedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated) {
            if (!mEnded) {
                mEnded = true;
                guard.close();
                if (mListener != null) {
                    mListener.onAnimationEnd(this);
                }
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            if (mListener != null) {
                mListener.onAnimationRepeat(this);
            }
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}","{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f;
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            fireAnimationStart();
            mStarted = true;
            if (USE_CLOSEGUARD) {
                guard.open(""cancel or detach or getTransformation"");
            }
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        applyTransformation(interpolatedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated) {
            if (!mEnded) {
                mEnded = true;
                guard.close();
                fireAnimationEnd();
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            fireAnimationRepeat();
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}",1,"/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
","/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"In the early and late versions, three internal methods related to animation listeners are changed from direct using mListener to using defined methods. Those are 'mListener.onAnimationStart(this)', 'mListener.onAnimationEnd(this)', and 'mListener.onAnimationRepeat(this)' which are changed to 'fireAnimationStart()', 'fireAnimationEnd()' and, 'fireAnimationRepeat()' respectively. Therefore, the change type is categorized as 5 (Dependent API changed).","These changes can potentially alter the return type of this API since the behavior and interaction with the internally used APIs are modified. The dependent APIs 'fireAnimationStart()', 'fireAnimationEnd()', 'fireAnimationRepeat()' might return different types or values than the early version, leading to a potential change in the return value of the 'getTransformation()' API. Thus, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
829,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",15,16,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0);
}","{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, false, COMPONENT_ENABLED_STATE_DEFAULT);
}",1,"/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
","/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The change is in the return statement, an additional two parameters are added to the method 'PackageParser.generatePackageInfo()', so the code change type is 1.","The addition of new parameters in the method PackageParser.generatePackageInfo() may modify the package information being returned, potentially making that API returns different values. Therefore, the CI type is 1."
831,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",15,16,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int,DatabaseErrorHandler)>",0,"{
    SQLiteDatabase sqliteDatabase = openDatabase(path, factory, flags, errorHandler, (short) 0);
    // set sqlite pagesize to mBlockSize
    if (sBlockSize == 0) {
        // TODO: ""/data"" should be a static final String constant somewhere. it is hardcoded
        // in several places right now.
        sBlockSize = new StatFs(""/data"").getBlockSize();
    }
    sqliteDatabase.setPageSize(sBlockSize);
    sqliteDatabase.setJournalMode(path, ""TRUNCATE"");
    // add this database to the list of databases opened in this process
    synchronized (mActiveDatabases) {
        mActiveDatabases.add(new WeakReference<SQLiteDatabase>(sqliteDatabase));
    }
    return sqliteDatabase;
}","{
    SQLiteDatabase db = new SQLiteDatabase(path, flags, factory, errorHandler);
    db.open();
    return db;
}",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
 * used to handle corruption when sqlite reports database corruption.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @param errorHandler the {@link DatabaseErrorHandler} obj to be used to handle corruption
 * when sqlite reports database corruption
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The entire method implementation has extensively changed between two versions. From the early version's openDatabase() method and several other statements to the late version's instantiation of a new SQLiteDatabase object and calling the open() method. Hence, the code change types are 1 (Return statement changed) and 4 (Other statement changed).","Due to the significant change in the method implementation, the return type and the return value would differ in each version, thus leading to a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
833,<android.view.HardwareRenderer.GlRenderer: GL createEglSurface(SurfaceHolder)>,15,16,<android.view.HardwareRenderer.GlRenderer: GL createEglSurface(SurfaceHolder)>,<android.view.HardwareRenderer.GlRenderer: GL createEglSurface(SurfaceHolder)>,0,"{
    // Check preconditions.
    if (sEgl == null) {
        throw new RuntimeException(""egl not initialized"");
    }
    if (sEglDisplay == null) {
        throw new RuntimeException(""eglDisplay not initialized"");
    }
    if (sEglConfig == null) {
        throw new RuntimeException(""eglConfig not initialized"");
    }
    if (Thread.currentThread() != mEglThread) {
        throw new IllegalStateException(""HardwareRenderer cannot be used "" + ""from multiple threads"");
    }
    // In case we need to destroy an existing surface
    destroySurface();
    // Create an EGL surface we can render into.
    if (!createSurface(holder)) {
        return null;
    }
    /*
             * Before we can issue GL commands, we need to make sure
             * the context is current and bound to a surface.
             */
    if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
        throw new Surface.OutOfResourcesException(""eglMakeCurrent failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
    }
    initCaches();
    // with EGL_SWAP_BEHAVIOR_PRESERVED_BIT set
    if (sDirtyRegions) {
        if (!(mDirtyRegionsEnabled = GLES20Canvas.preserveBackBuffer())) {
            Log.w(LOG_TAG, ""Backbuffer cannot be preserved"");
        }
    } else if (sDirtyRegionsRequested) {
        // If mDirtyRegions is not set, our EGL configuration does not
        // have EGL_SWAP_BEHAVIOR_PRESERVED_BIT; however, the default
        // swap behavior might be EGL_BUFFER_PRESERVED, which means we
        // want to set mDirtyRegions. We try to do this only if dirty
        // regions were initially requested as part of the device
        // configuration (see RENDER_DIRTY_REGIONS)
        mDirtyRegionsEnabled = GLES20Canvas.isBackBufferPreserved();
    }
    return mEglContext.getGL();
}","{
    // Check preconditions.
    if (sEgl == null) {
        throw new RuntimeException(""egl not initialized"");
    }
    if (sEglDisplay == null) {
        throw new RuntimeException(""eglDisplay not initialized"");
    }
    if (sEglConfig == null) {
        throw new RuntimeException(""eglConfig not initialized"");
    }
    if (Thread.currentThread() != mEglThread) {
        throw new IllegalStateException(""HardwareRenderer cannot be used "" + ""from multiple threads"");
    }
    // In case we need to destroy an existing surface
    destroySurface();
    // Create an EGL surface we can render into.
    if (!createSurface(holder)) {
        return null;
    }
    /*
             * Before we can issue GL commands, we need to make sure
             * the context is current and bound to a surface.
             */
    if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
        throw new Surface.OutOfResourcesException(""eglMakeCurrent failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
    }
    initCaches();
    enableDirtyRegions();
    return mEglContext.getGL();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The 'if' and 'else if' control flow block for handling 'sDirtyRegions' and 'sDirtyRegionsRequested' variables is replaced with a simple function call 'enableDirtyRegions()'. This code change type is categorized as ""Other statement changed"" (type 4).","Despite the change, it doesn't necessarily lead to a compatibility issue because the output, or potential exceptions, remains invariant regardless of the internal handling. So it is classified as ""No Compatibility Issue exist"" (type 0)."
834,<android.database.sqlite.SQLiteProgram: void bindAllArgsAsStrings(String[])>,15,16,<android.database.sqlite.SQLiteProgram: void bindAllArgsAsStrings(String[])>,<android.database.sqlite.SQLiteProgram: void bindAllArgsAsStrings(String[])>,0,"{
    if (bindArgs == null) {
        return;
    }
    int size = bindArgs.length;
    for (int i = 0; i < size; i++) {
        bindString(i + 1, bindArgs[i]);
    }
}","{
    if (bindArgs != null) {
        for (int i = bindArgs.length; i != 0; i--) {
            bindString(i, bindArgs[i - 1]);
        }
    }
}",1,"/**
 * Given an array of String bindArgs, this method binds all of them in one single call.
 *
 * @param bindArgs the String array of bind args.
 */
","/**
 * Given an array of String bindArgs, this method binds all of them in one single call.
 *
 * @param bindArgs the String array of bind args, none of which must be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",0,"There's no change in the functionality, but the for loop has been inverted in the late version and condition check in if statement is now positive instead of negative. So, the code change type is 1,3.","Though the order of operation has changed, it doesn't affect the final outcome as the bindString method will still receive the same inputs. Therefore no compatibility issue exists, so the CI type is 0."
835,<android.database.sqlite.SQLiteDatabase: void setMaxSqlCacheSize(int)>,15,16,<android.database.sqlite.SQLiteDatabase: void setMaxSqlCacheSize(int)>,<android.database.sqlite.SQLiteDatabase: void setMaxSqlCacheSize(int)>,0,"{
    synchronized (this) {
        LruCache<String, SQLiteCompiledSql> oldCompiledQueries = mCompiledQueries;
        if (cacheSize > MAX_SQL_CACHE_SIZE || cacheSize < 0) {
            throw new IllegalStateException(""expected value between 0 and "" + MAX_SQL_CACHE_SIZE);
        } else if (oldCompiledQueries != null && cacheSize < oldCompiledQueries.maxSize()) {
            throw new IllegalStateException(""cannot set cacheSize to a value less than the "" + ""value set with previous setMaxSqlCacheSize() call."");
        }
        mCompiledQueries = new LruCache<String, SQLiteCompiledSql>(cacheSize) {

            @Override
            protected void entryRemoved(boolean evicted, String key, SQLiteCompiledSql oldValue, SQLiteCompiledSql newValue) {
                verifyLockOwner();
                oldValue.releaseIfNotInUse();
            }
        };
        if (oldCompiledQueries != null) {
            for (Map.Entry<String, SQLiteCompiledSql> entry : oldCompiledQueries.snapshot().entrySet()) {
                mCompiledQueries.put(entry.getKey(), entry.getValue());
            }
        }
    }
}","{
    if (cacheSize > MAX_SQL_CACHE_SIZE || cacheSize < 0) {
        throw new IllegalStateException(""expected value between 0 and "" + MAX_SQL_CACHE_SIZE);
    }
    synchronized (mLock) {
        throwIfNotOpenLocked();
        final int oldMaxSqlCacheSize = mConfigurationLocked.maxSqlCacheSize;
        mConfigurationLocked.maxSqlCacheSize = cacheSize;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.maxSqlCacheSize = oldMaxSqlCacheSize;
            throw ex;
        }
    }
}",1,"/**
 * Sets the maximum size of the prepared-statement cache for this database.
 * (size of the cache = number of compiled-sql-statements stored in the cache).
 * <p>
 * Maximum cache size can ONLY be increased from its current size (default = 10).
 * If this method is called with smaller size than the current maximum value,
 * then IllegalStateException is thrown.
 * <p>
 * This method is thread-safe.
 *
 * @param cacheSize the size of the cache. can be (0 to {@link #MAX_SQL_CACHE_SIZE})
 * @throws IllegalStateException if input cacheSize > {@link #MAX_SQL_CACHE_SIZE} or
 * the value set with previous setMaxSqlCacheSize() call.
 */
","/**
 * Sets the maximum size of the prepared-statement cache for this database.
 * (size of the cache = number of compiled-sql-statements stored in the cache).
 * <p>
 * Maximum cache size can ONLY be increased from its current size (default = 10).
 * If this method is called with smaller size than the current maximum value,
 * then IllegalStateException is thrown.
 * <p>
 * This method is thread-safe.
 *
 * @param cacheSize the size of the cache. can be (0 to {@link #MAX_SQL_CACHE_SIZE})
 * @throws IllegalStateException if input cacheSize > {@link #MAX_SQL_CACHE_SIZE}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","There's almost no identical code between the early and late implementation. Specifically, the whole logic on how to handle the setMaxSqlCacheSize operation has changed. New condition handling, exception throwing and synchronization statements are introduced, and the previous code implementation is deleted. Therefore, the change types are 1, 2, 3, 4.","The late version introduces new exception handling and change the logic of setting cache size, which could make the method potentially return a different result and throw a different exception compared with the early version. So, the CI type is 1,2."
837,<android.database.DatabaseUtils: int getSqlStatementType(String)>,15,16,<android.database.DatabaseUtils: int getSqlStatementType(String)>,<android.database.DatabaseUtils: int getSqlStatementType(String)>,0,"{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase();
    if (prefixSql.equals(""SEL"")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals(""INS"") || prefixSql.equals(""UPD"") || prefixSql.equals(""REP"") || prefixSql.equals(""DEL"")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals(""ATT"")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals(""COM"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""END"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""ROL"")) {
        return STATEMENT_ABORT;
    } else if (prefixSql.equals(""BEG"")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals(""PRA"")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals(""CRE"") || prefixSql.equals(""DRO"") || prefixSql.equals(""ALT"")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals(""ANA"") || prefixSql.equals(""DET"")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}","{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase(Locale.US);
    if (prefixSql.equals(""SEL"")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals(""INS"") || prefixSql.equals(""UPD"") || prefixSql.equals(""REP"") || prefixSql.equals(""DEL"")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals(""ATT"")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals(""COM"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""END"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""ROL"")) {
        return STATEMENT_ABORT;
    } else if (prefixSql.equals(""BEG"")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals(""PRA"")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals(""CRE"") || prefixSql.equals(""DRO"") || prefixSql.equals(""ALT"")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals(""ANA"") || prefixSql.equals(""DET"")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}",1,"/**
 * Returns one of the following which represent the type of the given SQL statement.
 * <ol>
 * <li>{@link #STATEMENT_SELECT}</li>
 * <li>{@link #STATEMENT_UPDATE}</li>
 * <li>{@link #STATEMENT_ATTACH}</li>
 * <li>{@link #STATEMENT_BEGIN}</li>
 * <li>{@link #STATEMENT_COMMIT}</li>
 * <li>{@link #STATEMENT_ABORT}</li>
 * <li>{@link #STATEMENT_OTHER}</li>
 * </ol>
 * @param sql the SQL statement whose type is returned by this method
 * @return one of the values listed above
 */
","/**
 * Returns one of the following which represent the type of the given SQL statement.
 * <ol>
 * <li>{@link #STATEMENT_SELECT}</li>
 * <li>{@link #STATEMENT_UPDATE}</li>
 * <li>{@link #STATEMENT_ATTACH}</li>
 * <li>{@link #STATEMENT_BEGIN}</li>
 * <li>{@link #STATEMENT_COMMIT}</li>
 * <li>{@link #STATEMENT_ABORT}</li>
 * <li>{@link #STATEMENT_OTHER}</li>
 * </ol>
 * @param sql the SQL statement whose type is returned by this method
 * @return one of the values listed above
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method toUpperCase() in the line 'String prefixSql = sql.substring(0, 3).toUpperCase();' has been changed and a parameter Locale.US has been added to it in the late version, so the code change type is 4,5.","After this change, the API will potentially return a different value because the uppercase can be different depending on the local environment, so the CI type is 1."
838,<android.animation.LayoutTransition: long getStagger(int)>,15,16,<android.animation.LayoutTransition: long getStagger(int)>,<android.animation.LayoutTransition: long getStagger(int)>,0,"{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingStagger;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingStagger;
    }
    // shouldn't reach here
    return 0;
}","{
    switch(transitionType) {
        case CHANGE_APPEARING:
            return mChangingAppearingStagger;
        case CHANGE_DISAPPEARING:
            return mChangingDisappearingStagger;
        case CHANGING:
            return mChangingStagger;
    }
    // shouldn't reach here
    return 0;
}",1,"/**
 * Tets the length of time to delay between starting each animation during one of the
 * CHANGE animations.
 *
 * @param transitionType A value of {@link #CHANGE_APPEARING} or @link #CHANGE_DISAPPEARING}.
 * @return long The length of time, in milliseconds, to delay before launching the next
 * animation in the sequence.
 */
","/**
 * Gets the length of time to delay between starting each animation during one of the
 * change animations.
 *
 * @param transitionType A value of {@link #CHANGE_APPEARING}, {@link #CHANGE_DISAPPEARING}, or
 * {@link #CHANGING}.
 * @return long The length of time, in milliseconds, to delay before launching the next
 * animation in the sequence.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"There is a new case 'CHANGING' added to the 'switch' statement, and this new case contains a return statement: 'return mChangingStagger;'. So the code change types are 3,1.","As the new case in 'switch' statement provides a new return statement, the API potentially returns different values based on the input 'transitionType'. Therefore, the CI type is 1."
840,"<android.widget.ExpandableListView: boolean expandGroup(int,boolean)>",15,16,"<android.widget.ExpandableListView: boolean expandGroup(int,boolean)>","<android.widget.ExpandableListView: boolean expandGroup(int,boolean)>",0,"{
    PositionMetadata pm = mConnector.getFlattenedPos(ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1));
    boolean retValue = mConnector.expandGroup(pm);
    if (mOnGroupExpandListener != null) {
        mOnGroupExpandListener.onGroupExpand(groupPos);
    }
    if (animate) {
        final int groupFlatPos = pm.position.flatListPos;
        final int shiftedGroupPosition = groupFlatPos + getHeaderViewsCount();
        smoothScrollToPosition(shiftedGroupPosition + mAdapter.getChildrenCount(groupPos), shiftedGroupPosition);
    }
    pm.recycle();
    return retValue;
}","{
    ExpandableListPosition elGroupPos = ExpandableListPosition.obtain(ExpandableListPosition.GROUP, groupPos, -1, -1);
    PositionMetadata pm = mConnector.getFlattenedPos(elGroupPos);
    elGroupPos.recycle();
    boolean retValue = mConnector.expandGroup(pm);
    if (mOnGroupExpandListener != null) {
        mOnGroupExpandListener.onGroupExpand(groupPos);
    }
    if (animate) {
        final int groupFlatPos = pm.position.flatListPos;
        final int shiftedGroupPosition = groupFlatPos + getHeaderViewsCount();
        smoothScrollToPosition(shiftedGroupPosition + mAdapter.getChildrenCount(groupPos), shiftedGroupPosition);
    }
    pm.recycle();
    return retValue;
}",1,"/**
 * Expand a group in the grouped list view
 *
 * @param groupPos the group to be expanded
 * @param animate true if the expanding group should be animated in
 * @return True if the group was expanded, false otherwise (if the group
 * was already expanded, this will return false)
 */
","/**
 * Expand a group in the grouped list view
 *
 * @param groupPos the group to be expanded
 * @param animate true if the expanding group should be animated in
 * @return True if the group was expanded, false otherwise (if the group
 * was already expanded, this will return false)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is only a refactor: In the early version, the implementation uses one-line code to get the class object and pass it to the method, but in the late version, it separates this process into two lines code: first creating class object, and then pass the object to the method. However, these changes don't affect the function of this method, so the code change type is 4.","There is no compatibility issue as this change won't cause the method to return different values or types or throw different exceptions. Accordingly, the CI type is 0."
843,"<android.webkit.SelectActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",15,16,"<android.webkit.SelectActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>","<android.webkit.SelectActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",0,"{
    switch(item.getItemId()) {
        case android.R.id.copy:
            mWebView.copySelection();
            mode.finish();
            break;
        case com.android.internal.R.id.share:
            String selection = mWebView.getSelection();
            Browser.sendString(mWebView.getContext(), selection);
            mode.finish();
            break;
        case com.android.internal.R.id.select_all:
            mWebView.selectAll();
            break;
        case com.android.internal.R.id.find:
            String sel = mWebView.getSelection();
            mode.finish();
            mWebView.showFindDialog(sel, false);
            break;
        case com.android.internal.R.id.websearch:
            mode.finish();
            Intent i = new Intent(Intent.ACTION_WEB_SEARCH);
            i.putExtra(SearchManager.EXTRA_NEW_SEARCH, true);
            i.putExtra(SearchManager.QUERY, mWebView.getSelection());
            mWebView.getContext().startActivity(i);
            break;
        default:
            return false;
    }
    return true;
}","{
    switch(item.getItemId()) {
        case android.R.id.cut:
            mWebView.cutSelection();
            mode.finish();
            break;
        case android.R.id.copy:
            mWebView.copySelection();
            mode.finish();
            break;
        case android.R.id.paste:
            mWebView.pasteFromClipboard();
            mode.finish();
            break;
        case com.android.internal.R.id.share:
            String selection = mWebView.getSelection();
            Browser.sendString(mWebView.getContext(), selection);
            mode.finish();
            break;
        case com.android.internal.R.id.select_all:
            mWebView.selectAll();
            break;
        case com.android.internal.R.id.find:
            String sel = mWebView.getSelection();
            mode.finish();
            mWebView.showFindDialog(sel, false);
            break;
        case com.android.internal.R.id.websearch:
            mode.finish();
            Intent i = new Intent(Intent.ACTION_WEB_SEARCH);
            i.putExtra(SearchManager.EXTRA_NEW_SEARCH, true);
            i.putExtra(SearchManager.QUERY, mWebView.getSelection());
            if (!(mWebView.getContext() instanceof Activity)) {
                i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            }
            mWebView.getContext().startActivity(i);
            break;
        default:
            return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are several changes in the method's implementation. Firstly, the cases in the switch statement have been changed respectively. Secondly, more if statements have been added in the latest implementation. Lastly, the API which the method relies on has been changed as well, all indicating that a set of Other Statements has been changed which are neither Return Statements nor Exception Statements but are about control dependency and dependent API change. Thus, the code change type is 1,3,4.","The changes in the control flow could lead the method to return different results, thus, the CI type is 1."
844,<android.os.Looper: void prepare()>,15,16,<android.os.Looper: void prepare()>,<android.os.Looper: void prepare()>,0,"{
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(""Only one Looper may be created per thread"");
    }
    sThreadLocal.set(new Looper());
}","{
    prepare(true);
}",1,"/**
 * Initialize the current thread as a looper.
 * This gives you a chance to create handlers that then reference
 * this looper, before actually starting the loop. Be sure to call
 * {@link #loop()} after calling this method, and end it by calling
 * {@link #quit()}.
 */
","/**
 * Initialize the current thread as a looper.
 * This gives you a chance to create handlers that then reference
 * this looper, before actually starting the loop. Be sure to call
 * {@link #loop()} after calling this method, and end it by calling
 * {@link #quit()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The whole implementation of the function has changed. The early implementation has a conditional check and throws an exception if the condition is met. This check is replaced by the new Looper, set to the thread in the late implementation. So the change type is 1,5.","The new version of the API potentially returns a different value due to the changed implementation, and the thrown exception is also different, so the CI type is 1,2."
845,<android.webkit.WebSettings: int getCacheMode()>,15,16,<android.webkit.WebSettings: int getCacheMode()>,<android.webkit.WebSettings: int getCacheMode()>,0,"{
    return mOverrideCacheMode;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return the current setting for overriding the cache mode. For a full
 * description, see the {@link #setCacheMode(int)} function.
 */
","/**
 * Gets the current setting for overriding the cache mode. For a full
 * description, see the {@link #setCacheMode(int)} function.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement was removed and an exception handling statement was added. So, the code change category is both 1 and 2.","The change in code would lead to CI as returning mOverrideCacheMode is now replaced by throwing an exception, which, essentially alter the program's flow control. Therefore, CI is caused by both 1) potential differences in return values, and 2) potential differences in exception handling."
847,<android.webkit.WebSettings: boolean getLoadsImagesAutomatically()>,15,16,<android.webkit.WebSettings: boolean getLoadsImagesAutomatically()>,<android.webkit.WebSettings: boolean getLoadsImagesAutomatically()>,0,"{
    return mLoadsImagesAutomatically;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return true if the WebView will load image resources automatically.
 * The default is true.
 * @return True if the WebView loads images automatically.
 */
","/**
 * Gets whether the WebView loads image resources. This includes
 * images embedded using the data URI scheme.
 *
 * @return true if the WebView loads image resources
 * @see #setLoadsImagesAutomatically
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The original return statement has been replaced with a new throw statement, so the code change type is 1,2.","In the early version, this method returns the value mLoadsImagesAutomatically, but in the late version, it throws a MustOverrideException. This can cause the method to behave differently if invoked in the same context in the early and late versions, so it causes a compatibility issue of type 1,2."
849,<android.widget.NumberPicker: void onDraw(Canvas)>,15,16,<android.widget.NumberPicker: void onDraw(Canvas)>,<android.widget.NumberPicker: void onDraw(Canvas)>,0,"{
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {
        return;
    }
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    final int restoreCount = canvas.save();
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_SMALL) {
        Rect clipBounds = canvas.getClipBounds();
        clipBounds.inset(0, mSelectorElementHeight);
        canvas.clipRect(clipBounds);
    }
    // draw the selector wheel
    int[] selectorIndices = mSelectorIndices;
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        // value intermixed with the new one.
        if (i != SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() != VISIBLE) {
            canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
        }
        y += mSelectorElementHeight;
    }
    // draw the selection dividers (only if scrolling and drawable specified)
    if (mSelectionDivider != null) {
        // draw the top divider
        int topOfTopDivider = (getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int topOfBottomDivider = topOfTopDivider + mSelectorElementHeight;
        int bottomOfBottomDivider = bottomOfTopDivider + mSelectorElementHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
    canvas.restoreToCount(restoreCount);
}","{
    if (!mHasSelectorWheel) {
        super.onDraw(canvas);
        return;
    }
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    // draw the virtual buttons pressed state if needed
    if (mVirtualButtonPressedDrawable != null && mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
        if (mDecrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
        if (mIncrementVirtualButtonPressed) {
            mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
            mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight, mBottom);
            mVirtualButtonPressedDrawable.draw(canvas);
        }
    }
    // draw the selector wheel
    int[] selectorIndices = mSelectorIndices;
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        // with the new one.
        if (i != SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() != VISIBLE) {
            canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
        }
        y += mSelectorElementHeight;
    }
    // draw the selection dividers
    if (mSelectionDivider != null) {
        // draw the top divider
        int topOfTopDivider = mTopSelectionDividerTop;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int bottomOfBottomDivider = mBottomSelectionDividerBottom;
        int topOfBottomDivider = bottomOfBottomDivider - mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control statements and system calls have changed. This can be observed in the if checks where different conditions are checked in the two versions which is a change directly under the control dependency category. Also, most lines where various methods are called are different in the two versions, which indicates a significant code change not involving return and exception statements, and thus signifies an 'other statement change' category.","Despite these changes, the function doesn't exhibit compatibility issues. The return type doesn't change nor does the function potentially throw any exceptions differently between the two versions."
851,<android.webkit.WebSettings: void setDomStorageEnabled(boolean)>,15,16,<android.webkit.WebSettings: void setDomStorageEnabled(boolean)>,<android.webkit.WebSettings: void setDomStorageEnabled(boolean)>,0,"{
    if (mDomStorageEnabled != flag) {
        mDomStorageEnabled = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set whether the DOM storage API is enabled.
 * @param flag boolean True if the WebView should use the DOM storage
 * API.
 */
","/**
 * Sets whether the DOM storage API is enabled.
 *
 * @param flag true if the WebView should use the DOM storage API
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late implementation, all previous code is removed and instead an exception statement is introduced, which results in changes in both return and exception handling statements. Therefore, the code change types are 1,2.","The completely different behavior in the late version potentially leads to different return values (including no return in late version) and throws a completely new exception, so the Compatibility Issue type is 1,2."
852,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,15,16,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,0,"{
    try {
        return sGlobals.mService.getWallpaperInfo();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            return null;
        } else {
            return sGlobals.mService.getWallpaperInfo();
        }
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
","/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation has introduced a new 'if' control statement and added a new log statement, so the change types are 3,4.","Due to the introduced 'if' statement, the returned value could potentially be different compared to the early version. If 'sGlobals.mService' is null, the API will directly return null rather than invoking 'getWallpaperInfo()', this could lead to a compatibility issue, so CI type is 1."
853,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,15,16,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float x = ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final int x = (int) ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int x = (int) ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = (int) ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = (int) ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return values in 'if' and 'switch' statements have changed. Also, the variable 'x' type has changed from 'float' to 'int'. So, the code change type is 1,4.","Due to the revision of the type of the variable 'x' and the change of return statements, the API might return different values and thus the CI type is 1."
854,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,15,16,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,0,"{
    // we expect the cursor is already at the row we need to read from
    final long eventId = cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
    ContentValues cv = new ContentValues();
    cv.put(Events._ID, eventId);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, TITLE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DESCRIPTION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_LOCATION);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, STATUS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SELF_ATTENDEE_STATUS);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTSTART);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTEND);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DURATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_END_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ALL_DAY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, AVAILABILITY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_ALARM);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_EXTENDED_PROPERTIES);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_SYNC_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, ORIGINAL_INSTANCE_TIME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ORIGINAL_ALL_DAY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_DATE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, HAS_ATTENDEE_DATA);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_INVITE_OTHERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_MODIFY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_SEE_GUESTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_SYNCED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    Entity entity = new Entity(cv);
    Cursor subCursor;
    if (mResolver != null) {
        subCursor = mResolver.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues reminderValues = new ContentValues();
            reminderValues.put(Reminders.MINUTES, subCursor.getInt(COLUMN_MINUTES));
            reminderValues.put(Reminders.METHOD, subCursor.getInt(COLUMN_METHOD));
            entity.addSubValue(Reminders.CONTENT_URI, reminderValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues attendeeValues = new ContentValues();
            attendeeValues.put(Attendees.ATTENDEE_NAME, subCursor.getString(COLUMN_ATTENDEE_NAME));
            attendeeValues.put(Attendees.ATTENDEE_EMAIL, subCursor.getString(COLUMN_ATTENDEE_EMAIL));
            attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP, subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
            attendeeValues.put(Attendees.ATTENDEE_TYPE, subCursor.getInt(COLUMN_ATTENDEE_TYPE));
            attendeeValues.put(Attendees.ATTENDEE_STATUS, subCursor.getInt(COLUMN_ATTENDEE_STATUS));
            entity.addSubValue(Attendees.CONTENT_URI, attendeeValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues extendedValues = new ContentValues();
            extendedValues.put(ExtendedProperties._ID, subCursor.getString(COLUMN_ID));
            extendedValues.put(ExtendedProperties.NAME, subCursor.getString(COLUMN_NAME));
            extendedValues.put(ExtendedProperties.VALUE, subCursor.getString(COLUMN_VALUE));
            entity.addSubValue(ExtendedProperties.CONTENT_URI, extendedValues);
        }
    } finally {
        subCursor.close();
    }
    cursor.moveToNext();
    return entity;
}","{
    // we expect the cursor is already at the row we need to read from
    final long eventId = cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
    ContentValues cv = new ContentValues();
    cv.put(Events._ID, eventId);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, TITLE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DESCRIPTION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_LOCATION);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, STATUS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SELF_ATTENDEE_STATUS);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTSTART);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTEND);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DURATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_END_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ALL_DAY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, AVAILABILITY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_ALARM);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_EXTENDED_PROPERTIES);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_SYNC_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, ORIGINAL_INSTANCE_TIME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ORIGINAL_ALL_DAY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_DATE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, HAS_ATTENDEE_DATA);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_INVITE_OTHERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_MODIFY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_SEE_GUESTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_PACKAGE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_URI);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_SYNCED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    Entity entity = new Entity(cv);
    Cursor subCursor;
    if (mResolver != null) {
        subCursor = mResolver.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues reminderValues = new ContentValues();
            reminderValues.put(Reminders.MINUTES, subCursor.getInt(COLUMN_MINUTES));
            reminderValues.put(Reminders.METHOD, subCursor.getInt(COLUMN_METHOD));
            entity.addSubValue(Reminders.CONTENT_URI, reminderValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues attendeeValues = new ContentValues();
            attendeeValues.put(Attendees.ATTENDEE_NAME, subCursor.getString(COLUMN_ATTENDEE_NAME));
            attendeeValues.put(Attendees.ATTENDEE_EMAIL, subCursor.getString(COLUMN_ATTENDEE_EMAIL));
            attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP, subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
            attendeeValues.put(Attendees.ATTENDEE_TYPE, subCursor.getInt(COLUMN_ATTENDEE_TYPE));
            attendeeValues.put(Attendees.ATTENDEE_STATUS, subCursor.getInt(COLUMN_ATTENDEE_STATUS));
            attendeeValues.put(Attendees.ATTENDEE_IDENTITY, subCursor.getInt(COLUMN_ATTENDEE_IDENTITY));
            attendeeValues.put(Attendees.ATTENDEE_ID_NAMESPACE, subCursor.getInt(COLUMN_ATTENDEE_ID_NAMESPACE));
            entity.addSubValue(Attendees.CONTENT_URI, attendeeValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues extendedValues = new ContentValues();
            extendedValues.put(ExtendedProperties._ID, subCursor.getString(COLUMN_ID));
            extendedValues.put(ExtendedProperties.NAME, subCursor.getString(COLUMN_NAME));
            extendedValues.put(ExtendedProperties.VALUE, subCursor.getString(COLUMN_VALUE));
            entity.addSubValue(ExtendedProperties.CONTENT_URI, extendedValues);
        }
    } finally {
        subCursor.close();
    }
    cursor.moveToNext();
    return entity;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
855,<android.animation.ValueAnimator: long getFrameDelay()>,15,16,<android.animation.ValueAnimator: long getFrameDelay()>,<android.animation.ValueAnimator: long getFrameDelay()>,0,"{
    return sFrameDelay;
}","{
    return Choreographer.getFrameDelay();
}",1,"/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * @return the requested time between frames, in milliseconds
 */
","/**
 * The amount of time, in milliseconds, between each frame of the animation. This is a
 * requested time that the animation will attempt to honor, but the actual delay between
 * frames may be different, depending on system load and capabilities. This is a static
 * function because the same delay will be applied to all animations, since they are all
 * run off of a single timing loop.
 *
 * The frame delay may be ignored when the animation system uses an external timing
 * source, such as the display refresh rate (vsync), to govern animations.
 *
 * @return the requested time between frames, in milliseconds
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The API used to return the static variable sFrameDelay, but in the late version, it returns the result of function Choreographer.getFrameDelay(). This could be seen as both a returned value change and dependent API change. ","The change from sFrameDelay to Choreographer.getFrameDelay() will make API potentially return different values. Therefore, a compatibility issue might occur due to the potential change in return values."
856,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,15,16,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IEventListenerWrapper(this);
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void onSetConnectionId(int connectionId) {
            mConnectionId = connectionId;
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement is changed from 'return new IEventListenerWrapper(this);' to 'return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {...})', this change can be classified as 1 and 5, as it involves a different type of returned object and changed method dependencies.","Because of the return statement change, the API would potentially return different types of objects between two versions, hence causing the compatibility issue of type 1."
857,<android.widget.ExpandableListView: int getFlatListPosition(long)>,15,16,<android.widget.ExpandableListView: int getFlatListPosition(long)>,<android.widget.ExpandableListView: int getFlatListPosition(long)>,0,"{
    PositionMetadata pm = mConnector.getFlattenedPos(ExpandableListPosition.obtainPosition(packedPosition));
    final int flatListPosition = pm.position.flatListPos;
    pm.recycle();
    return getAbsoluteFlatPosition(flatListPosition);
}","{
    ExpandableListPosition elPackedPos = ExpandableListPosition.obtainPosition(packedPosition);
    PositionMetadata pm = mConnector.getFlattenedPos(elPackedPos);
    elPackedPos.recycle();
    final int flatListPosition = pm.position.flatListPos;
    pm.recycle();
    return getAbsoluteFlatPosition(flatListPosition);
}",1,"/**
 * Converts a group and/or child position to a flat list position. This is
 * useful in situations where the caller needs to use the underlying
 * {@link ListView}'s methods.
 *
 * @param packedPosition The group and/or child positions to be converted in
 * packed position representation. Use
 * {@link #getPackedPositionForChild(int, int)} or
 * {@link #getPackedPositionForGroup(int)}.
 * @return The flat list position for the given child or group.
 */
","/**
 * Converts a group and/or child position to a flat list position. This is
 * useful in situations where the caller needs to use the underlying
 * {@link ListView}'s methods.
 *
 * @param packedPosition The group and/or child positions to be converted in
 * packed position representation. Use
 * {@link #getPackedPositionForChild(int, int)} or
 * {@link #getPackedPositionForGroup(int)}.
 * @return The flat list position for the given child or group.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method used to obtain the position has changed from 'ExpandableListPosition.obtainPosition(packedPosition)' to 'ExpandableListPosition.obtainPosition(packedPosition)', also, the argument passed to 'mConnector.getFlattenedPos()' has changed, so the code change type is 4,5.","As the function used to create 'elPackedPos' has changed, it could potentially change the return value of APIs, therefore, the CI type is 1."
858,"<android.app.LoaderManagerImpl: Loader<D> restartLoader(int,Bundle,LoaderCallbacks<D>)>",15,16,"<android.app.LoaderManagerImpl: Loader<D> restartLoader(int,Bundle,LoaderCallbacks<D>)>","<android.app.LoaderManagerImpl: Loader<D> restartLoader(int,Bundle,LoaderCallbacks<D>)>",0,"{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    LoaderInfo info = mLoaders.get(id);
    if (DEBUG)
        Log.v(TAG, ""restartLoader in "" + this + "": args="" + args);
    if (info != null) {
        LoaderInfo inactive = mInactiveLoaders.get(id);
        if (inactive != null) {
            if (info.mHaveData) {
                // that now.
                if (DEBUG)
                    Log.v(TAG, ""  Removing last inactive loader: "" + info);
                inactive.mDeliveredData = false;
                inactive.destroy();
                info.mLoader.abandon();
                mInactiveLoaders.put(id, info);
            } else {
                // waiting for!  What to do, what to do...
                if (!info.mStarted) {
                    // thank-you-ma'am.
                    if (DEBUG)
                        Log.v(TAG, ""  Current loader is stopped; replacing"");
                    mLoaders.put(id, null);
                    info.destroy();
                } else {
                    // finishes.
                    if (info.mPendingLoader != null) {
                        if (DEBUG)
                            Log.v(TAG, ""  Removing pending loader: "" + info.mPendingLoader);
                        info.mPendingLoader.destroy();
                        info.mPendingLoader = null;
                    }
                    if (DEBUG)
                        Log.v(TAG, ""  Enqueuing as new pending loader"");
                    info.mPendingLoader = createLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
                    return (Loader<D>) info.mPendingLoader.mLoader;
                }
            }
        } else {
            // it when the new one completes.
            if (DEBUG)
                Log.v(TAG, ""  Making last loader inactive: "" + info);
            info.mLoader.abandon();
            mInactiveLoaders.put(id, info);
        }
    }
    info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
    return (Loader<D>) info.mLoader;
}","{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    LoaderInfo info = mLoaders.get(id);
    if (DEBUG)
        Log.v(TAG, ""restartLoader in "" + this + "": args="" + args);
    if (info != null) {
        LoaderInfo inactive = mInactiveLoaders.get(id);
        if (inactive != null) {
            if (info.mHaveData) {
                // that now.
                if (DEBUG)
                    Log.v(TAG, ""  Removing last inactive loader: "" + info);
                inactive.mDeliveredData = false;
                inactive.destroy();
                info.mLoader.abandon();
                mInactiveLoaders.put(id, info);
            } else {
                // waiting for!  What to do, what to do...
                if (!info.mStarted) {
                    // thank-you-ma'am.
                    if (DEBUG)
                        Log.v(TAG, ""  Current loader is stopped; replacing"");
                    mLoaders.put(id, null);
                    info.destroy();
                } else {
                    // finishes or is canceled.
                    if (DEBUG)
                        Log.v(TAG, ""  Current loader is running; attempting to cancel"");
                    info.cancel();
                    if (info.mPendingLoader != null) {
                        if (DEBUG)
                            Log.v(TAG, ""  Removing pending loader: "" + info.mPendingLoader);
                        info.mPendingLoader.destroy();
                        info.mPendingLoader = null;
                    }
                    if (DEBUG)
                        Log.v(TAG, ""  Enqueuing as new pending loader"");
                    info.mPendingLoader = createLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
                    return (Loader<D>) info.mPendingLoader.mLoader;
                }
            }
        } else {
            // it when the new one completes.
            if (DEBUG)
                Log.v(TAG, ""  Making last loader inactive: "" + info);
            info.mLoader.abandon();
            mInactiveLoaders.put(id, info);
        }
    }
    info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
    return (Loader<D>) info.mLoader;
}",1,"/**
 * Call to re-create the Loader associated with a particular ID.  If there
 * is currently a Loader associated with this ID, it will be
 * canceled/stopped/destroyed as appropriate.  A new Loader with the given
 * arguments will be created and its data delivered to you once available.
 *
 * <p>This function does some throttling of Loaders.  If too many Loaders
 * have been created for the given ID but not yet generated their data,
 * new calls to this function will create and return a new Loader but not
 * actually start it until some previous loaders have completed.
 *
 * <p>After calling this function, any previous Loaders associated with
 * this ID will be considered invalid, and you will receive no further
 * data updates from them.
 *
 * @param id A unique (to this LoaderManager instance) identifier under
 * which to manage the new Loader.
 * @param args Optional arguments that will be propagated to
 * {@link LoaderCallbacks#onCreateLoader(int, Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.
 * Its onCreateLoader() method will be called while inside of the function to
 * instantiate the Loader object.
 */
","/**
 * Call to re-create the Loader associated with a particular ID.  If there
 * is currently a Loader associated with this ID, it will be
 * canceled/stopped/destroyed as appropriate.  A new Loader with the given
 * arguments will be created and its data delivered to you once available.
 *
 * <p>This function does some throttling of Loaders.  If too many Loaders
 * have been created for the given ID but not yet generated their data,
 * new calls to this function will create and return a new Loader but not
 * actually start it until some previous loaders have completed.
 *
 * <p>After calling this function, any previous Loaders associated with
 * this ID will be considered invalid, and you will receive no further
 * data updates from them.
 *
 * @param id A unique (to this LoaderManager instance) identifier under
 * which to manage the new Loader.
 * @param args Optional arguments that will be propagated to
 * {@link LoaderCallbacks#onCreateLoader(int, Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.
 * Its onCreateLoader() method will be called while inside of the function to
 * instantiate the Loader object.
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,4,1,"In the late version, a new statement 'info.cancel();' is introduced, which is not related to return statements, exception handling statements, and control dependency. Therefore, the code change type is 4.","The introduction of 'info.cancel();' could potentially make the API return the value via 'return (Loader<D>) info.mPendingLoader.mLoader;' which may not be reached in the previous version when the same condition is met. Thus, the CI type is 1."
859,<android.app.ActivityThread.ActivityClientRecord: String toString()>,15,16,<android.app.ActivityThread.ActivityClientRecord: String toString()>,<android.app.ActivityThread.ActivityClientRecord: String toString()>,0,"{
    ComponentName componentName = intent.getComponent();
    return ""ActivityRecord{"" + Integer.toHexString(System.identityHashCode(this)) + "" token="" + token + "" "" + (componentName == null ? ""no component name"" : componentName.toShortString()) + ""}"";
}","{
    ComponentName componentName = intent != null ? intent.getComponent() : null;
    return ""ActivityRecord{"" + Integer.toHexString(System.identityHashCode(this)) + "" token="" + token + "" "" + (componentName == null ? ""no component name"" : componentName.toShortString()) + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The changes found in the given code relate to an early and late version where there is an extra check within ComponentName component initialization. They check if the intent is not null before calling the getComponent() method. Thus, the code change type is labeled as a Control dependency changed which is 3.","The change of the control dependency could have an impact on the returned result of the toString() method. If intent is null in the late version, the returned string will not include the component name. Hence it could return a different string value. Thus, the compatibility issue here is potentially different return values, type 1."
861,"<android.webkit.ZoomManager: void handleDoubleTap(float,float)>",15,16,"<android.webkit.ZoomManager: void handleDoubleTap(float,float)>","<android.webkit.ZoomManager: void handleDoubleTap(float,float)>",0,"{
    // User takes action, set initial zoom overview to false.
    mInitialZoomOverview = false;
    WebSettings settings = mWebView.getSettings();
    if (!isDoubleTapEnabled()) {
        return;
    }
    setZoomCenter(lastTouchX, lastTouchY);
    mAnchorX = mWebView.viewToContentX((int) lastTouchX + mWebView.getScrollX());
    mAnchorY = mWebView.viewToContentY((int) lastTouchY + mWebView.getScrollY());
    settings.setDoubleTapToastCount(0);
    // remove the zoom control after double tap
    dismissZoomPicker();
    /*
         * If the double tap was on a plugin then either zoom to maximize the
         * plugin on the screen or scale to overview mode.
         */
    Rect pluginBounds = mWebView.getPluginBounds(mAnchorX, mAnchorY);
    if (pluginBounds != null) {
        if (mWebView.isRectFitOnScreen(pluginBounds)) {
            zoomToOverview();
        } else {
            mWebView.centerFitRect(pluginBounds);
        }
        return;
    }
    final float newTextWrapScale;
    if (settings.getUseFixedViewport()) {
        newTextWrapScale = Math.max(mActualScale, getReadingLevelScale());
    } else {
        newTextWrapScale = mActualScale;
    }
    final boolean firstTimeReflow = !exceedsMinScaleIncrement(mActualScale, mTextWrapScale);
    if (firstTimeReflow || mInZoomOverview) {
        // In case first time reflow or in zoom overview mode, let reflow and zoom
        // happen at the same time.
        mTextWrapScale = newTextWrapScale;
    }
    if (settings.isNarrowColumnLayout() && exceedsMinScaleIncrement(mTextWrapScale, newTextWrapScale) && !firstTimeReflow && !mInZoomOverview) {
        // Reflow only.
        mTextWrapScale = newTextWrapScale;
        refreshZoomScale(true);
    } else if (!mInZoomOverview && willScaleTriggerZoom(getZoomOverviewScale())) {
        // Reflow, if necessary.
        if (mTextWrapScale > getReadingLevelScale()) {
            mTextWrapScale = getReadingLevelScale();
            refreshZoomScale(true);
        }
        zoomToOverview();
    } else {
        zoomToReadingLevelOrMore();
    }
}","{
    // User takes action, set initial zoom overview to false.
    mInitialZoomOverview = false;
    WebSettingsClassic settings = mWebView.getSettings();
    if (!isDoubleTapEnabled()) {
        return;
    }
    setZoomCenter(lastTouchX, lastTouchY);
    mAnchorX = mWebView.viewToContentX((int) lastTouchX + mWebView.getScrollX());
    mAnchorY = mWebView.viewToContentY((int) lastTouchY + mWebView.getScrollY());
    settings.setDoubleTapToastCount(0);
    // remove the zoom control after double tap
    dismissZoomPicker();
    final float newTextWrapScale;
    if (settings.getUseFixedViewport()) {
        newTextWrapScale = Math.max(mActualScale, getReadingLevelScale());
    } else {
        newTextWrapScale = mActualScale;
    }
    final boolean firstTimeReflow = !exceedsMinScaleIncrement(mActualScale, mTextWrapScale);
    if (firstTimeReflow || mInZoomOverview) {
        // In case first time reflow or in zoom overview mode, let reflow and zoom
        // happen at the same time.
        mTextWrapScale = newTextWrapScale;
    }
    if (settings.isNarrowColumnLayout() && exceedsMinScaleIncrement(mTextWrapScale, newTextWrapScale) && !firstTimeReflow && !mInZoomOverview) {
        // Reflow only.
        mTextWrapScale = newTextWrapScale;
        refreshZoomScale(true);
    } else if (!mInZoomOverview && willScaleTriggerZoom(getZoomOverviewScale())) {
        // Reflow, if necessary.
        if (mTextWrapScale > getReadingLevelScale()) {
            mTextWrapScale = getReadingLevelScale();
            refreshZoomScale(true);
        }
        zoomToOverview();
    } else {
        zoomToReadingLevel();
    }
}",1,"/**
 * The double tap gesture can result in different behaviors depending on the
 * content that is tapped.
 *
 * (1) PLUGINS: If the taps occur on a plugin then we maximize the plugin on
 * the screen. If the plugin is already maximized then zoom the user into
 * overview mode.
 *
 * (2) HTML/OTHER: If the taps occur outside a plugin then the following
 * heuristic is used.
 * A. If the current text wrap scale differs from newly calculated and the
 * layout algorithm specifies the use of NARROW_COLUMNS, then fit to
 * column by reflowing the text.
 * B. If the page is not in overview mode then change to overview mode.
 * C. If the page is in overmode then change to the default scale.
 */
","/**
 * The double tap gesture can result in different behaviors depending on the
 * content that is tapped.
 *
 * (1) PLUGINS: If the taps occur on a plugin then we maximize the plugin on
 * the screen. If the plugin is already maximized then zoom the user into
 * overview mode.
 *
 * (2) HTML/OTHER: If the taps occur outside a plugin then the following
 * heuristic is used.
 * A. If the current text wrap scale differs from newly calculated and the
 * layout algorithm specifies the use of NARROW_COLUMNS, then fit to
 * column by reflowing the text.
 * B. If the page is not in overview mode then change to overview mode.
 * C. If the page is in overmode then change to the default scale.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The following changes occur in the code: ,3) The last return statement 'zoomToReadingLevelOrMore();' has been modified to 'zoomToReadingLevel();' (Return statement changed: 1);
862,"<android.util.TimeUtils: TimeZone getTimeZone(int,boolean,long,String)>",15,16,"<android.util.TimeUtils: TimeZone getTimeZone(int,boolean,long,String)>","<android.util.TimeUtils: TimeZone getTimeZone(int,boolean,long,String)>",0,"{
    if (country == null) {
        return null;
    }
    TimeZone best = null;
    Resources r = Resources.getSystem();
    XmlResourceParser parser = r.getXml(com.android.internal.R.xml.time_zones_by_country);
    Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    try {
        XmlUtils.beginDocument(parser, ""timezones"");
        while (true) {
            XmlUtils.nextElement(parser);
            String element = parser.getName();
            if (element == null || !(element.equals(""timezone""))) {
                break;
            }
            String code = parser.getAttributeValue(null, ""code"");
            if (country.equals(code)) {
                if (parser.next() == XmlPullParser.TEXT) {
                    String maybe = parser.getText();
                    if (maybe.equals(currentName)) {
                        if (currentOffset == offset && currentDst == dst) {
                            return current;
                        }
                    }
                    if (best == null) {
                        TimeZone tz = TimeZone.getTimeZone(maybe);
                        if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                            best = tz;
                        }
                    }
                }
            }
        }
    } catch (XmlPullParserException e) {
        Log.e(TAG, ""Got exception while getting preferred time zone."", e);
    } catch (IOException e) {
        Log.e(TAG, ""Got exception while getting preferred time zone."", e);
    } finally {
        parser.close();
    }
    return best;
}","{
    TimeZone best = null;
    Resources r = Resources.getSystem();
    XmlResourceParser parser = r.getXml(com.android.internal.R.xml.time_zones_by_country);
    Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}",1,"/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */
","/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early version has an early return condition, which is completely missing in the late version. This indicates a return statement change, so the code change type is 1. The late version also changes the while loop in the early implementation to a for-loop over 'getTimeZones(country)', indicating a control dependency change, so the code change type also includes 3.","Depending on the input, the early version could potentially return null when 'country' is null. The same case is not present in the late version, meaning a slightly different functionality which can potentially lead to the API returning different values in both versions, therefore the CI type is 1."
864,"<android.widget.ScrollView: void smoothScrollBy(int,int)>",15,16,"<android.widget.ScrollView: void smoothScrollBy(int,int)>","<android.widget.ScrollView: void smoothScrollBy(int,int)>",0,"{
    if (getChildCount() == 0) {
        // Nothing to do.
        return;
    }
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        final int height = getHeight() - mPaddingBottom - mPaddingTop;
        final int bottom = getChildAt(0).getHeight();
        final int maxY = Math.max(0, bottom - height);
        final int scrollY = mScrollY;
        dy = Math.max(0, Math.min(scrollY + dy, maxY)) - scrollY;
        mScroller.startScroll(mScrollX, scrollY, 0, dy);
        invalidate();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
            if (mFlingStrictSpan != null) {
                mFlingStrictSpan.finish();
                mFlingStrictSpan = null;
            }
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}","{
    if (getChildCount() == 0) {
        // Nothing to do.
        return;
    }
    long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
    if (duration > ANIMATED_SCROLL_GAP) {
        final int height = getHeight() - mPaddingBottom - mPaddingTop;
        final int bottom = getChildAt(0).getHeight();
        final int maxY = Math.max(0, bottom - height);
        final int scrollY = mScrollY;
        dy = Math.max(0, Math.min(scrollY + dy, maxY)) - scrollY;
        mScroller.startScroll(mScrollX, scrollY, 0, dy);
        postInvalidateOnAnimation();
    } else {
        if (!mScroller.isFinished()) {
            mScroller.abortAnimation();
            if (mFlingStrictSpan != null) {
                mFlingStrictSpan.finish();
                mFlingStrictSpan = null;
            }
        }
        scrollBy(dx, dy);
    }
    mLastScroll = AnimationUtils.currentAnimationTimeMillis();
}",1,"/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
","/**
 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
 *
 * @param dx the number of pixels to scroll by on the X axis
 * @param dy the number of pixels to scroll by on the Y axis
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The function ""invalidate()"" has been replaced with ""postInvalidateOnAnimation()"". Both of these are internal methods for redrawing the view, so this is regarded as an 'other' statement change, i.e. type 4.","There is no compatibility issue between early and late version, as the root functionality and expected outcome remains the same. Although the implementation uses a different method for invalidating the view, both methods serve the same purpose - forcing a redraw of the view. Hence, type 0, no Compatibility Issue exists."
865,"<android.webkit.HTML5VideoViewProxy: HTML5VideoViewProxy getInstance(WebViewCore,int)>",15,16,"<android.webkit.HTML5VideoViewProxy: HTML5VideoViewProxy getInstance(WebViewCore,int)>","<android.webkit.HTML5VideoViewProxy: HTML5VideoViewProxy getInstance(WebViewCore,int)>",0,"{
    return new HTML5VideoViewProxy(webViewCore.getWebView(), nativePtr);
}","{
    return new HTML5VideoViewProxy(webViewCore.getWebViewClassic(), nativePtr);
}",1,"/**
 * The factory for HTML5VideoViewProxy instances.
 * @param webViewCore is the WebViewCore that is requesting the proxy.
 *
 * @return a new HTML5VideoViewProxy object.
 */
","/**
 * The factory for HTML5VideoViewProxy instances.
 * @param webViewCore is the WebViewCore that is requesting the proxy.
 *
 * @return a new HTML5VideoViewProxy object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The statement which creates a new instance of 'HTML5VideoViewProxy' is called with different methods 'getWebView()' and 'getWebViewClassic()', this indicates that their return type might differ. Hence, the code change type is 1,5.","As the return statement changed from 'getWebView()' to 'getWebViewClassic()', it could potentially return a different value to the caller, therefore the Compatibility Issue (CI) is of type 1, meaning it's caused by potential different return values."
867,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",15,16,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>","<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",0,"{
    throw new UnsupportedOperationException();
}","{
    // TODO: Implement
    region.getBounds(mClipBounds);
    return nClipRect(mRenderer, mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom, op.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the early version, an UnsupportedOperationException was thrown which is removed in the late version. In the late version, return statement and other statements have been added. Hence, the change types are 1 (return statement changed), 2 (exception handling statement changed), and 4 (other statements changed).","In the newer version, return statement has been added which returns a different value than the early version. The newer version also doesn't throw an exception which was thrown in the early version. Hence the Compatibility Issue (CI) types are 1 (potentially different return values or types) and 2 (potentially different exception handling)."
869,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,15,16,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,0,"{
    validateNotAppThread();
    try {
        (IWindowManager.Stub.asInterface(ServiceManager.getService(""window""))).injectPointerEvent(event, true);
    } catch (RemoteException e) {
    }
}","{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    InputManager.getInstance().injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
}",1,"/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
","/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The try-catch block has been replaced with a new series of function calls, including a new return statement - InputManager.getInstance().injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH), and the implementation of the dependent APIs also changed, so the code change type is 1,4,5.","The complete change of the implementation means the behavior of the API is likely to have completely changed, making the return statement potentially return a different value, so the CI type is 1."
871,<android.webkit.WebSettings: boolean getSaveFormData()>,15,16,<android.webkit.WebSettings: boolean getSaveFormData()>,<android.webkit.WebSettings: boolean getSaveFormData()>,0,"{
    return mSaveFormData && !mPrivateBrowsingEnabled;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return whether the WebView is saving form data and displaying prior
 * entries/autofill++.  Always false in private browsing mode.
 */
","/**
 * Gets whether the WebView is saving form data and displaying prior
 * entries/autofill++.  Always false in private browsing mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The function no longer returns a boolean value. Instead, it throws a MustOverrideException in all situations. Thus, both the return statement and exception handling statement have been significantly altered. Hence, the code change types are 1 and 2.","The occurrence of the exception causes the function to behave differently, thus leading to a Compatibility Issue under types 1 (cause the API return different values) and 2 (throw different exception)."
872,<android.view.HardwareRenderer.GlRenderer: int checkCurrent()>,15,16,<android.view.HardwareRenderer.GlRenderer: int checkCurrent()>,<android.view.HardwareRenderer.GlRenderer: int checkCurrent()>,0,"{
    if (mEglThread != Thread.currentThread()) {
        throw new IllegalStateException(""Hardware acceleration can only be used with a "" + ""single UI thread.\nOriginal thread: "" + mEglThread + ""\n"" + ""Current thread: "" + Thread.currentThread());
    }
    if (!mEglContext.equals(sEgl.eglGetCurrentContext()) || !mEglSurface.equals(sEgl.eglGetCurrentSurface(EGL_DRAW))) {
        if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
            Log.e(LOG_TAG, ""eglMakeCurrent failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            fallback(true);
            return SURFACE_STATE_ERROR;
        } else {
            return SURFACE_STATE_UPDATED;
        }
    }
    return SURFACE_STATE_SUCCESS;
}","{
    if (mEglThread != Thread.currentThread()) {
        throw new IllegalStateException(""Hardware acceleration can only be used with a "" + ""single UI thread.\nOriginal thread: "" + mEglThread + ""\n"" + ""Current thread: "" + Thread.currentThread());
    }
    if (!mEglContext.equals(sEgl.eglGetCurrentContext()) || !mEglSurface.equals(sEgl.eglGetCurrentSurface(EGL_DRAW))) {
        if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
            Log.e(LOG_TAG, ""eglMakeCurrent failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            fallback(true);
            return SURFACE_STATE_ERROR;
        } else {
            if (mUpdateDirtyRegions) {
                enableDirtyRegions();
                mUpdateDirtyRegions = false;
            }
            return SURFACE_STATE_UPDATED;
        }
    }
    return SURFACE_STATE_SUCCESS;
}",1,"/**
 * Ensures the current EGL context is the one we expect.
 *
 * @return {@link #SURFACE_STATE_ERROR} if the correct EGL context cannot be made current,
 * {@link #SURFACE_STATE_UPDATED} if the EGL context was changed or
 * {@link #SURFACE_STATE_SUCCESS} if the EGL context was the correct one
 */
","/**
 * Ensures the current EGL context is the one we expect.
 *
 * @return {@link #SURFACE_STATE_ERROR} if the correct EGL context cannot be made current,
 * {@link #SURFACE_STATE_UPDATED} if the EGL context was changed or
 * {@link #SURFACE_STATE_SUCCESS} if the EGL context was the correct one
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new statement ""if (mUpdateDirtyRegions)..."" has been introduced. The 'mUpdateDirtyRegions' variable's value is manipulated inside this new 'if' statement, which is under another control statement ""if (!mEglContext.equals...)"", so the code change types should be 3,4.","The introduction of the new statement ""if (mUpdateDirtyRegions)..."" can potentially change the behaviour of the API when the condition is met. This could lead to the API returning a different value even if the conditions above are the same (""mEglThread != Thread.currentThread()"", and ""!mEglContext.equals...""), so the Compatibility Issue type is 1."
873,"<com.google.android.mms.pdu.PduPersister: void updateParts(Uri,PduBody)>",15,16,"<com.google.android.mms.pdu.PduPersister: void updateParts(Uri,PduBody)>","<com.google.android.mms.pdu.PduPersister: void updateParts(Uri,PduBody)>",0,"{
    PduCacheEntry cacheEntry = PDU_CACHE_INSTANCE.get(uri);
    if (cacheEntry != null) {
        ((MultimediaMessagePdu) cacheEntry.getPdu()).setBody(body);
    }
    ArrayList<PduPart> toBeCreated = new ArrayList<PduPart>();
    HashMap<Uri, PduPart> toBeUpdated = new HashMap<Uri, PduPart>();
    int partsNum = body.getPartsNum();
    StringBuilder filter = new StringBuilder().append('(');
    for (int i = 0; i < partsNum; i++) {
        PduPart part = body.getPart(i);
        Uri partUri = part.getDataUri();
        if ((partUri == null) || !partUri.getAuthority().startsWith(""mms"")) {
            toBeCreated.add(part);
        } else {
            toBeUpdated.put(partUri, part);
            // 'AND' since 'i = 0' may be skipped in another branch.
            if (filter.length() > 1) {
                filter.append("" AND "");
            }
            filter.append(Part._ID);
            filter.append(""!="");
            DatabaseUtils.appendEscapedSQLString(filter, partUri.getLastPathSegment());
        }
    }
    filter.append(')');
    long msgId = ContentUris.parseId(uri);
    // Remove the parts which doesn't exist anymore.
    SqliteWrapper.delete(mContext, mContentResolver, Uri.parse(Mms.CONTENT_URI + ""/"" + msgId + ""/part""), filter.length() > 2 ? filter.toString() : null, null);
    // Create new parts which didn't exist before.
    for (PduPart part : toBeCreated) {
        persistPart(part, msgId);
    }
    // Update the modified parts.
    for (Map.Entry<Uri, PduPart> e : toBeUpdated.entrySet()) {
        updatePart(e.getKey(), e.getValue());
    }
}","{
    try {
        PduCacheEntry cacheEntry;
        synchronized (PDU_CACHE_INSTANCE) {
            if (PDU_CACHE_INSTANCE.isUpdating(uri)) {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""updateParts: "" + uri + "" blocked by isUpdating()"");
                }
                try {
                    PDU_CACHE_INSTANCE.wait();
                } catch (InterruptedException e) {
                    Log.e(TAG, ""updateParts: "", e);
                }
                cacheEntry = PDU_CACHE_INSTANCE.get(uri);
                if (cacheEntry != null) {
                    ((MultimediaMessagePdu) cacheEntry.getPdu()).setBody(body);
                }
            }
            // Tell the cache to indicate to other callers that this item
            // is currently being updated.
            PDU_CACHE_INSTANCE.setUpdating(uri, true);
        }
        ArrayList<PduPart> toBeCreated = new ArrayList<PduPart>();
        HashMap<Uri, PduPart> toBeUpdated = new HashMap<Uri, PduPart>();
        int partsNum = body.getPartsNum();
        StringBuilder filter = new StringBuilder().append('(');
        for (int i = 0; i < partsNum; i++) {
            PduPart part = body.getPart(i);
            Uri partUri = part.getDataUri();
            if ((partUri == null) || !partUri.getAuthority().startsWith(""mms"")) {
                toBeCreated.add(part);
            } else {
                toBeUpdated.put(partUri, part);
                // 'AND' since 'i = 0' may be skipped in another branch.
                if (filter.length() > 1) {
                    filter.append("" AND "");
                }
                filter.append(Part._ID);
                filter.append(""!="");
                DatabaseUtils.appendEscapedSQLString(filter, partUri.getLastPathSegment());
            }
        }
        filter.append(')');
        long msgId = ContentUris.parseId(uri);
        // Remove the parts which doesn't exist anymore.
        SqliteWrapper.delete(mContext, mContentResolver, Uri.parse(Mms.CONTENT_URI + ""/"" + msgId + ""/part""), filter.length() > 2 ? filter.toString() : null, null);
        // Create new parts which didn't exist before.
        for (PduPart part : toBeCreated) {
            persistPart(part, msgId);
        }
        // Update the modified parts.
        for (Map.Entry<Uri, PduPart> e : toBeUpdated.entrySet()) {
            updatePart(e.getKey(), e.getValue());
        }
    } finally {
        synchronized (PDU_CACHE_INSTANCE) {
            PDU_CACHE_INSTANCE.setUpdating(uri, false);
            PDU_CACHE_INSTANCE.notifyAll();
        }
    }
}",1,"/**
 * Update all parts of a PDU.
 *
 * @param uri The PDU which need to be updated.
 * @param body New message body of the PDU.
 * @throws MmsException Bad URI or updating failed.
 */
","/**
 * Update all parts of a PDU.
 *
 * @param uri The PDU which need to be updated.
 * @param body New message body of the PDU.
 * @throws MmsException Bad URI or updating failed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"Exception handling statements have been introduced to handle InterruptedException and finally block is added to ensure PDU_CACHE_INSTANCE state is reset and all threads waiting for this object are notified. Also, the control flow has been altered with the introduction of synchronization block and if check for 'PDU_CACHE_INSTANCE.isUpdating(uri)'. So, the change type is 2,3.","The addition of exception handling for InterruptedException changes the method behavior because now these exceptions are not thrown to the calling method but handled inside this method itself, hence thetype of CI is 2."
874,<android.widget.NumberPicker: boolean dispatchTrackballEvent(MotionEvent)>,15,16,<android.widget.NumberPicker: boolean dispatchTrackballEvent(MotionEvent)>,<android.widget.NumberPicker: boolean dispatchTrackballEvent(MotionEvent)>,0,"{
    int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
        removeAllCallbacks();
    }
    return super.dispatchTrackballEvent(event);
}","{
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            removeAllCallbacks();
            break;
    }
    return super.dispatchTrackballEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed from an 'if' statement to a 'switch' case but both are handling the same logic. So, the change type is 3.","Although the control dependency has changed, the behavior of the function remains the same in both scenarios; and hence there is no compatibility issue, so the CI type is 0."
876,<android.widget.NumberPicker: boolean dispatchTouchEvent(MotionEvent)>,15,16,<android.widget.NumberPicker: boolean dispatchTouchEvent(MotionEvent)>,<android.widget.NumberPicker: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {
                removeAllCallbacks();
                forceCompleteChangeCurrentByOneViaScroll();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            removeAllCallbacks();
            break;
    }
    return super.dispatchTouchEvent(event);
}","{
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            removeAllCallbacks();
            break;
    }
    return super.dispatchTouchEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"There is a change in the 'switch' statement where the condition 'MotionEvent.ACTION_MOVE' and related operations are removed in the late version. Therefore, the code change type is 3 (Control dependency changed).","The changes are only made inside a control statement and don't affect the API's behavior in terms of return or thrown exceptions. Hence, no Compatibility Issue exists (type 0)."
877,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,15,16,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,0,"{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.onSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        // Only add this if it's not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }
    return result;
}","{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.onSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it's not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no changes between the early and late versions of the method. Both implementations are exactly the same.,"Since there are no changes, there could not be any compatibility issue."
878,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int)>",15,16,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int)>",0,"{
    if (mParent == null) {
        int result = IActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            intent.setAllowFds(false);
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), intent, intent.resolveTypeIfNeeded(getContentResolver()), null, 0, mToken, mEmbeddedID, requestCode, true, false, null, null, false);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != IActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    return startActivityIfNeeded(intent, requestCode, null);
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * Same as calling {@link #startActivityIfNeeded(Intent, int, Bundle)}
 * with no options.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the early version, the code involves multiple operations before returning a boolean value. In the late version, all of these operations has been replaced by the call to 'startActivityIfNeeded(intent, requestCode, null)', which suggests both return statement changed and dependent API changed. So the code change type is 1,5.","The API potentially returns different results in these two versions, leading to a different behavior which is regarded as a compatibility issue. Thus, the CI type is 1."
882,<android.database.sqlite.SQLiteDatabase: boolean isDbLockedByCurrentThread()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean isDbLockedByCurrentThread()>,<android.database.sqlite.SQLiteDatabase: boolean isDbLockedByCurrentThread()>,0,"{
    return mLock.isHeldByCurrentThread();
}","{
    acquireReference();
    try {
        return getThreadSession().hasConnection();
    } finally {
        releaseReference();
    }
}",1,"/**
 * Checks if the database lock is held by this thread.
 *
 * @return true, if this thread is holding the database lock.
 */
","/**
 * Returns true if the current thread is holding an active connection to the database.
 * <p>
 * The name of this method comes from a time when having an active connection
 * to the database meant that the thread was holding an actual lock on the
 * database.  Nowadays, there is no longer a true ""database lock"" although threads
 * may block if they cannot acquire a database connection to perform a
 * particular operation.
 * </p>
 *
 * @return True if the current thread is holding an active connection to the database.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"In the late version multiple statements have been introduced: acquireReference(), try - finally block, releaseReference() and return statement inside the try block is also changed, so the change type is 1,4,5.","The changes in the return statement can lead to potentially different return values, so the CI type is 1."
883,<android.webkit.WebView: int computeVerticalScrollRange()>,15,16,<android.webkit.WebView: int computeVerticalScrollRange()>,<android.webkit.WebView: int computeVerticalScrollRange()>,0,"{
    int range = computeRealVerticalScrollRange();
    // Adjust reported range if overscrolled to compress the scroll bars
    final int scrollY = mScrollY;
    final int overscrollBottom = computeMaxScrollY();
    if (scrollY < 0) {
        range -= scrollY;
    } else if (scrollY > overscrollBottom) {
        range += scrollY - overscrollBottom;
    }
    return range;
}","{
    return mProvider.getScrollDelegate().computeVerticalScrollRange();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire method implementation has changed from a complex calculation implementation to just a single return statement that calls another method, so the code change type is 1,5.","Because the method implementation completely changed, the returned value could potentially be different which leads to a compatibility issue, so the CI type is 1."
884,"<android.widget.RelativeLayout.DependencyGraph: void getSortedViews(View[],int)>",15,16,"<android.widget.RelativeLayout.DependencyGraph: void getSortedViews(View[],int)>","<android.widget.RelativeLayout.DependencyGraph: void getSortedViews(View[],int)>",0,"{
    final LinkedList<Node> roots = findRoots(rules);
    int index = 0;
    while (roots.size() > 0) {
        final Node node = roots.removeFirst();
        final View view = node.view;
        final int key = view.getId();
        sorted[index++] = view;
        final HashSet<Node> dependents = node.dependents;
        for (Node dependent : dependents) {
            final SparseArray<Node> dependencies = dependent.dependencies;
            dependencies.remove(key);
            if (dependencies.size() == 0) {
                roots.add(dependent);
            }
        }
    }
    if (index < sorted.length) {
        throw new IllegalStateException(""Circular dependencies cannot exist"" + "" in RelativeLayout"");
    }
}","{
    final ArrayDeque<Node> roots = findRoots(rules);
    int index = 0;
    Node node;
    while ((node = roots.pollLast()) != null) {
        final View view = node.view;
        final int key = view.getId();
        sorted[index++] = view;
        final HashMap<Node, DependencyGraph> dependents = node.dependents;
        for (Node dependent : dependents.keySet()) {
            final SparseArray<Node> dependencies = dependent.dependencies;
            dependencies.remove(key);
            if (dependencies.size() == 0) {
                roots.add(dependent);
            }
        }
    }
    if (index < sorted.length) {
        throw new IllegalStateException(""Circular dependencies cannot exist"" + "" in RelativeLayout"");
    }
}",1,"/**
 * Builds a sorted list of views. The sorting order depends on the dependencies
 * between the view. For instance, if view C needs view A to be processed first
 * and view A needs view B to be processed first, the dependency graph
 * is: B -> A -> C. The sorted array will contain views B, A and C in this order.
 *
 * @param sorted The sorted list of views. The length of this array must
 * be equal to getChildCount().
 * @param rules The list of rules to take into account.
 */
","/**
 * Builds a sorted list of views. The sorting order depends on the dependencies
 * between the view. For instance, if view C needs view A to be processed first
 * and view A needs view B to be processed first, the dependency graph
 * is: B -> A -> C. The sorted array will contain views B, A and C in this order.
 *
 * @param sorted The sorted list of views. The length of this array must
 * be equal to getChildCount().
 * @param rules The list of rules to take into account.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"Some of the local variables have changed their types from LinkedList<Node> to ArrayDeque<Node> and HashSet<Node> to HashMap<Node, DependencyGraph>. The while loop condition also changes from roots.size() > 0 to (node = roots.pollLast()) != null. Therefore, the change type belongs to 3,4,5.","Even though there are changes in the implementation of control dependency and other statements, these changes don't directly influence the final returned variable (no return value is changed) or change the way exception handling is done. So, the API doesn't seem to have a CI in this case, hence the type is 0."
886,"<android.widget.NumberPicker: void onLayout(boolean,int,int,int,int)>",15,16,"<android.widget.NumberPicker: void onLayout(boolean,int,int,int,int)>","<android.widget.NumberPicker: void onLayout(boolean,int,int,int,int)>",0,"{
    final int msrdWdth = getMeasuredWidth();
    final int msrdHght = getMeasuredHeight();
    // Increment button at the top.
    final int inctBtnMsrdWdth = mIncrementButton.getMeasuredWidth();
    final int incrBtnLeft = (msrdWdth - inctBtnMsrdWdth) / 2;
    final int incrBtnTop = 0;
    final int incrBtnRight = incrBtnLeft + inctBtnMsrdWdth;
    final int incrBtnBottom = incrBtnTop + mIncrementButton.getMeasuredHeight();
    mIncrementButton.layout(incrBtnLeft, incrBtnTop, incrBtnRight, incrBtnBottom);
    // Input text centered horizontally.
    final int inptTxtMsrdWdth = mInputText.getMeasuredWidth();
    final int inptTxtMsrdHght = mInputText.getMeasuredHeight();
    final int inptTxtLeft = (msrdWdth - inptTxtMsrdWdth) / 2;
    final int inptTxtTop = (msrdHght - inptTxtMsrdHght) / 2;
    final int inptTxtRight = inptTxtLeft + inptTxtMsrdWdth;
    final int inptTxtBottom = inptTxtTop + inptTxtMsrdHght;
    mInputText.layout(inptTxtLeft, inptTxtTop, inptTxtRight, inptTxtBottom);
    // Decrement button at the top.
    final int decrBtnMsrdWdth = mIncrementButton.getMeasuredWidth();
    final int decrBtnLeft = (msrdWdth - decrBtnMsrdWdth) / 2;
    final int decrBtnTop = msrdHght - mDecrementButton.getMeasuredHeight();
    final int decrBtnRight = decrBtnLeft + decrBtnMsrdWdth;
    final int decrBtnBottom = msrdHght;
    mDecrementButton.layout(decrBtnLeft, decrBtnTop, decrBtnRight, decrBtnBottom);
    if (!mScrollWheelAndFadingEdgesInitialized) {
        mScrollWheelAndFadingEdgesInitialized = true;
        // need to do all this when we know our size
        initializeSelectorWheel();
        initializeFadingEdges();
    }
}","{
    if (!mHasSelectorWheel) {
        super.onLayout(changed, left, top, right, bottom);
        return;
    }
    final int msrdWdth = getMeasuredWidth();
    final int msrdHght = getMeasuredHeight();
    // Input text centered horizontally.
    final int inptTxtMsrdWdth = mInputText.getMeasuredWidth();
    final int inptTxtMsrdHght = mInputText.getMeasuredHeight();
    final int inptTxtLeft = (msrdWdth - inptTxtMsrdWdth) / 2;
    final int inptTxtTop = (msrdHght - inptTxtMsrdHght) / 2;
    final int inptTxtRight = inptTxtLeft + inptTxtMsrdWdth;
    final int inptTxtBottom = inptTxtTop + inptTxtMsrdHght;
    mInputText.layout(inptTxtLeft, inptTxtTop, inptTxtRight, inptTxtBottom);
    if (changed) {
        // need to do all this when we know our size
        initializeSelectorWheel();
        initializeFadingEdges();
        mTopSelectionDividerTop = (getHeight() - mSelectionDividersDistance) / 2 - mSelectionDividerHeight;
        mBottomSelectionDividerBottom = mTopSelectionDividerTop + 2 * mSelectionDividerHeight + mSelectionDividersDistance;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early logic of the method included positioning for increment and decrement buttons which are removed in the late version. Besides, there is a new condition check if (!mHasSelectorWheel) with associated actions in the late version. Additionally, a new return statement (super.onLayout(changed, left, top, right, bottom); return;) is added in the late version. Therefore, the code change type is 1,3,4.","The logic in the late version has modified the method structure, and removed some variables' changes and operation. These differences could cause different behaviors of the API, thus the CI type is 1."
887,<android.webkit.WebSettings: int getMinimumLogicalFontSize()>,15,16,<android.webkit.WebSettings: int getMinimumLogicalFontSize()>,<android.webkit.WebSettings: int getMinimumLogicalFontSize()>,0,"{
    return mMinimumLogicalFontSize;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the minimum logical font size. The default is 8.
 * @return A non-negative integer between 1 and 72.
 */
","/**
 * Gets the minimum logical font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setMinimumLogicalFontSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the new version, a new throw statement has been added and the previous return statement has been removed, so the code change type is 1,2.","The new version always throws an exception and does not return a value, which leads to different behavior between the two versions. Thus, the Compatibility Issue type is 1,2."
888,"<android.widget.TextView: boolean onKeyPreIme(int,KeyEvent)>",15,16,"<android.widget.TextView: boolean onKeyPreIme(int,KeyEvent)>","<android.widget.TextView: boolean onKeyPreIme(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        boolean isInSelectionMode = mSelectionActionMode != null;
        if (isInSelectionMode) {
            if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                KeyEvent.DispatcherState state = getKeyDispatcherState();
                if (state != null) {
                    state.startTracking(event, this);
                }
                return true;
            } else if (event.getAction() == KeyEvent.ACTION_UP) {
                KeyEvent.DispatcherState state = getKeyDispatcherState();
                if (state != null) {
                    state.handleUpEvent(event);
                }
                if (event.isTracking() && !event.isCanceled()) {
                    if (isInSelectionMode) {
                        stopSelectionActionMode();
                        return true;
                    }
                }
            }
        }
    }
    return super.onKeyPreIme(keyCode, event);
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        boolean isInSelectionMode = mEditor != null && mEditor.mSelectionActionMode != null;
        if (isInSelectionMode) {
            if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                KeyEvent.DispatcherState state = getKeyDispatcherState();
                if (state != null) {
                    state.startTracking(event, this);
                }
                return true;
            } else if (event.getAction() == KeyEvent.ACTION_UP) {
                KeyEvent.DispatcherState state = getKeyDispatcherState();
                if (state != null) {
                    state.handleUpEvent(event);
                }
                if (event.isTracking() && !event.isCanceled()) {
                    stopSelectionActionMode();
                    return true;
                }
            }
        }
    }
    return super.onKeyPreIme(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The change in the code occurs in the definition of the 'isInSelectionMode' variable where an additional condition has been added, thus making the change type as 1,3,4,5. Apart from the condition, a variable member (mEditor) has been added to the early version to form the late version which could alter the behavior of the function.","The altered 'isInSelectionMode' condition would potentially change the path of execution in the function, leading to different return values in some scenarios, hence the Compatibility Issue type is 1."
891,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",15,16,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",0,"{
    return mContentProvider.bulkInsert(url, initialValues);
}","{
    try {
        return mContentProvider.bulkInsert(url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
","/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","A return statement has been wrapped inside a try-catch block and a new exception handling statement (throw e) has been added, so the code change type is 1,2.","The added exception handling could potentially make the API throw a different exception than the previous version. Also, the utilized scope of return statement has changed which could lead to different return behavior. Therefore, the Compatibility Issue types are 1,2."
892,"<android.webkit.CallbackProxy: boolean onJsConfirm(String,String)>",15,16,"<android.webkit.CallbackProxy: boolean onJsConfirm(String,String)>","<android.webkit.CallbackProxy: boolean onJsConfirm(String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return false;
    }
    JsResult result = new JsResult(this, false);
    Message confirm = obtainMessage(JS_CONFIRM, result);
    confirm.getData().putString(""message"", message);
    confirm.getData().putString(""url"", url);
    synchronized (this) {
        sendMessage(confirm);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for jsConfirm"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    return result.getResult();
}","{
    // been set.
    if (mWebChromeClient == null) {
        return false;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message confirm = obtainMessage(JS_CONFIRM, result);
    confirm.getData().putString(""message"", message);
    confirm.getData().putString(""url"", url);
    sendMessageToUiThreadSync(confirm);
    return result.mJsResult.getResult();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the changed implementation, the type of 'result' changed from 'JsResult' to 'JsResultReceiver'. The method 'sendMessage(confirm)' changed to 'sendMessageToUiThreadSync(confirm)' and 'return result.getResult();' changed to 'return result.mJsResult.getResult();'. Therefore, the code change is of type 1 and 5.","'JsResultReceiver' may potentially behave differently from 'JsResult', and the change of the return statement ('return result.getResult();' -> 'return result.mJsResult.getResult();') could lead to a different returned value. Thus, it introduces a compatibility issue of type 1."
894,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,15,16,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,0,"{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !mTextIsSelectable && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
}","{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyAccessibilityStateChanged();
    }
}",1,"/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
","/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's been a addition of an 'if' statement (if (hasPasswordTransformationMethod())) and a method invocation within that (notifyAccessibilityStateChanged()), which constitutes a change of a different kind of statement and brings the change type 4.","Although there's a new method invocation (notifyAccessibilityStateChanged()), this would not impact the return value or potential exceptions thrown by the API because this method is void. So no Compatibility Issue exists here."
895,<android.app.Instrumentation: void sendKeySync(KeyEvent)>,15,16,<android.app.Instrumentation: void sendKeySync(KeyEvent)>,<android.app.Instrumentation: void sendKeySync(KeyEvent)>,0,"{
    validateNotAppThread();
    try {
        (IWindowManager.Stub.asInterface(ServiceManager.getService(""window""))).injectKeyEvent(event, true);
    } catch (RemoteException e) {
    }
}","{
    validateNotAppThread();
    long downTime = event.getDownTime();
    long eventTime = event.getEventTime();
    int action = event.getAction();
    int code = event.getKeyCode();
    int repeatCount = event.getRepeatCount();
    int metaState = event.getMetaState();
    int deviceId = event.getDeviceId();
    int scancode = event.getScanCode();
    int source = event.getSource();
    int flags = event.getFlags();
    if (source == InputDevice.SOURCE_UNKNOWN) {
        source = InputDevice.SOURCE_KEYBOARD;
    }
    if (eventTime == 0) {
        eventTime = SystemClock.uptimeMillis();
    }
    if (downTime == 0) {
        downTime = eventTime;
    }
    KeyEvent newEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount, metaState, deviceId, scancode, flags | KeyEvent.FLAG_FROM_SYSTEM, source);
    InputManager.getInstance().injectInputEvent(newEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
}",1,"/**
 * Send a key event to the currently focused window/view and wait for it to
 * be processed.  Finished at some point after the recipient has returned
 * from its event processing, though it may <em>not</em> have completely
 * finished reacting from the event -- for example, if it needs to update
 * its display as a result, it may still be in the process of doing that.
 *
 * @param event The event to send to the current focus.
 */
","/**
 * Send a key event to the currently focused window/view and wait for it to
 * be processed.  Finished at some point after the recipient has returned
 * from its event processing, though it may <em>not</em> have completely
 * finished reacting from the event -- for example, if it needs to update
 * its display as a result, it may still be in the process of doing that.
 *
 * @param event The event to send to the current focus.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The early version of the API is implementing the remote procedure call using a ServiceManager and its throwing a remote exception. In the late version of the API, the remote procedure call is performed via InputManager, creating a new KeyEvent, and the exception handling section has been removed. So the change type is 1,4,5.","The exception handling statement has been removed in the late version, and injection of key events is performed differently in the late version. Therefore, the method is exposed to potentially return a different value and throw different exceptions, thus the CI type is 1,2."
896,"<android.webkit.CallbackProxy: void onJsAlert(String,String)>",15,16,"<android.webkit.CallbackProxy: void onJsAlert(String,String)>","<android.webkit.CallbackProxy: void onJsAlert(String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    JsResult result = new JsResult(this, false);
    Message alert = obtainMessage(JS_ALERT, result);
    alert.getData().putString(""message"", message);
    alert.getData().putString(""url"", url);
    synchronized (this) {
        sendMessage(alert);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for jsAlert"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
}","{
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message alert = obtainMessage(JS_ALERT, result);
    alert.getData().putString(""message"", message);
    alert.getData().putString(""url"", url);
    sendMessageToUiThreadSync(alert);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"The change between early and late implementation includes removing ""synchronized"", ""wait"" and the ""catch"" block, and introducing a new dependent API (sendMessageToUiThreadSync instead of sendMessage). Thus, the code change type is 1,4,5.","There is no Compatibility Issue situation, because removing synchronization and introducing sendMessageToUiThreadSync do not affect the return value or exception thrown by the method. As a result, the CI type is 0."
897,<android.server.BluetoothAdapterStateMachine.PerProcessState: boolean processMessage(Message)>,15,16,<android.server.BluetoothAdapterStateMachine.PerProcessState: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.PerProcessState: boolean processMessage(Message)>,0,"{
    log(""PerProcessState process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case PER_PROCESS_TURN_ON:
            mCallback = (IBluetoothStateChangeCallback) getCurrentMessage().obj;
            // If this is not the first application call the callback.
            if (mBluetoothService.getNumberOfApplicationStateChangeTrackers() > 1) {
                perProcessCallback(true, mCallback);
            }
            break;
        case SCAN_MODE_CHANGED:
            if (isTurningOn) {
                perProcessCallback(true, mCallback);
                isTurningOn = false;
            }
            break;
        case POWER_STATE_CHANGED:
            removeMessages(POWER_DOWN_TIMEOUT);
            if (!((Boolean) message.obj)) {
                transitionTo(mHotOff);
                if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                    deferMessage(obtainMessage(TURN_COLD));
                }
            } else {
                if (!isTurningOn) {
                    recoverStateMachine(TURN_COLD, null);
                    for (IBluetoothStateChangeCallback c : mBluetoothService.getApplicationStateChangeCallbacks()) {
                        perProcessCallback(false, c);
                        deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
                    }
                }
            }
            break;
        case POWER_DOWN_TIMEOUT:
            transitionTo(mHotOff);
            Log.e(TAG, ""Power-down timed out, resetting..."");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case USER_TURN_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            persistSwitchSetting(true);
            mBluetoothService.initBluetoothAfterTurningOn();
            transitionTo(mBluetoothOn);
            broadcastState(BluetoothAdapter.STATE_ON);
            // run bluetooth now that it's turned on
            mBluetoothService.runBluetooth();
            break;
        case TURN_HOT:
            broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
            if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
                mBluetoothService.disconnectDevices();
                sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT, DEVICES_DISCONNECT_TIMEOUT_TIME);
                break;
            }
        // $FALL-THROUGH$ all devices are already disconnected
        case ALL_DEVICES_DISCONNECTED:
            removeMessages(DEVICES_DISCONNECT_TIMEOUT);
            finishSwitchingOff();
            break;
        case DEVICES_DISCONNECT_TIMEOUT:
            finishSwitchingOff();
            Log.e(TAG, ""Devices fail to disconnect, reseting..."");
            transitionTo(mHotOff);
            deferMessage(obtainMessage(TURN_COLD));
            for (IBluetoothStateChangeCallback c : mBluetoothService.getApplicationStateChangeCallbacks()) {
                perProcessCallback(false, c);
                deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
            }
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            if (mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
                mBluetoothService.switchConnectable(false);
                sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            }
            break;
        case AIRPLANE_MODE_ON:
            mBluetoothService.switchConnectable(false);
            sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            allProcessesCallback(false);
            // we turn all the way to PowerOff with AIRPLANE_MODE_ON
            deferMessage(obtainMessage(AIRPLANE_MODE_ON));
            break;
        case USER_TURN_OFF:
            Log.w(TAG, ""PerProcessState received: "" + message.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""PerProcessState process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case PER_PROCESS_TURN_ON:
            mCallback = (IBluetoothStateChangeCallback) getCurrentMessage().obj;
            // If this is not the first application call the callback.
            if (mBluetoothService.getNumberOfApplicationStateChangeTrackers() > 1) {
                perProcessCallback(true, mCallback);
            }
            break;
        case SCAN_MODE_CHANGED:
            if (isTurningOn) {
                perProcessCallback(true, mCallback);
                isTurningOn = false;
            }
            break;
        case POWER_STATE_CHANGED:
            removeMessages(TURN_OFF_TIMEOUT);
            if (!((Boolean) message.obj)) {
                transitionTo(mHotOff);
                if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                    deferMessage(obtainMessage(TURN_COLD));
                }
            } else {
                if (!isTurningOn) {
                    recoverStateMachine(TURN_COLD, null);
                    for (IBluetoothStateChangeCallback c : mBluetoothService.getApplicationStateChangeCallbacks()) {
                        perProcessCallback(false, c);
                        deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
                    }
                }
            }
            break;
        case TURN_OFF_TIMEOUT:
            transitionTo(mHotOff);
            Log.e(TAG, ""Power-down timed out, resetting..."");
            deferMessage(obtainMessage(TURN_COLD));
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                deferMessage(obtainMessage(TURN_HOT));
            }
            break;
        case USER_TURN_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            persistSwitchSetting(true);
            mBluetoothService.initBluetoothAfterTurningOn();
            transitionTo(mBluetoothOn);
            broadcastState(BluetoothAdapter.STATE_ON);
            // run bluetooth now that it's turned on
            mBluetoothService.runBluetooth();
            break;
        case TURN_HOT:
            broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
            if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
                mBluetoothService.disconnectDevices();
                sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT, DEVICES_DISCONNECT_TIMEOUT_TIME);
                break;
            }
        // $FALL-THROUGH$ all devices are already disconnected
        case ALL_DEVICES_DISCONNECTED:
            removeMessages(DEVICES_DISCONNECT_TIMEOUT);
            finishSwitchingOff();
            break;
        case DEVICES_DISCONNECT_TIMEOUT:
            finishSwitchingOff();
            Log.e(TAG, ""Devices fail to disconnect, reseting..."");
            transitionTo(mHotOff);
            deferMessage(obtainMessage(TURN_COLD));
            for (IBluetoothStateChangeCallback c : mBluetoothService.getApplicationStateChangeCallbacks()) {
                perProcessCallback(false, c);
                deferMessage(obtainMessage(PER_PROCESS_TURN_ON, c));
            }
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            if (mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
                mBluetoothService.switchConnectable(false);
                sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
            }
            break;
        case AIRPLANE_MODE_ON:
            mBluetoothService.switchConnectable(false);
            sendMessageDelayed(TURN_OFF_TIMEOUT, TURN_OFF_TIMEOUT_TIME);
            allProcessesCallback(false);
            break;
        case USER_TURN_OFF:
            Log.w(TAG, ""PerProcessState received: "" + message.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The method call inside the 'removeMessages()' changed from 'POWER_DOWN_TIMEOUT' to 'TURN_OFF_TIMEOUT'. So the change type is 4.,"This change only affects the messages that will be removed, it does not affect the return values nor does it change the exceptions that are thrown by this API, so there is no Compatibility Issue exist."
898,<android.webkit.CacheManager: void init(Context)>,15,16,<android.webkit.CacheManager: void init(Context)>,<android.webkit.CacheManager: void init(Context)>,0,"{
    if (JniUtil.useChromiumHttpStack()) {
        // This isn't actually where the real cache lives, but where we put files for the
        // purpose of getCacheFile().
        mBaseDir = new File(context.getCacheDir(), ""webviewCacheChromiumStaging"");
        if (!mBaseDir.exists()) {
            mBaseDir.mkdirs();
        }
        return;
    }
    mDataBase = WebViewDatabase.getInstance(context.getApplicationContext());
    mBaseDir = new File(context.getCacheDir(), ""webviewCache"");
    if (createCacheDirectory() && mClearCacheOnInit) {
        removeAllCacheFiles();
        mClearCacheOnInit = false;
    }
}","{
    // This isn't actually where the real cache lives, but where we put files for the
    // purpose of getCacheFile().
    mBaseDir = new File(context.getCacheDir(), ""webviewCacheChromiumStaging"");
    if (!mBaseDir.exists()) {
        mBaseDir.mkdirs();
    }
}",1,"/**
 * Initialize the CacheManager.
 *
 * Note that this is called automatically when a {@link android.webkit.WebView} is created.
 *
 * @param context The application context.
 */
","/**
 * Initializes the HTTP cache. This method must be called before any
 * CacheManager methods are used. Note that this is called automatically
 * when a {@link WebView} is created.
 *
 * @param context the application context
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a control dependency change as the condition 'if (JniUtil.useChromiumHttpStack())' has been deleted in the later version. Also, several other statements such as dealing with WebViewDatabase and cache directory creation have been removed, which sets the change types to 3,4.","The removal of the controlling condition and several other statements will change the sequence and logic of the function calls. The possible side effects, for instance, 'mDataBase = WebViewDatabase.getInstance(context.getApplicationContext())', are not conducted in the late version, which may lead to potential different behaviours, indicating a compatibility issue of type 1."
899,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String)>",15,16,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String)>",0,"{
    return mContentProvider.query(url, projection, selection, selectionArgs, sortOrder);
}","{
    try {
        return query(url, projection, selection, selectionArgs, sortOrder, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The return statement and the method being called in return have been modified with an additional parameter passed in the late version implementation. Besides, exception handling for 'DeadObjectException' is introduced in the late version. Therefore, the code changes fall into categories 1 (Return statement changed), 2 (Exception handling changed), and 5 (Dependent API changed).","The modified return statement could lead to different return values or types, causing compatibility issue category 1. Also, the newly introduced exception handling could throw a new 'DeadObjectException' which did not exist in the early version, causing compatibility issue category 2. So, the compatibility issue is of type 1,2."
901,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",15,16,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && mSoftInputShownOnFocus) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mInputContentType != null && mInputContentType.onEditorActionListener != null && mInputContentType.enterDown) {
                    mInputContentType.enterDown = false;
                    if (mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mInput != null)
        if (mInput.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null)
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",0,"There are several changes in the code snippet. Firstly, the dependent methods have changed (mInput to mEditor.mKeyListener and mInputContentType to mEditor.mInputContentType), which is categorized as code change type 5. Moreover, the return statements involving these methods also changed, classifying it under code change type 1. Lastly, the condition in the 'if' statement has changed from mSoftInputShownOnFocus to getShowSoftInputOnFocus(), which is categorized under code change type 4.","Despite these code changes, it won't break the compatibility because the return type remains the same (boolean), and moreover, these changes do not inherently imply a change in value it returns. Therefore, it's also not likely to cause different behaviours given the same inputs. Thus, no compatibility issue exists (CI type 0)."
902,<android.webkit.WebSettings: String getSansSerifFontFamily()>,15,16,<android.webkit.WebSettings: String getSansSerifFontFamily()>,<android.webkit.WebSettings: String getSansSerifFontFamily()>,0,"{
    return mSansSerifFontFamily;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Get the sans-serif font family name.
 * @return The sans-serif font family name as a string.
 */
","/**
 * Gets the sans-serif font family name.
 *
 * @return the sans-serif font family name as a string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the later version of the method, the return statement has been removed and instead an exception has been thrown, so the change type is 1,2.","This change will cause the method to behave differently since it no longer returns a value but throws an exception. Therefore, the compatibility issue type is 1,2."
903,<android.speech.tts.PlaybackSynthesisCallback: void stopImpl(boolean)>,15,16,<android.speech.tts.PlaybackSynthesisCallback: void stopImpl(boolean)>,<android.speech.tts.PlaybackSynthesisCallback: void stopImpl(boolean)>,0,"{
    if (DBG)
        Log.d(TAG, ""stop()"");
    // Note that mLogger.mError might be true too at this point.
    mLogger.onStopped();
    SynthesisMessageParams token;
    synchronized (mStateLock) {
        if (mStopped) {
            Log.w(TAG, ""stop() called twice"");
            return;
        }
        token = mToken;
        mStopped = true;
    }
    if (token != null) {
        // This might result in the synthesis thread being woken up, at which
        // point it will write an additional buffer to the token - but we
        // won't worry about that because the audio playback queue will be cleared
        // soon after (see SynthHandler#stop(String).
        token.setIsError(wasError);
        token.clearBuffers();
        if (wasError) {
            // Also clean up the audio track if an error occurs.
            mAudioTrackHandler.enqueueSynthesisDone(token);
        }
    } else {
        // This happens when stop() or error() were called before start() was.
        // In all other cases, mAudioTrackHandler.stop() will
        // result in onSynthesisDone being called, and we will
        // write data there.
        mLogger.onWriteData();
        if (wasError) {
            // We have to dispatch the error ourselves.
            mDispatcher.dispatchOnError();
        }
    }
}","{
    if (DBG)
        Log.d(TAG, ""stop()"");
    // Note that mLogger.mError might be true too at this point.
    mLogger.onStopped();
    SynthesisPlaybackQueueItem item;
    synchronized (mStateLock) {
        if (mStopped) {
            Log.w(TAG, ""stop() called twice"");
            return;
        }
        item = mItem;
        mStopped = true;
    }
    if (item != null) {
        // This might result in the synthesis thread being woken up, at which
        // point it will write an additional buffer to the item - but we
        // won't worry about that because the audio playback queue will be cleared
        // soon after (see SynthHandler#stop(String).
        item.stop(wasError);
    } else {
        // This happens when stop() or error() were called before start() was.
        // In all other cases, mAudioTrackHandler.stop() will
        // result in onSynthesisDone being called, and we will
        // write data there.
        mLogger.onWriteData();
        if (wasError) {
            // We have to dispatch the error ourselves.
            mDispatcher.dispatchOnError();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The variable 'token' is replaced by the variable 'item'. The usage of variable 'item' (item.stop(wasError)) is different from variable 'token' (token.setIsError(wasError), token.clearBuffers()), introducing a new method call stop() with a different parameter. The dependent API has changed, hence the types of code change are 1,4,5.","As the change of this method can lead to a different behavior, for instance, the token.clearBuffers() is removed and a new method item.stop(wasError) is called, which can potentially lead to a different return which is why CI type is 1."
904,"<android.webkit.CallbackProxy: String onJsPrompt(String,String,String)>",15,16,"<android.webkit.CallbackProxy: String onJsPrompt(String,String,String)>","<android.webkit.CallbackProxy: String onJsPrompt(String,String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return null;
    }
    JsPromptResult result = new JsPromptResult(this);
    Message prompt = obtainMessage(JS_PROMPT, result);
    prompt.getData().putString(""message"", message);
    prompt.getData().putString(""default"", defaultValue);
    prompt.getData().putString(""url"", url);
    synchronized (this) {
        sendMessage(prompt);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for jsPrompt"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    return result.getStringResult();
}","{
    // been set.
    if (mWebChromeClient == null) {
        return null;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message prompt = obtainMessage(JS_PROMPT, result);
    prompt.getData().putString(""message"", message);
    prompt.getData().putString(""default"", defaultValue);
    prompt.getData().putString(""url"", url);
    sendMessageToUiThreadSync(prompt);
    return result.mJsResult.getStringResult();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"In the late version implementation, the type of variable ""result"" has changed from JsPromptResult to JsResultReceiver. The new method sendMessageToUiThreadSync(prompt) is a replacement for the synchronized block. Also, the return statement is changed from result.getStringResult() to result.mJsResult.getStringResult(). Based on these differences, the code change type is 1,3,4,5.","There is a change in the return variable from result.getStringResult() to result.mJsResult.getStringResult(). Therefore, the API may potentially return a different value in the late version. So, the CI type is 1."
905,<android.webkit.WebSettings: void setGeolocationDatabasePath(String)>,15,16,<android.webkit.WebSettings: void setGeolocationDatabasePath(String)>,<android.webkit.WebSettings: void setGeolocationDatabasePath(String)>,0,"{
    if (databasePath != null && !databasePath.equals(mGeolocationDatabasePath)) {
        mGeolocationDatabasePath = databasePath;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the path where the Geolocation permissions database should be saved.
 * This will update WebCore when the Sync runs in the C++ side.
 * @param databasePath String path to the directory where the Geolocation
 * permissions database should be saved. May be the empty string but
 * should never be null.
 */
","// This will update WebCore when the Sync runs in the C++ side.
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The late version throws a new exception that didn't exist in the early version, and changes the entire method's implementation, so the code change type is 2,4.","As the API late version always throws an exception, whereas the early version does not, this constitutes a compatibility issue. Therefore, the CI type is 2."
906,<android.webkit.WebSettings: boolean getBlockNetworkImage()>,15,16,<android.webkit.WebSettings: boolean getBlockNetworkImage()>,<android.webkit.WebSettings: boolean getBlockNetworkImage()>,0,"{
    return mBlockNetworkImage;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return true if the WebView will block network images. The default is
 * false.
 * @return True if the WebView blocks network images.
 */
","/**
 * Gets whether the WebView does not load image resources from the network.
 *
 * @return true if the WebView does not load image resources from the network
 * @see #setBlockNetworkImage
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement in the early implementation has been removed. A new exception statement ""throw new MustOverrideException()"" has been introduced in the late implementation. Thus the code change types are 1 (Return Statement Changed) and 2 (Exception Handling Statement Changed).","The change in the return statement and the introduction of a new exception can potentially lead to different behaviors when the API is invoked. Therefore, the Compatibility Issues (CI) that may arise are also of type 1 (Compatibility Issue caused by potential different return values) and type 2 (Compatibility Issue caused by potential different exception handling)."
907,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String)>",15,16,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String)>","<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String)>",0,"{
    return query(db, projectionIn, selection, selectionArgs, groupBy, having, sortOrder, null);
}","{
    return query(db, projectionIn, selection, selectionArgs, groupBy, having, sortOrder, null, /* limit */
    null);
}",1,"/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
","/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The Late_Implementation introduced a new parameter for the query() method, therefore the code change type is 5 (Dependent API changed).","With the new parameter added to the query() method in the late version, it may potentially lead to different return values when the API is invoked in the two versions, thus the Compatibility Issue type is 1."
908,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",15,16,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>","<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",0,"{
    StringBuilder sql = new StringBuilder();
    sql.append(""INSERT"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append("" INTO "");
    sql.append(table);
    sql.append('(');
    Object[] bindArgs = null;
    int size = (initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
    if (size > 0) {
        bindArgs = new Object[size];
        int i = 0;
        for (String colName : initialValues.keySet()) {
            sql.append((i > 0) ? "","" : """");
            sql.append(colName);
            bindArgs[i++] = initialValues.get(colName);
        }
        sql.append(')');
        sql.append("" VALUES ("");
        for (i = 0; i < size; i++) {
            sql.append((i > 0) ? "",?"" : ""?"");
        }
    } else {
        sql.append(nullColumnHack + "") VALUES (NULL"");
    }
    sql.append(')');
    SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
    try {
        return statement.executeInsert();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        statement.close();
    }
}","{
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append(""INSERT"");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append("" INTO "");
        sql.append(table);
        sql.append('(');
        Object[] bindArgs = null;
        int size = (initialValues != null && initialValues.size() > 0) ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "","" : """");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append("" VALUES ("");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? "",?"" : ""?"");
            }
        } else {
            sql.append(nullColumnHack + "") VALUES (NULL"");
        }
        sql.append(')');
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}",1,"/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row
 * OR the primary key of the existing row if the input param 'conflictAlgorithm' =
 * {@link #CONFLICT_IGNORE}
 * OR -1 if any error
 */
","/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row
 * OR the primary key of the existing row if the input param 'conflictAlgorithm' =
 * {@link #CONFLICT_IGNORE}
 * OR -1 if any error
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"In the later version, an additional try block has been added and the exception handling has been removed, so the change type is 2.","The previously existing exception handling has been removed in the later version, which means that this method will not throw the SQLiteDatabaseCorruptException and execute the onCorruption() method like in the early version. So, the CI type is 2."
910,"<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>",15,16,"<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>","<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>",0,"{
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, callback);
    for (Activity a : activities) {
        if (a == null) {
            throw new NullPointerException(""activities cannot contain null"");
        }
        mNfcActivityManager.setOnNdefPushCompleteCallback(a, callback);
    }
}","{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setOnNdefPushCompleteCallback(activity, callback);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setOnNdefPushCompleteCallback(a, callback);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set the callback on a successful NDEF push over NFC.
 *
 * <p>This method may be called at any time, but NDEF push and this callback
 * can only occur when one of the specified activities is in resumed
 * (foreground) state.
 *
 * <p>One or more activities must be specified.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity an activity to enable the callback (at least one is required)
 * @param activities zero or more additional activities to enable to callback
 */
","/**
 * Set a callback on successful Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setOnNdefPushCompleteCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2",2,"The control dependency changed due to the introduction of a try-catch block. Additionally, a new exception handling statement is introduced in the 'catch' block. Therefore, the code change type is 3,2.","A new different exception handling is introduced in the late version, making it possible that the late version API throws a different kind of exception compared to the early version. Thus, the type of compatibility issue is 2."
912,<android.webkit.WebSettings: String getPluginsPath()>,15,16,<android.webkit.WebSettings: String getPluginsPath()>,<android.webkit.WebSettings: String getPluginsPath()>,0,"{
    return """";
}","{
    // Unconditionally returns empty string, so no need for derived classes to override.
    return """";
}",1,"/**
 * Returns the directory that contains the plugin libraries. This method is
 * obsolete since each plugin is now loaded from its own package.
 * @return An empty string.
 * @deprecated This method is no longer used as plugins are loaded from
 * their own APK via the system's package manager.
 */
","/**
 * Gets the directory that contains the plugin libraries. This method is
 * obsolete since each plugin is now loaded from its own package.
 *
 * @return an empty string
 * @deprecated This method is no longer used as plugins are loaded from
 * their own APK via the system's package manager.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,"No code implementation has been changed between the two versions except for comments. The return value remains constant, and no exception handling or dependency is involved. Therefore, its code change type is 0.","Given that the code implementation hasn't changed between these two versions, the output and behavior of the method also remains the same. Hence, no compatibility issues, i.e., CI type is 0."
913,"<android.view.GLES20Canvas: int saveLayer(float,float,float,float,Paint,int)>",15,16,"<android.view.GLES20Canvas: int saveLayer(float,float,float,float,Paint,int)>","<android.view.GLES20Canvas: int saveLayer(float,float,float,float,Paint,int)>",0,"{
    if (left < right && top < bottom) {
        int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        int count = nSaveLayer(mRenderer, left, top, right, bottom, nativePaint, saveFlags);
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
        return count;
    }
    return save(saveFlags);
}","{
    if (left < right && top < bottom) {
        int count;
        int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
        try {
            final int nativePaint = paint == null ? 0 : paint.mNativePaint;
            count = nSaveLayer(mRenderer, left, top, right, bottom, nativePaint, saveFlags);
        } finally {
            if (modifier != MODIFIER_NONE)
                nResetModifiers(mRenderer, modifier);
        }
        return count;
    }
    return save(saveFlags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,2",0,"In the late version, the control dependency changed as the execution flow has been wrapped inside a 'try-finally' block and an exception handling statement has been introduced, so the code change type is 3,2.","Despite the changes in the control flow and exception handling, these changes do not cause a different return value or exceptions compared to the early version. Therefore, there is no compatibility issue - CI type 0."
914,"<android.webkit.WebStorage: void getUsageForOrigin(String,ValueCallback<Long>)>",15,16,"<android.webkit.WebStorage: void getUsageForOrigin(String,ValueCallback<Long>)>","<android.webkit.WebStorage: void getUsageForOrigin(String,ValueCallback<Long>)>",0,"{
    if (callback == null) {
        return;
    }
    if (origin == null) {
        callback.onReceiveValue(null);
        return;
    }
    if (WebViewCore.THREAD_NAME.equals(Thread.currentThread().getName())) {
        syncValues();
        Origin website = mOrigins.get(origin);
        callback.onReceiveValue(new Long(website.getUsage()));
    } else {
        HashMap values = new HashMap<String, Object>();
        values.put(ORIGIN, origin);
        values.put(CALLBACK, callback);
        postMessage(Message.obtain(null, GET_USAGE_ORIGIN, values));
    }
}","{
// Must be a no-op for backward compatibility: see the hidden constructor for reason.
}",1,"/**
 * Returns the use for a given origin
 */
","/**
 * Gets the amount of storage currently being used by both the Application
 * Cache and Web SQL Database APIs by the given origin. The amount is given
 * in bytes and the origin is specified using its string representation.
 * This method operates asynchronously, with the result being provided via
 * a {@link ValueCallback}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"All the original implementation logic has been removed and replaced with a comment. So the code change is a combination of return statement changes and other statements changes, hence the change type is 1,4.","Because all the original behaviour of the function has been removed, it may return different results from previous versions of the function when used in the same circumstances, leading to a compatibility issue."
915,<android.webkit.WebIconDatabase: void open(String)>,15,16,<android.webkit.WebIconDatabase: void open(String)>,<android.webkit.WebIconDatabase: void open(String)>,0,"{
    if (path != null) {
        // Make the directories and parents if they don't exist
        File db = new File(path);
        if (!db.exists()) {
            db.mkdirs();
        }
        mEventHandler.postMessage(Message.obtain(null, EventHandler.OPEN, db.getAbsolutePath()));
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Open a the icon database and store the icons in the given path.
 * @param path The directory path where the icon database will be stored.
 */
","/**
 * Open a the icon database and store the icons in the given path.
 * @param path The directory path where the icon database will be stored.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version implementation was completely replaced by a throw statement, throwing a new `MustOverrideException`. This means both the return statements (return type was void) and the logical flow (exception handling) have been altered, so the code change types are 1,2.","The introduction of a new throw statement will cause the behavior of the program to change drastically if the exception is unhandled. Therefore, the CI types are 1,2. The API would return differently because previously it returned nothing (void), but now it throws an exception. The exception behavior also changed because previously no exception was thrown, but now a `MustOverrideException` is raised."
917,<android.webkit.WebSettings: void setSerifFontFamily(String)>,15,16,<android.webkit.WebSettings: void setSerifFontFamily(String)>,<android.webkit.WebSettings: void setSerifFontFamily(String)>,0,"{
    if (font != null && !font.equals(mSerifFontFamily)) {
        mSerifFontFamily = font;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the serif font family name. The default is ""sans-serif"".
 * @param font A font family name.
 */
","/**
 * Sets the serif font family name. The default is ""sans-serif"".
 *
 * @param font a font family name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","In the late version, the implementation has removed the previous control annd update statements and introduced throwing a new exception. Hence, the code change type would be 2 as the new version throws different exceptions and 4 as it includes other statements change such as set and condition statement changes.","The change in the implementation might lead to the API throwing an exception rather than updating the variable 'mSerifFontFamily' as in the previous version, which would lead to different behaviours and return values between the two versions. Thus, the CI types should include both 1 (potential different return values or types) and 2 (potential different exception handlings)."
919,<android.webkit.WebSettings: void setSaveFormData(boolean)>,15,16,<android.webkit.WebSettings: void setSaveFormData(boolean)>,<android.webkit.WebSettings: void setSaveFormData(boolean)>,0,"{
    mSaveFormData = save;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Store whether the WebView is saving form data.
 */
","/**
 * Sets whether the WebView is saving form data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","There is a change from updating a variable value to directly introducing a new exception. Hence, the type of code change here is 1,2 which means 'Return statement changed' and 'Exception handling statement changed'.","The new implementation will always throw an exception, unlike the earlier version which updates the 'mSaveFormData' variable. This means that regardless of input, the function now behaves dramatically differently and is likely to result in disrupted functionality and/or crashes. Consequently, the CI here includes both 'Potential Different Return Values or Types'(1) and 'Potential Different Exception Handlings'(2)."
921,<android.app.ContextImpl: void sendBroadcast(Intent)>,15,16,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"There is an extra parameter added in broadcastIntent() method in late version. Hence, it falls under Dependent API Changed category.","Since the method broadcastIntent() now has an additional parameter, it could potentially return a different value leading to different behaviours, therefore a compatibility issue could exist. It falls under Compatibility Issue caused by potential different return values or types."
923,"<android.app.ActivityManager: void moveTaskToFront(int,int)>",15,16,"<android.app.ActivityManager: void moveTaskToFront(int,int)>","<android.app.ActivityManager: void moveTaskToFront(int,int)>",0,"{
    try {
        ActivityManagerNative.getDefault().moveTaskToFront(taskId, flags);
    } catch (RemoteException e) {
    // System dead, we will be dead too soon!
    }
}","{
    moveTaskToFront(taskId, flags, null);
}",1,"/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.  Requires that
 * the caller hold permission {@link android.Manifest.permission#REORDER_TASKS}
 * or a SecurityException will be thrown.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags, 0 or more of
 * {@link #MOVE_TASK_WITH_HOME}.
 */
","/**
 * Equivalent to calling {@link #moveTaskToFront(int, int, Bundle)}
 * with a null options argument.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags, 0 or more of
 * {@link #MOVE_TASK_WITH_HOME}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",No Compatibility Issue exist,"The function call within the method changed from directly using 'ActivityManagerNative.getDefault().moveTaskToFront(taskId, flags)' to a simplified version 'moveTaskToFront(taskId, flags, null)'. This implies that a dependent API and other statement have been changed, therefore the code change type is 4,5.","Although the implementation is changed, the underlying functionality remains the same. The final effect of 'moveTaskToFront' method is not expected to change as the same taskID and flags are passed. Therefore, no compatibility issue exists."
924,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",15,16,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new statement has been introduced (s.setNpnProtocols(mNpnProtocols)), so the change type is 4.","The introduced statement may change the behavior of the 's'. Therefore, the 'return s' can potentially return a different value in late version, and the CI type is 1."
929,<android.view.View: boolean setAlphaNoInvalidation(float)>,15,16,<android.view.View: boolean setAlphaNoInvalidation(float)>,<android.view.View: boolean setAlphaNoInvalidation(float)>,0,"{
    ensureTransformationInfo();
    mTransformationInfo.mAlpha = alpha;
    boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
    if (subclassHandlesAlpha) {
        mPrivateFlags |= ALPHA_SET;
    } else {
        mPrivateFlags &= ~ALPHA_SET;
    }
    return subclassHandlesAlpha;
}","{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~ALPHA_SET;
            if (mDisplayList != null) {
                mDisplayList.setAlpha(alpha);
            }
        }
    }
    return false;
}",1,"/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha())
 */
","/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency of the code has changed with the introduction of a new 'if' condition checking whether 'mTransformationInfo.mAlpha' is not equal to 'alpha'. Also, return statements in the late version have changed, including the introduction of a new return statement (return true) and change in the value returned by the last return statement (return false). So code change types fall in categories 1 and 3.","The return values in the earlier and later versions differ. In the early version, the return value depends on 'subclassHandlesAlpha', whereas in the late version, the return value is 'true' when 'subclassHandlesAlpha' equals 'true', and 'false' if 'mTransformationInfo.mAlpha != alpha' is not satisfied. The change may result in potentially different return values, leading to a compatibility issue of type 1."
931,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",15,16,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_UP, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), false, event.getMetaState());
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (isEnterActionKey(keyCode)) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        if (nativeCursorIsTextInput()) {
            rebuildWebTextView();
            centerKeyPressOnTextField();
            if (inEditingMode()) {
                mWebTextView.setDefaultSelection();
            }
            return true;
        }
        clearTextEntry();
        nativeShowCursorTimed();
        if (mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            return true;
        }
        if (nativeCursorNodePointer() != 0 && !nativeCursorWantsKeyEvents()) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
            return true;
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    return mProvider.getViewDelegate().onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed from a complex logic to a simple return statement, and the refered API (mProvider.getViewDelegate().onKeyUp(keyCode, event)) is different from the old version, so the code change type is 1,5.","The return values of 'onKeyUp' API may change because of the referred API changes in the implementation. Thus, the CI type is 1."
933,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,15,16,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"An extra parameter, ""Binder.getOrigCallingUser()"", is passed to the ""unbroadcastIntent()"" method in the late version, so it belongs to code change type 5.","The change in dependent API method would potentially result in a different execution result and thus potentially leads to a different return, hence the CI type is 1."
935,"<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>",15,16,"<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>","<android.view.inputmethod.BaseInputConnection: boolean deleteSurroundingText(int,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""deleteSurroundingText "" + leftLength + "" / "" + rightLength);
    final Editable content = getEditable();
    if (content == null)
        return false;
    beginBatchEdit();
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // ignore the composing text.
    int ca = getComposingSpanStart(content);
    int cb = getComposingSpanEnd(content);
    if (cb < ca) {
        int tmp = ca;
        ca = cb;
        cb = tmp;
    }
    if (ca != -1 && cb != -1) {
        if (ca < a)
            a = ca;
        if (cb > b)
            b = cb;
    }
    int deleted = 0;
    if (leftLength > 0) {
        int start = a - leftLength;
        if (start < 0)
            start = 0;
        content.delete(start, a);
        deleted = a - start;
    }
    if (rightLength > 0) {
        b = b - deleted;
        int end = b + rightLength;
        if (end > content.length())
            end = content.length();
        content.delete(b, end);
    }
    endBatchEdit();
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""deleteSurroundingText "" + beforeLength + "" / "" + afterLength);
    final Editable content = getEditable();
    if (content == null)
        return false;
    beginBatchEdit();
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // ignore the composing text.
    int ca = getComposingSpanStart(content);
    int cb = getComposingSpanEnd(content);
    if (cb < ca) {
        int tmp = ca;
        ca = cb;
        cb = tmp;
    }
    if (ca != -1 && cb != -1) {
        if (ca < a)
            a = ca;
        if (cb > b)
            b = cb;
    }
    int deleted = 0;
    if (beforeLength > 0) {
        int start = a - beforeLength;
        if (start < 0)
            start = 0;
        content.delete(start, a);
        deleted = a - start;
    }
    if (afterLength > 0) {
        b = b - deleted;
        int end = b + afterLength;
        if (end > content.length())
            end = content.length();
        content.delete(b, end);
    }
    endBatchEdit();
    return true;
}",1,"/**
 * The default implementation performs the deletion around the current
 * selection position of the editable text.
 */
","/**
 * The default implementation performs the deletion around the current
 * selection position of the editable text.
 * @param beforeLength
 * @param afterLength
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The variable names of the method parameters have changed from 'leftLength' and 'rightLength' to 'beforeLength' and 'afterLength'. So the code change type is 4.,"Just the names of variables are changed, and it does not affect the behaviors of the API. The types, values that the method return, and the exceptions that the method may throw has not changed. So no CI exists, and the CI type is 0."
938,<android.widget.AdapterView: void handleDataChanged()>,15,16,<android.widget.AdapterView: void handleDataChanged()>,<android.widget.AdapterView: void handleDataChanged()>,0,"{
    final int count = mItemCount;
    boolean found = false;
    if (count > 0) {
        int newPos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects
            // it
            mNeedSync = false;
            // See if we can find a position in the new data with the same
            // id as the old selection
            newPos = findSyncPosition();
            if (newPos >= 0) {
                // Verify that new selection is selectable
                int selectablePos = lookForSelectablePosition(newPos, true);
                if (selectablePos == newPos) {
                    // Same row id is selected
                    setNextSelectedPositionInt(newPos);
                    found = true;
                }
            }
        }
        if (!found) {
            // Try to use the same position if we can't find matching data
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            int selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos < 0) {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
            }
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                checkSelectionChanged();
                found = true;
            }
        }
    }
    if (!found) {
        // Nothing is selected
        mSelectedPosition = INVALID_POSITION;
        mSelectedRowId = INVALID_ROW_ID;
        mNextSelectedPosition = INVALID_POSITION;
        mNextSelectedRowId = INVALID_ROW_ID;
        mNeedSync = false;
        checkSelectionChanged();
    }
}","{
    final int count = mItemCount;
    boolean found = false;
    if (count > 0) {
        int newPos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects
            // it
            mNeedSync = false;
            // See if we can find a position in the new data with the same
            // id as the old selection
            newPos = findSyncPosition();
            if (newPos >= 0) {
                // Verify that new selection is selectable
                int selectablePos = lookForSelectablePosition(newPos, true);
                if (selectablePos == newPos) {
                    // Same row id is selected
                    setNextSelectedPositionInt(newPos);
                    found = true;
                }
            }
        }
        if (!found) {
            // Try to use the same position if we can't find matching data
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            int selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos < 0) {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
            }
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                checkSelectionChanged();
                found = true;
            }
        }
    }
    if (!found) {
        // Nothing is selected
        mSelectedPosition = INVALID_POSITION;
        mSelectedRowId = INVALID_ROW_ID;
        mNextSelectedPosition = INVALID_POSITION;
        mNextSelectedRowId = INVALID_ROW_ID;
        mNeedSync = false;
        checkSelectionChanged();
    }
    // TODO: Hmm, we do not know the old state so this is sub-optimal
    notifyAccessibilityStateChanged();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new method call notifyAccessibilityStateChanged(); added at the end of the method, which is not an exception handling, not a return statement, not a control dependency, nor an dependent API change. This is classified under type 4 changes, the other statement change.","The addition of the notifyAccessibilityStateChanged() method alone will not cause a direct change of the method's behavior in terms of returning different values or throwing different exceptions. Thus, it doesn't lead to a compatibility issue."
939,<android.widget.NumberPicker: void setMaxValue(int)>,15,16,<android.widget.NumberPicker: void setMaxValue(int)>,<android.widget.NumberPicker: void setMaxValue(int)>,0,"{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
}","{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}",1,"/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value.
 */
","/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the 'invalidate();' function was added in the later version, so the change type is 4 (Other statement changed).","The added 'invalidate();' function is a common function in Android used to redraw a view, which does not alter the behaviour of the API. Therefore, there is no compatibility issue (CI type 0)."
940,<android.content.SyncManager.SyncHandler: long insertStartSyncEvent(SyncOperation)>,15,16,<android.content.SyncManager.SyncHandler: long insertStartSyncEvent(SyncOperation)>,<android.content.SyncManager.SyncHandler: long insertStartSyncEvent(SyncOperation)>,0,"{
    final int source = syncOperation.syncSource;
    final long now = System.currentTimeMillis();
    EventLog.writeEvent(2720, syncOperation.authority, SyncStorageEngine.EVENT_START, source, syncOperation.account.name.hashCode());
    return mSyncStorageEngine.insertStartSyncEvent(syncOperation.account, syncOperation.authority, now, source);
}","{
    final int source = syncOperation.syncSource;
    final long now = System.currentTimeMillis();
    EventLog.writeEvent(2720, syncOperation.authority, SyncStorageEngine.EVENT_START, source, syncOperation.account.name.hashCode());
    return mSyncStorageEngine.insertStartSyncEvent(syncOperation.account, syncOperation.userId, syncOperation.authority, now, source, syncOperation.isInitialization());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, the method with the same name but different parameters is called, so the code change type is 1,5.","The change of method with the same name but different parameters will make the API potentially return a different value, so the CI type is 1."
941,<android.webkit.WebSettings: void setJavaScriptEnabled(boolean)>,15,16,<android.webkit.WebSettings: void setJavaScriptEnabled(boolean)>,<android.webkit.WebSettings: void setJavaScriptEnabled(boolean)>,0,"{
    if (mJavaScriptEnabled != flag) {
        mJavaScriptEnabled = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to enable javascript execution.
 * @param flag True if the WebView should execute javascript.
 */
","/**
 * Tells the WebView to enable JavaScript execution.
 * <b>The default is false.</b>
 *
 * @param flag true if the WebView should execute JavaScript
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The entire implementation of the method is replaced by a new 'throw' statement, so the code change type is 2 and 4.","The new implemented method throws a new exception in all scenarios, so the CI type is 2."
943,"<android.provider.UserDictionary.Words: void addWord(Context,String,int,int)>",15,16,"<android.provider.UserDictionary.Words: void addWord(Context,String,int,int)>","<android.provider.UserDictionary.Words: void addWord(Context,String,int,int)>",0,"{
    final ContentResolver resolver = context.getContentResolver();
    if (TextUtils.isEmpty(word) || localeType < 0 || localeType > 1) {
        return;
    }
    if (frequency < 0)
        frequency = 0;
    if (frequency > 255)
        frequency = 255;
    String locale = null;
    // TODO: Verify if this is the best way to get the current locale
    if (localeType == LOCALE_TYPE_CURRENT) {
        locale = Locale.getDefault().toString();
    }
    ContentValues values = new ContentValues(4);
    values.put(WORD, word);
    values.put(FREQUENCY, frequency);
    values.put(LOCALE, locale);
    // TODO: Get App UID
    values.put(APP_ID, 0);
    Uri result = resolver.insert(CONTENT_URI, values);
// It's ok if the insert doesn't succeed because the word
// already exists.
}","{
    if (localeType != LOCALE_TYPE_ALL && localeType != LOCALE_TYPE_CURRENT) {
        return;
    }
    final Locale locale;
    if (localeType == LOCALE_TYPE_CURRENT) {
        locale = Locale.getDefault();
    } else {
        locale = null;
    }
    addWord(context, word, frequency, null, locale);
}",1,"/**
 * Adds a word to the dictionary, with the given frequency and the specified
 * specified locale type.
 * @param context the current application context
 * @param word the word to add to the dictionary. This should not be null or
 * empty.
 * @param localeType the locale type for this word. It should be one of
 * {@link #LOCALE_TYPE_ALL} or {@link #LOCALE_TYPE_CURRENT}.
 */
","/**
 * Adds a word to the dictionary, with the given frequency and the specified
 * specified locale type.
 *
 * @deprecated Please use
 * {@link #addWord(Context, String, int, String, Locale)} instead.
 *
 * @param context the current application context
 * @param word the word to add to the dictionary. This should not be null or
 * empty.
 * @param localeType the locale type for this word. It should be one of
 * {@link #LOCALE_TYPE_ALL} or {@link #LOCALE_TYPE_CURRENT}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,5",0,"The early version contains more complex statements compared to the late version, it contains control statements and use of the local variable 'resolver' which is not present in the later version. Therefore, the control dependency, return statements and the dependent APIs have changed.","Even though there is a change in the implementation, the new version still handles the same cases as the previous version, just with different execution paths. Thus, this should not cause a Compatibility Issue."
945,<android.view.InputDevice: int[] getDeviceIds()>,15,16,<android.view.InputDevice: int[] getDeviceIds()>,<android.view.InputDevice: int[] getDeviceIds()>,0,"{
    IWindowManager wm = Display.getWindowManager();
    try {
        return wm.getInputDeviceIds();
    } catch (RemoteException ex) {
        throw new RuntimeException(""Could not get input device ids from Window Manager."", ex);
    }
}","{
    return InputManager.getInstance().getInputDeviceIds();
}",1,"/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
","/**
 * Gets the ids of all input devices in the system.
 * @return The input device ids.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The entire algorithm of the method changed from interacting with the WindowManager to getting an instance of the InputManager. This corresponds to a change in the return statement, the dependent API, and the overall code structure. Thus, the code change type is 1,4,5.","The return value is different since it is now sourced from the InputManager instead of the WindowManager. Additionally, the exception that was previously thrown (RuntimeException) in the presence of a RemoteException is no longer present, leading to different exception handling rules. Thus, the CI type is 1,2."
946,<android.view.KeyCharacterMap: KeyCharacterMap load(int)>,15,16,<android.view.KeyCharacterMap: KeyCharacterMap load(int)>,<android.view.KeyCharacterMap: KeyCharacterMap load(int)>,0,"{
    synchronized (sInstances) {
        KeyCharacterMap map = sInstances.get(deviceId);
        if (map == null) {
            String kcm = null;
            if (deviceId != VIRTUAL_KEYBOARD) {
                InputDevice device = InputDevice.getDevice(deviceId);
                if (device != null) {
                    kcm = device.getKeyCharacterMapFile();
                }
            }
            if (kcm == null || kcm.length() == 0) {
                kcm = ""/system/usr/keychars/Virtual.kcm"";
            }
            // might throw
            int ptr = nativeLoad(kcm);
            map = new KeyCharacterMap(deviceId, ptr);
            sInstances.put(deviceId, map);
        }
        return map;
    }
}","{
    final InputManager im = InputManager.getInstance();
    InputDevice inputDevice = im.getInputDevice(deviceId);
    if (inputDevice == null) {
        inputDevice = im.getInputDevice(VIRTUAL_KEYBOARD);
        if (inputDevice == null) {
            throw new UnavailableException(""Could not load key character map for device "" + deviceId);
        }
    }
    return inputDevice.getKeyCharacterMap();
}",1,"/**
 * Loads the key character maps for the keyboard with the specified device id.
 *
 * @param deviceId The device id of the keyboard.
 * @return The associated key character map.
 * @throws {@link UnavailableException} if the key character map
 * could not be loaded because it was malformed or the default key character map
 * is missing from the system.
 */
","/**
 * Loads the key character maps for the keyboard with the specified device id.
 *
 * @param deviceId The device id of the keyboard.
 * @return The associated key character map.
 * @throws {@link UnavailableException} if the key character map
 * could not be loaded because it was malformed or the default key character map
 * is missing from the system.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","Multiple changes have occurred. The entire logic of the API implementation has been redesigned. The method used to retrieve the 'inputDevice' has been changed (InputManager.getInstance(), im.getInputDevice()), as well as the handling of the retrieved device. There is a new exception statement 'throw new UnavailableException()'. The return statement changed from a locally constructed object 'map' to 'inputDevice.getKeyCharacterMap()', hence the prediction is 1,2,3,4,5.","The changes in the API implementation are significant and can potentially cause different behaviours. The thrown exception is different and the returned value is also different hence, the CI type is 1,2."
947,<android.view.View: HardwareLayer getHardwareLayer()>,15,16,<android.view.View: HardwareLayer getHardwareLayer()>,<android.view.View: HardwareLayer getHardwareLayer()>,0,"{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {
        return null;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.setEmpty();
        } else if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
            mHardwareLayer.resize(width, height);
            mLocalDirtyRect.setEmpty();
        }
        // The layer is not valid if the underlying GPU resources cannot be allocated
        if (!mHardwareLayer.isValid()) {
            return null;
        }
        HardwareCanvas currentCanvas = mAttachInfo.mHardwareCanvas;
        final HardwareCanvas canvas = mHardwareLayer.start(currentCanvas);
        // Make sure all the GPU resources have been properly allocated
        if (canvas == null) {
            mHardwareLayer.end(currentCanvas);
            return null;
        }
        mAttachInfo.mHardwareCanvas = canvas;
        try {
            canvas.setViewport(width, height);
            canvas.onPreDraw(mLocalDirtyRect);
            mLocalDirtyRect.setEmpty();
            final int restoreCount = canvas.save();
            computeScroll();
            canvas.translate(-mScrollX, -mScrollY);
            mPrivateFlags |= DRAWN | DRAWING_CACHE_VALID;
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                mPrivateFlags &= ~DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
            canvas.restoreToCount(restoreCount);
        } finally {
            canvas.onPostDraw();
            mHardwareLayer.end(currentCanvas);
            mAttachInfo.mHardwareCanvas = currentCanvas;
        }
    }
    return mHardwareLayer;
}","{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {
        return null;
    }
    if (!mAttachInfo.mHardwareRenderer.validate())
        return null;
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.set(0, 0, width, height);
        } else if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
            mHardwareLayer.resize(width, height);
            mLocalDirtyRect.set(0, 0, width, height);
        }
        // The layer is not valid if the underlying GPU resources cannot be allocated
        if (!mHardwareLayer.isValid()) {
            return null;
        }
        mHardwareLayer.redraw(getHardwareLayerDisplayList(mHardwareLayer), mLocalDirtyRect);
        mLocalDirtyRect.setEmpty();
    }
    return mHardwareLayer;
}",1,"/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
","/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"From the early version to the late version, a new return statement (if(!mAttachInfo.mHardwareRenderer.validate()) return null;) has been added, multiple statements and logics inside the if clause ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) have been changed completely (e.g., mHardwareLayer.redraw() is called in the late version, while no such call in the early version). So, the code change type is 1,3,4.","The return variable can be different because of the change in return statements, and this could lead to failure in running old code since old codes are not designed to cope with new return variable. Therefore, the CI type is 1."
949,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,15,16,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,0,"{
    try {
        final List<ApplicationInfo> applicationInfos = new ArrayList<ApplicationInfo>();
        ApplicationInfo lastItem = null;
        ParceledListSlice<ApplicationInfo> slice;
        do {
            final String lastKey = lastItem != null ? lastItem.packageName : null;
            slice = mPM.getInstalledApplications(flags, lastKey);
            lastItem = slice.populateList(applicationInfos, ApplicationInfo.CREATOR);
        } while (!slice.isLastSlice());
        return applicationInfos;
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    int userId = UserId.getUserId(Process.myUid());
    try {
        final List<ApplicationInfo> applicationInfos = new ArrayList<ApplicationInfo>();
        ApplicationInfo lastItem = null;
        ParceledListSlice<ApplicationInfo> slice;
        do {
            final String lastKey = lastItem != null ? lastItem.packageName : null;
            slice = mPM.getInstalledApplications(flags, lastKey, userId);
            lastItem = slice.populateList(applicationInfos, ApplicationInfo.CREATOR);
        } while (!slice.isLastSlice());
        return applicationInfos;
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,"[@SuppressWarnings(""unchecked""), @Override]","[@SuppressWarnings(""unchecked""), @Override]",-1,-1,-1,-1,-1,-1,"4, 5",1,"The change includes the addition of a new variable ""userId"" declaration and assignment, and the new variable is used as an argument in the method `mPM.getInstalledApplications()`, so the change types are 4 and 5.","Given that the dependent method's signature has changed and new parameter is passed in the method `mPM.getInstalledApplications()`, this could result in a different return value. Therefore, the CI type is 1."
950,<android.webkit.WebSettings: void setMinimumLogicalFontSize(int)>,15,16,<android.webkit.WebSettings: void setMinimumLogicalFontSize(int)>,<android.webkit.WebSettings: void setMinimumLogicalFontSize(int)>,0,"{
    size = pin(size);
    if (mMinimumLogicalFontSize != size) {
        mMinimumLogicalFontSize = size;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the minimum logical font size.
 * @param size A non-negative integer between 1 and 72.
 * Any number outside the specified range will be pinned.
 */
","/**
 * Sets the minimum logical font size. The default is 8.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The full implementation has changed from some logical statements to a single 'throw' exception statement, hence the change type is 1 (Return statement changed), 2 (Exception handling statement changed), and 4 (Other statement changed).","The early version has some logical statements and assigns a value but the late version directly throws an exception, so the behaviour of this API definitely changes. Hence, the compatibility issue type is 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
951,"<android.app.ActivityThread.ApplicationThread: MemoryInfo dumpMemInfo(FileDescriptor,boolean,boolean,String[])>",15,16,"<android.app.ActivityThread.ApplicationThread: MemoryInfo dumpMemInfo(FileDescriptor,boolean,boolean,String[])>","<android.app.ActivityThread.ApplicationThread: MemoryInfo dumpMemInfo(FileDescriptor,boolean,boolean,String[])>",0,"{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new PrintWriter(fout);
    try {
        return dumpMemInfo(pw, checkin, all, args);
    } finally {
        pw.flush();
    }
}","{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new PrintWriter(fout);
    try {
        return dumpMemInfo(pw, checkin, all);
    } finally {
        pw.flush();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The call to the method 'dumpMemInfo' in the late version has a reduced parameter set as compared to the early version, this represents the change of a dependent API thus the code change type is 5.",The difference in parameters while calling the method 'dumpMemInfo' may cause the method to behave differently and potentially return a different value; this classifies as a type 1 CI.
953,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",15,16,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",0,"{
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    mNfcActivityManager.setNdefPushMessage(activity, message);
    for (Activity a : activities) {
        if (a == null) {
            throw new NullPointerException(""activities cannot contain null"");
        }
        mNfcActivityManager.setNdefPushMessage(a, message);
    }
}","{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessage(activity, message);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessage(a, message);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set the {@link NdefMessage} to push over NFC during the specified activities.
 *
 * <p>This method may be called at any time, but the NDEF message is
 * only made available for NDEF push when one of the specified activities
 * is in resumed (foreground) state.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set then
 * the callback will take priority.
 *
 * <p>Pass a null NDEF message to disable foreground NDEF push in the
 * specified activities.
 *
 * <p>At least one activity must be specified, and usually only one is necessary.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity an activity in which NDEF push should be enabled to share the provided
 * NDEF message
 * @param activities optional additional activities that should also enable NDEF push with
 * the provided NDEF message
 */
","/**
 * Set a static {@link NdefMessage} to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message is only made available for NDEF push when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code &lt;meta-data>} element inside the {@code &lt;application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessage(ndefMessage, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the NDEF message and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically generate an NDEF message,
 * then set a callback using {@link #setNdefPushMessageCallback} instead
 * of a static message.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"In the late version, a new 'try' and 'catch' block is added, which is change type 2. Also, a new variable 'targetSdkVersion' is introduced, which represents a change in control structure, so change type is 3.","In the late version, a new IllegalStateException is caught, and it can re-throw this exception based on certain conditions. This could potentially lead to the API throwing a different exception compared to the early version, hence the CI type is 2."
954,<android.webkit.WebSettings: void setAppCacheEnabled(boolean)>,15,16,<android.webkit.WebSettings: void setAppCacheEnabled(boolean)>,<android.webkit.WebSettings: void setAppCacheEnabled(boolean)>,0,"{
    if (mAppCacheEnabled != flag) {
        mAppCacheEnabled = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to enable Application Caches API.
 * @param flag True if the WebView should enable Application Caches.
 */
","/**
 * Tells the WebView to enable Application Caches API.
 *
 * @param flag true if the WebView should enable Application Caches
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","There are changes in both return statement and exception handling statement. The previous implementation of enable/disable flag setting is replaced completely with a 'throw' statement in the later version. So the change type is 1,2.","The change from a non-throwing method implementation to one that throws an exception will lead to different behaviors in the two versions. Also, the 'throw' statement in the late version could result in no return of the method. Hence, the CI type is both 1 (due to potential different return) and 2 (due to different exception throwing)."
956,<android.webkit.WebSettings: void setBlockNetworkLoads(boolean)>,15,16,<android.webkit.WebSettings: void setBlockNetworkLoads(boolean)>,<android.webkit.WebSettings: void setBlockNetworkLoads(boolean)>,0,"{
    if (mBlockNetworkLoads != flag) {
        mBlockNetworkLoads = flag;
        verifyNetworkAccess();
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Tell the WebView to block all network load requests. If you set the
 * value to false, you must call {@link android.webkit.WebView#reload} to
 * fetch remote resources. This flag supercedes the value passed to
 * {@link #setBlockNetworkImage}.
 * @param flag True if the WebView should block all network loads.
 * @see android.webkit.WebView#reload
 */
","/**
 * Sets whether the WebView should not load resources from the network.
 * Use {@link #setBlockNetworkImage} to only avoid loading
 * image resources. Note that if the value of this setting is
 * changed from true to false, network resources referenced by content
 * currently displayed by the WebView are not fetched until
 * {@link android.webkit.WebView#reload} is called.
 * If the application does not have the
 * {@link android.Manifest.permission#INTERNET} permission, attempts to set
 * a value of false will cause a {@link java.lang.SecurityException}
 * to be thrown. The default value is false if the application has the
 * {@link android.Manifest.permission#INTERNET} permission, otherwise it is
 * true.
 *
 * @param flag whether the WebView should not load any resources from the
 * network
 * @see android.webkit.WebView#reload
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The entire body of the method has replaced by throwing a new exception which means that the entire original functionality of the method has been bypassed, hence the change type is 2.","The throwing of a new exception in late version could cause the late version API to throw a different exception than the early version, hence the Compatibility Issue type is 2."
957,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,15,16,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            if (mPreviewCallback != null) {
                PreviewCallback cb = mPreviewCallback;
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                cb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            if (mAutoFocusCallback != null) {
                mAutoFocusCallback.onAutoFocus(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomListener != null) {
                mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_METADATA:
            if (mFaceListener != null) {
                mFaceListener.onFaceDetection((Face[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}","{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            PreviewCallback pCb = mPreviewCallback;
            if (pCb != null) {
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                pCb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            AutoFocusCallback cb = null;
            synchronized (mAutoFocusCallbackLock) {
                cb = mAutoFocusCallback;
            }
            if (cb != null) {
                boolean success = msg.arg1 == 0 ? false : true;
                cb.onAutoFocus(success, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomListener != null) {
                mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_METADATA:
            if (mFaceListener != null) {
                mFaceListener.onFaceDetection((Face[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS_MOVE:
            if (mAutoFocusMoveCallback != null) {
                mAutoFocusMoveCallback.onAutoFocusMoving(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",0,New case statement CAMERA_MSG_FOCUS_MOVE is introduced in the late version. In CAMERA_MSG_PREVIEW_FRAME and CAMERA_MSG_FOCUS cases are slightly adjusted in the way how callback is handled but without altering their behavior. So the code changes involve changes in control dependency and other statements.,"Despite changes in control dependency and other statements, these changes do not affect return values nor change exception handling, so there is no Compatibility Issue."
959,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,15,16,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,0,"{
    if (mInstance == null) {
        mInstance = new WebViewDatabase(context);
    }
    return mInstance;
}","{
    return WebViewFactory.getProvider().getWebViewDatabase(context);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement as well as the dependent API has changed. In the early version, the implementation was returning an instance of WebViewDatabase, while in the late version, it is fetching the WebViewDatabase via WebViewFactory.getProvider().getWebViewDatabase(context). Therefore, the classification of this code change is 1,5.","The change in the return statement leads to a possible change in the return value of the method, which can lead to a compatibility issue for programs depending on this method. Thus, the CI type is 1."
960,<android.webkit.WebView: void requestFocusNodeHref(Message)>,15,16,<android.webkit.WebView: void requestFocusNodeHref(Message)>,<android.webkit.WebView: void requestFocusNodeHref(Message)>,0,"{
    checkThread();
    if (hrefMsg == null) {
        return;
    }
    int contentX = viewToContentX(mLastTouchX + mScrollX);
    int contentY = viewToContentY(mLastTouchY + mScrollY);
    if (nativeHasCursorNode()) {
        Rect cursorBounds = nativeGetCursorRingBounds();
        if (!cursorBounds.contains(contentX, contentY)) {
            int slop = viewToContentDimension(mNavSlop);
            cursorBounds.inset(-slop, -slop);
            if (cursorBounds.contains(contentX, contentY)) {
                contentX = (int) cursorBounds.centerX();
                contentY = (int) cursorBounds.centerY();
            }
        }
    }
    mWebViewCore.sendMessage(EventHub.REQUEST_CURSOR_HREF, contentX, contentY, hrefMsg);
}","{
    checkThread();
    mProvider.requestFocusNodeHref(hrefMsg);
}",1,"/**
 * Request the anchor or image element URL at the last tapped point.
 * If hrefMsg is null, this method returns immediately and does not
 * dispatch hrefMsg to its target. If the tapped point hits an image,
 * an anchor, or an image in an anchor, the message associates
 * strings in named keys in its data. The value paired with the key
 * may be an empty string.
 *
 * @param hrefMsg This message will be dispatched with the result of the
 * request. The message data contains three keys:
 * - ""url"" returns the anchor's href attribute.
 * - ""title"" returns the anchor's text.
 * - ""src"" returns the image's src attribute.
 */
","/**
 * Requests the anchor or image element URL at the last tapped point.
 * If hrefMsg is null, this method returns immediately and does not
 * dispatch hrefMsg to its target. If the tapped point hits an image,
 * an anchor, or an image in an anchor, the message associates
 * strings in named keys in its data. The value paired with the key
 * may be an empty string.
 *
 * @param hrefMsg the message to be dispatched with the result of the
 * request. The message data contains three keys. ""url""
 * returns the anchor's href attribute. ""title"" returns the
 * anchor's text. ""src"" returns the image's src attribute.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the early implementation and the return statement in the late implementation have different dependencies, specifically, on different function calls (mWebViewCore.sendMessage() versus mProvider.requestFocusNodeHref()). The code change type is 1,5.","The late version of the API has removed some condition and control statements and updated the function it depends on. These changes can potentially lead to different return behavior of the API, so the CI type is 1."
961,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,15,16,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>,0,"{
    mUseWebViewBackgroundForOverscroll = view;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 * @deprecated This method is now obsolete.
 */
","/**
 * Sets whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 *
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late version, a new 'throw' statement has been introduced and the old 'set' statement has been deleted, leading to change type 1 and 2.","The late version will always throw an exception, whereas the early version never does so. Additionally, the variable ""mUseWebViewBackgroundForOverscroll"" is now not set in the late version, which causes different behaviors leading to CI types 1 and 2."
963,"<android.nfc.tech.NdefFormatable: void format(NdefMessage,boolean)>",15,16,"<android.nfc.tech.NdefFormatable: void format(NdefMessage,boolean)>","<android.nfc.tech.NdefFormatable: void format(NdefMessage,boolean)>",0,"{
    checkConnected();
    try {
        int serviceHandle = mTag.getServiceHandle();
        INfcTag tagService = mTag.getTagService();
        int errorCode = tagService.formatNdef(serviceHandle, MifareClassic.KEY_DEFAULT);
        switch(errorCode) {
            case ErrorCodes.SUCCESS:
                break;
            case ErrorCodes.ERROR_IO:
                throw new IOException();
            case ErrorCodes.ERROR_INVALID_PARAM:
                throw new FormatException();
            default:
                // Should not happen
                throw new IOException();
        }
        // Now check and see if the format worked
        if (tagService.isNdef(serviceHandle)) {
            errorCode = tagService.ndefWrite(serviceHandle, firstMessage);
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    break;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    throw new FormatException();
                default:
                    // Should not happen
                    throw new IOException();
            }
        } else {
            throw new IOException();
        }
        // optionally make read-only
        if (makeReadOnly) {
            errorCode = tagService.ndefMakeReadOnly(serviceHandle);
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    break;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    throw new IOException();
                default:
                    // Should not happen
                    throw new IOException();
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    }
}","{
    checkConnected();
    try {
        int serviceHandle = mTag.getServiceHandle();
        INfcTag tagService = mTag.getTagService();
        int errorCode = tagService.formatNdef(serviceHandle, MifareClassic.KEY_DEFAULT);
        switch(errorCode) {
            case ErrorCodes.SUCCESS:
                break;
            case ErrorCodes.ERROR_IO:
                throw new IOException();
            case ErrorCodes.ERROR_INVALID_PARAM:
                throw new FormatException();
            default:
                // Should not happen
                throw new IOException();
        }
        // Now check and see if the format worked
        if (!tagService.isNdef(serviceHandle)) {
            throw new IOException();
        }
        // Write a message, if one was provided
        if (firstMessage != null) {
            errorCode = tagService.ndefWrite(serviceHandle, firstMessage);
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    break;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    throw new FormatException();
                default:
                    // Should not happen
                    throw new IOException();
            }
        }
        // optionally make read-only
        if (makeReadOnly) {
            errorCode = tagService.ndefMakeReadOnly(serviceHandle);
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    break;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    throw new IOException();
                default:
                    // Should not happen
                    throw new IOException();
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","The condition within the first 'if' statement has changed, moving the '!' operator creating a negation. Additionally, a null check for the 'firstMessage' variable has been introduced in the late version. These changes fall into the 3) Control dependency changed and 4) Other statement changed categories.",Both changes lead to potential incompatible behavior. The conditional change in the first 'if' statement can lead to different exceptions being thrown (2) Compatibility Issue caused by potential different exception handlings. The newly introduced null check for the 'firstMessage' variable can also lead to different return statements being potentially reached (1) Compatibility Issue caused by potential different return values or types.
965,<android.app.LoaderManagerImpl.LoaderInfo: void start()>,15,16,<android.app.LoaderManagerImpl.LoaderInfo: void start()>,<android.app.LoaderManagerImpl.LoaderInfo: void start()>,0,"{
    if (mRetaining && mRetainingStarted) {
        // Our owner is started, but we were being retained from a
        // previous instance in the started state...  so there is really
        // nothing to do here, since the loaders are still started.
        mStarted = true;
        return;
    }
    if (mStarted) {
        // If loader already started, don't restart.
        return;
    }
    mStarted = true;
    if (DEBUG)
        Log.v(TAG, ""  Starting: "" + this);
    if (mLoader == null && mCallbacks != null) {
        mLoader = mCallbacks.onCreateLoader(mId, mArgs);
    }
    if (mLoader != null) {
        if (mLoader.getClass().isMemberClass() && !Modifier.isStatic(mLoader.getClass().getModifiers())) {
            throw new IllegalArgumentException(""Object returned from onCreateLoader must not be a non-static inner member class: "" + mLoader);
        }
        if (!mListenerRegistered) {
            mLoader.registerListener(mId, this);
            mListenerRegistered = true;
        }
        mLoader.startLoading();
    }
}","{
    if (mRetaining && mRetainingStarted) {
        // Our owner is started, but we were being retained from a
        // previous instance in the started state...  so there is really
        // nothing to do here, since the loaders are still started.
        mStarted = true;
        return;
    }
    if (mStarted) {
        // If loader already started, don't restart.
        return;
    }
    mStarted = true;
    if (DEBUG)
        Log.v(TAG, ""  Starting: "" + this);
    if (mLoader == null && mCallbacks != null) {
        mLoader = mCallbacks.onCreateLoader(mId, mArgs);
    }
    if (mLoader != null) {
        if (mLoader.getClass().isMemberClass() && !Modifier.isStatic(mLoader.getClass().getModifiers())) {
            throw new IllegalArgumentException(""Object returned from onCreateLoader must not be a non-static inner member class: "" + mLoader);
        }
        if (!mListenerRegistered) {
            mLoader.registerListener(mId, this);
            mLoader.registerOnLoadCanceledListener(this);
            mListenerRegistered = true;
        }
        mLoader.startLoading();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new statement mLoader.registerOnLoadCanceledListener(this) was added within the condition 'if (!mListenerRegistered)', so the code change type is 4.","The added statement does not affect the return value or exception handling of the API, hence there's no compatibility issue, and the CI type is 0."
966,<android.webkit.WebView: void invokeZoomPicker()>,15,16,<android.webkit.WebView: void invokeZoomPicker()>,<android.webkit.WebView: void invokeZoomPicker()>,0,"{
    checkThread();
    if (!getSettings().supportZoom()) {
        Log.w(LOGTAG, ""This WebView doesn't support zoom."");
        return;
    }
    clearHelpers();
    mZoomManager.invokeZoomPicker();
}","{
    checkThread();
    mProvider.invokeZoomPicker();
}",1,"/**
 * Invoke the graphical zoom picker widget for this WebView. This will
 * result in the zoom widget appearing on the screen to control the zoom
 * level of this WebView.
 */
","/**
 * Invokes the graphical zoom picker widget for this WebView. This will
 * result in the zoom widget appearing on the screen to control the zoom
 * level of this WebView.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the early version API, 'if' statement with return was deleted. And control flow statement which is 'clearHelpers()', and statement 'mZoomManager.invokeZoomPicker()' have been replaced by 'mProvider.invokeZoomPicker()', which are of type 1,3,4 respectively.","The deletion of the 'if' condition and 'return' statement, and the replacement of 'mZoomManager.invokeZoomPicker()' by 'mProvider.invokeZoomPicker()' could cause the late version API to return a different value. Thus, it is of type 1."
972,<android.webkit.WebView: Picture capturePicture()>,15,16,<android.webkit.WebView: Picture capturePicture()>,<android.webkit.WebView: Picture capturePicture()>,0,"{
    checkThread();
    if (mNativeClass == 0)
        return null;
    Picture result = new Picture();
    nativeCopyBaseContentToPicture(result);
    return result;
}","{
    checkThread();
    return mProvider.capturePicture();
}",1,"/**
 * Return a new picture that captures the current display of the webview.
 * This is a copy of the display, and will be unaffected if the webview
 * later loads a different URL.
 *
 * @return a picture containing the current contents of the view. Note this
 * picture is of the entire document, and is not restricted to the
 * bounds of the view.
 */
","/**
 * Gets a new picture that captures the current display of this WebView.
 * This is a copy of the display, and will be unaffected if this WebView
 * later loads a different URL.
 *
 * @return a picture containing the current contents of this WebView. Note
 * this picture is of the entire document, and is not restricted to
 * the bounds of the view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed from 'return result;' to 'return mProvider.capturePicture();'. Besides, some statements and a call to a dependent method (nativeCopyBaseContentToPicture(result)) are deleted in the Late_Implementation. Therefore, the change types include 1,4,5.","The change in the return statement (returning a result from a different method call) in the Late_Implementation will potentially lead the API to return a different value or type, hence the CI type is 1."
973,<android.webkit.WebView: String getTitle()>,15,16,<android.webkit.WebView: String getTitle()>,<android.webkit.WebView: String getTitle()>,0,"{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getTitle() : null;
}","{
    checkThread();
    return mProvider.getTitle();
}",1,"/**
 * Get the title for the current page. This is the title of the current page
 * until WebViewClient.onReceivedTitle is called.
 * @return The title for the current page.
 */
","/**
 * Gets the title for the current page. This is the title of the current page
 * until WebViewClient.onReceivedTitle is called.
 *
 * @return the title for the current page
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the new version, the method mCallbackProxy.getBackForwardList().getCurrentItem() is replaced with the method mProvider.getTitle(), so the change types are 1 and 5.","The method mProvider.getTitle() may return a different result compared to mCallbackProxy.getBackForwardList().getCurrentItem() causing a potential difference in the returned values. Therefore, the CI type is 1."
974,<android.webkit.WebSettings: void setTextZoom(int)>,15,16,<android.webkit.WebSettings: void setTextZoom(int)>,<android.webkit.WebSettings: void setTextZoom(int)>,0,"{
    if (mTextSize != textZoom) {
        if (WebView.mLogEvent) {
            EventLog.writeEvent(EventLogTags.BROWSER_TEXT_SIZE_CHANGE, mTextSize, textZoom);
        }
        mTextSize = textZoom;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the text zoom of the page in percent. Default is 100.
 * @param textZoom A percent value for increasing or decreasing the text.
 */
","/**
 * Sets the text zoom of the page in percent. Default is 100.
 *
 * @param textZoom the percent value for increasing or decreasing the text
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late implementation, all the statements have been replaced by a throw new MustOverrideException(), so the code change type is 1,2.","As the original statements have been removed and replaced with an exception throw, the method does not return the same value nor handles exceptions in the same way as the earlier version, thus causing a compatibility issue. The CI type is 1,2."
979,<android.webkit.WebSettings: boolean getUseWideViewPort()>,15,16,<android.webkit.WebSettings: boolean getUseWideViewPort()>,<android.webkit.WebSettings: boolean getUseWideViewPort()>,0,"{
    return mUseWideViewport;
}","{
    throw new MustOverrideException();
}",1,"/**
 * @return True if the WebView is using a wide viewport
 */
","/**
 * Gets whether the WebView is using a wide viewport.
 *
 * @return true if the WebView is using a wide viewport
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early implementation of the method simply returned a data member while the later version throws an exception. Hence, the change type includes a change in return type (1), and the addition of an error handling mechanism (2).","This change can result in compatibility issues in two ways. Firstly (1), applications utilizing the API could expect a boolean value returned, but in the later version, the function doesn't return anything and instead throws an exception. Secondly (2), such an exception was never expected in the previous version and, hence, might not be handled by the application."
980,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,15,16,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mIsBeingDragged = getChildCount() != 0;
                if (!mIsBeingDragged) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float y = ev.getY(activePointerIndex);
                final int deltaY = (int) (mLastMotionY - y);
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                final float y = ev.getY(index);
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There are changes on control dependency since the 'if' condition has been updated, and also an additional code block has been added inside to call parent.requestDisallowInterceptTouchEvent(true). Besides, other changes include casting the float values to int with the change in implementation of fetching the Y-axis motion event and altering invalidate() with postInvalidateOnAnimation(). Hence, the code change types are 3,4.","Since the initial code implementation has changed with the added parent.requestDisallowInterceptTouchEvent(true), modifications to casting float values to int, and altered invalidate() method, the implementation differences could result in different behaviours of the API potentially causing different return values. Therefore, the CI type is 1."
982,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,15,16,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,0,"{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f.mIndex);
    mActive.set(f.mIndex, null);
    if (mAvailIndices == null) {
        mAvailIndices = new ArrayList<Integer>();
    }
    mAvailIndices.add(f.mIndex);
    mActivity.invalidateFragmentIndex(f.mIndex);
    f.initState();
}","{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f);
    mActive.set(f.mIndex, null);
    if (mAvailIndices == null) {
        mAvailIndices = new ArrayList<Integer>();
    }
    mAvailIndices.add(f.mIndex);
    mActivity.invalidateFragmentIndex(f.mIndex);
    f.initState();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable in the log statement has changed from f.mIndex to f. Therefore, the code change type is 4. ","This change won't affect the return value or the exception handling of this method, so no compatibility issues exist, and the CI type is 0."
984,"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",15,16,"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_BROADCAST, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_BROADCAST, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statement inside the getBroadcast method of the ActivityManagerNative class has been modified, a new `null` parameter has been added in the last method call while the parameter `IActivityManager.INTENT_SENDER_BROADCAST` has been changed to `ActivityManager.INTENT_SENDER_BROADCAST`, so the code change type is 4.","The change in parameter could affect the return value of `getIntentSender()` method or the creation of `PendingIntent` object if the new `null` parameter makes any difference on how the `getIntentSender()` function processes which in turn can cause a difference in return type or value between the two versions. Hence, the Compatibility Issue type is 1."
985,<android.webkit.CallbackProxy: WebResourceResponse shouldInterceptRequest(String)>,15,16,<android.webkit.CallbackProxy: WebResourceResponse shouldInterceptRequest(String)>,<android.webkit.CallbackProxy: WebResourceResponse shouldInterceptRequest(String)>,0,"{
    if (mWebViewClient == null) {
        return null;
    }
    // Note: This method does _not_ send a message.
    WebResourceResponse r = mWebViewClient.shouldInterceptRequest(mWebView, url);
    if (r == null) {
        sendMessage(obtainMessage(LOAD_RESOURCE, url));
    }
    return r;
}","{
    if (mWebViewClient == null) {
        return null;
    }
    // Note: This method does _not_ send a message.
    WebResourceResponse r = mWebViewClient.shouldInterceptRequest(mWebView.getWebView(), url);
    if (r == null) {
        sendMessage(obtainMessage(LOAD_RESOURCE, url));
    }
    return r;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API has changed, the method from `mWebView` directly has transformed to `mWebView.getWebView()`, so the code change type is 5.","The call to `mWebView.getWebView()` could potentially influence the behavior of `mWebViewClient.shouldInterceptRequest()` and thus change the return value, so the CI type is 1."
987,"<android.webkit.WebStorage: void getQuotaForOrigin(String,ValueCallback<Long>)>",15,16,"<android.webkit.WebStorage: void getQuotaForOrigin(String,ValueCallback<Long>)>","<android.webkit.WebStorage: void getQuotaForOrigin(String,ValueCallback<Long>)>",0,"{
    if (callback == null) {
        return;
    }
    if (origin == null) {
        callback.onReceiveValue(null);
        return;
    }
    if (WebViewCore.THREAD_NAME.equals(Thread.currentThread().getName())) {
        syncValues();
        Origin website = mOrigins.get(origin);
        callback.onReceiveValue(new Long(website.getUsage()));
    } else {
        HashMap values = new HashMap<String, Object>();
        values.put(ORIGIN, origin);
        values.put(CALLBACK, callback);
        postMessage(Message.obtain(null, GET_QUOTA_ORIGIN, values));
    }
}","{
// Must be a no-op for backward compatibility: see the hidden constructor for reason.
}",1,"/**
 * Returns the quota for a given origin
 */
","/**
 * Gets the storage quota for the Web SQL Database API for the given origin.
 * The quota is given in bytes and the origin is specified using its string
 * representation. This method operates asynchronously, with the result
 * being provided via a {@link ValueCallback}. Note that a quota is not
 * enforced on a per-origin basis for the Application Cache API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation in the late version became a no-op comment, deleting all the previous method actions. Thus, the changes include the return statement being deleted and other statements being removed. Therefore, the change types are 1,4.","Since the late version's implementation became a comment and doesn't do anything, it could make the API return a different value from what the early implementation would return. Therefore, the CI type is 1 due to the potential change in the method return value."
988,<android.webkit.WebSettings: void setNavDump(boolean)>,15,16,<android.webkit.WebSettings: void setNavDump(boolean)>,<android.webkit.WebSettings: void setNavDump(boolean)>,0,"{
    mNavDump = enabled;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Enables dumping the pages navigation cache to a text file.
 * @deprecated This method is now obsolete.
 */
","/**
 * Enables dumping the pages navigation cache to a text file.
 *
 * @deprecated This method is now obsolete.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,4",2,"The behavior of the method significantly changes from setting an attribute, mNavDump, to throwing an exception (setNavDump always throws an exception in the late version regardless of the input). Hence, the code change type is 2,4.","The introduction of a throwing exception could lead to a behavior change. The API could throw an exception when executed, in cases where it was not throwing any in the earlier version. Hence, the Compatibility Issue type is 2."
990,"<android.hardware.SensorManager: boolean registerListener(SensorListener,int,int)>",15,16,"<android.hardware.SensorManager: boolean registerListener(SensorListener,int,int)>","<android.hardware.SensorManager: boolean registerListener(SensorListener,int,int)>",0,"{
    if (listener == null) {
        return false;
    }
    boolean result = false;
    result = registerLegacyListener(SENSOR_ACCELEROMETER, Sensor.TYPE_ACCELEROMETER, listener, sensors, rate) || result;
    result = registerLegacyListener(SENSOR_MAGNETIC_FIELD, Sensor.TYPE_MAGNETIC_FIELD, listener, sensors, rate) || result;
    result = registerLegacyListener(SENSOR_ORIENTATION_RAW, Sensor.TYPE_ORIENTATION, listener, sensors, rate) || result;
    result = registerLegacyListener(SENSOR_ORIENTATION, Sensor.TYPE_ORIENTATION, listener, sensors, rate) || result;
    result = registerLegacyListener(SENSOR_TEMPERATURE, Sensor.TYPE_TEMPERATURE, listener, sensors, rate) || result;
    return result;
}","{
    return getLegacySensorManager().registerListener(listener, sensors, rate);
}",1,"/**
 * Registers a SensorListener for given sensors.
 *
 * @deprecated This method is deprecated, use
 * {@link SensorManager#registerListener(SensorEventListener, Sensor, int)}
 * instead.
 *
 * @param listener
 * sensor listener object
 *
 * @param sensors
 * a bit masks of the sensors to register to
 *
 * @param rate
 * rate of events. This is only a hint to the system. events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 *
 * @return <code>true</code> if the sensor is supported and successfully
 * enabled
 */
","/**
 * Registers a SensorListener for given sensors.
 *
 * @deprecated This method is deprecated, use
 * {@link SensorManager#registerListener(SensorEventListener, Sensor, int)}
 * instead.
 *
 * @param listener
 * sensor listener object
 *
 * @param sensors
 * a bit masks of the sensors to register to
 *
 * @param rate
 * rate of events. This is only a hint to the system. events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 *
 * @return <code>true</code> if the sensor is supported and successfully
 * enabled
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The code has been simplified from multiple different calls to registerLegacyListener() method to a single call to getLegacySensorManager().registerListener() method. As the methods and their parameters are different, the code change type is 1,5.","Since the implementation has changed significantly, this might change the return values of this method depending on the implementation of getLegacySensorManager().registerListener(). Hence, the Compatibility Issue type is 1."
991,"<android.webkit.CookieManager: void setCookie(String,String)>",15,16,"<android.webkit.CookieManager: void setCookie(String,String)>","<android.webkit.CookieManager: void setCookie(String,String)>",0,"{
    if (JniUtil.useChromiumHttpStack()) {
        setCookie(url, value, false);
        return;
    }
    WebAddress uri;
    try {
        uri = new WebAddress(url);
    } catch (ParseException ex) {
        Log.e(LOGTAG, ""Bad address: "" + url);
        return;
    }
    setCookie(uri, value);
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set cookie for a given url. The old cookie with same host/path/name will
 * be removed. The new cookie will be added if it is not expired or it does
 * not have expiration which implies it is session cookie.
 * @param url The url which cookie is set for
 * @param value The value for set-cookie: in http response header
 */
","/**
 * Sets a cookie for the given URL. Any existing cookie with the same host,
 * path and name will be replaced with the new cookie. The cookie being set
 * must not have expired and must not be a session cookie, otherwise it
 * will be ignored.
 *
 * @param url the URL for which the cookie is set
 * @param value the cookie as a string, using the format of the 'Set-Cookie'
 * HTTP response header
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 2","1, 2","In the late version, all previous statements are deleted and a new exception throw statement is introduced, so the change type is 1,2.","In the early version, there were multiple return points but in the late version, an exception is simply thrown. This could cause the API potentially return a different value and also potentially throws a different exception. Therefore, the CI type is 1,2."
992,<android.app.WallpaperManager: void setBitmap(Bitmap)>,15,16,<android.app.WallpaperManager: void setBitmap(Bitmap)>,<android.app.WallpaperManager: void setBitmap(Bitmap)>,0,"{
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition ""if (sGlobals.mService == null)"" has been added in the late implementation which is a control dependency change, so the code change type is 3.","The newly added condition ""if (sGlobals.mService == null)"" could cause the method to return at that point without executing the rest of the code, which is different from the early implementation. This potential difference in behavior could bring CI, so the CI type is 1."
993,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,15,16,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,0,"{
    mNumResults++;
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(account));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onError() on response "" + response);
                }
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
            } else {
                if (mStripAuthTokenFromResult) {
                    result.remove(AccountManager.KEY_AUTHTOKEN);
                }
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
                }
                response.onResult(result);
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}","{
    mNumResults++;
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(mAccounts, account));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onError() on response "" + response);
                }
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
            } else {
                if (mStripAuthTokenFromResult) {
                    result.remove(AccountManager.KEY_AUTHTOKEN);
                }
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
                }
                response.onResult(result);
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the method call to 'getSigninRequiredNotificationId', where an additional variable 'mAccounts' is passed as an argument in the late version, hence the code change types are 4,5.","Providing additional argument to the function 'getSigninRequiredNotificationId' won't affect the return type or value of API 'onResult(Bundle)', nor does it affect the potential exception handling of the API. Therefore, no Compatibility Issue exists here. The CI type is 0."
994,<android.content.res.Configuration: int updateFrom(Configuration)>,15,16,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        textLayoutDirection = LocaleUtil.getLayoutDirectionFromLocale(locale);
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        layoutDirection = LocaleUtil.getLayoutDirectionFromLocale(locale);
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
","/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The variable 'textLayoutDirection' has been changed to 'layoutDirection' in the function call of LocaleUtil.getLayoutDirectionFromLocale(), so the code change type is 4.","The change of variable 'textLayoutDirection' to 'layoutDirection' could potentially result in different behaviors when using the function call of LocaleUtil.getLayoutDirectionFromLocale(), so the CI type is 1."
996,<android.widget.TextView: String getPrivateImeOptions()>,15,16,<android.widget.TextView: String getPrivateImeOptions()>,<android.widget.TextView: String getPrivateImeOptions()>,0,"{
    return mInputContentType != null ? mInputContentType.privateImeOptions : null;
}","{
    return mEditor != null && mEditor.mInputContentType != null ? mEditor.mInputContentType.privateImeOptions : null;
}",1,"/**
 * Get the private type of the content.
 *
 * @see #setPrivateImeOptions(String)
 * @see EditorInfo#privateImeOptions
 */
","/**
 * Get the private type of the content.
 *
 * @see #setPrivateImeOptions(String)
 * @see EditorInfo#privateImeOptions
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed and the control condition for deciding the return value has also changed. Therefore, the code change type is both 1 and 3.","This alteration in the condition of the return statement is prime to potentially change the return value of the API based on the conditions. Therefore, it leads to a compatibility issue of type 1."
998,"<android.view.GLES20Canvas: void drawOval(RectF,Paint)>",15,16,"<android.view.GLES20Canvas: void drawOval(RectF,Paint)>","<android.view.GLES20Canvas: void drawOval(RectF,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    nDrawOval(mRenderer, oval.left, oval.top, oval.right, oval.bottom, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawOval(mRenderer, oval.left, oval.top, oval.right, oval.bottom, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3",1,"The first line in both versions changed: 'setupModifiers(paint)' is replaced with 'setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER)'. Also, the introduction of try and finally blocks can also be seen as a change in control dependency and exception handling, so the code change type is 1,2,3.","The change in the setupModifier method invocation which acts as a dependency API could potentially return a different value in 'modifiers' variable and could impact the subsequent operations like 'nDrawOval' or 'nResetModifiers'. Furthermore, the introduction of 'try'-'finally' block also changes the control flow of the method, which may cause the method to return different results based on the condition of 'modifiers' variable after these changes. Thus, the CI type is 1."
999,<android.webkit.WebSettings: void setAllowFileAccess(boolean)>,15,16,<android.webkit.WebSettings: void setAllowFileAccess(boolean)>,<android.webkit.WebSettings: void setAllowFileAccess(boolean)>,0,"{
    mAllowFileAccess = allow;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Enable or disable file access within WebView. File access is enabled by
 * default.  Note that this enables or disables file system access only.
 * Assets and resources are still accessible using file:///android_asset and
 * file:///android_res.
 */
","/**
 * Enables or disables file access within WebView. File access is enabled by
 * default.  Note that this enables or disables file system access only.
 * Assets and resources are still accessible using file:///android_asset and
 * file:///android_res.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The earlier version had an assignment statement that has been replaced by a 'throw' statement in the later version. Therefore, the change type is 1 (Return statement changed), and 2 (Exception handling statement changed).","The earlier version allowed file access based on a boolean flag. However, the later version throws an exception, making it behave differently. Therefore, there is a compatibility issue of type 1 (caused by potential different return values or types) and type 2 (caused by potential different exception handlings)."
1001,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>",15,16,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>","<android.webkit.WebView: boolean showFindDialog(String,boolean)>",0,"{
    checkThread();
    FindActionModeCallback callback = new FindActionModeCallback(mContext);
    if (getParent() == null || startActionMode(callback) == null) {
        // Could not start the action mode, so end Find on page
        return false;
    }
    mCachedOverlappingActionModeHeight = -1;
    mFindCallback = callback;
    setFindIsUp(true);
    mFindCallback.setWebView(this);
    if (showIme) {
        mFindCallback.showSoftInput();
    } else if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
        return true;
    }
    if (text == null) {
        text = mLastFind;
    }
    if (text != null) {
        mFindCallback.setText(text);
    }
    return true;
}","{
    checkThread();
    return mProvider.showFindDialog(text, showIme);
}",1,"/**
 * Start an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 * @param text If non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme If true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return boolean True if the find dialog is shown, false otherwise.
 */
","/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The API has removed several different types of statements, including the return statement, and replaced them with a new return statement 'return mProvider.showFindDialog(text, showIme);'. Also, the method showFindDialog() called in return statement is a dependent API which is not found in the early version, therefore the code change type is 1,4,5.","The return statement has changed significantly. Whether or not showFindDialog() returns the same result as the old method depends on its implementation (which we don't know), so the API may return different results, thus CI type is 1."
1002,<android.database.sqlite.SQLiteDatabase: void setLocale(Locale)>,15,16,<android.database.sqlite.SQLiteDatabase: void setLocale(Locale)>,<android.database.sqlite.SQLiteDatabase: void setLocale(Locale)>,0,"{
    lock();
    try {
        native_setLocale(locale.toString(), mFlags);
    } finally {
        unlock();
    }
}","{
    if (locale == null) {
        throw new IllegalArgumentException(""locale must not be null."");
    }
    synchronized (mLock) {
        throwIfNotOpenLocked();
        final Locale oldLocale = mConfigurationLocked.locale;
        mConfigurationLocked.locale = locale;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.locale = oldLocale;
            throw ex;
        }
    }
}",1,"/**
 * Sets the locale for this database.  Does nothing if this database has
 * the NO_LOCALIZED_COLLATORS flag set or was opened read only.
 * @throws SQLException if the locale could not be set.  The most common reason
 * for this is that there is no collator available for the locale you requested.
 * In this case the database remains unchanged.
 */
","/**
 * Sets the locale for this database.  Does nothing if this database has
 * the {@link #NO_LOCALIZED_COLLATORS} flag set or was opened read only.
 *
 * @param locale The new locale.
 *
 * @throws SQLException if the locale could not be set.  The most common reason
 * for this is that there is no collator available for the locale you requested.
 * In this case the database remains unchanged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","Multiple changes took place between the two versions. There is a new control statement (if (locale == null)) introduced (Change Type 3). The `lock()` and `unlock()` have been replaced with a synchronized statement while the exception handling statements changed as well (Change Type 2). The return statement (`native_setLocale(locale.toString(), mFlags);` in Early Implementation) was replaced by a new variable assignment and a new API is called (`mConnectionPoolLocked.reconfigure(mConfigurationLocked);` in Late Implementation (Change Type 1,5). Hence the change is of type 1,2,3,4,5.","The change in the return statement could result in the API returning a different value, leading to a Compatibility Issue Type 1. Also, the exception handling change means that the Late Implementation now throws an IllegalArgumentException when the locale is null (which was not present in the Early Implementation). This change in exception handling leads to Compatibility Issue Type 2."
1004,"<android.widget.TextView: boolean extractText(ExtractedTextRequest,ExtractedText)>",15,16,"<android.widget.TextView: boolean extractText(ExtractedTextRequest,ExtractedText)>","<android.widget.TextView: boolean extractText(ExtractedTextRequest,ExtractedText)>",0,"{
    return extractTextInternal(request, EXTRACT_UNKNOWN, EXTRACT_UNKNOWN, EXTRACT_UNKNOWN, outText);
}","{
    createEditorIfNeeded();
    return mEditor.extractText(request, outText);
}",1,"/**
 * If this TextView contains editable content, extract a portion of it
 * based on the information in <var>request</var> in to <var>outText</var>.
 * @return Returns true if the text was successfully extracted, else false.
 */
","/**
 * If this TextView contains editable content, extract a portion of it
 * based on the information in <var>request</var> in to <var>outText</var>.
 * @return Returns true if the text was successfully extracted, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of this method changed from calling the `extractTextInternal` method to calling the `extractText` method of `mEditor` after invoking `createEditorIfNeeded`. Thus, the change falls under Return statement changed (1), as the returned statement could potentially return different values or types, and the Dependent API changed (5), as there is a change in the dependent API `extractTextInternal` to `mEditor.extractText`.","The different returned result from the late version could cause a compatibility issue due to the potential difference in the return values or types from the previous version to the new one. Hence, the compatibility issue is classified as Compatibility Issue caused by potential different return values or types (1)."
1005,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",15,16,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,The number of arguments in ActivityManagerNative.getDefault().broadcastIntent() has increased from 10 to 11 with an addition of Binder.getOrigCallingUser() which is considered as typ 4 as it's a kind of other statement and type 5 as data or information depending on 'Binder.getOrigCallingUser()' might differ leading to code to behave differently.,"Despite the changes in the called function, the return value of the parent function has not been affected, nither the exception handling. therefore there's no actual compatibility issues and the CI type is 0."
1006,"<android.app.AlarmManager: void setRepeating(int,long,long,PendingIntent)>",15,16,"<android.app.AlarmManager: void setRepeating(int,long,long,PendingIntent)>","<android.app.AlarmManager: void setRepeating(int,long,long,PendingIntent)>",0,"{
    try {
        mService.setRepeating(type, triggerAtTime, interval, operation);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mService.setRepeating(type, triggerAtMillis, intervalMillis, operation);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,
 * timeouts, etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>Like {@link #set}, except you can also
 * supply a rate at which the alarm will repeat.  This alarm continues
 * repeating until explicitly removed with {@link #cancel}.  If the time
 * occurs in the past, the alarm will be triggered immediately, with an
 * alarm count depending on how far in the past the trigger time is relative
 * to the repeat interval.
 *
 * <p>If an alarm is delayed (by system sleep, for example, for non
 * _WAKEUP alarm types), a skipped repeat will be delivered as soon as
 * possible.  After that, future alarms will be delivered according to the
 * original schedule; they do not drift over time.  For example, if you have
 * set a recurring alarm for the top of every hour but the phone was asleep
 * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
 * then the next alarm will be sent at 9:00.
 *
 * <p>If your application wants to allow the delivery times to drift in
 * order to guarantee that at least a certain time interval always elapses
 * between alarms, then the approach to take is to use one-time alarms,
 * scheduling the next one yourself when handling each alarm delivery.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtTime Time the alarm should first go off, using the
 * appropriate clock (depending on the alarm type).
 * @param interval Interval between subsequent repeats of the alarm.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
","/**
 * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,
 * timeouts, etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>Like {@link #set}, except you can also
 * supply a rate at which the alarm will repeat.  This alarm continues
 * repeating until explicitly removed with {@link #cancel}.  If the time
 * occurs in the past, the alarm will be triggered immediately, with an
 * alarm count depending on how far in the past the trigger time is relative
 * to the repeat interval.
 *
 * <p>If an alarm is delayed (by system sleep, for example, for non
 * _WAKEUP alarm types), a skipped repeat will be delivered as soon as
 * possible.  After that, future alarms will be delivered according to the
 * original schedule; they do not drift over time.  For example, if you have
 * set a recurring alarm for the top of every hour but the phone was asleep
 * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
 * then the next alarm will be sent at 9:00.
 *
 * <p>If your application wants to allow the delivery times to drift in
 * order to guarantee that at least a certain time interval always elapses
 * between alarms, then the approach to take is to use one-time alarms,
 * scheduling the next one yourself when handling each alarm delivery.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The parameters of mService.setRepeating() have changed from (type, triggerAtTime, interval, operation) to (type, triggerAtMillis, intervalMillis, operation), so the code change type is 1,5.","Although there was a change in the parameter names, but these parameters still refer to the same type of objects or values. Thus, no potential change in API behavior or return value was introduced, therefore no Compatibility Issue (CI). The CI type is 0."
1009,<android.widget.TextView: boolean onDragEvent(DragEvent)>,15,16,<android.widget.TextView: boolean onDragEvent(DragEvent)>,<android.widget.TextView: boolean onDragEvent(DragEvent)>,0,"{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            final int offset = getOffsetForPosition(event.getX(), event.getY());
            Selection.setSelection((Spannable) mText, offset);
            return true;
        case DragEvent.ACTION_DROP:
            onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}","{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return mEditor != null && mEditor.hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            final int offset = getOffsetForPosition(event.getX(), event.getY());
            Selection.setSelection((Spannable) mText, offset);
            return true;
        case DragEvent.ACTION_DROP:
            if (mEditor != null)
                mEditor.onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The method calls within the control structure (switch-case) have been modified, so the code change types are 1 and 3.","With the introduction of condition ""mEditor != null"" and the change of method call ""hasInsertionController()"" to ""mEditor.hasInsertionController()"" and ""onDrop(event)"" to ""mEditor.onDrop(event)"", the method can potentially returns different values if the conditions do not meet or mEditor does not exist. Thus, the CI type is 1."
1011,<android.database.sqlite.SQLiteStatement: void execute()>,15,16,<android.database.sqlite.SQLiteStatement: void execute()>,<android.database.sqlite.SQLiteStatement: void execute()>,0,"{
    executeUpdateDelete();
}","{
    acquireReference();
    try {
        getSession().execute(getSql(), getBindArgs(), getConnectionFlags(), null);
    } catch (SQLiteDatabaseCorruptException ex) {
        onCorruption();
        throw ex;
    } finally {
        releaseReference();
    }
}",1,"/**
 * Execute this SQL statement, if it is not a SELECT / INSERT / DELETE / UPDATE, for example
 * CREATE / DROP table, view, trigger, index etc.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement, if it is not a SELECT / INSERT / DELETE / UPDATE, for example
 * CREATE / DROP table, view, trigger, index etc.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The entire implementation of the method has changed. This includes changes to the invoked methods (executeUpdateDelete to getSession().execute() and others), the introduction of exception handling logic, and changes to the return instructions. This falls under categories 1 (Return statement changed), 2 (Exception handling statement changed), and 5 (Dependent API changed).","The newly implemented method now potentially throws a new type of exception (SQLiteDatabaseCorruptException) and the return instruction has changed, so now it could potentially return different values or even types. This is a Compatibility Issue that falls under categories 1 and 2, which refer to changes in return values or types, and changes in exception handling, respectively."
1016,"<android.app.DatePickerDialog: void onClick(DialogInterface,int)>",15,16,"<android.app.DatePickerDialog: void onClick(DialogInterface,int)>","<android.app.DatePickerDialog: void onClick(DialogInterface,int)>",0,"{
    if (mCallBack != null) {
        mDatePicker.clearFocus();
        mCallBack.onDateSet(mDatePicker, mDatePicker.getYear(), mDatePicker.getMonth(), mDatePicker.getDayOfMonth());
    }
}","{
    tryNotifyDateSet();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The calling method changes, from several detailed set and clear operations to a single method ""tryNotifyDateSet()"", so the code change type is 1,5.","As the change in the method calling could possibly make this API return different values, so the CI type is 1."
1018,<android.view.View: boolean post(Runnable)>,15,16,<android.view.View: boolean post(Runnable)>,<android.view.View: boolean post(Runnable)>,0,"{
    Handler handler;
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        handler = attachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().post(action);
        return true;
    }
    return handler.post(action);
}","{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.post(action);
    }
    // Assume that post will succeed later
    ViewRootImpl.getRunQueue().post(action);
    return true;
}",1,"/**
 * <p>Causes the Runnable to be added to the message queue.
 * The runnable will be run on the user interface thread.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable that will be executed.
 *
 * @return Returns true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 */
","/**
 * <p>Causes the Runnable to be added to the message queue.
 * The runnable will be run on the user interface thread.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable that will be executed.
 *
 * @return Returns true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 *
 * @see #postDelayed
 * @see #removeCallbacks
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition under 'if' and the location of return statements in the control process have changed, and there is a deletion of defining 'handler' variable, so the code change type is 3,4.","Due to the modification of 'if' condition, the sequence and choice of return statements are different between the two versions, which may result in different return values under some circumstances. So, a Compatibility Issue of type 1 exists."
1019,<android.webkit.WebSettings: String getDatabasePath()>,15,16,<android.webkit.WebSettings: String getDatabasePath()>,<android.webkit.WebSettings: String getDatabasePath()>,0,"{
    return mDatabasePath;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return the path to where database storage API databases are saved for
 * the current WebView.
 * @return the String path to the database storage API databases.
 */
","/**
 * Gets the path to where database storage API databases are saved for
 * the current WebView.
 *
 * @return the String path to the database storage API databases
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been replaced with an exception throw statement, thus the change type is 1,2.","The removed return statement and the new exception handling could result in a different behaviour when the late version API is invoked, leading to a potential different return output or different exception handling. Therefore, the CI type is 1,2."
1024,<android.webkit.WebView: boolean zoomOut()>,15,16,<android.webkit.WebView: boolean zoomOut()>,<android.webkit.WebView: boolean zoomOut()>,0,"{
    checkThread();
    return mZoomManager.zoomOut();
}","{
    checkThread();
    return mProvider.zoomOut();
}",1,"/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
","/**
 * Performs zoom out in this WebView.
 *
 * @return true if zoom out succeeds, false if no zoom changes
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed from using mZoomManager.zoomOut() to mProvider.zoomOut() in the return statement, and the dependent method zoomOut() in the object mProvider is potentially different from the zoomOut() in mZoomManager. So, the code change type is 1,5.","The change of method implementation can cause the method to potentially return different value, therefore, the CI type is 1."
1025,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,15,16,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,<android.content.AsyncTaskLoader.LoadTask: void onPostExecute(D)>,0,"{
    if (DEBUG)
        Slog.v(TAG, this + "" onPostExecute"");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        done.countDown();
    }
}","{
    if (DEBUG)
        Slog.v(TAG, this + "" onPostExecute"");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}",1,"/* Runs on the UI thread */
","/* Runs on the UI thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The variable name inside a statement has changed, from `done` to `mDone`, so the code change type is 4.","Although the variable name has changed, this has no impact on the return variable and Exception handling. As such, there is no Compatibility Issue (CI), so the CI type is 0."
1026,<android.widget.TextView: CharSequence getError()>,15,16,<android.widget.TextView: CharSequence getError()>,<android.widget.TextView: CharSequence getError()>,0,"{
    return mError;
}","{
    return mEditor == null ? null : mEditor.mError;
}",1,"/**
 * Returns the error message that was set to be displayed with
 * {@link #setError}, or <code>null</code> if no error was set
 * or if it the error was cleared by the widget after user input.
 */
","/**
 * Returns the error message that was set to be displayed with
 * {@link #setError}, or <code>null</code> if no error was set
 * or if it the error was cleared by the widget after user input.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"In the early version, the method directly returned a variable 'mError', while in the later version, it firstly checks if 'mEditor' is null, and then returned a variable 'mEditor.mError'. So the change type is 1.","The returned variable of the method has changed from 'mError' to 'mEditor.mError' and a null-check is also added to it. Therefore, the method can potentially return a different value which leads to a class 1 Compatibility Issue."
1027,"<android.app.ApplicationPackageManager: void setComponentEnabledSetting(ComponentName,int,int)>",15,16,"<android.app.ApplicationPackageManager: void setComponentEnabledSetting(ComponentName,int,int)>","<android.app.ApplicationPackageManager: void setComponentEnabledSetting(ComponentName,int,int)>",0,"{
    try {
        mPM.setComponentEnabledSetting(componentName, newState, flags);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.setComponentEnabledSetting(componentName, newState, flags, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The dependent API 'setComponentEnabledSetting()' has added a new parameter named 'UserId.myUserId()', so the code change type is 5.","Since the dependent API 'setComponentEnabledSetting()' has an extra parameter 'UserId.myUserId()' in comparison to the early version, the output it produces may vary. Since it is nested in a try statement, the exception it throws is likely to change as well, so the CI type is 1."
1028,<android.widget.ShareActionProvider.ShareMenuItemOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,15,16,<android.widget.ShareActionProvider.ShareMenuItemOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,<android.widget.ShareActionProvider.ShareMenuItemOnMenuItemClickListener: boolean onMenuItemClick(MenuItem)>,0,"{
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    final int itemId = item.getItemId();
    Intent launchIntent = dataModel.chooseActivity(itemId);
    if (launchIntent != null) {
        mContext.startActivity(launchIntent);
    }
    return true;
}","{
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    final int itemId = item.getItemId();
    Intent launchIntent = dataModel.chooseActivity(itemId);
    if (launchIntent != null) {
        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        mContext.startActivity(launchIntent);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The 'launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);' line has been added in the later version, means the flags of launchIntent have changed, so the change type is 4.","Although the 'launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);' line has been added, this change doesn't seem to alter the type or value that the API returns, or the exceptions it throws. Therefore, no compatibility issues (CI) are identified - CI type is 0."
1032,<android.webkit.WebSettings: void setRenderPriority(RenderPriority)>,15,16,<android.webkit.WebSettings: void setRenderPriority(RenderPriority)>,<android.webkit.WebSettings: void setRenderPriority(RenderPriority)>,0,"{
    if (mRenderPriority != priority) {
        mRenderPriority = priority;
        mEventHandler.sendMessage(Message.obtain(null, EventHandler.PRIORITY));
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the priority of the Render thread. Unlike the other settings, this
 * one only needs to be called once per process. The default is NORMAL.
 *
 * @param priority RenderPriority, can be normal, high or low.
 */
","/**
 * Sets the priority of the Render thread. Unlike the other settings, this
 * one only needs to be called once per process. The default is NORMAL.
 *
 * @param priority a RenderPriority
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","In the late implementation, a new exception statement, ""throw new MustOverrideException()"", has been introduced, and an ""if"" statement has been deleted. Thus, the change type is 1,2.","The deletion of the ""if"" statement leads to the change of the return value, and the introduction of the new exception statement leads to a new exception being thrown. Therefore, the CI type is 1,2."
1036,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,15,16,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,<android.database.sqlite.SQLiteDatabase: boolean isOpen()>,0,"{
    return mNativeHandle != 0;
}","{
    synchronized (mLock) {
        return mConnectionPoolLocked != null;
    }
}",1,"/**
 * @return true if the DB is currently open (has not been closed)
 */
","/**
 * Returns true if the database is currently open.
 *
 * @return True if the database is currently open (has not been closed).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed from returning `mNativeHandle != 0` to `mConnectionPoolLocked != null` inside a synchronized block (a control statement), so the code change type is 1,3","The 'return statement changed' significantly here, leading to the potential for different return values in these two versions, thus the API could behave differently, so the CI type is 1."
1037,<android.server.BluetoothAdapterStateMachine.HotOff: boolean processMessage(Message)>,15,16,<android.server.BluetoothAdapterStateMachine.HotOff: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.HotOff: boolean processMessage(Message)>,0,"{
    log(""HotOff process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            if ((Boolean) message.obj) {
                persistSwitchSetting(true);
            }
        // $FALL-THROUGH$
        case TURN_ON_CONTINUE:
            mBluetoothService.switchConnectable(true);
            transitionTo(mSwitching);
            break;
        case AIRPLANE_MODE_ON:
        case TURN_COLD:
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
                transitionTo(mSwitching);
                mBluetoothService.switchConnectable(true);
            }
            break;
        case PER_PROCESS_TURN_ON:
            transitionTo(mPerProcessState);
            // Resend the PER_PROCESS_TURN_ON message so that the callback
            // can be sent through.
            deferMessage(message);
            mBluetoothService.switchConnectable(true);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case // ignore
        USER_TURN_OFF:
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                recoverStateMachine(TURN_HOT, null);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""HotOff process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            if ((Boolean) message.obj) {
                persistSwitchSetting(true);
            }
        // $FALL-THROUGH$
        case TURN_ON_CONTINUE:
            mBluetoothService.switchConnectable(true);
            transitionTo(mSwitching);
            break;
        case AIRPLANE_MODE_ON:
        case TURN_COLD:
            shutoffBluetooth();
            // we cannot go to power off state yet, we need wait for the Bluetooth
            // device power off. Unfortunately the stack does not give a event back
            // so we wait a little bit here
            sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            break;
        case POWER_DOWN_TIMEOUT:
            transitionTo(mPowerOff);
            if (!mDelayBroadcastStateOff) {
                broadcastState(BluetoothAdapter.STATE_OFF);
            }
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
                transitionTo(mSwitching);
                mBluetoothService.switchConnectable(true);
            }
            break;
        case PER_PROCESS_TURN_ON:
            transitionTo(mPerProcessState);
            // Resend the PER_PROCESS_TURN_ON message so that the callback
            // can be sent through.
            deferMessage(message);
            mBluetoothService.switchConnectable(true);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case // ignore
        USER_TURN_OFF:
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                recoverStateMachine(TURN_HOT, null);
            }
            break;
        case TURN_HOT:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the case 'AIRPLANE_MODE_ON' and 'TURN_COLD', several statements have been changed. So, the types of code change are 3 and 4.","The state transition logic of 'AIRPLANE_MODE_ON' and 'TURN_COLD' changed, which can directly affect the device's power status. So it could return different behavior such as a different state depending on the operation. Thus, the compatibility issue type is 1."
1039,"<android.database.CursorWindow: void writeToParcel(Parcel,int)>",15,16,"<android.database.CursorWindow: void writeToParcel(Parcel,int)>","<android.database.CursorWindow: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mStartPos);
    nativeWriteToParcel(mWindowPtr, dest);
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        dest.writeInt(mStartPos);
        nativeWriteToParcel(mWindowPtr, dest);
    } finally {
        releaseReference();
    }
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        releaseReference();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"In the early version, no reference was acquired before write operation. In the late version, acquireReference() was introduced and releaseReference() was moved into a finally block. Also, additional normal statements have been introduced at the start of the method. Therefore, the type of code change is 3 (Control dependency change) and 4 (Other statement change).","The introduced change in the late version is mainly about resource management, which doesn't change the essentials of writing data to a parcel. It is not likely to cause the API to return different variable or throw a new exception. Therefore, no compatibility issue exists."
1040,"<android.database.DatabaseUtils: void writeExceptionToParcel(Parcel,Exception)>",15,16,"<android.database.DatabaseUtils: void writeExceptionToParcel(Parcel,Exception)>","<android.database.DatabaseUtils: void writeExceptionToParcel(Parcel,Exception)>",0,"{
    int code = 0;
    boolean logException = true;
    if (e instanceof FileNotFoundException) {
        code = 1;
        logException = false;
    } else if (e instanceof IllegalArgumentException) {
        code = 2;
    } else if (e instanceof UnsupportedOperationException) {
        code = 3;
    } else if (e instanceof SQLiteAbortException) {
        code = 4;
    } else if (e instanceof SQLiteConstraintException) {
        code = 5;
    } else if (e instanceof SQLiteDatabaseCorruptException) {
        code = 6;
    } else if (e instanceof SQLiteFullException) {
        code = 7;
    } else if (e instanceof SQLiteDiskIOException) {
        code = 8;
    } else if (e instanceof SQLiteException) {
        code = 9;
    } else if (e instanceof OperationApplicationException) {
        code = 10;
    } else {
        reply.writeException(e);
        Log.e(TAG, ""Writing exception to parcel"", e);
        return;
    }
    reply.writeInt(code);
    reply.writeString(e.getMessage());
    if (logException) {
        Log.e(TAG, ""Writing exception to parcel"", e);
    }
}","{
    int code = 0;
    boolean logException = true;
    if (e instanceof FileNotFoundException) {
        code = 1;
        logException = false;
    } else if (e instanceof IllegalArgumentException) {
        code = 2;
    } else if (e instanceof UnsupportedOperationException) {
        code = 3;
    } else if (e instanceof SQLiteAbortException) {
        code = 4;
    } else if (e instanceof SQLiteConstraintException) {
        code = 5;
    } else if (e instanceof SQLiteDatabaseCorruptException) {
        code = 6;
    } else if (e instanceof SQLiteFullException) {
        code = 7;
    } else if (e instanceof SQLiteDiskIOException) {
        code = 8;
    } else if (e instanceof SQLiteException) {
        code = 9;
    } else if (e instanceof OperationApplicationException) {
        code = 10;
    } else if (e instanceof OperationCanceledException) {
        code = 11;
        logException = false;
    } else {
        reply.writeException(e);
        Log.e(TAG, ""Writing exception to parcel"", e);
        return;
    }
    reply.writeInt(code);
    reply.writeString(e.getMessage());
    if (logException) {
        Log.e(TAG, ""Writing exception to parcel"", e);
    }
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * exception will be re-thrown by the function in another process
 * @param reply Parcel to write to
 * @param e The Exception to be written.
 * @see Parcel#writeNoException
 * @see Parcel#writeException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * exception will be re-thrown by the function in another process
 * @param reply Parcel to write to
 * @param e The Exception to be written.
 * @see Parcel#writeNoException
 * @see Parcel#writeException
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new branch (else if (e instanceof OperationCanceledException)) is added to handle a new exception type, which set variable 'code' to different values. Thus, type '4' change is detected.","Even though the implementation is changed, the change doesn't impact the behavior of the method and potential results it provides. No new return statements are added or removed, and no new exceptions are thrown, thus it shouldn't cause any compatibility issues, type '0' for CI."
1041,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,15,16,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,0,"{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetIntMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
        Log.d(""PropertyValuesHolder"", ""Can't find native method using JNI, use reflection"" + e);
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetIntMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The implementation of handling NoSuchMethodError exception was changed from logging a message into nothing, so the change type is 2. Moreover, a comment was added, which is a type 4 change.","The change in exception handling - logging in early version and doing nothing in late version - potentially leads to a different behavior. Based on Rule 3, any code change leading to potential different behavior can be classified as a CI. Therefore, the CI is of type 2."
1042,<android.webkit.CallbackProxy: boolean uiOverrideKeyEvent(KeyEvent)>,15,16,<android.webkit.CallbackProxy: boolean uiOverrideKeyEvent(KeyEvent)>,<android.webkit.CallbackProxy: boolean uiOverrideKeyEvent(KeyEvent)>,0,"{
    if (mWebViewClient != null) {
        return mWebViewClient.shouldOverrideKeyEvent(mWebView, event);
    }
    return false;
}","{
    if (mWebViewClient != null) {
        return mWebViewClient.shouldOverrideKeyEvent(mWebView.getWebView(), event);
    }
    return false;
}",1,"/**
 * Called by UI side.
 */
","/**
 * Called by UI side.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method call of mWebView.getWebView() is introduced in the late version, so the code change type is 5.","The introduction of mWebView.getWebView() may lead to different results returned by shouldOverrideKeyEvent(), thus causing potential different return values, and the Compatibility Issue type is 1."
1043,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>",15,16,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>","<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>",0,"{
    return mContentProvider.openFile(url, mode);
}","{
    try {
        return mContentProvider.openFile(url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"Two new statements have been introduced inside an exception handling block, so the code change type is 2,4.","The newly introduced exception handling might cause the late version API to throw a different exception, so the CI type is 2."
1045,"<android.server.BluetoothService: boolean notifyIncomingConnection(String,boolean)>",15,16,"<android.server.BluetoothService: boolean notifyIncomingConnection(String,boolean)>","<android.server.BluetoothService: boolean notifyIncomingConnection(String,boolean)>",0,"{
    BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
    if (state != null) {
        Message msg = new Message();
        if (rejected) {
            if (mA2dpService.getPriority(getRemoteDevice(address)) >= BluetoothProfile.PRIORITY_ON) {
                msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
                msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;
                state.sendMessageDelayed(msg, BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
            }
        } else {
            msg.what = BluetoothDeviceProfileState.CONNECT_HFP_INCOMING;
            state.sendMessage(msg);
        }
        return true;
    }
    return false;
}","{
    synchronized (this) {
        if (!mAllowConnect) {
            Log.d(TAG, ""Not allowing incoming connection because of temporary BT on state."");
            return false;
        }
    }
    BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
    if (state != null) {
        Message msg = new Message();
        if (rejected) {
            if (mA2dpService.getPriority(getRemoteDevice(address)) >= BluetoothProfile.PRIORITY_ON) {
                msg.what = BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES;
                msg.arg1 = BluetoothDeviceProfileState.CONNECT_A2DP_OUTGOING;
                state.sendMessageDelayed(msg, BluetoothDeviceProfileState.CONNECT_OTHER_PROFILES_DELAY);
            }
        } else {
            msg.what = BluetoothDeviceProfileState.CONNECT_HFP_INCOMING;
            state.sendMessage(msg);
        }
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"A new control statement 'synchronized (this)' is added  in the beginning and impacted the return values, so the code change type is 3,1.","As the addition of the 'synchronized (this)' may cause the API to return false in scenarios where it would have not in the earlier version (when 'mAllowConnect' is false). This can lead to a compatibility issue. So, the CI type is 1."
1046,"<android.speech.tts.TextToSpeech.Connection: void onServiceConnected(ComponentName,IBinder)>",15,16,"<android.speech.tts.TextToSpeech.Connection: void onServiceConnected(ComponentName,IBinder)>","<android.speech.tts.TextToSpeech.Connection: void onServiceConnected(ComponentName,IBinder)>",0,"{
    Log.i(TAG, ""Connected to "" + name);
    synchronized (mStartLock) {
        if (mServiceConnection != null) {
            // Disconnect any previous service connection
            mServiceConnection.disconnect();
        }
        mServiceConnection = this;
        mService = ITextToSpeechService.Stub.asInterface(service);
        try {
            mService.setCallback(getPackageName(), mCallback);
            dispatchOnInit(SUCCESS);
        } catch (RemoteException re) {
            Log.e(TAG, ""Error connecting to service, setCallback() failed"");
            dispatchOnInit(ERROR);
        }
    }
}","{
    Log.i(TAG, ""Connected to "" + name);
    synchronized (mStartLock) {
        if (mServiceConnection != null) {
            // Disconnect any previous service connection
            mServiceConnection.disconnect();
        }
        mServiceConnection = this;
        mService = ITextToSpeechService.Stub.asInterface(service);
        try {
            mService.setCallback(getCallerIdentity(), mCallback);
            dispatchOnInit(SUCCESS);
        } catch (RemoteException re) {
            Log.e(TAG, ""Error connecting to service, setCallback() failed"");
            dispatchOnInit(ERROR);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,There's a change in one of the parameters of the method mService.setCallback(). The parameter has changed from getPackageName() to getCallerIdentity(). This is classified as Other statement changed (4) as one of the method invocation statements changed and Dependent API changed (5) as the method getPackageName() is replaced with getCallerIdentity().,"There's no compatibility issue (CI) detected. The change in the method parameter does not affect the functionality of the API, it won't lead to the API returning a different value or throwing a different exception."
1048,<android.webkit.WebView: int computeVerticalScrollOffset()>,15,16,<android.webkit.WebView: int computeVerticalScrollOffset()>,<android.webkit.WebView: int computeVerticalScrollOffset()>,0,"{
    return Math.max(mScrollY - getTitleHeight(), 0);
}","{
    return mProvider.getScrollDelegate().computeVerticalScrollOffset();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'Math.max(mScrollY - getTitleHeight(), 0)' to 'mProvider.getScrollDelegate().computeVerticalScrollOffset()', and this change is based on the change in the dependent method getScrollDelegate(), so the code change type is 1,5.","The change in the return statement could potentially make the API return a different value, so the CI type is 1."
1049,"<android.view.GLES20Canvas: void drawCircle(float,float,float,Paint)>",15,16,"<android.view.GLES20Canvas: void drawCircle(float,float,float,Paint)>","<android.view.GLES20Canvas: void drawCircle(float,float,float,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    nDrawCircle(mRenderer, cx, cy, radius, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawCircle(mRenderer, cx, cy, radius, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",0,"The control statements (try-finally) have been introduced, and an additional modifier (MODIFIER_SHADER | MODIFIER_COLOR_FILTER) is added to the setupModifiers method, so the code change type is 2,3.","Although there is change in the handling of exceptions and control dependencies, this change doesn't affect the behaviour of the method because it does not change the returned value or exceptions thrown by the API. Therefore, there are no detectable Compatibility Issues."
1050,<android.view.InputDevice: String toString()>,15,16,<android.view.InputDevice: String toString()>,<android.view.InputDevice: String toString()>,0,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Key Character Map: "").append(mKeyCharacterMapFile).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Several string appending operations have been added or removed, like ""Descriptor"", ""Generation"", ""Location"" were added and ""Key Character Map"" was removed. Plus, the return value, description.toString(), is affected accordingly. Therefore, the change includes both return statement and other type statement change, so the change type is 1,4.","Due to the changes in string appending operations, the return value, which is a string, could exhibit different content between the early and late version. Therefore, the compatibility issue due to potential different return values exists. Thus, the CI type is 1."
1051,"<android.content.Intent: Intent createChooser(Intent,CharSequence)>",15,16,"<android.content.Intent: Intent createChooser(Intent,CharSequence)>","<android.content.Intent: Intent createChooser(Intent,CharSequence)>",0,"{
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_INTENT, target);
    if (title != null) {
        intent.putExtra(EXTRA_TITLE, title);
    }
    return intent;
}","{
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_INTENT, target);
    if (title != null) {
        intent.putExtra(EXTRA_TITLE, title);
    }
    // Migrate any clip data and flags from target.
    int permFlags = target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);
    if (permFlags != 0) {
        ClipData targetClipData = target.getClipData();
        if (targetClipData == null && target.getData() != null) {
            ClipData.Item item = new ClipData.Item(target.getData());
            String[] mimeTypes;
            if (target.getType() != null) {
                mimeTypes = new String[] { target.getType() };
            } else {
                mimeTypes = new String[] {};
            }
            targetClipData = new ClipData(null, mimeTypes, item);
        }
        if (targetClipData != null) {
            intent.setClipData(targetClipData);
            intent.addFlags(permFlags);
        }
    }
    return intent;
}",1,"/**
 * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
 *
 * @param target The Intent that the user will be selecting an activity
 * to perform.
 * @param title Optional title that will be displayed in the chooser.
 * @return Return a new Intent object that you can hand to
 * {@link Context#startActivity(Intent) Context.startActivity()} and
 * related methods.
 */
","/**
 * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
 *
 * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
 * target intent, also optionally supplying a title.  If the target
 * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
 * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
 * set in the returned chooser intent, with its ClipData set appropriately:
 * either a direct reflection of {@link #getClipData()} if that is non-null,
 * or a new ClipData build from {@link #getData()}.
 *
 * @param target The Intent that the user will be selecting an activity
 * to perform.
 * @param title Optional title that will be displayed in the chooser.
 * @return Return a new Intent object that you can hand to
 * {@link Context#startActivity(Intent) Context.startActivity()} and
 * related methods.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Several new lines of code have been inserted into the late version, including variable definitions, control statements (e.g. 'if' conditions), and methods for performing operations on variables (e.g. intent.setClipData(targetClipData)). Therefore, the code change type is 1 (since the value of the returned 'intent' could differ due to the new operations), 3 (due to the introduced control 'if' statement), and 4 (owing to the new variable assignments and method calls).","The new lines of code may cause the returned 'intent' to have different properties and/or to encompass more data in the late version. As a result, the API could potentially return a different output, meaning that the CI type is 1."
1052,<android.webkit.WebSettings: boolean getLoadWithOverviewMode()>,15,16,<android.webkit.WebSettings: boolean getLoadWithOverviewMode()>,<android.webkit.WebSettings: boolean getLoadWithOverviewMode()>,0,"{
    return mLoadWithOverviewMode;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if this WebView loads page with overview mode
 */
","/**
 * Gets whether this WebView loads pages with overview mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The origin return statement has been replaced by a throw exception statement, therefore the code change type is 1,2.","The replacement of the original return statement with an exception handling, will definitely lead to not only different return values, but also different exceptions thrown, hence the CI type is 1,2."
1053,<android.hardware.SensorManager: void unregisterListener(SensorEventListener)>,15,16,<android.hardware.SensorManager: void unregisterListener(SensorEventListener)>,<android.hardware.SensorManager: void unregisterListener(SensorEventListener)>,0,"{
    unregisterListener((Object) listener);
}","{
    if (listener == null) {
        return;
    }
    unregisterListenerImpl(listener, null);
}",1,"/**
 * Unregisters a listener for all sensors.
 *
 * @param listener
 * a SensorListener object
 *
 * @see #unregisterListener(SensorEventListener, Sensor)
 * @see #registerListener(SensorEventListener, Sensor, int)
 */
","/**
 * Unregisters a listener for all sensors.
 *
 * @param listener
 * a SensorListener object
 *
 * @see #unregisterListener(SensorEventListener, Sensor)
 * @see #registerListener(SensorEventListener, Sensor, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","There is an additional ""if"" statement checking if the listener is null and a 'return' statement has been introduced. Also, the method call has changed from 'unregisterListener' to 'unregisterListenerImpl', so the number of parameters has changed from 1 to 2. Therefore, the code change types are 1,3,4.","The introduction of the 'return' statement can potentially make the API return earlier and skip the remaining method call. If the 'listener' is null, the early version of this function would still execute 'unregisterListener', while the late version won't. Meanwhile, the change from calling 'unregisterListener' to 'unregisterListenerImpl' could affect the function behavior, possibly causing exceptions under certain circumstances. Therefore, the CI type is both 1 and 2."
1054,<android.view.ViewTreeObserver: void removeGlobalOnLayoutListener(OnGlobalLayoutListener)>,15,16,<android.view.ViewTreeObserver: void removeGlobalOnLayoutListener(OnGlobalLayoutListener)>,<android.view.ViewTreeObserver: void removeGlobalOnLayoutListener(OnGlobalLayoutListener)>,0,"{
    checkIsAlive();
    if (mOnGlobalLayoutListeners == null) {
        return;
    }
    mOnGlobalLayoutListeners.remove(victim);
}","{
    removeOnGlobalLayoutListener(victim);
}",1,"/**
 * Remove a previously installed global layout callback
 *
 * @param victim The callback to remove
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 *
 * @see #addOnGlobalLayoutListener(OnGlobalLayoutListener)
 */
","/**
 * Remove a previously installed global layout callback
 *
 * @param victim The callback to remove
 *
 * @throws IllegalStateException If {@link #isAlive()} returns false
 *
 * @deprecated Use #removeOnGlobalLayoutListener instead
 *
 * @see #addOnGlobalLayoutListener(OnGlobalLayoutListener)
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version, the API completely changes its implementation. It now directly calls removeOnGlobalLayoutListener(victim) instead of doing a series of operations like in the early version. So, change types include 1 - return statement changed and 4 - other statements changed.","The complete change of the method implementation could lead to potentially different return values, which is a compatibility issue under class 1 -  Compatibility Issue caused by potential different return values or types."
1056,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",15,16,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>","<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",0,"{
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    if (end == start && tbstart == tbend) {
        return this;
    }
    if (end == start || tbstart == tbend) {
        change(start, end, tb, tbstart, tbend);
    } else {
        int selstart = Selection.getSelectionStart(this);
        int selend = Selection.getSelectionEnd(this);
        // XXX just make the span fixups in change() do the right thing
        // instead of this madness!
        checkRange(""replace"", start, end);
        moveGapTo(end);
        TextWatcher[] recipients;
        int origlen = end - start;
        recipients = sendTextWillChange(start, origlen, tbend - tbstart);
        if (mGapLength < 2)
            resizeFor(length() + 1);
        for (int i = mSpanCount - 1; i >= 0; i--) {
            if (mSpanStarts[i] == mGapStart)
                mSpanStarts[i]++;
            if (mSpanEnds[i] == mGapStart)
                mSpanEnds[i]++;
        }
        mText[mGapStart] = ' ';
        mGapStart++;
        mGapLength--;
        if (mGapLength < 1) {
            new Exception(""mGapLength < 1"").printStackTrace();
        }
        int inserted = change(false, start + 1, start + 1, tb, tbstart, tbend);
        change(false, start, start + 1, """", 0, 0);
        change(false, start + inserted, start + inserted + origlen, """", 0, 0);
        /*
             * Special case to keep the cursor in the same position
             * if it was somewhere in the middle of the replaced region.
             * If it was at the start or the end or crossing the whole
             * replacement, it should already be where it belongs.
             * TODO: Is there some more general mechanism that could
             * accomplish this?
             */
        if (selstart > start && selstart < end) {
            long off = selstart - start;
            off = off * inserted / (end - start);
            selstart = (int) off + start;
            setSpan(false, Selection.SELECTION_START, selstart, selstart, Spanned.SPAN_POINT_POINT);
        }
        if (selend > start && selend < end) {
            long off = selend - start;
            off = off * inserted / (end - start);
            selend = (int) off + start;
            setSpan(false, Selection.SELECTION_END, selend, selend, Spanned.SPAN_POINT_POINT);
        }
        sendTextChange(recipients, start, origlen, inserted);
        sendTextHasChanged(recipients);
    }
    return this;
}","{
    checkRange(""replace"", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        if (selectionStart > start && selectionStart < end) {
            final int offset = (selectionStart - start) * newLen / origLen;
            selectionStart = start + offset;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final int offset = (selectionEnd - start) * newLen / origLen;
            selectionEnd = start + offset;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}",1,"// Documentation from interface
","// Documentation from interface
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control flow statements have been altered from the early version to the late version implementation of this method. There are changes regarding 'for' loop and 'if' statements. Moreover, adjustments have been made to the sequence and call of certain variables/methods. Hence, code change types 3 and 4 apply.","The alterations in control flow and other statements might affect the outcome of the API, especially since it changes how the input parameters are managed and might potentially return different results. Hence, this can cause a Compatibility Issue of type 1."
1058,<android.webkit.WebView: boolean dispatchKeyEvent(KeyEvent)>,15,16,<android.webkit.WebView: boolean dispatchKeyEvent(KeyEvent)>,<android.webkit.WebView: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    switch(event.getAction()) {
        case KeyEvent.ACTION_DOWN:
            mKeysPressed.add(Integer.valueOf(event.getKeyCode()));
            break;
        case KeyEvent.ACTION_MULTIPLE:
            // Always accept the action.
            break;
        case KeyEvent.ACTION_UP:
            int location = mKeysPressed.indexOf(Integer.valueOf(event.getKeyCode()));
            if (location == -1) {
                // handle the key up.
                return false;
            } else {
                // We did receive the key down.  Handle the key up, and
                // remove it from our pressed keys.
                mKeysPressed.remove(location);
            }
            break;
        default:
            // action is added to KeyEvent.
            break;
    }
    if (inEditingMode() && mWebTextView.isFocused()) {
        // not currently have a bounds.
        return mWebTextView.dispatchKeyEvent(event);
    } else {
        return super.dispatchKeyEvent(event);
    }
}","{
    return mProvider.getViewDelegate().dispatchKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The early version implementation has various control statements and action handling inside 'switch' block. But in the late version, it directly returns the result of mProvider.getViewDelegate().dispatchKeyEvent(event). Both the return statement and the dependent APIs have changed, so the code change type is 1,5.","As the return statement has been changed significantly, the late version can potentially return a different value when compared to the early version. Therefore, the CI type is 1."
1059,<android.webkit.WebSettings: boolean getLightTouchEnabled()>,15,16,<android.webkit.WebSettings: boolean getLightTouchEnabled()>,<android.webkit.WebSettings: boolean getLightTouchEnabled()>,0,"{
    return mLightTouchEnabled;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns true if light touches are enabled.
 */
","/**
 * Gets whether light touches are enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been replaced with a throw statement, so the code change type is 1,2.","The change of return statement to a exception throwing statement will make the API potentially return a different value or type and throw a different exception. So, the CI type is 1,2."
1061,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,15,16,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,0,"{
    if (context == null) {
        throw new IllegalArgumentException(""context cannot be null"");
    }
    context = context.getApplicationContext();
    /* use getSystemService() instead of just instantiating to take
         * advantage of the context's cached NfcManager & NfcAdapter */
    NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
    if (manager == null) {
        // NFC not available
        return null;
    }
    return manager.getDefaultAdapter();
}","{
    if (context == null) {
        throw new IllegalArgumentException(""context cannot be null"");
    }
    context = context.getApplicationContext();
    if (context == null) {
        throw new IllegalArgumentException(""context not associated with any application (using a mock context?)"");
    }
    /* use getSystemService() for consistency */
    NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
    if (manager == null) {
        // NFC not available
        return null;
    }
    return manager.getDefaultAdapter();
}",1,"/**
 * Helper to get the default NFC Adapter.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 * <p>
 * This helper is the equivalent of:
 * <pre>{@code
 * NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
 * NfcAdapter adapter = manager.getDefaultAdapter();
 * }</pre>
 * @param context the calling application's context
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 */
","/**
 * Helper to get the default NFC Adapter.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 * <p>
 * This helper is the equivalent of:
 * <pre>
 * NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
 * NfcAdapter adapter = manager.getDefaultAdapter();</pre>
 * @param context the calling application's context
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An additional exception throwing statement is introduced in the late version implementation, and also the comments after ""getSystemService()"" are changed. Thus, the types of code changes are 2, 3.","The additional possibility of throwing an IllegalArgumentException in the late version causes a behavioural difference. Therefore, theres is compatibility issue type of 2."
1062,<android.webkit.FindActionModeCallback: void findAll()>,15,16,<android.webkit.FindActionModeCallback: void findAll()>,<android.webkit.FindActionModeCallback: void findAll()>,0,"{
    if (mWebView == null) {
        throw new AssertionError(""No WebView for FindActionModeCallback::findAll"");
    }
    CharSequence find = mEditText.getText();
    if (0 == find.length()) {
        mWebView.clearMatches();
        mMatches.setVisibility(View.GONE);
        mMatchesFound = false;
    } else {
        mMatchesFound = true;
        mMatches.setVisibility(View.VISIBLE);
        mNumberOfMatches = mWebView.findAll(find.toString());
        if (0 == mNumberOfMatches) {
            mMatches.setText(mResources.getString(com.android.internal.R.string.no_matches));
        } else {
            updateMatchesString();
        }
    }
}","{
    if (mWebView == null) {
        throw new AssertionError(""No WebView for FindActionModeCallback::findAll"");
    }
    CharSequence find = mEditText.getText();
    if (0 == find.length()) {
        mWebView.clearMatches();
        mMatches.setVisibility(View.GONE);
        mMatchesFound = false;
        mWebView.findAll(null);
    } else {
        mMatchesFound = true;
        mMatches.setVisibility(View.INVISIBLE);
        mNumberOfMatches = 0;
        mWebView.findAllAsync(find.toString());
    }
}",1,"/*
     * Highlight all the instances of the string from mEditText in mWebView.
     */
","/*
     * Highlight all the instances of the string from mEditText in mWebView.
     */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The if-else statement has been updated with a visibility set to 'INVISIBLE' from 'VISIBLE', and the assignment of 'mNumberOfMatches' has been changed. The 'else' section has also introduced a new method call 'mWebView.findAllAsync(find.toString())' replacing the old method 'mWebView.findAll(find.toString())', which invokes a change in dependent API. Meanwhile, 'mWebView.findAll(null)' was introduced, indicating a change in the other statements.","These code changes could lead to different states of the object when the method is finished executing, potentially causing a change in the return of other functions of the object. Additionally, the method 'findAllAsync(find.toString())' may handle exceptions differently than 'findAll(find.toString())'. Therefore, the CI types are 1 and 2."
1065,<android.widget.CompoundButton: void setChecked(boolean)>,15,16,<android.widget.CompoundButton: void setChecked(boolean)>,<android.widget.CompoundButton: void setChecked(boolean)>,0,"{
    if (mChecked != checked) {
        mChecked = checked;
        refreshDrawableState();
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        mBroadcasting = false;
    }
}","{
    if (mChecked != checked) {
        mChecked = checked;
        refreshDrawableState();
        notifyAccessibilityStateChanged();
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        mBroadcasting = false;
    }
}",1,"/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
","/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code are inserting the notifyAccessibilityStateChanged() method, which belongs to the category 4 (Other statement changed).","This API will not return a different value of variable or throw an exception differently because of this change, therefore, there is no Compatibility Issue (CI 0)."
1068,<android.speech.tts.AudioPlaybackHandler: void quit()>,15,16,<android.speech.tts.AudioPlaybackHandler: void quit()>,<android.speech.tts.AudioPlaybackHandler: void quit()>,0,"{
    removeAllMessages();
    stop(getCurrentParams());
    mQueue.add(new ListEntry(SHUTDOWN, null, HIGH_PRIORITY));
}","{
    removeAllMessages();
    stop(mCurrentWorkItem);
    mHandlerThread.interrupt();
}",1,"/**
 * Shut down the audio playback thread.
 */
","/**
 * Shut down the audio playback thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method parameters in the 'stop()' function has changed and also the statement 'mHandlerThread.interrupt()' has been added as a replacement of 'mQueue.add(new ListEntry(SHUTDOWN, null, HIGH_PRIORITY))', so the code change type is 1,4.","The behavior of the method gets affected due to the introduction of new return values by changing the parameters in 'stop()' function and removing 'mQueue.add(new ListEntry(SHUTDOWN, null, HIGH_PRIORITY))' and introducing 'mHandlerThread.interrupt()', leading to a potential compatibility issue. So, the CI type is 1."
1071,<android.app.ActivityManager: int getLauncherLargeIconSize()>,15,16,<android.app.ActivityManager: int getLauncherLargeIconSize()>,<android.app.ActivityManager: int getLauncherLargeIconSize()>,0,"{
    final Resources res = mContext.getResources();
    final int size = res.getDimensionPixelSize(android.R.dimen.app_icon_size);
    if ((res.getConfiguration().screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) != Configuration.SCREENLAYOUT_SIZE_XLARGE) {
        return size;
    }
    final int density = res.getDisplayMetrics().densityDpi;
    switch(density) {
        case DisplayMetrics.DENSITY_LOW:
            return (size * DisplayMetrics.DENSITY_MEDIUM) / DisplayMetrics.DENSITY_LOW;
        case DisplayMetrics.DENSITY_MEDIUM:
            return (size * DisplayMetrics.DENSITY_HIGH) / DisplayMetrics.DENSITY_MEDIUM;
        case DisplayMetrics.DENSITY_HIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_XHIGH:
            return (size * DisplayMetrics.DENSITY_MEDIUM * 2) / DisplayMetrics.DENSITY_XHIGH;
        default:
            return size;
    }
}","{
    final Resources res = mContext.getResources();
    final int size = res.getDimensionPixelSize(android.R.dimen.app_icon_size);
    final int sw = res.getConfiguration().smallestScreenWidthDp;
    if (sw < 600) {
        // Smaller than approx 7"" tablets, use the regular icon size.
        return size;
    }
    final int density = res.getDisplayMetrics().densityDpi;
    switch(density) {
        case DisplayMetrics.DENSITY_LOW:
            return (size * DisplayMetrics.DENSITY_MEDIUM) / DisplayMetrics.DENSITY_LOW;
        case DisplayMetrics.DENSITY_MEDIUM:
            return (size * DisplayMetrics.DENSITY_HIGH) / DisplayMetrics.DENSITY_MEDIUM;
        case DisplayMetrics.DENSITY_TV:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_HIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_XHIGH:
            return (size * DisplayMetrics.DENSITY_XXHIGH) / DisplayMetrics.DENSITY_XHIGH;
        case DisplayMetrics.DENSITY_XXHIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH * 2) / DisplayMetrics.DENSITY_XXHIGH;
        default:
            // abnormal value that is a reasonable scaling of it.
            return (int) ((size * 1.5f) + .5f);
    }
}",1,"/**
 * Get the preferred launcher icon size. This is used when custom drawables
 * are created (e.g., for shortcuts).
 *
 * @return dimensions of square icons in terms of pixels
 */
","/**
 * Get the preferred launcher icon size. This is used when custom drawables
 * are created (e.g., for shortcuts).
 *
 * @return dimensions of square icons in terms of pixels
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The 'if' condition and a 'switch' case label has been updated and the returned variable in the default switch case has been updated as well, so the code change type is 1,3.","Different return statements in multiple branches could potentially make the method return a different value between two versions, so the CI type is 1."
1072,<android.app.Instrumentation: void sendStringSync(String)>,15,16,<android.app.Instrumentation: void sendStringSync(String)>,<android.app.Instrumentation: void sendStringSync(String)>,0,"{
    if (text == null) {
        return;
    }
    KeyCharacterMap keyCharacterMap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
    KeyEvent[] events = keyCharacterMap.getEvents(text.toCharArray());
    if (events != null) {
        for (int i = 0; i < events.length; i++) {
            sendKeySync(events[i]);
        }
    }
}","{
    if (text == null) {
        return;
    }
    KeyCharacterMap keyCharacterMap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
    KeyEvent[] events = keyCharacterMap.getEvents(text.toCharArray());
    if (events != null) {
        for (int i = 0; i < events.length; i++) {
            // We have to change the time of an event before injecting it because
            // all KeyEvents returned by KeyCharacterMap.getEvents() have the same
            // time stamp and the system rejects too old events. Hence, it is
            // possible for an event to become stale before it is injected if it
            // takes too long to inject the preceding ones.
            sendKeySync(KeyEvent.changeTimeRepeat(events[i], SystemClock.uptimeMillis(), 0));
        }
    }
}",1,"/**
 * Sends the key events corresponding to the text to the app being
 * instrumented.
 *
 * @param text The text to be sent.
 */
","/**
 * Sends the key events corresponding to the text to the app being
 * instrumented.
 *
 * @param text The text to be sent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"In the method ""sendStringSync"", the only change is the added time modification of the key event before sending it, which comes under category 4 ""Other Changes"".","The modification of the timestamp of the KeyEvent could potentially lead to different outcomes when the method is executed, which could cause unexpected results or issues (especially in time-related processing), hence, the change could lead to compatibility issues of category 1."
1073,<android.webkit.WebSettings: boolean getJavaScriptEnabled()>,15,16,<android.webkit.WebSettings: boolean getJavaScriptEnabled()>,<android.webkit.WebSettings: boolean getJavaScriptEnabled()>,0,"{
    return mJavaScriptEnabled;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Return true if javascript is enabled. <b>Note: The default is false.</b>
 * @return True if javascript is enabled.
 */
","/**
 * Gets whether JavaScript is enabled.
 *
 * @return true if JavaScript is enabled
 * @see #setJavaScriptEnabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The return statement has been removed and an exception statement has been introduced in the Late_Implementation, therefore the code change type is 1,2.","The early version method implementation returns a value, whereas the later version implementation throws an exception. Thus, the Compatibility Issue (CI) type is 1,2."
1075,"<android.widget.LinearLayout: void measureVertical(int,int)>",15,16,"<android.widget.LinearLayout: void measureVertical(int,int)>","<android.widget.LinearLayout: void measureVertical(int,int)>",0,"{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && widthMode == MeasureSpec.UNSPECIFIED) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}","{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}",1,"/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
","/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
1076,"<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>",15,16,"<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>","<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>",0,"{
    // make sure the input args are non-null/non-zero
    validateArgumentIsNonEmpty(""title"", title);
    validateArgumentIsNonEmpty(""description"", description);
    validateArgumentIsNonEmpty(""path"", path);
    validateArgumentIsNonEmpty(""mimeType"", mimeType);
    if (length <= 0) {
        throw new IllegalArgumentException("" invalid value for param: totalBytes"");
    }
    // if there is already an entry with the given path name in downloads.db, return its id
    Request request = new Request(NON_DOWNLOADMANAGER_DOWNLOAD).setTitle(title).setDescription(description).setMimeType(mimeType);
    ContentValues values = request.toContentValues(null);
    values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);
    values.put(Downloads.Impl._DATA, path);
    values.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);
    values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, length);
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (isMediaScannerScannable) ? Request.SCANNABLE_VALUE_YES : Request.SCANNABLE_VALUE_NO);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, (showNotification) ? Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION : Request.VISIBILITY_HIDDEN);
    Uri downloadUri = mResolver.insert(Downloads.Impl.CONTENT_URI, values);
    if (downloadUri == null) {
        return -1;
    }
    return Long.parseLong(downloadUri.getLastPathSegment());
}","{
    // make sure the input args are non-null/non-zero
    validateArgumentIsNonEmpty(""title"", title);
    validateArgumentIsNonEmpty(""description"", description);
    validateArgumentIsNonEmpty(""path"", path);
    validateArgumentIsNonEmpty(""mimeType"", mimeType);
    if (length < 0) {
        throw new IllegalArgumentException("" invalid value for param: totalBytes"");
    }
    // if there is already an entry with the given path name in downloads.db, return its id
    Request request = new Request(NON_DOWNLOADMANAGER_DOWNLOAD).setTitle(title).setDescription(description).setMimeType(mimeType);
    ContentValues values = request.toContentValues(null);
    values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);
    values.put(Downloads.Impl._DATA, path);
    values.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);
    values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, length);
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (isMediaScannerScannable) ? Request.SCANNABLE_VALUE_YES : Request.SCANNABLE_VALUE_NO);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, (showNotification) ? Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION : Request.VISIBILITY_HIDDEN);
    Uri downloadUri = mResolver.insert(Downloads.Impl.CONTENT_URI, values);
    if (downloadUri == null) {
        return -1;
    }
    return Long.parseLong(downloadUri.getLastPathSegment());
}",1,"/**
 * Adds a file to the downloads database system, so it could appear in Downloads App
 * (and thus become eligible for management by the Downloads App).
 * <p>
 * It is helpful to make the file scannable by MediaScanner by setting the param
 * isMediaScannerScannable to true. It makes the file visible in media managing
 * applications such as Gallery App, which could be a useful purpose of using this API.
 *
 * @param title the title that would appear for this file in Downloads App.
 * @param description the description that would appear for this file in Downloads App.
 * @param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
 * scanned by MediaScanner appear in the applications used to view media (for example,
 * Gallery app).
 * @param mimeType mimetype of the file.
 * @param path absolute pathname to the file. The file should be world-readable, so that it can
 * be managed by the Downloads App and any other app that is used to read it (for example,
 * Gallery app to display the file, if the file contents represent a video/image).
 * @param length length of the downloaded file
 * @param showNotification true if a notification is to be sent, false otherwise
 * @return  an ID for the download entry added to the downloads app, unique across the system
 * This ID is used to make future calls related to this download.
 */
","/**
 * Adds a file to the downloads database system, so it could appear in Downloads App
 * (and thus become eligible for management by the Downloads App).
 * <p>
 * It is helpful to make the file scannable by MediaScanner by setting the param
 * isMediaScannerScannable to true. It makes the file visible in media managing
 * applications such as Gallery App, which could be a useful purpose of using this API.
 *
 * @param title the title that would appear for this file in Downloads App.
 * @param description the description that would appear for this file in Downloads App.
 * @param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
 * scanned by MediaScanner appear in the applications used to view media (for example,
 * Gallery app).
 * @param mimeType mimetype of the file.
 * @param path absolute pathname to the file. The file should be world-readable, so that it can
 * be managed by the Downloads App and any other app that is used to read it (for example,
 * Gallery app to display the file, if the file contents represent a video/image).
 * @param length length of the downloaded file
 * @param showNotification true if a notification is to be sent, false otherwise
 * @return  an ID for the download entry added to the downloads app, unique across the system
 * This ID is used to make future calls related to this download.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","One condition of the throw statement has been changed: it used to throw the exception when `length <= 0`, but in the later version, it throws when `length < 0`. So, this represents changes in exception handling and control dependency, hence the change type is 2,3.","Since the condition for throwing an exception is altered, the method can potentially throw a different exception in the later version. Also, the change in control condition may affect the return value of the function if 'length' equals 0, which means it can return different values. Therefore, the CI types are 1,2."
1077,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentServices(Intent,int)>",15,16,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentServices(Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentServices(Intent,int)>",0,"{
    try {
        return mPM.queryIntentServices(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.queryIntentServices(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed with the dependent API 'mPM.queryIntentServices' now having an additional parameter 'UserId.myUserId()', so the code change type is 1,5.","The change of return statement will make the API potentially return different values because the behavior of 'mPM.queryIntentServices' may be different due to the extra parameter, so the CI type is 1."
1078,<android.view.KeyCharacterMap: KeyEvent[] getEvents(char[])>,15,16,<android.view.KeyCharacterMap: KeyEvent[] getEvents(char[])>,<android.view.KeyCharacterMap: KeyEvent[] getEvents(char[])>,0,"{
    if (chars == null) {
        throw new IllegalArgumentException(""chars must not be null."");
    }
    return nativeGetEvents(mPtr, mDeviceId, chars);
}","{
    if (chars == null) {
        throw new IllegalArgumentException(""chars must not be null."");
    }
    return nativeGetEvents(mPtr, chars);
}",1,"/**
 * Get an array of KeyEvent objects that if put into the input stream
 * could plausibly generate the provided sequence of characters.  It is
 * not guaranteed that the sequence is the only way to generate these
 * events or that it is optimal.
 * <p>
 * This function is primarily offered for instrumentation and testing purposes.
 * It may fail to map characters to key codes.  In particular, the key character
 * map for the {@link #BUILT_IN_KEYBOARD built-in keyboard} device id may be empty.
 * Consider using the key character map associated with the
 * {@link #VIRTUAL_KEYBOARD virtual keyboard} device id instead.
 * </p><p>
 * For robust text entry, do not use this function.  Instead construct a
 * {@link KeyEvent} with action code {@link KeyEvent#ACTION_MULTIPLE} that contains
 * the desired string using {@link KeyEvent#KeyEvent(long, String, int, int)}.
 * </p>
 *
 * @param chars The sequence of characters to generate.
 * @return An array of {@link KeyEvent} objects, or null if the given char array
 * can not be generated using the current key character map.
 */
","/**
 * Get an array of KeyEvent objects that if put into the input stream
 * could plausibly generate the provided sequence of characters.  It is
 * not guaranteed that the sequence is the only way to generate these
 * events or that it is optimal.
 * <p>
 * This function is primarily offered for instrumentation and testing purposes.
 * It may fail to map characters to key codes.  In particular, the key character
 * map for the {@link #BUILT_IN_KEYBOARD built-in keyboard} device id may be empty.
 * Consider using the key character map associated with the
 * {@link #VIRTUAL_KEYBOARD virtual keyboard} device id instead.
 * </p><p>
 * For robust text entry, do not use this function.  Instead construct a
 * {@link KeyEvent} with action code {@link KeyEvent#ACTION_MULTIPLE} that contains
 * the desired string using {@link KeyEvent#KeyEvent(long, String, int, int)}.
 * </p>
 *
 * @param chars The sequence of characters to generate.
 * @return An array of {@link KeyEvent} objects, or null if the given char array
 * can not be generated using the current key character map.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The invocation of dependent API method nativeGetEvents changed from nativeGetEvents(mPtr, mDeviceId, chars) to nativeGetEvents(mPtr, chars), showing a decrease in the number of parameters, so the code change type is 5.","After changing the parameters of the method called in the return statement, the return value of the method may be altered, thus causing a potential compatibility issue of returning different values which is type 1 CI."
1079,<android.content.res.Configuration: String toString()>,15,16,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    sb.append(mcc);
    sb.append(""mcc"");
    sb.append(mnc);
    sb.append(""mnc"");
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" (no locale)"");
    }
    switch(textLayoutDirection) {
        case LocaleUtil.TEXT_LAYOUT_DIRECTION_RTL_DO_NOT_USE:
            sb.append("" rtl"");
            break;
        default:
            sb.append("" layoutdir="");
            sb.append(textLayoutDirection);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    sb.append(mcc);
    sb.append(""mcc"");
    sb.append(mnc);
    sb.append(""mnc"");
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" (no locale)"");
    }
    switch(layoutDirection) {
        case View.LAYOUT_DIRECTION_LTR:
            /* ltr not interesting */
            break;
        case View.LAYOUT_DIRECTION_RTL:
            sb.append("" rtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDirection);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
1082,<android.widget.TextView: CharSequence getImeActionLabel()>,15,16,<android.widget.TextView: CharSequence getImeActionLabel()>,<android.widget.TextView: CharSequence getImeActionLabel()>,0,"{
    return mInputContentType != null ? mInputContentType.imeActionLabel : null;
}","{
    return mEditor != null && mEditor.mInputContentType != null ? mEditor.mInputContentType.imeActionLabel : null;
}",1,"/**
 * Get the IME action label previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
","/**
 * Get the IME action label previous set with {@link #setImeActionLabel}.
 *
 * @see #setImeActionLabel
 * @see android.view.inputmethod.EditorInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The main difference between the two methods is the object that the mInputContentType property is being accessed from. In the Early Implementation, it's accessed from the current object instance (this), while in the Late Implementation, it's accessed from the mEditor object. Therefore, the code change type is 4.","The difference in object from which we are accessing the mInputContentType property and subsequently the imeActionLabel property, can lead to a different value being returned. Thus, the Compatibility Issue type is 1."
1086,"<android.speech.tts.TextToSpeech: int playSilence(long,int,HashMap<String, String>)>",15,16,"<android.speech.tts.TextToSpeech: int playSilence(long,int,HashMap<String, String>)>","<android.speech.tts.TextToSpeech: int playSilence(long,int,HashMap<String, String>)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.playSilence(getPackageName(), durationInMs, queueMode, getParams(params));
        }
    }, ERROR, ""playSilence"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.playSilence(getCallerIdentity(), durationInMs, queueMode, getParams(params));
        }
    }, ERROR, ""playSilence"");
}",1,"/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 *
 * @param durationInMs The duration of the silence.
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 *
 * @param durationInMs The duration of the silence.
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The getPackageName() method call in the early version API implementation has been replaced with a getCallerIdentity() method in the late version API, resulting in the code change type being 1,5.","Because getPackageName() and getCallerIdentity() may return different results, the return value of the playSilence function may also be different between two versions, thus generating Compatibility Issue of type 1."
1088,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,15,16,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,0,"{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    Gl20Renderer.Gl20RendererEglContext managedContext = sEglContextStorage.get();
    mEglContext = managedContext != null ? managedContext.getContext() : null;
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(new Gl20Renderer.Gl20RendererEglContext(mEglContext));
    }
}","{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    ManagedEGLContext managedContext = sEglContextStorage.get();
    mEglContext = managedContext != null ? managedContext.getContext() : null;
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(createManagedContext(mEglContext));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,This change results from modification of the variable type from Gl20Renderer.Gl20RendererEglContext to ManagedEGLContext and the change of method invocation from new Gl20Renderer.Gl20RendererEglContext(mEglContext) to createManagedContext(mEglContext). These are classified as Other statement change and Dependent API change.,"Even though there has been changes, all these changes only impact the internal implementation, not the behavior of the APIs. This suggests no Compatibility Issue."
1089,"<android.view.GLES20Canvas: void drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)>",15,16,"<android.view.GLES20Canvas: void drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)>","<android.view.GLES20Canvas: void drawBitmap(int[],int,int,float,float,int,int,boolean,Paint)>",0,"{
    // Shaders are ignored when drawing bitmaps
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    final Bitmap.Config config = hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
    final Bitmap b = Bitmap.createBitmap(colors, offset, stride, width, height, config);
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, b.mNativeBitmap, b.mBuffer, x, y, nativePaint);
    b.recycle();
    if (modifier != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifier);
}","{
    if (width < 0) {
        throw new IllegalArgumentException(""width must be >= 0"");
    }
    if (height < 0) {
        throw new IllegalArgumentException(""height must be >= 0"");
    }
    if (Math.abs(stride) < width) {
        throw new IllegalArgumentException(""abs(stride) must be >= width"");
    }
    int lastScanline = offset + (height - 1) * stride;
    int length = colors.length;
    if (offset < 0 || (offset + width > length) || lastScanline < 0 || (lastScanline + width > length)) {
        throw new ArrayIndexOutOfBoundsException();
    }
    // Shaders are ignored when drawing bitmaps
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, colors, offset, stride, x, y, width, height, hasAlpha, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3","1,2","The code block has checked for the violation of the conditions in the late version which were not in the early version resulting the change in exception handling statement hence the type is 2, and the change in condition in between is resulting the change in control dependencies hence it is 3. ",The addition of exception handlers in late version changes the chances of interrupting the execution and returning a different value than expected hence the CI type is 1 based on Return statement changed and 2  based on Exception handling statement changed.
1090,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,15,16,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>,0,"{
    size = pin(size);
    if (mDefaultFixedFontSize != size) {
        mDefaultFixedFontSize = size;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the default fixed font size.
 * @param size A non-negative integer between 1 and 72.
 * Any number outside the specified range will be pinned.
 */
","/**
 * Sets the default fixed font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The 'throw new MustOverrideException()' statement has been added in the late implementation, replacing the old implementation. It implements a completely different functionality and also introduces exception handling in the code. Therefore, the code change types are 1,2,5.","The new implementation throws an exception while the old implementation does not. Besides, the return of void type method is actually the control flow of the method, which means if the method finishes without throwing an exception or not. Therefore, the compatibility issue types are 1,2."
1091,<android.webkit.WebView: void documentHasImages(Message)>,15,16,<android.webkit.WebView: void documentHasImages(Message)>,<android.webkit.WebView: void documentHasImages(Message)>,0,"{
    checkThread();
    if (response == null) {
        return;
    }
    mWebViewCore.sendMessage(EventHub.DOC_HAS_IMAGES, response);
}","{
    checkThread();
    mProvider.documentHasImages(response);
}",1,"/**
 * Query the document to see if it contains any image references. The
 * message object will be dispatched with arg1 being set to 1 if images
 * were found and 0 if the document does not reference any images.
 * @param response The message that will be dispatched with the result.
 */
","/**
 * Queries the document to see if it contains any image references. The
 * message object will be dispatched with arg1 being set to 1 if images
 * were found and 0 if the document does not reference any images.
 *
 * @param response the message that will be dispatched with the result
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been deleted and the method mWebViewCore.sendMessage(EventHub.DOC_HAS_IMAGES, response) has been replaced with mProvider.documentHasImages(response), so the code change type is 1,5.","The deletion of return statement and dependent API change could potentially lead to a different result when the method is called, so the CI type is 1."
1092,<android.server.BluetoothService: boolean prepareBluetooth()>,15,16,<android.server.BluetoothService: boolean prepareBluetooth()>,<android.server.BluetoothService: boolean prepareBluetooth()>,0,"{
    if (!setupNativeDataNative()) {
        return false;
    }
    switchConnectable(false);
    updateSdpRecords();
    return true;
}","{
    if (!setupNativeDataNative()) {
        return false;
    }
    switchConnectable(false);
    // SDP records, otherwise dbus stalls for over 30 seconds 1 out of 50 runs
    try {
        Thread.sleep(50);
    } catch (InterruptedException e) {
    }
    updateSdpRecords();
    return true;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"Delay has been added before updateSdpRecords() using Thread.sleep(50) within a try-catch block (Control dependency changed). So, the change type is 3,4.","Although new statements have been added, they don't alter the API's behavior in terms of its return values or exceptions. Therefore, no Compatibility Issue (CI) exists for this API. The CI type is 0."
1093,<android.widget.EdgeEffect: boolean draw(Canvas)>,15,16,<android.widget.EdgeEffect: boolean draw(Canvas)>,<android.widget.EdgeEffect: boolean draw(Canvas)>,0,"{
    update();
    final int edgeHeight = mEdge.getIntrinsicHeight();
    final int edgeWidth = mEdge.getIntrinsicWidth();
    final int glowHeight = mGlow.getIntrinsicHeight();
    final int glowWidth = mGlow.getIntrinsicWidth();
    mGlow.setAlpha((int) (Math.max(0, Math.min(mGlowAlpha, 1)) * 255));
    int glowBottom = (int) Math.min(glowHeight * mGlowScaleY * glowHeight / glowWidth * 0.6f, glowHeight * MAX_GLOW_HEIGHT);
    if (mWidth < mMinWidth) {
        // Center the glow and clip it.
        int glowLeft = (mWidth - mMinWidth) / 2;
        mGlow.setBounds(glowLeft, 0, mWidth - glowLeft, glowBottom);
    } else {
        // Stretch the glow to fit.
        mGlow.setBounds(0, 0, mWidth, glowBottom);
    }
    mGlow.draw(canvas);
    mEdge.setAlpha((int) (Math.max(0, Math.min(mEdgeAlpha, 1)) * 255));
    int edgeBottom = (int) (edgeHeight * mEdgeScaleY);
    if (mWidth < mMinWidth) {
        // Center the edge and clip it.
        int edgeLeft = (mWidth - mMinWidth) / 2;
        mEdge.setBounds(edgeLeft, 0, mWidth - edgeLeft, edgeBottom);
    } else {
        // Stretch the edge to fit.
        mEdge.setBounds(0, 0, mWidth, edgeBottom);
    }
    mEdge.draw(canvas);
    return mState != STATE_IDLE;
}","{
    update();
    mGlow.setAlpha((int) (Math.max(0, Math.min(mGlowAlpha, 1)) * 255));
    int glowBottom = (int) Math.min(mGlowHeight * mGlowScaleY * mGlowHeight / mGlowWidth * 0.6f, mGlowHeight * MAX_GLOW_HEIGHT);
    if (mWidth < mMinWidth) {
        // Center the glow and clip it.
        int glowLeft = (mWidth - mMinWidth) / 2;
        mGlow.setBounds(glowLeft, 0, mWidth - glowLeft, glowBottom);
    } else {
        // Stretch the glow to fit.
        mGlow.setBounds(0, 0, mWidth, glowBottom);
    }
    mGlow.draw(canvas);
    mEdge.setAlpha((int) (Math.max(0, Math.min(mEdgeAlpha, 1)) * 255));
    int edgeBottom = (int) (mEdgeHeight * mEdgeScaleY);
    if (mWidth < mMinWidth) {
        // Center the edge and clip it.
        int edgeLeft = (mWidth - mMinWidth) / 2;
        mEdge.setBounds(edgeLeft, 0, mWidth - edgeLeft, edgeBottom);
    } else {
        // Stretch the edge to fit.
        mEdge.setBounds(0, 0, mWidth, edgeBottom);
    }
    mEdge.draw(canvas);
    if (mState == STATE_RECEDE && glowBottom == 0 && edgeBottom == 0) {
        mState = STATE_IDLE;
    }
    return mState != STATE_IDLE;
}",1,"/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */
","/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code has been changed in both the control dependency and other statements. Specifically, the variable initializations have been removed and a new 'if' condition has been added therefore, the code change type is 3,4. ","Due to the added 'if' control structure, the state of mState can potentially change before the return statement, potentially causing the API to return a different value. Thus, the CI is of type 1 as a result of potential different return values."
1095,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,15,16,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,0,"{
    return mParentInputMethodManager.mActive;
}","{
    return mParentInputMethodManager.mActive && mActive;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 1",1,"The return statement in the late version has an additional condition, and the condition in the ""return"" statement. This accounts for categories of changes 3 and 1.","The additional condition in the ""return"" statement means that even under the same conditions, the return value in the late version could potentially be different from the return value in the early version. This corresponds to a CI of type 1."
1097,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",15,16,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method call `s.setNpnProtocols(mNpnProtocols);` has been added in the late version, which does not come under return statements, exception handling statements, control statements, or dependent API, thus falling under category 4: Other statement changed.","No Compatibility Issue (CI) exists in this change. The API's behavior remains the same with regard to return values and exception handling. An additional step of setting NpnProtocols doesn't change the method's primary function nor does it introduce possibilities of returning a different value or throwing a different exception. Hence, the CI type is 0."
1098,"<android.app.ApplicationPackageManager: ActivityInfo getReceiverInfo(ComponentName,int)>",15,16,"<android.app.ApplicationPackageManager: ActivityInfo getReceiverInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ActivityInfo getReceiverInfo(ComponentName,int)>",0,"{
    try {
        ActivityInfo ai = mPM.getReceiverInfo(className, flags);
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ActivityInfo ai = mPM.getReceiverInfo(className, flags, UserId.myUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call mPM.getReceiverInfo() in the return statement has added a new parameter UserId.myUserId(). Hence, the code change types are 1,5.","The method call mPM.getReceiverInfo() will potentially return a different value when calling with different arguments. So, the CI is led by potential different return values, with CI type 1."
1099,<android.os.Looper: void prepareMainLooper()>,15,16,<android.os.Looper: void prepareMainLooper()>,<android.os.Looper: void prepareMainLooper()>,0,"{
    prepare();
    setMainLooper(myLooper());
    myLooper().mQueue.mQuitAllowed = false;
}","{
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(""The main Looper has already been prepared."");
        }
        sMainLooper = myLooper();
    }
}",1,"/**
 * Initialize the current thread as a looper, marking it as an
 * application's main looper. The main looper for your application
 * is created by the Android environment, so you should never need
 * to call this function yourself.  See also: {@link #prepare()}
 */
","/**
 * Initialize the current thread as a looper, marking it as an
 * application's main looper. The main looper for your application
 * is created by the Android environment, so you should never need
 * to call this function yourself.  See also: {@link #prepare()}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","In the later version, the return types of the methods 'prepare()' and 'setMainLooper(myLooper())' have changed as both these methods have been altered with a new implementation (prepare(false) and sMainLooper = myLooper()). Also, the control statement 'if (sMainLooper != null)' and the new exception 'throw new IllegalStateException(""The main Looper has already been prepared."")' have been introduced. Moreover, the dependent API 'prepare()' changed its parameter from no input to a boolean input. Therefore, the code change type is 1,3,4,5.","Due to the introduction of the new 'if' statement and the changes in the prepare and setMainLooper methods, the API could return different types and raise an IllegalStateException which was not existing before. Thus, the compatibility issue type is 1,2."
1101,<android.database.sqlite.SQLiteCursor: void finalize()>,15,16,<android.database.sqlite.SQLiteCursor: void finalize()>,<android.database.sqlite.SQLiteCursor: void finalize()>,0,"{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (mStackTrace != null) {
                int len = mQuery.mSql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (false) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (mStackTrace != null) {
                String sql = mQuery.getSql();
                int len = sql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.getDatabase().getLabel() + "", table = "" + mEditTable + "", query = "" + sql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
        }
    } finally {
        super.finalize();
    }
}",1,"/**
 * Release the native resources, if they haven't been released yet.
 */
","/**
 * Release the native resources, if they haven't been released yet.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"In the late version, mQuery.mSql is replaced by mQuery.getSql() and mQuery.mDatabase.getPath() is replaced by mQuery.getDatabase().getLabel(). Also, a method call SQLiteDebug.notifyActiveCursorFinalized() was removed that doesn't fit into return, exception handling or control dependency categories. So the type is 4,5",The change in methods of mQuery object may lead to different behaviors and thus different return values in finalize(). So the CI type is 1.
1103,<android.webkit.WebViewDatabase: boolean hasUsernamePassword()>,15,16,<android.webkit.WebViewDatabase: boolean hasUsernamePassword()>,<android.webkit.WebViewDatabase: boolean hasUsernamePassword()>,0,"{
    synchronized (mPasswordLock) {
        return hasEntries(TABLE_PASSWORD_ID);
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Find out if there are any passwords saved.
 *
 * @return TRUE if there is passwords saved
 */
","/**
 * Gets whether there are any username/password combinations
 * from web pages saved.
 *
 * @return true if there are any username/passwords used in web
 * forms saved
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The early implementation for this function has been completely removed and replaced with an exception throwing statement in the late version, so the code change type is 2.","The absence of the original method and the introduction of an exception throwing statement in the late version can lead to the API potentially throwing a new exception when it's invoked, therefore the CI type is 2."
1104,<android.webkit.WebHistoryItem: String getTitle()>,15,16,<android.webkit.WebHistoryItem: String getTitle()>,<android.webkit.WebHistoryItem: String getTitle()>,0,"{
    return mTitle;
}","{
    if (mNativeBridge == 0)
        return null;
    return nativeGetTitle(mNativeBridge);
}",1,"/**
 * Return the document title of this history item.
 * @return The document title of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */
","/**
 * Return the document title of this history item.
 * @return The document title of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The 'return' and 'if' statements have changed. So, the code change type is 1,3.","Because of the new introduced condition check 'if (mNativeBridge == 0)', in some cases the return value might change from mTitle to null. Therefore, the CI type is 1."
1105,<android.webkit.WebViewDatabase: void clearUsernamePassword()>,15,16,<android.webkit.WebViewDatabase: void clearUsernamePassword()>,<android.webkit.WebViewDatabase: void clearUsernamePassword()>,0,"{
    if (!checkInitialized()) {
        return;
    }
    synchronized (mPasswordLock) {
        mDatabase.delete(mTableNames[TABLE_PASSWORD_ID], null, null);
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Clear password database
 */
","/**
 * Clears any username/password combinations saved from web forms.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The early version's implementation has been completely replaced with a 'throw new MustOverrideException()' statement in the late version. This change involves a new return statement (as the previous implementation has been removed) and a new exception statement is also added, thereby making the code change type classified as 1,2.","The late version of the API now throws an exception instead of executing the previous functionalities, and the return values from the API could be different. Therefore, the CI type is 1,2."
1106,<android.view.View: void setBackgroundDrawable(Drawable)>,15,16,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    if (d == mBGDrawable) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBGDrawable != null) {
        mBGDrawable.setCallback(null);
        unscheduleDrawable(mBGDrawable);
    }
    if (d != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        if (d.getPadding(padding)) {
            switch(d.getResolvedLayoutDirectionSelf()) {
                case LAYOUT_DIRECTION_RTL:
                    setPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    setPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
        }
        // if it has a different minimum size, we should layout again
        if (mBGDrawable == null || mBGDrawable.getMinimumHeight() != d.getMinimumHeight() || mBGDrawable.getMinimumWidth() != d.getMinimumWidth()) {
            requestLayout = true;
        }
        d.setCallback(this);
        if (d.isStateful()) {
            d.setState(getDrawableState());
        }
        d.setVisible(getVisibility() == VISIBLE, false);
        mBGDrawable = d;
        if ((mPrivateFlags & SKIP_DRAW) != 0) {
            mPrivateFlags &= ~SKIP_DRAW;
            mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBGDrawable = null;
        if ((mPrivateFlags & ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        if (background.getPadding(padding)) {
            switch(background.getResolvedLayoutDirectionSelf()) {
                case LAYOUT_DIRECTION_RTL:
                    setPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    setPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        if ((mPrivateFlags & SKIP_DRAW) != 0) {
            mPrivateFlags &= ~SKIP_DRAW;
            mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}",1,"/**
 * Set the background to a given Drawable, or remove the background. If the
 * background has padding, this View's padding is set to the background's
 * padding. However, when a background is removed, this View's padding isn't
 * touched. If setting the padding is desired, please use
 * {@link #setPadding(int, int, int, int)}.
 *
 * @param d The Drawable to use as the background, or null to remove the
 * background
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The variable 'mBGDrawable' has been renamed to 'mBackground' and 'd' to 'background'. All changes are purely naming,so the code change type is 4.","The changes are entirely cosmetic and do not affect the functioning of the method, therefore there is no compatibility issue (CI type 0)."
1107,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",15,16,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        return constructor.newInstance(args);
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    }
}","{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // always use ourselves when inflating ViewStub later
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(this);
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    }
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Three new lines of code are added in the late version with the introduction of two new variables 'view' and 'viewStub'. Also, the assignment statement for the variable 'args' has changed, so the type of code change is categorized as 1,3.","The introduction of new variables and change in assignment of 'args' could potentially lead to a different return value depending on the condition 'view instanceof ViewStub'. Thus causing a potential compatibility issue as the return values might vary between the two versions, so the CI type is 1."
1108,<android.app.ContextImpl: boolean deleteDatabase(String)>,15,16,<android.app.ContextImpl: boolean deleteDatabase(String)>,<android.app.ContextImpl: boolean deleteDatabase(String)>,0,"{
    try {
        File f = validateFilePath(name, false);
        return f.delete();
    } catch (Exception e) {
    }
    return false;
}","{
    try {
        File f = validateFilePath(name, false);
        return SQLiteDatabase.deleteDatabase(f);
    } catch (Exception e) {
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning the result of f.delete() to SQLiteDatabase.deleteDatabase(f). This also means that the dependent API, delete(), has been changed to SQLiteDatabase.deleteDatabase(), therefore, the code change type is 1,5.","The change of return statement will make the API potentially return a different value and thus affect the behavior of user-written code, so the CI type is 1."
1109,<android.widget.NumberPicker: boolean onTouchEvent(MotionEvent)>,15,16,<android.widget.NumberPicker: boolean onTouchEvent(MotionEvent)>,<android.widget.NumberPicker: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    int action = ev.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = ev.getY();
            if (mBeginEditOnUpEvent || mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
                if (deltaDownY > mTouchSlop) {
                    mBeginEditOnUpEvent = false;
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                }
            }
            int deltaMoveY = (int) (currentMoveY - mLastMotionEventY);
            scrollBy(0, deltaMoveY);
            invalidate();
            mLastMotionEventY = currentMoveY;
            break;
        case MotionEvent.ACTION_UP:
            if (mBeginEditOnUpEvent) {
                setSelectorWheelState(SELECTOR_WHEEL_STATE_SMALL);
                showInputControls(mShowInputControlsAnimimationDuration);
                mInputText.requestFocus();
                return true;
            }
            VelocityTracker velocityTracker = mVelocityTracker;
            velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            int initialVelocity = (int) velocityTracker.getYVelocity();
            if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
                fling(initialVelocity);
                onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
            } else {
                if (mAdjustScrollerOnUpEvent) {
                    if (mFlingScroller.isFinished() && mAdjustScroller.isFinished()) {
                        postAdjustScrollerCommand(0);
                    }
                } else {
                    postAdjustScrollerCommand(SHOW_INPUT_CONTROLS_DELAY_MILLIS);
                }
            }
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            break;
    }
    return true;
}","{
    if (!isEnabled() || !mHasSelectorWheel) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(event);
    int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            {
                if (mIngonreMoveEvents) {
                    break;
                }
                float currentMoveY = event.getY();
                if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                    int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
                    if (deltaDownY > mTouchSlop) {
                        removeAllCallbacks();
                        onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                } else {
                    int deltaMoveY = (int) ((currentMoveY - mLastDownOrMoveEventY));
                    scrollBy(0, deltaMoveY);
                    invalidate();
                }
                mLastDownOrMoveEventY = currentMoveY;
            }
            break;
        case MotionEvent.ACTION_UP:
            {
                removeBeginSoftInputCommand();
                removeChangeCurrentByOneFromLongPress();
                mPressedStateHelper.cancel();
                VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity();
                if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
                    fling(initialVelocity);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                } else {
                    int eventY = (int) event.getY();
                    int deltaMoveY = (int) Math.abs(eventY - mLastDownEventY);
                    long deltaTime = event.getEventTime() - mLastDownEventTime;
                    if (deltaMoveY <= mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
                        if (mShowSoftInputOnTap) {
                            mShowSoftInputOnTap = false;
                            showSoftInput();
                        } else {
                            int selectorIndexOffset = (eventY / mSelectorElementHeight) - SELECTOR_MIDDLE_ITEM_INDEX;
                            if (selectorIndexOffset > 0) {
                                changeValueByOne(true);
                                mPressedStateHelper.buttonTapped(PressedStateHelper.BUTTON_INCREMENT);
                            } else if (selectorIndexOffset < 0) {
                                changeValueByOne(false);
                                mPressedStateHelper.buttonTapped(PressedStateHelper.BUTTON_DECREMENT);
                            }
                        }
                    } else {
                        ensureScrollWheelAdjusted();
                    }
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the early implementation, the condition of an if statement at the start has changed in the late implementation, which is considered a control dependency change (type 3). Some new logic and statements have been added to the switch block in the late implementation under both the 'ACTION_MOVE' and 'ACTION_UP' cases representing a change type of 4. The return statement 'return false' in an if statement at the start has a new condition to be met in the late implementation, which is a change of the return type 1.","Due to the change in condition leading to 'return false' statement, and additional logic and statements in the switch block, the API behavior can potentially change. Due to these changes, the API might return different values between the two versions. Hence, there is a compatibility issue caused by the potential difference in return values (type 1)."
1111,<android.webkit.WebSettings: void setDatabaseEnabled(boolean)>,15,16,<android.webkit.WebSettings: void setDatabaseEnabled(boolean)>,<android.webkit.WebSettings: void setDatabaseEnabled(boolean)>,0,"{
    if (mDatabaseEnabled != flag) {
        mDatabaseEnabled = flag;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set whether the database storage API is enabled.
 * @param flag boolean True if the WebView should use the database storage
 * API.
 */
","/**
 * Sets whether the database storage API is enabled.
 *
 * @param flag true if the WebView should use the database storage API
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The late version of the code concisely throws an exception irrespective of any conditions, which is a alteration from the early version that has if-else statements and some method calls. Therefore, the code change fits into categories 2 and 4 (Exception handling statement changed and Other statement changed).","In this case, the Compatibility Issue type is 2. Because, while invoking the late version of the API, the application will face unexpected exception throwing, which is a deviation from the behavior of the early version."
1113,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",15,16,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API ActivityManagerNative.getDefault().getIntentSender() is changed by adding a new parameter in late version, so the code change type is 5.","Variable 'target' depends directly on the returned value from the dependent API. So the change in the dependent API could make this API potentially return a different value. Therefore, the CI type is 1."
1114,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,15,16,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        return;
                    }
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner();
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                    }
                    startInputInner();
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                }
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        return;
                    }
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            checkFocus(mHasBeenInactive);
                        }
                    }
                }
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the Late version, the parameter of the method startInputInner() has been changed, and a new variable startInput and a new if condition have been added inside the case MSG_UNBIND. In the case MSG_SET_ACTIVE, a new method checkFocus(mHasBeenInactive) has been added. So, there is a change type 3 for Control Dependency and 4 for Other Statement change.","As a new condition and method are introduced, it can conditionally produce different behaviors, hence potentially leading to a different return value. So, there is a Compatibility Issue type 1."
1115,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",15,16,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>","<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",0,"{
    String packageName = getPackageName();
    try {
        data.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API 'ActivityManagerNative.getDefault().getIntentSender()' has changes in the number of parameters, so the code change type is 5.","Despite the change in the dependent API, this change doesn't lead to different return values or exception handlings, so there is no Compatibility Issue. The CI type is 0."
1116,"<android.webkit.WebView: boolean onKeyMultiple(int,int,KeyEvent)>",15,16,"<android.webkit.WebView: boolean onKeyMultiple(int,int,KeyEvent)>","<android.webkit.WebView: boolean onKeyMultiple(int,int,KeyEvent)>",0,"{
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // send complex characters to webkit for use by JS and plugins
    if (keyCode == KeyEvent.KEYCODE_UNKNOWN && event.getCharacters() != null) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    return false;
}","{
    return mProvider.getViewDelegate().onKeyMultiple(keyCode, repeatCount, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation has been changed to a single return statement that involves a different dependent API, hence code change type is 1,5.","The change in return statement and the dependent API would potentially alter the return value, resulting in different behavior from the original version from the early version. Hence, CI type is 1."
1117,<android.os.Looper: Looper getMainLooper()>,15,16,<android.os.Looper: Looper getMainLooper()>,<android.os.Looper: Looper getMainLooper()>,0,"{
    return mMainLooper;
}","{
    synchronized (Looper.class) {
        return sMainLooper;
    }
}",1,"/**
 * Returns the application's main looper, which lives in the main thread of the application.
 */
","/**
 * Returns the application's main looper, which lives in the main thread of the application.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3",1,"The return statement is changed from `mMainLooper` to a synchronized version of `sMainLooper`, which can be classified into a return statement change. In addition, the introduction of a new 'synchronized' statement can be classified as a control dependency change.","Because of the change in the source of the `Looper` object being returned, there could potentially be different return values between the two versions, causing a compatibility issue of type 1, which is due to potential different return values or types."
1118,<android.webkit.WebView: InputConnection onCreateInputConnection(EditorInfo)>,15,16,<android.webkit.WebView: InputConnection onCreateInputConnection(EditorInfo)>,<android.webkit.WebView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    InputConnection connection = super.onCreateInputConnection(outAttrs);
    outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_FULLSCREEN;
    return connection;
}","{
    return mProvider.getViewDelegate().onCreateInputConnection(outAttrs);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The change shows that the method now returns mProvider.getViewDelegate().onCreateInputConnection(outAttrs) instead of connection. Also, the dependant API super.onCreateInputConnection() is replaced with mProvider.getViewDelegate().onCreateInputConnection(), so the code change type is 1,5.","Because the return statement has been changed, the method can potentially return different types/values, so the CI type is 1."
1119,"<android.widget.AbsListView.PositionScroller: void start(int,int)>",15,16,"<android.widget.AbsListView.PositionScroller: void start(int,int)>","<android.widget.AbsListView.PositionScroller: void start(int,int)>",0,"{
    stop();
    if (boundPosition == INVALID_POSITION) {
        start(position);
        return;
    }
    final int firstPos = mFirstPosition;
    final int lastPos = firstPos + getChildCount() - 1;
    int viewTravelCount;
    if (position <= firstPos) {
        final int boundPosFromLast = lastPos - boundPosition;
        if (boundPosFromLast < 1) {
            // Moving would shift our bound position off the screen. Abort.
            return;
        }
        final int posTravel = firstPos - position + 1;
        final int boundTravel = boundPosFromLast - 1;
        if (boundTravel < posTravel) {
            viewTravelCount = boundTravel;
            mMode = MOVE_UP_BOUND;
        } else {
            viewTravelCount = posTravel;
            mMode = MOVE_UP_POS;
        }
    } else if (position >= lastPos) {
        final int boundPosFromFirst = boundPosition - firstPos;
        if (boundPosFromFirst < 1) {
            // Moving would shift our bound position off the screen. Abort.
            return;
        }
        final int posTravel = position - lastPos + 1;
        final int boundTravel = boundPosFromFirst - 1;
        if (boundTravel < posTravel) {
            viewTravelCount = boundTravel;
            mMode = MOVE_DOWN_BOUND;
        } else {
            viewTravelCount = posTravel;
            mMode = MOVE_DOWN_POS;
        }
    } else {
        // Already on screen, nothing to do
        return;
    }
    if (viewTravelCount > 0) {
        mScrollDuration = SCROLL_DURATION / viewTravelCount;
    } else {
        mScrollDuration = SCROLL_DURATION;
    }
    mTargetPos = position;
    mBoundPos = boundPosition;
    mLastSeenPos = INVALID_POSITION;
    post(this);
}","{
    stop();
    if (boundPosition == INVALID_POSITION) {
        start(position);
        return;
    }
    if (mDataChanged) {
        // Wait until we're back in a stable state to try this.
        mPositionScrollAfterLayout = new Runnable() {

            @Override
            public void run() {
                start(position, boundPosition);
            }
        };
        return;
    }
    final int childCount = getChildCount();
    if (childCount == 0) {
        // Can't scroll without children.
        return;
    }
    final int firstPos = mFirstPosition;
    final int lastPos = firstPos + childCount - 1;
    int viewTravelCount;
    int clampedPosition = Math.max(0, Math.min(getCount() - 1, position));
    if (clampedPosition < firstPos) {
        final int boundPosFromLast = lastPos - boundPosition;
        if (boundPosFromLast < 1) {
            // Moving would shift our bound position off the screen. Abort.
            return;
        }
        final int posTravel = firstPos - clampedPosition + 1;
        final int boundTravel = boundPosFromLast - 1;
        if (boundTravel < posTravel) {
            viewTravelCount = boundTravel;
            mMode = MOVE_UP_BOUND;
        } else {
            viewTravelCount = posTravel;
            mMode = MOVE_UP_POS;
        }
    } else if (clampedPosition > lastPos) {
        final int boundPosFromFirst = boundPosition - firstPos;
        if (boundPosFromFirst < 1) {
            // Moving would shift our bound position off the screen. Abort.
            return;
        }
        final int posTravel = clampedPosition - lastPos + 1;
        final int boundTravel = boundPosFromFirst - 1;
        if (boundTravel < posTravel) {
            viewTravelCount = boundTravel;
            mMode = MOVE_DOWN_BOUND;
        } else {
            viewTravelCount = posTravel;
            mMode = MOVE_DOWN_POS;
        }
    } else {
        scrollToVisible(clampedPosition, boundPosition, SCROLL_DURATION);
        return;
    }
    if (viewTravelCount > 0) {
        mScrollDuration = SCROLL_DURATION / viewTravelCount;
    } else {
        mScrollDuration = SCROLL_DURATION;
    }
    mTargetPos = clampedPosition;
    mBoundPos = boundPosition;
    mLastSeenPos = INVALID_POSITION;
    postOnAnimation(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The conditional check for mDataChanged has been introduced, the variable clampedPosition is added to the code, some calculations and the method scrollToVisible() are added, and post(this) is changed to postOnAnimation(this) in the late version. Hence, the code change type is 1,3,4.","Although there are changes in the code, these changes will not cause the API to return different values or types and no new exceptions has been introduced, so there is no Compatibility issue."
1120,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,15,16,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider);
    }
    return null;
}","{
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The instantiation of ContentProviderClient changed its construction method by adding a boolean parameter, which is a dependent API change. Hence, the code change type is 1 and 5.","The instantiation of ContentProviderClient changed in the late version, making it potentially return a different object value. Therefore, the Compatibility Issue type is 1."
1121,<android.widget.TextView: boolean onCheckIsTextEditor()>,15,16,<android.widget.TextView: boolean onCheckIsTextEditor()>,<android.widget.TextView: boolean onCheckIsTextEditor()>,0,"{
    return mInputType != EditorInfo.TYPE_NULL;
}","{
    return mEditor != null && mEditor.mInputType != EditorInfo.TYPE_NULL;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement ""return mInputType != EditorInfo.TYPE_NULL;"" has been replaced with ""return mEditor != null && mEditor.mInputType != EditorInfo.TYPE_NULL;"", and a new condition `mEditor != null` is added, so the code change type is 1,3.","Due to the change of control dependency and return statement, the result of ""onCheckIsTextEditor()"" can be different now based on whether 'mEditor' is null or not unlike before which only depends on 'mInputType != EditorInfo.TYPE_NULL'. So, the CI type is 1."
1122,<android.widget.NumberPicker: void computeScroll()>,15,16,<android.widget.NumberPicker: void computeScroll()>,<android.widget.NumberPicker: void computeScroll()>,0,"{
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {
        return;
    }
    Scroller scroller = mFlingScroller;
    if (scroller.isFinished()) {
        scroller = mAdjustScroller;
        if (scroller.isFinished()) {
            return;
        }
    }
    scroller.computeScrollOffset();
    int currentScrollerY = scroller.getCurrY();
    if (mPreviousScrollerY == 0) {
        mPreviousScrollerY = scroller.getStartY();
    }
    scrollBy(0, currentScrollerY - mPreviousScrollerY);
    mPreviousScrollerY = currentScrollerY;
    if (scroller.isFinished()) {
        onScrollerFinished(scroller);
    } else {
        invalidate();
    }
}","{
    Scroller scroller = mFlingScroller;
    if (scroller.isFinished()) {
        scroller = mAdjustScroller;
        if (scroller.isFinished()) {
            return;
        }
    }
    scroller.computeScrollOffset();
    int currentScrollerY = scroller.getCurrY();
    if (mPreviousScrollerY == 0) {
        mPreviousScrollerY = scroller.getStartY();
    }
    scrollBy(0, currentScrollerY - mPreviousScrollerY);
    mPreviousScrollerY = currentScrollerY;
    if (scroller.isFinished()) {
        onScrollerFinished(scroller);
    } else {
        invalidate();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The early and late version codes have one change where the condition 'if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE)' and return statement have been removed in the late version code, so the code change type is 1.","The early implementation checks 'mSelectorWheelState',and if 'mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE' it returns. But in the late version, it doesn't contain this check, therefore the API in later version possibly doesn't stop execution and could return a different value compared to the earlier version. Therefore, the CI type is 1."
1125,"<android.view.View: void setFlags(int,int)>",15,16,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus
            if (getRootView() != this) {
                clearFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (flags & VISIBILITY_MASK));
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBGDrawable != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if ((changed & LAYOUT_DIRECTION_MASK) != 0) {
        requestLayout();
    }
}","{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            notifyAccessibilityStateChanged();
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), (flags & VISIBILITY_MASK));
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled() && ((changed & FOCUSABLE) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & ENABLED) != 0)) {
        notifyAccessibilityStateChanged();
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"From the comparison of two versions of implementation code, new method calls, such as 'clearAccessibilityFocus()' and 'notifyAccessibilityStateChanged()', have been added in multiple places of the method body, and a condition clause, i.e., 'if (AccessibilityManager.getInstance(mContext).isEnabled() && ((changed & FOCUSABLE) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & ENABLED) != 0))', has been newly introduced in the late version. Therefore, the code change types are 3,4.","The newly added 'notifyAccessibilityStateChanged()' method could potentially throw a different exception in the updated API, leading to different exception handling behaviors between the two versions. Thus, the CI type is 2."
1126,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,15,16,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,0,"{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mText instanceof Spannable) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(LOG_TAG, ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection((Spannable) mText, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                setError(error);
            }
        });
    }
}","{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mText instanceof Spannable) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(LOG_TAG, ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection((Spannable) mText, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    createEditorIfNeeded();
                    mEditor.mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                setError(error);
            }
        });
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The statement ""createEditorIfNeeded();"" is added in the latest implementation which is not related to return statements, exception handling statements, and control dependencies. So, the code change type is 4 (Other statement changed).","Although there is a code change, this change (createEditorIfNeeded) is unlikely to cause a compatibility issue since the method output and behavior is not modified. Hence, CI type is 0 (No Compatibility Issue exist)."
1129,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,15,16,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,0,"{
    enforceSealed();
    if (mConnectionId == UNDEFINED || mSourceWindowId == UNDEFINED || mSourceViewId == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceViewId);
}","{
    enforceSealed();
    if (mConnectionId == UNDEFINED || mSourceWindowId == UNDEFINED || AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, GET_SOURCE_PREFETCH_FLAGS);
}",1,"/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
","/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The condition statement has changed from checking whether mSourceViewId is UNDEFINED to whether AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) is UNDEFINED. Also, the arguments of the returned statement client.findAccessibilityNodeInfoByAccessibilityId have changed. It now includes mSourceNodeId and GET_SOURCE_PREFETCH_FLAGS. Therefore, the classes of code changes are 1,5.","Since both the check condition and the returned statement client.findAccessibilityNodeInfoByAccessibilityId have changed, this could potentially lead to different returned values from the method in the new version, creating a compatibility issue. Thus, the CI type is 1."
1130,"<android.content.Intent: int fillIn(Intent,int)>",15,16,"<android.content.Intent: int fillIn(Intent,int)>","<android.content.Intent: int fillIn(Intent,int)>",0,"{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new HashSet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}","{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new HashSet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    if (other.mClipData != null && (mClipData == null || (flags & FILL_IN_CLIP_DATA) != 0)) {
        mClipData = other.mClipData;
        changes |= FILL_IN_CLIP_DATA;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}",1,"/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data URI and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} to override the restriction where the
 * corresponding field will not be replaced if it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT} is explicitly
 * specified.  The selector will only be copied if {@link #FILL_IN_SELECTOR} is
 * explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
 */
","/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}.
 * <li> selector, as set by {@link #setSelector(Intent)}.
 * <li> clip data, as set by {@link #setClipData(ClipData)}.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
 * the restriction where the corresponding field will not be replaced if
 * it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
 * is explicitly specified.  The selector will only be copied if
 * {@link #FILL_IN_SELECTOR} is explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition and assignment statement about mClipData have been introduced, so the code change types are 3 and 4.","As these changes can lead to different changes in mClipData, it will influence the value of changes, which is the returned value of the method. Hence, the CI type is 1."
1131,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int)>",15,16,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    return getActivity(context, requestCode, intent, flags, null);
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The function implementation has completely changed, from a complex series of implementations to simply invoking another function 'getActivity(context, requestCode, intent, flags, null)'. Thus, the code change type is 1,4,5.","Due to the complete rewrite of the function, the returned value could be different as a result, resulting in a CI. Thus, the CI type is 1."
1134,"<android.view.GLES20Canvas: void drawPosText(String,float[],Paint)>",15,16,"<android.view.GLES20Canvas: void drawPosText(String,float[],Paint)>","<android.view.GLES20Canvas: void drawPosText(String,float[],Paint)>",0,"{
// TODO: Implement
}","{
    if (text.length() * 2 > pos.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawPosText(mRenderer, text, 0, text.length(), pos, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],"[@SuppressWarnings(""deprecation""), @Override]",-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the early version, there is no implementation. In the late version, new return and exception handling statements are introduced along with other statement, which indicates a change type of 1,2,4.","The late version implementation introduces a new exception handling 'throw new ArrayIndexOutOfBoundsException()' and a new return type which doesn't exist in the early version. Hence, the API potentially exhibits different behaviors, throwing a different exception and returning a different value (type) due to the new implementation. This indicates a CI type of 1,2."
1135,"<android.view.HardwareRenderer.GlRenderer: boolean draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>",15,16,"<android.view.HardwareRenderer.GlRenderer: boolean draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>","<android.view.HardwareRenderer.GlRenderer: boolean draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>",0,"{
    if (canDraw()) {
        if (!hasDirtyRegions()) {
            dirty = null;
        }
        attachInfo.mIgnoreDirtyState = true;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        view.mPrivateFlags |= View.DRAWN;
        final int surfaceState = checkCurrent();
        if (surfaceState != SURFACE_STATE_ERROR) {
            // We had to change the current surface and/or context, redraw everything
            if (surfaceState == SURFACE_STATE_UPDATED) {
                dirty = null;
            }
            onPreDraw(dirty);
            HardwareCanvas canvas = mCanvas;
            attachInfo.mHardwareCanvas = canvas;
            int saveCount = canvas.save();
            callbacks.onHardwarePreDraw(canvas);
            try {
                view.mRecreateDisplayList = (view.mPrivateFlags & View.INVALIDATED) == View.INVALIDATED;
                view.mPrivateFlags &= ~View.INVALIDATED;
                DisplayList displayList = view.getDisplayList();
                if (displayList != null) {
                    if (canvas.drawDisplayList(displayList, view.getWidth(), view.getHeight(), mRedrawClip)) {
                        if (mRedrawClip.isEmpty() || view.getParent() == null) {
                            view.invalidate();
                        } else {
                            view.getParent().invalidateChild(view, mRedrawClip);
                        }
                        mRedrawClip.setEmpty();
                    }
                } else {
                    // Shouldn't reach here
                    view.draw(canvas);
                }
                if (DEBUG_DIRTY_REGION) {
                    if (mDebugPaint == null) {
                        mDebugPaint = new Paint();
                        mDebugPaint.setColor(0x7fff0000);
                    }
                    if (dirty != null && (mFrameCount++ & 1) == 0) {
                        canvas.drawRect(dirty, mDebugPaint);
                    }
                }
            } finally {
                callbacks.onHardwarePostDraw(canvas);
                canvas.restoreToCount(saveCount);
                view.mRecreateDisplayList = false;
            }
            onPostDraw();
            attachInfo.mIgnoreDirtyState = false;
            sEgl.eglSwapBuffers(sEglDisplay, mEglSurface);
            checkEglErrors();
            return dirty == null;
        }
    }
    return false;
}","{
    if (canDraw()) {
        if (!hasDirtyRegions()) {
            dirty = null;
        }
        attachInfo.mIgnoreDirtyState = true;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        view.mPrivateFlags |= View.DRAWN;
        final int surfaceState = checkCurrent();
        if (surfaceState != SURFACE_STATE_ERROR) {
            HardwareCanvas canvas = mCanvas;
            attachInfo.mHardwareCanvas = canvas;
            if (mProfileEnabled) {
                mProfileLock.lock();
            }
            // We had to change the current surface and/or context, redraw everything
            if (surfaceState == SURFACE_STATE_UPDATED) {
                dirty = null;
                beginFrame(null);
            } else {
                int[] size = mSurfaceSize;
                beginFrame(size);
                if (size[1] != mHeight || size[0] != mWidth) {
                    mWidth = size[0];
                    mHeight = size[1];
                    canvas.setViewport(mWidth, mHeight);
                    dirty = null;
                }
            }
            int status = onPreDraw(dirty);
            int saveCount = canvas.save();
            callbacks.onHardwarePreDraw(canvas);
            try {
                view.mRecreateDisplayList = (view.mPrivateFlags & View.INVALIDATED) == View.INVALIDATED;
                view.mPrivateFlags &= ~View.INVALIDATED;
                long getDisplayListStartTime = 0;
                if (mProfileEnabled) {
                    mProfileCurrentFrame += PROFILE_FRAME_DATA_COUNT;
                    if (mProfileCurrentFrame >= mProfileData.length) {
                        mProfileCurrentFrame = 0;
                    }
                    getDisplayListStartTime = System.nanoTime();
                }
                DisplayList displayList;
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""getDisplayList"");
                try {
                    displayList = view.getDisplayList();
                } finally {
                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                }
                if (mProfileEnabled) {
                    long now = System.nanoTime();
                    float total = (now - getDisplayListStartTime) * 0.000001f;
                    // noinspection PointlessArithmeticExpression
                    mProfileData[mProfileCurrentFrame] = total;
                }
                if (displayList != null) {
                    long drawDisplayListStartTime = 0;
                    if (mProfileEnabled) {
                        drawDisplayListStartTime = System.nanoTime();
                    }
                    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""drawDisplayList"");
                    try {
                        status |= canvas.drawDisplayList(displayList, mRedrawClip, DisplayList.FLAG_CLIP_CHILDREN);
                    } finally {
                        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                    }
                    if (mProfileEnabled) {
                        long now = System.nanoTime();
                        float total = (now - drawDisplayListStartTime) * 0.000001f;
                        mProfileData[mProfileCurrentFrame + 1] = total;
                    }
                    handleFunctorStatus(attachInfo, status);
                } else {
                    // Shouldn't reach here
                    view.draw(canvas);
                }
            } finally {
                callbacks.onHardwarePostDraw(canvas);
                canvas.restoreToCount(saveCount);
                view.mRecreateDisplayList = false;
                mFrameCount++;
                if (mDebugDirtyRegions) {
                    if (mDebugPaint == null) {
                        mDebugPaint = new Paint();
                        mDebugPaint.setColor(0x7fff0000);
                    }
                    if (dirty != null && (mFrameCount & 1) == 0) {
                        canvas.drawRect(dirty, mDebugPaint);
                    }
                }
            }
            onPostDraw();
            attachInfo.mIgnoreDirtyState = false;
            if ((status & DisplayList.STATUS_DREW) == DisplayList.STATUS_DREW) {
                long eglSwapBuffersStartTime = 0;
                if (mProfileEnabled) {
                    eglSwapBuffersStartTime = System.nanoTime();
                }
                sEgl.eglSwapBuffers(sEglDisplay, mEglSurface);
                if (mProfileEnabled) {
                    long now = System.nanoTime();
                    float total = (now - eglSwapBuffersStartTime) * 0.000001f;
                    mProfileData[mProfileCurrentFrame + 2] = total;
                }
                checkEglErrors();
            }
            if (mProfileEnabled) {
                mProfileLock.unlock();
            }
            return dirty == null;
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version of the implementation, some new statements were added and some existing ones were modified within the if and else-if conditions. This means that the control dependency and the other statements have changed, which leads to change types 3 and 4.","Even though there were changes in the code, these changes do not affect the way the method operates, the type or the value of what is being returned. Thus, there is no Compatibility Issue present."
1136,<android.widget.TextView: int getInputType()>,15,16,<android.widget.TextView: int getInputType()>,<android.widget.TextView: int getInputType()>,0,"{
    return mInputType;
}","{
    return mEditor == null ? EditorInfo.TYPE_NULL : mEditor.mInputType;
}",1,"/**
 * Get the type of the content.
 *
 * @see #setInputType(int)
 * @see android.text.InputType
 */
","/**
 * Get the type of the editable content.
 *
 * @see #setInputType(int)
 * @see android.text.InputType
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement of this method has changed, from returning a straight member variable, to a conditional operation determining whether to return a null type or a specific property of the 'mEditor' object.","Since the return condition has changed, there's a compatibility issue caused by potential different return values or types. Depending on the state of the 'mEditor' object at runtime, the return value can be different, which leads to type 1 compatibility issue."
1137,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",15,16,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>","<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",0,"{
    final IBinder fWindowToken = windowToken;
    final float fXOffset = xOffset;
    final float fYOffset = yOffset;
    sGlobals.getHandler().post(new Runnable() {

        public void run() {
            try {
                // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
                ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(fWindowToken, fXOffset, fYOffset, mWallpaperXStep, mWallpaperYStep);
            // Log.v(TAG, ""...app returning after sending offsets!"");
            } catch (RemoteException e) {
            // Ignore.
            } catch (IllegalArgumentException e) {
            // Since this is being posted, it's possible that this windowToken is no longer
            // valid, for example, if setWallpaperOffsets is called just before rotation.
            }
        }
    });
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
","/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version, the code that deals with 'Runnable' and 'exception IllegalArgumentException' has been removed, and three statements about variable assignment at the beginning of the method have been removed as well. It Type 3 and 4 changes because the control dependency (Runnable) and statements has been removed.","There is no Compatibility Issue as all that is done is to remove the runnable wrapper which schedule the task to be abled to be run in the thread which the handler which are attached to. The IllegalArgumentException has been removed from late version but it doesn't have an effect on the return value or the way the method handles exceptions, the behaviour of API remains the same."
1139,<android.preference.DialogPreference: void onClick()>,15,16,<android.preference.DialogPreference: void onClick()>,<android.preference.DialogPreference: void onClick()>,0,"{
    showDialog(null);
}","{
    if (mDialog != null && mDialog.isShowing())
        return;
    showDialog(null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"New control dependency (an 'if' condition) was added to the method. Thus, this change classifies as a control dependency change type 3.","The new 'if' condition block added in the API can lead to situations where the API call doesn't show the dialog and simply returns. This means that the API could potentially return different outcomes than the early version based on the conditions specified, therefore classifying as a Compatibility Issue caused by potential different return values or types (type 1)."
1141,<android.nfc.tech.Ndef: void writeNdefMessage(NdefMessage)>,15,16,<android.nfc.tech.Ndef: void writeNdefMessage(NdefMessage)>,<android.nfc.tech.Ndef: void writeNdefMessage(NdefMessage)>,0,"{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            int errorCode = tagService.ndefWrite(serviceHandle, msg);
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    break;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    throw new FormatException();
                default:
                    // Should not happen
                    throw new IOException();
            }
        } else {
            throw new IOException(""Tag is not ndef"");
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    }
}","{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException(""Mock tags don't support this operation."");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            int errorCode = tagService.ndefWrite(serviceHandle, msg);
            switch(errorCode) {
                case ErrorCodes.SUCCESS:
                    break;
                case ErrorCodes.ERROR_IO:
                    throw new IOException();
                case ErrorCodes.ERROR_INVALID_PARAM:
                    throw new FormatException();
                default:
                    // Should not happen
                    throw new IOException();
            }
        } else {
            throw new IOException(""Tag is not ndef"");
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    }
}",1,"/**
 * Overwrite the {@link NdefMessage} on this tag.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param msg the NDEF Message to write, must not be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message to write is malformed
 */
","/**
 * Overwrite the {@link NdefMessage} on this tag.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param msg the NDEF Message to write, must not be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message to write is malformed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new exception check (tagService == null) has been introduced, it will change the control flow and throw a new IOException, so the code change type is 2,3.","The introduction of the new exception handling check may cause the method to throw a different exception (IOException(""Mock tags don't support this operation."")) that was not present in the early version, hence CI type is 2."
1142,<android.widget.AbsListView.PositionScroller: void run()>,15,16,<android.widget.AbsListView.PositionScroller: void run()>,<android.widget.AbsListView.PositionScroller: void run()>,0,"{
    if (mTouchMode != TOUCH_MODE_FLING && mLastSeenPos != INVALID_POSITION) {
        return;
    }
    final int listHeight = getHeight();
    final int firstPos = mFirstPosition;
    switch(mMode) {
        case MOVE_DOWN_POS:
            {
                final int lastViewIndex = getChildCount() - 1;
                final int lastPos = firstPos + lastViewIndex;
                if (lastViewIndex < 0) {
                    return;
                }
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    post(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = lastPos < mItemCount - 1 ? mExtraScroll : mListPadding.bottom;
                smoothScrollBy(lastViewHeight - lastViewPixelsShowing + extraScroll, mScrollDuration);
                mLastSeenPos = lastPos;
                if (lastPos < mTargetPos) {
                    post(this);
                }
                break;
            }
        case MOVE_DOWN_BOUND:
            {
                final int nextViewIndex = 1;
                final int childCount = getChildCount();
                if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) {
                    return;
                }
                final int nextPos = firstPos + nextViewIndex;
                if (nextPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    post(this);
                    return;
                }
                final View nextView = getChildAt(nextViewIndex);
                final int nextViewHeight = nextView.getHeight();
                final int nextViewTop = nextView.getTop();
                final int extraScroll = mExtraScroll;
                if (nextPos < mBoundPos) {
                    smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration);
                    mLastSeenPos = nextPos;
                    post(this);
                } else {
                    if (nextViewTop > extraScroll) {
                        smoothScrollBy(nextViewTop - extraScroll, mScrollDuration);
                    }
                }
                break;
            }
        case MOVE_UP_POS:
            {
                if (firstPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    post(this);
                    return;
                }
                final View firstView = getChildAt(0);
                if (firstView == null) {
                    return;
                }
                final int firstViewTop = firstView.getTop();
                final int extraScroll = firstPos > 0 ? mExtraScroll : mListPadding.top;
                smoothScrollBy(firstViewTop - extraScroll, mScrollDuration);
                mLastSeenPos = firstPos;
                if (firstPos > mTargetPos) {
                    post(this);
                }
                break;
            }
        case MOVE_UP_BOUND:
            {
                final int lastViewIndex = getChildCount() - 2;
                if (lastViewIndex < 0) {
                    return;
                }
                final int lastPos = firstPos + lastViewIndex;
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    post(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                mLastSeenPos = lastPos;
                if (lastPos > mBoundPos) {
                    smoothScrollBy(-(lastViewPixelsShowing - mExtraScroll), mScrollDuration);
                    post(this);
                } else {
                    final int bottom = listHeight - mExtraScroll;
                    final int lastViewBottom = lastViewTop + lastViewHeight;
                    if (bottom > lastViewBottom) {
                        smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration);
                    }
                }
                break;
            }
        case MOVE_OFFSET:
            {
                if (mLastSeenPos == firstPos) {
                    // No new views, let things keep going.
                    post(this);
                    return;
                }
                mLastSeenPos = firstPos;
                final int childCount = getChildCount();
                final int position = mTargetPos;
                final int lastPos = firstPos + childCount - 1;
                int viewTravelCount = 0;
                if (position < firstPos) {
                    viewTravelCount = firstPos - position + 1;
                } else if (position > lastPos) {
                    viewTravelCount = position - lastPos;
                }
                // Estimate how many screens we should travel
                final float screenTravelCount = (float) viewTravelCount / childCount;
                final float modifier = Math.min(Math.abs(screenTravelCount), 1.f);
                if (position < firstPos) {
                    smoothScrollBy((int) (-getHeight() * modifier), mScrollDuration);
                    post(this);
                } else if (position > lastPos) {
                    smoothScrollBy((int) (getHeight() * modifier), mScrollDuration);
                    post(this);
                } else {
                    // On-screen, just scroll.
                    final int targetTop = getChildAt(position - firstPos).getTop();
                    final int distance = targetTop - mOffsetFromTop;
                    smoothScrollBy(distance, (int) (mScrollDuration * ((float) distance / getHeight())));
                }
                break;
            }
        default:
            break;
    }
}","{
    final int listHeight = getHeight();
    final int firstPos = mFirstPosition;
    switch(mMode) {
        case MOVE_DOWN_POS:
            {
                final int lastViewIndex = getChildCount() - 1;
                final int lastPos = firstPos + lastViewIndex;
                if (lastViewIndex < 0) {
                    return;
                }
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = lastPos < mItemCount - 1 ? Math.max(mListPadding.bottom, mExtraScroll) : mListPadding.bottom;
                final int scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                smoothScrollBy(scrollBy, mScrollDuration, true);
                mLastSeenPos = lastPos;
                if (lastPos < mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_DOWN_BOUND:
            {
                final int nextViewIndex = 1;
                final int childCount = getChildCount();
                if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) {
                    return;
                }
                final int nextPos = firstPos + nextViewIndex;
                if (nextPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View nextView = getChildAt(nextViewIndex);
                final int nextViewHeight = nextView.getHeight();
                final int nextViewTop = nextView.getTop();
                final int extraScroll = Math.max(mListPadding.bottom, mExtraScroll);
                if (nextPos < mBoundPos) {
                    smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration, true);
                    mLastSeenPos = nextPos;
                    postOnAnimation(this);
                } else {
                    if (nextViewTop > extraScroll) {
                        smoothScrollBy(nextViewTop - extraScroll, mScrollDuration, true);
                    }
                }
                break;
            }
        case MOVE_UP_POS:
            {
                if (firstPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View firstView = getChildAt(0);
                if (firstView == null) {
                    return;
                }
                final int firstViewTop = firstView.getTop();
                final int extraScroll = firstPos > 0 ? Math.max(mExtraScroll, mListPadding.top) : mListPadding.top;
                smoothScrollBy(firstViewTop - extraScroll, mScrollDuration, true);
                mLastSeenPos = firstPos;
                if (firstPos > mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_UP_BOUND:
            {
                final int lastViewIndex = getChildCount() - 2;
                if (lastViewIndex < 0) {
                    return;
                }
                final int lastPos = firstPos + lastViewIndex;
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = Math.max(mListPadding.top, mExtraScroll);
                mLastSeenPos = lastPos;
                if (lastPos > mBoundPos) {
                    smoothScrollBy(-(lastViewPixelsShowing - extraScroll), mScrollDuration, true);
                    postOnAnimation(this);
                } else {
                    final int bottom = listHeight - extraScroll;
                    final int lastViewBottom = lastViewTop + lastViewHeight;
                    if (bottom > lastViewBottom) {
                        smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration, true);
                    }
                }
                break;
            }
        case MOVE_OFFSET:
            {
                if (mLastSeenPos == firstPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                mLastSeenPos = firstPos;
                final int childCount = getChildCount();
                final int position = mTargetPos;
                final int lastPos = firstPos + childCount - 1;
                int viewTravelCount = 0;
                if (position < firstPos) {
                    viewTravelCount = firstPos - position + 1;
                } else if (position > lastPos) {
                    viewTravelCount = position - lastPos;
                }
                // Estimate how many screens we should travel
                final float screenTravelCount = (float) viewTravelCount / childCount;
                final float modifier = Math.min(Math.abs(screenTravelCount), 1.f);
                if (position < firstPos) {
                    final int distance = (int) (-getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true);
                    postOnAnimation(this);
                } else if (position > lastPos) {
                    final int distance = (int) (getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true);
                    postOnAnimation(this);
                } else {
                    // On-screen, just scroll.
                    final int targetTop = getChildAt(position - firstPos).getTop();
                    final int distance = targetTop - mOffsetFromTop;
                    final int duration = (int) (mScrollDuration * ((float) Math.abs(distance) / getHeight()));
                    smoothScrollBy(distance, duration, true);
                }
                break;
            }
        default:
            break;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
1143,<android.app.Activity: MenuInflater getMenuInflater()>,15,16,<android.app.Activity: MenuInflater getMenuInflater()>,<android.app.Activity: MenuInflater getMenuInflater()>,0,"{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext());
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}","{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}",1,"/**
 * Returns a {@link MenuInflater} with this context.
 */
","/**
 * Returns a {@link MenuInflater} with this context.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The instantiation of 'MenuInflater' when 'mActionBar != null' has changed, this can be classified as changes in return statements and changes in dependent APIs.","As a result of the change in the instantiation of 'MenuInflater', this method could potentially return a different value between the two versions. Thus, the CI type is 1."
1144,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",15,16,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>","<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",0,"{
    if (isHeaderOrFooterPosition(flatListPosition)) {
        // Return normal info for header/footer view context menus
        return new AdapterContextMenuInfo(view, flatListPosition, id);
    }
    final int adjustedPosition = getFlatPositionForConnector(flatListPosition);
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    ExpandableListPosition pos = pm.position;
    pm.recycle();
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pos.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}","{
    if (isHeaderOrFooterPosition(flatListPosition)) {
        // Return normal info for header/footer view context menus
        return new AdapterContextMenuInfo(view, flatListPosition, id);
    }
    final int adjustedPosition = getFlatPositionForConnector(flatListPosition);
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    ExpandableListPosition pos = pm.position;
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pm.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late version, one statement 'pos.recycle()' has been deleted. So, the code change type is 4.","The deleted statement 'pos.recycle()' is a cleaning up operation, which does not affect the return value or exception handling of the API. So, no Compatibility Issue exists, the CI type is 0."
1145,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",15,16,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>","<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",0,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE_CHILD_IN_PARENT);
    }
    if ((mPrivateFlags & DRAWN) == DRAWN || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) != FLAG_CLIP_CHILDREN || dirty.intersect(0, 0, mRight - left, mBottom - top) || (mPrivateFlags & DRAW_ANIMATION) == DRAW_ANIMATION) {
                mPrivateFlags &= ~DRAWING_CACHE_VALID;
                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
                if (mLayerType != LAYER_TYPE_NONE) {
                    mLocalDirtyRect.union(dirty);
                }
                return mParent;
            }
        } else {
            mPrivateFlags &= ~DRAWN & ~DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}","{
    if ((mPrivateFlags & DRAWN) == DRAWN || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) != FLAG_CLIP_CHILDREN || dirty.intersect(0, 0, mRight - left, mBottom - top) || (mPrivateFlags & DRAW_ANIMATION) == DRAW_ANIMATION) {
                mPrivateFlags &= ~DRAWING_CACHE_VALID;
                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
                if (mLayerType != LAYER_TYPE_NONE) {
                    mPrivateFlags |= INVALIDATED;
                    mLocalDirtyRect.union(dirty);
                }
                return mParent;
            }
        } else {
            mPrivateFlags &= ~DRAWN & ~DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement 'mPrivateFlags |= INVALIDATED' has been added twice in the late implementation. There is no change in control dependency, return statement, or exception handling. Also, no dependent APIs have been changed. Hence, it falls under the category of 'Other Statement Changed' (type 4).","Although there are changes in the statements, these changes do not affect the API's potential return values or the exceptions it may throw. Hence, there is no compatibility issue (type 0)."
1146,"<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>",15,16,"<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>","<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>",0,"{
    if (values == null || values.size() == 0) {
        throw new IllegalArgumentException(""Empty values"");
    }
    StringBuilder sql = new StringBuilder(120);
    sql.append(""UPDATE "");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(table);
    sql.append("" SET "");
    // move all bind args to one array
    int setValuesSize = values.size();
    int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
    Object[] bindArgs = new Object[bindArgsSize];
    int i = 0;
    for (String colName : values.keySet()) {
        sql.append((i > 0) ? "","" : """");
        sql.append(colName);
        bindArgs[i++] = values.get(colName);
        sql.append(""=?"");
    }
    if (whereArgs != null) {
        for (i = setValuesSize; i < bindArgsSize; i++) {
            bindArgs[i] = whereArgs[i - setValuesSize];
        }
    }
    if (!TextUtils.isEmpty(whereClause)) {
        sql.append("" WHERE "");
        sql.append(whereClause);
    }
    SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
    try {
        return statement.executeUpdateDelete();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        statement.close();
    }
}","{
    if (values == null || values.size() == 0) {
        throw new IllegalArgumentException(""Empty values"");
    }
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder(120);
        sql.append(""UPDATE "");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append(table);
        sql.append("" SET "");
        // move all bind args to one array
        int setValuesSize = values.size();
        int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);
        Object[] bindArgs = new Object[bindArgsSize];
        int i = 0;
        for (String colName : values.keySet()) {
            sql.append((i > 0) ? "","" : """");
            sql.append(colName);
            bindArgs[i++] = values.get(colName);
            sql.append(""=?"");
        }
        if (whereArgs != null) {
            for (i = setValuesSize; i < bindArgsSize; i++) {
                bindArgs[i] = whereArgs[i - setValuesSize];
            }
        }
        if (!TextUtils.isEmpty(whereClause)) {
            sql.append("" WHERE "");
            sql.append(whereClause);
        }
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeUpdateDelete();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}",1,"/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
","/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The line 'acquireReference();' has been added and 'onCorruption(); throw e;' has been removed. Therefore, the code change type is 2 (Exception handling statement changed) and 4 (Other statement changed).","The API no longer throws the SQLiteDatabaseCorruptException and does not call the 'onCorruption()' method anymore when an exception occurs. Therefore, the Compatibility Issue type is 2 (Compatibility Issue caused by potential different exception handlings)."
1147,<android.view.accessibility.AccessibilityEvent: String toString()>,15,16,<android.view.accessibility.AccessibilityEvent: String toString()>,<android.view.accessibility.AccessibilityEvent: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; sourceViewId: "").append(mSourceViewId);
        for (int i = 0; i < mRecords.size(); i++) {
            AccessibilityRecord record = mRecords.get(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < mRecords.size(); i++) {
            AccessibilityRecord record = mRecords.get(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Two new statements have been added that append the strings of mMovementGranularity and mAction to the StringBuilder, and three variables (mSourceViewId, and the iteration of mRecords) in the original implementation have been removed. Therefore, the operation of the builder object has changed, hence the type is 1,4.","As the 'return builder.toString()' in the late version will return a different string from the early version due to the change of contents of the builder, the CI type is 1."
1149,<android.view.accessibility.AccessibilityNodeInfo: boolean equals(Object)>,15,16,<android.view.accessibility.AccessibilityNodeInfo: boolean equals(Object)>,<android.view.accessibility.AccessibilityNodeInfo: boolean equals(Object)>,0,"{
    if (this == object) {
        return true;
    }
    if (object == null) {
        return false;
    }
    if (getClass() != object.getClass()) {
        return false;
    }
    AccessibilityNodeInfo other = (AccessibilityNodeInfo) object;
    if (mAccessibilityViewId != other.mAccessibilityViewId) {
        return false;
    }
    if (mAccessibilityWindowId != other.mAccessibilityWindowId) {
        return false;
    }
    return true;
}","{
    if (this == object) {
        return true;
    }
    if (object == null) {
        return false;
    }
    if (getClass() != object.getClass()) {
        return false;
    }
    AccessibilityNodeInfo other = (AccessibilityNodeInfo) object;
    if (mSourceNodeId != other.mSourceNodeId) {
        return false;
    }
    if (mWindowId != other.mWindowId) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The method is comparing different instance variables in the early and late version, i.e., (mAccessibilityViewId, mAccessibilityWindowId) is replaced with (mSourceNodeId, mWindowId) so, the code change type is 4(Others).","The comparison fields in the equals(...) method are changed, potentially causing the function to return different results. It might return true in previous version where it would return false in the new version and vice versa depending on the object's state. So, the CI type is 1(Return statement changed)."
1150,<android.webkit.WebView: WebBackForwardList copyBackForwardList()>,15,16,<android.webkit.WebView: WebBackForwardList copyBackForwardList()>,<android.webkit.WebView: WebBackForwardList copyBackForwardList()>,0,"{
    checkThread();
    return mCallbackProxy.getBackForwardList().clone();
}","{
    checkThread();
    return mProvider.copyBackForwardList();
}",1,"/**
 * Return the WebBackForwardList for this WebView. This contains the
 * back/forward list for use in querying each item in the history stack.
 * This is a copy of the private WebBackForwardList so it contains only a
 * snapshot of the current state. Multiple calls to this method may return
 * different objects. The object returned from this method will not be
 * updated to reflect any new state.
 */
","/**
 * Gets the WebBackForwardList for this WebView. This contains the
 * back/forward list for use in querying each item in the history stack.
 * This is a copy of the private WebBackForwardList so it contains only a
 * snapshot of the current state. Multiple calls to this method may return
 * different objects. The object returned from this method will not be
 * updated to reflect any new state.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 5",1,"The return statement has changed from 'mCallbackProxy.getBackForwardList().clone()' to 'mProvider.copyBackForwardList()'. Additionally, the dependent API 'mCallbackProxy.getBackForwardList().clone()' has been replaced by 'mProvider.copyBackForwardList()', leading to a change type of 1,5.","The return value could potentially be different because the implementation and the dependent API used in the return statement has changed. Therefore, the CI type is 1."
1151,<android.text.format.Time: boolean parse3339(String)>,15,16,<android.text.format.Time: boolean parse3339(String)>,<android.text.format.Time: boolean parse3339(String)>,0,"{
    if (nativeParse3339(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}","{
    if (s == null) {
        throw new NullPointerException(""time string is null"");
    }
    if (nativeParse3339(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}",1,"/**
 * Parse a time in RFC 3339 format.  This method also parses simple dates
 * (that is, strings that contain no time or time offset).  For example,
 * all of the following strings are valid:
 *
 * <ul>
 * <li>""2008-10-13T16:00:00.000Z""</li>
 * <li>""2008-10-13T16:00:00.000+07:00""</li>
 * <li>""2008-10-13T16:00:00.000-07:00""</li>
 * <li>""2008-10-13""</li>
 * </ul>
 *
 * <p>
 * If the string contains a time and time offset, then the time offset will
 * be used to convert the time value to UTC.
 * </p>
 *
 * <p>
 * If the given string contains just a date (with no time field), then
 * the {@link #allDay} field is set to true and the {@link #hour},
 * {@link #minute}, and  {@link #second} fields are set to zero.
 * </p>
 *
 * <p>
 * Returns true if the resulting time value is in UTC time.
 * </p>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
","/**
 * Parse a time in RFC 3339 format.  This method also parses simple dates
 * (that is, strings that contain no time or time offset).  For example,
 * all of the following strings are valid:
 *
 * <ul>
 * <li>""2008-10-13T16:00:00.000Z""</li>
 * <li>""2008-10-13T16:00:00.000+07:00""</li>
 * <li>""2008-10-13T16:00:00.000-07:00""</li>
 * <li>""2008-10-13""</li>
 * </ul>
 *
 * <p>
 * If the string contains a time and time offset, then the time offset will
 * be used to convert the time value to UTC.
 * </p>
 *
 * <p>
 * If the given string contains just a date (with no time field), then
 * the {@link #allDay} field is set to true and the {@link #hour},
 * {@link #minute}, and  {@link #second} fields are set to zero.
 * </p>
 *
 * <p>
 * Returns true if the resulting time value is in UTC time.
 * </p>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An exception handling statement (throw new NullPointerException) has been introduced under a conditional statement (if s == null), so the change type is 2,3.","As a new null pointer exception handling has been added, the API can behave differently when the input string is null. Therefore, the API can return different values (success or throws an exception), so the CI type is 1,2."
1152,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivities(Intent,int)>",15,16,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivities(Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivities(Intent,int)>",0,"{
    try {
        return mPM.queryIntentActivities(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags);
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.queryIntentActivities(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,The return statement has changed with the introduction of an additional parameter (UserId.myUserId()) in the mPM.queryIntentActivities() call. This falls into code change types 1 and 5.,The change in the return statement with a new parameter being passed to the mPM.queryIntentActivities() function implies that the late version of the API could potentially return different data resulting from changes in the query. This leads to CI type 1.
1153,<android.widget.AdapterViewAnimator: void refreshChildren()>,15,16,<android.widget.AdapterViewAnimator: void refreshChildren()>,<android.widget.AdapterViewAnimator: void refreshChildren()>,0,"{
    if (mAdapter == null)
        return;
    for (int i = mCurrentWindowStart; i <= mCurrentWindowEnd; i++) {
        int index = modulo(i, getWindowSize());
        int adapterCount = getCount();
        // get the fresh child from the adapter
        final View updatedChild = mAdapter.getView(modulo(i, adapterCount), null, this);
        if (mViewsMap.containsKey(index)) {
            final FrameLayout fl = (FrameLayout) mViewsMap.get(index).view;
            // add the new child to the frame, if it exists
            if (updatedChild != null) {
                // flush out the old child
                fl.removeAllViewsInLayout();
                fl.addView(updatedChild);
            }
        }
    }
}","{
    if (mAdapter == null)
        return;
    for (int i = mCurrentWindowStart; i <= mCurrentWindowEnd; i++) {
        int index = modulo(i, getWindowSize());
        int adapterCount = getCount();
        // get the fresh child from the adapter
        final View updatedChild = mAdapter.getView(modulo(i, adapterCount), null, this);
        if (updatedChild.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            updatedChild.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mViewsMap.containsKey(index)) {
            final FrameLayout fl = (FrameLayout) mViewsMap.get(index).view;
            // add the new child to the frame, if it exists
            if (updatedChild != null) {
                // flush out the old child
                fl.removeAllViewsInLayout();
                fl.addView(updatedChild);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two new method calls about ""importantForAccessibility"" attribute on ""updatedChild"" object have been introduced in the Late_Implementation. Therefore, the code change type is 4 (Other statement changed).","Deducing purely from the code standpoint, the introduced statements only change the ""importantForAccessibility"" attribute and does not seem to change the behaviour of the API or what it returns. So, it can be classified as no Compatibility Issue exists."
1154,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String)>",15,16,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String)>","<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String)>",0,"{
    if (mTables == null) {
        return null;
    }
    if (mStrict && selection != null && selection.length() > 0) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        String sqlForValidation = buildQuery(projectionIn, ""("" + selection + "")"", groupBy, having, sortOrder, limit);
        // will throw if query is invalid
        validateSql(db, sqlForValidation);
    }
    String sql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Performing query: "" + sql);
    }
    return db.rawQueryWithFactory(mFactory, sql, selectionArgs, // will throw if query is invalid
    SQLiteDatabase.findEditTable(mTables));
}","{
    return query(db, projectionIn, selection, selectionArgs, groupBy, having, sortOrder, limit, null);
}",1,"/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
","/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The whole method body is replaced with a single line 'return' statement which is calling another method, query(, null), with similar parameter. Such modification results in removal of a lot of preceding lines involving checks like ""if (mTables == null)"" and ""if (mStrict && selection != null && selection.length() > 0)"", logging, as well as a lot of code related to the 'sql' string variable. So the change type is classified into Return statement changed(1), Other statement changed(4), and Dependent API changed(5).","The whole method body is rewritten so it potentially leads to different return values or types. For instance, the early version of the method could return null if mTables == null but in the late version, that check does not exist anymore. Thus, the CI type is classified as 1, Compatibility Issue caused by potential different return values or types."
1157,<android.webkit.WebIconDatabase: void retainIconForPageUrl(String)>,15,16,<android.webkit.WebIconDatabase: void retainIconForPageUrl(String)>,<android.webkit.WebIconDatabase: void retainIconForPageUrl(String)>,0,"{
    if (url != null) {
        mEventHandler.postMessage(Message.obtain(null, EventHandler.RETAIN_ICON, url));
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Retain the icon for the given page url.
 * @param url The page's url.
 */
","/**
 * Retain the icon for the given page url.
 * @param url The page's url.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4",2,"The early implementation is replaced by a single 'throw new MustOverrideException();' statement. The return statement was removed, a new exception statement was added, and all other statements were removed as well, corresponding to the change types 1,2,4.","The late version throws a 'MustOverrideException', which the early version doesn't do. This directly leads to potential different behaviours when invoking the API and thus a compatibility issue (type 2) is detected."
1158,"<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>",15,16,"<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>","<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>",0,"{
    long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
    synchronized (this) {
        if (mValuesVersion != newValuesVersion) {
            if (LOCAL_LOGV) {
                Log.v(TAG, ""invalidate ["" + mUri.getLastPathSegment() + ""]: current "" + newValuesVersion + "" != cached "" + mValuesVersion);
            }
            mValues.clear();
            mValuesVersion = newValuesVersion;
        }
        if (mValues.containsKey(name)) {
            // Could be null, that's OK -- negative caching
            return mValues.get(name);
        }
    }
    IContentProvider cp = null;
    synchronized (this) {
        cp = mContentProvider;
        if (cp == null) {
            cp = mContentProvider = cr.acquireProvider(mUri.getAuthority());
        }
    }
    // interface.
    if (mCallCommand != null) {
        try {
            Bundle b = cp.call(mCallCommand, name, null);
            if (b != null) {
                String value = b.getPairValue();
                synchronized (this) {
                    mValues.put(name, value);
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
    synchronized (this) {
        if (mValuesVersion != newValuesVersion) {
            if (LOCAL_LOGV) {
                Log.v(TAG, ""invalidate ["" + mUri.getLastPathSegment() + ""]: current "" + newValuesVersion + "" != cached "" + mValuesVersion);
            }
            mValues.clear();
            mValuesVersion = newValuesVersion;
        }
        if (mValues.containsKey(name)) {
            // Could be null, that's OK -- negative caching
            return mValues.get(name);
        }
    }
    IContentProvider cp = null;
    synchronized (this) {
        cp = mContentProvider;
        if (cp == null) {
            cp = mContentProvider = cr.acquireProvider(mUri.getAuthority());
        }
    }
    // interface.
    if (mCallCommand != null) {
        try {
            Bundle b = cp.call(mCallCommand, name, null);
            if (b != null) {
                String value = b.getPairValue();
                synchronized (this) {
                    mValues.put(name, value);
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API - cp.query() has changed. An extra null parameter has been added in the late version, so the change type is 5.","The API cp.query() is changed with an extra parameter which can affect the behavior of the API and hence the return type of the method, therefore the Compatibility Issue type is 1."
1160,<android.view.View: boolean onHoverEvent(MotionEvent)>,15,16,<android.view.View: boolean onHoverEvent(MotionEvent)>,<android.view.View: boolean onHoverEvent(MotionEvent)>,0,"{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getAction();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            mSendingHoverAccessibilityEvents = true;
            sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_HOVER_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        return true;
    }
    return false;
}","{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
            // focus as soon as the user stop hovering over the view.
            if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
                getViewRootImpl().setAccessibilityFocus(null, null);
            }
        }
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
","/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The action is now determined by using getActionMasked() instead of getAction(). New statements are introduced (sendAccessibilityHoverEvent, getViewRootImpl().setAccessibilityFocus), and old statements are deleted (sendAccessibilityEvent). Some of the statements are shuffled as well. Therefore, the change can be classified as types 1, 3, 4, 5.","The changes could potentially lead to different return values due to the changes in the handling of the event action and the introduction of new statements and deletions of the old ones. Therefore, it's classified as CI type 1."
1162,"<android.app.Activity: boolean onPreparePanel(int,View,Menu)>",15,16,"<android.app.Activity: boolean onPreparePanel(int,View,Menu)>","<android.app.Activity: boolean onPreparePanel(int,View,Menu)>",0,"{
    if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
        boolean goforit = onPrepareOptionsMenu(menu);
        goforit |= mFragments.dispatchPrepareOptionsMenu(menu);
        return goforit && menu.hasVisibleItems();
    }
    return true;
}","{
    if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
        boolean goforit = onPrepareOptionsMenu(menu);
        goforit |= mFragments.dispatchPrepareOptionsMenu(menu);
        return goforit;
    }
    return true;
}",1,"/**
 * Default implementation of
 * {@link android.view.Window.Callback#onPreparePanel}
 * for activities.  This
 * calls through to the new {@link #onPrepareOptionsMenu} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
","/**
 * Default implementation of
 * {@link android.view.Window.Callback#onPreparePanel}
 * for activities.  This
 * calls through to the new {@link #onPrepareOptionsMenu} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement within conditional statement has changed from returning 'goforit && menu.hasVisibleItems()' to 'goforit'. Therefore, the code change type is 1.","Since the return statement within the conditional statement has changed, the API potentially returns a different boolean value in the two versions. Therefore, the CI type is 1."
1163,"<android.view.GLES20Canvas: void drawArc(RectF,float,float,boolean,Paint)>",15,16,"<android.view.GLES20Canvas: void drawArc(RectF,float,float,boolean,Paint)>","<android.view.GLES20Canvas: void drawArc(RectF,float,float,boolean,Paint)>",0,"{
    int modifiers = setupModifiers(paint);
    nDrawArc(mRenderer, oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle, useCenter, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}","{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawArc(mRenderer, oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle, useCenter, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",0,"The method setupModifiers() is called with different arguments. A try-finally block is added, so control dependency is changed. A constant MODIFIER_COLOR_FILTER | MODIFIER_SHADER has been introduced into the setupModifiers(paint) function, so other statements changed. Overall, the code change type is 2,3,4.","Neither the return values (as there aren't any) nor the type of exceptions that the method potentially throws are changed. Therefore, there are no Compatibility Issues."
1164,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,15,16,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,0,"{
    AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain(this);
    onInitializeAccessibilityNodeInfo(info);
    return info;
}","{
    AccessibilityNodeProvider provider = getAccessibilityNodeProvider();
    if (provider != null) {
        return provider.createAccessibilityNodeInfo(View.NO_ID);
    } else {
        AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain(this);
        onInitializeAccessibilityNodeInfo(info);
        return info;
    }
}",1,"/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
","/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, new conditional statements are added to check if the 'provider' is null or not.Then, based on the condition, the return statement also changes. So, the code change type is 1,3.","As the return statement has been moved inside a conditional block in the late version, depending upon the condition, the returned results of the method can be different between two versions. Hence, the CI type is 1."
1165,<android.widget.TextView: void setTextIsSelectable(boolean)>,15,16,<android.widget.TextView: void setTextIsSelectable(boolean)>,<android.widget.TextView: void setTextIsSelectable(boolean)>,0,"{
    if (mTextIsSelectable == selectable)
        return;
    mTextIsSelectable = selectable;
    setFocusableInTouchMode(selectable);
    setFocusable(selectable);
    setClickable(selectable);
    setLongClickable(selectable);
    // mInputType is already EditorInfo.TYPE_NULL and mInput is null;
    setMovementMethod(selectable ? ArrowKeyMovementMethod.getInstance() : null);
    setText(getText(), selectable ? BufferType.SPANNABLE : BufferType.NORMAL);
    // Called by setText above, but safer in case of future code changes
    prepareCursorControllers();
}","{
    // false is default value with no edit data
    if (!selectable && mEditor == null)
        return;
    createEditorIfNeeded();
    if (mEditor.mTextIsSelectable == selectable)
        return;
    mEditor.mTextIsSelectable = selectable;
    setFocusableInTouchMode(selectable);
    setFocusable(selectable);
    setClickable(selectable);
    setLongClickable(selectable);
    // mInputType should already be EditorInfo.TYPE_NULL and mInput should be null
    setMovementMethod(selectable ? ArrowKeyMovementMethod.getInstance() : null);
    setText(mText, selectable ? BufferType.SPANNABLE : BufferType.NORMAL);
    // Called by setText above, but safer in case of future code changes
    mEditor.prepareCursorControllers();
}",1,"/**
 * Sets whether or not (default) the content of this view is selectable by the user.
 *
 * Note that this methods affect the {@link #setFocusable(boolean)},
 * {@link #setFocusableInTouchMode(boolean)} {@link #setClickable(boolean)} and
 * {@link #setLongClickable(boolean)} states and you may want to restore these if they were
 * customized.
 *
 * See {@link #isTextSelectable} for details.
 *
 * @param selectable Whether or not the content of this TextView should be selectable.
 */
","/**
 * Sets whether or not (default) the content of this view is selectable by the user.
 *
 * Note that this methods affect the {@link #setFocusable(boolean)},
 * {@link #setFocusableInTouchMode(boolean)} {@link #setClickable(boolean)} and
 * {@link #setLongClickable(boolean)} states and you may want to restore these if they were
 * customized.
 *
 * See {@link #isTextSelectable} for details.
 *
 * @param selectable Whether or not the content of this TextView should be selectable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The function implementations are basically same apart from a new condition introduced at the beginning of the method and references have been prefixed with `mEditor`. So, there is a control dependency change (type 3), other statement change (due to the introduction of the new pre-fix `mEditor`) (type 4), and a return statement change (type 1).","Because of changes in the method, depending on the value of `selectable` and whether `mEditor` is `null`, the function might return at different points than the early version leading potentially to different behaviors. So, a compatibility issue exists due to potential different return values or types (type 1)."
1166,<android.webkit.WebSettings: boolean supportZoom()>,15,16,<android.webkit.WebSettings: boolean supportZoom()>,<android.webkit.WebSettings: boolean supportZoom()>,0,"{
    return mSupportZoom;
}","{
    throw new MustOverrideException();
}",1,"/**
 * Returns whether the WebView supports zoom
 */
","/**
 * Gets whether the WebView supports zoom.
 *
 * @return true if the WebView supports zoom
 * @see #setSupportZoom
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The old return statement that was returning `mSupportZoom` has been removed and a new exception statement `throw new MustOverrideException();` has been introduced in the late version. Therefore, the change type is 1,2.","Since the value returned by the method has changed and an exception has been introduced in the late version, it leads to compatibility issues as it will behave differently depending on the version used. Therefore, the CI type is 1,2."
1167,<android.webkit.WebView: int getProgress()>,15,16,<android.webkit.WebView: int getProgress()>,<android.webkit.WebView: int getProgress()>,0,"{
    checkThread();
    return mCallbackProxy.getProgress();
}","{
    checkThread();
    return mProvider.getProgress();
}",1,"/**
 * Get the progress for the current page.
 * @return The progress for the current page between 0 and 100.
 */
","/**
 * Gets the progress for the current page.
 *
 * @return the progress for the current page between 0 and 100
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method 'getProgress' called on 'mCallbackProxy' has been changed to be called on 'mProvider', so the code change type is 1,5 (Return statement changed and Dependent API changed).","The return of the method changes because the method 'getProgress' is called from a different object now. It might return different values, depending on the state of the 'mProvider' object. Thus, the CI type is 1 (Compatibility Issue is caused by a potential difference in return values)."
1169,<android.widget.ProgressBar: void onDraw(Canvas)>,15,16,<android.widget.ProgressBar: void onDraw(Canvas)>,<android.widget.ProgressBar: void onDraw(Canvas)>,0,"{
    super.onDraw(canvas);
    Drawable d = mCurrentDrawable;
    if (d != null) {
        // Translate canvas so a indeterminate circular progress bar with padding
        // rotates properly in its animation
        canvas.save();
        canvas.translate(mPaddingLeft, mPaddingTop);
        long time = getDrawingTime();
        if (mAnimation != null) {
            mAnimation.getTransformation(time, mTransformation);
            float scale = mTransformation.getAlpha();
            try {
                mInDrawing = true;
                d.setLevel((int) (scale * MAX_LEVEL));
            } finally {
                mInDrawing = false;
            }
            if (SystemClock.uptimeMillis() - mLastDrawTime >= mAnimationResolution) {
                mLastDrawTime = SystemClock.uptimeMillis();
                postInvalidateDelayed(mAnimationResolution);
            }
        }
        d.draw(canvas);
        canvas.restore();
        if (mShouldStartAnimationDrawable && d instanceof Animatable) {
            ((Animatable) d).start();
            mShouldStartAnimationDrawable = false;
        }
    }
}","{
    super.onDraw(canvas);
    Drawable d = mCurrentDrawable;
    if (d != null) {
        // Translate canvas so a indeterminate circular progress bar with padding
        // rotates properly in its animation
        canvas.save();
        canvas.translate(mPaddingLeft, mPaddingTop);
        long time = getDrawingTime();
        if (mHasAnimation) {
            mAnimation.getTransformation(time, mTransformation);
            float scale = mTransformation.getAlpha();
            try {
                mInDrawing = true;
                d.setLevel((int) (scale * MAX_LEVEL));
            } finally {
                mInDrawing = false;
            }
            postInvalidateOnAnimation();
        }
        d.draw(canvas);
        canvas.restore();
        if (mShouldStartAnimationDrawable && d instanceof Animatable) {
            ((Animatable) d).start();
            mShouldStartAnimationDrawable = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The condition of the if statement has changed from 'mAnimation != null' to 'mHasAnimation', and some other statements under that condition like 'if (SystemClock.uptimeMillis() - mLastDrawTime >= mAnimationResolution)' are deleted and replaced by 'postInvalidateOnAnimation()'. So the code change type is 3 for control statement and 4 for other statements except the return and exception handling statements.","Though the implementation has changed, the behavior of this method 'onDraw(Canvas)' does not seem to be affected because the core process of drawing stays the same, and thus no compatibility issue exists. So the CI type is 0."
1170,"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>",15,16,"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>","<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri utteranceUri = mUtterances.get(text);
            if (utteranceUri != null) {
                return service.playAudio(getPackageName(), utteranceUri, queueMode, getParams(params));
            } else {
                return service.speak(getPackageName(), text, queueMode, getParams(params));
            }
        }
    }, ERROR, ""speak"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri utteranceUri = mUtterances.get(text);
            if (utteranceUri != null) {
                return service.playAudio(getCallerIdentity(), utteranceUri, queueMode, getParams(params));
            } else {
                return service.speak(getCallerIdentity(), text, queueMode, getParams(params));
            }
        }
    }, ERROR, ""speak"");
}",1,"/**
 * Speaks the string using the specified queuing strategy and speech
 * parameters.
 *
 * @param text The string of text to be spoken.
 * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID},
 * {@link Engine#KEY_PARAM_VOLUME},
 * {@link Engine#KEY_PARAM_PAN}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Speaks the string using the specified queuing strategy and speech
 * parameters.
 *
 * @param text The string of text to be spoken.
 * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID},
 * {@link Engine#KEY_PARAM_VOLUME},
 * {@link Engine#KEY_PARAM_PAN}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"A dependent API has changed from getPackageName() to getCallerIdentity(), and that function is invoked inside other statements which means also other statement is changed, so the code change type is 4,5.","Change in the dependent API could potentially lead to it returning different values impacting the overall return value of the method, hence it can cause compatibility issues. CI Type is 1."
1171,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,15,16,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentAccessibilityViewId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mAccessibilityWindowId, mParentAccessibilityViewId);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The parameter for the function 'canPerformRequestOverConnection()' has changed, and the return statement's function 'findAccessibilityNodeInfoByAccessibilityId()' has got different parameters. Meanwhile, the variables 'mParentAccessibilityViewId', 'mParentNodeId', 'mWindowId', 'mAccessibilityWindowId' have changes, leading to the code change type to be 1,4,5.","Changes in the conditions as well as the method's parameters may result in different return values from the early version to the late version of the API, causing Compatibility Issue type 1."
1172,<android.webkit.WebSettings: void setCursiveFontFamily(String)>,15,16,<android.webkit.WebSettings: void setCursiveFontFamily(String)>,<android.webkit.WebSettings: void setCursiveFontFamily(String)>,0,"{
    if (font != null && !font.equals(mCursiveFontFamily)) {
        mCursiveFontFamily = font;
        postSync();
    }
}","{
    throw new MustOverrideException();
}",1,"/**
 * Set the cursive font family name.
 * @param font A font family name.
 */
","/**
 * Sets the cursive font family name. The default is ""cursive"".
 *
 * @param font a font family name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","The entire implementation was replaced with a throw new MustOverrideException() statement, and this relates to exception handling and other statements, so the change type is 2,4.","The addition of an exception throwing (throw new MustOverrideException()) potentially changes the behavior and the returned value (throwing an exception instead), so the CI type is 1,2."
1175,"<android.os.MessageQueue: void removeCallbacksAndMessages(Handler,Object)>",15,16,"<android.os.MessageQueue: void removeCallbacksAndMessages(Handler,Object)>","<android.os.MessageQueue: void removeCallbacksAndMessages(Handler,Object)>",0,"{
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}","{
    if (h == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        // Remove all messages at front.
        while (p != null && p.target == h && (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycle();
            p = n;
        }
        // Remove all messages after front.
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h && (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycle();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,No Compatibility Issue exist,"In the late version, a new condition statement 'if (h == null)' was added to make sure that the parameter 'h' is not null before proceeding with the operations, so the code change type is 3.","The newly added code ensures more safety by checking the nullability of 'h'. However, as the exception and return values do not change even if the added code will cause the method execute differently when h is null in the late version, there is no compatibility issue."
1177,<android.view.TextureView: HardwareLayer getHardwareLayer()>,15,16,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // from an arbitrary thread
                synchronized (mLock) {
                    mUpdateLayer = true;
                }
                postInvalidateDelayed(0);
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}","{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        }
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // from an arbitrary thread
                synchronized (mLock) {
                    mUpdateLayer = true;
                }
                if (Looper.myLooper() == Looper.getMainLooper()) {
                    invalidate();
                } else {
                    postInvalidate();
                }
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // parameters are correct (width, height, transform, etc.)
        synchronized (mLock) {
            mUpdateLayer = true;
        }
        mMatrixChanged = true;
        mAttachInfo.mHardwareRenderer.setSurfaceTexture(mLayer, mSurface);
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Several control dependencies (e.g., the introduction of 'if (!mUpdateSurface)') and other statements (e.g., adding a block of code under 'if (mUpdateSurface)') have been modified or added. Thus, the code change type is 3,4.",#CI_description
