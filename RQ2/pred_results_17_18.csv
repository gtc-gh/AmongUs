Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
3,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",17,18,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",0,"{
    path.computeBounds(mPathBounds, true);
    return nQuickReject(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom, type.nativeInt);
}","{
    path.computeBounds(mPathBounds, true);
    return nQuickReject(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter list of nQuickReject() function changed and a return statement also changed due to removal of the 'type.nativeInt' parameter, so the code change type is 1,5.","As the return statement has changed due to altered function call of nQuickReject(), the API could return a different value. Thus, the CI type is 1."
4,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,17,18,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int action = event.getActionMasked();
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += event.getX(i);
        sumY += event.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    if (!mInProgress && span >= mMinSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
        }
    }
    return true;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += event.getX(i);
        sumY += event.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    if (!mInProgress && span >= mMinSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}",1,"/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
","/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,There was additional implementation added to the later version of the code. The variable mCurrTime = event.getEventTime() and mPrevTime = mCurrTime were introduced to the later version of the code.,"The introduction of mCurrTime and mPrevTime to the code means it will return a different outcome. This could be a compatibility issue as the new result differs from earlier versions. Thus, the CI type is 1."
5,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void clear()>,17,18,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void clear()>,<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void clear()>,0,"{
    // We currently just clear the references, and leave all the previous layouts returned
    // in their default state of the loading view.
    mReferences.clear();
}","{
    // We currently just clear the references, and leave all the previous layouts returned
    // in their default state of the loading view.
    mReferences.clear();
    mViewToLinkedList.clear();
}",1,"/**
 * Removes all references to all RemoteViewsFrameLayouts returned by the adapter.
 */
","/**
 * Removes all references to all RemoteViewsFrameLayouts returned by the adapter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"One line 'mViewToLinkedList.clear();' has been added in the late version, which only clears another data structure 'mViewToLinkedList', so the code change type is 4.","The added line is related to the internal data structure management and does not affect the return value or exception handling of the API, so no compatibility issue exists. The CI type is 0."
6,"<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>",17,18,"<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>","<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>",0,"{
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (count < 4)
        return;
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"There is an added return statement in 'if' condition statement (control dependency), so the code change type is 1,3.","The added return statement could lead to the fact that the API might return without executing the part of the code from the Early Version depending on the 'count' value, which may lead to different behaviours. Therefore, a Compatibility Issue exists, and the CI type is 1."
7,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",17,18,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>","<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",0,"{
    try {
        return mContentProvider.insert(url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
","/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mContentProvider.insert(url, initialValues) to mContentProvider.insert(mPackageName, url, initialValues), and the underlying API called (mContentProvider.insert) now requires an additional argument (mPackageName). Therefore, the code change type is 1,5.","The change of return statement could potentially lead to different return value situations, therefore, the CI type is 1."
9,<android.inputmethodservice.IInputMethodWrapper.InputMethodSessionCallbackWrapper: void sessionCreated(InputMethodSession)>,17,18,<android.inputmethodservice.IInputMethodWrapper.InputMethodSessionCallbackWrapper: void sessionCreated(InputMethodSession)>,<android.inputmethodservice.IInputMethodWrapper.InputMethodSessionCallbackWrapper: void sessionCreated(InputMethodSession)>,0,"{
    try {
        if (session != null) {
            IInputMethodSessionWrapper wrap = new IInputMethodSessionWrapper(mContext, session);
            mCb.sessionCreated(wrap);
        } else {
            mCb.sessionCreated(null);
        }
    } catch (RemoteException e) {
    }
}","{
    try {
        if (session != null) {
            IInputMethodSessionWrapper wrap = new IInputMethodSessionWrapper(mContext, session, mChannel);
            mCb.sessionCreated(wrap);
        } else {
            if (mChannel != null) {
                mChannel.dispose();
            }
            mCb.sessionCreated(null);
        }
    } catch (RemoteException e) {
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"The parameters of the method IInputMethodSessionWrapper, and the handling of mChannel in the else block have changed. Thus the change types are 1 (Return statement) and 3 (Control dependency).","Although the changes occur in the implementation, it will not lead to any different behaviour in values returned or exceptions thrown by the method, hence no Compatibility Issues are detected."
11,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,17,18,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,<android.appwidget.AppWidgetManager: Bundle getAppWidgetOptions(int)>,0,"{
    try {
        return sService.getAppWidgetOptions(appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        return sService.getAppWidgetOptions(appWidgetId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get the extras associated with a given widget instance.
 *
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #updateAppWidgetOptions(int, Bundle)
 *
 * @param appWidgetId     The AppWidget instances for which to set the RemoteViews.
 * @return                The options associated with the given widget instance.
 */
","/**
 * Get the extras associated with a given widget instance.
 *
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #updateAppWidgetOptions(int, Bundle)
 *
 * @param appWidgetId     The AppWidget instances for which to set the RemoteViews.
 * @return                The options associated with the given widget instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called in the return statement changed from sService.getAppWidgetOptions(appWidgetId) to sService.getAppWidgetOptions(appWidgetId, mContext.getUserId()). So we can assume both Return statement and Dependent API changed.","The method in return statement changed its signature, potentially causing the returned value to be different, which could result in a compatibility issue."
12,<android.widget.ImageView: Matrix getImageMatrix()>,17,18,<android.widget.ImageView: Matrix getImageMatrix()>,<android.widget.ImageView: Matrix getImageMatrix()>,0,"{
    return mMatrix;
}","{
    if (mDrawMatrix == null) {
        return new Matrix(Matrix.IDENTITY_MATRIX);
    }
    return mDrawMatrix;
}",1,"/**
 * Return the view's optional matrix. This is applied to the
 * view's drawable when it is drawn. If there is not matrix,
 * this method will return null.
 * Do not change this matrix in place. If you want a different matrix
 * applied to the drawable, be sure to call setImageMatrix().
 */
","/**
 * Return the view's optional matrix. This is applied to the
 * view's drawable when it is drawn. If there is not matrix,
 * this method will return an identity matrix.
 * Do not change this matrix in place but make a copy.
 * If you want a different matrix applied to the drawable,
 * be sure to call setImageMatrix().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early version of API directly returned the value of `mMatrix`. However, the late version verifies if `mDrawMatrix` is `null`, if so, then it returns a newly created Matrix instance; else it returns the `mDrawMatrix`. This is clearly a change in a return statement and also a control dependency change, hence the code change type is 1,3.","Due to the changes in return statements, the API might return a different value in the late version which is likely to cause compatibility issues of the type 1."
13,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,17,18,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed in one of the cases in the switch condition. Specifically, the case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_VIEW_ID has changed to MSG_FIND_ACCESSIBLITY_NODE_INFOS_BY_VIEW_ID. Hence, the change type is 1.","The change in the return statement could potentially cause the API to return a new message, so it poses a compatibility issue. Hence, the CI type is 1."
15,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",17,18,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(""RemoteViews"", ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(""RemoteViews"", ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId());
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(LOG_TAG, ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(LOG_TAG, ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId());
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The string inside the Log.e() function changed. This belongs to the 'Other statement changed' category that does not affect the functionality or behaviours of API.,"There is no compatibility issue since the variable value passed into the Log.e() function does not impact the functionality or behaviours of API. The change only affects the log output, not the functional execution or results of the API."
16,<android.app.Notification.BigPictureStyle: BigPictureStyle setBigContentTitle(CharSequence)>,17,18,<android.app.Notification.BigPictureStyle: BigPictureStyle setBigContentTitle(CharSequence)>,<android.app.Notification.BigPictureStyle: BigPictureStyle setBigContentTitle(CharSequence)>,0,"{
    internalSetBigContentTitle(title);
    return this;
}","{
    internalSetBigContentTitle(safeCharSequence(title));
    return this;
}",1,"/**
 * Overrides ContentTitle in the big form of the template.
 * This defaults to the value passed to setContentTitle().
 */
","/**
 * Overrides ContentTitle in the big form of the template.
 * This defaults to the value passed to setContentTitle().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method setBigContentTitle() has changed, with the title being converted to a safeCharSequence in the late version. This indicates that both the method calls (Type 4) and dependency API (Type 5) have changed.","The change in the method from direct assignment to safeCharSequence conversion potentially leads to a different behavior, specifically in returning different results, thus leading to a Compatibility Issue of Type 1 (potential different return values)."
17,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,17,18,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, true, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The statement 'intent.setAllowFds(false);' is replaced with 'intent.prepareToLeaveProcess();'. Also, in the method 'broadcastIntent', 'AppOpsManager.OP_NONE' has replaced 'null'. So, the code change type is 4,5.","These changes could potentially change the behavior of the 'broadcastIntent' function, leading to return different result. So, the CI type is 1."
18,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,17,18,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,0,"{
    try {
        return mContentProvider.applyBatch(operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
","/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method mContentProvider.applyBatch() has been changed to mContentProvider.applyBatch(mPackageName,), so the code change type is 1,5.","The returned result of the method could be different because an extra parameter is added in the late version. Therefore, the CI type is 1."
19,<android.view.accessibility.AccessibilityNodeInfo: boolean isLongClickable()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isLongClickable()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isLongClickable()>,0,"{
    return getBooleanProperty(PROPERTY_LONG_CLICKABLE);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_LONG_CLICKABLE);
}",1,"/**
 * Gets whether this node is long clickable.
 *
 * @return True if the node is long clickable.
 */
","/**
 * Gets whether this node is long clickable.
 *
 * @return True if the node is long clickable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getBooleanProperty(PROPERTY_LONG_CLICKABLE) to getBooleanProperty(BOOLEAN_PROPERTY_LONG_CLICKABLE) and the parameter type of getBooleanProperty() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
20,"<android.view.ViewGroup.ChildListForAccessibility: ChildListForAccessibility obtain(ViewGroup,boolean)>",17,18,"<android.view.ViewGroup.ChildListForAccessibility: ChildListForAccessibility obtain(ViewGroup,boolean)>","<android.view.ViewGroup.ChildListForAccessibility: ChildListForAccessibility obtain(ViewGroup,boolean)>",0,"{
    ChildListForAccessibility list = null;
    synchronized (sPoolLock) {
        if (sPool != null) {
            list = sPool;
            sPool = list.mNext;
            list.mNext = null;
            list.mIsPooled = false;
            sPoolSize--;
        } else {
            list = new ChildListForAccessibility();
        }
        list.init(parent, sort);
        return list;
    }
}","{
    ChildListForAccessibility list = sPool.acquire();
    if (list == null) {
        list = new ChildListForAccessibility();
    }
    list.init(parent, sort);
    return list;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The 'synchronized' block is removed and the implementation of obtaining an instance of ChildListForAccessibility is changed, so the code change type is 3 (Control dependency changed: the 'synchronized' block is removed) and 4 (Other statement changed: the method to obtain an instance of ChildListForAccessibility is changed). ",Removing 'synchronized' block can change the multithreading behavior of a method which could potentially lead to different results being returned. 
21,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",17,18,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"{
    try {
        return mContentProvider.update(url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed as the dependent API 'mContentProvider.update()' calls an extra parameter 'mPackageName' in the late version. So, the code change types are 1,5.","The addition of a new parameter to the dependent API call could potentially affect the return value of the API. Thus, the compatibility issue type is 1."
22,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,17,18,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!mIsAttached) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            if (mPositionScroller != null) {
                                mPositionScroller.stop();
                            }
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionX = (int) ev.getX();
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            mDirection = 0;
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling).
                                    // It might be a click or a scroll. Assume it is a click until
                                    // proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        mFlingRunnable.flywheelTouch();
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                if (performButtonActionOnTouchDown(ev)) {
                    if (mTouchMode == TOUCH_MODE_DOWN) {
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                int pointerIndex = ev.findPointerIndex(mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    mActivePointerId = ev.getPointerId(pointerIndex);
                }
                final int y = (int) ev.getY(pointerIndex);
                if (mDataChanged) {
                    // Re-sync everything if data has been changed
                    // since the scroll operation can query the adapter.
                    layoutChildren();
                }
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(y);
                        break;
                    case TOUCH_MODE_SCROLL:
                    case TOUCH_MODE_OVERSCROLL:
                        scrollIfNeeded(y);
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        final float x = ev.getX();
                        final boolean inList = x > mListPadding.left && x < getWidth() - mListPadding.right;
                        if (child != null && !child.hasFocusable() && inList) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(mMotionPosition, child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    if (mTouchModeReset != null) {
                                        removeCallbacks(mTouchModeReset);
                                    }
                                    mTouchModeReset = new Runnable() {

                                        @Override
                                        public void run() {
                                            mTouchMode = TOUCH_MODE_REST;
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                performClick.run();
                                            }
                                        }
                                    };
                                    postDelayed(mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    updateSelectorState();
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                performClick.run();
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        updateSelectorState();
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) (velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                    if (mFlingRunnable != null) {
                                        mFlingRunnable.endFling();
                                    }
                                    if (mPositionScroller != null) {
                                        mPositionScroller.stop();
                                    }
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                recycleVelocityTracker();
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                if (mScrollStrictSpan != null) {
                    mScrollStrictSpan.finish();
                    mScrollStrictSpan = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        recycleVelocityTracker();
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!mIsAttached) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            if (mPositionScroller != null) {
                                mPositionScroller.stop();
                            }
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionX = (int) ev.getX();
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            mDirection = 0;
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling).
                                    // It might be a click or a scroll. Assume it is a click until
                                    // proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        mFlingRunnable.flywheelTouch();
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                if (performButtonActionOnTouchDown(ev)) {
                    if (mTouchMode == TOUCH_MODE_DOWN) {
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                int pointerIndex = ev.findPointerIndex(mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    mActivePointerId = ev.getPointerId(pointerIndex);
                }
                final int y = (int) ev.getY(pointerIndex);
                if (mDataChanged) {
                    // Re-sync everything if data has been changed
                    // since the scroll operation can query the adapter.
                    layoutChildren();
                }
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(y);
                        break;
                    case TOUCH_MODE_SCROLL:
                    case TOUCH_MODE_OVERSCROLL:
                        scrollIfNeeded(y);
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        final float x = ev.getX();
                        final boolean inList = x > mListPadding.left && x < getWidth() - mListPadding.right;
                        if (child != null && !child.hasFocusable() && inList) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(mMotionPosition, child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    if (mTouchModeReset != null) {
                                        removeCallbacks(mTouchModeReset);
                                    }
                                    mTouchModeReset = new Runnable() {

                                        @Override
                                        public void run() {
                                            mTouchModeReset = null;
                                            mTouchMode = TOUCH_MODE_REST;
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                performClick.run();
                                            }
                                        }
                                    };
                                    postDelayed(mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    updateSelectorState();
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                performClick.run();
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        updateSelectorState();
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) (velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                    if (mFlingRunnable != null) {
                                        mFlingRunnable.endFling();
                                    }
                                    if (mPositionScroller != null) {
                                        mPositionScroller.stop();
                                    }
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                recycleVelocityTracker();
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                if (mScrollStrictSpan != null) {
                    mScrollStrictSpan.finish();
                    mScrollStrictSpan = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        recycleVelocityTracker();
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
23,<android.widget.RelativeLayout.DependencyGraph.Node: Node acquire(View)>,17,18,<android.widget.RelativeLayout.DependencyGraph.Node: Node acquire(View)>,<android.widget.RelativeLayout.DependencyGraph.Node: Node acquire(View)>,0,"{
    final Node node = sPool.acquire();
    node.view = view;
    return node;
}","{
    Node node = sPool.acquire();
    if (node == null) {
        node = new Node();
    }
    node.view = view;
    return node;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the early version, the API simply acquires a Node from the sPool and assigns the view to the Node. However, in the latest version, after acquiring the Node, it checks if the node is null. If it is, it creates a new Node before assigning the view. Changes involve the condition checking and return statement themselves, therefore the change types are 1 and 3.","Due to the condition checking and return statement change, the API in late version could potentially return a brand new Node instead of previously acquired Node from the pool in certain situations. Therefore, the change can potentially result in different return values, which indicates a Compatibility Issue of type 1."
25,<android.widget.AppSecurityPermissions.PermissionItemView: void onClick(View)>,17,18,<android.widget.AppSecurityPermissions.PermissionItemView: void onClick(View)>,<android.widget.AppSecurityPermissions.PermissionItemView: void onClick(View)>,0,"{
    if (mGroup != null && mPerm != null) {
        if (mDialog != null) {
            mDialog.dismiss();
        }
        PackageManager pm = getContext().getPackageManager();
        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle(mGroup.mLabel);
        if (mPerm.descriptionRes != 0) {
            builder.setMessage(mPerm.loadDescription(pm));
        } else {
            CharSequence appName;
            try {
                ApplicationInfo app = pm.getApplicationInfo(mPerm.packageName, 0);
                appName = app.loadLabel(pm);
            } catch (NameNotFoundException e) {
                appName = mPerm.packageName;
            }
            StringBuilder sbuilder = new StringBuilder(128);
            sbuilder.append(getContext().getString(R.string.perms_description_app, appName));
            sbuilder.append(""\n\n"");
            sbuilder.append(mPerm.name);
            builder.setMessage(sbuilder.toString());
        }
        builder.setCancelable(true);
        builder.setIcon(mGroup.loadGroupIcon(pm));
        mDialog = builder.show();
        mDialog.setCanceledOnTouchOutside(true);
    }
}","{
    if (mGroup != null && mPerm != null) {
        if (mDialog != null) {
            mDialog.dismiss();
        }
        PackageManager pm = getContext().getPackageManager();
        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle(mGroup.mLabel);
        if (mPerm.descriptionRes != 0) {
            builder.setMessage(mPerm.loadDescription(pm));
        } else {
            CharSequence appName;
            try {
                ApplicationInfo app = pm.getApplicationInfo(mPerm.packageName, 0);
                appName = app.loadLabel(pm);
            } catch (NameNotFoundException e) {
                appName = mPerm.packageName;
            }
            StringBuilder sbuilder = new StringBuilder(128);
            sbuilder.append(getContext().getString(R.string.perms_description_app, appName));
            sbuilder.append(""\n\n"");
            sbuilder.append(mPerm.name);
            builder.setMessage(sbuilder.toString());
        }
        builder.setCancelable(true);
        builder.setIcon(mGroup.loadGroupIcon(pm));
        addRevokeUIIfNecessary(builder);
        mDialog = builder.show();
        mDialog.setCanceledOnTouchOutside(true);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new method 'addRevokeUIIfNecessary(builder)' has been introduced in the late version without changing any existing control flow or return, so the code change type is 4.","The introduced statement won't introduce any new return values or potential exceptions, because it does not change whatsoever the value being returned nor the exceptions the method handles. Therefore, no compatibility issue exists, the CI type is 0."
28,"<android.widget.Editor.SelectionActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",17,18,"<android.widget.Editor.SelectionActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>","<android.widget.Editor.SelectionActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",0,"{
    TypedArray styledAttributes = mTextView.getContext().obtainStyledAttributes(com.android.internal.R.styleable.SelectionModeDrawables);
    boolean allowText = mTextView.getContext().getResources().getBoolean(com.android.internal.R.bool.config_allowActionMenuItemTextWithIcon);
    mode.setTitle(mTextView.getContext().getString(com.android.internal.R.string.textSelectionCABTitle));
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    // No icon by default
    int selectAllIconId = 0;
    if (!allowText) {
        // Provide an icon, text will not be displayed on smaller screens.
        selectAllIconId = styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeSelectAllDrawable, 0);
    }
    menu.add(0, TextView.ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setIcon(selectAllIconId).setAlphabeticShortcut('a').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    if (mTextView.canCut()) {
        menu.add(0, TextView.ID_CUT, 0, com.android.internal.R.string.cut).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCutDrawable, 0)).setAlphabeticShortcut('x').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canCopy()) {
        menu.add(0, TextView.ID_COPY, 0, com.android.internal.R.string.copy).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCopyDrawable, 0)).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canPaste()) {
        menu.add(0, TextView.ID_PASTE, 0, com.android.internal.R.string.paste).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModePasteDrawable, 0)).setAlphabeticShortcut('v').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    styledAttributes.recycle();
    if (mCustomSelectionActionModeCallback != null) {
        if (!mCustomSelectionActionModeCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode
            return false;
        }
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        getSelectionController().show();
        mTextView.setHasTransientState(true);
        return true;
    } else {
        return false;
    }
}","{
    TypedArray styledAttributes = mTextView.getContext().obtainStyledAttributes(com.android.internal.R.styleable.SelectionModeDrawables);
    mode.setTitle(mTextView.getContext().getString(com.android.internal.R.string.textSelectionCABTitle));
    mode.setSubtitle(null);
    mode.setTitleOptionalHint(true);
    menu.add(0, TextView.ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeSelectAllDrawable, 0)).setAlphabeticShortcut('a').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    if (mTextView.canCut()) {
        menu.add(0, TextView.ID_CUT, 0, com.android.internal.R.string.cut).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCutDrawable, 0)).setAlphabeticShortcut('x').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canCopy()) {
        menu.add(0, TextView.ID_COPY, 0, com.android.internal.R.string.copy).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCopyDrawable, 0)).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (mTextView.canPaste()) {
        menu.add(0, TextView.ID_PASTE, 0, com.android.internal.R.string.paste).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModePasteDrawable, 0)).setAlphabeticShortcut('v').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    styledAttributes.recycle();
    if (mCustomSelectionActionModeCallback != null) {
        if (!mCustomSelectionActionModeCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode
            return false;
        }
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        getSelectionController().show();
        mTextView.setHasTransientState(true);
        return true;
    } else {
        return false;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The line of code ""boolean allowText = mTextView.getContext().getResources().getBoolean(com.android.internal.R.bool.config_allowActionMenuItemTextWithIcon);"" was removed along with its related conditional block, and ""int selectAllIconId"" declaration is also removed.","Given that the removed code does not affect the return values nor the exceptions thrown by the method, there are no potential Compatibility Issues. The code change impacts the internal logic of method, but does not affect its external behavior."
29,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",17,18,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>","<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.synthesizeToFile(getCallerIdentity(), text, filename, getParams(params));
        }
    }, ERROR, ""synthesizeToFile"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            ParcelFileDescriptor fileDescriptor;
            int returnValue;
            try {
                File file = new File(filename);
                if (file.exists() && !file.canWrite()) {
                    Log.e(TAG, ""Can't write to "" + filename);
                    return ERROR;
                }
                fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE);
                returnValue = service.synthesizeToFileDescriptor(getCallerIdentity(), text, fileDescriptor, getParams(params));
                fileDescriptor.close();
                return returnValue;
            } catch (FileNotFoundException e) {
                Log.e(TAG, ""Opening file "" + filename + "" failed"", e);
                return ERROR;
            } catch (IOException e) {
                Log.e(TAG, ""Closing file "" + filename + "" failed"", e);
                return ERROR;
            }
        }
    }, ERROR, ""synthesizeToFile"");
}",1,"/**
 * Synthesizes the given text to a file using the specified parameters.
 *
 * @param text The text that should be synthesized
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param filename Absolute file filename to write the generated audio data to.It should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Synthesizes the given text to a file using the specified parameters.
 * This method is asynchronous, i.e. the method just adds the request to the queue of TTS
 * requests and then returns. The synthesis might not have finished (or even started!) at the
 * time when this method returns. In order to reliably detect errors during synthesis,
 * we recommend setting an utterance progress listener (see
 * {@link #setOnUtteranceProgressListener}) and using the
 * {@link Engine#KEY_PARAM_UTTERANCE_ID} parameter.
 *
 * @param text The text that should be synthesized. No longer than
 * {@link #getMaxSpeechInputLength()} characters.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param filename Absolute file filename to write the generated audio data to.It should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return {@link #ERROR} or {@link #SUCCESS} of <b>queuing</b> the synthesizeToFile operation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The return statement has changed from service.synthesizeToFile() to service.synthesizeToFileDescriptor() and also the new method contains more exceptions and return statements related to dealing with IOException situation. Besides, there is a control dependency change due to the addition of new `if` and `try-catch` blocks. And other statements are also added, for instance creating a new File instance and checking if the file can be written. So the change type is 1,2,3,4.","Compatibility issue exists because the function now returns different values depending on whether the file exists and can be written or not, and in case of finding and dealing with IOException. This leads to potential return a different value and throw a different exception, so the CI type is 1,2."
31,<android.os.ParcelFileDescriptor: int detachFd()>,17,18,<android.os.ParcelFileDescriptor: int detachFd()>,<android.os.ParcelFileDescriptor: int detachFd()>,0,"{
    if (mClosed) {
        throw new IllegalStateException(""Already closed"");
    }
    if (mParcelDescriptor != null) {
        int fd = mParcelDescriptor.detachFd();
        mClosed = true;
        return fd;
    }
    int fd = getFd();
    mClosed = true;
    Parcel.clearFileDescriptor(mFileDescriptor);
    return fd;
}","{
    if (mClosed) {
        throw new IllegalStateException(""Already closed"");
    }
    if (mWrapped != null) {
        int fd = mWrapped.detachFd();
        mClosed = true;
        mGuard.close();
        return fd;
    }
    int fd = getFd();
    mClosed = true;
    mGuard.close();
    Parcel.clearFileDescriptor(mFileDescriptor);
    return fd;
}",1,"/**
 * Return the native fd int for this ParcelFileDescriptor and detach it
 * from the object here.  You are now responsible for closing the fd in
 * native code.
 */
","/**
 * Return the native fd int for this ParcelFileDescriptor and detach it
 * from the object here.  You are now responsible for closing the fd in
 * native code.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The name of the object called method ""detachFd()"" changed from ""mParcelDescriptor"" to ""mWrapped"". Besides, a new statement ""mGuard.close()"" was added, and the method ""clearFileDescriptor()"" takes a different input variable in the two versions. Therefore, the change type is 1,4,5.","The modification in the variable for method ""detachFd()"" and ""clearFileDescriptor()"" would possibly change the returned value, hence the Compatibility Issue type is 1."
34,<android.os.Parcel: T readParcelable(ClassLoader)>,17,18,<android.os.Parcel: T readParcelable(ClassLoader)>,<android.os.Parcel: T readParcelable(ClassLoader)>,0,"{
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<T> creator;
    synchronized (mCreators) {
        HashMap<String, Parcelable.Creator> map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<String, Parcelable.Creator>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
        if (creator == null) {
            try {
                Class c = loader == null ? Class.forName(name) : Class.forName(name, true, loader);
                Field f = c.getField(""CREATOR"");
                creator = (Parcelable.Creator) f.get(null);
            } catch (IllegalAccessException e) {
                Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name);
            } catch (ClassNotFoundException e) {
                Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name);
            } catch (ClassCastException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            } catch (NoSuchFieldException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            if (creator == null) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            map.put(name, creator);
        }
    }
    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {
        return ((Parcelable.ClassLoaderCreator<T>) creator).createFromParcel(this, loader);
    }
    return creator.createFromParcel(this);
}","{
    Parcelable.Creator<T> creator = readParcelableCreator(loader);
    if (creator == null) {
        return null;
    }
    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {
        return ((Parcelable.ClassLoaderCreator<T>) creator).createFromParcel(this, loader);
    }
    return creator.createFromParcel(this);
}",1,"/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
","/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"Many implementations in the early version have been changed and replaced by readParcelableCreator(loader) method call in the late version, which means both the internal processing statements and the dependent API have changed. Therefore, the code change types include 4 and 5.","Even though the implementation has changed significantly, it doesn't lead to a compatibility issue. This is because the main functionality, which is to return a value from the method readParcelable, remains the same, thus there's no compatibility issue."
35,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",17,18,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",0,"{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(activity, callback);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessageCallback(a, callback);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(activity, callback, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessageCallback(a, callback, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code &lt;meta-data>} element inside the {@code &lt;application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessageCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
","/**
 * Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code &lt;meta-data>} element inside the {@code &lt;application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessageCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent method setNdefPushMessageCallback's parameter has been changed from 2 to 3 parameters, so the code change type is 4,5.","Even though the parameter of dependent method setNdefPushMessageCallback has been changed, this code change doesn't alter the return values or exceptions thrown by this API, hence there is no Compatibility Issue."
38,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",17,18,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>","<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",0,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
","/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The provider.update() method has added a new parameter mPackageName and the return statement has depended on this change, so the types of code change are 1,5.","The change of dependent API might result in a different return value (rowsUpdated), therefore the type of Compatibility Issue is 1."
39,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",17,18,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>","<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",0,"{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    // TODO: Colors are ignored for now
    colors = null;
    colorOffset = 0;
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        checkRange(colors.length, colorOffset, count);
    }
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",2,"The control flow in the code has changed due to the introduction of a new 'if' statement checking if 'colors' is null. Moreover, the statement 'colors = null; colorOffset = 0;' has been removed. So, the change type is 3, 4.","The addition of the 'if' condition changes the behavior of the function, specifically, the function can now potentially throw an exception due to the 'checkRange' function. Therefore, the Compatibility Issue type is 2."
40,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",17,18,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        showWindow(true);
    }
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = onEvaluateInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, ""BadTokenException: IME is done."");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = onEvaluateInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * Handle a request by the system to show the soft input area.
 */
","/**
 * Handle a request by the system to show the soft input area.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"In the late version, the statement 'showWindow(true)' is enclosed in a try-catch block that was absent in the early version.","The introduced try-catch block in the late version is meant to catch a 'BadTokenException'. This can potentially lead to different exception handling between two versions, hence a compatibility issue (CI) caused by potential different exception handlings is detected, labeled as 2."
41,<android.text.format.DateFormat: DateFormat getTimeFormat(Context)>,17,18,<android.text.format.DateFormat: DateFormat getTimeFormat(Context)>,<android.text.format.DateFormat: DateFormat getTimeFormat(Context)>,0,"{
    boolean b24 = is24HourFormat(context);
    int res;
    if (b24) {
        res = R.string.twenty_four_hour_time_format;
    } else {
        res = R.string.twelve_hour_time_format;
    }
    return new java.text.SimpleDateFormat(context.getString(res));
}","{
    return new java.text.SimpleDateFormat(getTimeFormatString(context));
}",1,"/**
 * Returns a {@link java.text.DateFormat} object that can format the time according
 * to the current locale and the user's 12-/24-hour clock preference.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the time.
 */
","/**
 * Returns a {@link java.text.DateFormat} object that can format the time according
 * to the current locale and the user's 12-/24-hour clock preference.
 * @param context the application context
 * @return the {@link java.text.DateFormat} object that properly formats the time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has been simplified in the late version to create a new SimpleDateFormat object with the return value from the getTimeFormatString(context) method. In the early version, the SimpleDateFormat object was created by checking if the format is 24 hour or not and then getting the appropriate string resource. The dependent API has changed and the return statement has also been modified, so the code change type is 1,5.","The API return value could change in the late version as the time format string is now dependent on the getTimeFormatString(context) method, which can have different implementation than the boolean check for 24 hour format in early version. Therefore, the CI type is 1."
42,"<android.view.View: void postInvalidateDelayed(long,int,int,int,int)>",17,18,"<android.view.View: void postInvalidateDelayed(long,int,int,int,int)>","<android.view.View: void postInvalidateDelayed(long,int,int,int,int)>",0,"{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.acquire();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
    }
}","{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.obtain();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
    }
}",1,"/**
 * <p>Cause an invalidate of the specified area to happen on a subsequent cycle
 * through the event loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 *
 * @see #invalidate(int, int, int, int)
 * @see #invalidate(Rect)
 * @see #postInvalidate(int, int, int, int)
 */
","/**
 * <p>Cause an invalidate of the specified area to happen on a subsequent cycle
 * through the event loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 *
 * @see #invalidate(int, int, int, int)
 * @see #invalidate(Rect)
 * @see #postInvalidate(int, int, int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change from using the method 'acquire()' to 'obtain()' from the class AttachInfo.InvalidateInfo, which does not affect the invocation of the late version API method thus the code change type is 4,5.","The change is in a method that is used internally and does not affect the return value or exceptions thrown by the API, hence there is no Compatibility Issue."
43,<android.widget.ExpandableListView: void dispatchDraw(Canvas)>,17,18,<android.widget.ExpandableListView: void dispatchDraw(Canvas)>,<android.widget.ExpandableListView: void dispatchDraw(Canvas)>,0,"{
    // Draw children, etc.
    super.dispatchDraw(canvas);
    // If we have any indicators to draw, we do it here
    if ((mChildIndicator == null) && (mGroupIndicator == null)) {
        return;
    }
    int saveCount = 0;
    final boolean clipToPadding = (mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        saveCount = canvas.save();
        final int scrollX = mScrollX;
        final int scrollY = mScrollY;
        canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop, scrollX + mRight - mLeft - mPaddingRight, scrollY + mBottom - mTop - mPaddingBottom);
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int lastChildFlPos = mItemCount - getFooterViewsCount() - headerViewsCount - 1;
    final int myB = mBottom;
    PositionMetadata pos;
    View item;
    Drawable indicator;
    int t, b;
    // Start at a value that is neither child nor group
    int lastItemType = ~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
    final Rect indicatorRect = mIndicatorRect;
    // The ""child"" mentioned in the following two lines is this
    // View's child, not referring to an expandable list's
    // notion of a child (as opposed to a group)
    final int childCount = getChildCount();
    for (int i = 0, childFlPos = mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
        if (childFlPos < 0) {
            // This child is header
            continue;
        } else if (childFlPos > lastChildFlPos) {
            // This child is footer, so are all subsequent children
            break;
        }
        item = getChildAt(i);
        t = item.getTop();
        b = item.getBottom();
        // This item isn't on the screen
        if ((b < 0) || (t > myB))
            continue;
        // Get more expandable list-related info for this item
        pos = mConnector.getUnflattenedPos(childFlPos);
        // the left & right bounds
        if (pos.position.type != lastItemType) {
            if (pos.position.type == ExpandableListPosition.CHILD) {
                indicatorRect.left = (mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
                indicatorRect.right = (mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
            } else {
                indicatorRect.left = mIndicatorLeft;
                indicatorRect.right = mIndicatorRight;
            }
            indicatorRect.left += mPaddingLeft;
            indicatorRect.right += mPaddingLeft;
            lastItemType = pos.position.type;
        }
        if (indicatorRect.left != indicatorRect.right) {
            // Use item's full height + the divider height
            if (mStackFromBottom) {
                // See ListView#dispatchDraw
                // - mDividerHeight;
                indicatorRect.top = t;
                indicatorRect.bottom = b;
            } else {
                indicatorRect.top = t;
                // + mDividerHeight;
                indicatorRect.bottom = b;
            }
            // Get the indicator (with its state set to the item's state)
            indicator = getIndicator(pos);
            if (indicator != null) {
                // Draw the indicator
                indicator.setBounds(indicatorRect);
                indicator.draw(canvas);
            }
        }
        pos.recycle();
    }
    if (clipToPadding) {
        canvas.restoreToCount(saveCount);
    }
}","{
    // Draw children, etc.
    super.dispatchDraw(canvas);
    // If we have any indicators to draw, we do it here
    if ((mChildIndicator == null) && (mGroupIndicator == null)) {
        return;
    }
    int saveCount = 0;
    final boolean clipToPadding = (mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        saveCount = canvas.save();
        final int scrollX = mScrollX;
        final int scrollY = mScrollY;
        canvas.clipRect(scrollX + mPaddingLeft, scrollY + mPaddingTop, scrollX + mRight - mLeft - mPaddingRight, scrollY + mBottom - mTop - mPaddingBottom);
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int lastChildFlPos = mItemCount - getFooterViewsCount() - headerViewsCount - 1;
    final int myB = mBottom;
    PositionMetadata pos;
    View item;
    Drawable indicator;
    int t, b;
    // Start at a value that is neither child nor group
    int lastItemType = ~(ExpandableListPosition.CHILD | ExpandableListPosition.GROUP);
    final Rect indicatorRect = mIndicatorRect;
    // The ""child"" mentioned in the following two lines is this
    // View's child, not referring to an expandable list's
    // notion of a child (as opposed to a group)
    final int childCount = getChildCount();
    for (int i = 0, childFlPos = mFirstPosition - headerViewsCount; i < childCount; i++, childFlPos++) {
        if (childFlPos < 0) {
            // This child is header
            continue;
        } else if (childFlPos > lastChildFlPos) {
            // This child is footer, so are all subsequent children
            break;
        }
        item = getChildAt(i);
        t = item.getTop();
        b = item.getBottom();
        // This item isn't on the screen
        if ((b < 0) || (t > myB))
            continue;
        // Get more expandable list-related info for this item
        pos = mConnector.getUnflattenedPos(childFlPos);
        final boolean isLayoutRtl = isLayoutRtl();
        final int width = getWidth();
        // the left & right bounds
        if (pos.position.type != lastItemType) {
            if (pos.position.type == ExpandableListPosition.CHILD) {
                indicatorRect.left = (mChildIndicatorLeft == CHILD_INDICATOR_INHERIT) ? mIndicatorLeft : mChildIndicatorLeft;
                indicatorRect.right = (mChildIndicatorRight == CHILD_INDICATOR_INHERIT) ? mIndicatorRight : mChildIndicatorRight;
            } else {
                indicatorRect.left = mIndicatorLeft;
                indicatorRect.right = mIndicatorRight;
            }
            if (isLayoutRtl) {
                final int temp = indicatorRect.left;
                indicatorRect.left = width - indicatorRect.right;
                indicatorRect.right = width - temp;
                indicatorRect.left -= mPaddingRight;
                indicatorRect.right -= mPaddingRight;
            } else {
                indicatorRect.left += mPaddingLeft;
                indicatorRect.right += mPaddingLeft;
            }
            lastItemType = pos.position.type;
        }
        if (indicatorRect.left != indicatorRect.right) {
            // Use item's full height + the divider height
            if (mStackFromBottom) {
                // See ListView#dispatchDraw
                // - mDividerHeight;
                indicatorRect.top = t;
                indicatorRect.bottom = b;
            } else {
                indicatorRect.top = t;
                // + mDividerHeight;
                indicatorRect.bottom = b;
            }
            // Get the indicator (with its state set to the item's state)
            indicator = getIndicator(pos);
            if (indicator != null) {
                // Draw the indicator
                indicator.setBounds(indicatorRect);
                indicator.draw(canvas);
            }
        }
        pos.recycle();
    }
    if (clipToPadding) {
        canvas.restoreToCount(saveCount);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The late version has added two new variables 'isLayoutRtl' and 'width' which are not present in the early version. Additionally, new if-else control statements have been added, which causes changes to assignments for 'indicatorRect.left' and 'indicatorRect.right'. This indicates that both control dependency and other statements have changed, placing the code belong to types 3 and 4.","The change of control statements and assignments to 'indicatorRect.left' and 'indicatorRect.right' will affect the return value of the method 'dispatchDraw' as it determines the rectangle area to be drawn on the canvas. Thus, potentially, it can lead to a different display effect when drawing, which can be considered as a different return value. So, it falls into type 1 compatibility issue."
45,"<android.content.UriMatcher: void addURI(String,String,int)>",17,18,"<android.content.UriMatcher: void addURI(String,String,int)>","<android.content.UriMatcher: void addURI(String,String,int)>",0,"{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = path != null ? PATH_SPLIT_PATTERN.split(path) : null;
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals(""#"")) {
                child.mWhich = NUMBER;
            } else if (token.equals(""*"")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}","{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 0 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = PATH_SPLIT_PATTERN.split(newPath);
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals(""#"")) {
                child.mWhich = NUMBER;
            } else if (token.equals(""*"")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}",1,"/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
","/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"In the new implementation, some extra code was added to use the new variable 'newPath' and perform additional string operations on 'path' before splitting into tokens. Thus, the code change type is 3.","However, the change does not affect the logic of the function or create compatibility issues as the final tokens created still fall under the same conditions and execute the same logic in both versions. So, there's no Compatibility Issue (CI type: 0)."
46,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",17,18,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>","<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccount(account, password, userdata);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}",1,"/**
 * Adds an account directly to the AccountManager.  Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the added account's authenticator.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, or another error occurs.
 */
","/**
 * Adds an account directly to the AccountManager.  Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#AUTHENTICATE_ACCOUNTS}
 * and to have the same UID as the added account's authenticator.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, or another error occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement and dependent API have changed from mService.addAccount() to mService.addAccountExplicitly(), thus the code change type should be classified as 1,5.","Given that the method that is called in the return statement has changed between early and late versions, this potentially leads to different return values. Therefore, we have detected a compatibility issue of type 1."
48,<android.os.Debug: int getGlobalClassInitCount()>,17,18,<android.os.Debug: int getGlobalClassInitCount()>,<android.os.Debug: int getGlobalClassInitCount()>,0,"{
    /* number of classes that have been successfully initialized */
    return VMDebug.getAllocCount(VMDebug.KIND_GLOBAL_CLASS_INIT_COUNT);
}","{
    return VMDebug.getAllocCount(VMDebug.KIND_GLOBAL_CLASS_INIT_COUNT);
}",1,,"/**
 * Returns the number of classes successfully initialized (ie those that executed without
 * throwing an exception) between a {@link #startAllocCounting() start} and
 * {@link #stopAllocCounting() stop}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There exists no code change in the method implementation between the two versions.,No compatibility issue exists as there was no change made between the two versions of the method implementation.
50,<android.app.Activity: boolean navigateUpTo(Intent)>,17,18,<android.app.Activity: boolean navigateUpTo(Intent)>,<android.app.Activity: boolean navigateUpTo(Intent)>,0,"{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.setAllowFds(false);
        }
        try {
            return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}","{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess();
        }
        try {
            upIntent.prepareToLeaveProcess();
            return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}",1,"/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
","/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, the method 'prepareToLeaveProcess()' is called on the 'resultData' object and on 'upIntent', which is not occurred in the early version. So, the code change type is 4.","The change does not impact the return variables or the exception handling, thus there is no compatibility issue in the API between these two versions, and the CI type is 0."
52,<android.database.sqlite.SQLiteConnection.OperationLog: String describeCurrentOperation()>,17,18,<android.database.sqlite.SQLiteConnection.OperationLog: String describeCurrentOperation()>,<android.database.sqlite.SQLiteConnection.OperationLog: String describeCurrentOperation()>,0,"{
    synchronized (mOperations) {
        final Operation operation = mOperations[mIndex];
        if (operation != null && !operation.mFinished) {
            StringBuilder msg = new StringBuilder();
            operation.describe(msg);
            return msg.toString();
        }
        return null;
    }
}","{
    synchronized (mOperations) {
        final Operation operation = mOperations[mIndex];
        if (operation != null && !operation.mFinished) {
            StringBuilder msg = new StringBuilder();
            operation.describe(msg, false);
            return msg.toString();
        }
        return null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API (operation.describe) has changed by introducing a new parameter, so the code change type is 5.","The change in the dependent API's signature may affect its behavior and hence the return value of the method describeCurrentOperation(), so the CI type is 1."
54,<android.util.DisplayMetrics: boolean equals(DisplayMetrics)>,17,18,<android.util.DisplayMetrics: boolean equals(DisplayMetrics)>,<android.util.DisplayMetrics: boolean equals(DisplayMetrics)>,0,"{
    return other != null && widthPixels == other.widthPixels && heightPixels == other.heightPixels && density == other.density && densityDpi == other.densityDpi && scaledDensity == other.scaledDensity && xdpi == other.xdpi && ydpi == other.ydpi && noncompatWidthPixels == other.noncompatWidthPixels && noncompatHeightPixels == other.noncompatHeightPixels && noncompatDensity == other.noncompatDensity && noncompatDensityDpi == other.noncompatDensityDpi && noncompatScaledDensity == other.noncompatScaledDensity && noncompatXdpi == other.noncompatXdpi && noncompatYdpi == other.noncompatYdpi;
}","{
    return equalsPhysical(other) && scaledDensity == other.scaledDensity && noncompatScaledDensity == other.noncompatScaledDensity;
}",1,"/**
 * Returns true if these display metrics equal the other display metrics.
 *
 * @param other The display metrics with which to compare.
 * @return True if the display metrics are equal.
 */
","/**
 * Returns true if these display metrics equal the other display metrics.
 *
 * @param other The display metrics with which to compare.
 * @return True if the display metrics are equal.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the code has been changed to call a different method equalsPhysical(other) instead of directly comparing individual attributes. The dependent API equalsPhysical() also represents a new introduction, making the change type as 1,5.","The return value of this API in the late version could be different, depending on the definition and behavior of the equalsPhysical() method, as compared to the earlier direct comparison of individual fields. Hence, the Compatibility Issue type is 1."
55,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",17,18,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>","<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",0,"{
    try {
        return mContentProvider.openTypedAssetFile(uri, mimeType, opts);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
","/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mContentProvider.openTypedAssetFile(uri, mimeType, opts) to mContentProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts) and the parameters of the method call mContentProvider.openTypedAssetFile have changed, so the code change type is 1,5.",The change of return statement will make the API potentially return a different value and therefore CI type is 1.
56,<android.content.ClipboardManager: boolean hasPrimaryClip()>,17,18,<android.content.ClipboardManager: boolean hasPrimaryClip()>,<android.content.ClipboardManager: boolean hasPrimaryClip()>,0,"{
    try {
        return getService().hasPrimaryClip();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return getService().hasPrimaryClip(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
","/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement got changed 'getService().hasPrimaryClip()' is modified to 'getService().hasPrimaryClip(mContext.getBasePackageName())' and the parameters of 'getService().hasPrimaryClip()' method also got changed, hence the code change type is 1,5.","The change to the return statement can potentially cause the method to return different values, thus the CI type is 1."
58,<android.app.ActivityThread.H: String codeToString(int)>,17,18,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ACTIVITY_EXTRAS:
                return ""REQUEST_ACTIVITY_EXTRAS"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"In late version, there is a new case REQUEST_ACTIVITY_EXTRAS added to the switch block in the implementation of the function which will lead to a new return value. So, the change type is 1. ","The new added case in the late version could alter the return value of the function from what it was in the early version. Therefore, the compatibility issue type is 1. It will return a different value upon receiving the input 'REQUEST_ACTIVITY_EXTRAS' as its parameter."
62,<android.webkit.AccessibilityInjector.TextToSpeechWrapper: int stop()>,17,18,<android.webkit.AccessibilityInjector.TextToSpeechWrapper: int stop()>,<android.webkit.AccessibilityInjector.TextToSpeechWrapper: int stop()>,0,"{
    synchronized (mTextToSpeech) {
        if (!mReady) {
            if (DEBUG) {
                Log.w(WRAP_TAG, ""["" + hashCode() + ""] Attempted to stop before initialize"");
            }
            return TextToSpeech.ERROR;
        } else {
            if (DEBUG) {
                Log.i(WRAP_TAG, ""["" + hashCode() + ""] Stop called from JS binder"");
            }
        }
        return mTextToSpeech.stop();
    }
}","{
    synchronized (mTtsLock) {
        if (!mReady) {
            if (DEBUG) {
                Log.w(WRAP_TAG, ""["" + hashCode() + ""] Attempted to stop before initialize"");
            }
            return TextToSpeech.ERROR;
        } else {
            if (DEBUG) {
                Log.i(WRAP_TAG, ""["" + hashCode() + ""] Stop called from JS binder"");
            }
        }
        return mTextToSpeech.stop();
    }
}",1,,,-1,"[@JavascriptInterface, @SuppressWarnings(""unused"")]","[@JavascriptInterface, @SuppressWarnings(""unused"")]",-1,-1,-1,-1,-1,-1,4,0,"The object which is used for the synchronization has changed from mTextToSpeech to mTtsLock. This change is neither part of return, control dependency, nor it is a change in the dependent API. Therefore, it falls under the ""Other statement changed"" category.","The change is limited to synchronization object and does not affect the return value or exception handling behavior. Therefore, there is no compatibility issue."
63,"<android.view.GLES20Canvas: boolean clipPath(Path,Op)>",17,18,"<android.view.GLES20Canvas: boolean clipPath(Path,Op)>","<android.view.GLES20Canvas: boolean clipPath(Path,Op)>",0,"{
    // TODO: Implement
    path.computeBounds(mPathBounds, true);
    return nClipRect(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom, op.nativeInt);
}","{
    return nClipPath(mRenderer, path.mNativePath, op.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the method has changed - it does not process path and bounds anymore, but directly passes parameters into nClipPath() function. Thus, it is both a return statement change and an ""other statement"" change.","Since the return statement has been directly changed (it now directly uses nClipPath() instead of nClipRect() and doesn't process path and bounds), this could lead to returning different values compared to the previous implementation. So, this is a compatibility issue caused by potential different return values or types."
65,<android.widget.TextView: boolean bringPointIntoView(int)>,17,18,<android.widget.TextView: boolean bringPointIntoView(int)>,<android.widget.TextView: boolean bringPointIntoView(int)>,0,"{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(layout.getLineLeft(line));
    int right = (int) FloatMath.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}","{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    // We only want to clamp the cursor to fit within the layout width
    // in left-to-right modes, because in a right to left alignment,
    // we want to scroll to keep the line-right on the screen, as other
    // lines are likely to have text flush with the right margin, which
    // we want to keep visible.
    // A better long-term solution would probably be to measure both
    // the full line and a blank-trimmed version, and, for example, use
    // the latter measurement for centering and right alignment, but for
    // the time being we only implement the cursor clamping in left to
    // right where it is most likely to be annoying.
    final boolean clamped = grav > 0;
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset, clamped);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(layout.getLineLeft(line));
    int right = (int) FloatMath.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    if (!mHorizontallyScrolling && right - left > hspace && right > x) {
        // If cursor has been clamped, make sure we don't scroll.
        right = Math.max(x, left + hspace);
    }
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
66,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",17,18,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>","<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",0,"{
    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Don't put header or footer views or views that should be ignored
    // into the scrap heap
    int viewType = lp.viewType;
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
        if (scrapHasTransientState) {
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            scrap.dispatchStartTemporaryDetach();
            mTransientStateViews.put(position, scrap);
        }
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    if (mViewTypeCount == 1) {
        mCurrentScrap.add(scrap);
    } else {
        mScrapViews[viewType].add(scrap);
    }
    scrap.setAccessibilityDelegate(null);
    if (mRecyclerListener != null) {
        mRecyclerListener.onMovedToScrapHeap(scrap);
    }
}","{
    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Don't put header or footer views or views that should be ignored
    // into the scrap heap
    int viewType = lp.viewType;
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
        if (scrapHasTransientState) {
            scrap.dispatchStartTemporaryDetach();
            if (mAdapter != null && mAdapterHasStableIds) {
                if (mTransientStateViewsById == null) {
                    mTransientStateViewsById = new LongSparseArray<View>();
                }
                mTransientStateViewsById.put(lp.itemId, scrap);
            } else if (!mDataChanged) {
                // the layout positions may be out of sync with the adapter positions
                if (mTransientStateViews == null) {
                    mTransientStateViews = new SparseArray<View>();
                }
                mTransientStateViews.put(position, scrap);
            }
        }
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    if (mViewTypeCount == 1) {
        mCurrentScrap.add(scrap);
    } else {
        mScrapViews[viewType].add(scrap);
    }
    scrap.setAccessibilityDelegate(null);
    if (mRecyclerListener != null) {
        mRecyclerListener.onMovedToScrapHeap(scrap);
    }
}",1,"/**
 * Put a view into the ScrapViews list. These views are unordered.
 *
 * @param scrap The view to add
 */
","/**
 * Put a view into the ScrapViews list. These views are unordered.
 *
 * @param scrap The view to add
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition changed from ""viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState"" to ""viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState"". Another block of statement has been introduced for handling mTransientStateViewsById. The change types are 3 (control dependency change) and 4 (other statement changed).","The alteration in if condition and addition of the block to handle mTransietStateViewsById potentially alter the method's behavior and potentially make it return differently. Therefore, the compatibility issue type is 1."
67,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",17,18,"<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>","<android.app.backup.BackupAgent: void fullBackupFile(File,FullBackupDataOutput)>",0,"{
    // Look up where all of our various well-defined dir trees live on this device
    String mainDir;
    String filesDir;
    String dbDir;
    String spDir;
    String cacheDir;
    String libDir;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        mainDir = new File(appInfo.dataDir).getCanonicalPath();
        filesDir = getFilesDir().getCanonicalPath();
        dbDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
        cacheDir = getCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib and cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(libDir)) {
        Log.w(TAG, ""lib and cache files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.DATA_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(mainDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = mainDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // And now that we know where it lives, semantically, back it up appropriately
    Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output.getData());
}","{
    // Look up where all of our various well-defined dir trees live on this device
    String mainDir;
    String filesDir;
    String dbDir;
    String spDir;
    String cacheDir;
    String libDir;
    String efDir = null;
    String filePath;
    ApplicationInfo appInfo = getApplicationInfo();
    try {
        mainDir = new File(appInfo.dataDir).getCanonicalPath();
        filesDir = getFilesDir().getCanonicalPath();
        dbDir = getDatabasePath(""foo"").getParentFile().getCanonicalPath();
        spDir = getSharedPrefsFile(""foo"").getParentFile().getCanonicalPath();
        cacheDir = getCacheDir().getCanonicalPath();
        libDir = (appInfo.nativeLibraryDir == null) ? null : new File(appInfo.nativeLibraryDir).getCanonicalPath();
        // may or may not have external files access to attempt backup/restore there
        if (Process.myUid() != Process.SYSTEM_UID) {
            File efLocation = getExternalFilesDir(null);
            if (efLocation != null) {
                efDir = efLocation.getCanonicalPath();
            }
        }
        // Now figure out which well-defined tree the file is placed in, working from
        // most to least specific.  We also specifically exclude the lib and cache dirs.
        filePath = file.getCanonicalPath();
    } catch (IOException e) {
        Log.w(TAG, ""Unable to obtain canonical paths"");
        return;
    }
    if (filePath.startsWith(cacheDir) || filePath.startsWith(libDir)) {
        Log.w(TAG, ""lib and cache files are not backed up"");
        return;
    }
    final String domain;
    String rootpath = null;
    if (filePath.startsWith(dbDir)) {
        domain = FullBackup.DATABASE_TREE_TOKEN;
        rootpath = dbDir;
    } else if (filePath.startsWith(spDir)) {
        domain = FullBackup.SHAREDPREFS_TREE_TOKEN;
        rootpath = spDir;
    } else if (filePath.startsWith(filesDir)) {
        domain = FullBackup.DATA_TREE_TOKEN;
        rootpath = filesDir;
    } else if (filePath.startsWith(mainDir)) {
        domain = FullBackup.ROOT_TREE_TOKEN;
        rootpath = mainDir;
    } else if ((efDir != null) && filePath.startsWith(efDir)) {
        domain = FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
        rootpath = efDir;
    } else {
        Log.w(TAG, ""File "" + filePath + "" is in an unsupported location; skipping"");
        return;
    }
    // And now that we know where it lives, semantically, back it up appropriately
    Log.i(TAG, ""backupFile() of "" + filePath + "" => domain="" + domain + "" rootpath="" + rootpath);
    FullBackup.backupToTar(getPackageName(), domain, null, rootpath, filePath, output.getData());
}",1,"/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
","/**
 * Write an entire file as part of a full-backup operation.  The file's contents
 * will be delivered to the backup destination along with the metadata necessary
 * to place it with the proper location and permissions on the device where the
 * data is restored.
 *
 * @param file The file to be backed up.  The file must exist and be readable by
 * the caller.
 * @param output The destination to which the backed-up file data will be sent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, a new variable 'efDir' is added and a new condition checking if filePath starts with efDir is included in the source code. This results in the Control dependency change (change type 3) and other statements changed (change type 4).","The addition of the new condition checking can potentially make the system backup a file in the different domain, which in turn can change the return of the method FullBackup.backupToTar(). This indicates that the API may return different values, hence the CI type is 1."
68,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",17,18,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            intent.setAllowFds(false);
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the try block, the statements and the parameter variations of the method startActivity() in ActivityManagerNative.getDefault() have been changed. The intent.setAllowFds(false), which is in early implementation, has been replaced by intent.migrateExtraStreamToClipData() and intent.prepareToLeaveProcess() method in the late implementation. Also, the startActivity() method is introduced with the new parameter getBasePackageName() in the late implementation rather than the earlier one, which makes the type as 1,5.","Since the parameters of the dependent method 'startActivity()' have changed, the method might return different values for similar inputs. Thus, the change could potentially lead to a Compatibility Issue, with the CI type being 1."
69,<android.speech.tts.TextToSpeech: void shutdown()>,17,18,<android.speech.tts.TextToSpeech: void shutdown()>,<android.speech.tts.TextToSpeech: void shutdown()>,0,"{
    runActionNoReconnect(new Action<Void>() {

        @Override
        public Void run(ITextToSpeechService service) throws RemoteException {
            service.setCallback(getCallerIdentity(), null);
            service.stop(getCallerIdentity());
            mServiceConnection.disconnect();
            // Context#unbindService does not result in a call to
            // ServiceConnection#onServiceDisconnected. As a result, the
            // service ends up being destroyed (if there are no other open
            // connections to it) but the process lives on and the
            // ServiceConnection continues to refer to the destroyed service.
            // 
            // This leads to tons of log spam about SynthThread being dead.
            mServiceConnection = null;
            mCurrentEngine = null;
            return null;
        }
    }, null, ""shutdown"");
}","{
    // Special case, we are asked to shutdown connection that did finalize its connection.
    synchronized (mStartLock) {
        if (mConnectingServiceConnection != null) {
            mContext.unbindService(mConnectingServiceConnection);
            mConnectingServiceConnection = null;
            return;
        }
    }
    // Post connection case
    runActionNoReconnect(new Action<Void>() {

        @Override
        public Void run(ITextToSpeechService service) throws RemoteException {
            service.setCallback(getCallerIdentity(), null);
            service.stop(getCallerIdentity());
            mServiceConnection.disconnect();
            // Context#unbindService does not result in a call to
            // ServiceConnection#onServiceDisconnected. As a result, the
            // service ends up being destroyed (if there are no other open
            // connections to it) but the process lives on and the
            // ServiceConnection continues to refer to the destroyed service.
            // 
            // This leads to tons of log spam about SynthThread being dead.
            mServiceConnection = null;
            mCurrentEngine = null;
            return null;
        }
    }, null, ""shutdown"", false);
}",1,"/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
","/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,1",1,"Additional control statements are introduced, and new statements altering the mConnectingServiceConnection object have been added. Also, a new return statement has been introduced in line 12. Hence, the change types are 3, 4 and 1.","The additional control condition and the new return statement introduce a new path where the function could potentially end earlier without executing the rest of the code, hence the CI type is 1."
70,<android.view.Surface: void readFromParcel(Parcel)>,17,18,<android.view.Surface: void readFromParcel(Parcel)>,<android.view.Surface: void readFromParcel(Parcel)>,0,"{
    if (source == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    mName = source.readString();
    nativeReadFromParcel(source);
}","{
    if (source == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    synchronized (mLock) {
        mName = source.readString();
        setNativeObjectLocked(nativeReadFromParcel(mNativeSurface, source));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code changes include an additional synchronization block along with a modification of the method that is called during this process. The changes fall under the category of ""Other statement changed"".","Even though the underlying implementation has changed, the function behavior and its output has not been altered. The changes made only involve how the system handles the read operation internally, not impacting what is returned or any exceptions thrown. Hence, there are no compatibility issues between these two versions."
71,"<android.text.method.DigitsKeyListener: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",17,18,"<android.text.method.DigitsKeyListener: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.text.method.DigitsKeyListener: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,"{
    CharSequence out = super.filter(source, start, end, dest, dstart, dend);
    if (mSign == false && mDecimal == false) {
        return out;
    }
    if (out != null) {
        source = out;
        start = 0;
        end = out.length();
    }
    int sign = -1;
    int decimal = -1;
    int dlen = dest.length();
    for (int i = 0; i < dstart; i++) {
        char c = dest.charAt(i);
        if (c == '-') {
            sign = i;
        } else if (c == '.') {
            decimal = i;
        }
    }
    for (int i = dend; i < dlen; i++) {
        char c = dest.charAt(i);
        if (c == '-') {
            // Nothing can be inserted in front of a '-'.
            return """";
        } else if (c == '.') {
            decimal = i;
        }
    }
    /*
         * If it does, we must strip them out from the source.
         * In addition, '-' must be the very first character,
         * and nothing can be inserted before an existing '-'.
         * Go in reverse order so the offsets are stable.
         */
    SpannableStringBuilder stripped = null;
    for (int i = end - 1; i >= start; i--) {
        char c = source.charAt(i);
        boolean strip = false;
        if (c == '-') {
            if (i != start || dstart != 0) {
                strip = true;
            } else if (sign >= 0) {
                strip = true;
            } else {
                sign = i;
            }
        } else if (c == '.') {
            if (decimal >= 0) {
                strip = true;
            } else {
                decimal = i;
            }
        }
        if (strip) {
            if (end == start + 1) {
                // Only one character, and it was stripped.
                return """";
            }
            if (stripped == null) {
                stripped = new SpannableStringBuilder(source, start, end);
            }
            stripped.delete(i - start, i + 1 - start);
        }
    }
    if (stripped != null) {
        return stripped;
    } else if (out != null) {
        return out;
    } else {
        return null;
    }
}","{
    CharSequence out = super.filter(source, start, end, dest, dstart, dend);
    if (mSign == false && mDecimal == false) {
        return out;
    }
    if (out != null) {
        source = out;
        start = 0;
        end = out.length();
    }
    int sign = -1;
    int decimal = -1;
    int dlen = dest.length();
    for (int i = 0; i < dstart; i++) {
        char c = dest.charAt(i);
        if (isSignChar(c)) {
            sign = i;
        } else if (isDecimalPointChar(c)) {
            decimal = i;
        }
    }
    for (int i = dend; i < dlen; i++) {
        char c = dest.charAt(i);
        if (isSignChar(c)) {
            // Nothing can be inserted in front of a sign character.
            return """";
        } else if (isDecimalPointChar(c)) {
            decimal = i;
        }
    }
    /*
         * If it does, we must strip them out from the source.
         * In addition, a sign character must be the very first character,
         * and nothing can be inserted before an existing sign character.
         * Go in reverse order so the offsets are stable.
         */
    SpannableStringBuilder stripped = null;
    for (int i = end - 1; i >= start; i--) {
        char c = source.charAt(i);
        boolean strip = false;
        if (isSignChar(c)) {
            if (i != start || dstart != 0) {
                strip = true;
            } else if (sign >= 0) {
                strip = true;
            } else {
                sign = i;
            }
        } else if (isDecimalPointChar(c)) {
            if (decimal >= 0) {
                strip = true;
            } else {
                decimal = i;
            }
        }
        if (strip) {
            if (end == start + 1) {
                // Only one character, and it was stripped.
                return """";
            }
            if (stripped == null) {
                stripped = new SpannableStringBuilder(source, start, end);
            }
            stripped.delete(i - start, i + 1 - start);
        }
    }
    if (stripped != null) {
        return stripped;
    } else if (out != null) {
        return out;
    } else {
        return null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"Here, condition checks have replaced the static character checks for '-' and '.' with method calls: isSignChar(c) and isDecimalPointChar(c). So, the code change types are 4,5.","The result of the new method calls: isSignChar(c) and isDecimalPointChar(c) may not always match the original static character checks for '-' and '.', therefore, this may lead to different return values in the late version, causing CI type of 1."
72,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",17,18,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, true, true, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method called on the 'intent' object is changed from setAllowFds(false) to prepareToLeaveProcess(), and the parameters of the method call 'broadcastIntent' also slightly changed. hence, the change type is 4 and 5.","As the change in the method 'prepareToLeaveProcess' and 'broadcastIntent' can potentially lead to different behaviour, so CI type is 1."
73,"<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>",17,18,"<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // sense, do they mean to set a PendingIntent template for the AdapterView's children?
    if (mIsWidgetCollectionChild) {
        Log.w(""RemoteViews"", ""Cannot setOnClickPendingIntent for collection item "" + ""(id: "" + viewId + "")"");
        ApplicationInfo appInfo = root.getContext().getApplicationInfo();
        // been disabled from the outset, but was left open by accident.
        if (appInfo != null && appInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
            return;
        }
    }
    if (target != null) {
        // If the pendingIntent is null, we clear the onClickListener
        OnClickListener listener = null;
        if (pendingIntent != null) {
            listener = new OnClickListener() {

                public void onClick(View v) {
                    // Find target view location in screen coordinates and
                    // fill into PendingIntent before sending.
                    final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                    final int[] pos = new int[2];
                    v.getLocationOnScreen(pos);
                    final Rect rect = new Rect();
                    rect.left = (int) (pos[0] * appScale + 0.5f);
                    rect.top = (int) (pos[1] * appScale + 0.5f);
                    rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                    rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(v, pendingIntent, intent);
                }
            };
        }
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // sense, do they mean to set a PendingIntent template for the AdapterView's children?
    if (mIsWidgetCollectionChild) {
        Log.w(LOG_TAG, ""Cannot setOnClickPendingIntent for collection item "" + ""(id: "" + viewId + "")"");
        ApplicationInfo appInfo = root.getContext().getApplicationInfo();
        // been disabled from the outset, but was left open by accident.
        if (appInfo != null && appInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
            return;
        }
    }
    if (target != null) {
        // If the pendingIntent is null, we clear the onClickListener
        OnClickListener listener = null;
        if (pendingIntent != null) {
            listener = new OnClickListener() {

                public void onClick(View v) {
                    // Find target view location in screen coordinates and
                    // fill into PendingIntent before sending.
                    final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                    final int[] pos = new int[2];
                    v.getLocationOnScreen(pos);
                    final Rect rect = new Rect();
                    rect.left = (int) (pos[0] * appScale + 0.5f);
                    rect.top = (int) (pos[1] * appScale + 0.5f);
                    rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                    rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(v, pendingIntent, intent);
                }
            };
        }
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The value of the parameter in a Log statement has changed from ""RemoteViews"" to LOG_TAG. This is a minor change not fitting into other change categories, thus classified under 'Other statement changed' (4).","This string substitution change in the log print statement doesn't affect the API return value or the exceptions it throws, thereby not causing a compatibility issue (0)."
74,"<android.view.GLES20Canvas: boolean quickReject(float,float,float,float,EdgeType)>",17,18,"<android.view.GLES20Canvas: boolean quickReject(float,float,float,float,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(float,float,float,float,EdgeType)>",0,"{
    return nQuickReject(mRenderer, left, top, right, bottom, type.nativeInt);
}","{
    return nQuickReject(mRenderer, left, top, right, bottom);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call in the return statement changed, it used to pass 'type.nativeInt' to 'nQuickReject', which is removed in the late version. So, the code change type is 1,5.","As the method call used in the return statement is changed, the returned value may change in the late version, causing potential CI. Therefore, the CI type is 1."
75,<android.view.accessibility.AccessibilityNodeInfo: boolean isClickable()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isClickable()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isClickable()>,0,"{
    return getBooleanProperty(PROPERTY_CLICKABLE);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_CLICKABLE);
}",1,"/**
 * Gets whether this node is clickable.
 *
 * @return True if the node is clickable.
 */
","/**
 * Gets whether this node is clickable.
 *
 * @return True if the node is clickable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter of getBooleanProperty() function has changed from PROPERTY_CLICKABLE to BOOLEAN_PROPERTY_CLICKABLE, so the code change type is 1,5.","As the parameter in the return statement has changed, it may subsequently lead to different return values, thus the CI type is 1."
76,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,17,18,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final View child = children[i];
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    lastHoverTarget = hoverTarget;
                    mFirstHoverTarget = hoverTarget;
                }
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}","{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final boolean customChildOrder = isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = customChildOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = children[childIndex];
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    lastHoverTarget = hoverTarget;
                    mFirstHoverTarget = hoverTarget;
                }
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@SuppressWarnings({ ""ConstantConditions"" }), @Override]","[@SuppressWarnings({ ""ConstantConditions"" }), @Override]",-1,-1,-1,-1,-1,-1,,,,
77,"<android.webkit.WebViewClassic: void setNewPicture(DrawData,boolean)>",17,18,"<android.webkit.WebViewClassic: void setNewPicture(DrawData,boolean)>","<android.webkit.WebViewClassic: void setNewPicture(DrawData,boolean)>",0,"{
    if (mNativeClass == 0) {
        if (mDelaySetPicture != null) {
            throw new IllegalStateException(""Tried to setNewPicture with"" + "" a delay picture already set! (memory leak)"");
        }
        // Not initialized yet, delay set
        mDelaySetPicture = draw;
        return;
    }
    WebViewCore.ViewState viewState = draw.mViewState;
    boolean isPictureAfterFirstLayout = viewState != null;
    if (updateBaseLayer) {
        setBaseLayer(draw.mBaseLayer, getSettings().getShowVisualIndicator(), isPictureAfterFirstLayout);
    }
    final Point viewSize = draw.mViewSize;
    // We update the layout (i.e. request a layout from the
    // view system) if the last view size that we sent to
    // WebCore matches the view size of the picture we just
    // received in the fixed dimension.
    final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
    // Don't send scroll event for picture coming from webkit,
    // since the new picture may cause a scroll event to override
    // the saved history scroll position.
    mSendScrollEvent = false;
    recordNewContentSize(draw.mContentSize.x, draw.mContentSize.y, updateLayout);
    if (isPictureAfterFirstLayout) {
        // Reset the last sent data here since dealing with new page.
        mLastWidthSent = 0;
        mZoomManager.onFirstLayout(draw);
        int scrollX = viewState.mShouldStartScrolledRight ? getContentWidth() : viewState.mScrollX;
        int scrollY = viewState.mScrollY;
        contentScrollTo(scrollX, scrollY, false);
        if (!mDrawHistory) {
            // As we are on a new page, hide the keyboard
            hideSoftKeyboard();
        }
    }
    mSendScrollEvent = true;
    int functor = 0;
    boolean forceInval = isPictureAfterFirstLayout;
    ViewRootImpl viewRoot = mWebView.getViewRootImpl();
    if (mWebView.isHardwareAccelerated() && mWebView.getLayerType() != View.LAYER_TYPE_SOFTWARE && viewRoot != null) {
        functor = nativeGetDrawGLFunction(mNativeClass);
        if (functor != 0) {
            // force an invalidate if functor attach not successful
            forceInval |= !viewRoot.attachFunctor(functor);
        }
    }
    if (functor == 0 || forceInval || mWebView.getLayerType() != View.LAYER_TYPE_NONE) {
        // invalidate the screen so that the next repaint will show new content
        // TODO: partial invalidate
        mWebView.invalidate();
    }
    // update the zoom information based on the new picture
    if (mZoomManager.onNewPicture(draw))
        invalidate();
    if (isPictureAfterFirstLayout) {
        mViewManager.postReadyToDrawAll();
    }
    scrollEditWithCursor();
    if (mPictureListener != null) {
        if (!mWebView.isHardwareAccelerated() || mWebView.getLayerType() == View.LAYER_TYPE_SOFTWARE) {
            // trigger picture listener for software layers. Hardware layers are
            // triggered in pageSwapCallback
            mPictureListener.onNewPicture(getWebView(), capturePicture());
        }
    }
}","{
    if (mNativeClass == 0) {
        if (mDelaySetPicture != null) {
            throw new IllegalStateException(""Tried to setNewPicture with"" + "" a delay picture already set! (memory leak)"");
        }
        // Not initialized yet, delay set
        mDelaySetPicture = draw;
        return;
    }
    WebViewCore.ViewState viewState = draw.mViewState;
    boolean isPictureAfterFirstLayout = viewState != null;
    if (updateBaseLayer) {
        setBaseLayer(draw.mBaseLayer, getSettings().getShowVisualIndicator(), isPictureAfterFirstLayout);
    }
    final Point viewSize = draw.mViewSize;
    // We update the layout (i.e. request a layout from the
    // view system) if the last view size that we sent to
    // WebCore matches the view size of the picture we just
    // received in the fixed dimension.
    final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
    // Don't send scroll event for picture coming from webkit,
    // since the new picture may cause a scroll event to override
    // the saved history scroll position.
    mSendScrollEvent = false;
    recordNewContentSize(draw.mContentSize.x, draw.mContentSize.y, updateLayout);
    if (isPictureAfterFirstLayout) {
        // Reset the last sent data here since dealing with new page.
        mLastWidthSent = 0;
        mZoomManager.onFirstLayout(draw);
        int scrollX = viewState.mShouldStartScrolledRight ? getContentWidth() : viewState.mScrollX;
        int scrollY = viewState.mScrollY;
        contentScrollTo(scrollX, scrollY, false);
        if (!mDrawHistory) {
            // As we are on a new page, hide the keyboard
            hideSoftKeyboard();
        }
    }
    mSendScrollEvent = true;
    int functor = 0;
    boolean forceInval = isPictureAfterFirstLayout;
    ViewRootImpl viewRoot = mWebView.getViewRootImpl();
    if (mWebView.isHardwareAccelerated() && mWebView.getLayerType() != View.LAYER_TYPE_SOFTWARE && viewRoot != null) {
        functor = nativeGetDrawGLFunction(mNativeClass);
        if (functor != 0) {
            // force an invalidate if functor attach not successful
            forceInval |= !viewRoot.attachFunctor(functor);
        }
    }
    if (functor == 0 || forceInval || mWebView.getLayerType() != View.LAYER_TYPE_NONE) {
        // invalidate the screen so that the next repaint will show new content
        // TODO: partial invalidate
        mWebView.invalidate();
    }
    // update the zoom information based on the new picture
    if (mZoomManager.onNewPicture(draw))
        invalidate();
    if (isPictureAfterFirstLayout) {
        mViewManager.postReadyToDrawAll();
    }
    scrollEditWithCursor();
    if (mPictureListener != null) {
        if (!mWebView.isHardwareAccelerated() || mWebView.getLayerType() == View.LAYER_TYPE_SOFTWARE) {
            // trigger picture listener for software layers. Hardware layers are
            // triggered in pageSwapCallback
            Picture picture = mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.JELLY_BEAN_MR2 ? capturePicture() : null;
            mPictureListener.onNewPicture(getWebView(), picture);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The code change is for this block of code:,"mPictureListener.onNewPicture(getWebView(), picture);"
78,"<android.view.HardwareRenderer.GlRenderer: boolean attachFunctor(AttachInfo,int)>",17,18,"<android.view.HardwareRenderer.GlRenderer: boolean attachFunctor(AttachInfo,int)>","<android.view.HardwareRenderer.GlRenderer: boolean attachFunctor(AttachInfo,int)>",0,"{
    if (mCanvas != null) {
        mCanvas.attachFunctor(functor);
        scheduleFunctors(attachInfo, false);
        return true;
    }
    return false;
}","{
    if (mCanvas != null) {
        mCanvas.attachFunctor(functor);
        mFunctorsRunnable.attachInfo = attachInfo;
        attachInfo.mHandler.removeCallbacks(mFunctorsRunnable);
        attachInfo.mHandler.postDelayed(mFunctorsRunnable, 0);
        return true;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The 'scheduleFunctors(attachInfo, false);' statement has been replaced with four different lines of code involving 'mFunctorsRunnable', 'attachInfo.mHandler', and calling methods 'removeCallbacks()' and 'postDelayed()' on it. The differences include control dependency change (the original method call and the new method calls have different conditions), and other statements change (new instances for objects and new method calls), so this code change type is categorized as 1,3,4.","These changes affect the flow control and execution of this method attachFunctor(). Even though the return type is a boolean and the returned values for both versions are true or false, the condition to return true has changed. The 'return true' statement is inside the conditional block which checks that mCanvas isn't null, however, as there are changes in this conditional block (the function that gets called when mCanvas isn't null has changed), it can lead to the fact that in the same condition, the method could potentially return different values in the early and late version of the API, which is a compatibility issue, type 1."
79,"<android.webkit.WebViewClassic: boolean showFindDialog(String,boolean)>",17,18,"<android.webkit.WebViewClassic: boolean showFindDialog(String,boolean)>","<android.webkit.WebViewClassic: boolean showFindDialog(String,boolean)>",0,"{
    FindActionModeCallback callback = new FindActionModeCallback(mContext);
    if (mWebView.getParent() == null || mWebView.startActionMode(callback) == null) {
        // Could not start the action mode, so end Find on page
        return false;
    }
    mCachedOverlappingActionModeHeight = -1;
    mFindCallback = callback;
    setFindIsUp(true);
    mFindCallback.setWebView(this);
    if (showIme) {
        mFindCallback.showSoftInput();
    } else if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
        return true;
    }
    if (text == null) {
        text = mFindRequest == null ? null : mFindRequest.mSearchText;
    }
    if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
    }
    return true;
}","{
    FindActionModeCallback callback = new FindActionModeCallback(mContext);
    if (mWebView.getParent() == null || mWebView.startActionMode(callback) == null) {
        // Could not start the action mode, so end Find on page
        return false;
    }
    mCachedOverlappingActionModeHeight = -1;
    mFindCallback = callback;
    setFindIsUp(true);
    mFindCallback.setWebView(getWebView());
    if (showIme) {
        mFindCallback.showSoftInput();
    } else if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
        return true;
    }
    if (text == null) {
        text = mFindRequest == null ? null : mFindRequest.mSearchText;
    }
    if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
    }
    return true;
}",1,"/**
 * Start an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 * @param text If non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme If true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return boolean True if the find dialog is shown, false otherwise.
 */
","/**
 * Start an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 * @param text If non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme If true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return boolean True if the find dialog is shown, false otherwise.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The code change is at the line ""mFindCallback.setWebView(this);"" to ""mFindCallback.setWebView(getWebView());"", where 'this' has been changed to 'getWebView()'. The source of method 'setWebView' has also changed, so the types are 4,5.","The change in the 'setWebView' method can lead to the 'return true' result changing, causing a difference in return behaviour and thus causing a Compatibility Issue. The CI type is 1."
81,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>",17,18,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>","<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>",0,"{
    String path = file.getPath();
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(path);
        if ((mode & MODE_WRITE_ONLY) != 0) {
            security.checkWrite(path);
        }
    }
    if ((mode & MODE_READ_WRITE) == 0) {
        throw new IllegalArgumentException(""Must specify MODE_READ_ONLY, MODE_WRITE_ONLY, or MODE_READ_WRITE"");
    }
    FileDescriptor fd = Parcel.openFileDescriptor(path, mode);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}","{
    String path = file.getPath();
    if ((mode & MODE_READ_WRITE) == 0) {
        throw new IllegalArgumentException(""Must specify MODE_READ_ONLY, MODE_WRITE_ONLY, or MODE_READ_WRITE"");
    }
    FileDescriptor fd = Parcel.openFileDescriptor(path, mode);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}",1,"/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and {@link #MODE_WORLD_WRITEABLE}.
 *
 * @return Returns a new ParcelFileDescriptor pointing to the given
 * file.
 *
 * @throws FileNotFoundException Throws FileNotFoundException if the given
 * file does not exist or can not be opened with the requested mode.
 */
","/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and {@link #MODE_WORLD_WRITEABLE}.
 *
 * @return Returns a new ParcelFileDescriptor pointing to the given
 * file.
 *
 * @throws FileNotFoundException Throws FileNotFoundException if the given
 * file does not exist or can not be opened with the requested mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,3",0,"The entire code block related to SecurityManager was removed. Therefore, the code change type is 4 and 3 because it includes the removal of an 'if' control statement and other statements.","The removed code block was checking the path of the file for security purposes and doesn't affect the returned value or the exceptions thrown by this method. Therefore, there is no compatibility issue."
83,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,17,18,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    return enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS);
}","{
    return enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE);
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement value has been changed from earlier version to later version because of the addition of DETECT_VM_FILE_URI_EXPOSURE, so the code change type is 1.","The change in the return statement will potentially cause this API to return a different value in the later version, hence the CI type is 1."
84,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        SparseLongArray childIds = mChildNodeIds;
        builder.append(""; childAccessibilityIds: ["");
        for (int i = 0, count = childIds.size(); i < count; i++) {
            builder.append(childIds.valueAt(i));
            if (i < count - 1) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "" + isScrollable());
    builder.append(""; ["");
    for (int actionBits = mActions; actionBits != 0; ) {
        final int action = 1 << Integer.numberOfTrailingZeros(actionBits);
        actionBits &= ~action;
        builder.append(getActionSymbolicName(action));
        if (actionBits != 0) {
            builder.append("", "");
        }
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        SparseLongArray childIds = mChildNodeIds;
        builder.append(""; childAccessibilityIds: ["");
        for (int i = 0, count = childIds.size(); i < count; i++) {
            builder.append(childIds.valueAt(i));
            if (i < count - 1) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "" + isScrollable());
    builder.append(""; ["");
    for (int actionBits = mActions; actionBits != 0; ) {
        final int action = 1 << Integer.numberOfTrailingZeros(actionBits);
        actionBits &= ~action;
        builder.append(getActionSymbolicName(action));
        if (actionBits != 0) {
            builder.append("", "");
        }
    }
    builder.append(""]"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There is an extra line of code inserted (""builder.append(""; viewIdResName: "").append(mViewIdResourceName);"") which is a new return statement addition. So the code change type is 1.","This addition of new return statement leads to a different output from what it used to generate as it is adding more data (""viewIdResName"") to the resultant string. Hence, the API could potentially return a different value and the CI type is 1."
85,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String)>",17,18,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, AppOpsManager.OP_NONE, false, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The statement 'intent.setAllowFds(false);' in the early version implementation has been changed to 'intent.prepareToLeaveProcess();' in the late version. This falls under other types of statement changes, thus, the type of change is 4.","Even though there was a change in the code, this change doesn't lead to a change in the return type/value of the method or alter the exception handling mechanism. Thus, it doesn't constitute a Compatibility Issue. So, the type of Compatibility Issue is 0, meaning no Compatibility issue exists."
86,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,17,18,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,0,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"New cases have been added to the switch statement in the late version of the implementation, so the code change type is 1,3.","The addition of new cases to the switch statement can lead to different return values according to the input. Therefore, the CI type is 1."
87,"<android.widget.Editor.EasyEditSpanController: void onSpanAdded(Spannable,Object,int,int)>",17,18,"<android.widget.Editor.EasyEditSpanController: void onSpanAdded(Spannable,Object,int,int)>","<android.widget.Editor.EasyEditSpanController: void onSpanAdded(Spannable,Object,int,int)>",0,"{
    if (span instanceof EasyEditSpan) {
        if (mPopupWindow == null) {
            mPopupWindow = new EasyEditPopupWindow();
            mHidePopup = new Runnable() {

                @Override
                public void run() {
                    hide();
                }
            };
        }
        // Make sure there is only at most one EasyEditSpan in the text
        if (mPopupWindow.mEasyEditSpan != null) {
            text.removeSpan(mPopupWindow.mEasyEditSpan);
        }
        mPopupWindow.setEasyEditSpan((EasyEditSpan) span);
        if (mTextView.getWindowVisibility() != View.VISIBLE) {
            // The window is not visible yet, ignore the text change.
            return;
        }
        if (mTextView.getLayout() == null) {
            // The view has not been laid out yet, ignore the text change
            return;
        }
        if (extractedTextModeWillBeStarted()) {
            // the original TextView, as the ExtractEditText will do
            return;
        }
        mPopupWindow.show();
        mTextView.removeCallbacks(mHidePopup);
        mTextView.postDelayed(mHidePopup, DISPLAY_TIMEOUT_MS);
    }
}","{
    if (span instanceof EasyEditSpan) {
        if (mPopupWindow == null) {
            mPopupWindow = new EasyEditPopupWindow();
            mHidePopup = new Runnable() {

                @Override
                public void run() {
                    hide();
                }
            };
        }
        // Make sure there is only at most one EasyEditSpan in the text
        if (mPopupWindow.mEasyEditSpan != null) {
            mPopupWindow.mEasyEditSpan.setDeleteEnabled(false);
        }
        mPopupWindow.setEasyEditSpan((EasyEditSpan) span);
        mPopupWindow.setOnDeleteListener(new EasyEditDeleteListener() {

            @Override
            public void onDeleteClick(EasyEditSpan span) {
                Editable editable = (Editable) mTextView.getText();
                int start = editable.getSpanStart(span);
                int end = editable.getSpanEnd(span);
                if (start >= 0 && end >= 0) {
                    sendNotification(EasyEditSpan.TEXT_DELETED, span);
                    mTextView.deleteText_internal(start, end);
                }
                editable.removeSpan(span);
            }
        });
        if (mTextView.getWindowVisibility() != View.VISIBLE) {
            // The window is not visible yet, ignore the text change.
            return;
        }
        if (mTextView.getLayout() == null) {
            // The view has not been laid out yet, ignore the text change
            return;
        }
        if (extractedTextModeWillBeStarted()) {
            // the original TextView, as the ExtractEditText will do
            return;
        }
        mPopupWindow.show();
        mTextView.removeCallbacks(mHidePopup);
        mTextView.postDelayed(mHidePopup, DISPLAY_TIMEOUT_MS);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change to the statement where the 'delete text' feature was enabled in the early version, which was removed in the late version and new delete operations were added. Hence, the changes belong to type 4, other statements change, and 5, depended API change due to 'setDeleteEnabled()' method was no longer used.","The changes made do not affect the return value or the exceptions that API throws. Thus, there is no compatibility issue (CI type 0)."
88,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",17,18,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>","<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",0,"{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        int oldSubtype = mNetworkInfo.getSubtype();
        int newSubType = TelephonyManager.getDefault().getNetworkType();
        String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
        mNetworkInfo.setSubtype(newSubType, subTypeName);
        if (newSubType != oldSubtype && mNetworkInfo.isConnected()) {
            Message msg = mTarget.obtainMessage(EVENT_NETWORK_SUBTYPE_CHANGED, oldSubtype, 0, mNetworkInfo);
            msg.sendToTarget();
        }
        PhoneConstants.DataState state = Enum.valueOf(PhoneConstants.DataState.class, intent.getStringExtra(PhoneConstants.STATE_KEY));
        String reason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                    if (mLinkProperties == null) {
                        loge(""CONNECTED event did not supply link properties."");
                        mLinkProperties = new LinkProperties();
                    }
                    mLinkCapabilities = intent.getParcelableExtra(PhoneConstants.DATA_LINK_CAPABILITIES_KEY);
                    if (mLinkCapabilities == null) {
                        loge(""CONNECTED event did not supply link capabilities."");
                        mLinkCapabilities = new LinkCapabilities();
                    }
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        String reason = intent.getStringExtra(PhoneConstants.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        if (DBG) {
            log(""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else if (intent.getAction().equals(DctConstants.ACTION_DATA_CONNECTION_TRACKER_MESSENGER)) {
        if (VDBG)
            log(mApnType + "" got ACTION_DATA_CONNECTION_TRACKER_MESSENGER"");
        mMessenger = intent.getParcelableExtra(DctConstants.EXTRA_MESSENGER);
        AsyncChannel ac = new AsyncChannel();
        ac.connect(mContext, MobileDataStateTracker.this.mHandler, mMessenger);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}","{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        int oldSubtype = mNetworkInfo.getSubtype();
        int newSubType = TelephonyManager.getDefault().getNetworkType();
        String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
        mNetworkInfo.setSubtype(newSubType, subTypeName);
        if (newSubType != oldSubtype && mNetworkInfo.isConnected()) {
            Message msg = mTarget.obtainMessage(EVENT_NETWORK_SUBTYPE_CHANGED, oldSubtype, 0, mNetworkInfo);
            msg.sendToTarget();
        }
        PhoneConstants.DataState state = Enum.valueOf(PhoneConstants.DataState.class, intent.getStringExtra(PhoneConstants.STATE_KEY));
        String reason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                    if (mLinkProperties == null) {
                        loge(""CONNECTED event did not supply link properties."");
                        mLinkProperties = new LinkProperties();
                    }
                    mLinkCapabilities = intent.getParcelableExtra(PhoneConstants.DATA_LINK_CAPABILITIES_KEY);
                    if (mLinkCapabilities == null) {
                        loge(""CONNECTED event did not supply link capabilities."");
                        mLinkCapabilities = new LinkCapabilities();
                    }
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        String reason = intent.getStringExtra(PhoneConstants.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        if (DBG) {
            log(""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only a small part of the method has changed (a few lines of code have been deleted), which consists of an 'else if' block that handled the intent for the 'ACTION_DATA_CONNECTION_TRACKER_MESSENGER' action. As such, the type of code change is 4 (Other statement changed).","Despite the change in the implementation, this isn't likely to cause compatibility issues as all the major blocks of the method have remained intact. Hence, the CI is 0 (No Compatibility Issue exist)."
89,"<android.view.GLES20Canvas: boolean quickReject(RectF,EdgeType)>",17,18,"<android.view.GLES20Canvas: boolean quickReject(RectF,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(RectF,EdgeType)>",0,"{
    return nQuickReject(mRenderer, rect.left, rect.top, rect.right, rect.bottom, type.nativeInt);
}","{
    return nQuickReject(mRenderer, rect.left, rect.top, rect.right, rect.bottom);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, specifically the parameter list of the method nQuickReject() which has invalidated the last parameter (type.nativeInt), so the code change type is 1,5.","Due to the change in the return statement, the API potentially returns a different value. Therefore, the CI type is 1."
90,"<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int)>",17,18,"<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int)>","<android.hardware.usb.UsbDeviceConnection: int bulkTransfer(UsbEndpoint,byte[],int,int)>",0,"{
    return native_bulk_request(endpoint.getAddress(), buffer, length, timeout);
}","{
    return bulkTransfer(endpoint, buffer, 0, length, timeout);
}",1,"/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive,
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a bulk transaction on the given endpoint.
 * The direction of the transfer is determined by the direction of the endpoint.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #bulkTransfer(UsbEndpoint, byte[], int, int, int)}.
 * </p>
 *
 * @param endpoint the endpoint for this transaction
 * @param buffer buffer for data to send or receive
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in early version was calling a native method 'native_bulk_request' while in the late version it's calling a different method 'bulkTransfer'. Also, the parameters in the method call have been changed. Therefore, the code change types are 1,5.","The change of the return statement could potentially lead to a different return value or type between two versions of the code, hence the CI type 1."
91,"<android.view.ViewRootImpl.TrackballAxis: float collect(float,long,String)>",17,18,"<android.view.ViewRootImpl.TrackballAxis: float collect(float,long,String)>","<android.view.ViewRootImpl.TrackballAxis: float collect(float,long,String)>",0,"{
    long normTime;
    if (off > 0) {
        normTime = (long) (off * FAST_MOVE_TIME);
        if (dir < 0) {
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" reversed to positive!"");
            position = 0;
            step = 0;
            acceleration = 1;
            lastMoveTime = 0;
        }
        dir = 1;
    } else if (off < 0) {
        normTime = (long) ((-off) * FAST_MOVE_TIME);
        if (dir > 0) {
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" reversed to negative!"");
            position = 0;
            step = 0;
            acceleration = 1;
            lastMoveTime = 0;
        }
        dir = -1;
    } else {
        normTime = 0;
    }
    // or deceleration, scaled by the offset we have here.
    if (normTime > 0) {
        long delta = time - lastMoveTime;
        lastMoveTime = time;
        float acc = acceleration;
        if (delta < normTime) {
            // The user is scrolling rapidly, so increase acceleration.
            float scale = (normTime - delta) * ACCEL_MOVE_SCALING_FACTOR;
            if (scale > 1)
                acc *= scale;
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" accelerate: off="" + off + "" normTime="" + normTime + "" delta="" + delta + "" scale="" + scale + "" acc="" + acc);
            acceleration = acc < MAX_ACCELERATION ? acc : MAX_ACCELERATION;
        } else {
            // The user is scrolling slowly, so decrease acceleration.
            float scale = (delta - normTime) * ACCEL_MOVE_SCALING_FACTOR;
            if (scale > 1)
                acc /= scale;
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" deccelerate: off="" + off + "" normTime="" + normTime + "" delta="" + delta + "" scale="" + scale + "" acc="" + acc);
            acceleration = acc > 1 ? acc : 1;
        }
    }
    position += off;
    return (absPosition = Math.abs(position));
}","{
    long normTime;
    if (off > 0) {
        normTime = (long) (off * FAST_MOVE_TIME);
        if (dir < 0) {
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" reversed to positive!"");
            position = 0;
            step = 0;
            acceleration = 1;
            lastMoveTime = 0;
        }
        dir = 1;
    } else if (off < 0) {
        normTime = (long) ((-off) * FAST_MOVE_TIME);
        if (dir > 0) {
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" reversed to negative!"");
            position = 0;
            step = 0;
            acceleration = 1;
            lastMoveTime = 0;
        }
        dir = -1;
    } else {
        normTime = 0;
    }
    // or deceleration, scaled by the offset we have here.
    if (normTime > 0) {
        long delta = time - lastMoveTime;
        lastMoveTime = time;
        float acc = acceleration;
        if (delta < normTime) {
            // The user is scrolling rapidly, so increase acceleration.
            float scale = (normTime - delta) * ACCEL_MOVE_SCALING_FACTOR;
            if (scale > 1)
                acc *= scale;
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" accelerate: off="" + off + "" normTime="" + normTime + "" delta="" + delta + "" scale="" + scale + "" acc="" + acc);
            acceleration = acc < MAX_ACCELERATION ? acc : MAX_ACCELERATION;
        } else {
            // The user is scrolling slowly, so decrease acceleration.
            float scale = (delta - normTime) * ACCEL_MOVE_SCALING_FACTOR;
            if (scale > 1)
                acc /= scale;
            if (DEBUG_TRACKBALL)
                Log.v(TAG, axis + "" deccelerate: off="" + off + "" normTime="" + normTime + "" delta="" + delta + "" scale="" + scale + "" acc="" + acc);
            acceleration = acc > 1 ? acc : 1;
        }
    }
    position += off;
    return Math.abs(position);
}",1,"/**
 * Add trackball movement into the state.  If the direction of movement
 * has been reversed, the state is reset before adding the
 * movement (so that you don't have to compensate for any previously
 * collected movement before see the result of the movement in the
 * new direction).
 *
 * @return Returns the absolute value of the amount of movement
 * collected so far.
 */
","/**
 * Add trackball movement into the state.  If the direction of movement
 * has been reversed, the state is reset before adding the
 * movement (so that you don't have to compensate for any previously
 * collected movement before see the result of the movement in the
 * new direction).
 *
 * @return Returns the absolute value of the amount of movement
 * collected so far.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from (absPosition = Math.abs(position)) to Math.abs(position), which means the method stops changing the value of the variable absPosition. The change class is 1.","As the return statement has changed, the method potentially returns a different value, which leads to a Compatibility Issue. The CI type is 1."
92,<android.view.HardwareRenderer.GlRenderer: boolean initialize(Surface)>,17,18,<android.view.HardwareRenderer.GlRenderer: boolean initialize(Surface)>,<android.view.HardwareRenderer.GlRenderer: boolean initialize(Surface)>,0,"{
    if (isRequested() && !isEnabled()) {
        initializeEgl();
        mGl = createEglSurface(surface);
        mDestroyed = false;
        if (mGl != null) {
            int err = sEgl.eglGetError();
            if (err != EGL_SUCCESS) {
                destroy(true);
                setRequested(false);
            } else {
                if (mCanvas == null) {
                    mCanvas = createCanvas();
                }
                if (mCanvas != null) {
                    setEnabled(true);
                } else {
                    Log.w(LOG_TAG, ""Hardware accelerated Canvas could not be created"");
                }
            }
            return mCanvas != null;
        }
    }
    return false;
}","{
    if (isRequested() && !isEnabled()) {
        initializeEgl();
        mGl = createEglSurface(surface);
        mDestroyed = false;
        if (mGl != null) {
            int err = sEgl.eglGetError();
            if (err != EGL_SUCCESS) {
                destroy(true);
                setRequested(false);
            } else {
                if (mCanvas == null) {
                    mCanvas = createCanvas();
                    mCanvas.setName(mName);
                }
                setEnabled(true);
            }
            return mCanvas != null;
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late implementation, a new statement mCanvas.setName(mName); is introduced. This statement is not related to the return, exception handling, control dependency, or dependent APIs, so the code change type is 4.","The new line of code does not affect the return value nor the exception handling of the method, therefore no compatibility issue exists. The CI type is 0."
93,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",17,18,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    sendOrderedBroadcast(intent, receiverPermission, AppOpsManager.OP_NONE, resultReceiver, scheduler, initialCode, initialData, initialExtras);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method parameters of sendOrderedBroadcast have been altered, and there is a huge change in the implementation body with many lines of code stripped away and replaced by another API call, so the code change type is 4,5.","The behavior of the method is likely altered due to the change in the parameters of the sendOrderedBroadcast method and the implementation body's major modification. Therefore, the method may return different results when invoked according to different conditions, leading to potential compatibility issues of form 1."
94,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",17,18,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    boolean useDisplayListProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.mChildTransformation.clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.mChildTransformation;
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) == PFLAG3_VIEW_IS_ANIMATING_TRANSFORM && mDisplayList != null) {
            // No longer animating: clear out old animation matrix
            mDisplayList.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!useDisplayListProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final boolean hasTransform = parent.getChildStaticTransformation(this, parent.mChildTransformation);
            if (hasTransform) {
                final int transformType = parent.mChildTransformation.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? parent.mChildTransformation : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    useDisplayListProperties &= hasDisplayList;
    if (useDisplayListProperties) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
            useDisplayListProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!useDisplayListProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!useDisplayListProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (useDisplayListProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = useDisplayListProperties ? 1 : getAlpha();
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (useDisplayListProperties) {
                        displayList.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !useDisplayListProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (useDisplayListProperties) {
                        displayList.setAlpha(alpha * getAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && !useDisplayListProperties) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (!useDisplayListProperties && hasDisplayList) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !useDisplayListProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            if (alpha < 1) {
                cachePaint.setAlpha((int) (alpha * 255));
                parent.mGroupFlags |= ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                cachePaint.setAlpha(255);
                parent.mGroupFlags &= ~ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        parent.invalidate(true);
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    boolean useDisplayListProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.mChildTransformation.clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.mChildTransformation;
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) == PFLAG3_VIEW_IS_ANIMATING_TRANSFORM && mDisplayList != null) {
            // No longer animating: clear out old animation matrix
            mDisplayList.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!useDisplayListProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final boolean hasTransform = parent.getChildStaticTransformation(this, parent.mChildTransformation);
            if (hasTransform) {
                final int transformType = parent.mChildTransformation.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? parent.mChildTransformation : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    useDisplayListProperties &= hasDisplayList;
    if (useDisplayListProperties) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
            useDisplayListProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!useDisplayListProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!useDisplayListProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (useDisplayListProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = useDisplayListProperties ? 1 : getAlpha();
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (useDisplayListProperties) {
                        displayList.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !useDisplayListProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (useDisplayListProperties) {
                        displayList.setAlpha(alpha * getAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && !useDisplayListProperties && cache == null) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (!useDisplayListProperties && hasDisplayList) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !useDisplayListProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            if (alpha < 1) {
                cachePaint.setAlpha((int) (alpha * 255));
                parent.mGroupFlags |= ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                cachePaint.setAlpha(255);
                parent.mGroupFlags &= ~ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        parent.invalidate(true);
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
95,<android.app.Notification.BigPictureStyle: BigPictureStyle setSummaryText(CharSequence)>,17,18,<android.app.Notification.BigPictureStyle: BigPictureStyle setSummaryText(CharSequence)>,<android.app.Notification.BigPictureStyle: BigPictureStyle setSummaryText(CharSequence)>,0,"{
    internalSetSummaryText(cs);
    return this;
}","{
    internalSetSummaryText(safeCharSequence(cs));
    return this;
}",1,"/**
 * Set the first line of text after the detail section in the big form of the template.
 */
","/**
 * Set the first line of text after the detail section in the big form of the template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"In the new version, there is an additional method 'safeCharSequence' applied to the parameter of 'internalSetSummaryText'. It leads to the changes in both the return statement and dependent API. So, the code changes belong to categories 1,5.","Despite the method modification in the implementation, the 'setSummaryText' API does not change the return value or throw different exceptions in the two versions. Therefore, there is no compatibility issue."
97,<android.provider.MediaStore.Audio.Media: Uri getContentUriForPath(String)>,17,18,<android.provider.MediaStore.Audio.Media: Uri getContentUriForPath(String)>,<android.provider.MediaStore.Audio.Media: Uri getContentUriForPath(String)>,0,"{
    return (path.startsWith(Environment.getExternalStorageDirectory().getPath()) ? EXTERNAL_CONTENT_URI : INTERNAL_CONTENT_URI);
}","{
    for (String ep : EXTERNAL_PATHS) {
        if (path.startsWith(ep)) {
            return EXTERNAL_CONTENT_URI;
        }
    }
    return (path.startsWith(Environment.getExternalStorageDirectory().getPath()) ? EXTERNAL_CONTENT_URI : INTERNAL_CONTENT_URI);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the Late Implementation, a 'for' loop is introduced and return statement has a change within this loop, thus it belongs to change type of 1 and 3.",This change in return statement in the 'for' loop can potentially return different values and thus resulting a compatibility issue of type 1.
99,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,17,18,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,0,"{
    switch(eventType) {
        case TYPE_VIEW_CLICKED:
            return ""TYPE_VIEW_CLICKED"";
        case TYPE_VIEW_LONG_CLICKED:
            return ""TYPE_VIEW_LONG_CLICKED"";
        case TYPE_VIEW_SELECTED:
            return ""TYPE_VIEW_SELECTED"";
        case TYPE_VIEW_FOCUSED:
            return ""TYPE_VIEW_FOCUSED"";
        case TYPE_VIEW_TEXT_CHANGED:
            return ""TYPE_VIEW_TEXT_CHANGED"";
        case TYPE_WINDOW_STATE_CHANGED:
            return ""TYPE_WINDOW_STATE_CHANGED"";
        case TYPE_VIEW_HOVER_ENTER:
            return ""TYPE_VIEW_HOVER_ENTER"";
        case TYPE_VIEW_HOVER_EXIT:
            return ""TYPE_VIEW_HOVER_EXIT"";
        case TYPE_NOTIFICATION_STATE_CHANGED:
            return ""TYPE_NOTIFICATION_STATE_CHANGED"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_START:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_START"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_END:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_END"";
        case TYPE_WINDOW_CONTENT_CHANGED:
            return ""TYPE_WINDOW_CONTENT_CHANGED"";
        case TYPE_VIEW_TEXT_SELECTION_CHANGED:
            return ""TYPE_VIEW_TEXT_SELECTION_CHANGED"";
        case TYPE_VIEW_SCROLLED:
            return ""TYPE_VIEW_SCROLLED"";
        case TYPE_ANNOUNCEMENT:
            return ""TYPE_ANNOUNCEMENT"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUSED"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"";
        case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
            return ""TYPE_CURRENT_AT_GRANULARITY_MOVEMENT_CHANGED"";
        case TYPE_GESTURE_DETECTION_START:
            return ""TYPE_GESTURE_DETECTION_START"";
        case TYPE_GESTURE_DETECTION_END:
            return ""TYPE_GESTURE_DETECTION_END"";
        case TYPE_TOUCH_INTERACTION_START:
            return ""TYPE_TOUCH_INTERACTION_START"";
        case TYPE_TOUCH_INTERACTION_END:
            return ""TYPE_TOUCH_INTERACTION_END"";
        default:
            return null;
    }
}","{
    if (eventType == TYPES_ALL_MASK) {
        return ""TYPES_ALL_MASK"";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_LONG_CLICKED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SELECTED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_ENTER"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_HOVER_EXIT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_NOTIFICATION_STATE_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_EXPLORATION_GESTURE_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_WINDOW_CONTENT_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_SELECTION_CHANGED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_SCROLLED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_ANNOUNCEMENT"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUSED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_GESTURE_DETECTION_END"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_START"");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append("", "");
                    }
                    builder.append(""TYPE_TOUCH_INTERACTION_END"");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}",1,"/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
","/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependencies (if and switch statements) and return statements have changed between the two versions, so the code change type is 1,3.","Due to the changes in the control dependencies and return statements, the API might return a different value in the late version compared to the early version, therefore the CI type is 1."
100,"<android.content.res.Resources: float getFraction(int,int,int)>",17,18,"<android.content.res.Resources: float getFraction(int,int,int)>","<android.content.res.Resources: float getFraction(int,int,int)>",0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_FRACTION) {
            return TypedValue.complexToFraction(value.data, base, pbase);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_FRACTION) {
            return TypedValue.complexToFraction(value.data, base, pbase);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}",1,"/**
 * Retrieve a fractional unit for a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Retrieve a fractional unit for a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The synchronized block has been changed from 'mTmpValue' to 'mAccessLock'. Also, an if-check statement has been added to check if 'mTmpValue' is null and it instantiates it if it's null. Therefore, the changes fall under type 4 - Other statement changed.","These changes do not affect the return value or the type of exception thrown by the method. The added null check for 'mTmpValue' does not introduce any new behaviors that could lead to a compatibility issue. Hence, no Compatibility Issue exists and the CI type is 0."
101,<android.webkit.AccessibilityInjectorFallback: boolean onKeyEvent(KeyEvent)>,17,18,<android.webkit.AccessibilityInjectorFallback: boolean onKeyEvent(KeyEvent)>,<android.webkit.AccessibilityInjectorFallback: boolean onKeyEvent(KeyEvent)>,0,"{
    // We do not handle ENTER in any circumstances.
    if (isEnterActionKey(event.getKeyCode())) {
        return false;
    }
    if (event.getAction() == KeyEvent.ACTION_UP) {
        return mLastDownEventHandled;
    }
    mLastDownEventHandled = false;
    AccessibilityWebContentKeyBinding binding = null;
    for (AccessibilityWebContentKeyBinding candidate : sBindings) {
        if (event.getKeyCode() == candidate.getKeyCode() && event.hasModifiers(candidate.getModifiers())) {
            binding = candidate;
            break;
        }
    }
    if (binding == null) {
        return false;
    }
    for (int i = 0, count = binding.getActionCount(); i < count; i++) {
        int actionCode = binding.getActionCode(i);
        String contentDescription = Integer.toHexString(binding.getAction(i));
        switch(actionCode) {
            case ACTION_SET_CURRENT_AXIS:
                int axis = binding.getFirstArgument(i);
                boolean sendEvent = (binding.getSecondArgument(i) == 1);
                setCurrentAxis(axis, sendEvent, contentDescription);
                mLastDownEventHandled = true;
                break;
            case ACTION_TRAVERSE_CURRENT_AXIS:
                int direction = binding.getFirstArgument(i);
                // on second null selection string in same direction - WebView handles the event
                if (direction == mLastDirection && mIsLastSelectionStringNull) {
                    mIsLastSelectionStringNull = false;
                    return false;
                }
                mLastDirection = direction;
                sendEvent = (binding.getSecondArgument(i) == 1);
                mLastDownEventHandled = traverseCurrentAxis(direction, sendEvent, contentDescription);
                break;
            case ACTION_TRAVERSE_GIVEN_AXIS:
                direction = binding.getFirstArgument(i);
                // on second null selection string in same direction => WebView handle the event
                if (direction == mLastDirection && mIsLastSelectionStringNull) {
                    mIsLastSelectionStringNull = false;
                    return false;
                }
                mLastDirection = direction;
                axis = binding.getSecondArgument(i);
                sendEvent = (binding.getThirdArgument(i) == 1);
                traverseGivenAxis(direction, axis, sendEvent, contentDescription);
                mLastDownEventHandled = true;
                break;
            case ACTION_PERFORM_AXIS_TRANSITION:
                int fromAxis = binding.getFirstArgument(i);
                int toAxis = binding.getSecondArgument(i);
                sendEvent = (binding.getThirdArgument(i) == 1);
                performAxisTransition(fromAxis, toAxis, sendEvent, contentDescription);
                mLastDownEventHandled = true;
                break;
            case ACTION_TRAVERSE_DEFAULT_WEB_VIEW_BEHAVIOR_AXIS:
                // If we are not on the default WebView navigation axis this is NOP.
                if (mCurrentAxis == NAVIGATION_AXIS_DEFAULT_WEB_VIEW_BEHAVIOR) {
                    // While WebVew handles navigation we do not get null selection
                    // strings so do not check for that here as the cases above.
                    mLastDirection = binding.getFirstArgument(i);
                    sendEvent = (binding.getSecondArgument(i) == 1);
                    traverseGivenAxis(mLastDirection, NAVIGATION_AXIS_DEFAULT_WEB_VIEW_BEHAVIOR, sendEvent, contentDescription);
                    mLastDownEventHandled = false;
                } else {
                    mLastDownEventHandled = true;
                }
                break;
            default:
                Log.w(LOG_TAG, ""Unknown action code: "" + actionCode);
        }
    }
    return mLastDownEventHandled;
}","{
    // We do not handle ENTER in any circumstances.
    if (isEnterActionKey(event.getKeyCode())) {
        return false;
    }
    if (event.getAction() == KeyEvent.ACTION_UP) {
        return mLastDownEventHandled;
    }
    mLastDownEventHandled = false;
    AccessibilityWebContentKeyBinding binding = null;
    for (AccessibilityWebContentKeyBinding candidate : sBindings) {
        if (event.getKeyCode() == candidate.getKeyCode() && event.hasModifiers(candidate.getModifiers())) {
            binding = candidate;
            break;
        }
    }
    if (binding == null) {
        return false;
    }
    for (int i = 0, count = binding.getActionCount(); i < count; i++) {
        int actionCode = binding.getActionCode(i);
        String contentDescription = Integer.toHexString(binding.getAction(i));
        switch(actionCode) {
            case ACTION_SET_CURRENT_AXIS:
                int axis = binding.getFirstArgument(i);
                boolean sendEvent = (binding.getSecondArgument(i) == 1);
                setCurrentAxis(axis, sendEvent, contentDescription);
                mLastDownEventHandled = true;
                break;
            case ACTION_TRAVERSE_CURRENT_AXIS:
                int direction = binding.getFirstArgument(i);
                // on second null selection string in same direction - WebView handles the event
                if (direction == mLastDirection && mIsLastSelectionStringNull) {
                    mIsLastSelectionStringNull = false;
                    return false;
                }
                mLastDirection = direction;
                sendEvent = (binding.getSecondArgument(i) == 1);
                mLastDownEventHandled = traverseGivenAxis(direction, mCurrentAxis, sendEvent, contentDescription, false);
                break;
            case ACTION_TRAVERSE_GIVEN_AXIS:
                direction = binding.getFirstArgument(i);
                // on second null selection string in same direction => WebView handle the event
                if (direction == mLastDirection && mIsLastSelectionStringNull) {
                    mIsLastSelectionStringNull = false;
                    return false;
                }
                mLastDirection = direction;
                axis = binding.getSecondArgument(i);
                sendEvent = (binding.getThirdArgument(i) == 1);
                traverseGivenAxis(direction, axis, sendEvent, contentDescription, false);
                mLastDownEventHandled = true;
                break;
            case ACTION_PERFORM_AXIS_TRANSITION:
                int fromAxis = binding.getFirstArgument(i);
                int toAxis = binding.getSecondArgument(i);
                sendEvent = (binding.getThirdArgument(i) == 1);
                performAxisTransition(fromAxis, toAxis, sendEvent, contentDescription);
                mLastDownEventHandled = true;
                break;
            case ACTION_TRAVERSE_DEFAULT_WEB_VIEW_BEHAVIOR_AXIS:
                // If we are not on the default WebView navigation axis this is NOP.
                if (mCurrentAxis == NAVIGATION_AXIS_DEFAULT_WEB_VIEW_BEHAVIOR) {
                    // While WebVew handles navigation we do not get null selection
                    // strings so do not check for that here as the cases above.
                    mLastDirection = binding.getFirstArgument(i);
                    sendEvent = (binding.getSecondArgument(i) == 1);
                    traverseGivenAxis(mLastDirection, NAVIGATION_AXIS_DEFAULT_WEB_VIEW_BEHAVIOR, sendEvent, contentDescription, false);
                    mLastDownEventHandled = false;
                } else {
                    mLastDownEventHandled = true;
                }
                break;
            default:
                Log.w(LOG_TAG, ""Unknown action code: "" + actionCode);
        }
    }
    return mLastDownEventHandled;
}",1,"/**
 * Processes a key down <code>event</code>.
 *
 * @return True if the event was processed.
 */
","/**
 * Processes a key down <code>event</code>.
 *
 * @return True if the event was processed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The method traverseCurrentAxis() and traverseGivenAxis() are now being called with an additional parameter (false) which was not there in early implementation. Also, the first parameter of traverseCurrentAxis() is changed from direction to mCurrentAxis. Therefore, the type of code change is both 1 (Return statement changed) and 3 (Control dependency change).","The difference in parameters passed to traverseCurrentAxis() and traverseGivenAxis() methods might lead to changes in their output. Therefore, the returned value of onKeyEvent() method could be different for the same input, which entitles to a Compatibility Issue of type 1 (potential different return values)."
102,<android.app.Notification.BigTextStyle: BigTextStyle setSummaryText(CharSequence)>,17,18,<android.app.Notification.BigTextStyle: BigTextStyle setSummaryText(CharSequence)>,<android.app.Notification.BigTextStyle: BigTextStyle setSummaryText(CharSequence)>,0,"{
    internalSetSummaryText(cs);
    return this;
}","{
    internalSetSummaryText(safeCharSequence(cs));
    return this;
}",1,"/**
 * Set the first line of text after the detail section in the big form of the template.
 */
","/**
 * Set the first line of text after the detail section in the big form of the template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The function safeCharSequence() is introduced to the API which potentially changes the input of the internalSetSummaryText() function. This leads to the code change type as 4 and 5.,"The change in this API could potentially result in the different input to the internalSetSummaryText() function, which could lead to a different processing result, even the API will return `this` as always. Therefore, the CI type is 1."
104,<android.app.Notification.Builder: Builder setContentTitle(CharSequence)>,17,18,<android.app.Notification.Builder: Builder setContentTitle(CharSequence)>,<android.app.Notification.Builder: Builder setContentTitle(CharSequence)>,0,"{
    mContentTitle = title;
    return this;
}","{
    mContentTitle = safeCharSequence(title);
    return this;
}",1,"/**
 * Set the first line of text in the platform notification template.
 */
","/**
 * Set the first line of text in the platform notification template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement ""mContentTitle = title;"" has been changed to ""mContentTitle = safeCharSequence(title);"", which represents a change in the assignment statement and possibly a change in the function it relies on (safeCharSequence()). Therefore, the code change type is 4,5.","The value assigned to mContentTitle is now being processed by the ""safeCharSequence()"" method, which might modify the input 'title'. Hence, the behavior of the API could potentially change, leading to a possible compatibility issue. Therefore, the Compatibility Issue type is 1."
105,<android.content.res.Resources: int getDimensionPixelSize(int)>,17,18,<android.content.res.Resources: int getDimensionPixelSize(int)>,<android.content.res.Resources: int getDimensionPixelSize(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelSize(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelSize(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}",1,"/**
 * Retrieve a dimensional for a particular resource ID for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
","/**
 * Retrieve a dimensional for a particular resource ID for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The object that the method is synchronizing on, changed from 'mTmpValue' to 'mAccessLock'. Besides, a new code block that checks if 'mTmpValue' is null is added , if it is, a new instance of 'TypedValue' is created. Therefore, the change type is 3,4.","Although some changes have been made, they wouldn't lead to a compatibility issue since they neither affect the return type nor the exception handling of the method."
106,<android.widget.VideoView: int getDuration()>,17,18,<android.widget.VideoView: int getDuration()>,<android.widget.VideoView: int getDuration()>,0,"{
    if (isInPlaybackState()) {
        if (mDuration > 0) {
            return mDuration;
        }
        mDuration = mMediaPlayer.getDuration();
        return mDuration;
    }
    mDuration = -1;
    return mDuration;
}","{
    if (isInPlaybackState()) {
        return mMediaPlayer.getDuration();
    }
    return -1;
}",1,"// cache duration as mDuration for faster access
",,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The API alters the mechanism of obtaining the video duration from storing and returning a value recorded earlier to directly obtaining the duration from MediaPlayer every time. The return statements have also been modified. Therefore, the code change types are 1 and 4.","The replacement of the return statements and the direct use of mMediaPlayer.getDuration() in the later version will lead to a different return value when compared to the early version if the video duration changes during playback. Therefore, the CI type is 1."
107,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>",17,18,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>","<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>",0,"{
    try {
        return mContentProvider.openAssetFile(url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.openAssetFile(mPackageName, url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API (mContentProvider.openAssetFile()) used in the return statement has changed by passing an additional parameter in the late version. Therefore, the code change type is 1,5.","Since the return statement is restructured in the late version, this change can potentially cause the API to return a different value. Therefore, the CI type is 1."
109,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>",17,18,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new method waitForSharedPrefs() has been used in the Late_Implementation. This method was not present in the early version, so the change type is 4.","This new statement waitForSharedPrefs() does not directly affect the return of the method nor does it affect the exception handling. Thus, no compatibility issues have been introduced, so the CI type is 0."
110,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,17,18,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.isLanguageAvailable(loc.getISO3Language(), loc.getISO3Country(), loc.getVariant());
        }
    }, LANG_NOT_SUPPORTED, ""isLanguageAvailable"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            return service.isLanguageAvailable(language, country, loc.getVariant());
        }
    }, LANG_NOT_SUPPORTED, ""isLanguageAvailable"");
}",1,"/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc The Locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc The Locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","Exception handling statements are added to deal with MissingResourceException, and control dependencies of 'try-catch' are introduced in the late version, so the code change type is 2,3.","The newly introduced exception handling could lead to different return values (returning LANG_NOT_SUPPORTED) and throwing a different exception when the late version API is invoked, thus the CI type is 1,2."
111,<android.os.WorkSource: int hashCode()>,17,18,<android.os.WorkSource: int hashCode()>,<android.os.WorkSource: int hashCode()>,0,"{
    int result = 0;
    for (int i = 0; i < mNum; i++) {
        result = ((result << 4) | (result >>> 28)) ^ mUids[i];
    }
    return result;
}","{
    int result = 0;
    for (int i = 0; i < mNum; i++) {
        result = ((result << 4) | (result >>> 28)) ^ mUids[i];
    }
    if (mNames != null) {
        for (int i = 0; i < mNum; i++) {
            result = ((result << 4) | (result >>> 28)) ^ mNames[i].hashCode();
        }
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The code has introduced a new loop with a new logic for the hash calculation if 'mNames' is not null. There is a change in the control dependency considering the extra 'if' statement has been introduced. Also, it could possibly change the final output value by manipulating 'result' by 'mNames[i].hashCode()'. So, the code change type is 1,3.","The addition of the new 'if' condition and loop could affect the final return variable as it includes a new calculation for 'result'. Hence, late version API may return a different value than the early version API. Thus, the CI type is 1."
112,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",17,18,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The function call ""s.setChannelIdPrivateKey(mChannelIdPrivateKey);"" has been added in the late implementation. This makes the changes type 1 and 4.","The added function call could change the state of the socket 's' because it modifies a private key which may in turn change the behavior of the returned socket. Therefore, the CI type is 1."
113,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,17,18,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,0,"{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = loc.getISO3Language();
            String country = loc.getISO3Country();
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            int result = service.loadLanguage(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = """";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = """";
                    }
                }
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 639-2/T language code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve ISO 3166 country code for locale: "" + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            int result = service.loadLanguage(getCallerIdentity(), language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = """";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = """";
                    }
                }
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}",1,"/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","In the late version, not only do we see the introduction of exception handling statements (try-catch blocks), but there's also a change in the return statements (because the exception handling statements include the return statement, return LANG_NOT_SUPPORTED). In addition, there's a change in the control flow (with the new try-catch blocks), and there's a change in the DEPENDENT API, service.loadLanguage() where getCallerIdentity() has been added in the late version, so the change types are 1,2,3 and 5.","The change in return statement, exception handling and dependent API could potentially cause the function to return a different value when an exception is raised or based on the new added parameter in the service.loadLanguage() method. Therefore, we indicate that there's compatibility issue of type 1 (return type/value change) and 2 (exception handling change)."
114,<android.accessibilityservice.AccessibilityServiceInfo: boolean getCanRetrieveWindowContent()>,17,18,<android.accessibilityservice.AccessibilityServiceInfo: boolean getCanRetrieveWindowContent()>,<android.accessibilityservice.AccessibilityServiceInfo: boolean getCanRetrieveWindowContent()>,0,"{
    return mCanRetrieveWindowContent;
}","{
    return (mCapabilities & CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT) != 0;
}",1,"/**
 * Whether this service can retrieve the current window's content.
 * <p>
 * <strong>Statically set from
 * {@link AccessibilityService#SERVICE_META_DATA meta-data}.</strong>
 * </p>
 * @return True if window content can be retrieved.
 */
","/**
 * Whether this service can retrieve the current window's content.
 * <p>
 * <strong>Statically set from
 * {@link AccessibilityService#SERVICE_META_DATA meta-data}.</strong>
 * </p>
 * @return True if window content can be retrieved.
 *
 * @deprecated Use {@link #getCapabilities()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement from 'return mCanRetrieveWindowContent' has changed to 'return (mCapabilities & CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT) != 0', so the code change type is return statement changed (1).","As the return statement has changed, the late version of the API 'getCanRetrieveWindowContent' might return a different value, so it potentially leads to a compatibility issue. Therefore, the CI type is 'Compatibility Issue caused by potential different return values or types' (1)."
115,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,17,18,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,0,"{
    BluetoothSocket acceptedSocket;
    if (mSocketState != SocketState.LISTENING)
        throw new IOException(""bt socket is not in listen state"");
    // TODO(BT) wait on an incoming connection
    String RemoteAddr = waitSocketSignal(mSocketIS);
    synchronized (this) {
        if (mSocketState != SocketState.LISTENING)
            throw new IOException(""bt socket is not in listen state"");
        acceptedSocket = acceptSocket(RemoteAddr);
    // quick drop the reference of the file handle
    }
    // return this;
    return acceptedSocket;
}","{
    BluetoothSocket acceptedSocket;
    if (mSocketState != SocketState.LISTENING)
        throw new IOException(""bt socket is not in listen state"");
    if (timeout > 0) {
        Log.d(TAG, ""accept() set timeout (ms):"" + timeout);
        mSocket.setSoTimeout(timeout);
    }
    String RemoteAddr = waitSocketSignal(mSocketIS);
    if (timeout > 0)
        mSocket.setSoTimeout(0);
    synchronized (this) {
        if (mSocketState != SocketState.LISTENING)
            throw new IOException(""bt socket is not in listen state"");
        acceptedSocket = acceptSocket(RemoteAddr);
    // quick drop the reference of the file handle
    }
    return acceptedSocket;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"There have been new control statements added (if statement with condition timeout > 0) in the late version. Hence, the code change type is 3 (Control dependency changed).","Even though new control dependencies were introduced, the return variable 'acceptedSocket' and the exceptions that the method may throw remain the same. There is no Compatibility Issue in this situation as any change does not affect the API's behavior from the user's perspective."
116,<android.view.Surface: Canvas lockCanvas(Rect)>,17,18,<android.view.Surface: Canvas lockCanvas(Rect)>,<android.view.Surface: Canvas lockCanvas(Rect)>,0,"{
    return nativeLockCanvas(dirty);
}","{
    synchronized (mLock) {
        checkNotReleasedLocked();
        nativeLockCanvas(mNativeSurface, mCanvas, inOutDirty);
        return mCanvas;
    }
}",1,"/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller should
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param dirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller should redraw the entire dirty region as represented
 * by the contents of the dirty rect upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 */
","/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control statement (synchronized) and return statement has changed. Also, the usage of mLock, checkNotReleasedLocked() and mNativeSurface, inOutDirty are introduced. So, the code change types are 1,3,4.","The value return by the method in the late version would be mCanvas, whereas in the early version it was the result of nativeLockCanvas(dirty). So the CI type is 1."
117,"<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",17,18,"<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>","<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",0,"{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
        if (selStart < 0 || selEnd < 0) {
            selStart = selEnd = 0;
            Selection.setSelection(content, 0, 0);
        }
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // QWERTY keyboard normal case
    int i = event.getUnicodeChar(event.getMetaState() | getMetaState(content));
    if (!mFullKeyboard) {
        int count = event.getRepeatCount();
        if (count > 0 && selStart == selEnd && selStart > 0) {
            char c = content.charAt(selStart - 1);
            if (c == i || c == Character.toUpperCase(i) && view != null) {
                if (showCharacterPicker(view, content, c, false, count)) {
                    resetMetaState(content);
                    return true;
                }
            }
        }
    }
    if (i == KeyCharacterMap.PICKER_DIALOG_INPUT) {
        if (view != null) {
            showCharacterPicker(view, content, KeyCharacterMap.PICKER_DIALOG_INPUT, true, 1);
        }
        resetMetaState(content);
        return true;
    }
    if (i == KeyCharacterMap.HEX_INPUT) {
        int start;
        if (selStart == selEnd) {
            start = selEnd;
            while (start > 0 && selEnd - start < 4 && Character.digit(content.charAt(start - 1), 16) >= 0) {
                start--;
            }
        } else {
            start = selStart;
        }
        int ch = -1;
        try {
            String hex = TextUtils.substring(content, start, selEnd);
            ch = Integer.parseInt(hex, 16);
        } catch (NumberFormatException nfe) {
        }
        if (ch >= 0) {
            selStart = start;
            Selection.setSelection(content, selStart, selEnd);
            i = ch;
        } else {
            i = 0;
        }
    }
    if (i != 0) {
        boolean dead = false;
        if ((i & KeyCharacterMap.COMBINING_ACCENT) != 0) {
            dead = true;
            i = i & KeyCharacterMap.COMBINING_ACCENT_MASK;
        }
        if (activeStart == selStart && activeEnd == selEnd) {
            boolean replace = false;
            if (selEnd - selStart - 1 == 0) {
                char accent = content.charAt(selStart);
                int composed = event.getDeadChar(accent, i);
                if (composed != 0) {
                    i = composed;
                    replace = true;
                }
            }
            if (!replace) {
                Selection.setSelection(content, selEnd);
                content.removeSpan(TextKeyListener.ACTIVE);
                selStart = selEnd;
            }
        }
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && Character.isLowerCase(i) && TextKeyListener.shouldCap(mAutoCap, content, selStart)) {
            int where = content.getSpanEnd(TextKeyListener.CAPPED);
            int flags = content.getSpanFlags(TextKeyListener.CAPPED);
            if (where == selStart && (((flags >> 16) & 0xFFFF) == i)) {
                content.removeSpan(TextKeyListener.CAPPED);
            } else {
                flags = i << 16;
                i = Character.toUpperCase(i);
                if (selStart == 0)
                    content.setSpan(TextKeyListener.CAPPED, 0, 0, Spannable.SPAN_MARK_MARK | flags);
                else
                    content.setSpan(TextKeyListener.CAPPED, selStart - 1, selStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | flags);
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, String.valueOf((char) i));
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (oldStart < selEnd) {
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            if (dead) {
                Selection.setSelection(content, oldStart, selEnd);
                content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        adjustMetaAfterKeypress(content);
        if ((pref & TextKeyListener.AUTO_TEXT) != 0 && mAutoText && (i == ' ' || i == '\t' || i == '\n' || i == ',' || i == '.' || i == '!' || i == '?' || i == '""' || Character.getType(i) == Character.END_PUNCTUATION) && content.getSpanEnd(TextKeyListener.INHIBIT_REPLACEMENT) != oldStart) {
            int x;
            for (x = oldStart; x > 0; x--) {
                char c = content.charAt(x - 1);
                if (c != '\'' && !Character.isLetter(c)) {
                    break;
                }
            }
            String rep = getReplacement(content, x, oldStart, view);
            if (rep != null) {
                Replaced[] repl = content.getSpans(0, content.length(), Replaced.class);
                for (int a = 0; a < repl.length; a++) content.removeSpan(repl[a]);
                char[] orig = new char[oldStart - x];
                TextUtils.getChars(content, x, oldStart, orig, 0);
                content.setSpan(new Replaced(orig), x, oldStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                content.replace(x, oldStart, rep);
            }
        }
        if ((pref & TextKeyListener.AUTO_PERIOD) != 0 && mAutoText) {
            selEnd = Selection.getSelectionEnd(content);
            if (selEnd - 3 >= 0) {
                if (content.charAt(selEnd - 1) == ' ' && content.charAt(selEnd - 2) == ' ') {
                    char c = content.charAt(selEnd - 3);
                    for (int j = selEnd - 3; j > 0; j--) {
                        if (c == '""' || Character.getType(c) == Character.END_PUNCTUATION) {
                            c = content.charAt(j - 1);
                        } else {
                            break;
                        }
                    }
                    if (Character.isLetter(c) || Character.isDigit(c)) {
                        content.replace(selEnd - 2, selEnd - 1, ""."");
                    }
                }
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_DEL && (event.hasNoModifiers() || event.hasModifiers(KeyEvent.META_ALT_ON)) && selStart == selEnd) {
        // special backspace case for undoing autotext
        int consider = 1;
        if (content.getSpanEnd(TextKeyListener.LAST_TYPED) == selStart) {
            if (content.charAt(selStart - 1) != '\n')
                consider = 2;
        }
        Replaced[] repl = content.getSpans(selStart - consider, selStart, Replaced.class);
        if (repl.length > 0) {
            int st = content.getSpanStart(repl[0]);
            int en = content.getSpanEnd(repl[0]);
            String old = new String(repl[0].mText);
            content.removeSpan(repl[0]);
            // itself).
            if (selStart >= en) {
                content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en, en, Spannable.SPAN_POINT_POINT);
                content.replace(st, en, old);
                en = content.getSpanStart(TextKeyListener.INHIBIT_REPLACEMENT);
                if (en - 1 >= 0) {
                    content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en - 1, en, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    content.removeSpan(TextKeyListener.INHIBIT_REPLACEMENT);
                }
                adjustMetaAfterKeypress(content);
            } else {
                adjustMetaAfterKeypress(content);
                return super.onKeyDown(view, content, keyCode, event);
            }
            return true;
        }
    }
    return super.onKeyDown(view, content, keyCode, event);
}","{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
        if (selStart < 0 || selEnd < 0) {
            selStart = selEnd = 0;
            Selection.setSelection(content, 0, 0);
        }
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // QWERTY keyboard normal case
    int i = event.getUnicodeChar(event.getMetaState() | getMetaState(content));
    if (!mFullKeyboard) {
        int count = event.getRepeatCount();
        if (count > 0 && selStart == selEnd && selStart > 0) {
            char c = content.charAt(selStart - 1);
            if (c == i || c == Character.toUpperCase(i) && view != null) {
                if (showCharacterPicker(view, content, c, false, count)) {
                    resetMetaState(content);
                    return true;
                }
            }
        }
    }
    if (i == KeyCharacterMap.PICKER_DIALOG_INPUT) {
        if (view != null) {
            showCharacterPicker(view, content, KeyCharacterMap.PICKER_DIALOG_INPUT, true, 1);
        }
        resetMetaState(content);
        return true;
    }
    if (i == KeyCharacterMap.HEX_INPUT) {
        int start;
        if (selStart == selEnd) {
            start = selEnd;
            while (start > 0 && selEnd - start < 4 && Character.digit(content.charAt(start - 1), 16) >= 0) {
                start--;
            }
        } else {
            start = selStart;
        }
        int ch = -1;
        try {
            String hex = TextUtils.substring(content, start, selEnd);
            ch = Integer.parseInt(hex, 16);
        } catch (NumberFormatException nfe) {
        }
        if (ch >= 0) {
            selStart = start;
            Selection.setSelection(content, selStart, selEnd);
            i = ch;
        } else {
            i = 0;
        }
    }
    if (i != 0) {
        boolean dead = false;
        if ((i & KeyCharacterMap.COMBINING_ACCENT) != 0) {
            dead = true;
            i = i & KeyCharacterMap.COMBINING_ACCENT_MASK;
        }
        if (activeStart == selStart && activeEnd == selEnd) {
            boolean replace = false;
            if (selEnd - selStart - 1 == 0) {
                char accent = content.charAt(selStart);
                int composed = event.getDeadChar(accent, i);
                if (composed != 0) {
                    i = composed;
                    replace = true;
                    dead = false;
                }
            }
            if (!replace) {
                Selection.setSelection(content, selEnd);
                content.removeSpan(TextKeyListener.ACTIVE);
                selStart = selEnd;
            }
        }
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && Character.isLowerCase(i) && TextKeyListener.shouldCap(mAutoCap, content, selStart)) {
            int where = content.getSpanEnd(TextKeyListener.CAPPED);
            int flags = content.getSpanFlags(TextKeyListener.CAPPED);
            if (where == selStart && (((flags >> 16) & 0xFFFF) == i)) {
                content.removeSpan(TextKeyListener.CAPPED);
            } else {
                flags = i << 16;
                i = Character.toUpperCase(i);
                if (selStart == 0)
                    content.setSpan(TextKeyListener.CAPPED, 0, 0, Spannable.SPAN_MARK_MARK | flags);
                else
                    content.setSpan(TextKeyListener.CAPPED, selStart - 1, selStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | flags);
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, String.valueOf((char) i));
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (oldStart < selEnd) {
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            if (dead) {
                Selection.setSelection(content, oldStart, selEnd);
                content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        adjustMetaAfterKeypress(content);
        if ((pref & TextKeyListener.AUTO_TEXT) != 0 && mAutoText && (i == ' ' || i == '\t' || i == '\n' || i == ',' || i == '.' || i == '!' || i == '?' || i == '""' || Character.getType(i) == Character.END_PUNCTUATION) && content.getSpanEnd(TextKeyListener.INHIBIT_REPLACEMENT) != oldStart) {
            int x;
            for (x = oldStart; x > 0; x--) {
                char c = content.charAt(x - 1);
                if (c != '\'' && !Character.isLetter(c)) {
                    break;
                }
            }
            String rep = getReplacement(content, x, oldStart, view);
            if (rep != null) {
                Replaced[] repl = content.getSpans(0, content.length(), Replaced.class);
                for (int a = 0; a < repl.length; a++) content.removeSpan(repl[a]);
                char[] orig = new char[oldStart - x];
                TextUtils.getChars(content, x, oldStart, orig, 0);
                content.setSpan(new Replaced(orig), x, oldStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                content.replace(x, oldStart, rep);
            }
        }
        if ((pref & TextKeyListener.AUTO_PERIOD) != 0 && mAutoText) {
            selEnd = Selection.getSelectionEnd(content);
            if (selEnd - 3 >= 0) {
                if (content.charAt(selEnd - 1) == ' ' && content.charAt(selEnd - 2) == ' ') {
                    char c = content.charAt(selEnd - 3);
                    for (int j = selEnd - 3; j > 0; j--) {
                        if (c == '""' || Character.getType(c) == Character.END_PUNCTUATION) {
                            c = content.charAt(j - 1);
                        } else {
                            break;
                        }
                    }
                    if (Character.isLetter(c) || Character.isDigit(c)) {
                        content.replace(selEnd - 2, selEnd - 1, ""."");
                    }
                }
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_DEL && (event.hasNoModifiers() || event.hasModifiers(KeyEvent.META_ALT_ON)) && selStart == selEnd) {
        // special backspace case for undoing autotext
        int consider = 1;
        if (content.getSpanEnd(TextKeyListener.LAST_TYPED) == selStart) {
            if (content.charAt(selStart - 1) != '\n')
                consider = 2;
        }
        Replaced[] repl = content.getSpans(selStart - consider, selStart, Replaced.class);
        if (repl.length > 0) {
            int st = content.getSpanStart(repl[0]);
            int en = content.getSpanEnd(repl[0]);
            String old = new String(repl[0].mText);
            content.removeSpan(repl[0]);
            // itself).
            if (selStart >= en) {
                content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en, en, Spannable.SPAN_POINT_POINT);
                content.replace(st, en, old);
                en = content.getSpanStart(TextKeyListener.INHIBIT_REPLACEMENT);
                if (en - 1 >= 0) {
                    content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en - 1, en, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    content.removeSpan(TextKeyListener.INHIBIT_REPLACEMENT);
                }
                adjustMetaAfterKeypress(content);
            } else {
                adjustMetaAfterKeypress(content);
                return super.onKeyDown(view, content, keyCode, event);
            }
            return true;
        }
    }
    return super.onKeyDown(view, content, keyCode, event);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
118,<android.app.Notification.Builder: Notification build()>,17,18,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    if (mStyle != null) {
        return mStyle.build();
    } else {
        return buildUnstyled();
    }
}","{
    final Notification n;
    if (mStyle != null) {
        n = mStyle.build();
    } else {
        n = buildUnstyled();
    }
    n.extras = mExtras != null ? new Bundle(mExtras) : new Bundle();
    addExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    return n;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the early version the build() method returns either mStyle.build() or buildUnstyled() directly, but in the late version, it stores the return statements in a new variable 'n', further sets the 'extras' parameter of 'n', and finally returns 'n'. So the code change types are 1,4.","Since the returned object in the late version had new variable 'extras' that is potentially different from the early version one, the API could potentially return different values, thus the CI type is 1."
122,"<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,int,IBackupManager)>",17,18,"<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor());
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor());
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any SharedPreferences writes have landed after the backup,
        // in case the app code has side effects (since apps cannot provide this
        // guarantee themselves).
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only the method waitForSharedPrefs() is added in the late version which is not covered by return statements, exception handling statements and control dependencies. Hence, the code change type is 4.","The addition of waitForSharedPrefs() doesn't cause any difference in the return values or the exception handling, thus no Compatibility Issue exists here. The CI type is 0."
123,<android.widget.NumberPicker: void setDisplayedValues(String[])>,17,18,<android.widget.NumberPicker: void setDisplayedValues(String[])>,<android.widget.NumberPicker: void setDisplayedValues(String[])>,0,"{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
        // values. This will take care of the current value as well.
        if (getMinValue() >= displayedValues.length) {
            setMinValue(0);
        }
        if (getMaxValue() >= displayedValues.length) {
            setMaxValue(displayedValues.length - 1);
        }
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    initializeSelectorWheelIndices();
    tryComputeMaxWidth();
}","{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    initializeSelectorWheelIndices();
    tryComputeMaxWidth();
}",1,"/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 */
","/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 *
 * <strong>Note:</strong> The length of the displayed values array
 * must be equal to the range of selectable numbers which is equal to
 * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The changes occured in the third ""if"" block of statements. The part that sets the minimum and maximum values using the method setMinValue() and setMaxValue() in the early version has been removed completely in the late. Therefore, the code change type is 4 (Other statement changed). Also, there are contol statements (if) in this block, therefore, the code change type is also 3 (Control dependency change).","As these changes in the control and other statements can potentially make the API behave differently (e.g., no setting of the min and max values in the late version), the CI type is 1 (Compatibility Issue caused by potentially different return values or types)."
124,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",17,18,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a new statement added in the late version: s.setChannelIdPrivateKey(mChannelIdPrivateKey), which is not related to the return statement, not changing exception situations, and not involved in control dependency. Therefore, the code change type is 4.","The extra statement of setting the channelIdPrivateKey does not impact the resulting type or value returned by the method, and it doesn't introduce any additional exceptions, therefore no Compatibility Issue exists. So the CI type is 0."
126,<android.view.GLES20Canvas: boolean clipRegion(Region)>,17,18,<android.view.GLES20Canvas: boolean clipRegion(Region)>,<android.view.GLES20Canvas: boolean clipRegion(Region)>,0,"{
    // TODO: Implement
    region.getBounds(mClipBounds);
    return nClipRect(mRenderer, mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom, Region.Op.INTERSECT.nativeInt);
}","{
    return nClipRegion(mRenderer, region.mNativeRegion, Region.Op.INTERSECT.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The core implementation of the method changed significantly from getting the bounds of a region and clipping a rectangle to directly clipping a region. As a result, the return value has potentially changed, classifying this change as both Return Statement Changed(1) and Dependent API Changed(5).","As a result of the change, if the region is not rectangular, 'nClipRect' in the early version and 'nClipRegion' in the late version will potentially lead to different results. This signifies that a Compatibility Issue caused by potential different return values (1) exists."
127,<android.view.GLES20Canvas: boolean clipPath(Path)>,17,18,<android.view.GLES20Canvas: boolean clipPath(Path)>,<android.view.GLES20Canvas: boolean clipPath(Path)>,0,"{
    // TODO: Implement
    path.computeBounds(mPathBounds, true);
    return nClipRect(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom, Region.Op.INTERSECT.nativeInt);
}","{
    return nClipPath(mRenderer, path.mNativePath, Region.Op.INTERSECT.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the `clipPath()` method has changed, and the dependent API `nClipPath()` has also altered its parameters. Thus, the code change type is 1,5.","Since the return statement has changed, the API potentially returns a different value in the late version. Therefore, the Compatibility Issue type would be 1."
128,<android.webkit.WebViewClassic.PrivateHandler: void handleMessage(Message)>,17,18,<android.webkit.WebViewClassic.PrivateHandler: void handleMessage(Message)>,<android.webkit.WebViewClassic.PrivateHandler: void handleMessage(Message)>,0,"{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
        // Blocking messages from webkit
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mCurrentScrollingLayerId == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    scrollLayerTo(mScrollingLayerRect.left + mAutoScrollX, mScrollingLayerRect.top + mAutoScrollY);
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || !imm.isActive(mWebView)) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                contentScrollTo(p.x, p.y, msg.arg1 == 1);
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case UPDATE_ZOOM_DENSITY:
            {
                final float density = (Float) msg.obj;
                mZoomManager.updateDefaultZoomDensity(density);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                setNewPicture(draw, true);
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            String drawableDir = BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR, mContext);
            nativeCreate(msg.arg1, drawableDir, ActivityManager.isHighEndGfx());
            if (mDelaySetPicture != null) {
                setNewPicture(mDelaySetPicture, true);
                mDelaySetPicture = null;
            }
            if (mIsPaused) {
                nativeSetPauseDrawing(mNativeClass, true);
            }
            mInputDispatcher = new WebViewInputDispatcher(this, mWebViewCore.getInputDispatcherCallbacks());
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (msg.arg2 == mTextGeneration) {
                String text = (String) msg.obj;
                if (null == text) {
                    text = """";
                }
                if (mInputConnection != null && mFieldPointer == msg.arg1) {
                    mInputConnection.setTextAndKeepSelection(text);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case TAKE_FOCUS:
            int direction = msg.arg1;
            View focusSearch = mWebView.focusSearch(direction);
            if (focusSearch != null && focusSearch != mWebView) {
                focusSearch.requestFocus();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            hideSoftKeyboard();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            if (mFieldPointer == msg.arg1) {
                ArrayAdapter<String> adapter = (ArrayAdapter<String>) msg.obj;
                mAutoCompletePopup.setAdapter(adapter);
            }
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            mWebView.performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mInputDispatcher.setWebKitWantsTouchEvents(msg.arg1 != 0);
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
            break;
        case SCREEN_ON:
            mWebView.setKeepScreenOn(msg.arg1 == 1);
            break;
        case EXIT_FULLSCREEN_VIDEO:
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.exitFullScreenVideo();
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int orientation = msg.arg1;
                int npp = msg.arg2;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebViewClassic.this, orientation, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.show();
                invalidate();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                int x = (int) (left + data.mXPercentInDoc * width - data.mXPercentInView * viewWidth);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeightImpl());
                mWebView.scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case SELECTION_STRING_CHANGED:
            if (isAccessibilityInjectionEnabled()) {
                getAccessibilityInjector().handleSelectionChangedIfNecessary((String) msg.obj);
            }
            break;
        case FOCUS_NODE_CHANGED:
            mIsEditingText = (msg.arg1 == mFieldPointer);
            if (mAutoCompletePopup != null && !mIsEditingText) {
                mAutoCompletePopup.clearAdapter();
            }
        // fall through to HIT_TEST_RESULT
        case HIT_TEST_RESULT:
            WebKitHitTest hit = (WebKitHitTest) msg.obj;
            mFocusedNode = hit;
            setTouchHighlightRects(hit);
            setHitTestResult(hit);
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mInputConnection != null) {
                mInputConnection.setAutoFillable(mAutoFillData.getQueryId());
                mAutoCompletePopup.setAutoFillQueryId(mAutoFillData.getQueryId());
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mAutoCompletePopup != null) {
                ArrayList<String> pastEntries = new ArrayList<String>();
                mAutoCompletePopup.setAdapter(new ArrayAdapter<String>(mContext, com.android.internal.R.layout.web_text_view_dropdown, pastEntries));
            }
            break;
        case COPY_TO_CLIPBOARD:
            copyToClipboard((String) msg.obj);
            break;
        case INIT_EDIT_FIELD:
            if (mInputConnection != null) {
                TextFieldInitData initData = (TextFieldInitData) msg.obj;
                mTextGeneration = 0;
                mFieldPointer = initData.mFieldPointer;
                mInputConnection.initEditorInfo(initData);
                mInputConnection.setTextAndKeepSelection(initData.mText);
                mEditTextContentBounds.set(initData.mContentBounds);
                mEditTextLayerId = initData.mNodeLayerId;
                nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
                mEditTextContent.set(initData.mClientRect);
                relocateAutoCompletePopup();
            }
            break;
        case REPLACE_TEXT:
            {
                String text = (String) msg.obj;
                int start = msg.arg1;
                int end = msg.arg2;
                int cursorPosition = start + text.length();
                replaceTextfieldText(start, end, text, cursorPosition, cursorPosition);
                selectionDone();
                break;
            }
        case UPDATE_MATCH_COUNT:
            {
                WebViewCore.FindAllRequest request = (WebViewCore.FindAllRequest) msg.obj;
                if (request == null) {
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(0, 0, true);
                    }
                } else if (request == mFindRequest) {
                    int matchCount, matchIndex;
                    synchronized (mFindRequest) {
                        matchCount = request.mMatchCount;
                        matchIndex = request.mMatchIndex;
                    }
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(matchIndex, matchCount, false);
                    }
                    if (mFindListener != null) {
                        mFindListener.onFindResultReceived(matchIndex, matchCount, true);
                    }
                }
                break;
            }
        case CLEAR_CARET_HANDLE:
            if (mIsCaretSelection) {
                selectionDone();
            }
            break;
        case KEY_PRESS:
            sendBatchableInputMessage(EventHub.KEY_PRESS, msg.arg1, 0, null);
            break;
        case RELOCATE_AUTO_COMPLETE_POPUP:
            relocateAutoCompletePopup();
            break;
        case AUTOFILL_FORM:
            mWebViewCore.sendMessage(EventHub.AUTOFILL_FORM, msg.arg1, /* unused */
            0);
            break;
        case EDIT_TEXT_SIZE_CHANGED:
            if (msg.arg1 == mFieldPointer) {
                mEditTextContent.set((Rect) msg.obj);
            }
            break;
        case SHOW_CARET_HANDLE:
            if (!mSelectingText && mIsEditingText && mIsCaretSelection) {
                setupWebkitSelect();
                resetCaretTimer();
                showPasteWindow();
            }
            break;
        case UPDATE_CONTENT_BOUNDS:
            mEditTextContentBounds.set((Rect) msg.obj);
            nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
            break;
        case SCROLL_EDIT_TEXT:
            scrollEditWithCursor();
            break;
        case SCROLL_HANDLE_INTO_VIEW:
            scrollDraggedSelectionHandleIntoView();
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
        // Blocking messages from webkit
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mCurrentScrollingLayerId == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    scrollLayerTo(mScrollingLayerRect.left + mAutoScrollX, mScrollingLayerRect.top + mAutoScrollY);
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || !imm.isActive(mWebView)) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                contentScrollTo(p.x, p.y, msg.arg1 == 1);
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case UPDATE_ZOOM_DENSITY:
            {
                final float density = (Float) msg.obj;
                mZoomManager.updateDefaultZoomDensity(density);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                setNewPicture(draw, true);
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            String drawableDir = BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR, mContext);
            nativeCreate(msg.arg1, drawableDir, ActivityManager.isHighEndGfx());
            if (mDelaySetPicture != null) {
                setNewPicture(mDelaySetPicture, true);
                mDelaySetPicture = null;
            }
            if (mIsPaused) {
                nativeSetPauseDrawing(mNativeClass, true);
            }
            mInputDispatcher = new WebViewInputDispatcher(this, mWebViewCore.getInputDispatcherCallbacks());
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (msg.arg2 == mTextGeneration) {
                String text = (String) msg.obj;
                if (null == text) {
                    text = """";
                }
                if (mInputConnection != null && mFieldPointer == msg.arg1) {
                    mInputConnection.setTextAndKeepSelection(text);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case TAKE_FOCUS:
            int direction = msg.arg1;
            View focusSearch = mWebView.focusSearch(direction);
            if (focusSearch != null && focusSearch != mWebView) {
                focusSearch.requestFocus();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            hideSoftKeyboard();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            if (mFieldPointer == msg.arg1) {
                ArrayAdapter<String> adapter = (ArrayAdapter<String>) msg.obj;
                mAutoCompletePopup.setAdapter(adapter);
            }
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            mWebView.performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mInputDispatcher.setWebKitWantsTouchEvents(msg.arg1 != 0);
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
            break;
        case SCREEN_ON:
            mWebView.setKeepScreenOn(msg.arg1 == 1);
            break;
        case EXIT_FULLSCREEN_VIDEO:
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.exitFullScreenVideo();
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int orientation = msg.arg1;
                int npp = msg.arg2;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebViewClassic.this, orientation, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.show();
                invalidate();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                int x = (int) (left + data.mXPercentInDoc * width - data.mXPercentInView * viewWidth);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeightImpl());
                mWebView.scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case FOCUS_NODE_CHANGED:
            mIsEditingText = (msg.arg1 == mFieldPointer);
            if (mAutoCompletePopup != null && !mIsEditingText) {
                mAutoCompletePopup.clearAdapter();
            }
        // fall through to HIT_TEST_RESULT
        case HIT_TEST_RESULT:
            WebKitHitTest hit = (WebKitHitTest) msg.obj;
            mFocusedNode = hit;
            setTouchHighlightRects(hit);
            setHitTestResult(hit);
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mInputConnection != null) {
                mInputConnection.setAutoFillable(mAutoFillData.getQueryId());
                mAutoCompletePopup.setAutoFillQueryId(mAutoFillData.getQueryId());
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mAutoCompletePopup != null) {
                ArrayList<String> pastEntries = new ArrayList<String>();
                mAutoCompletePopup.setAdapter(new ArrayAdapter<String>(mContext, com.android.internal.R.layout.web_text_view_dropdown, pastEntries));
            }
            break;
        case COPY_TO_CLIPBOARD:
            copyToClipboard((String) msg.obj);
            break;
        case INIT_EDIT_FIELD:
            if (mInputConnection != null) {
                TextFieldInitData initData = (TextFieldInitData) msg.obj;
                mTextGeneration = 0;
                mFieldPointer = initData.mFieldPointer;
                mInputConnection.initEditorInfo(initData);
                mInputConnection.setTextAndKeepSelection(initData.mText);
                mEditTextContentBounds.set(initData.mContentBounds);
                mEditTextLayerId = initData.mNodeLayerId;
                nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
                mEditTextContent.set(initData.mClientRect);
                relocateAutoCompletePopup();
            }
            break;
        case REPLACE_TEXT:
            {
                String text = (String) msg.obj;
                int start = msg.arg1;
                int end = msg.arg2;
                int cursorPosition = start + text.length();
                replaceTextfieldText(start, end, text, cursorPosition, cursorPosition);
                selectionDone();
                break;
            }
        case UPDATE_MATCH_COUNT:
            {
                WebViewCore.FindAllRequest request = (WebViewCore.FindAllRequest) msg.obj;
                if (request == null) {
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(0, 0, true);
                    }
                } else if (request == mFindRequest) {
                    int matchCount, matchIndex;
                    synchronized (mFindRequest) {
                        matchCount = request.mMatchCount;
                        matchIndex = request.mMatchIndex;
                    }
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(matchIndex, matchCount, false);
                    }
                    if (mFindListener != null) {
                        mFindListener.onFindResultReceived(matchIndex, matchCount, true);
                    }
                }
                break;
            }
        case CLEAR_CARET_HANDLE:
            if (mIsCaretSelection) {
                selectionDone();
            }
            break;
        case KEY_PRESS:
            sendBatchableInputMessage(EventHub.KEY_PRESS, msg.arg1, 0, null);
            break;
        case RELOCATE_AUTO_COMPLETE_POPUP:
            relocateAutoCompletePopup();
            break;
        case AUTOFILL_FORM:
            mWebViewCore.sendMessage(EventHub.AUTOFILL_FORM, msg.arg1, /* unused */
            0);
            break;
        case EDIT_TEXT_SIZE_CHANGED:
            if (msg.arg1 == mFieldPointer) {
                mEditTextContent.set((Rect) msg.obj);
            }
            break;
        case SHOW_CARET_HANDLE:
            if (!mSelectingText && mIsEditingText && mIsCaretSelection) {
                setupWebkitSelect();
                resetCaretTimer();
                showPasteWindow();
            }
            break;
        case UPDATE_CONTENT_BOUNDS:
            mEditTextContentBounds.set((Rect) msg.obj);
            nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
            break;
        case SCROLL_EDIT_TEXT:
            scrollEditWithCursor();
            break;
        case SCROLL_HANDLE_INTO_VIEW:
            scrollDraggedSelectionHandleIntoView();
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
129,"<android.widget.ProgressBar.RefreshData: RefreshData obtain(int,int,boolean)>",17,18,"<android.widget.ProgressBar.RefreshData: RefreshData obtain(int,int,boolean)>","<android.widget.ProgressBar.RefreshData: RefreshData obtain(int,int,boolean)>",0,"{
    RefreshData rd = sPool.acquire();
    rd.id = id;
    rd.progress = progress;
    rd.fromUser = fromUser;
    return rd;
}","{
    RefreshData rd = sPool.acquire();
    if (rd == null) {
        rd = new RefreshData();
    }
    rd.id = id;
    rd.progress = progress;
    rd.fromUser = fromUser;
    return rd;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new 'if' statement added in the late version to instantiate a new `RefreshData` object when `sPool.acquire()` returns null, it thus indicates change in control dependency. Also, new statement `rd = new RefreshData()` has been added which is neither return nor exception handling. So, the change type is 3,4.","The introduction of a ""new RefreshData()"" in the new 'if' statement infers that the returned object in the late version could be different from the early version when `sPool.acquire()` returns null, making the CI type 1."
130,"<android.app.ApplicationLoaders: ClassLoader getClassLoader(String,String,ClassLoader)>",17,18,"<android.app.ApplicationLoaders: ClassLoader getClassLoader(String,String,ClassLoader)>","<android.app.ApplicationLoaders: ClassLoader getClassLoader(String,String,ClassLoader)>",0,"{
    /*
         * This is the parent we use if they pass ""null"" in.  In theory
         * this should be the ""system"" class loader; in practice we
         * don't use that and can happily (and more efficiently) use the
         * bootstrap class loader.
         */
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();
    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }
        /*
             * If we're one step up from the base class loader, find
             * something in our cache.  Otherwise, we create a whole
             * new ClassLoader for the zip archive.
             */
        if (parent == baseParent) {
            ClassLoader loader = mLoaders.get(zip);
            if (loader != null) {
                return loader;
            }
            PathClassLoader pathClassloader = new PathClassLoader(zip, libPath, parent);
            mLoaders.put(zip, pathClassloader);
            return pathClassloader;
        }
        return new PathClassLoader(zip, parent);
    }
}","{
    /*
         * This is the parent we use if they pass ""null"" in.  In theory
         * this should be the ""system"" class loader; in practice we
         * don't use that and can happily (and more efficiently) use the
         * bootstrap class loader.
         */
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();
    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }
        /*
             * If we're one step up from the base class loader, find
             * something in our cache.  Otherwise, we create a whole
             * new ClassLoader for the zip archive.
             */
        if (parent == baseParent) {
            ClassLoader loader = mLoaders.get(zip);
            if (loader != null) {
                return loader;
            }
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);
            PathClassLoader pathClassloader = new PathClassLoader(zip, libPath, parent);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            mLoaders.put(zip, pathClassloader);
            return pathClassloader;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);
        PathClassLoader pathClassloader = new PathClassLoader(zip, parent);
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        return pathClassloader;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in the implementation introduces two new method Trace.traceBegin and Trace.traceEnd, which do not change the return variable and do not throw any new exceptions. Therefore, the only code change type is 4.","The return statement remains the same and no new exception is thrown in the late version of the function, there is therefore no compatibility issue."
131,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>",17,18,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>",0,"{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), modeToMode(uri, mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                try {
                    fd = unstableProvider.openAssetFile(uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}","{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), modeToMode(uri, mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call unstableProvider.openAssetFile(uri, mode) has been changed to unstableProvider.openAssetFile(mPackageName, uri, mode) with an addition of new argument 'mPackageName'. This change is categorized as type 1 (Return statement changed) and type 5 (Dependent API changed).","The return value of the method might be different due to the added argument 'mPackageName' during the API call, which potentially alters the returned AssetFileDescriptor. Hence, this is a case of Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
133,<android.widget.NumberPicker.AccessibilityNodeProviderImpl: AccessibilityNodeInfo createAccessibilityNodeInfo(int)>,17,18,<android.widget.NumberPicker.AccessibilityNodeProviderImpl: AccessibilityNodeInfo createAccessibilityNodeInfo(int)>,<android.widget.NumberPicker.AccessibilityNodeProviderImpl: AccessibilityNodeInfo createAccessibilityNodeInfo(int)>,0,"{
    switch(virtualViewId) {
        case View.NO_ID:
            return createAccessibilityNodeInfoForNumberPicker(mScrollX, mScrollY, mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
        case VIRTUAL_VIEW_ID_DECREMENT:
            return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_DECREMENT, getVirtualDecrementButtonText(), mScrollX, mScrollY, mScrollX + (mRight - mLeft), mTopSelectionDividerTop + mSelectionDividerHeight);
        case VIRTUAL_VIEW_ID_INPUT:
            return createAccessibiltyNodeInfoForInputText();
        case VIRTUAL_VIEW_ID_INCREMENT:
            return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_INCREMENT, getVirtualIncrementButtonText(), mScrollX, mBottomSelectionDividerBottom - mSelectionDividerHeight, mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
    }
    return super.createAccessibilityNodeInfo(virtualViewId);
}","{
    switch(virtualViewId) {
        case View.NO_ID:
            return createAccessibilityNodeInfoForNumberPicker(mScrollX, mScrollY, mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
        case VIRTUAL_VIEW_ID_DECREMENT:
            return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_DECREMENT, getVirtualDecrementButtonText(), mScrollX, mScrollY, mScrollX + (mRight - mLeft), mTopSelectionDividerTop + mSelectionDividerHeight);
        case VIRTUAL_VIEW_ID_INPUT:
            return createAccessibiltyNodeInfoForInputText(mScrollX, mTopSelectionDividerTop + mSelectionDividerHeight, mScrollX + (mRight - mLeft), mBottomSelectionDividerBottom - mSelectionDividerHeight);
        case VIRTUAL_VIEW_ID_INCREMENT:
            return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_INCREMENT, getVirtualIncrementButtonText(), mScrollX, mBottomSelectionDividerBottom - mSelectionDividerHeight, mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
    }
    return super.createAccessibilityNodeInfo(virtualViewId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"Under `case VIRTUAL_VIEW_ID_INPUT:`, the method of `createAccessibiltyNodeInfoForInputText()` changed to `createAccessibiltyNodeInfoForInputText(mScrollX, mTopSelectionDividerTop + mSelectionDividerHeight, mScrollX + (mRight - mLeft), mBottomSelectionDividerBottom - mSelectionDividerHeight)`, which means the parameter list of the method `createAccessibiltyNodeInfoForInputText()` has changed. So the code change type is 1,5.","Since the method `createAccessibiltyNodeInfoForInputText()` in the return statement accepts different arguments in the late version, it might return a different value compared to the early version. Therefore, the CI type is 1."
134,"<android.os.Binder: void dump(FileDescriptor,String[])>",17,18,"<android.os.Binder: void dump(FileDescriptor,String[])>","<android.os.Binder: void dump(FileDescriptor,String[])>",0,"{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new PrintWriter(fout);
    try {
        dump(fd, pw, args);
    } finally {
        pw.flush();
    }
}","{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new PrintWriter(fout);
    try {
        final String disabled;
        synchronized (Binder.class) {
            disabled = sDumpDisabled;
        }
        if (disabled == null) {
            dump(fd, pw, args);
        } else {
            pw.println(sDumpDisabled);
        }
    } finally {
        pw.flush();
    }
}",1,"/**
 * Implemented to call the more convenient version
 * {@link #dump(FileDescriptor, PrintWriter, String[])}.
 */
","/**
 * Implemented to call the more convenient version
 * {@link #dump(FileDescriptor, PrintWriter, String[])}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The method call of dump() is now conditional under an if statement, and a new String variable 'disabled' is used in the new logic structure. Thus the code change type is 1,3.","The new introduced condition and logic can modify the control flow and output of the function, which means the return value may change and the CI type is 1."
135,"<android.app.Activity: boolean onMenuItemSelected(int,MenuItem)>",17,18,"<android.app.Activity: boolean onMenuItemSelected(int,MenuItem)>","<android.app.Activity: boolean onMenuItemSelected(int,MenuItem)>",0,"{
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            // Put event logging here so it gets called even if subclass
            // doesn't call through to superclass's implmeentation of each
            // of these methods below
            EventLog.writeEvent(50000, 0, item.getTitleCondensed());
            if (onOptionsItemSelected(item)) {
                return true;
            }
            if (mFragments.dispatchOptionsItemSelected(item)) {
                return true;
            }
            if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
                if (mParent == null) {
                    return onNavigateUp();
                } else {
                    return mParent.onNavigateUpFromChild(this);
                }
            }
            return false;
        case Window.FEATURE_CONTEXT_MENU:
            EventLog.writeEvent(50000, 1, item.getTitleCondensed());
            if (onContextItemSelected(item)) {
                return true;
            }
            return mFragments.dispatchContextItemSelected(item);
        default:
            return false;
    }
}","{
    CharSequence titleCondensed = item.getTitleCondensed();
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            // of these methods below
            if (titleCondensed != null) {
                EventLog.writeEvent(50000, 0, titleCondensed.toString());
            }
            if (onOptionsItemSelected(item)) {
                return true;
            }
            if (mFragments.dispatchOptionsItemSelected(item)) {
                return true;
            }
            if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
                if (mParent == null) {
                    return onNavigateUp();
                } else {
                    return mParent.onNavigateUpFromChild(this);
                }
            }
            return false;
        case Window.FEATURE_CONTEXT_MENU:
            if (titleCondensed != null) {
                EventLog.writeEvent(50000, 1, titleCondensed.toString());
            }
            if (onContextItemSelected(item)) {
                return true;
            }
            return mFragments.dispatchContextItemSelected(item);
        default:
            return false;
    }
}",1,"/**
 * Default implementation of
 * {@link android.view.Window.Callback#onMenuItemSelected}
 * for activities.  This calls through to the new
 * {@link #onOptionsItemSelected} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
","/**
 * Default implementation of
 * {@link android.view.Window.Callback#onMenuItemSelected}
 * for activities.  This calls through to the new
 * {@link #onOptionsItemSelected} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new statement that gets the title and adds it into the switch case statement. Also, the EventLog.writeEvent() statements have changed a bit. Therefore, the type of changes here are both control dependency change (3) and other statement change (4).","Although there are changes in the implementation, these changes only affect which title is logged, and do not affect the returned values or the exception handlings. Therefore, according to the definitions, no Compatibility Issue (CI) exists. The CI type is 0."
136,<android.widget.TextView: int getVerticalOffset(boolean)>,17,18,<android.widget.TextView: int getVerticalOffset(boolean)>,<android.widget.TextView: int getVerticalOffset(boolean)>,0,"{
    int voffset = 0;
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    Layout l = mLayout;
    if (!forceNormal && mText.length() == 0 && mHintLayout != null) {
        l = mHintLayout;
    }
    if (gravity != Gravity.TOP) {
        int boxht;
        if (l == mHintLayout) {
            boxht = getMeasuredHeight() - getCompoundPaddingTop() - getCompoundPaddingBottom();
        } else {
            boxht = getMeasuredHeight() - getExtendedPaddingTop() - getExtendedPaddingBottom();
        }
        int textht = l.getHeight();
        if (textht < boxht) {
            if (gravity == Gravity.BOTTOM)
                voffset = boxht - textht;
            else
                // (gravity == Gravity.CENTER_VERTICAL)
                voffset = (boxht - textht) >> 1;
        }
    }
    return voffset;
}","{
    int voffset = 0;
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    Layout l = mLayout;
    if (!forceNormal && mText.length() == 0 && mHintLayout != null) {
        l = mHintLayout;
    }
    if (gravity != Gravity.TOP) {
        int boxht = getBoxHeight(l);
        int textht = l.getHeight();
        if (textht < boxht) {
            if (gravity == Gravity.BOTTOM)
                voffset = boxht - textht;
            else
                // (gravity == Gravity.CENTER_VERTICAL)
                voffset = (boxht - textht) >> 1;
        }
    }
    return voffset;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement hasn't changed but the computation of the 'voffset' has been modified, especially the method 'getBoxHeight()' has been introduced in the late version, so the change type is ""1,4,5"".","As the method of computing 'voffset' has changed and 'getBoxHeight(l)' has been introduced in the late version, these changes can potentially make the API return a different value, the CI type is ""1""."
138,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,17,18,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
139,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,17,18,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mCaller.mContext, (IInputMethodCallback) msg.obj));
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mCaller.mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter of the method 'inputMethod.createSession' and 'new InputMethodSessionCallbackWrapper' are changed in the late version. So, the code change types are 1,5.","Different inputs of 'inputMethod.createSession' method in the late version could lead to different return results of 'executeMessage' method. Thus, the compatibility issue type is 1."
140,<android.widget.TextView: Locale getTextServicesLocale()>,17,18,<android.widget.TextView: Locale getTextServicesLocale()>,<android.widget.TextView: Locale getTextServicesLocale()>,0,"{
    if (mCurrentTextServicesLocaleCache == null) {
        // If there is no cached text services locale, just return the default locale.
        mCurrentTextServicesLocaleCache = Locale.getDefault();
    }
    // Start fetching the text services locale asynchronously.
    updateTextServicesLocaleAsync();
    return mCurrentTextServicesLocaleCache;
}","{
    return getTextServicesLocale(false);
}",1,"// by catching intent of keyboard switch event
","// by catching intent of keyboard switch event
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation has been changed, fixed to just return getTextServicesLocale(false). It no longer checks whether mCurrentTextServicesLocaleCache is null, doesn't invoke updateTextServicesLocaleAsync, and doesn't return mCurrentTextServicesLocaleCache. The dependent API 'getTextServicesLocale' is called, which is a change to the dependent API. Thus, the code change type is 1,5.","The API potentially returns a different value as the return statement has been changed to return a new method call getTextServicesLocale(false). It doesn't consider the condition and returns the same thing every time, unlike the previous implementation. This could cause a change in the API behavior, which makes the Compatibility Issue to be 1."
141,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",17,18,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>","<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",0,"{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int c;
    int count;
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        int temp;
        count = 1;
        c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i, len);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case AM_PM:
                replacement = DateUtils.getAMPMString(inDate.get(Calendar.AM_PM));
                break;
            case CAPITAL_AM_PM:
                // FIXME: this is the same as AM_PM? no capital?
                replacement = DateUtils.getAMPMString(inDate.get(Calendar.AM_PM));
                break;
            case DATE:
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case DAY:
                temp = inDate.get(Calendar.DAY_OF_WEEK);
                replacement = DateUtils.getDayOfWeekString(temp, count < 4 ? DateUtils.LENGTH_MEDIUM : DateUtils.LENGTH_LONG);
                break;
            case HOUR:
                temp = inDate.get(Calendar.HOUR);
                if (0 == temp)
                    temp = 12;
                replacement = zeroPad(temp, count);
                break;
            case HOUR_OF_DAY:
                replacement = zeroPad(inDate.get(Calendar.HOUR_OF_DAY), count);
                break;
            case MINUTE:
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case MONTH:
            case STANDALONE_MONTH:
                replacement = getMonthString(inDate, count, c);
                break;
            case SECONDS:
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case TIME_ZONE:
                replacement = getTimeZoneString(inDate, count);
                break;
            case YEAR:
                replacement = getYearString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned)
        return new SpannedString(s);
    else
        return s.toString();
}","{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int count;
    LocaleData localeData = LocaleData.get(Locale.getDefault());
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        count = 1;
        int c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i, len);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case 'A':
            case 'a':
                replacement = localeData.amPm[inDate.get(Calendar.AM_PM) - Calendar.AM];
                break;
            case 'd':
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case 'c':
            case 'E':
                replacement = getDayOfWeekString(localeData, inDate.get(Calendar.DAY_OF_WEEK), count, c);
                break;
            // hour in am/pm (0-11)
            case 'K':
            case // hour in am/pm (1-12)
            'h':
                {
                    int hour = inDate.get(Calendar.HOUR);
                    if (c == 'h' && hour == 0) {
                        hour = 12;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            // hour in day (0-23)
            case 'H':
            case // hour in day (1-24) [but see note below]
            'k':
                {
                    int hour = inDate.get(Calendar.HOUR_OF_DAY);
                    // times are abusing 'k'. http://b/8359981.
                    if (false && c == 'k' && hour == 0) {
                        hour = 24;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            case 'L':
            case 'M':
                replacement = getMonthString(localeData, inDate.get(Calendar.MONTH), count, c);
                break;
            case 'm':
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case 's':
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case 'y':
                replacement = getYearString(inDate.get(Calendar.YEAR), count);
                break;
            case 'z':
                replacement = getTimeZoneString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned) {
        return new SpannedString(s);
    } else {
        return s.toString();
    }
}",1,"/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
","/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"Several statements have been revised, including control flow changes (for instance, 'if', 'for', 'while', and 'switch' statements), and other changes including the alteration of used constant values from direct numbers to variables (e.g., 'A' to 'a', 'd', 'c', 'E', etc). In addition, a new variable (localeData) from another API has been introduced and affected the calculation of 'replacement'. Therefore, the change types involve 3 (control dependency change), 4 (other statement changed), and 5 (dependent API changed).","The variable 'replacement' is used in 's.replace()' function which then contributes to the return value. Its calculation changes with the implementation update, which could affect the return value. Hence, this leads to Compatibility Issues under category 1 (Compatibility Issue caused by potential different return values or types)."
142,<android.appwidget.AppWidgetHost: void stopListening()>,17,18,<android.appwidget.AppWidgetHost: void stopListening()>,<android.appwidget.AppWidgetHost: void stopListening()>,0,"{
    try {
        sService.stopListening(mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.stopListening(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}",1,"/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
","/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method sService.stopListening(...) is called with different parameters between the two versions as a new parameter 'mContext.getUserId()' is added in the late version, indicating a Dependent API change (5). The early version method does not have the 'clearViews();' statement which is present in the late version, indicating Other statement changed (4). The return statement has changed as a new line of code (clearViews();) is added after it in the late version, indicating Return statement changed (1).","The change in return statement could cause the method to behave differently as an extra statement (clearViews();) is executed in the late version. Thus, there is a Compatibility Issue caused by potential different return values or types (1)."
143,"<android.text.format.DateUtils: String formatElapsedTime(StringBuilder,long)>",17,18,"<android.text.format.DateUtils: String formatElapsedTime(StringBuilder,long)>","<android.text.format.DateUtils: String formatElapsedTime(StringBuilder,long)>",0,"{
    initFormatStrings();
    long hours = 0;
    long minutes = 0;
    long seconds = 0;
    if (elapsedSeconds >= 3600) {
        hours = elapsedSeconds / 3600;
        elapsedSeconds -= hours * 3600;
    }
    if (elapsedSeconds >= 60) {
        minutes = elapsedSeconds / 60;
        elapsedSeconds -= minutes * 60;
    }
    seconds = elapsedSeconds;
    String result;
    if (hours > 0) {
        return formatElapsedTime(recycle, sElapsedFormatHMMSS, hours, minutes, seconds);
    } else {
        return formatElapsedTime(recycle, sElapsedFormatMMSS, minutes, seconds);
    }
}","{
    // Break the elapsed seconds into hours, minutes, and seconds.
    long hours = 0;
    long minutes = 0;
    long seconds = 0;
    if (elapsedSeconds >= 3600) {
        hours = elapsedSeconds / 3600;
        elapsedSeconds -= hours * 3600;
    }
    if (elapsedSeconds >= 60) {
        minutes = elapsedSeconds / 60;
        elapsedSeconds -= minutes * 60;
    }
    seconds = elapsedSeconds;
    // Create a StringBuilder if we weren't given one to recycle.
    // TODO: if we cared, we could have a thread-local temporary StringBuilder.
    StringBuilder sb = recycle;
    if (sb == null) {
        sb = new StringBuilder(8);
    } else {
        sb.setLength(0);
    }
    // Format the broken-down time in a locale-appropriate way.
    // TODO: use icu4c when http://unicode.org/cldr/trac/ticket/3407 is fixed.
    Formatter f = new Formatter(sb, Locale.getDefault());
    initFormatStrings();
    if (hours > 0) {
        return f.format(sElapsedFormatHMMSS, hours, minutes, seconds).toString();
    } else {
        return f.format(sElapsedFormatMMSS, minutes, seconds).toString();
    }
}",1,"/**
 * Formats an elapsed time in the form ""MM:SS"" or ""H:MM:SS""
 * for display on the call-in-progress screen.
 *
 * @param recycle {@link StringBuilder} to recycle, if possible
 * @param elapsedSeconds the elapsed time in seconds.
 */
","/**
 * Formats an elapsed time in a format like ""MM:SS"" or ""H:MM:SS"" (using a form
 * suited to the current locale), similar to that used on the call-in-progress
 * screen.
 *
 * @param recycle {@link StringBuilder} to recycle, or null to use a temporary one.
 * @param elapsedSeconds the elapsed time in seconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method used to return values, formatElapsedTime(), has been replaced by f.format(). The first parameter of formatElapsedTime and f.format are different, being recycle and sb respectively. Also, there are new instances of StringBuilder and Formatter being created and a call to setLength method that weren't present in the early version, so the code change types are 1 and 4.","As the return statement has changed from formatElapsedTime() to f.format(). The format method might return different values compared with formatElapsedTime method, thus the CI type is 1. The removal of the initFormatStrings() method and the addition of the setLength() method may not lead to the API returning a different value or throwing different exceptions, so they do not affect the CI type."
145,<android.content.PeriodicSync: boolean equals(Object)>,17,18,<android.content.PeriodicSync: boolean equals(Object)>,<android.content.PeriodicSync: boolean equals(Object)>,0,"{
    if (o == this) {
        return true;
    }
    if (!(o instanceof PeriodicSync)) {
        return false;
    }
    final PeriodicSync other = (PeriodicSync) o;
    return account.equals(other.account) && authority.equals(other.authority) && period == other.period && SyncStorageEngine.equals(extras, other.extras);
}","{
    if (o == this) {
        return true;
    }
    if (!(o instanceof PeriodicSync)) {
        return false;
    }
    final PeriodicSync other = (PeriodicSync) o;
    return account.equals(other.account) && authority.equals(other.authority) && period == other.period && syncExtrasEquals(extras, other.extras);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The function 'SyncStorageEngine.equals()' used in the return statement has been replaced with 'syncExtrasEquals()', that's why change type is 4,5.","The change in the method used in the return statement can potentially lead to a different return value, hence CI type is 1."
148,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,17,18,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                perfromAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_VIEW_ID:
            {
                findAccessibilityNodeInfoByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                perfromAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBLITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBLITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5","1,2","In the switch statement, the method call findAccessibilityNodeInfoByViewIdUiThread(message) was changed to findAccessibilityNodeInfosByViewIdUiThread(message), indicating both control dependency and dependent API changes, hence the classification 3,5.","The change in the method name from findAccessibilityNodeInfoByViewIdUiThread to findAccessibilityNodeInfosByViewIdUiThread indicates different functionalities which might potentially yield different return values or exceptions, leading to both a potential difference in return values and exception handling, hence CI type is 1,2."
149,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,17,18,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,0,"{
    try {
        return getService().getPrimaryClipDescription();
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return getService().getPrimaryClipDescription(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
","/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late version of the API introduces a new parameter 'mContext.getBasePackageName()' to the getPrimaryClipDescription() function, so the code change type is 1 and 5.","The addition of new parameter to the function getPrimaryClipDescription() might possibly cause the late version API to return a different value. Therefore, the CI type is 1."
150,<android.os.WorkSource: String toString()>,17,18,<android.os.WorkSource: String toString()>,<android.os.WorkSource: String toString()>,0,"{
    StringBuilder result = new StringBuilder();
    result.append(""{WorkSource: uids=["");
    for (int i = 0; i < mNum; i++) {
        if (i != 0) {
            result.append("", "");
        }
        result.append(mUids[i]);
    }
    result.append(""]}"");
    return result.toString();
}","{
    StringBuilder result = new StringBuilder();
    result.append(""WorkSource{"");
    for (int i = 0; i < mNum; i++) {
        if (i != 0) {
            result.append("", "");
        }
        result.append(mUids[i]);
        if (mNames != null) {
            result.append("" "");
            result.append(mNames[i]);
        }
    }
    result.append(""}"");
    return result.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The initial string attached to the StringBuilder, the for loop, and the append statements within the loop have all changed. Hence, the change types are 1, 3, 4.","The method can potentially return a different value due to the alterations in the string content, resulting in a compatibility issue of type 1."
151,<android.view.GLES20DisplayList: int getSize()>,17,18,<android.view.GLES20DisplayList: int getSize()>,<android.view.GLES20DisplayList: int getSize()>,0,"{
    if (mFinalizer == null)
        return 0;
    return GLES20Canvas.getDisplayListSize(mFinalizer.mNativeDisplayList);
}","{
    if (mFinalizer == null)
        return 0;
    return nGetDisplayListSize(mFinalizer.mNativeDisplayList);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called in the return statement has changed from GLES20Canvas.getDisplayListSize() to nGetDisplayListSize(). So, the code change type is 1 and 5.","The change in the method that is called in the return statement may cause the method to return a different value, thus leading to compatibility issue type 1."
152,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,17,18,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,0,"{
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}","{
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null, 0);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null, 0);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}",1,"/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @deprecated use {@link #setNdefPushMessage} instead
 */
","/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",0,"The method setNdefPushMessage and setNdefPushMessageCallback in the mNfcActivityManager object have changed in terms of parameters, which now includes '0' as an extra argument, so the change type is 1,5.","Despite the changes in the methods' parameters of the dependent API, these changes do not lead to any compatibility issues as they don't alter the return values or exception handling of the API. Therefore, there is no compatibility issue present, hence, CI type is 0."
153,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",17,18,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",0,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.setAllowFds(false);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
    }
}","{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess();
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Two new methods (migrateExtraStreamToClipData() and prepareToLeaveProcess()) have been added to the fillInIntent object, which are not return statements, exception handling, control dependencies, or dependent APIs. They are other type of statement changes, so the code change type is 4.","Despite the addition of the new methods within the fillInIntent, they do not change the return type and do not result in differing exceptions. Therefore, no compatibility issue exists (CI type 0)."
155,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,17,18,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,0,"{
    try {
        WindowManagerGlobal.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
","/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The calling of dependent API WindowManagerGlobal.getWindowSession() changed by removing a parameter (mContext.getMainLooper()), so the code change type is 5.","The reduction of parameter in the method getWindowSession() could potentially lead to a different return, thus the possible CI type is 1."
156,<android.view.ViewGroup.MarginLayoutParams: int getMarginEnd()>,17,18,<android.view.ViewGroup.MarginLayoutParams: int getMarginEnd()>,<android.view.ViewGroup.MarginLayoutParams: int getMarginEnd()>,0,"{
    if (endMargin != DEFAULT_RELATIVE)
        return endMargin;
    switch(layoutDirection) {
        case View.LAYOUT_DIRECTION_RTL:
            return leftMargin;
        case View.LAYOUT_DIRECTION_LTR:
        default:
            return rightMargin;
    }
}","{
    if (endMargin != DEFAULT_MARGIN_RELATIVE)
        return endMargin;
    if ((mMarginFlags & NEED_RESOLUTION_MASK) == NEED_RESOLUTION_MASK) {
        doResolveMargins();
    }
    switch(mMarginFlags & LAYOUT_DIRECTION_MASK) {
        case View.LAYOUT_DIRECTION_RTL:
            return leftMargin;
        case View.LAYOUT_DIRECTION_LTR:
        default:
            return rightMargin;
    }
}",1,"/**
 * Returns the end margin in pixels.
 *
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 *
 * @return the end margin in pixels.
 */
","/**
 * Returns the end margin in pixels.
 *
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 *
 * @return the end margin in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The parameter in the first 'if' statement and the 'switch' statement has changed, an 'if' statement was added in the late version, so the code change type is 1,3,4.","The added 'if' statement and the changed comparison value in the first 'if' statement could cause the method to return different values, hence the CI type is 1."
159,"<android.view.View: void measure(int,int)>",17,18,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        // measure ourselves, this should set the measured dimension flag back
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}","{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        // measure ourselves, this should set the measured dimension flag back
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version, new lines of code have been added to adjust the width and height of the view based on the optical layout mode. The control statement of checking whether mode and parent's mode are optical or not is introduced, along with internally calling getOpticalInsets() and MeasureSpec.adjust(), so the code change type is 3,4.","Although a new code block has been added at the beginning of the method in the late version, it does not change the return value or exception handling of the method itself. Thus, we can consider there is no compatibility issue. The CI type is 0."
160,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",17,18,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The statement 'intent.setAllowFds(false)' was replaced with 'intent.prepareToLeaveProcess()' and the parameter list of the function 'ActivityManagerNative.getDefault().broadcastIntent()' has also been changed in the late version, so the code change type is 4,5.","The changes in how 'intent' is prepared and the altered parameters of the broadcastIntent(...) function call, could potentially lead to a different behavior when invoking this API in the late version, thus the Compatibility Issue type is 1."
162,<android.app.Notification.BigTextStyle: Notification build()>,17,18,<android.app.Notification.BigTextStyle: Notification build()>,<android.app.Notification.BigTextStyle: Notification build()>,0,"{
    checkBuilder();
    Notification wip = mBuilder.buildUnstyled();
    wip.bigContentView = makeBigContentView();
    return wip;
}","{
    checkBuilder();
    Notification wip = mBuilder.buildUnstyled();
    wip.bigContentView = makeBigContentView();
    wip.extras.putCharSequence(EXTRA_TEXT, mBigText);
    return wip;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"A new statement 'wip.extras.putCharSequence(EXTRA_TEXT, mBigText);' is added in the late version. According to the rule, the added statement causes both Return statement changed (type 1) and Other statement changed (type 4).","Due to the added statement, the returned notification `wip` will carry more data (mBigText), causing the return statement potentially yield different results between two versions. So the CI type is 1."
163,"<android.view.View: void postInvalidateOnAnimation(int,int,int,int)>",17,18,"<android.view.View: void postInvalidateOnAnimation(int,int,int,int)>","<android.view.View: void postInvalidateOnAnimation(int,int,int,int)>",0,"{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.acquire();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        attachInfo.mViewRootImpl.dispatchInvalidateRectOnAnimation(info);
    }
}","{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.obtain();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        attachInfo.mViewRootImpl.dispatchInvalidateRectOnAnimation(info);
    }
}",1,"/**
 * <p>Cause an invalidate of the specified area to happen on the next animation
 * time step, typically the next display frame.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 *
 * @see #invalidate(int, int, int, int)
 * @see #invalidate(Rect)
 */
","/**
 * <p>Cause an invalidate of the specified area to happen on the next animation
 * time step, typically the next display frame.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 *
 * @see #invalidate(int, int, int, int)
 * @see #invalidate(Rect)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the early version, 'AttachInfo.InvalidateInfo.acquire()' was used, while in the late version, 'AttachInfo.InvalidateInfo.obtain()' was used. Hence, the change type is 4,5.","The method 'AttachInfo.InvalidateInfo.obtain()' may return a different value than 'AttachInfo.InvalidateInfo.acquire()'. Consequently, the dependent APIs could have different behaviors. Hence, the CI type is 1."
165,<android.view.accessibility.AccessibilityNodeInfo: boolean isVisibleToUser()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isVisibleToUser()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isVisibleToUser()>,0,"{
    return getBooleanProperty(PROPERTY_VISIBLE_TO_USER);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_VISIBLE_TO_USER);
}",1,"/**
 * Sets whether this node is visible to the user.
 *
 * @return Whether the node is visible to the user.
 */
","/**
 * Sets whether this node is visible to the user.
 *
 * @return Whether the node is visible to the user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the return statement, parameter value of the 'getBooleanProperty' method has been changed. Therefore, the change type is 1,5.","The return statement has been modified in such a way that the late version of the API may potentially return a different value, leading to the Compatibility Issue type of 1."
166,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,17,18,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,<android.speech.tts.TextToSpeechService.SynthHandler: int stopAll()>,0,"{
    // Stop the current speech item unconditionally.
    SpeechItem current = setCurrentSpeechItem(null);
    if (current != null) {
        current.stop();
    }
    // Remove all other items from the queue.
    removeCallbacksAndMessages(null);
    // Remove all pending playback as well.
    mAudioPlaybackHandler.stop();
    return TextToSpeech.SUCCESS;
}","{
    // Stop the current speech item unconditionally .
    SpeechItem current = setCurrentSpeechItem(null);
    if (current != null) {
        current.stop();
    }
    // Remove all other items from the queue.
    removeCallbacksAndMessages(null);
    // Remove all pending playback as well.
    mAudioPlaybackHandler.stop();
    return TextToSpeech.SUCCESS;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no changes between the early and late versions of this API implementation.,No Compatibility Issues exist as there are no changes in the given API between two versions.
167,<android.view.ViewGroup.MarginLayoutParams: int getLayoutDirection()>,17,18,<android.view.ViewGroup.MarginLayoutParams: int getLayoutDirection()>,<android.view.ViewGroup.MarginLayoutParams: int getLayoutDirection()>,0,"{
    return layoutDirection;
}","{
    return (mMarginFlags & LAYOUT_DIRECTION_MASK);
}",1,"/**
 * Retuns the layout direction. Can be either {@link View#LAYOUT_DIRECTION_LTR} or
 * {@link View#LAYOUT_DIRECTION_RTL}.
 *
 * @return the layout direction.
 */
","/**
 * Retuns the layout direction. Can be either {@link View#LAYOUT_DIRECTION_LTR} or
 * {@link View#LAYOUT_DIRECTION_RTL}.
 *
 * @return the layout direction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'layoutDirection' to '(mMarginFlags & LAYOUT_DIRECTION_MASK)', so the code change type is 1.","The change of the return statement will make the API potentially return a different value, so the CI type is 1."
169,"<android.view.KeyCharacterMap: int getDeadChar(int,int)>",17,18,"<android.view.KeyCharacterMap: int getDeadChar(int,int)>","<android.view.KeyCharacterMap: int getDeadChar(int,int)>",0,"{
    int combining = sAccentToCombining.get(accent);
    if (combining == 0) {
        return 0;
    }
    final int combination = (combining << 16) | c;
    int combined;
    synchronized (sDeadKeyCache) {
        combined = sDeadKeyCache.get(combination, -1);
        if (combined == -1) {
            sDeadKeyBuilder.setLength(0);
            sDeadKeyBuilder.append((char) c);
            sDeadKeyBuilder.append((char) combining);
            String result = Normalizer.normalize(sDeadKeyBuilder, Normalizer.Form.NFC);
            combined = result.length() == 1 ? result.charAt(0) : 0;
            sDeadKeyCache.put(combination, combined);
        }
    }
    return combined;
}","{
    if (c == accent || CHAR_SPACE == c) {
        // In this case we don't even need to compute the combining character.
        return accent;
    }
    int combining = sAccentToCombining.get(accent);
    if (combining == 0) {
        return 0;
    }
    final int combination = (combining << 16) | c;
    int combined;
    synchronized (sDeadKeyCache) {
        combined = sDeadKeyCache.get(combination, -1);
        if (combined == -1) {
            sDeadKeyBuilder.setLength(0);
            sDeadKeyBuilder.append((char) c);
            sDeadKeyBuilder.append((char) combining);
            String result = Normalizer.normalize(sDeadKeyBuilder, Normalizer.Form.NFC);
            combined = result.codePointCount(0, result.length()) == 1 ? result.codePointAt(0) : 0;
            sDeadKeyCache.put(combination, combined);
        }
    }
    return combined;
}",1,"/**
 * Get the character that is produced by putting accent on the character c.
 * For example, getDeadChar('`', 'e') returns &egrave;.
 *
 * @param accent The accent character.  eg. '`'
 * @param c The basic character.
 * @return The combined character, or 0 if the characters cannot be combined.
 */
","/**
 * Get the character that is produced by combining the dead key producing accent
 * with the key producing character c.
 * For example, getDeadChar('`', 'e') returns &egrave;.
 * getDeadChar('^', ' ') returns '^' and getDeadChar('^', '^') returns '^'.
 *
 * @param accent The accent character.  eg. '`'
 * @param c The basic character.
 * @return The combined character, or 0 if the characters cannot be combined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"New if condition (if (c == accent || CHAR_SPACE == c)) introduced and combined variable assignment statement changed (combined = result.length() == 1 ? result.charAt(0) : 0 to combined = result.codePointCount(0, result.length()) == 1 ? result.codePointAt(0) : 0), so the code change type is 1,3.","The added if condition and the change in the assignment of combined can potentially change the return value of the API, leading to compatibility issues. Thus, the type of CI is considered to be 1."
171,<android.content.res.Resources: int getInteger(int)>,17,18,<android.content.res.Resources: int getInteger(int)>,<android.content.res.Resources: int getInteger(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}",1,"/**
 * Return an integer associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the integer value contained in the resource.
 */
","/**
 * Return an integer associated with a particular resource ID.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the integer value contained in the resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There's change in synchronized block which changes from synchronized (mTmpValue) to synchronized (mAccessLock). Also, a new if statement is introduced that checks if value is null and if it is, this assigns a new 'TypedValue()' to 'mTmpValue'. So, the code change type is 3,4.","Although there were changes in the code, these changes will not affect the results of the method or the Exceptions that are thrown by the method in relation to its input, hence there's no Compatibility Issue, CI type is 0."
172,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",17,18,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                } else if (mCurMethod == null) {
                    // This means there is no input method available.
                    if (DEBUG)
                        Log.v(TAG, ""ABORT input: no input method!"");
                    return true;
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            @Override
            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    setInputChannelLocked(res.channel);
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                } else {
                    if (res.channel != null && res.channel != mCurChannel) {
                        res.channel.dispose();
                    }
                    if (mCurMethod == null) {
                        // This means there is no input method available.
                        if (DEBUG)
                            Log.v(TAG, ""ABORT input: no input method!"");
                        return true;
                    }
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","Several changes have been introduced in the latest version. A new method, setInputChannelLocked(res.channel), is called when res.id is not null, and an additional condition, res.channel != mCurChannel, is introduced in the next 'if' statement. A dispose() method is invoked when this condition is met. Consequently, the code change type is 1,4,5.","The introduced changes could potentially lead to different return values or throw different exceptions; For instance, if res.id is not null, the method setInputChannelLocked() has a chance to throw an exception if any unexpected scenario happens inside. Additionally, the changes to the 'if' condition and the introduction of the dispose() method also affect the control flow and potentially return value, leading to a CI of type 1 and 2."
173,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,17,18,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,0,"{
    try {
        getService().setPrimaryClip(clip);
    } catch (RemoteException e) {
    }
}","{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess();
        }
        getService().setPrimaryClip(clip, mContext.getBasePackageName());
    } catch (RemoteException e) {
    }
}",1,"/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
","/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"In the new version, a new 'if' control statement is added, the content inside the getService().setPrimaryClip() method also changes, and a invocation of two new methods clip.prepareToLeaveProcess() and mContext.getBasePackageName() are added. So the code change types are 1,3,4,5.","Though several changes have occurred in the new version, none of them appears to affect what the method returns or the exceptions it might throw, hence there are no compatibility issues."
174,<android.animation.ValueAnimator: boolean animationFrame(long)>,17,18,<android.animation.ValueAnimator: boolean animationFrame(long)>,<android.animation.ValueAnimator: boolean animationFrame(long)>,0,"{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = mPlayingBackwards ? false : true;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}","{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}",1,"/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code> has been exceeded and the animation should be ended.
 */
","/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code> has been exceeded and the animation should be ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The operation to change mPlayingBackwards value has transformed from a ternary operation to a simple negation operation, so the change type is 4.","No CI is expected to occur since this change doesn't affect the returned value or thrown exceptions by the API, the CI type is 0."
175,<android.preference.PreferenceActivity: void switchToHeader(Header)>,17,18,<android.preference.PreferenceActivity: void switchToHeader(Header)>,<android.preference.PreferenceActivity: void switchToHeader(Header)>,0,"{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        int direction = mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
        switchToHeaderInner(header.fragment, header.fragmentArguments, direction);
        setSelectedHeader(header);
    }
}","{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        if (header.fragment == null) {
            throw new IllegalStateException(""can't switch to header that has no fragment"");
        }
        int direction = mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
        switchToHeaderInner(header.fragment, header.fragmentArguments, direction);
        setSelectedHeader(header);
    }
}",1,"/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
","/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late implementation, there is an additional check to verify if ""header.fragment"" is null or not and throwing an exception if it is, so the code change types are 2,3.","The change in the code potentially raises a new exception and this could change the behaviour of the API, potentially leading to a different return or an unexpected exception. So, the CI types are 1,2."
176,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,17,18,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,0,"{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(mId);
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""retrieveScreenContent: "").append(mCanRetrieveWindowContent);
    return stringBuilder.toString();
}","{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(mId);
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been altered in the late version, which includes an additional method call, appendCapabilities(stringBuilder, mCapabilities), so the code change type is 1.","The change in the return statement could lead to different string output in the late version, therefore the CI type is 1."
177,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",17,18,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        Cursor qCursor;
        try {
            qCursor = unstableProvider.query(uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // force query execution
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object
        CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri));
        stableProvider = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri));
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}",1,"/**
 * <p>
 * Query the given URI, returning a {@link Cursor} over the result set.
 * </p>
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * <p>
 * Query the given URI, returning a {@link Cursor} over the result set.
 * </p>
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The query() function called in both the try and catch blocks have been updated to include an additional parameter 'mPackageName'. An additional local variable 'qCursor' is defined at the start and it's eventually closed in the finally block. There is also a change in the order of some statements. Therefore, the code change is classified as type 1 (Return statement changed), type 3 (Control dependency changed), and type 4 (Other statement changed).","The addition of a new parameter to the query() function could potentially change the return value of the function and thus affect the return value of the API, considering the query() function's result is used in the return statement. Therefore, the Compatibility Issue type is 1 (Compatibility Issue caused by potential different return values or types)."
178,"<android.webkit.CallbackProxy: boolean onJsBeforeUnload(String,String)>",17,18,"<android.webkit.CallbackProxy: boolean onJsBeforeUnload(String,String)>","<android.webkit.CallbackProxy: boolean onJsBeforeUnload(String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return true;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message confirm = obtainMessage(JS_UNLOAD, result);
    confirm.getData().putString(""message"", message);
    confirm.getData().putString(""url"", url);
    sendMessageToUiThreadSync(confirm);
    return result.mJsResult.getResult();
}","{
    // been set.
    if (mWebChromeClient == null) {
        return true;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message unload = obtainMessage(JS_DIALOG, result);
    unload.getData().putString(""message"", message);
    unload.getData().putString(""url"", url);
    unload.getData().putInt(""type"", JsDialogHelper.UNLOAD);
    sendMessageToUiThreadSync(unload);
    return result.mJsResult.getResult();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The code has changed during the creation of the 'Message' object, specifically the parameter given to 'obtainMessage()' and addition of a 'putInt()' method, as well as changed constant used as the parameter. Hence, the code change can be classified as type 1 (Return statement changed) and type 4 (Other statement changed).","Despite the changes in the code, 'result.mJsResult.getResult()' is still returned. However, as the 'Message' object creation and population have been modified, the returned value of 'result.mJsResult.getResult()' could potentially be different, causing a type 1 Compatibility Issue (CI caused by potential different return values)."
179,"<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>",17,18,"<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>","<android.appwidget.AppWidgetManager: void updateAppWidget(ComponentName,RemoteViews)>",0,"{
    try {
        sService.updateAppWidgetProvider(provider, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.updateAppWidgetProvider(provider, views, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * @param provider      The {@link ComponentName} for the {@link
 * android.content.BroadcastReceiver BroadcastReceiver} provider
 * for your AppWidget.
 * @param views         The RemoteViews object to show.
 */
","/**
 * Set the RemoteViews to use for all AppWidget instances for the supplied AppWidget provider.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * @param provider      The {@link ComponentName} for the {@link
 * android.content.BroadcastReceiver BroadcastReceiver} provider
 * for your AppWidget.
 * @param views         The RemoteViews object to show.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"sService.updateAppWidgetProvider() method has added a new parameter mContext.getUserId() in the newer version, thus comes under change category 1 and 5. ","Despite of the change in method's signature, its functional behaviour remains same, thus no compatibility issue exists(API returns nothing nor throws a different exception)."
180,"<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",17,18,"<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>","<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",0,"{
    Editable editable = (Editable) mTextView.getText();
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
        int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
        if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
            // Do not leave two adjacent spaces after deletion, or one at beginning of text
            if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                spanUnionEnd = spanUnionEnd + 1;
            }
            mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
        }
        hide();
        return;
    }
    final int spanStart = editable.getSpanStart(suggestionInfo.suggestionSpan);
    final int spanEnd = editable.getSpanEnd(suggestionInfo.suggestionSpan);
    if (spanStart < 0 || spanEnd <= spanStart) {
        // Span has been removed
        hide();
        return;
    }
    final String originalText = editable.toString().substring(spanStart, spanEnd);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
        intent.putExtra(""word"", originalText);
        intent.putExtra(""locale"", mTextView.getTextServicesLocale().toString());
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        mTextView.getContext().startActivity(intent);
        // There is no way to know if the word was indeed added. Re-check.
        // TODO The ExtractEditText should remove the span in the original text instead
        editable.removeSpan(suggestionInfo.suggestionSpan);
        Selection.setSelection(editable, spanEnd);
        updateSpellCheckSpans(spanStart, spanEnd, false);
    } else {
        // SuggestionSpans are removed by replace: save them before
        SuggestionSpan[] suggestionSpans = editable.getSpans(spanStart, spanEnd, SuggestionSpan.class);
        final int length = suggestionSpans.length;
        int[] suggestionSpansStarts = new int[length];
        int[] suggestionSpansEnds = new int[length];
        int[] suggestionSpansFlags = new int[length];
        for (int i = 0; i < length; i++) {
            final SuggestionSpan suggestionSpan = suggestionSpans[i];
            suggestionSpansStarts[i] = editable.getSpanStart(suggestionSpan);
            suggestionSpansEnds[i] = editable.getSpanEnd(suggestionSpan);
            suggestionSpansFlags[i] = editable.getSpanFlags(suggestionSpan);
            // Remove potential misspelled flags
            int suggestionSpanFlags = suggestionSpan.getFlags();
            if ((suggestionSpanFlags & SuggestionSpan.FLAG_MISSPELLED) > 0) {
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_MISSPELLED;
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_EASY_CORRECT;
                suggestionSpan.setFlags(suggestionSpanFlags);
            }
        }
        final int suggestionStart = suggestionInfo.suggestionStart;
        final int suggestionEnd = suggestionInfo.suggestionEnd;
        final String suggestion = suggestionInfo.text.subSequence(suggestionStart, suggestionEnd).toString();
        mTextView.replaceText_internal(spanStart, spanEnd, suggestion);
        // Notify source IME of the suggestion pick. Do this before swaping texts.
        if (!TextUtils.isEmpty(suggestionInfo.suggestionSpan.getNotificationTargetClassName())) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null) {
                imm.notifySuggestionPicked(suggestionInfo.suggestionSpan, originalText, suggestionInfo.suggestionIndex);
            }
        }
        // Swap text content between actual text and Suggestion span
        String[] suggestions = suggestionInfo.suggestionSpan.getSuggestions();
        suggestions[suggestionInfo.suggestionIndex] = originalText;
        // Restore previous SuggestionSpans
        final int lengthDifference = suggestion.length() - (spanEnd - spanStart);
        for (int i = 0; i < length; i++) {
            // way to assign them a valid range after replacement
            if (suggestionSpansStarts[i] <= spanStart && suggestionSpansEnds[i] >= spanEnd) {
                mTextView.setSpan_internal(suggestionSpans[i], suggestionSpansStarts[i], suggestionSpansEnds[i] + lengthDifference, suggestionSpansFlags[i]);
            }
        }
        // Move cursor at the end of the replaced word
        final int newCursorPosition = spanEnd + lengthDifference;
        mTextView.setCursorPosition_internal(newCursorPosition, newCursorPosition);
    }
    hide();
}","{
    Editable editable = (Editable) mTextView.getText();
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
        int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
        if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
            // Do not leave two adjacent spaces after deletion, or one at beginning of text
            if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                spanUnionEnd = spanUnionEnd + 1;
            }
            mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
        }
        hide();
        return;
    }
    final int spanStart = editable.getSpanStart(suggestionInfo.suggestionSpan);
    final int spanEnd = editable.getSpanEnd(suggestionInfo.suggestionSpan);
    if (spanStart < 0 || spanEnd <= spanStart) {
        // Span has been removed
        hide();
        return;
    }
    final String originalText = editable.toString().substring(spanStart, spanEnd);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
        intent.putExtra(""word"", originalText);
        intent.putExtra(""locale"", mTextView.getTextServicesLocale().toString());
        // Put a listener to replace the original text with a word which the user
        // modified in a user dictionary dialog.
        mUserDictionaryListener.waitForUserDictionaryAdded(mTextView, originalText, spanStart, spanEnd);
        intent.putExtra(""listener"", new Messenger(mUserDictionaryListener));
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        mTextView.getContext().startActivity(intent);
        // There is no way to know if the word was indeed added. Re-check.
        // TODO The ExtractEditText should remove the span in the original text instead
        editable.removeSpan(suggestionInfo.suggestionSpan);
        Selection.setSelection(editable, spanEnd);
        updateSpellCheckSpans(spanStart, spanEnd, false);
    } else {
        // SuggestionSpans are removed by replace: save them before
        SuggestionSpan[] suggestionSpans = editable.getSpans(spanStart, spanEnd, SuggestionSpan.class);
        final int length = suggestionSpans.length;
        int[] suggestionSpansStarts = new int[length];
        int[] suggestionSpansEnds = new int[length];
        int[] suggestionSpansFlags = new int[length];
        for (int i = 0; i < length; i++) {
            final SuggestionSpan suggestionSpan = suggestionSpans[i];
            suggestionSpansStarts[i] = editable.getSpanStart(suggestionSpan);
            suggestionSpansEnds[i] = editable.getSpanEnd(suggestionSpan);
            suggestionSpansFlags[i] = editable.getSpanFlags(suggestionSpan);
            // Remove potential misspelled flags
            int suggestionSpanFlags = suggestionSpan.getFlags();
            if ((suggestionSpanFlags & SuggestionSpan.FLAG_MISSPELLED) > 0) {
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_MISSPELLED;
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_EASY_CORRECT;
                suggestionSpan.setFlags(suggestionSpanFlags);
            }
        }
        final int suggestionStart = suggestionInfo.suggestionStart;
        final int suggestionEnd = suggestionInfo.suggestionEnd;
        final String suggestion = suggestionInfo.text.subSequence(suggestionStart, suggestionEnd).toString();
        mTextView.replaceText_internal(spanStart, spanEnd, suggestion);
        // Notify source IME of the suggestion pick. Do this before
        // swaping texts.
        suggestionInfo.suggestionSpan.notifySelection(mTextView.getContext(), originalText, suggestionInfo.suggestionIndex);
        // Swap text content between actual text and Suggestion span
        String[] suggestions = suggestionInfo.suggestionSpan.getSuggestions();
        suggestions[suggestionInfo.suggestionIndex] = originalText;
        // Restore previous SuggestionSpans
        final int lengthDifference = suggestion.length() - (spanEnd - spanStart);
        for (int i = 0; i < length; i++) {
            // way to assign them a valid range after replacement
            if (suggestionSpansStarts[i] <= spanStart && suggestionSpansEnds[i] >= spanEnd) {
                mTextView.setSpan_internal(suggestionSpans[i], suggestionSpansStarts[i], suggestionSpansEnds[i] + lengthDifference, suggestionSpansFlags[i]);
            }
        }
        // Move cursor at the end of the replaced word
        final int newCursorPosition = spanEnd + lengthDifference;
        mTextView.setCursorPosition_internal(newCursorPosition, newCursorPosition);
    }
    hide();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,The main changes are addition of these two lines of code:,"intent.putExtra(""listener"", new Messenger(mUserDictionaryListener));"
181,<android.app.Instrumentation.InstrumentationThread: void run()>,17,18,<android.app.Instrumentation.InstrumentationThread: void run()>,<android.app.Instrumentation.InstrumentationThread: void run()>,0,"{
    IActivityManager am = ActivityManagerNative.getDefault();
    try {
        Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);
    } catch (RuntimeException e) {
        Log.w(TAG, ""Exception setting priority of instrumentation thread "" + Process.myTid(), e);
    }
    if (mAutomaticPerformanceSnapshots) {
        startPerformanceSnapshot();
    }
    onStart();
}","{
    try {
        Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);
    } catch (RuntimeException e) {
        Log.w(TAG, ""Exception setting priority of instrumentation thread "" + Process.myTid(), e);
    }
    if (mAutomaticPerformanceSnapshots) {
        startPerformanceSnapshot();
    }
    onStart();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The instantiation of IActivityManager 'am' is removed in the late version of the implementation. So the code change type is classified under 4, which corresponds to 'Other statement changed'.","Although an instantiation has been deleted, there is no effect on what the API returns as the 'am' instance was not used in the method's logic, nor does it affect the type of exceptions thrown by the method. Therefore, there is no Compatibility Issue (CI), hence CI type is 0."
186,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",17,18,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
","/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The argument of method provider.bulkInsert() has added one parameter 'mPackageName'. The call to method provider.bulkInsert() also has different arguments in two versions: from (url, values) to (mPackageName, url, values). So the types of the changes are 1 and 5.","The 'provider.bulkInsert(mPackageName, url, values)' in the late version can potentially return a different value from the early version's 'provider.bulkInsert(url, values)', hence the CI type is 1."
188,<android.webkit.WebViewClassic.InvokeListBox: void run()>,17,18,<android.webkit.WebViewClassic.InvokeListBox: void run()>,<android.webkit.WebViewClassic.InvokeListBox: void run()>,0,"{
    if (mWebViewCore == null || getWebView().getWindowToken() == null || getWebView().getViewRootImpl() == null) {
        // We've been detached and/or destroyed since this was posted
        return;
    }
    final ListView listView = (ListView) LayoutInflater.from(mContext).inflate(com.android.internal.R.layout.select_dialog, null);
    final MyArrayListAdapter adapter = new MyArrayListAdapter();
    AlertDialog.Builder b = new AlertDialog.Builder(mContext).setView(listView).setCancelable(true).setInverseBackgroundForced(true);
    if (mMultiple) {
        b.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                mWebViewCore.sendMessage(EventHub.LISTBOX_CHOICES, adapter.getCount(), 0, listView.getCheckedItemPositions());
            }
        });
        b.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                mWebViewCore.sendMessage(EventHub.SINGLE_LISTBOX_CHOICE, -2, 0);
            }
        });
    }
    mListBoxDialog = b.create();
    listView.setAdapter(adapter);
    listView.setFocusableInTouchMode(true);
    // There is a bug (1250103) where the checks in a ListView with
    // multiple items selected are associated with the positions, not
    // the ids, so the items do not properly retain their checks when
    // filtered.  Do not allow filtering on multiple lists until
    // that bug is fixed.
    listView.setTextFilterEnabled(!mMultiple);
    if (mMultiple) {
        listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
        int length = mSelectedArray.length;
        for (int i = 0; i < length; i++) {
            listView.setItemChecked(mSelectedArray[i], true);
        }
    } else {
        listView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
                // Rather than sending the message right away, send it
                // after the page regains focus.
                mListBoxMessage = Message.obtain(null, EventHub.SINGLE_LISTBOX_CHOICE, (int) id, 0);
                if (mListBoxDialog != null) {
                    mListBoxDialog.dismiss();
                    mListBoxDialog = null;
                }
            }
        });
        if (mSelection != -1) {
            listView.setSelection(mSelection);
            listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
            listView.setItemChecked(mSelection, true);
            DataSetObserver observer = new SingleDataSetObserver(adapter.getItemId(mSelection), listView, adapter);
            adapter.registerDataSetObserver(observer);
        }
    }
    mListBoxDialog.setOnCancelListener(new DialogInterface.OnCancelListener() {

        @Override
        public void onCancel(DialogInterface dialog) {
            mWebViewCore.sendMessage(EventHub.SINGLE_LISTBOX_CHOICE, -2, 0);
            mListBoxDialog = null;
        }
    });
    mListBoxDialog.show();
}","{
    if (mWebViewCore == null || getWebView().getWindowToken() == null || getWebView().getViewRootImpl() == null) {
        // We've been detached and/or destroyed since this was posted
        return;
    }
    final ListView listView = (ListView) LayoutInflater.from(mContext).inflate(com.android.internal.R.layout.select_dialog, null);
    final MyArrayListAdapter adapter = new MyArrayListAdapter();
    AlertDialog.Builder b = new AlertDialog.Builder(mContext).setView(listView).setCancelable(true).setInverseBackgroundForced(true);
    if (mMultiple) {
        b.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                mWebViewCore.sendMessage(EventHub.LISTBOX_CHOICES, adapter.getCount(), 0, listView.getCheckedItemPositions());
            }
        });
        b.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                mWebViewCore.sendMessage(EventHub.SINGLE_LISTBOX_CHOICE, -2, 0);
            }
        });
    }
    mListBoxDialog = b.create();
    listView.setAdapter(adapter);
    listView.setFocusableInTouchMode(true);
    // There is a bug (1250103) where the checks in a ListView with
    // multiple items selected are associated with the positions, not
    // the ids, so the items do not properly retain their checks when
    // filtered.  Do not allow filtering on multiple lists until
    // that bug is fixed.
    listView.setTextFilterEnabled(!mMultiple);
    if (mMultiple) {
        listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
        int length = mSelectedArray.length;
        for (int i = 0; i < length; i++) {
            listView.setItemChecked(mSelectedArray[i], true);
        }
    } else {
        listView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
                // Rather than sending the message right away, send it
                // after the page regains focus.
                mListBoxMessage = Message.obtain(null, EventHub.SINGLE_LISTBOX_CHOICE, (int) id, 0);
                if (mListBoxDialog != null) {
                    mListBoxDialog.dismiss();
                    mListBoxDialog = null;
                }
            }
        });
        if (mSelection != -1) {
            listView.setSelection(mSelection);
            listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
            listView.setItemChecked(mSelection, true);
            DataSetObserver observer = new SingleDataSetObserver(adapter.getItemId(mSelection), listView, adapter);
            adapter.registerDataSetObserver(observer);
        }
    }
    mListBoxDialog.setOnCancelListener(new DialogInterface.OnCancelListener() {

        @Override
        public void onCancel(DialogInterface dialog) {
            if (mWebViewCore != null) {
                mWebViewCore.sendMessage(EventHub.SINGLE_LISTBOX_CHOICE, -2, 0);
            }
            mListBoxDialog = null;
        }
    });
    mListBoxDialog.show();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"Only the condition statement in 'onCancel' method has changed to include a null check for 'mWebViewCore', so the code change type is 3.","The change in the condition check will not lead to the API returning a different value or throwing an exception, and thus, no Compatibility Issue."
189,<android.widget.TextView: int getBaseline()>,17,18,<android.widget.TextView: int getBaseline()>,<android.widget.TextView: int getBaseline()>,0,"{
    if (mLayout == null) {
        return super.getBaseline();
    }
    int voffset = 0;
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        voffset = getVerticalOffset(true);
    }
    return getExtendedPaddingTop() + voffset + mLayout.getLineBaseline(0);
}","{
    if (mLayout == null) {
        return super.getBaseline();
    }
    int voffset = 0;
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        voffset = getVerticalOffset(true);
    }
    if (isLayoutModeOptical(mParent)) {
        voffset -= getOpticalInsets().top;
    }
    return getExtendedPaddingTop() + voffset + mLayout.getLineBaseline(0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Control statement 'if (isLayoutModeOptical(mParent))' is introduced and the value of 'voffset' is updated inside it, so the code change type is 3,4.","The update in 'voffset' and the introduced control statement possibly change the return value in the late version, thus, the Compatibility Issue type is 1."
191,<android.app.ActivityThread.H: void handleMessage(Message)>,17,18,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ACTIVITY_EXTRAS:
            handleRequestActivityExtras((RequestActivityExtras) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
192,<android.content.CursorLoader: Cursor loadInBackground()>,17,18,<android.content.CursorLoader: Cursor loadInBackground()>,<android.content.CursorLoader: Cursor loadInBackground()>,0,"{
    synchronized (this) {
        if (isLoadInBackgroundCanceled()) {
            throw new OperationCanceledException();
        }
        mCancellationSignal = new CancellationSignal();
    }
    try {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder, mCancellationSignal);
        if (cursor != null) {
            // Ensure the cursor window is filled
            cursor.getCount();
            registerContentObserver(cursor, mObserver);
        }
        return cursor;
    } finally {
        synchronized (this) {
            mCancellationSignal = null;
        }
    }
}","{
    synchronized (this) {
        if (isLoadInBackgroundCanceled()) {
            throw new OperationCanceledException();
        }
        mCancellationSignal = new CancellationSignal();
    }
    try {
        Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection, mSelectionArgs, mSortOrder, mCancellationSignal);
        if (cursor != null) {
            try {
                // Ensure the cursor window is filled.
                cursor.getCount();
                cursor.registerContentObserver(mObserver);
            } catch (RuntimeException ex) {
                cursor.close();
                throw ex;
            }
        }
        return cursor;
    } finally {
        synchronized (this) {
            mCancellationSignal = null;
        }
    }
}",1,"/* Runs on a worker thread */
","/* Runs on a worker thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"In the late version, a new try-catch block was added to handle any RuntimeException that could occur when the cursor window is filled or when it is registered to an observer. Thus, the code change types include 2 and 3.","The newly added exception handling statement could cause the API to behave differently, specifically by potentially throwing a different exception when a RuntimeException is encountered. Therefore, the CI type is 2."
194,<android.view.GLES20DisplayList.DisplayListFinalizer: void finalize()>,17,18,<android.view.GLES20DisplayList.DisplayListFinalizer: void finalize()>,<android.view.GLES20DisplayList.DisplayListFinalizer: void finalize()>,0,"{
    try {
        GLES20Canvas.destroyDisplayList(mNativeDisplayList);
    } finally {
        super.finalize();
    }
}","{
    try {
        nDestroyDisplayList(mNativeDisplayList);
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent method that this implementation calls has been changed from GLES20Canvas.destroyDisplayList to nDestroyDisplayList. So, the type of code change is 5.",There's no compatibility issue observable since the final impact towards the callers is expected to remain the same despite the internal API used being different.
195,<android.app.Notification: Notification clone()>,17,18,<android.app.Notification: Notification clone()>,<android.app.Notification: Notification clone()>,0,"{
    Notification that = new Notification();
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    final String[] thiskind = this.kind;
    if (thiskind != null) {
        final int N = thiskind.length;
        final String[] thatkind = that.kind = new String[N];
        System.arraycopy(thiskind, 0, thatkind, 0, N);
    }
    if (this.extras != null) {
        that.extras = new Bundle(this.extras);
    }
    that.actions = new Action[this.actions.length];
    for (int i = 0; i < this.actions.length; i++) {
        that.actions[i] = this.actions[i].clone();
    }
    if (this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    return that;
}","{
    Notification that = new Notification();
    cloneInto(that, true);
    return that;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The whole code block has been abstracted to cloneInto(that, true), although the inner logic of these two methods may be identical, we still have to classify it as manipulated by another API method in the late version, so the code change type is 4.","Given that the implementation of the cloneInto method is unknown and may vary, the clone() method is potentially returning different values between the two versions. Therefore, the CI type is 1."
197,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,17,18,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are new 'if' statement blocks to check changes for 'rotationAnimation' in the late version, so the code change type is 4.","The introduced checks for 'rotationAnimation' should not lead to different return values or potential different exception handlings, so there's no Compatibility Issue."
199,<android.preference.PreferenceActivity: Header onGetInitialHeader()>,17,18,<android.preference.PreferenceActivity: Header onGetInitialHeader()>,<android.preference.PreferenceActivity: Header onGetInitialHeader()>,0,"{
    return mHeaders.get(0);
}","{
    for (int i = 0; i < mHeaders.size(); i++) {
        Header h = mHeaders.get(i);
        if (h.fragment != null) {
            return h;
        }
    }
    throw new IllegalStateException(""Must have at least one header with a fragment"");
}",1,"/**
 * Called to determine the initial header to be shown.  The default
 * implementation simply returns the fragment of the first header.  Note
 * that the returned Header object does not actually need to exist in
 * your header list -- whatever its fragment is will simply be used to
 * show for the initial UI.
 */
","/**
 * Called to determine the initial header to be shown.  The default
 * implementation simply returns the fragment of the first header.  Note
 * that the returned Header object does not actually need to exist in
 * your header list -- whatever its fragment is will simply be used to
 * show for the initial UI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The 'return mHeaders.get(0)' statement has changed to a control statement 'for' with a new 'return' statement. And it also introduces a new exception 'throw new IllegalStateException', so the code change type is 1,2,3.","The returned value from this method could be different between the two versions due to the change in the return statement and the new 'throw new IllegalStateException' introduced in the late version may let the API behaves differently in case of an exception. Therefore, the CI type is 1,2."
200,<android.view.WindowManager.LayoutParams: String toString()>,17,18,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,A new statement which concatenates 'rotationAnimation' to the StringBuilder object was introduced in the late version. The code change type is 4.,The new statement introduced would lead to different return values in the late version. Thus the compatibility issue type is 1.
201,<android.view.accessibility.AccessibilityNodeInfo: boolean isSelected()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isSelected()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isSelected()>,0,"{
    return getBooleanProperty(PROPERTY_SELECTED);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_SELECTED);
}",1,"/**
 * Gets whether this node is selected.
 *
 * @return True if the node is selected.
 */
","/**
 * Gets whether this node is selected.
 *
 * @return True if the node is selected.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The name of the constant used in the return statement method call has been changed from PROPERTY_SELECTED to BOOLEAN_PROPERTY_SELECTED, thus both the return statement has changed and the dependent API has changed within this change type, so the change type is 1,5.","Given that the constant passed to the getBooleanProperty method has been changed, the return value of the method might also differ. The API therefore may potentially return a different value, hence a Compatibility Issue of type 1 exists."
202,<android.app.Notification.Builder: Builder setSubText(CharSequence)>,17,18,<android.app.Notification.Builder: Builder setSubText(CharSequence)>,<android.app.Notification.Builder: Builder setSubText(CharSequence)>,0,"{
    mSubText = text;
    return this;
}","{
    mSubText = safeCharSequence(text);
    return this;
}",1,"/**
 * Set the third line of text in the platform notification template.
 * Don't use if you're also using {@link #setProgress(int, int, boolean)}; they occupy the same location in the standard template.
 */
","/**
 * Set the third line of text in the platform notification template.
 * Don't use if you're also using {@link #setProgress(int, int, boolean)}; they occupy the
 * same location in the standard template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the late version, ""safeCharSequence(text)"" is called before assigning a value to mSubText while in the early version, ""text"" is directly assigned to mSubText. So, the code change type can be classified as 1,5.","This change may potentially cause the mSubText variable to have a different value in the late version, hence, cause the API to return a different value, leading to a compatibility issue. Therefore, the CI type is 1."
203,<android.app.MediaRouteButton: boolean performClick()>,17,18,<android.app.MediaRouteButton: boolean performClick()>,<android.app.MediaRouteButton: boolean performClick()>,0,"{
    // Send the appropriate accessibility events and call listeners
    boolean handled = super.performClick();
    if (!handled) {
        playSoundEffect(SoundEffectConstants.CLICK);
    }
    if (mToggleMode) {
        if (mRemoteActive) {
            mRouter.selectRouteInt(mRouteTypes, mRouter.getSystemAudioRoute());
        } else {
            final int N = mRouter.getRouteCount();
            for (int i = 0; i < N; i++) {
                final RouteInfo route = mRouter.getRouteAt(i);
                if ((route.getSupportedTypes() & mRouteTypes) != 0 && route != mRouter.getSystemAudioRoute()) {
                    mRouter.selectRouteInt(mRouteTypes, route);
                }
            }
        }
    } else {
        showDialog();
    }
    return handled;
}","{
    // Send the appropriate accessibility events and call listeners
    boolean handled = super.performClick();
    if (!handled) {
        playSoundEffect(SoundEffectConstants.CLICK);
    }
    if (mToggleMode) {
        if (mRemoteActive) {
            mRouter.selectRouteInt(mRouteTypes, mRouter.getDefaultRoute());
        } else {
            final int N = mRouter.getRouteCount();
            for (int i = 0; i < N; i++) {
                final RouteInfo route = mRouter.getRouteAt(i);
                if ((route.getSupportedTypes() & mRouteTypes) != 0 && route != mRouter.getDefaultRoute()) {
                    mRouter.selectRouteInt(mRouteTypes, route);
                }
            }
        }
    } else {
        showDialog();
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method mRouter.getSystemAudioRoute() has been changed to mRouter.getDefaultRoute(). Even as this is not a return statement, this change will possibly lead to a different result, so the pred_change is 1,5. ","The change of method from getSystemAudioRoute() to getDefaultRoute() can potentially make the API run differently (as it may lead to the selection of a different route), causing different behaviours when the API is invoked. In this case, the API potentiall returns a different value, so CI type is 1."
204,<android.app.Notification.InboxStyle: InboxStyle addLine(CharSequence)>,17,18,<android.app.Notification.InboxStyle: InboxStyle addLine(CharSequence)>,<android.app.Notification.InboxStyle: InboxStyle addLine(CharSequence)>,0,"{
    mTexts.add(cs);
    return this;
}","{
    mTexts.add(safeCharSequence(cs));
    return this;
}",1,"/**
 * Append a line to the digest section of the Inbox notification.
 */
","/**
 * Append a line to the digest section of the Inbox notification.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the line `mTexts.add(cs);` has changed to `mTexts.add(safeCharSequence(cs));` in the late version, meaning the object `cs` is now passed through the `safeCharSequence` method before being added to `mTexts`. Thus, the change of this statement, the introduction of another method (safeCharSequence), and the dependent API change (from add(cs) to add(safeCharSequence(cs))) all led to code change types 1, 4, and 5.","Because of the introduction of the new `safeCharSequence` method, the value added to `mTexts` may be different in the late version, which may turn to different behaviors when retrieving the objects stored in `mTexts`. Therefore, there is a potential compatibility issue because the returned value might have changed, leading to the CI type 1."
206,<android.webkit.BrowserFrame: void handleMessage(Message)>,17,18,<android.webkit.BrowserFrame: void handleMessage(Message)>,<android.webkit.BrowserFrame: void handleMessage(Message)>,0,"{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.getScheme() + uri.getHost();
                        String[] up = mDatabase.getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                if (mOrientation != msg.arg1) {
                    mOrientation = msg.arg1;
                    nativeOrientationChanged(msg.arg1);
                }
                break;
            }
        default:
            break;
    }
}","{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.getScheme() + uri.getHost();
                        String[] up = WebViewDatabaseClassic.getInstance(mContext).getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                if (mOrientation != msg.arg1) {
                    mOrientation = msg.arg1;
                    nativeOrientationChanged(msg.arg1);
                }
                break;
            }
        default:
            break;
    }
}",1,"/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
","/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There are some changes in the method where the `getUsernamePassword` is called. The late version is calling this method on the `WebViewDatabaseClassic` instance, whereas the previous version called this method on `mDatabase`. These changes can be categorized into ""Dependent API changed (5)"" and ""Other statement changed (4)"".","Even though there is a change in the method, it doesn't affect the final returned values or the exceptions thrown by this method. Thus, no compatibility issue is found in this API change."
207,<android.os.ParcelFileDescriptor: void close()>,17,18,<android.os.ParcelFileDescriptor: void close()>,<android.os.ParcelFileDescriptor: void close()>,0,"{
    synchronized (this) {
        if (mClosed)
            return;
        mClosed = true;
    }
    if (mParcelDescriptor != null) {
        // If this is a proxy to another file descriptor, just call through to its
        // close method.
        mParcelDescriptor.close();
    } else {
        Parcel.closeFileDescriptor(mFileDescriptor);
    }
}","{
    if (mClosed)
        return;
    mClosed = true;
    mGuard.close();
    if (mWrapped != null) {
        // If this is a proxy to another file descriptor, just call through to its
        // close method.
        mWrapped.close();
    } else {
        Parcel.closeFileDescriptor(mFileDescriptor);
    }
}",1,"/**
 * Close the ParcelFileDescriptor. This implementation closes the underlying
 * OS resources allocated to represent this stream.
 *
 * @throws IOException
 * If an error occurs attempting to close this ParcelFileDescriptor.
 */
","/**
 * Close the ParcelFileDescriptor. This implementation closes the underlying
 * OS resources allocated to represent this stream.
 *
 * @throws IOException
 * If an error occurs attempting to close this ParcelFileDescriptor.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"A syncronized block has been removed, and the variable 'mParcelDescriptor' has been replaced by 'mWrapped'. Also a new statement 'mGuard.close()' has been introduced. So, code change type is 3,4,5.","As 'mGuard.close()', and 'mWrapped.close()' are new statements which could potentially make the API behave differently and return a different exception. Thus, the CI type is 1."
210,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",17,18,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>","<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",0,"{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf) {
        long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
        // Our own user's settings data uses a client-side cache
        synchronized (this) {
            if (mValuesVersion != newValuesVersion) {
                if (LOCAL_LOGV || false) {
                    Log.v(TAG, ""invalidate ["" + mUri.getLastPathSegment() + ""]: current "" + newValuesVersion + "" != cached "" + mValuesVersion);
                }
                mValues.clear();
                mValuesVersion = newValuesVersion;
            }
            if (mValues.containsKey(name)) {
                // Could be null, that's OK -- negative caching
                return mValues.get(name);
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = lazyGetProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            Bundle b = cp.call(mCallGetCommand, name, args);
            if (b != null) {
                String value = b.getPairValue();
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (this) {
                        mValues.put(name, value);
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf) {
        long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
        // Our own user's settings data uses a client-side cache
        synchronized (this) {
            if (mValuesVersion != newValuesVersion) {
                if (LOCAL_LOGV || false) {
                    Log.v(TAG, ""invalidate ["" + mUri.getLastPathSegment() + ""]: current "" + newValuesVersion + "" != cached "" + mValuesVersion);
                }
                mValues.clear();
                mValuesVersion = newValuesVersion;
            }
            if (mValues.containsKey(name)) {
                // Could be null, that's OK -- negative caching
                return mValues.get(name);
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = lazyGetProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            Bundle b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            if (b != null) {
                String value = b.getPairValue();
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (this) {
                        mValues.put(name, value);
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER, new String[] { name }, null, null);
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (this) {
            mValues.put(name, value);
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method cp.call() and cp.query() all added a new parameter 'cr.getPackageName()'. This changes the method signature of dependent APIs, so the code change type is 5. Additionally, 'cr.getPackageName()' is a new statement, so this is also an 'Other statement changed', making the type 4.","The change in parameters of cp.call() and cp.query() methods, which are dependent APIs, can potentially lead to different return values. They can have impacts on the overall behaviour of the API, thus the compatibility issue type is 1."
211,<android.os.WorkSource: void set(WorkSource)>,17,18,<android.os.WorkSource: void set(WorkSource)>,<android.os.WorkSource: void set(WorkSource)>,0,"{
    if (other == null) {
        mNum = 0;
        return;
    }
    mNum = other.mNum;
    if (other.mUids != null) {
        if (mUids != null && mUids.length >= mNum) {
            System.arraycopy(other.mUids, 0, mUids, 0, mNum);
        } else {
            mUids = other.mUids.clone();
        }
    } else {
        mUids = null;
    }
}","{
    if (other == null) {
        mNum = 0;
        return;
    }
    mNum = other.mNum;
    if (other.mUids != null) {
        if (mUids != null && mUids.length >= mNum) {
            System.arraycopy(other.mUids, 0, mUids, 0, mNum);
        } else {
            mUids = other.mUids.clone();
        }
        if (other.mNames != null) {
            if (mNames != null && mNames.length >= mNum) {
                System.arraycopy(other.mNames, 0, mNames, 0, mNum);
            } else {
                mNames = other.mNames.clone();
            }
        } else {
            mNames = null;
        }
    } else {
        mUids = null;
        mNames = null;
    }
}",1,"/**
 * Replace the current contents of this work source with the given
 * work source.  If <var>other</var> is null, the current work source
 * will be made empty.
 */
","/**
 * Replace the current contents of this work source with the given
 * work source.  If <var>other</var> is null, the current work source
 * will be made empty.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method now sets the mNames field based on the provided WorkSource object in the late version implementation of the method, but does not do so in the early version. This can be regarded as 'Other statement change'.","No difference will be observed in the return values or the thrown exceptions between the two versions of the method, so no compatibility issue (CI) exists for this particular API."
212,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",17,18,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",0,"{
    synchronized (mConstructorArgs) {
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                View temp;
                if (TAG_1995.equals(name)) {
                    temp = new BlinkLayout(mContext, attrs);
                } else {
                    temp = createViewFromTag(root, name, attrs);
                }
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        return result;
    }
}","{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                View temp;
                if (TAG_1995.equals(name)) {
                    temp = new BlinkLayout(mContext, attrs);
                } else {
                    temp = createViewFromTag(root, name, attrs);
                }
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        return result;
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The Late_Implementation introduces a new API Trace.traceBegin() and Trace.traceEnd() which is not present in Early_Implementation, this matches with the category 5 (Dependent API changed). Also, these new APIs do not affect the control flow of the method. It introduces some extra tracing which can be classified to other statement changed - category 4.",There is no Compatibility Issue(CI) because these changes don't affect the output (return type and values) of the method nor does it change any exception the method can throw. The Trace APIs added are for tracing and do not affect the core functionality of the method.
213,<android.widget.ListView: void layoutChildren()>,17,18,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Remember which child, if any, had accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View accessFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (accessFocusedView != null) {
                final View accessFocusedChild = findAccessibilityFocusedChild(accessFocusedView);
                if (accessFocusedChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(accessFocusedChild)) {
                        // If the views won't be changing, try to maintain
                        // focus on the current view host and (if
                        // applicable) its virtual view.
                        accessibilityFocusLayoutRestoreView = accessFocusedView;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    } else {
                        // Otherwise, try to maintain focus at the same
                        // position.
                        accessibilityFocusPosition = getPositionForView(accessFocusedChild);
                    }
                }
            }
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus.
        if (accessibilityFocusLayoutRestoreNode != null) {
            accessibilityFocusLayoutRestoreNode.performAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
        } else if (accessibilityFocusLayoutRestoreView != null) {
            accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
        } else if (accessibilityFocusPosition != INVALID_POSITION) {
            // Bound the position within the visible children.
            final int position = MathUtils.constrain((accessibilityFocusPosition - mFirstPosition), 0, (getChildCount() - 1));
            final View restoreView = getChildAt(position);
            if (restoreView != null) {
                restoreView.requestAccessibilityFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View accessFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (accessFocusedView != null) {
                final View accessFocusedChild = findAccessibilityFocusedChild(accessFocusedView);
                if (accessFocusedChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(accessFocusedChild)) {
                        // If the views won't be changing, try to maintain
                        // focus on the current view host and (if
                        // applicable) its virtual view.
                        accessibilityFocusLayoutRestoreView = accessFocusedView;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    } else {
                        // Otherwise, try to maintain focus at the same
                        // position.
                        accessibilityFocusPosition = getPositionForView(accessFocusedChild);
                    }
                }
            }
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus.
        if (accessibilityFocusLayoutRestoreView != null) {
            final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
            if ((accessibilityFocusLayoutRestoreNode != null) && (provider != null)) {
                final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
            } else {
                accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
            }
        } else if (accessibilityFocusPosition != INVALID_POSITION) {
            // Bound the position within the visible children.
            final int position = MathUtils.constrain((accessibilityFocusPosition - mFirstPosition), 0, (getChildCount() - 1));
            final View restoreView = getChildAt(position);
            if (restoreView != null) {
                restoreView.requestAccessibilityFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
215,<android.webkit.CallbackProxy: void handleMessage(Message)>,17,18,<android.webkit.CallbackProxy: void handleMessage(Message)>,<android.webkit.CallbackProxy: void handleMessage(Message)>,0,"{
    // 32-bit reads and writes.
    if (messagesBlocked())
        return;
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView.getWebView(), startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView.getWebView(), finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView.getWebView(), (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(), (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView.getWebView(), reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView.getWebView(), dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(), handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView.getWebView(), (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROCEEDED_AFTER_SSL_ERROR:
            if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
                ((WebViewClientClassicExt) mWebViewClient).onProceededAfterSslError(mWebView.getWebView(), (SslError) msg.obj);
            }
            break;
        case CLIENT_CERT_REQUEST:
            if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                ((WebViewClientClassicExt) mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(), (ClientCertRequestHandler) map.get(""handler""), (String) map.get(""host_and_port""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView.getWebView(), mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(), (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                String referer = msg.getData().getString(""referer"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                if (mDownloadListener instanceof BrowserDownloadListener) {
                    ((BrowserDownloadListener) mDownloadListener).onDownloadStart(url, userAgent, contentDisposition, mimetype, referer, contentLength);
                } else {
                    mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
                }
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(), msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView.getWebView());
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow(((WebViewClassic) msg.obj).getWebView());
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(), (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long quota = ((Long) map.get(""quota"")).longValue();
                long totalQuota = ((Long) map.get(""totalQuota"")).longValue();
                long estimatedDatabaseSize = ((Long) map.get(""estimatedDatabaseSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, quota, estimatedDatabaseSize, totalQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long requiredStorage = ((Long) map.get(""requiredStorage"")).longValue();
                long quota = ((Long) map.get(""quota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage, quota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsPromptResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(), url, message, defaultVal, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        @Override
                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                receiver.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView.getWebView(), msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType(), data.getCapture());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(), realm, account, args);
                }
                break;
            }
    }
}","{
    // 32-bit reads and writes.
    if (messagesBlocked())
        return;
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView.getWebView(), startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView.getWebView(), finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView.getWebView(), (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(), (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView.getWebView(), reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView.getWebView(), dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(), handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView.getWebView(), (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROCEEDED_AFTER_SSL_ERROR:
            if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
                ((WebViewClientClassicExt) mWebViewClient).onProceededAfterSslError(mWebView.getWebView(), (SslError) msg.obj);
            }
            break;
        case CLIENT_CERT_REQUEST:
            if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                ((WebViewClientClassicExt) mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(), (ClientCertRequestHandler) map.get(""handler""), (String) map.get(""host_and_port""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView.getWebView(), mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(), (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                String referer = msg.getData().getString(""referer"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                if (mDownloadListener instanceof BrowserDownloadListener) {
                    ((BrowserDownloadListener) mDownloadListener).onDownloadStart(url, userAgent, contentDisposition, mimetype, referer, contentLength);
                } else {
                    mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
                }
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(), msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView.getWebView());
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow(((WebViewClassic) msg.obj).getWebView());
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(), (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long quota = ((Long) map.get(""quota"")).longValue();
                long totalQuota = ((Long) map.get(""totalQuota"")).longValue();
                long estimatedDatabaseSize = ((Long) map.get(""estimatedDatabaseSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, quota, estimatedDatabaseSize, totalQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long requiredStorage = ((Long) map.get(""requiredStorage"")).longValue();
                long quota = ((Long) map.get(""quota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage, quota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_DIALOG:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                JsDialogHelper helper = new JsDialogHelper(receiver.mJsResult, msg);
                if (!helper.invokeCallback(mWebChromeClient, mWebView.getWebView())) {
                    helper.showDialog(mContext);
                }
                receiver.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                receiver.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView.getWebView(), msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType(), data.getCapture());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(), realm, account, args);
                }
                break;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
216,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",17,18,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
217,<android.view.ViewGroup: void removeAllViewsInLayout()>,17,18,<android.view.ViewGroup: void removeAllViewsInLayout()>,<android.view.ViewGroup: void removeAllViewsInLayout()>,0,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    View clearChildFocus = null;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus();
            clearChildFocus = view;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus != null) {
        clearChildFocus(clearChildFocus);
        ensureInputFocusOnFirstFocusable();
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus();
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}",1,"/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
","/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The type of variable 'clearChildFocus' is changed from View to boolean, a new method 'rootViewRequestFocus()' is invoked, and 'clearChildFocus' no longer invokes 'ensureInputFocusOnFirstFocus()' in the late version. The condition statement 'view.isAccessibilityFocused()' is added. Therefore, the change type is 1,3 and 4.","The introduced changes in type, condition statement and invoked methods can potentially lead to different behaviours when the late version API is invoked. Hence the CI type is 1."
218,<android.widget.FastScroller: void draw(Canvas)>,17,18,<android.widget.FastScroller: void draw(Canvas)>,<android.widget.FastScroller: void draw(Canvas)>,0,"{
    if (mState == STATE_NONE) {
        // No need to draw anything
        return;
    }
    final int y = mThumbY;
    final int viewWidth = mList.getWidth();
    final FastScroller.ScrollFade scrollFade = mScrollFade;
    int alpha = -1;
    if (mState == STATE_EXIT) {
        alpha = scrollFade.getAlpha();
        if (alpha < ScrollFade.ALPHA_MAX / 2) {
            mThumbDrawable.setAlpha(alpha * 2);
        }
        int left = 0;
        switch(mPosition) {
            case View.SCROLLBAR_POSITION_RIGHT:
                left = viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
            case View.SCROLLBAR_POSITION_LEFT:
                left = -mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
        }
        mThumbDrawable.setBounds(left, 0, left + mThumbW, mThumbH);
        mChangedBounds = true;
    }
    if (mTrackDrawable != null) {
        final Rect thumbBounds = mThumbDrawable.getBounds();
        final int left = thumbBounds.left;
        final int halfThumbHeight = (thumbBounds.bottom - thumbBounds.top) / 2;
        final int trackWidth = mTrackDrawable.getIntrinsicWidth();
        final int trackLeft = (left + mThumbW / 2) - trackWidth / 2;
        mTrackDrawable.setBounds(trackLeft, halfThumbHeight, trackLeft + trackWidth, mList.getHeight() - halfThumbHeight);
        mTrackDrawable.draw(canvas);
    }
    canvas.translate(0, y);
    mThumbDrawable.draw(canvas);
    canvas.translate(0, -y);
    // If user is dragging the scroll bar, draw the alphabet overlay
    if (mState == STATE_DRAGGING && mDrawOverlay) {
        if (mOverlayPosition == OVERLAY_AT_THUMB) {
            int left = 0;
            switch(mPosition) {
                default:
                case View.SCROLLBAR_POSITION_RIGHT:
                    left = Math.max(0, mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
                    break;
                case View.SCROLLBAR_POSITION_LEFT:
                    left = Math.min(mThumbDrawable.getBounds().right + mThumbW, mList.getWidth() - mOverlaySize);
                    break;
            }
            int top = Math.max(0, Math.min(y + (mThumbH - mOverlaySize) / 2, mList.getHeight() - mOverlaySize));
            final RectF pos = mOverlayPos;
            pos.left = left;
            pos.right = pos.left + mOverlaySize;
            pos.top = top;
            pos.bottom = pos.top + mOverlaySize;
            if (mOverlayDrawable != null) {
                mOverlayDrawable.setBounds((int) pos.left, (int) pos.top, (int) pos.right, (int) pos.bottom);
            }
        }
        mOverlayDrawable.draw(canvas);
        final Paint paint = mPaint;
        float descent = paint.descent();
        final RectF rectF = mOverlayPos;
        final Rect tmpRect = mTmpRect;
        mOverlayDrawable.getPadding(tmpRect);
        final int hOff = (tmpRect.right - tmpRect.left) / 2;
        final int vOff = (tmpRect.bottom - tmpRect.top) / 2;
        canvas.drawText(mSectionText, (int) (rectF.left + rectF.right) / 2 - hOff, (int) (rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff, paint);
    } else if (mState == STATE_EXIT) {
        if (alpha == 0) {
            // Done with exit
            setState(STATE_NONE);
        } else if (mTrackDrawable != null) {
            mList.invalidate(viewWidth - mThumbW, 0, viewWidth, mList.getHeight());
        } else {
            mList.invalidate(viewWidth - mThumbW, y, viewWidth, y + mThumbH);
        }
    }
}","{
    if (mState == STATE_NONE) {
        // No need to draw anything
        return;
    }
    final int y = mThumbY;
    final int viewWidth = mList.getWidth();
    final FastScroller.ScrollFade scrollFade = mScrollFade;
    int alpha = -1;
    if (mState == STATE_EXIT) {
        alpha = scrollFade.getAlpha();
        if (alpha < ScrollFade.ALPHA_MAX / 2) {
            mThumbDrawable.setAlpha(alpha * 2);
        }
        int left = 0;
        switch(mPosition) {
            case View.SCROLLBAR_POSITION_RIGHT:
                left = viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
            case View.SCROLLBAR_POSITION_LEFT:
                left = -mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
        }
        mThumbDrawable.setBounds(left, 0, left + mThumbW, mThumbH);
        mChangedBounds = true;
    }
    if (mTrackDrawable != null) {
        final Rect thumbBounds = mThumbDrawable.getBounds();
        final int left = thumbBounds.left;
        final int halfThumbHeight = (thumbBounds.bottom - thumbBounds.top) / 2;
        final int trackWidth = mTrackDrawable.getIntrinsicWidth();
        final int trackLeft = (left + mThumbW / 2) - trackWidth / 2;
        mTrackDrawable.setBounds(trackLeft, halfThumbHeight, trackLeft + trackWidth, mList.getHeight() - halfThumbHeight);
        mTrackDrawable.draw(canvas);
    }
    canvas.translate(0, y);
    mThumbDrawable.draw(canvas);
    canvas.translate(0, -y);
    // If user is dragging the scroll bar, draw the alphabet overlay
    if (mState == STATE_DRAGGING && mDrawOverlay) {
        if (mOverlayPosition == OVERLAY_AT_THUMB) {
            int left = 0;
            switch(mPosition) {
                default:
                case View.SCROLLBAR_POSITION_RIGHT:
                    left = Math.max(0, mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
                    break;
                case View.SCROLLBAR_POSITION_LEFT:
                    left = Math.min(mThumbDrawable.getBounds().right + mThumbW, mList.getWidth() - mOverlaySize);
                    break;
            }
            int top = Math.max(0, Math.min(y + (mThumbH - mOverlaySize) / 2, mList.getHeight() - mOverlaySize));
            final RectF pos = mOverlayPos;
            pos.left = left;
            pos.right = pos.left + mOverlaySize;
            pos.top = top;
            pos.bottom = pos.top + mOverlaySize;
            if (mOverlayDrawable != null) {
                mOverlayDrawable.setBounds((int) pos.left, (int) pos.top, (int) pos.right, (int) pos.bottom);
            }
        }
        mOverlayDrawable.draw(canvas);
        final Paint paint = mPaint;
        float descent = paint.descent();
        final RectF rectF = mOverlayPos;
        final Rect tmpRect = mTmpRect;
        mOverlayDrawable.getPadding(tmpRect);
        final int hOff = (tmpRect.right - tmpRect.left) / 2;
        final int vOff = (tmpRect.bottom - tmpRect.top) / 2;
        canvas.drawText(mSectionText, (int) (rectF.left + rectF.right) / 2 - hOff, (int) (rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff, paint);
    } else if (mState == STATE_EXIT) {
        if (alpha == 0) {
            // Done with exit
            setState(STATE_NONE);
        } else {
            final int left, right, top, bottom;
            if (mTrackDrawable != null) {
                top = 0;
                bottom = mList.getHeight();
            } else {
                top = y;
                bottom = y + mThumbH;
            }
            switch(mList.getLayoutDirection()) {
                case View.LAYOUT_DIRECTION_RTL:
                    left = 0;
                    right = mThumbW;
                    break;
                case View.LAYOUT_DIRECTION_LTR:
                default:
                    left = viewWidth - mThumbW;
                    right = viewWidth;
            }
            mList.invalidate(left, top, right, bottom);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition statement after 'else if (mState == STATE_EXIT)' and the assignment of 'left','right','top','bottom' variables have been changed. So the change type is 3,4.","Since the assignment of the variables 'left', 'right', 'top', and 'bottom' have changed, the different values of these variables may cause the behavior of mList.invalidate() to be different in the late version, so the CI type is 1."
219,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,17,18,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (childrenCount != 0) {
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
220,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,17,18,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,0,"{
    return new int[] { EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 0, EGL_CONFIG_CAVEAT, EGL_NONE, // TODO: Find a better way to choose the stencil size
    EGL_STENCIL_SIZE, mShowOverdraw ? GLES20Canvas.getStencilSize() : 0, EGL_SURFACE_TYPE, EGL_WINDOW_BIT | (dirtyRegions ? EGL14.EGL_SWAP_BEHAVIOR_PRESERVED_BIT : 0), EGL_NONE };
}","{
    // noinspection PointlessBooleanExpression,ConstantConditions
    final int stencilSize = GLES20Canvas.getStencilSize();
    final int swapBehavior = dirtyRegions ? EGL14.EGL_SWAP_BEHAVIOR_PRESERVED_BIT : 0;
    return new int[] { EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 0, EGL_CONFIG_CAVEAT, EGL_NONE, EGL_STENCIL_SIZE, stencilSize, EGL_SURFACE_TYPE, EGL_WINDOW_BIT | swapBehavior, EGL_NONE };
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The change is focused on multiple statements where the method ""getElementSize()"" is extracted to a local variable ""stencilSize"", and the condition/ternary operation ""dirtyRegions ? EGL14.EGL_SWAP_BEHAVIOR_PRESERVED_BIT : 0"" is extracted to a local variable ""swapBehavior"". Thus it belongs to class 1 (Return statement changed) because the int array returned has different expressions for its elements, and class 4 (Other statement changed) for the addition of new local variable definitions.",There is no compatibility issue detected here. The data returned by the function remains the same in both versions; only the implementation details have changed. So the CI type is 0.
222,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",17,18,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>","<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",0,"{
    if (!speechItem.isValid()) {
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
}","{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
}",1,"/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
","/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control logic of how to handle the error when the speech item is not valid has changed, so the code change type is 1,3.","Because the control logic of how to handle the error when the speech item is not valid has been changed, it could lead to a different error message when the exception is thrown, therefore, the CI type is 1."
223,<android.os.MessageQueue: Message next()>,17,18,<android.os.MessageQueue: Message next()>,<android.os.MessageQueue: Message next()>,0,"{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            if (mQuiting) {
                return null;
            }
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}","{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // Process the quit message now that all pending messages have been handled.
            if (mQuiting) {
                dispose();
                return null;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The ""if (mQuiting)"" condition has been moved to after the processing of messages and the method call dispose() has been introduced in the later implementation. So the change type is 3 because the control dependency has been changed, and 4 because other statements (method call dispose()) alteration was included.","As the control flow changes,  the return value of the function can be different in the two versions, resulting in a compatibility issue. If ""mQuiting"" is true, in the late version, the function may return null later compared with the early version, because the processing of messages has to be completed before the 'return null' statement (in the late version). Therefore, the Compatibility Issue type is 1."
224,<android.view.View: int getLayoutDirection()>,17,18,<android.view.View: int getLayoutDirection()>,<android.view.View: int getLayoutDirection()>,0,"{
    final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
    if (targetSdkVersion < JELLY_BEAN_MR1) {
        mPrivateFlags2 |= PFLAG2_LAYOUT_DIRECTION_RESOLVED;
        return LAYOUT_DIRECTION_LTR;
    }
    return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}","{
    final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
    if (targetSdkVersion < JELLY_BEAN_MR1) {
        mPrivateFlags2 |= PFLAG2_LAYOUT_DIRECTION_RESOLVED;
        return LAYOUT_DIRECTION_RESOLVED_DEFAULT;
    }
    return ((mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Returns the resolved layout direction for this view.
 *
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns
 * {@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.
 *
 * For compatibility, this will return {@link #LAYOUT_DIRECTION_LTR} if API version
 * is lower than {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 */
","/**
 * Returns the resolved layout direction for this view.
 *
 * @return {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL or returns
 * {@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.
 *
 * For compatibility, this will return {@link #LAYOUT_DIRECTION_LTR} if API version
 * is lower than {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 *
 * @attr ref android.R.styleable#View_layoutDirection
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""layout"", mapping = { @ViewDebug.IntToString(from = LAYOUT_DIRECTION_LTR, to = ""RESOLVED_DIRECTION_LTR""), @ViewDebug.IntToString(from = LAYOUT_DIRECTION_RTL, to = ""RESOLVED_DIRECTION_RTL"") })]","[@ViewDebug.ExportedProperty(category = ""layout"", mapping = { @ViewDebug.IntToString(from = LAYOUT_DIRECTION_LTR, to = ""RESOLVED_DIRECTION_LTR""), @ViewDebug.IntToString(from = LAYOUT_DIRECTION_RTL, to = ""RESOLVED_DIRECTION_RTL"") })]",-1,-1,-1,-1,-1,-1,1,1,"The return statement inside the 'if' condition block has been changed from 'return LAYOUT_DIRECTION_LTR;' to 'return LAYOUT_DIRECTION_RESOLVED_DEFAULT;', so the code change type is 1.","With the change of return statement in the 'if' condition block, the API could potentially return a different value. Therefore, the CI type is 1."
225,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,17,18,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_KEY:
            return ""MSG_DISPATCH_KEY"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_IME_FINISHED_EVENT:
            return ""MSG_IME_FINISHED_EVENT"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_DISPATCH_SCREEN_STATE:
            return ""MSG_DISPATCH_SCREEN_STATE"";
        case MSG_INVALIDATE_DISPLAY_LIST:
            return ""MSG_INVALIDATE_DISPLAY_LIST"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_KEY:
            return ""MSG_DISPATCH_KEY"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_DISPATCH_SCREEN_STATE:
            return ""MSG_DISPATCH_SCREEN_STATE"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There are cases removed from the switch statement, specifically the cases 'MSG_IME_FINISHED_EVENT' and 'MSG_INVALIDATE_DISPLAY_LIST', so the code change type is 1.","As the removed cases leads to different return statements depending on the value of 'message.what'. Therefore, the return value could be different in the late version and the CI type is 1."
226,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>",17,18,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>","<android.content.ContentProviderClient: int delete(Uri,String,String[])>",0,"{
    try {
        return mContentProvider.delete(url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
","/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call for mContentProvider.delete() in return statement has changed from 3 parameters to 4 parameters with an additional parameter 'mPackageName'. Therefore, the change type is 1 (Return statement changed) and 5 (Dependent API changed).","Since the return statement has been altered with the addition of an extra parameter in the method call, it will cause the API to return a potentially different value or behaviour. Therefore, the type of CI is 1 (Compatibility Issue caused by potential different return values or types)."
228,<android.view.View: void draw(Canvas)>,17,18,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBackground;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
}","{
    if (mClipBounds != null) {
        canvas.clipRect(mClipBounds);
    }
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBackground;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
229,<android.widget.TextView: TextDirectionHeuristic getTextDirectionHeuristic()>,17,18,<android.widget.TextView: TextDirectionHeuristic getTextDirectionHeuristic()>,<android.widget.TextView: TextDirectionHeuristic getTextDirectionHeuristic()>,0,"{
    if (hasPasswordTransformationMethod()) {
        // to the left or to the right
        return TextDirectionHeuristics.LOCALE;
    }
    // Always need to resolve layout direction first
    final boolean defaultIsRtl = (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    // Now, we can select the heuristic
    switch(getTextDirection()) {
        default:
        case TEXT_DIRECTION_FIRST_STRONG:
            return (defaultIsRtl ? TextDirectionHeuristics.FIRSTSTRONG_RTL : TextDirectionHeuristics.FIRSTSTRONG_LTR);
        case TEXT_DIRECTION_ANY_RTL:
            return TextDirectionHeuristics.ANYRTL_LTR;
        case TEXT_DIRECTION_LTR:
            return TextDirectionHeuristics.LTR;
        case TEXT_DIRECTION_RTL:
            return TextDirectionHeuristics.RTL;
        case TEXT_DIRECTION_LOCALE:
            return TextDirectionHeuristics.LOCALE;
    }
}","{
    if (hasPasswordTransformationMethod()) {
        // passwords fields should be LTR
        return TextDirectionHeuristics.LTR;
    }
    // Always need to resolve layout direction first
    final boolean defaultIsRtl = (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    // Now, we can select the heuristic
    switch(getTextDirection()) {
        default:
        case TEXT_DIRECTION_FIRST_STRONG:
            return (defaultIsRtl ? TextDirectionHeuristics.FIRSTSTRONG_RTL : TextDirectionHeuristics.FIRSTSTRONG_LTR);
        case TEXT_DIRECTION_ANY_RTL:
            return TextDirectionHeuristics.ANYRTL_LTR;
        case TEXT_DIRECTION_LTR:
            return TextDirectionHeuristics.LTR;
        case TEXT_DIRECTION_RTL:
            return TextDirectionHeuristics.RTL;
        case TEXT_DIRECTION_LOCALE:
            return TextDirectionHeuristics.LOCALE;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return value of the first conditional if statement (in case hasPasswordTransformationMethod() returns True) is changed - from ""TextDirectionHeuristics.LOCALE"" to ""TextDirectionHeuristics.LTR"". Therefore, the code change type is 1 (Return statement changed).","The change of return value in the if statement will make the API potentially return a different value when hasPasswordTransformationMethod() returns True. This change could lead to potential different behavior or the output of the method. Therefore, it is a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
231,"<android.view.FocusFinder.SequentialFocusComparator: int compare(View,View)>",17,18,"<android.view.FocusFinder.SequentialFocusComparator: int compare(View,View)>","<android.view.FocusFinder.SequentialFocusComparator: int compare(View,View)>",0,"{
    if (first == second) {
        return 0;
    }
    getRect(first, mFirstRect);
    getRect(second, mSecondRect);
    if (mFirstRect.top < mSecondRect.top) {
        return -1;
    } else if (mFirstRect.top > mSecondRect.top) {
        return 1;
    } else if (mFirstRect.left < mSecondRect.left) {
        return -1;
    } else if (mFirstRect.left > mSecondRect.left) {
        return 1;
    } else if (mFirstRect.bottom < mSecondRect.bottom) {
        return -1;
    } else if (mFirstRect.bottom > mSecondRect.bottom) {
        return 1;
    } else if (mFirstRect.right < mSecondRect.right) {
        return -1;
    } else if (mFirstRect.right > mSecondRect.right) {
        return 1;
    } else {
        // means that the views will retain their layout order relative to one another.
        return 0;
    }
}","{
    if (first == second) {
        return 0;
    }
    getRect(first, mFirstRect);
    getRect(second, mSecondRect);
    if (mFirstRect.top < mSecondRect.top) {
        return -1;
    } else if (mFirstRect.top > mSecondRect.top) {
        return 1;
    } else if (mFirstRect.left < mSecondRect.left) {
        return mIsLayoutRtl ? 1 : -1;
    } else if (mFirstRect.left > mSecondRect.left) {
        return mIsLayoutRtl ? -1 : 1;
    } else if (mFirstRect.bottom < mSecondRect.bottom) {
        return -1;
    } else if (mFirstRect.bottom > mSecondRect.bottom) {
        return 1;
    } else if (mFirstRect.right < mSecondRect.right) {
        return mIsLayoutRtl ? 1 : -1;
    } else if (mFirstRect.right > mSecondRect.right) {
        return mIsLayoutRtl ? -1 : 1;
    } else {
        // means that the views will retain their layout order relative to one another.
        return 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The code change includes the modified return statements inside the conditions, which now consider the additional variable 'mIsLayoutRtl'. Therefore, the code change type is 1(Control dependency changed) and 3(Return statement changed).","Because of the changes in the return statements and control dependencies, the API could potentially return different values in the late version. Therefore, the type of Compatibility Issue is 1 (Compatibility Issue caused by potential different return values)."
233,<android.content.res.Resources: ColorStateList getColorStateList(int)>,17,18,<android.content.res.Resources: ColorStateList getColorStateList(int)>,<android.content.res.Resources: ColorStateList getColorStateList(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        return loadColorStateList(value, id);
    }
}","{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    ColorStateList res = loadColorStateList(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}",1,"/**
 * Return a color state list associated with a particular resource ID.  The
 * resource may contain either a single raw color value, or a complex
 * {@link android.content.res.ColorStateList} holding multiple possible colors.
 *
 * @param id The desired resource identifier of a {@link ColorStateList},
 * as generated by the aapt tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a ColorStateList object containing either a single
 * solid color or multiple colors that can be selected based on a state.
 */
","/**
 * Return a color state list associated with a particular resource ID.  The
 * resource may contain either a single raw color value, or a complex
 * {@link android.content.res.ColorStateList} holding multiple possible colors.
 *
 * @param id The desired resource identifier of a {@link ColorStateList},
 * as generated by the aapt tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a ColorStateList object containing either a single
 * solid color or multiple colors that can be selected based on a state.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control dependency on the 'synchronized' statement and 'if' statement has changed. The return statement was directly under the 'synchronized' block, but in the new version, it's outside the block. Some new variables and object creation were introduced in the late version as well. Hence, the code change type is 1, 3, 4.","Since the return statement has been moved out of the 'synchronized' block, and the control logic and other statements have changed, it may result in different 'res'(or return values) potentially. Thus, the CI type is 1."
235,<android.app.NativeActivity: void onCreate(Bundle)>,17,18,<android.app.NativeActivity: void onCreate(Bundle)>,<android.app.NativeActivity: void onCreate(Bundle)>,0,"{
    String libname = ""main"";
    String funcname = ""ANativeActivity_onCreate"";
    ActivityInfo ai;
    mIMM = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
    mInputMethodCallback = new InputMethodCallback(this);
    getWindow().takeSurface(this);
    getWindow().takeInputQueue(this);
    getWindow().setFormat(PixelFormat.RGB_565);
    getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
    mNativeContentView = new NativeContentView(this);
    mNativeContentView.mActivity = this;
    setContentView(mNativeContentView);
    mNativeContentView.requestFocus();
    mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
    try {
        ai = getPackageManager().getActivityInfo(getIntent().getComponent(), PackageManager.GET_META_DATA);
        if (ai.metaData != null) {
            String ln = ai.metaData.getString(META_DATA_LIB_NAME);
            if (ln != null)
                libname = ln;
            ln = ai.metaData.getString(META_DATA_FUNC_NAME);
            if (ln != null)
                funcname = ln;
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(""Error getting activity info"", e);
    }
    String path = null;
    File libraryFile = new File(ai.applicationInfo.nativeLibraryDir, System.mapLibraryName(libname));
    if (libraryFile.exists()) {
        path = libraryFile.getPath();
    }
    if (path == null) {
        throw new IllegalArgumentException(""Unable to find native library: "" + libname);
    }
    byte[] nativeSavedState = savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
    mNativeHandle = loadNativeCode(path, funcname, Looper.myQueue(), getFilesDir().toString(), getObbDir().toString(), Environment.getExternalStorageAppFilesDirectory(ai.packageName).toString(), Build.VERSION.SDK_INT, getAssets(), nativeSavedState);
    if (mNativeHandle == 0) {
        throw new IllegalArgumentException(""Unable to load native library: "" + path);
    }
    super.onCreate(savedInstanceState);
}","{
    String libname = ""main"";
    String funcname = ""ANativeActivity_onCreate"";
    ActivityInfo ai;
    mIMM = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
    getWindow().takeSurface(this);
    getWindow().takeInputQueue(this);
    getWindow().setFormat(PixelFormat.RGB_565);
    getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
    mNativeContentView = new NativeContentView(this);
    mNativeContentView.mActivity = this;
    setContentView(mNativeContentView);
    mNativeContentView.requestFocus();
    mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
    try {
        ai = getPackageManager().getActivityInfo(getIntent().getComponent(), PackageManager.GET_META_DATA);
        if (ai.metaData != null) {
            String ln = ai.metaData.getString(META_DATA_LIB_NAME);
            if (ln != null)
                libname = ln;
            ln = ai.metaData.getString(META_DATA_FUNC_NAME);
            if (ln != null)
                funcname = ln;
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(""Error getting activity info"", e);
    }
    String path = null;
    File libraryFile = new File(ai.applicationInfo.nativeLibraryDir, System.mapLibraryName(libname));
    if (libraryFile.exists()) {
        path = libraryFile.getPath();
    }
    if (path == null) {
        throw new IllegalArgumentException(""Unable to find native library: "" + libname);
    }
    byte[] nativeSavedState = savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
    mNativeHandle = loadNativeCode(path, funcname, Looper.myQueue(), getFilesDir().toString(), getObbDir().toString(), Environment.getExternalStorageAppFilesDirectory(ai.packageName).toString(), Build.VERSION.SDK_INT, getAssets(), nativeSavedState);
    if (mNativeHandle == 0) {
        throw new IllegalArgumentException(""Unable to load native library: "" + path);
    }
    super.onCreate(savedInstanceState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation of the method between the two versions.,"Since there is no change, there is no compatibility issue."
237,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",17,18,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>","<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,int,int)>",0,"{
    // that we need to fix this.
    if (builtInDisplayId != Surface.BUILT_IN_DISPLAY_ID_MAIN) {
        Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."");
        scheduleVsync();
        return;
    }
    // Post the vsync event to the Handler.
    // The idea is to prevent incoming vsync events from completely starving
    // the message queue.  If there are no messages in the queue with timestamps
    // earlier than the frame time, then the vsync event will be processed immediately.
    // Otherwise, messages that predate the vsync event will be handled first.
    long now = System.nanoTime();
    if (timestampNanos > now) {
        Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
        timestampNanos = now;
    }
    if (mHavePendingVsync) {
        Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
    } else {
        mHavePendingVsync = true;
    }
    mTimestampNanos = timestampNanos;
    mFrame = frame;
    Message msg = Message.obtain(mHandler, this);
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS);
}","{
    // that we need to fix this.
    if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {
        Log.d(TAG, ""Received vsync from secondary display, but we don't support "" + ""this case yet.  Choreographer needs a way to explicitly request "" + ""vsync for a specific display to ensure it doesn't lose track "" + ""of its scheduled vsync."");
        scheduleVsync();
        return;
    }
    // Post the vsync event to the Handler.
    // The idea is to prevent incoming vsync events from completely starving
    // the message queue.  If there are no messages in the queue with timestamps
    // earlier than the frame time, then the vsync event will be processed immediately.
    // Otherwise, messages that predate the vsync event will be handled first.
    long now = System.nanoTime();
    if (timestampNanos > now) {
        Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
        timestampNanos = now;
    }
    if (mHavePendingVsync) {
        Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
    } else {
        mHavePendingVsync = true;
    }
    mTimestampNanos = timestampNanos;
    mFrame = frame;
    Message msg = Message.obtain(mHandler, this);
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, timestampNanos / NANOS_PER_MS);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The dependent API ""Surface"" has been changed to ""SurfaceControl"" in the condition's check ""builtInDisplayId != Surface(BUILT_IN_DISPLAY_ID_MAIN)"" to ""builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN"" but all other code remains the same, so the code change type is 5.","Due to the dependent API changed, the condition evaluation may change. If the condition of the first 'if' statement change, the method might return earlier, hence the behavior of the method could be altered. Thus the CI type is 1."
238,<android.content.res.Resources: AssetFileDescriptor openRawResourceFd(int)>,17,18,<android.content.res.Resources: AssetFileDescriptor openRawResourceFd(int)>,<android.content.res.Resources: AssetFileDescriptor openRawResourceFd(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        try {
            return mAssets.openNonAssetFd(value.assetCookie, value.string.toString());
        } catch (Exception e) {
            NotFoundException rnf = new NotFoundException(""File "" + value.string.toString() + "" from drawable resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
    }
}","{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    try {
        return mAssets.openNonAssetFd(value.assetCookie, value.string.toString());
    } catch (Exception e) {
        NotFoundException rnf = new NotFoundException(""File "" + value.string.toString() + "" from drawable resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(e);
        throw rnf;
    } finally {
        synchronized (mAccessLock) {
            if (mTmpValue == null) {
                mTmpValue = value;
            }
        }
    }
}",1,"/**
 * Open a file descriptor for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * <p>This function only works for resources that are stored in the package
 * as uncompressed data, which typically includes things like mp3 files
 * and png images.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return AssetFileDescriptor A new file descriptor you can use to read
 * the resource.  This includes the file descriptor itself, as well as the
 * offset and length of data where the resource appears in the file.  A
 * null is returned if the file exists but is compressed.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Open a file descriptor for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * <p>This function only works for resources that are stored in the package
 * as uncompressed data, which typically includes things like mp3 files
 * and png images.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return AssetFileDescriptor A new file descriptor you can use to read
 * the resource.  This includes the file descriptor itself, as well as the
 * offset and length of data where the resource appears in the file.  A
 * null is returned if the file exists but is compressed.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The creation and assignment of the 'value' variable have changed from being inside the first 'synchronized' block to being outside in the later version. Also, a new 'synchronized' block has been added to the 'finally' section in the late version. Therefore, the classification of the change is 3,4.","The changes on how variable 'value' is processed and the additional processing in finally section do not affect the return value or the exception thrown by the method. The returned value and exception still come from the same method call mAssets.openNonAssetFd and the same exception thrown construction. Therefore, no Compatibility Issue exists."
239,"<android.view.Surface: void writeToParcel(Parcel,int)>",17,18,"<android.view.Surface: void writeToParcel(Parcel,int)>","<android.view.Surface: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeString(mName);
    nativeWriteToParcel(dest);
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        release();
    }
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    synchronized (mLock) {
        dest.writeString(mName);
        nativeWriteToParcel(mNativeSurface, dest);
    }
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        release();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change types are: 3) Control dependency changed because of the introduction of the 'synchronized (mLock)' block; 4) Other statement changed because the line 'nativeWriteToParcel(dest);' is replaced by 'nativeWriteToParcel(mNativeSurface, dest);'.",There are no compatibility issues because the method does not return any value nor throw any different exceptions. The change is only about synchronizing the write operation to the parcel and providing an additional parameter to the nativeWriteToParcel function. These revisions will only change the execution but do not lead to different behaviors in terms of its outputs/returns or exceptions.
240,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",17,18,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>","<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",0,"{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags, mContext.getUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags, mContext.getUserId(), mContext.getBasePackageName());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"In the late version, a new parameter has been added in the method mPM.setApplicationEnabledSetting, hence the change type is 1,5.","Because of the extra parameter added in setApplicationEnabledSetting method, which makes the method invoke differently. It potentially leads to a different return, hence the CI type is 1."
244,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",17,18,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    final long key = isColorDrawable ? value.data : (((long) value.assetCookie) << 32) | value.data;
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (isColorDrawable) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, ""Loading framework drawable #"" + Integer.toHexString(id) + "": "" + name + "" at "" + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                if (verifyPreloadConfig(value, ""drawable"")) {
                    if (isColorDrawable) {
                        sPreloadedColorDrawables.put(key, cs);
                    } else {
                        sPreloadedDrawables.put(key, cs);
                    }
                }
            } else {
                synchronized (mTmpValue) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    final long key = isColorDrawable ? value.data : (((long) value.assetCookie) << 32) | value.data;
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (isColorDrawable) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, ""Loading framework drawable #"" + Integer.toHexString(id) + "": "" + name + "" at "" + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            } else {
                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                final int changingConfigs = cs.getChangingConfigurations();
                if (isColorDrawable) {
                    if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, ""drawable"")) {
                        sPreloadedColorDrawables.put(key, cs);
                    }
                } else {
                    if (verifyPreloadConfig(changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, ""drawable"")) {
                        if ((changingConfigs & LAYOUT_DIR_CONFIG) == 0) {
                            // If this resource does not vary based on layout direction,
                            // we can put it in all of the preload maps.
                            sPreloadedDrawables[0].put(key, cs);
                            sPreloadedDrawables[1].put(key, cs);
                        } else {
                            // Otherwise, only in the layout dir we loaded it for.
                            final LongSparseArray<Drawable.ConstantState> preloads = sPreloadedDrawables[mConfiguration.getLayoutDirection()];
                            preloads.put(key, cs);
                        }
                    }
                }
            } else {
                synchronized (mAccessLock) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"Multiple elements have changed from the early version to the late version. The method that is being invoked on `sPreloadedDrawables` has changed and now uses the `getLayoutDirection` method that belongs to `mConfiguration`. Also, some synchronized blocks refer to `mAccessLock` instead of `mTmpValue`. Therefore, the control dependency (3) and dependent APIs (5) have also changed.","These changes, specifically the use of `getLayoutDirection` and the alterations in the synchronized blocks, can potentially change the return value of the function (type 1 CI). Thus the Compatibility Issue cite is 1."
245,<android.content.ClipboardManager: boolean hasText()>,17,18,<android.content.ClipboardManager: boolean hasText()>,<android.content.ClipboardManager: boolean hasText()>,0,"{
    try {
        return getService().hasClipboardText();
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return getService().hasClipboardText(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
","/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the 'return' statement, the method 'hasClipboardText' of 'getService' has added a parameter 'mContext.getBasePackageName()', so the code changes should be classified as 1,4. ","The new parameter might affect the value returned by the 'hasClipboardText' method, which would result in different return values between the two versions. This corresponds to a CI type 1."
246,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",17,18,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAcount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAccount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}",1,"/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
","/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, the name of the method used in the doWork() function has changed from mService.addAcount to mService.addAccount, so the code change type is 4.","Since the method mService.addAccount in the late version just corrects a spelling mistake from the early version (mService.addAcount), it doesnt lead to a compatibility issue. The return value and exception handling remain the same in both versions. Therefore, no compatibility issue exists, so the CI type is 0."
248,<android.widget.ImageView: boolean hasOverlappingRendering()>,17,18,<android.widget.ImageView: boolean hasOverlappingRendering()>,<android.widget.ImageView: boolean hasOverlappingRendering()>,0,"{
    return (getBackground() != null);
}","{
    return (getBackground() != null && getBackground().getCurrent() != null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The boolean condition of the return statement has changed, adding a new condition (`getBackground().getCurrent() != null`), so the code change type is 3.","The return value could potentially vary between versions as a result of the change in the condition, leading to a compatibility issue of type 1."
251,<android.text.Layout: float getSecondaryHorizontal(int)>,17,18,<android.text.Layout: float getSecondaryHorizontal(int)>,<android.text.Layout: float getSecondaryHorizontal(int)>,0,"{
    boolean trailing = primaryIsTrailingPrevious(offset);
    return getHorizontal(offset, !trailing);
}","{
    return getSecondaryHorizontal(offset, false);
}",1,"/**
 * Get the secondary horizontal position for the specified text offset.
 * This is the location where a new character would be inserted in
 * the direction other than the paragraph's primary direction.
 */
","/**
 * Get the secondary horizontal position for the specified text offset.
 * This is the location where a new character would be inserted in
 * the direction other than the paragraph's primary direction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed and the parameter for getHorizontal() method has also changed, so the code change type is 1,5.","The new implementation changes the way 'getSecondaryHorizontal' works by discarding previous logic, which might lead the API to return different results. Thus, there is a compatibility issue of type 1."
253,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",17,18,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>","<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mTmpValue) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mAccessLock) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation has been modified to introduce the invocation of Trace.traceBegin and Trace.traceEnd, while the parameters of the verifyPreloadConfig() method have also been changed. Thus, the code change type is 3,4.","The changes in control structure and other statements can potentially influence the execution flow of the method, leading to different return values. Therefore, the CI type is 1."
254,"<android.text.TextDirectionHeuristics.TextDirectionHeuristicImpl: boolean isRtl(char[],int,int)>",17,18,"<android.text.TextDirectionHeuristics.TextDirectionHeuristicImpl: boolean isRtl(char[],int,int)>","<android.text.TextDirectionHeuristics.TextDirectionHeuristicImpl: boolean isRtl(char[],int,int)>",0,"{
    if (chars == null || start < 0 || count < 0 || chars.length - count < start) {
        throw new IllegalArgumentException();
    }
    if (mAlgorithm == null) {
        return defaultIsRtl();
    }
    return doCheck(chars, start, count);
}","{
    return isRtl(CharBuffer.wrap(array), start, count);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed entirely between the two versions, with the return statements being modified and the dependent API being changed, so the prediction is 1,5.","The change of return statement will make the API potentially return different values, due to changes in method calls in its implementation. Therefore, the CI is of type 1."
257,<android.app.Notification.Builder: Builder setTicker(CharSequence)>,17,18,<android.app.Notification.Builder: Builder setTicker(CharSequence)>,<android.app.Notification.Builder: Builder setTicker(CharSequence)>,0,"{
    mTickerText = tickerText;
    return this;
}","{
    mTickerText = safeCharSequence(tickerText);
    return this;
}",1,"/**
 * Set the ""ticker"" text which is displayed in the status bar when the notification first
 * arrives.
 *
 * @see Notification#tickerText
 */
","/**
 * Set the ""ticker"" text which is displayed in the status bar when the notification first
 * arrives.
 *
 * @see Notification#tickerText
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement 'mTickerText = tickerText' has changed to 'mTickerText = safeCharSequence(tickerText)', which includes a change in the method call. Therefore, the change type is 4,5.","As the method 'safeCharSequence()' might process the variable 'tickerText' in a different way compared to direct assignment, it could potentially lead to a different value to be assigned to 'mTickerText'. Thus, the CI type is 1."
258,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",17,18,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>","<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",0,"{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.setAllowFds(false);
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()));
    } catch (RemoteException e) {
    }
    return binder;
}","{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess();
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()));
    } catch (RemoteException e) {
    }
    return binder;
}",1,"/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
","/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement service.setAllowFds(false) in the early version has been replaced with service.prepareToLeaveProcess() in the late version. This change doesn't fall into any return statement, exception handling, control dependency or dependent API change. Hence, the code change type is 4.","Even though the internal statement has been changed in the late version, this change does not cause any difference in the behavior of the API, such as returning a different variable or throwing a different exception. Therefore, no Compatibility Issue (CI) exists, so the CI type is 0."
259,<android.content.res.Resources: boolean getBoolean(int)>,17,18,<android.content.res.Resources: boolean getBoolean(int)>,<android.content.res.Resources: boolean getBoolean(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data != 0;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data != 0;
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}",1,"/**
 * Return a boolean associated with a particular resource ID.  This can be
 * used with any integral resource value, and will return true if it is
 * non-zero.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the boolean value contained in the resource.
 */
","/**
 * Return a boolean associated with a particular resource ID.  This can be
 * used with any integral resource value, and will return true if it is
 * non-zero.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns the boolean value contained in the resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statements inside synchronized block have changed. A new block of handling 'value == null' is added before 'getValue(id, value, true)', so the pred_change is 4.","Since a new block of handling 'value == null' introduced, which will lead to the difference in 'return value.data != 0' between the old and new versions. Therefore, pred_CI is 1."
260,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,17,18,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.NumberPicker: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    final int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            removeAllCallbacks();
            break;
    }
    return super.dispatchKeyEvent(event);
}","{
    final int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            removeAllCallbacks();
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_UP:
            if (!mHasSelectorWheel) {
                break;
            }
            switch(event.getAction()) {
                case KeyEvent.ACTION_DOWN:
                    if (mWrapSelectorWheel || (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) ? getValue() < getMaxValue() : getValue() > getMinValue()) {
                        requestFocus();
                        mLastHandledDownDpadKeyCode = keyCode;
                        removeAllCallbacks();
                        if (mFlingScroller.isFinished()) {
                            changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
                        }
                        return true;
                    }
                    break;
                case KeyEvent.ACTION_UP:
                    if (mLastHandledDownDpadKeyCode == keyCode) {
                        mLastHandledDownDpadKeyCode = -1;
                        return true;
                    }
                    break;
            }
    }
    return super.dispatchKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"New cases for the 'KeyEvent.KEYCODE_DPAD_DOWN' and 'KeyEvent.KEYCODE_DPAD_UP' are added to the 'switch' statements, and they have new 'return true' at some conditions, so the code change type is 3,1.","Because of the inserted 'return true' statements under certain conditions in the cases of 'KeyEvent.KEYCODE_DPAD_DOWN' and 'KeyEvent.KEYCODE_DPAD_UP', the return value of the method could be different when these keys are pressed. Therefore, the CI type is 1."
261,<android.inputmethodservice.InputMethodService: void sendDownUpKeyEvents(int)>,17,18,<android.inputmethodservice.InputMethodService: void sendDownUpKeyEvents(int)>,<android.inputmethodservice.InputMethodService: void sendDownUpKeyEvents(int)>,0,"{
    InputConnection ic = getCurrentInputConnection();
    if (ic == null)
        return;
    long eventTime = SystemClock.uptimeMillis();
    ic.sendKeyEvent(new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, keyEventCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE));
    ic.sendKeyEvent(new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, keyEventCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE));
}","{
    InputConnection ic = getCurrentInputConnection();
    if (ic == null)
        return;
    long eventTime = SystemClock.uptimeMillis();
    ic.sendKeyEvent(new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, keyEventCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE));
    ic.sendKeyEvent(new KeyEvent(eventTime, SystemClock.uptimeMillis(), KeyEvent.ACTION_UP, keyEventCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE));
}",1,"/**
 * Send the given key event code (as defined by {@link KeyEvent}) to the
 * current input connection is a key down + key up event pair.  The sent
 * events have {@link KeyEvent#FLAG_SOFT_KEYBOARD KeyEvent.FLAG_SOFT_KEYBOARD}
 * set, so that the recipient can identify them as coming from a software
 * input method, and
 * {@link KeyEvent#FLAG_KEEP_TOUCH_MODE KeyEvent.FLAG_KEEP_TOUCH_MODE}, so
 * that they don't impact the current touch mode of the UI.
 *
 * <p>Note that it's discouraged to send such key events in normal operation;
 * this is mainly for use with {@link android.text.InputType#TYPE_NULL} type
 * text fields, or for non-rich input methods. A reasonably capable software
 * input method should use the
 * {@link android.view.inputmethod.InputConnection#commitText} family of methods
 * to send text to an application, rather than sending key events.</p>
 *
 * @param keyEventCode The raw key code to send, as defined by
 * {@link KeyEvent}.
 */
","/**
 * Send the given key event code (as defined by {@link KeyEvent}) to the
 * current input connection is a key down + key up event pair.  The sent
 * events have {@link KeyEvent#FLAG_SOFT_KEYBOARD KeyEvent.FLAG_SOFT_KEYBOARD}
 * set, so that the recipient can identify them as coming from a software
 * input method, and
 * {@link KeyEvent#FLAG_KEEP_TOUCH_MODE KeyEvent.FLAG_KEEP_TOUCH_MODE}, so
 * that they don't impact the current touch mode of the UI.
 *
 * <p>Note that it's discouraged to send such key events in normal operation;
 * this is mainly for use with {@link android.text.InputType#TYPE_NULL} type
 * text fields, or for non-rich input methods. A reasonably capable software
 * input method should use the
 * {@link android.view.inputmethod.InputConnection#commitText} family of methods
 * to send text to an application, rather than sending key events.</p>
 *
 * @param keyEventCode The raw key code to send, as defined by
 * {@link KeyEvent}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The difference between the early and late versions of code is that `SystemClock.uptimeMillis()` is used as the second parameter in the new KeyEvent for `ACTION_UP` in the late version, instead of `eventTime` in the early version. This change is not related to return statements, exception handling, control dependency or dependent APIs changes. Thus, it is categorized as type 4 (other statement changed).","The change doesn't result in different return values or exceptions. Therefore, it is considered that no Compatibility Issue exists, thus the CI type is 0."
263,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,17,18,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,0,"{
    Rect bounds = mAttachInfo.mTmpInvalRect;
    getDrawingRect(bounds);
    info.setBoundsInParent(bounds);
    getBoundsOnScreen(bounds);
    info.setBoundsInScreen(bounds);
    ViewParent parent = getParentForAccessibility();
    if (parent instanceof View) {
        info.setParent((View) parent);
    }
    if (mID != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View label = rootView.findLabelForView(this, mID);
        if (label != null) {
            info.setLabeledBy(label);
        }
    }
    if (mLabelForId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View labeled = rootView.findViewInsideOutShouldExist(this, mLabelForId);
        if (labeled != null) {
            info.setLabelFor(labeled);
        }
    }
    info.setVisibleToUser(isVisibleToUser());
    info.setPackageName(mContext.getPackageName());
    info.setClassName(View.class.getName());
    info.setContentDescription(getContentDescription());
    info.setEnabled(isEnabled());
    info.setClickable(isClickable());
    info.setFocusable(isFocusable());
    info.setFocused(isFocused());
    info.setAccessibilityFocused(isAccessibilityFocused());
    info.setSelected(isSelected());
    info.setLongClickable(isLongClickable());
    // TODO: These make sense only if we are in an AdapterView but all
    // views can be selected. Maybe from accessibility perspective
    // we should report as selectable view in an AdapterView.
    info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    if (isFocusable()) {
        if (isFocused()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_FOCUS);
        } else {
            info.addAction(AccessibilityNodeInfo.ACTION_FOCUS);
        }
    }
    if (!isAccessibilityFocused()) {
        info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    }
    if (isClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
    }
    if (isLongClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
    }
    if (mContentDescription != null && mContentDescription.length() > 0) {
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH);
    }
}","{
    Rect bounds = mAttachInfo.mTmpInvalRect;
    getDrawingRect(bounds);
    info.setBoundsInParent(bounds);
    getBoundsOnScreen(bounds);
    info.setBoundsInScreen(bounds);
    ViewParent parent = getParentForAccessibility();
    if (parent instanceof View) {
        info.setParent((View) parent);
    }
    if (mID != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View label = rootView.findLabelForView(this, mID);
        if (label != null) {
            info.setLabeledBy(label);
        }
        if ((mAttachInfo.mAccessibilityFetchFlags & AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS) != 0 && Resources.resourceHasPackage(mID)) {
            try {
                String viewId = getResources().getResourceName(mID);
                info.setViewIdResourceName(viewId);
            } catch (Resources.NotFoundException nfe) {
            /* ignore */
            }
        }
    }
    if (mLabelForId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View labeled = rootView.findViewInsideOutShouldExist(this, mLabelForId);
        if (labeled != null) {
            info.setLabelFor(labeled);
        }
    }
    info.setVisibleToUser(isVisibleToUser());
    info.setPackageName(mContext.getPackageName());
    info.setClassName(View.class.getName());
    info.setContentDescription(getContentDescription());
    info.setEnabled(isEnabled());
    info.setClickable(isClickable());
    info.setFocusable(isFocusable());
    info.setFocused(isFocused());
    info.setAccessibilityFocused(isAccessibilityFocused());
    info.setSelected(isSelected());
    info.setLongClickable(isLongClickable());
    // TODO: These make sense only if we are in an AdapterView but all
    // views can be selected. Maybe from accessibility perspective
    // we should report as selectable view in an AdapterView.
    info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    if (isFocusable()) {
        if (isFocused()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_FOCUS);
        } else {
            info.addAction(AccessibilityNodeInfo.ACTION_FOCUS);
        }
    }
    if (!isAccessibilityFocused()) {
        info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    }
    if (isClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
    }
    if (isLongClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
    }
    CharSequence text = getIterableTextForAccessibility();
    if (text != null && text.length() > 0) {
        info.setTextSelection(getAccessibilitySelectionStart(), getAccessibilitySelectionEnd());
        info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH);
    }
}",1,"/**
 * @see #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
","/**
 * @see #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Several statements have been introduced in the late version, including a condition statement. Also, two statements have been deleted compared to the early version. Therefore, the change type should be 1,4.","The API has potentially changed the state of 'info' object in the late version, therefore, different operations in the late version API may lead to different return values, so the CI type should be 1."
264,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",17,18,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class)} Intent.setClass</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two new statements (intent.migrateExtraStreamToClipData() and intent.prepareToLeaveProcess()) are added in the late version. Thus, the code change is the type of 4 (Other statement changed).","Since the added statements don't modify the return value of the API or the exceptions it throws, no Compatibility Issue (CI) has been caused."
265,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",17,18,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, AppOpsManager.OP_NONE, true, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call to intent.setAllowFds(false) has been replaced with a call to intent.prepareToLeaveProcess() and the parameters of the function call ActivityManagerNative.getDefault().broadcastIntent() has also changed, so the change type is 1,5 as both the function call and the parameters are changed.","As the function call is changed, the broadcastIntent() may lead to different behaviors which might possibly make the return value of the method different, thus the CI type is 1."
266,"<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>",17,18,"<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>","<android.view.GLES20Canvas: void drawPoints(float[],int,int,Paint)>",0,"{
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawPoints(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    if (count < 2)
        return;
    int modifiers = setupModifiers(paint, MODIFIER_COLOR_FILTER | MODIFIER_SHADER);
    try {
        nDrawPoints(mRenderer, pts, offset, count, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement has been introduced under a new 'if' statement, so the code change type is 1,3.","The new return statement under 'if' control can potentially make the API return without executing the rest of the method, which could have resulted in different behavior. Therefore, CI type is 1."
267,<android.view.accessibility.AccessibilityNodeInfo: void recycle()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: void recycle()>,<android.view.accessibility.AccessibilityNodeInfo: void recycle()>,0,"{
    if (mIsInPool) {
        throw new IllegalStateException(""Info already recycled!"");
    }
    clear();
    synchronized (sPoolLock) {
        if (sPoolSize <= MAX_POOL_SIZE) {
            mNext = sPool;
            sPool = this;
            mIsInPool = true;
            sPoolSize++;
        }
    }
}","{
    clear();
    sPool.release(this);
}",1,"/**
 * Return an instance back to be reused.
 * <p>
 * <strong>Note:</strong> You must not touch the object after calling this function.
 *
 * @throws IllegalStateException If the info is already recycled.
 */
","/**
 * Return an instance back to be reused.
 * <p>
 * <strong>Note:</strong> You must not touch the object after calling this function.
 *
 * @throws IllegalStateException If the info is already recycled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is uncertainty in the mechanism of how the object is recycled in the Early Version, where the object is put back into the pool only when the pool size is within MAX_POOL_SIZE. The late version, on the other hand, releases the object to the pool directly, replacing the synchronized block and the if condition by a simpler call to sPool.release(this). Therefore, the change type includes both Control dependency change (3) and Other statement change (4).","Although the implementation details have changed, the overall behaviour of the method - recycling an object - should remain the same. Hence, no Compatibility Issue (0) should exist."
268,<android.view.Surface: String toString()>,17,18,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"{
    return ""Surface(name="" + mName + "", identity="" + nativeGetIdentity() + "")"";
}","{
    synchronized (mLock) {
        return ""Surface(name="" + mName + "")"";
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed: part of the return value (""identity="" + nativeGetIdentity()) has been removed and there is the introduction of a new 'synchronized' control block. Hence, the code change type is 1,3.","The removal of part of the return value (""identity="" + nativeGetIdentity()) could cause the API to possibly return a different value in the late version, thus the CI type is 1."
269,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",17,18,"<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>","<android.hardware.usb.UsbDeviceConnection: int controlTransfer(int,int,int,int,byte[],int,int)>",0,"{
    return native_control_request(requestType, request, value, index, buffer, length, timeout);
}","{
    return controlTransfer(requestType, request, value, index, buffer, 0, length, timeout);
}",1,"/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
","/**
 * Performs a control transaction on endpoint zero for this device.
 * The direction of the transfer is determined by the request type.
 * If requestType & {@link UsbConstants#USB_ENDPOINT_DIR_MASK} is
 * {@link UsbConstants#USB_DIR_OUT}, then the transfer is a write,
 * and if it is {@link UsbConstants#USB_DIR_IN}, then the transfer
 * is a read.
 * <p>
 * This method transfers data starting from index 0 in the buffer.
 * To specify a different offset, use
 * {@link #controlTransfer(int, int, int, int, byte[], int, int, int)}.
 * </p>
 *
 * @param requestType request type for this transaction
 * @param request request ID for this transaction
 * @param value value field for this transaction
 * @param index index field for this transaction
 * @param buffer buffer for data portion of transaction,
 * or null if no data needs to be sent or received
 * @param length the length of the data to send or receive
 * @param timeout in milliseconds
 * @return length of data transferred (or zero) for success,
 * or negative value for failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call in the return statement has changed from ""native_control_request()"" to ""controlTransfer()"", and also the parameters of the function call has changed. Hence, the code change type is 1,5.","As the return statement has changed, it can potentially lead to a different return value in the later version, so the CI type is 1."
271,"<android.view.View.MeasureSpec: int makeMeasureSpec(int,int)>",17,18,"<android.view.View.MeasureSpec: int makeMeasureSpec(int,int)>","<android.view.View.MeasureSpec: int makeMeasureSpec(int,int)>",0,"{
    return size + mode;
}","{
    if (sUseBrokenMakeMeasureSpec) {
        return size + mode;
    } else {
        return (size & ~MODE_MASK) | (mode & MODE_MASK);
    }
}",1,"/**
 * Creates a measure specification based on the supplied size and mode.
 *
 * The mode must always be one of the following:
 * <ul>
 * <li>{@link android.view.View.MeasureSpec#UNSPECIFIED}</li>
 * <li>{@link android.view.View.MeasureSpec#EXACTLY}</li>
 * <li>{@link android.view.View.MeasureSpec#AT_MOST}</li>
 * </ul>
 *
 * @param size the size of the measure specification
 * @param mode the mode of the measure specification
 * @return the measure specification based on size and mode
 */
","/**
 * Creates a measure specification based on the supplied size and mode.
 *
 * The mode must always be one of the following:
 * <ul>
 * <li>{@link android.view.View.MeasureSpec#UNSPECIFIED}</li>
 * <li>{@link android.view.View.MeasureSpec#EXACTLY}</li>
 * <li>{@link android.view.View.MeasureSpec#AT_MOST}</li>
 * </ul>
 *
 * <p><strong>Note:</strong> On API level 17 and lower, makeMeasureSpec's
 * implementation was such that the order of arguments did not matter
 * and overflow in either value could impact the resulting MeasureSpec.
 * {@link android.widget.RelativeLayout} was affected by this bug.
 * Apps targeting API levels greater than 17 will get the fixed, more strict
 * behavior.</p>
 *
 * @param size the size of the measure specification
 * @param mode the mode of the measure specification
 * @return the measure specification based on size and mode
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement inside 'else' block in the late release is different from the one in the early release and there is also a new if control statement, so the change type is 1,3.","The change in return statement under different control conditions could lead to a different return value of the API in late release comparing with the early release, and therefore the CI type is 1."
272,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",17,18,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",0,"{
    if (!mIsConnecting) {
        try {
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            mgr.bindRemoteViewsService(appWidgetId, intent, asBinder());
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RemoteViewsAdapterServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}","{
    if (!mIsConnecting) {
        try {
            RemoteViewsAdapter adapter;
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            if (Process.myUid() == Process.SYSTEM_UID && (adapter = mAdapter.get()) != null) {
                mgr.bindRemoteViewsService(appWidgetId, intent, asBinder(), new UserHandle(adapter.mUserId));
            } else {
                mgr.bindRemoteViewsService(appWidgetId, intent, asBinder(), Process.myUserHandle());
            }
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RemoteViewsAdapterServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, a new control statement 'if (Process.myUid() == Process.SYSTEM_UID && (adapter = mAdapter.get()) != null)' is introduced and the parameter of method 'mgr.bindRemoteViewsService' has also changed. Therefore, the code changed type is 3,4. ","The parameter change in 'mgr.bindRemoteViewsService' method could cause the API to behave differently, such as returning a different type/value, and the new control statement could also lead to different behaviours. Thus, the CI type is 1."
273,"<android.webkit.AccessibilityInjector.TextToSpeechWrapper: int speak(String,int,HashMap<String, String>)>",17,18,"<android.webkit.AccessibilityInjector.TextToSpeechWrapper: int speak(String,int,HashMap<String, String>)>","<android.webkit.AccessibilityInjector.TextToSpeechWrapper: int speak(String,int,HashMap<String, String>)>",0,"{
    synchronized (mTextToSpeech) {
        if (!mReady) {
            if (DEBUG) {
                Log.w(WRAP_TAG, ""["" + hashCode() + ""] Attempted to speak before TTS init"");
            }
            return TextToSpeech.ERROR;
        } else {
            if (DEBUG) {
                Log.i(WRAP_TAG, ""["" + hashCode() + ""] Speak called from JS binder"");
            }
        }
        return mTextToSpeech.speak(text, queueMode, params);
    }
}","{
    synchronized (mTtsLock) {
        if (!mReady) {
            if (DEBUG) {
                Log.w(WRAP_TAG, ""["" + hashCode() + ""] Attempted to speak before TTS init"");
            }
            return TextToSpeech.ERROR;
        } else {
            if (DEBUG) {
                Log.i(WRAP_TAG, ""["" + hashCode() + ""] Speak called from JS binder"");
            }
        }
        return mTextToSpeech.speak(text, queueMode, params);
    }
}",1,,,-1,"[@JavascriptInterface, @SuppressWarnings(""unused"")]","[@JavascriptInterface, @SuppressWarnings(""unused"")]",-1,-1,-1,-1,-1,-1,4,0,"The synchronized block now locks on a different object (mTextToSpeech -> mTtsLock), so the code change type is 4.","Despite the change in the synchronization object, this will not influence the output of the method or the exceptions it might throw, therefore there is no Compatibility Issue. Hence, the CI type is 0."
275,<android.app.ApplicationPackageManager: int installExistingPackage(String)>,17,18,<android.app.ApplicationPackageManager: int installExistingPackage(String)>,<android.app.ApplicationPackageManager: int installExistingPackage(String)>,0,"{
    try {
        int res = mPM.installExistingPackage(packageName);
        if (res == INSTALL_FAILED_INVALID_URI) {
            throw new NameNotFoundException(""Package "" + packageName + "" doesn't exist"");
        }
        return res;
    } catch (RemoteException e) {
        // Should never happen!
        throw new NameNotFoundException(""Package "" + packageName + "" doesn't exist"");
    }
}","{
    try {
        int res = mPM.installExistingPackageAsUser(packageName, UserHandle.myUserId());
        if (res == INSTALL_FAILED_INVALID_URI) {
            throw new NameNotFoundException(""Package "" + packageName + "" doesn't exist"");
        }
        return res;
    } catch (RemoteException e) {
        // Should never happen!
        throw new NameNotFoundException(""Package "" + packageName + "" doesn't exist"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API has changed from mPM.installExistingPackage(packageName) in the early version to mPM.installExistingPackageAsUser(packageName, UserHandle.myUserId()) in the late version, which also altered the return statement, so the code change type is 1 and 5.","The change of the dependent API implies a different return statement, which may cause the function to return a different result, hence, it poses a compatibility issue of type 1."
276,<android.view.ViewGroup.MarginLayoutParams: boolean isMarginRelative()>,17,18,<android.view.ViewGroup.MarginLayoutParams: boolean isMarginRelative()>,<android.view.ViewGroup.MarginLayoutParams: boolean isMarginRelative()>,0,"{
    return (startMargin != DEFAULT_RELATIVE) || (endMargin != DEFAULT_RELATIVE);
}","{
    return (startMargin != DEFAULT_MARGIN_RELATIVE || endMargin != DEFAULT_MARGIN_RELATIVE);
}",1,"/**
 * Check if margins are relative.
 *
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 *
 * @return true if either marginStart or marginEnd has been set.
 */
","/**
 * Check if margins are relative.
 *
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginEnd
 *
 * @return true if either marginStart or marginEnd has been set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statements are different since startMargin and endMargin are compared to different values (DEFAULT_RELATIVE and DEFAULT_MARGIN_RELATIVE), so the code change type is 1,5.","The change of the condition in the return statement can make the return values of this function different, so the change leads to CI of type 1."
277,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",17,18,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, true, true, user.getIdentifier());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The ""intent.setAllowFds(false);"" statement in the try block from the early version is replaced by the ""intent.prepareToLeaveProcess();"" statement in the late version. Additionally, the 'broadcastIntent' dependent API's parameters have changed from 'null, true, true' to 'AppOpsManager.OP_NONE, true, true'. Therefore, codes changes belong to classes 4 and 5.","The change in the method invoked on the 'intent' instance and the change in the parameters of the 'broadcastIntent' method can potentially alter returned values of the API, leading to a compatibility issue of type 1."
278,<android.widget.QuickContactBadge: void onClick(View)>,17,18,<android.widget.QuickContactBadge: void onClick(View)>,<android.widget.QuickContactBadge: void onClick(View)>,0,"{
    if (mContactUri != null) {
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (mContactEmail != null) {
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, mContactEmail, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null) {
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, mContactPhone, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}","{
    // If contact has been assigned, mExtras should no longer be null, but do a null check
    // anyway just in case assignContactFromPhone or Email was called with a null bundle or
    // wasn't assigned previously.
    final Bundle extras = (mExtras == null) ? new Bundle() : mExtras;
    if (mContactUri != null) {
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (mContactEmail != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactEmail);
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactPhone);
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,An extra statement was added at the beginning of the late version (final Bundle extras = (mExtras == null) ? new Bundle() : mExtras;) and the changes were made in the method calls inside 'if' and 'else if' conditions. This changes fall under the category of control dependency changes (3) and other statement changes (4).,"These changes in statements or calls don't affect the output or the exception handling of the API, so no Compatibility Issue (0) exists."
279,<android.speech.tts.FileSynthesisCallback: int done()>,17,18,<android.speech.tts.FileSynthesisCallback: int done()>,<android.speech.tts.FileSynthesisCallback: int done()>,0,"{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    synchronized (mStateLock) {
        if (mDone) {
            if (DBG)
                Log.d(TAG, ""Duplicate call to done()"");
            // we'd return ERROR because mFile == null and we'd add to logspam.
            return TextToSpeech.ERROR;
        }
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            // Write WAV header at start of file
            mFile.seek(0);
            int dataLength = (int) (mFile.length() - WAV_HEADER_LENGTH);
            mFile.write(makeWavHeader(mSampleRateInHz, mAudioFormat, mChannelCount, dataLength));
            closeFileAndWidenPermissions();
            mDone = true;
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    synchronized (mStateLock) {
        if (mDone) {
            if (DBG)
                Log.d(TAG, ""Duplicate call to done()"");
            // we'd return ERROR because mFile == null and we'd add to logspam.
            return TextToSpeech.ERROR;
        }
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            // Write WAV header at start of file
            mFileChannel.position(0);
            int dataLength = (int) (mFileChannel.size() - WAV_HEADER_LENGTH);
            mFileChannel.write(makeWavHeader(mSampleRateInHz, mAudioFormat, mChannelCount, dataLength));
            closeFile();
            mDone = true;
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to output file descriptor"", ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The variable name has changed from 'mFile' to 'mFileChannel'. In addition, the methods 'closeFileAndWidenPermissions()' and 'cleanUp()' have been replaced by 'closeFile()'. Therefore, the change types are 1 (for the return statement change), 4 (for the other statement changes), and 5 (for the dependent API changes).","Due to these changes, the method may now return different results under the same conditions, which constitutes a compatibility issue of type 1 (potential different return values or types)."
280,<android.view.accessibility.AccessibilityNodeInfo: boolean isFocused()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isFocused()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isFocused()>,0,"{
    return getBooleanProperty(PROPERTY_FOCUSED);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_FOCUSED);
}",1,"/**
 * Gets whether this node is focused.
 *
 * @return True if the node is focused.
 */
","/**
 * Gets whether this node is focused.
 *
 * @return True if the node is focused.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getBooleanProperty(PROPERTY_FOCUSED) to getBooleanProperty(BOOLEAN_PROPERTY_FOCUSED) and the parameter type of getBooleanProperty() function also changed, thus the change type is denoted as 1,5.","The change of return statement will make the API potentially return a different value. Therefore, the CI type is 1."
281,<android.view.Surface: void finalize()>,17,18,<android.view.Surface: void finalize()>,<android.view.Surface: void finalize()>,0,"{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        nativeRelease();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        release();
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method nativeRelease() has been replaced by release(), so the return type of this function has changed. Thus, the code change types are 1,5.","The call to release() might potentially return a different type or value compared to nativeRelease(), thus leading to a Compatibility Issue type 1."
282,"<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(long,long,long,int)>",17,18,"<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(long,long,long,int)>","<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(long,long,long,int)>",0,"{
    Resources r = Resources.getSystem();
    boolean abbrevRelative = (flags & (FORMAT_ABBREV_RELATIVE | FORMAT_ABBREV_ALL)) != 0;
    boolean past = (now >= time);
    long duration = Math.abs(now - time);
    int resId;
    long count;
    if (duration < MINUTE_IN_MILLIS && minResolution < MINUTE_IN_MILLIS) {
        count = duration / SECOND_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_seconds_ago;
            } else {
                resId = com.android.internal.R.plurals.num_seconds_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_seconds;
            } else {
                resId = com.android.internal.R.plurals.in_num_seconds;
            }
        }
    } else if (duration < HOUR_IN_MILLIS && minResolution < HOUR_IN_MILLIS) {
        count = duration / MINUTE_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_minutes_ago;
            } else {
                resId = com.android.internal.R.plurals.num_minutes_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_minutes;
            } else {
                resId = com.android.internal.R.plurals.in_num_minutes;
            }
        }
    } else if (duration < DAY_IN_MILLIS && minResolution < DAY_IN_MILLIS) {
        count = duration / HOUR_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_hours_ago;
            } else {
                resId = com.android.internal.R.plurals.num_hours_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_hours;
            } else {
                resId = com.android.internal.R.plurals.in_num_hours;
            }
        }
    } else if (duration < WEEK_IN_MILLIS && minResolution < WEEK_IN_MILLIS) {
        count = getNumberOfDaysPassed(time, now);
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_days_ago;
            } else {
                resId = com.android.internal.R.plurals.num_days_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_days;
            } else {
                resId = com.android.internal.R.plurals.in_num_days;
            }
        }
    } else {
        // in a null context.
        return formatDateRange(null, time, time, flags);
    }
    String format = r.getQuantityString(resId, (int) count);
    return String.format(format, count);
}","{
    Resources r = Resources.getSystem();
    boolean abbrevRelative = (flags & (FORMAT_ABBREV_RELATIVE | FORMAT_ABBREV_ALL)) != 0;
    boolean past = (now >= time);
    long duration = Math.abs(now - time);
    int resId;
    long count;
    if (duration < MINUTE_IN_MILLIS && minResolution < MINUTE_IN_MILLIS) {
        count = duration / SECOND_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_seconds_ago;
            } else {
                resId = com.android.internal.R.plurals.num_seconds_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_seconds;
            } else {
                resId = com.android.internal.R.plurals.in_num_seconds;
            }
        }
    } else if (duration < HOUR_IN_MILLIS && minResolution < HOUR_IN_MILLIS) {
        count = duration / MINUTE_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_minutes_ago;
            } else {
                resId = com.android.internal.R.plurals.num_minutes_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_minutes;
            } else {
                resId = com.android.internal.R.plurals.in_num_minutes;
            }
        }
    } else if (duration < DAY_IN_MILLIS && minResolution < DAY_IN_MILLIS) {
        count = duration / HOUR_IN_MILLIS;
        if (past) {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_num_hours_ago;
            } else {
                resId = com.android.internal.R.plurals.num_hours_ago;
            }
        } else {
            if (abbrevRelative) {
                resId = com.android.internal.R.plurals.abbrev_in_num_hours;
            } else {
                resId = com.android.internal.R.plurals.in_num_hours;
            }
        }
    } else if (duration < WEEK_IN_MILLIS && minResolution < WEEK_IN_MILLIS) {
        return getRelativeDayString(r, time, now);
    } else {
        // in a null context.
        return formatDateRange(null, time, time, flags);
    }
    String format = r.getQuantityString(resId, (int) count);
    return String.format(format, count);
}",1,"/**
 * Returns a string describing 'time' as a time relative to 'now'.
 * <p>
 * Time spans in the past are formatted like ""42 minutes ago"". Time spans in
 * the future are formatted like ""in 42 minutes"".
 * <p>
 * Can use {@link #FORMAT_ABBREV_RELATIVE} flag to use abbreviated relative
 * times, like ""42 mins ago"".
 *
 * @param time the time to describe, in milliseconds
 * @param now the current time in milliseconds
 * @param minResolution the minimum timespan to report. For example, a time
 * 3 seconds in the past will be reported as ""0 minutes ago"" if
 * this is set to MINUTE_IN_MILLIS. Pass one of 0,
 * MINUTE_IN_MILLIS, HOUR_IN_MILLIS, DAY_IN_MILLIS,
 * WEEK_IN_MILLIS
 * @param flags a bit mask of formatting options, such as
 * {@link #FORMAT_NUMERIC_DATE} or
 * {@link #FORMAT_ABBREV_RELATIVE}
 */
","/**
 * Returns a string describing 'time' as a time relative to 'now'.
 * <p>
 * Time spans in the past are formatted like ""42 minutes ago"". Time spans in
 * the future are formatted like ""in 42 minutes"".
 * <p>
 * Can use {@link #FORMAT_ABBREV_RELATIVE} flag to use abbreviated relative
 * times, like ""42 mins ago"".
 *
 * @param time the time to describe, in milliseconds
 * @param now the current time in milliseconds
 * @param minResolution the minimum timespan to report. For example, a time
 * 3 seconds in the past will be reported as ""0 minutes ago"" if
 * this is set to MINUTE_IN_MILLIS. Pass one of 0,
 * MINUTE_IN_MILLIS, HOUR_IN_MILLIS, DAY_IN_MILLIS,
 * WEEK_IN_MILLIS
 * @param flags a bit mask of formatting options, such as
 * {@link #FORMAT_NUMERIC_DATE} or
 * {@link #FORMAT_ABBREV_RELATIVE}
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"In the late version, the statement return getRelativeDayString(r, time, now) has been added replacing the previous operations. So the code change type is 1.","With the new return statement, the API potentially returns a different value which leads to a compatibility issue. Therefore, the CI type is 1."
283,<android.test.AndroidTestCase: void scrubClass(Class<?>)>,17,18,<android.test.AndroidTestCase: void scrubClass(Class<?>)>,<android.test.AndroidTestCase: void scrubClass(Class<?>)>,0,"{
    final Field[] fields = getClass().getDeclaredFields();
    for (Field field : fields) {
        final Class<?> fieldClass = field.getDeclaringClass();
        if (testCaseClass.isAssignableFrom(fieldClass) && !field.getType().isPrimitive()) {
            try {
                field.setAccessible(true);
                field.set(this, null);
            } catch (Exception e) {
                android.util.Log.d(""TestCase"", ""Error: Could not nullify field!"");
            }
            if (field.get(this) != null) {
                android.util.Log.d(""TestCase"", ""Error: Could not nullify field!"");
            }
        }
    }
}","{
    final Field[] fields = getClass().getDeclaredFields();
    for (Field field : fields) {
        if (!field.getType().isPrimitive() && !Modifier.isStatic(field.getModifiers())) {
            try {
                field.setAccessible(true);
                field.set(this, null);
            } catch (Exception e) {
                android.util.Log.d(""TestCase"", ""Error: Could not nullify field!"");
            }
            if (field.get(this) != null) {
                android.util.Log.d(""TestCase"", ""Error: Could not nullify field!"");
            }
        }
    }
}",1,"/**
 * This function is called by various TestCase implementations, at tearDown() time, in order
 * to scrub out any class variables.  This protects against memory leaks in the case where a
 * test case creates a non-static inner class (thus referencing the test case) and gives it to
 * someone else to hold onto.
 *
 * @param testCaseClass The class of the derived TestCase implementation.
 *
 * @throws IllegalAccessException
 */
","/**
 * This function is called by various TestCase implementations, at tearDown() time, in order
 * to scrub out any class variables.  This protects against memory leaks in the case where a
 * test case creates a non-static inner class (thus referencing the test case) and gives it to
 * someone else to hold onto.
 *
 * @param testCaseClass The class of the derived TestCase implementation.
 *
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The conditions of the 'if' statement are modified which is a control dependency change of code.,"The change in the control dependency modifies the logic and may lead to different behaviors producing different outcomes and thus, causing a potential compatibility issue of type 1."
284,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,17,18,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,0,"{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}","{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(appWidgetId, mContext.getUserId());
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}",1,"/**
 * Stop listening to changes for this AppWidget.
 */
","/**
 * Stop listening to changes for this AppWidget.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent ""sService.deleteAppWidgetId()"" method's signature has changed from a single parameter to two parameters in the late version, which falls under category 5 - Dependent API changed. Also, the return statement of sService.deleteAppWidgetId() has slightly changed, making it correspond to change type 1 - Return statement changed.","The change in the signature of the dependent API and its return statement could potentially return different results, leading to Compatibility Issue type 1. Although the behavior of the method and the exceptions it throws remain unchanged, it now operates with an additional context."
286,<android.content.res.Resources: InputStream openRawResource(int)>,17,18,<android.content.res.Resources: InputStream openRawResource(int)>,<android.content.res.Resources: InputStream openRawResource(int)>,0,"{
    synchronized (mTmpValue) {
        return openRawResource(id, mTmpValue);
    }
}","{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
    }
    InputStream res = openRawResource(id, value);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}",1,"/**
 * Open a data stream for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return InputStream Access to the resource data.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
","/**
 * Open a data stream for reading a raw resource.  This can only be used
 * with resources whose value is the name of an asset files -- that is, it can be
 * used to open drawable, sound, and raw resources; it will fail on string
 * and color resources.
 *
 * @param id The resource identifier to open, as generated by the appt
 * tool.
 *
 * @return InputStream Access to the resource data.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The structure of the function has been drastically changed including the instantiation, condition, and calculation statements (TypeValue), the access of the object that is being synchronized has changed, and additional condition control statements have been included. Thus, the code change type is 3 and 4.","The potential return value changes because of the new implementation, where the type value is either grabbed from mTmpValue or a newly instantiated object, and returned by openRawResource(). Therefore, the CI type is 1."
287,<android.os.CommonTimeUtils: InetSocketAddress transactGetSockaddr(int)>,17,18,<android.os.CommonTimeUtils: InetSocketAddress transactGetSockaddr(int)>,<android.os.CommonTimeUtils: InetSocketAddress transactGetSockaddr(int)>,0,"{
    android.os.Parcel data = android.os.Parcel.obtain();
    android.os.Parcel reply = android.os.Parcel.obtain();
    InetSocketAddress ret_val = null;
    try {
        int res;
        data.writeInterfaceToken(mInterfaceDesc);
        mRemote.transact(method_code, data, reply, 0);
        res = reply.readInt();
        if (0 == res) {
            int type;
            int port = 0;
            String addrStr = null;
            type = reply.readInt();
            if (AF_INET == type) {
                int addr = reply.readInt();
                port = reply.readInt();
                addrStr = String.format(""%d.%d.%d.%d"", (addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF);
            } else if (AF_INET6 == type) {
                int addr1 = reply.readInt();
                int addr2 = reply.readInt();
                int addr3 = reply.readInt();
                int addr4 = reply.readInt();
                port = reply.readInt();
                int flowinfo = reply.readInt();
                int scope_id = reply.readInt();
                addrStr = String.format(""[%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X]"", (addr1 >> 16) & 0xFFFF, addr1 & 0xFFFF, (addr2 >> 16) & 0xFFFF, addr2 & 0xFFFF, (addr3 >> 16) & 0xFFFF, addr3 & 0xFFFF, (addr4 >> 16) & 0xFFFF, addr4 & 0xFFFF);
            }
            if (null != addrStr) {
                ret_val = new InetSocketAddress(addrStr, port);
            }
        }
    } finally {
        reply.recycle();
        data.recycle();
    }
    return ret_val;
}","{
    android.os.Parcel data = android.os.Parcel.obtain();
    android.os.Parcel reply = android.os.Parcel.obtain();
    InetSocketAddress ret_val = null;
    try {
        int res;
        data.writeInterfaceToken(mInterfaceDesc);
        mRemote.transact(method_code, data, reply, 0);
        res = reply.readInt();
        if (0 == res) {
            int type;
            int port = 0;
            String addrStr = null;
            type = reply.readInt();
            if (AF_INET == type) {
                int addr = reply.readInt();
                port = reply.readInt();
                addrStr = String.format(Locale.US, ""%d.%d.%d.%d"", (addr >> 24) & 0xFF, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF);
            } else if (AF_INET6 == type) {
                int addr1 = reply.readInt();
                int addr2 = reply.readInt();
                int addr3 = reply.readInt();
                int addr4 = reply.readInt();
                port = reply.readInt();
                int flowinfo = reply.readInt();
                int scope_id = reply.readInt();
                addrStr = String.format(Locale.US, ""[%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X]"", (addr1 >> 16) & 0xFFFF, addr1 & 0xFFFF, (addr2 >> 16) & 0xFFFF, addr2 & 0xFFFF, (addr3 >> 16) & 0xFFFF, addr3 & 0xFFFF, (addr4 >> 16) & 0xFFFF, addr4 & 0xFFFF);
            }
            if (null != addrStr) {
                ret_val = new InetSocketAddress(addrStr, port);
            }
        }
    } finally {
        reply.recycle();
        data.recycle();
    }
    return ret_val;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"In the string formatting part, the 'String.format()' has changed to 'String.format(Locale.US,...)'. So, the code change type is 1.","Due to the format changes for the 'String.format()' function, it will potentially return a different formatted string, hence, the new 'InetSocketAddress(addrStr, port)' may return a different result. Therefore, the CI type is 1."
289,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",17,18,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>","<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */
","/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API ""provider.insert()"" has changed with the inclusion of the extra parameter ""mPackageName"". As this API is included in the return statement, the types of code changes are 1 and 5.","The value returned by the function ""provider.insert()"" is being returned directly from this method. As the function ""provider.insert()"" has changed, the return value could potentially change too. This leads to a compatibility issue of type 1."
290,<android.view.accessibility.AccessibilityEvent: void recycle()>,17,18,<android.view.accessibility.AccessibilityEvent: void recycle()>,<android.view.accessibility.AccessibilityEvent: void recycle()>,0,"{
    if (mIsInPool) {
        throw new IllegalStateException(""Event already recycled!"");
    }
    clear();
    synchronized (sPoolLock) {
        if (sPoolSize <= MAX_POOL_SIZE) {
            mNext = sPool;
            sPool = this;
            mIsInPool = true;
            sPoolSize++;
        }
    }
}","{
    clear();
    sPool.release(this);
}",1,"/**
 * Recycles an instance back to be reused.
 * <p>
 * <b>Note: You must not touch the object after calling this function.</b>
 * </p>
 *
 * @throws IllegalStateException If the event is already recycled.
 */
","/**
 * Recycles an instance back to be reused.
 * <p>
 * <b>Note: You must not touch the object after calling this function.</b>
 * </p>
 *
 * @throws IllegalStateException If the event is already recycled.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The exception statement ""throw new IllegalStateException(""Event already recycled!"");"" is removed and the control flow has been significantly simplified from having a condition and a synchronised block to a single method call ""sPool.release(this);"". Thus, the type of code change is 1,4,5.","With the removal of the exception being thrown and the reordering of method calls, the program could either behave differently when returning result or handling exceptions. Hence, the Compatibility Issue classification is 1,2."
292,"<android.app.ApplicationPackageManager: void deletePackage(String,IPackageDeleteObserver,int)>",17,18,"<android.app.ApplicationPackageManager: void deletePackage(String,IPackageDeleteObserver,int)>","<android.app.ApplicationPackageManager: void deletePackage(String,IPackageDeleteObserver,int)>",0,"{
    try {
        mPM.deletePackage(packageName, observer, flags);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.deletePackageAsUser(packageName, observer, UserHandle.myUserId(), flags);
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"There has been a change in the dependent API from 'deletePackage()' to 'deletePackageAsUser()', which also involves change in the number of parameters, hence the change type is 5.","Although there is a change in the dependent API, it doesn't lead to a potential change in the output (value or type) or the exception handling. Therefore, no compatibility issue exists as per the given definitions."
293,<android.view.View: void onDrawScrollBars(Canvas)>,17,18,<android.view.View: void onDrawScrollBars(Canvas)>,<android.view.View: void onDrawScrollBars(Canvas)>,0,"{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.setAlpha(255);
        }
        final int viewFlags = mViewFlags;
        final boolean drawHorizontalScrollBar = (viewFlags & SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;
        final boolean drawVerticalScrollBar = (viewFlags & SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final int width = mRight - mLeft;
            final int height = mBottom - mTop;
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final int inside = (viewFlags & SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;
            int left, top, right, bottom;
            if (drawHorizontalScrollBar) {
                int size = scrollBar.getSize(false);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final int verticalScrollBarGap = drawVerticalScrollBar ? getVerticalScrollbarWidth() : 0;
                top = scrollY + height - size - (mUserPaddingBottom & inside);
                left = scrollX + (mPaddingLeft & inside);
                right = scrollX + width - (mUserPaddingRight & inside) - verticalScrollBarGap;
                bottom = top + size;
                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
            if (drawVerticalScrollBar) {
                int size = scrollBar.getSize(true);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                int verticalScrollbarPosition = mVerticalScrollbarPosition;
                if (verticalScrollbarPosition == SCROLLBAR_POSITION_DEFAULT) {
                    verticalScrollbarPosition = isLayoutRtl() ? SCROLLBAR_POSITION_LEFT : SCROLLBAR_POSITION_RIGHT;
                }
                switch(verticalScrollbarPosition) {
                    default:
                    case SCROLLBAR_POSITION_RIGHT:
                        left = scrollX + width - size - (mUserPaddingRight & inside);
                        break;
                    case SCROLLBAR_POSITION_LEFT:
                        left = scrollX + (mUserPaddingLeft & inside);
                        break;
                }
                top = scrollY + (mPaddingTop & inside);
                right = left + size;
                bottom = scrollY + height - (mUserPaddingBottom & inside);
                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
        }
    }
}","{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.setAlpha(255);
        }
        final int viewFlags = mViewFlags;
        final boolean drawHorizontalScrollBar = (viewFlags & SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;
        final boolean drawVerticalScrollBar = (viewFlags & SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final int width = mRight - mLeft;
            final int height = mBottom - mTop;
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final int inside = (viewFlags & SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;
            int left;
            int top;
            int right;
            int bottom;
            if (drawHorizontalScrollBar) {
                int size = scrollBar.getSize(false);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final int verticalScrollBarGap = drawVerticalScrollBar ? getVerticalScrollbarWidth() : 0;
                top = scrollY + height - size - (mUserPaddingBottom & inside);
                left = scrollX + (mPaddingLeft & inside);
                right = scrollX + width - (mUserPaddingRight & inside) - verticalScrollBarGap;
                bottom = top + size;
                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
            if (drawVerticalScrollBar) {
                int size = scrollBar.getSize(true);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                int verticalScrollbarPosition = mVerticalScrollbarPosition;
                if (verticalScrollbarPosition == SCROLLBAR_POSITION_DEFAULT) {
                    verticalScrollbarPosition = isLayoutRtl() ? SCROLLBAR_POSITION_LEFT : SCROLLBAR_POSITION_RIGHT;
                }
                switch(verticalScrollbarPosition) {
                    default:
                    case SCROLLBAR_POSITION_RIGHT:
                        left = scrollX + width - size - (mUserPaddingRight & inside);
                        break;
                    case SCROLLBAR_POSITION_LEFT:
                        left = scrollX + (mUserPaddingLeft & inside);
                        break;
                }
                top = scrollY + (mPaddingTop & inside);
                right = left + size;
                bottom = scrollY + height - (mUserPaddingBottom & inside);
                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
        }
    }
}",1,"/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
","/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change between the API early version and late version.,"As the implementation of the API is same in both versions, no Compatibility Issues exist."
294,"<android.widget.NumberPicker.InputTextFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",17,18,"<android.widget.NumberPicker.InputTextFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>","<android.widget.NumberPicker.InputTextFilter: CharSequence filter(CharSequence,int,int,Spanned,int,int)>",0,"{
    if (mDisplayedValues == null) {
        CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
        if (filtered == null) {
            filtered = source.subSequence(start, end);
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        if ("""".equals(result)) {
            return result;
        }
        int val = getSelectedPos(result);
        /*
                 * Ensure the user can't type in a value greater than the max
                 * allowed. We have to allow less than min as the user might
                 * want to delete some numbers and then type a new number.
                 */
        if (val > mMaxValue) {
            return """";
        } else {
            return filtered;
        }
    } else {
        CharSequence filtered = String.valueOf(source.subSequence(start, end));
        if (TextUtils.isEmpty(filtered)) {
            return """";
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        String str = String.valueOf(result).toLowerCase();
        for (String val : mDisplayedValues) {
            String valLowerCase = val.toLowerCase();
            if (valLowerCase.startsWith(str)) {
                postSetSelectionCommand(result.length(), val.length());
                return val.subSequence(dstart, val.length());
            }
        }
        return """";
    }
}","{
    if (mDisplayedValues == null) {
        CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
        if (filtered == null) {
            filtered = source.subSequence(start, end);
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        if ("""".equals(result)) {
            return result;
        }
        int val = getSelectedPos(result);
        /*
                 * Ensure the user can't type in a value greater than the max
                 * allowed. We have to allow less than min as the user might
                 * want to delete some numbers and then type a new number.
                 * And prevent multiple-""0"" that exceeds the length of upper
                 * bound number.
                 */
        if (val > mMaxValue || result.length() > String.valueOf(mMaxValue).length()) {
            return """";
        } else {
            return filtered;
        }
    } else {
        CharSequence filtered = String.valueOf(source.subSequence(start, end));
        if (TextUtils.isEmpty(filtered)) {
            return """";
        }
        String result = String.valueOf(dest.subSequence(0, dstart)) + filtered + dest.subSequence(dend, dest.length());
        String str = String.valueOf(result).toLowerCase();
        for (String val : mDisplayedValues) {
            String valLowerCase = val.toLowerCase();
            if (valLowerCase.startsWith(str)) {
                postSetSelectionCommand(result.length(), val.length());
                return val.subSequence(dstart, val.length());
            }
        }
        return """";
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"An additional condition statement 'result.length() > String.valueOf(mMaxValue).length()' is inserted inside the 'if' condition, so the code change type is 3.","Due to the additional 'if' condition, now the API could return a different result (""""), thus the CI type is 1."
297,<android.app.Activity: void finish()>,17,18,<android.app.Activity: void finish()>,<android.app.Activity: void finish()>,0,"{
    if (mParent == null) {
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (false)
            Log.v(TAG, ""Finishing self: token="" + mToken);
        try {
            if (resultData != null) {
                resultData.setAllowFds(false);
            }
            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishFromChild(this);
    }
}","{
    if (mParent == null) {
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (false)
            Log.v(TAG, ""Finishing self: token="" + mToken);
        try {
            if (resultData != null) {
                resultData.prepareToLeaveProcess();
            }
            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishFromChild(this);
    }
}",1,"/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */
","/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called on the object 'resultData' has changed from 'setAllowFds(false)' to 'prepareToLeaveProcess()', which does not change control flow but is a minor alteration in method execution, thus the change type is 4 and 5.","There is no Compatibility Issue detected. The change in method invocation on the 'resultData' object does not alter the flow control or exception handling. This change does not lead to a different return value or exception. Hence, CI type is 0."
298,<android.os.Environment: File getRootDirectory()>,17,18,<android.os.Environment: File getRootDirectory()>,<android.os.Environment: File getRootDirectory()>,0,"{
    return ROOT_DIRECTORY;
}","{
    return DIR_ANDROID_ROOT;
}",1,"/**
 * Gets the Android root directory.
 */
","/**
 * Gets the Android root directory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning ROOT_DIRECTORY to returning DIR_ANDROID_ROOT, which falls under change type 1.","The change of the return statement can result in the API potentially returning a different value. Thus, the CI type is 1."
299,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)>",17,18,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, AppOpsManager.OP_NONE, true, false, user.getIdentifier());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is on the statement 'intent.setAllowFds(false);', replaced by 'intent.prepareToLeaveProcess();' and another statement 'ActivityManagerNative.getDefault().broadcastIntent(..., true, false, user.getIdentifier())' in which parameter is replaced from 'true' to 'AppOpsManager.OP_NONE'. So the change type is 4,5 as it's another statement changes and method 'setAllowFds' and 'broadcastIntent' has undergone changes.","There's no compatibility issue regarding the change as 'intent.prepareToLeaveProcess();' also setAllowFds to false, and parameter replacing 'true' to 'AppOpsManager.OP_NONE' also results in the same behavior because AppOpsManager.OP_NONE is a constant that actually equals to -1 which means permission check not needed (e.g., 'true')."
300,<android.bluetooth.BluetoothSocket: void connect()>,17,18,<android.bluetooth.BluetoothSocket: void connect()>,<android.bluetooth.BluetoothSocket: void connect()>,0,"{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        // TODO(BT) derive flag from auth and encrypt
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
    }
}","{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
    }
}",1,"/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
","/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,No code change is observed from the early version to the late version of the API.,"Since there are no changes in the code, it indicates there is no compatibility issue between these two versions."
301,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,17,18,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,<android.view.ViewGroup.MarginLayoutParams: void resolveLayoutDirection(int)>,0,"{
    setLayoutDirection(layoutDirection);
    if (!isMarginRelative())
        return;
    switch(layoutDirection) {
        case View.LAYOUT_DIRECTION_RTL:
            leftMargin = (endMargin > DEFAULT_RELATIVE) ? endMargin : initialLeftMargin;
            rightMargin = (startMargin > DEFAULT_RELATIVE) ? startMargin : initialRightMargin;
            break;
        case View.LAYOUT_DIRECTION_LTR:
        default:
            leftMargin = (startMargin > DEFAULT_RELATIVE) ? startMargin : initialLeftMargin;
            rightMargin = (endMargin > DEFAULT_RELATIVE) ? endMargin : initialRightMargin;
            break;
    }
}","{
    setLayoutDirection(layoutDirection);
    // Will use the left and right margins if no relative margin is defined.
    if (!isMarginRelative() || (mMarginFlags & NEED_RESOLUTION_MASK) != NEED_RESOLUTION_MASK)
        return;
    // Proceed with resolution
    doResolveMargins();
}",1,"/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
","/**
 * This will be called by {@link android.view.View#requestLayout()}. Left and Right margins
 * may be overridden depending on layout direction.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The 'resolveLayoutDirection(int)' method's implementation has changed significantly. In early version, there is a switch-case statement, whereas in the late version, this switch-case statement has been replaced by an if statement and an invocation to 'doResolveMargins()'. As per the change specifics, this is a control dependency change (switch-case to if), return statement changed (due to new if condition introduced), and other statements changed (doResolveMargins() method introduced). So the change type is 1,3,4.","The late version of the method has a different control flow with a new condition checking statement that could cause an early return of the method, which means the method could potentially have different behaviour. Therefore, the API has potential different return values or types, classifying it as CI type 1."
302,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>",17,18,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>","<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>",0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = mMetrics.densityDpi;
            } else {
                value.density = (value.density * mMetrics.densityDpi) / density;
            }
        }
        return loadDrawable(value, id);
    }
}","{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = mMetrics.densityDpi;
            } else {
                value.density = (value.density * mMetrics.densityDpi) / density;
            }
        }
    }
    Drawable res = loadDrawable(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}",1,"/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI. This will set the drawable's density to be
 * the device's density multiplied by the ratio of actual drawable density
 * to requested density. This allows the drawable to be scaled up to the
 * correct size if needed. Various types of objects will be returned
 * depending on the underlying resource -- for example, a solid color, PNG
 * image, scalable image, etc. The Drawable API hides these implementation
 * details.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density the desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @return Drawable An object that can be used to draw this resource.
 */
","/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI. This will set the drawable's density to be
 * the device's density multiplied by the ratio of actual drawable density
 * to requested density. This allows the drawable to be scaled up to the
 * correct size if needed. Various types of objects will be returned
 * depending on the underlying resource -- for example, a solid color, PNG
 * image, scalable image, etc. The Drawable API hides these implementation
 * details.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density the desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @return Drawable An object that can be used to draw this resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The synchronized block has been refactored to add a new condition to check if the value is null, and a statement has been added to recycle the 'value' object after it's used outside the synchronized block. Thus, the code change type is 3 and 4.","The modification of adding a null check and recycling 'value' won't affect the output of the API. It is only responsible for resource allocation and recycling, neither the return value nor the exception handling has changed. So, no Compatibility Issue exists here."
303,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,17,18,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,0,"{
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        return sService.allocateAppWidgetId(mPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        return sService.allocateAppWidgetId(mPackageName, mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
","/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from sService.allocateAppWidgetId(mPackageName, mHostId) to sService.allocateAppWidgetId(mPackageName, mHostId, mContext.getUserId()), and the parameters passed into the method allocateAppWidgetId() also changed, so the code change type is 1,5.","The change occurred in the parameter, which may lead to return a different value by the dependent API, hence the Compatibility Issue type is 1."
304,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,17,18,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,<android.appwidget.AppWidgetManager: int[] getAppWidgetIds(ComponentName)>,0,"{
    try {
        return sService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        return sService.getAppWidgetIds(provider, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */
","/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API sService.getAppWidgetIds() has a change in the parameters, which upgrades from provider to provider, mContext.getUserId(). Therefore, the change type is 1,5.","Due to the modification of the dependent API's parameters, the return value might be different, leading to potential compatibility issue of type 1."
305,<android.widget.TextView: boolean hasOverlappingRendering()>,17,18,<android.widget.TextView: boolean hasOverlappingRendering()>,<android.widget.TextView: boolean hasOverlappingRendering()>,0,"{
    return (getBackground() != null || mText instanceof Spannable || hasSelection());
}","{
    return ((getBackground() != null && getBackground().getCurrent() != null) || mText instanceof Spannable || hasSelection());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition in the return statement has changed, specifically, an additional condition (getBackground().getCurrent() != null) has been added to the original condition, so the code change type is 3.","As the condition in the return statement has changed, this could potentially lead to different return values, thus the CI type is 1."
306,"<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>",17,18,"<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    Class klass = view.getClass();
    Method method;
    try {
        method = klass.getMethod(this.methodName, getParameterType());
    } catch (NoSuchMethodException ex) {
        throw new ActionException(""view: "" + klass.getName() + "" doesn't have method: "" + this.methodName + ""("" + param.getName() + "")"");
    }
    if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""view: "" + klass.getName() + "" can't use method with RemoteViews: "" + this.methodName + ""("" + param.getName() + "")"");
    }
    try {
        // noinspection ConstantIfStatement
        if (false) {
            Log.d(""RemoteViews"", ""view: "" + klass.getName() + "" calling method: "" + this.methodName + ""("" + param.getName() + "") with "" + (this.value == null ? ""null"" : this.value.getClass().getName()));
        }
        method.invoke(view, this.value);
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}","{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    Class klass = view.getClass();
    Method method;
    try {
        method = klass.getMethod(this.methodName, getParameterType());
    } catch (NoSuchMethodException ex) {
        throw new ActionException(""view: "" + klass.getName() + "" doesn't have method: "" + this.methodName + ""("" + param.getName() + "")"");
    }
    if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""view: "" + klass.getName() + "" can't use method with RemoteViews: "" + this.methodName + ""("" + param.getName() + "")"");
    }
    try {
        // noinspection ConstantIfStatement
        if (false) {
            Log.d(LOG_TAG, ""view: "" + klass.getName() + "" calling method: "" + this.methodName + ""("" + param.getName() + "") with "" + (this.value == null ? ""null"" : this.value.getClass().getName()));
        }
        method.invoke(view, this.value);
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only a constant string ""RemoteViews"" in the Log.d() function has been replaced by another constant LOG_TAG. Therefore, the code change type is 4 (Other statement changed).","This change is not causing any differences in the behavior of the API. Neither the potential returned values/types nor the potential exception handling is affected by this change. So, no Compatibility Issue exists, and the CI type is 0."
307,<android.view.ViewGroup.ChildListForAccessibility: void recycle()>,17,18,<android.view.ViewGroup.ChildListForAccessibility: void recycle()>,<android.view.ViewGroup.ChildListForAccessibility: void recycle()>,0,"{
    if (mIsPooled) {
        throw new IllegalStateException(""Instance already recycled."");
    }
    clear();
    synchronized (sPoolLock) {
        if (sPoolSize < MAX_POOL_SIZE) {
            mNext = sPool;
            mIsPooled = true;
            sPool = this;
            sPoolSize++;
        }
    }
}","{
    clear();
    sPool.release(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the early version, there is a conditional 'if' statement with a 'throw' statement inside, but in the late version, this is replaced by the single line 'sPool.release(this)'. Therefore, the change involves the removal of the 'throw' statement (change type 1) and the modification of other statements (change type 4).","Since the exception handling statement has been removed in the late version, the behavior of the method has been altered. If the early version would throw an Exception, the late version wouldn't, which results in potential different behaviours. Therefore, this is classified as a compatibility issue of type 1, caused by potentially different return values or types."
309,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",17,18,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, true, user.getIdentifier());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"In the two versions, the method that the Intent object calls has changed from setAllowFds(false), to prepareToLeaveProcess(). Therefore, the code change type is 1.","The method call on the Intent object has changed. This could potentially alter the behavior of the sendStickyBroadcastAsUser API and cause it to return different results/behaviors, so the CI type is 1."
310,<android.view.View: void requestLayout()>,17,18,<android.view.View: void requestLayout()>,<android.view.View: void requestLayout()>,0,"{
    mPrivateFlags |= PFLAG_FORCE_LAYOUT;
    mPrivateFlags |= PFLAG_INVALIDATED;
    if (mParent != null && !mParent.isLayoutRequested()) {
        mParent.requestLayout();
    }
}","{
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {
        // Only trigger request-during-layout logic if this is the view requesting it,
        // not the views in its parent hierarchy
        ViewRootImpl viewRoot = getViewRootImpl();
        if (viewRoot != null && viewRoot.isInLayout()) {
            if (!viewRoot.requestLayoutDuringLayout(this)) {
                return;
            }
        }
        mAttachInfo.mViewRequestingLayout = this;
    }
    mPrivateFlags |= PFLAG_FORCE_LAYOUT;
    mPrivateFlags |= PFLAG_INVALIDATED;
    if (mParent != null && !mParent.isLayoutRequested()) {
        mParent.requestLayout();
    }
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {
        mAttachInfo.mViewRequestingLayout = null;
    }
}",1,"/**
 * Call this when something has changed which has invalidated the
 * layout of this view. This will schedule a layout pass of the view
 * tree.
 */
","/**
 * Call this when something has changed which has invalidated the
 * layout of this view. This will schedule a layout pass of the view
 * tree. This should not be called while the view hierarchy is currently in a layout
 * pass ({@link #isInLayout()}. If layout is happening, the request may be honored at the
 * end of the current layout pass (and then layout will run again) or after the current
 * frame is drawn and the next layout occurs.
 *
 * <p>Subclasses which override this method should call the superclass method to
 * handle possible request-during-layout errors correctly.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version of ""requestLayout()"", there have been some changes made adding a new if-else condition and manipulation with mAttachInfo, which are not present in the early version. Addtitional control statements were added and other statements changed, therefore the code change type is 1,3,4.","This change may cause a difference in behavoir as there is a new return statement inside the if-else condition, which could stop the function early, causing the API to potentially return differently depending on the version. Therefore, the CI type is 1."
312,<android.view.accessibility.AccessibilityNodeInfo: boolean isCheckable()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isCheckable()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isCheckable()>,0,"{
    return getBooleanProperty(PROPERTY_CHECKABLE);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_CHECKABLE);
}",1,"/**
 * Gets whether this node is checkable.
 *
 * @return True if the node is checkable.
 */
","/**
 * Gets whether this node is checkable.
 *
 * @return True if the node is checkable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method parameter for getBooleanProperty() function has changed. So, the code change type is 1,5.","The change of the method parameter in getBooleanProperty() means the API can potentially return a different boolean value, therefore the CI type is 1."
314,<android.speech.tts.TextToSpeech: Locale getLanguage()>,17,18,<android.speech.tts.TextToSpeech: Locale getLanguage()>,<android.speech.tts.TextToSpeech: Locale getLanguage()>,0,"{
    return runAction(new Action<Locale>() {

        @Override
        public Locale run(ITextToSpeechService service) throws RemoteException {
            String[] locStrings = service.getLanguage();
            if (locStrings != null && locStrings.length == 3) {
                return new Locale(locStrings[0], locStrings[1], locStrings[2]);
            }
            return null;
        }
    }, null, ""getLanguage"");
}","{
    return runAction(new Action<Locale>() {

        @Override
        public Locale run(ITextToSpeechService service) {
            /* No service call, but we're accessing mParams, hence need for
                   wrapping it as an Action instance */
            String lang = mParams.getString(Engine.KEY_PARAM_LANGUAGE, """");
            String country = mParams.getString(Engine.KEY_PARAM_COUNTRY, """");
            String variant = mParams.getString(Engine.KEY_PARAM_VARIANT, """");
            return new Locale(lang, country, variant);
        }
    }, null, ""getLanguage"");
}",1,"/**
 * Returns a Locale instance describing the language currently being used by the TextToSpeech
 * engine.
 *
 * @return language, country (if any) and variant (if any) used by the engine stored in a Locale
 * instance, or {@code null} on error.
 */
","/**
 * Returns a Locale instance describing the language currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * In Android 4.2 and before (API <= 17) this function returns the language that is currently
 * being used by the TTS engine. That is the last language set by this or any other
 * client by a {@link TextToSpeech#setLanguage} call to the same engine.
 *
 * In Android versions after 4.2 this function returns the language that is currently being
 * used for the synthesis requests sent from this client. That is the last language set
 * by a {@link TextToSpeech#setLanguage} call on this instance.
 *
 * @return language, country (if any) and variant (if any) used by the client stored in a
 * Locale instance, or {@code null} on error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement in 'run' method has been changed. Now it does not rely on the return of 'service.getLanguage()', but makes use of class members 'mParams', so the code change type is 1,4.","As the information used to create the returned Locale object has changed, this can potentially cause different Locale objects to be returned. So, the CI type is 1."
315,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,17,18,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,<android.content.AsyncTaskLoader.LoadTask: D doInBackground(Void)>,0,"{
    if (DEBUG)
        Slog.v(TAG, this + "" >>> doInBackground"");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground"");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground (was canceled)"");
        return null;
    }
}","{
    if (DEBUG)
        Slog.v(TAG, this + "" >>> doInBackground"");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground"");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Slog.v(TAG, this + ""  <<< doInBackground (was canceled)"", ex);
        return null;
    }
}",1,"/* Runs on a worker thread */
","/* Runs on a worker thread */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only the log statement (i.e., Slog.v(TAG, this + ""  <<< doInBackground (was canceled)"", ex);) has changed, this does not have an impact on the program's behaviour. Thus, the code change type is classified as 4. ","The change is only in the logs, it does not impact how the method behaves, it doesn't lead to a different return value or exceptions. Thus, no compatibility issue exists, thus it is a 0 CI type."
316,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,17,18,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,<android.accounts.AccountManager.GetAuthTokenByTypeAndFeaturesTask: void doWork()>,0,"{
    getAccountsByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Account[]>() {

        public void run(AccountManagerFuture<Account[]> future) {
            Account[] accounts;
            try {
                accounts = future.getResult();
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            mNumAccounts = accounts.length;
            if (accounts.length == 0) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else if (accounts.length == 1) {
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            } else {
                if (mActivity != null) {
                    IAccountManagerResponse chooseResponse = new IAccountManagerResponse.Stub() {

                        public void onResult(Bundle value) throws RemoteException {
                            Account account = new Account(value.getString(KEY_ACCOUNT_NAME), value.getString(KEY_ACCOUNT_TYPE));
                            mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                        }

                        public void onError(int errorCode, String errorMessage) throws RemoteException {
                            mResponse.onError(errorCode, errorMessage);
                        }
                    };
                    // have many accounts, launch the chooser
                    Intent intent = new Intent();
                    intent.setClassName(""android"", ""android.accounts.ChooseAccountActivity"");
                    intent.putExtra(KEY_ACCOUNTS, accounts);
                    intent.putExtra(KEY_ACCOUNT_MANAGER_RESPONSE, new AccountManagerResponse(chooseResponse));
                    mActivity.startActivity(intent);
                // the result will arrive via the IAccountManagerResponse
                } else {
                    // send result since we can't prompt to select an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNTS, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            }
        }
    }, mHandler);
}","{
    getAccountsByTypeAndFeatures(mAccountType, mFeatures, new AccountManagerCallback<Account[]>() {

        public void run(AccountManagerFuture<Account[]> future) {
            Account[] accounts;
            try {
                accounts = future.getResult();
            } catch (OperationCanceledException e) {
                setException(e);
                return;
            } catch (IOException e) {
                setException(e);
                return;
            } catch (AuthenticatorException e) {
                setException(e);
                return;
            }
            mNumAccounts = accounts.length;
            if (accounts.length == 0) {
                if (mActivity != null) {
                    // no accounts, add one now. pretend that the user directly
                    // made this request
                    mFuture = addAccount(mAccountType, mAuthTokenType, mFeatures, mAddAccountOptions, mActivity, mMyCallback, mHandler);
                } else {
                    // send result since we can't prompt to add an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNT_NAME, null);
                    result.putString(KEY_ACCOUNT_TYPE, null);
                    result.putString(KEY_AUTHTOKEN, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            } else if (accounts.length == 1) {
                // have a single account, return an authtoken for it
                if (mActivity == null) {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, false, /* notifyAuthFailure */
                    mMyCallback, mHandler);
                } else {
                    mFuture = getAuthToken(accounts[0], mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                }
            } else {
                if (mActivity != null) {
                    IAccountManagerResponse chooseResponse = new IAccountManagerResponse.Stub() {

                        public void onResult(Bundle value) throws RemoteException {
                            Account account = new Account(value.getString(KEY_ACCOUNT_NAME), value.getString(KEY_ACCOUNT_TYPE));
                            mFuture = getAuthToken(account, mAuthTokenType, mLoginOptions, mActivity, mMyCallback, mHandler);
                        }

                        public void onError(int errorCode, String errorMessage) throws RemoteException {
                            mResponse.onError(errorCode, errorMessage);
                        }
                    };
                    // have many accounts, launch the chooser
                    Intent intent = new Intent();
                    ComponentName componentName = ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseAccountActivity));
                    intent.setClassName(componentName.getPackageName(), componentName.getClassName());
                    intent.putExtra(KEY_ACCOUNTS, accounts);
                    intent.putExtra(KEY_ACCOUNT_MANAGER_RESPONSE, new AccountManagerResponse(chooseResponse));
                    mActivity.startActivity(intent);
                // the result will arrive via the IAccountManagerResponse
                } else {
                    // send result since we can't prompt to select an account
                    Bundle result = new Bundle();
                    result.putString(KEY_ACCOUNTS, null);
                    try {
                        mResponse.onResult(result);
                    } catch (RemoteException e) {
                    // this will never happen
                    }
                // we are done
                }
            }
        }
    }, mHandler);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The code has changed in the following command 'intent.setClassName(""android"",""android.accounts.ChooseAccountActivity"")' to 'intent.setClassName(componentName.getPackageName(), componentName.getClassName())' where a new API 'ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseAccountActivity))' has been introduced and used, so the code change type is 4,5.","The changing of the way that the 'componentName' is set means that the variable could potentially have a different value, hence, the activities launched could be essentially different, thus the CI type is 1."
317,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",17,18,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
    }
}","{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"Two case statements (BluetoothProfile.GATT and BluetoothProfile.GATT_SERVER) have been added to the switch block involving different class types of proxies (BluetoothGatt and BluetoothGattServer respectively) and calling close() on them. Therefore, the code change type is 3.","The added case statements imply that, for the same inputs, we might have different effects (execution paths) in the latest version of the API. This is because the proxy now could also be of type BluetoothGatt or BluetoothGattServer, which can lead to different operations (calling close() on BluetoothGatt or BluetoothGattServer instead of earlier types). Thus, the CI type is 1."
318,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,17,18,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket();
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket();
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}",1,"/**
 * Creates a new socket which is not connected to any remote host.
 * You must use {@link Socket#connect} to connect the socket.
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * Creates a new socket which is not connected to any remote host.
 * You must use {@link Socket#connect} to connect the socket.
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,0,"A new setter method s.setChannelIdPrivateKey(mChannelIdPrivateKey); is added in the late version, which can be regarded as a change in the return statement since it modifies the object to be returned, so the change type is 1.","Although there is a change in the return statement, this addition doesn't affect the type or value of the return object directly but only adds more information to the returned object s. Therefore, it does not cause a compatibility issue. CI type is 0."
319,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,17,18,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,0,"{
    try {
        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId, mContext.getUserId());
        if (info != null) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
","/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent method sService.getAppWidgetInfo in the method has more parameters in the late version, making the 'Dependent API changed'. Besides, the returned AppWidgetProviderInfo object may have different properties since the 'appWidgetId' parameter used for initializing has been changed. Therefore, the code change types are 1 and 5.","The change of 'appWidgetId' in sService.getAppWidgetInfo can potentially result in returning a different value or type since the returned object will be initialized differently. Thus, the CI type is 1."
320,<android.os.Bundle: String getString(String)>,17,18,<android.os.Bundle: String getString(String)>,<android.os.Bundle: String getString(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (String) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""String"", e);
        return null;
    }
}","{
    unparcel();
    final Object o = mMap.get(key);
    try {
        return (String) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""String"", e);
        return null;
    }
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a String value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a String value, or null
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the declaration of variable o, where it has been changed from non-final to final. This constitutes a change in other statement types, hence the code change type is 4.","The change from non-final to final for variable o doesn't mean the API will return a different value or throw a different exception, so it does not cause a compatibility issue. Hence, the CI type is 0."
321,<android.view.View: boolean fitSystemWindows(Rect)>,17,18,<android.view.View: boolean fitSystemWindows(Rect)>,<android.view.View: boolean fitSystemWindows(Rect)>,0,"{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = UNDEFINED_PADDING;
        mUserPaddingEnd = UNDEFINED_PADDING;
        if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || (mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0) {
            internalSetPadding(insets.left, insets.top, insets.right, insets.bottom);
            return true;
        } else {
            internalSetPadding(0, 0, 0, 0);
            return false;
        }
    }
    return false;
}","{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = UNDEFINED_PADDING;
        mUserPaddingEnd = UNDEFINED_PADDING;
        Rect localInsets = sThreadLocal.get();
        if (localInsets == null) {
            localInsets = new Rect();
            sThreadLocal.set(localInsets);
        }
        boolean res = computeFitSystemWindows(insets, localInsets);
        internalSetPadding(localInsets.left, localInsets.top, localInsets.right, localInsets.bottom);
        return res;
    }
    return false;
}",1,"/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * inset's to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return Return true if this view applied the insets and it should not
 * continue propagating further down the hierarchy, false otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 */
","/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * inset's to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return Return true if this view applied the insets and it should not
 * continue propagating further down the hierarchy, false otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control structure 'if' has been modified and some part of the codes including the return statement are deleted and replaced with new different implementations. Therefore the code change type is 1,3,4.","As the 'return' statement inside the 'if' block changes, it would potentially make the API return a different value. So the CI type is 1."
322,<android.widget.AbsListView.RecycleBin: View getTransientStateView(int)>,17,18,<android.widget.AbsListView.RecycleBin: View getTransientStateView(int)>,<android.widget.AbsListView.RecycleBin: View getTransientStateView(int)>,0,"{
    if (mTransientStateViews == null) {
        return null;
    }
    final int index = mTransientStateViews.indexOfKey(position);
    if (index < 0) {
        return null;
    }
    final View result = mTransientStateViews.valueAt(index);
    mTransientStateViews.removeAt(index);
    return result;
}","{
    if (mAdapter != null && mAdapterHasStableIds && mTransientStateViewsById != null) {
        long id = mAdapter.getItemId(position);
        View result = mTransientStateViewsById.get(id);
        mTransientStateViewsById.remove(id);
        return result;
    }
    if (mTransientStateViews != null) {
        final int index = mTransientStateViews.indexOfKey(position);
        if (index >= 0) {
            View result = mTransientStateViews.valueAt(index);
            mTransientStateViews.removeAt(index);
            return result;
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Major changes are introduced including the addition of new condition 'if (mAdapter != null && mAdapterHasStableIds && mTransientStateViewsById != null)' with the return statement within it and the alteration of the condition in existing if statement. So, the code change type is 1,3.","The introduction of a new 'if' condition statement where the return statement of getTransientStateView(int) method is based could lead to different return values, hence CI type is 1."
325,<android.net.CaptivePortalTracker.DelayedCaptiveCheckState: boolean processMessage(Message)>,17,18,<android.net.CaptivePortalTracker.DelayedCaptiveCheckState: boolean processMessage(Message)>,<android.net.CaptivePortalTracker.DelayedCaptiveCheckState: boolean processMessage(Message)>,0,"{
    if (DBG)
        log(getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_DELAYED_CAPTIVE_CHECK:
            if (message.arg1 == mDelayedCheckToken) {
                InetAddress server = lookupHost(mServer);
                if (server != null) {
                    if (isCaptivePortal(server)) {
                        if (DBG)
                            log(""Captive network "" + mNetworkInfo);
                        setNotificationVisible(true);
                    }
                }
                if (DBG)
                    log(""Not captive network "" + mNetworkInfo);
                transitionTo(mActiveNetworkState);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    if (DBG)
        log(getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_DELAYED_CAPTIVE_CHECK:
            if (message.arg1 == mDelayedCheckToken) {
                InetAddress server = lookupHost(mServer);
                boolean captive = server != null && isCaptivePortal(server);
                if (captive) {
                    if (DBG)
                        log(""Captive network "" + mNetworkInfo);
                } else {
                    if (DBG)
                        log(""Not captive network "" + mNetworkInfo);
                }
                if (mDeviceProvisioned) {
                    if (captive) {
                        // Setup Wizard will assist the user in connecting to a captive
                        // portal, so make the notification visible unless during setup
                        setNotificationVisible(true);
                    }
                } else {
                    Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_TEST_COMPLETED);
                    intent.putExtra(ConnectivityManager.EXTRA_IS_CAPTIVE_PORTAL, captive);
                    intent.setPackage(SETUP_WIZARD_PACKAGE);
                    mContext.sendBroadcast(intent);
                }
                transitionTo(mActiveNetworkState);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There is a control dependency change in the if-else statements responsible for evaluating 'captive' within the case CMD_DELAYED_CAPTIVE_CHECK. Other statement changes include adding a check for 'mDeviceProvisioned' and broadcasting an intent. So the code change falls in categories 3,4.","Checking 'mDeviceProvisioned' and broadcasting of an intent are new behaviours introduced in the late version. These changes influence the processing of messages which might lead to different return values. Thus, the CI type is 1."
328,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",17,18,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>","<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",0,"{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger QuickContact
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, lookupUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        getContext().startActivity(intent);
    }
}","{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    Bundle extras = (cookie != null) ? (Bundle) cookie : new Bundle();
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger QuickContact
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, lookupUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        if (extras != null) {
            extras.remove(EXTRA_URI_CONTENT);
            intent.putExtras(extras);
        }
        getContext().startActivity(intent);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are several changes happened between two versions: 1) The method used to extract data from `cookie` changed and `extras` variable is introduced; 2) Several function callings have changed parameters or added new parameters; 3) A new control flow statement introduced in the final 'else if'. Therefore, code change type is 1,3,4.","Considering the parameter change in function calling and different control flow, as well as the type change in the `cookie`, the API could potentially return different variable or invoke different methods. Therefore, CI type is 1."
330,<android.view.accessibility.AccessibilityNodeInfo: boolean isScrollable()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isScrollable()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isScrollable()>,0,"{
    return getBooleanProperty(PROPERTY_SCROLLABLE);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_SCROLLABLE);
}",1,"/**
 * Gets if the node is scrollable.
 *
 * @return True if the node is scrollable, false otherwise.
 */
","/**
 * Gets if the node is scrollable.
 *
 * @return True if the node is scrollable, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getBooleanProperty(PROPERTY_SCROLLABLE) to getBooleanProperty(BOOLEAN_PROPERTY_SCROLLABLE) and the parameter of getBooleanProperty() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
332,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",17,18,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",0,"{
    try {
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        mgr.unbindRemoteViewsService(appWidgetId, intent);
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RemoteViewsAdapterServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}","{
    try {
        RemoteViewsAdapter adapter;
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if (Process.myUid() == Process.SYSTEM_UID && (adapter = mAdapter.get()) != null) {
            mgr.unbindRemoteViewsService(appWidgetId, intent, new UserHandle(adapter.mUserId));
        } else {
            mgr.unbindRemoteViewsService(appWidgetId, intent, Process.myUserHandle());
        }
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RemoteViewsAdapterServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"In the newer version, the `mgr.unbindRemoteViewsService()` method is provided with additional parameter `new UserHandle(adapter.mUserId)` or `Process.myUserHandle()`. This indicates changes in control dependency (3) and dependent API (5).","Even though the dependent API was changed, it is unlikely to affect the return value or exceptions thrown by the given API as both early and late versions don't contain return and exception statements, thus no compatibility issue (0) is implied."
333,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,17,18,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,0,"{
    if (mInputMethodSession == null)
        return;
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_DISPATCH_KEY_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.dispatchKeyEvent(msg.arg1, (KeyEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_DISPATCH_TRACKBALL_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.dispatchTrackballEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_DISPATCH_GENERIC_MOTION_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.dispatchGenericMotionEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                mInputMethodSession = null;
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null) {
        // The session has been finished.
        return;
    }
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,0,Several cases in the switch statement have been removed in the late version.,"The removal of these cases does not change the behaviour of the API as the switch case statement only consists of internal logic and does not impact the return values or thrown exceptions. Therefore, there is no compatibility issue in this change."
335,"<android.app.ActivityManagerProxy: boolean killPids(int[],String,boolean)>",17,18,"<android.app.ActivityManagerProxy: boolean killPids(int[],String,boolean)>","<android.app.ActivityManagerProxy: boolean killPids(int[],String,boolean)>",0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeIntArray(pids);
    data.writeString(reason);
    data.writeInt(secure ? 1 : 0);
    mRemote.transact(KILL_PIDS_TRANSACTION, data, reply, 0);
    boolean res = reply.readInt() != 0;
    data.recycle();
    reply.recycle();
    return res;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeIntArray(pids);
    data.writeString(reason);
    data.writeInt(secure ? 1 : 0);
    mRemote.transact(KILL_PIDS_TRANSACTION, data, reply, 0);
    reply.readException();
    boolean res = reply.readInt() != 0;
    data.recycle();
    reply.recycle();
    return res;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement 'reply.readException()' was added in the late version compared to the early one. This change indicate that another type of returned object (exception) from the 'mRemote.transact()' will be read, so the code change is of type 4.","Even though a new instruction is introduced to read exceptions, it can't contribute to a different result from the function itself, because there's no exception thrown and the return values are not affected by the new statement. Hence, it is deemed that no compatibility issue exists."
337,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",17,18,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",0,"{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        try {
            fd = unstableProvider.openTypedAssetFile(uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}","{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent method 'openTypedAssetFile()' has changed. In the early version it takes 3 parameters, while in the late version it takes 4 parameters, so the code change type is 1,5.","The change in method 'openTypedAssetFile()' affects the return statement, hence potentially returning a different value in the late version. Therefore, the CI type is 1."
338,<android.view.View: void buildDrawingCache(boolean)>,17,18,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
            if (mOverlay != null && !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().draw(canvas);
            }
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The 'if' condition statement '(mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW' has been expanded in the later implementation, so the code change type is 3.","As the code change in the 'if' condition statement and addition of the new draw operation 'mOverlay.getOverlayView().draw(canvas)', the API could potentially return a different result when invoked. Therefore, the CI type is 1."
339,<android.content.Loader: boolean takeContentChanged()>,17,18,<android.content.Loader: boolean takeContentChanged()>,<android.content.Loader: boolean takeContentChanged()>,0,"{
    boolean res = mContentChanged;
    mContentChanged = false;
    return res;
}","{
    boolean res = mContentChanged;
    mContentChanged = false;
    mProcessingChange |= res;
    return res;
}",1,"/**
 * Take the current flag indicating whether the loader's content had
 * changed while it was stopped.  If it had, true is returned and the
 * flag is cleared.
 */
","/**
 * Take the current flag indicating whether the loader's content had
 * changed while it was stopped.  If it had, true is returned and the
 * flag is cleared.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new variable assignment (mProcessingChange |= res;) has been added, which falls into the category of 'other statement changed' but does not affect the return values or exceptions.","The added assignment does not influence the outcome of the API's implementation. It will not cause different return values or exceptions between the two versions, so the Compatibility Issue does not exist."
341,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",17,18,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>","<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",0,"{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider, null, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
","/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The 'bindAppWidgetIdIfAllowed' method of 'sService' that is called within the try block has an additional parameter 'mContext.getUserId()' in its late implementation. Hence, the code categories are 1 and 5.","The change in 'sService.bindAppWidgetIdIfAllowed()' method's parameters can lead to different return value. Therefore, the Compatibility Issue type is 1."
343,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",17,18,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>","<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",0,"{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate;
    if (timeZone != null) {
        startDate = new Time(timeZone);
    } else if (useUTC) {
        startDate = new Time(Time.TIMEZONE_UTC);
    } else {
        startDate = new Time();
    }
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endDate = new Time(timeZone);
        } else if (useUTC) {
            endDate = new Time(Time.TIMEZONE_UTC);
        } else {
            endDate = new Time();
        }
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    String startStandaloneMonthString = startMonthString;
    String endStandaloneMonthString = endMonthString;
    // We need standalone months for these strings in Persian (fa): http://b/6811327
    if (!numericDate && !abbrevMonth && Locale.getDefault().getLanguage().equals(""fa"")) {
        startStandaloneMonthString = startDate.format(""%-B"");
        endStandaloneMonthString = endDate.format(""%-B"");
    }
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}","{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Calendar startCalendar, endCalendar;
    Time startDate = new Time();
    if (timeZone != null) {
        startCalendar = Calendar.getInstance(TimeZone.getTimeZone(timeZone));
    } else if (useUTC) {
        startCalendar = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
    } else {
        startCalendar = Calendar.getInstance();
    }
    startCalendar.setTimeInMillis(startMillis);
    setTimeFromCalendar(startDate, startCalendar);
    Time endDate = new Time();
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endCalendar = Calendar.getInstance(TimeZone.getTimeZone(timeZone));
        } else if (useUTC) {
            endCalendar = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        } else {
            endCalendar = Calendar.getInstance();
        }
        endCalendar.setTimeInMillis(endMillis);
        setTimeFromCalendar(endDate, endCalendar);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    String startStandaloneMonthString = startMonthString;
    String endStandaloneMonthString = endMonthString;
    // We need standalone months for these strings in Persian (fa): http://b/6811327
    if (!numericDate && !abbrevMonth && Locale.getDefault().getLanguage().equals(""fa"")) {
        startStandaloneMonthString = startDate.format(""%-B"");
        endStandaloneMonthString = endDate.format(""%-B"");
    }
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}",1,"/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * <p>
 * If the end date ends at 12:00am at the beginning of a day, it is
 * formatted as the end of the previous day in two scenarios:
 * <ul>
 * <li>For single day events. This results in ""8pm - midnight"" instead of
 * ""Nov 10, 8pm - Nov 11, 12am"".</li>
 * <li>When the time is not displayed. This results in ""Nov 10 - 11"" for
 * an event with a start date of Nov 10 and an end date of Nov 12 at
 * 00:00.</li>
 * </ul>
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
","/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * <p>
 * If the end date ends at 12:00am at the beginning of a day, it is
 * formatted as the end of the previous day in two scenarios:
 * <ul>
 * <li>For single day events. This results in ""8pm - midnight"" instead of
 * ""Nov 10, 8pm - Nov 11, 12am"".</li>
 * <li>When the time is not displayed. This results in ""Nov 10 - 11"" for
 * an event with a start date of Nov 10 and an end date of Nov 12 at
 * 00:00.</li>
 * </ul>
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
344,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",17,18,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>","<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,int)>",0,"{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        IContentProvider cp = lazyGetProvider(cr);
        cp.call(mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}","{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        IContentProvider cp = lazyGetProvider(cr);
        cp.call(cr.getPackageName(), mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The call method of IContentProvider has changed. The parameter in function call 'cp.call()' has changed, so the code change type is 4,5.","Despite the code change in the method 'call()' of IContentProvider, it does not affect the return value nor the exception handling of the API. Thus, we can conclude no compatibility issue exist with the API, so the CI type is 0."
345,<android.content.res.Configuration: int getLayoutDirection()>,17,18,<android.content.res.Configuration: int getLayoutDirection()>,<android.content.res.Configuration: int getLayoutDirection()>,0,"{
    // having LRT set to ""1"" and RTL set to ""2""
    return ((screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) >> SCREENLAYOUT_LAYOUTDIR_SHIFT) - 1;
}","{
    return (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) == SCREENLAYOUT_LAYOUTDIR_RTL ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Return the layout direction. Will be either {@link View#LAYOUT_DIRECTION_LTR} or
 * {@link View#LAYOUT_DIRECTION_RTL}.
 *
 * @return the layout direction
 */
","/**
 * Return the layout direction. Will be either {@link View#LAYOUT_DIRECTION_LTR} or
 * {@link View#LAYOUT_DIRECTION_RTL}.
 *
 * @return Returns {@link View#LAYOUT_DIRECTION_RTL} if the configuration
 * is {@link #SCREENLAYOUT_LAYOUTDIR_RTL}, otherwise {@link View#LAYOUT_DIRECTION_LTR}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement changed from subtracting operation to a conditional operation, so the code change is classified as type 1.","The change in return statement leads to the situations where depending on the conditions met by screenLayout, we may have different return values for the late version compared to the early version, thus the CI is classified as type 1."
346,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>",17,18,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>","<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName,Bundle)>",0,"{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider, options);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider, options, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @param options       Bundle containing options for the AppWidget. See also
 * {@link #updateAppWidgetOptions(int, Bundle)}
 *
 * @return true if this component has permission to bind the AppWidget
 */
","/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @param options       Bundle containing options for the AppWidget. See also
 * {@link #updateAppWidgetOptions(int, Bundle)}
 *
 * @return true if this component has permission to bind the AppWidget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed as the method call sService.bindAppWidgetIdIfAllowed has an extra parameter, mContext.getUserId(), in the late version. Therefore, the code change type is 1,5.","The extra parameter in the method call sService.bindAppWidgetIdIfAllowed may lead the method to return a different value, thus the CI type is 1."
347,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",17,18,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    ICancellationSignal remoteCancellationSignal = null;
    if (cancellationSignal != null) {
        remoteCancellationSignal = mContentProvider.createCancellationSignal();
        cancellationSignal.setRemote(remoteCancellationSignal);
    }
    try {
        return mContentProvider.query(url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    ICancellationSignal remoteCancellationSignal = null;
    if (cancellationSignal != null) {
        remoteCancellationSignal = mContentProvider.createCancellationSignal();
        cancellationSignal.setRemote(remoteCancellationSignal);
    }
    try {
        return mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mContentProvider.query() to mContentProvider.query(mPackageName,...). The method called in return statement has added a new parameter 'mPackageName', so the code change type is 1,5.","The change in the called method within the return statement will potentially lead to the returning of different results, hence the CI type is 1."
351,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,17,18,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,<android.animation.KeyframeSet: KeyframeSet ofFloat(float)>,0,"{
    int numKeyframes = values.length;
    FloatKeyframe[] keyframes = new FloatKeyframe[Math.max(numKeyframes, 2)];
    if (numKeyframes == 1) {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
        keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
    } else {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
        for (int i = 1; i < numKeyframes; ++i) {
            keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
        }
    }
    return new FloatKeyframeSet(keyframes);
}","{
    boolean badValue = false;
    int numKeyframes = values.length;
    FloatKeyframe[] keyframes = new FloatKeyframe[Math.max(numKeyframes, 2)];
    if (numKeyframes == 1) {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
        keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
        if (Float.isNaN(values[0])) {
            badValue = true;
        }
    } else {
        keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
        for (int i = 1; i < numKeyframes; ++i) {
            keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
            if (Float.isNaN(values[i])) {
                badValue = true;
            }
        }
    }
    if (badValue) {
        Log.w(""Animator"", ""Bad value (NaN) in float animator"");
    }
    return new FloatKeyframeSet(keyframes);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new local variable 'badValue' is introduced and values[i] is checked whether it's NaN in the version 18. So, the change is about the local variable and new control statement ('if'). Therefore, the code change type is 3,4.","Despite the changes in version 18, the expected behavior of the function has not been altered. The changes look like they were meant to check for bad values and issues warnings accordingly, which does not affect how the function returns its outputs. Hence, no compatibility issue exists, and the CI type is 0."
352,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",17,18,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a single line of code added in the late version (s.setChannelIdPrivateKey(mChannelIdPrivateKey);), which is a different statement, so the code change type is 4.","The added line of code (s.setChannelIdPrivateKey(mChannelIdPrivateKey);) does not affect the returned value of this function nor does it introduce any new exception handling. Therefore, no compatibility issue (CI type: 0) exists for this API change."
353,<android.app.Notification: String toString()>,17,18,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    // TODO(dsandler): defaults take precedence over local values, so reorder the branches below
    sb.append("" vibrate="");
    if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if (this.sound != null) {
        sb.append(this.sound.toString());
    } else if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append("" kind=["");
    if (this.kind == null) {
        sb.append(""null"");
    } else {
        for (int i = 0; i < this.kind.length; i++) {
            if (i > 0)
                sb.append("","");
            sb.append(this.kind[i]);
        }
    }
    sb.append(""]"");
    if (actions != null) {
        sb.append("" "");
        sb.append(actions.length);
        sb.append("" action"");
        if (actions.length > 1)
            sb.append(""s"");
    }
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    // TODO(dsandler): defaults take precedence over local values, so reorder the branches below
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append("" kind=["");
    if (this.kind == null) {
        sb.append(""null"");
    } else {
        for (int i = 0; i < this.kind.length; i++) {
            if (i > 0)
                sb.append("","");
            sb.append(this.kind[i]);
        }
    }
    sb.append(""]"");
    if (actions != null) {
        sb.append("" "");
        sb.append(actions.length);
        sb.append("" action"");
        if (actions.length > 1)
            sb.append(""s"");
    }
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The order of the conditions about 'vibrate' and 'sound' have changed which affects the string being returned by the toString method, it seems just a trivial difference, it doesn't involve return statements, exception handling statements, and signature changes of the dependent APIs, and hence, the change type is 3 - Control dependency change.","The changed order of the conditions can influence the potential return values of the toString method by appending different strings to the StringBuilder. Therefore, it leads to a compatibility issue, the type is 1 - Compatibility Issue caused potentially by different return values."
354,"<android.text.format.DateUtils: String getMonthString(int,int)>",17,18,"<android.text.format.DateUtils: String getMonthString(int,int)>","<android.text.format.DateUtils: String getMonthString(int,int)>",0,"{
    // Note that here we use d.shortMonthNames for MEDIUM, SHORT and SHORTER.
    // This is a shortcut to not spam the translators with too many variations
    // of the same string.  If we find that in a language the distinction
    // is necessary, we can can add more without changing this API.
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longMonthNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORT:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTER:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyMonthNames;
            break;
        default:
            names = d.shortMonthNames;
            break;
    }
    return names[month];
}","{
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longMonthNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORT:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTER:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyMonthNames;
            break;
        default:
            names = d.shortMonthNames;
            break;
    }
    return names[month];
}",1,"/**
 * Return a localized string for the month of the year.
 * @param month One of {@link Calendar#JANUARY Calendar.JANUARY},
 * {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},
 * or {@link #LENGTH_SHORTEST}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @return Localized month of the year.
 * @deprecated use {@link java.text.SimpleDateFormat} instead.
 */
","/**
 * Return a localized string for the month of the year.
 * @param month One of {@link Calendar#JANUARY Calendar.JANUARY},
 * {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},
 * or {@link #LENGTH_SHORTEST}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @return Localized month of the year.
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation from the early version to the late version.,"Since there is no change in the implementations of the two versions, there is no compatibility issue."
356,"<android.accounts.AccountManager: Intent newChooseAccountIntent(Account,ArrayList<Account>,String[],boolean,String,String,String[],Bundle)>",17,18,"<android.accounts.AccountManager: Intent newChooseAccountIntent(Account,ArrayList<Account>,String[],boolean,String,String,String[],Bundle)>","<android.accounts.AccountManager: Intent newChooseAccountIntent(Account,ArrayList<Account>,String[],boolean,String,String,String[],Bundle)>",0,"{
    Intent intent = new Intent();
    intent.setClassName(""android"", ""android.accounts.ChooseTypeAndAccountActivity"");
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST, allowableAccounts);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY, allowableAccountTypes);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_OPTIONS_BUNDLE, addAccountOptions);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_SELECTED_ACCOUNT, selectedAccount);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT, alwaysPromptForAccount);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_DESCRIPTION_TEXT_OVERRIDE, descriptionOverrideText);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_AUTH_TOKEN_TYPE_STRING, addAccountAuthTokenType);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_REQUIRED_FEATURES_STRING_ARRAY, addAccountRequiredFeatures);
    return intent;
}","{
    Intent intent = new Intent();
    ComponentName componentName = ComponentName.unflattenFromString(Resources.getSystem().getString(R.string.config_chooseTypeAndAccountActivity));
    intent.setClassName(componentName.getPackageName(), componentName.getClassName());
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST, allowableAccounts);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALLOWABLE_ACCOUNT_TYPES_STRING_ARRAY, allowableAccountTypes);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_OPTIONS_BUNDLE, addAccountOptions);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_SELECTED_ACCOUNT, selectedAccount);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ALWAYS_PROMPT_FOR_ACCOUNT, alwaysPromptForAccount);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_DESCRIPTION_TEXT_OVERRIDE, descriptionOverrideText);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_AUTH_TOKEN_TYPE_STRING, addAccountAuthTokenType);
    intent.putExtra(ChooseTypeAndAccountActivity.EXTRA_ADD_ACCOUNT_REQUIRED_FEATURES_STRING_ARRAY, addAccountRequiredFeatures);
    return intent;
}",1,"/**
 * Returns an intent to an {@link Activity} that prompts the user to choose from a list of
 * accounts.
 * The caller will then typically start the activity by calling
 * <code>startActivityWithResult(intent, ...);</code>.
 * <p>
 * On success the activity returns a Bundle with the account name and type specified using
 * keys {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}.
 * <p>
 * The most common case is to call this with one account type, e.g.:
 * <p>
 * <pre>  newChooseAccountsIntent(null, null, new String[]{""com.google""}, false, null,
 * null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currently
 * selected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link ArrayList} of accounts that are allowed to be
 * shown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are used
 * both to filter the shown accounts and to filter the list of account types that are shown
 * when adding an account.
 * @param alwaysPromptForAccount if set the account chooser screen is always shown, otherwise
 * it is only shown when there is more than one account from which to choose
 * @param descriptionOverrideText if non-null this string is used as the description in the
 * accounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}
 * authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}
 * requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} options
 * parameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
","/**
 * Returns an intent to an {@link Activity} that prompts the user to choose from a list of
 * accounts.
 * The caller will then typically start the activity by calling
 * <code>startActivityForResult(intent, ...);</code>.
 * <p>
 * On success the activity returns a Bundle with the account name and type specified using
 * keys {@link #KEY_ACCOUNT_NAME} and {@link #KEY_ACCOUNT_TYPE}.
 * <p>
 * The most common case is to call this with one account type, e.g.:
 * <p>
 * <pre>  newChooseAccountIntent(null, null, new String[]{""com.google""}, false, null,
 * null, null, null);</pre>
 * @param selectedAccount if specified, indicates that the {@link Account} is the currently
 * selected one, according to the caller's definition of selected.
 * @param allowableAccounts an optional {@link ArrayList} of accounts that are allowed to be
 * shown. If not specified then this field will not limit the displayed accounts.
 * @param allowableAccountTypes an optional string array of account types. These are used
 * both to filter the shown accounts and to filter the list of account types that are shown
 * when adding an account.
 * @param alwaysPromptForAccount if set the account chooser screen is always shown, otherwise
 * it is only shown when there is more than one account from which to choose
 * @param descriptionOverrideText if non-null this string is used as the description in the
 * accounts chooser screen rather than the default
 * @param addAccountAuthTokenType this string is passed as the {@link #addAccount}
 * authTokenType parameter
 * @param addAccountRequiredFeatures this string array is passed as the {@link #addAccount}
 * requiredFeatures parameter
 * @param addAccountOptions This {@link Bundle} is passed as the {@link #addAccount} options
 * parameter
 * @return an {@link Intent} that can be used to launch the ChooseAccount activity flow.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The way of setting the component name of the intent has been changed, and this involves the use of several new APIs such as ComponentName.unflattenFromString() and Resources.getSystem().getString(), so the code change type is 4,5.","Due to the change in the method of obtaining component name, the returned Intent instance might have a different component name which leads to the possibility of different behaviour when this intent is started. Thus, the CI type is 1."
358,"<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>",17,18,"<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>","<android.appwidget.AppWidgetManager: void updateAppWidget(int[],RemoteViews)>",0,"{
    try {
        sService.updateAppWidgetIds(appWidgetIds, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.updateAppWidgetIds(appWidgetIds, views, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Set the RemoteViews to use for the specified appWidgetIds.
 *
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int[], RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views         The RemoteViews object to show.
 */
","/**
 * Set the RemoteViews to use for the specified appWidgetIds.
 *
 * Note that the RemoteViews parameter will be cached by the AppWidgetService, and hence should
 * contain a complete representation of the widget. For performing partial widget updates, see
 * {@link #partiallyUpdateAppWidget(int[], RemoteViews)}.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * The total Bitmap memory used by the RemoteViews object cannot exceed that required to
 * fill the screen 1.5 times, ie. (screen width x screen height x 4 x 1.5) bytes.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views         The RemoteViews object to show.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API sService.updateAppWidgetIds has changed, adding an extra parameter mContext.getUserId(). Moreover, a return statement has changed because the API relies on sService.updateAppWidgetIds which was modified. So, the code change type is 1,5.","Given the change in sService.updateAppWidgetIds method call and since the return of this method potentially impacts the updateAppWidget method's return behaviour, a compatibility issue may arise due to potential different return values or types. Therefore, the CI type is 1."
359,"<android.content.AsyncTaskLoader: void dispatchOnLoadComplete(LoadTask,D)>",17,18,"<android.content.AsyncTaskLoader: void dispatchOnLoadComplete(LoadTask,D)>","<android.content.AsyncTaskLoader: void dispatchOnLoadComplete(LoadTask,D)>",0,"{
    if (mTask != task) {
        if (DEBUG)
            Slog.v(TAG, ""Load complete of old task, trying to cancel"");
        dispatchOnCancelled(task, data);
    } else {
        if (isAbandoned()) {
            // This cursor has been abandoned; just cancel the new data.
            onCanceled(data);
        } else {
            mLastLoadCompleteTime = SystemClock.uptimeMillis();
            mTask = null;
            if (DEBUG)
                Slog.v(TAG, ""Delivering result"");
            deliverResult(data);
        }
    }
}","{
    if (mTask != task) {
        if (DEBUG)
            Slog.v(TAG, ""Load complete of old task, trying to cancel"");
        dispatchOnCancelled(task, data);
    } else {
        if (isAbandoned()) {
            // This cursor has been abandoned; just cancel the new data.
            onCanceled(data);
        } else {
            commitContentChanged();
            mLastLoadCompleteTime = SystemClock.uptimeMillis();
            mTask = null;
            if (DEBUG)
                Slog.v(TAG, ""Delivering result"");
            deliverResult(data);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's an extra line (commitContentChanged();) in the late implementation, that doesn't modify return and exception handling statements or control dependencies. So, the change is classified as a type 4.","The method commitContentChanged() is an internal statement and doesn't affect the behavior of the API directly. It doesn't change the value returned by the API, nor the exception handling. Therefore, there's no compatibility issue (type 0)."
360,<android.view.accessibility.AccessibilityNodeInfo: boolean isFocusable()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isFocusable()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isFocusable()>,0,"{
    return getBooleanProperty(PROPERTY_FOCUSABLE);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_FOCUSABLE);
}",1,"/**
 * Gets whether this node is focusable.
 *
 * @return True if the node is focusable.
 */
","/**
 * Gets whether this node is focusable.
 *
 * @return True if the node is focusable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getBooleanProperty(PROPERTY_FOCUSABLE) to getBooleanProperty(BOOLEAN_PROPERTY_FOCUSABLE), and the parameter type of the getBooleanProperty() method also changed, so the code change type is 1,5.","The change of the return statement will make the API potentially return a different value, thus the CI type is 1."
361,<android.app.Notification.BigTextStyle: BigTextStyle setBigContentTitle(CharSequence)>,17,18,<android.app.Notification.BigTextStyle: BigTextStyle setBigContentTitle(CharSequence)>,<android.app.Notification.BigTextStyle: BigTextStyle setBigContentTitle(CharSequence)>,0,"{
    internalSetBigContentTitle(title);
    return this;
}","{
    internalSetBigContentTitle(safeCharSequence(title));
    return this;
}",1,"/**
 * Overrides ContentTitle in the big form of the template.
 * This defaults to the value passed to setContentTitle().
 */
","/**
 * Overrides ContentTitle in the big form of the template.
 * This defaults to the value passed to setContentTitle().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call inside the implementation has changed from internalSetBigContentTitle(title) to internalSetBigContentTitle(safeCharSequence(title)), thus this is classified under class 5 for dependent API changing. Also, the input parameters of that API changed hence the change is also under class 4 for other statement change.","Even though the dependent API input parameter changed, the purpose of implementing safeCharSequence is to ensure the CharSequence used is safe and won't throw any exceptions, enhancing the robustness. Hence, this doesn't create a compatibility issue as the returned output and behaviour is the same as before. Therefore, it is classified as class 0 for no compatibility issue."
362,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",17,18,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    warnIfCallingFromSystemProcess();
    return bindService(service, conn, flags, UserHandle.getUserId(Process.myUid()));
}","{
    warnIfCallingFromSystemProcess();
    return bindServiceAsUser(service, conn, flags, Process.myUserHandle());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statements have been modified from bindService(service, conn, flags, UserHandle.getUserId(Process.myUid())) to bindServiceAsUser(service, conn, flags, Process.myUserHandle()), even though the name of the method called and the number of parameters are altered. Thus, the code change type is 1,5.","Since the return statement has been modified, the method may return a different value in the later version, causing the CI type to be 1."
363,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>",17,18,"<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>","<android.appwidget.AppWidgetManager: void notifyAppWidgetViewDataChanged(int[],int)>",0,"{
    try {
        sService.notifyAppWidgetViewDataChanged(appWidgetIds, viewId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.notifyAppWidgetViewDataChanged(appWidgetIds, viewId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their currently data.
 *
 * @param appWidgetIds  The AppWidget instances for which to notify of view data changes.
 * @param viewId        The collection view id.
 */
","/**
 * Notifies the specified collection view in all the specified AppWidget instances
 * to invalidate their currently data.
 *
 * @param appWidgetIds  The AppWidget instances for which to notify of view data changes.
 * @param viewId        The collection view id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,No Compatibility Issue exists,"Only the invokation of 'sService.notifyAppWidgetViewDataChanged' in API changed by introducing a new parameter 'mContext.getUserId()', which indiciates that the dependent API sService.notifyAppWidgetViewDataChanged(...) changed, so the code change type is 5.","The change is about how to call the dependent method, but it won't lead to a different potential behaviour of this API, no matter return a different value or throw a different exception. Hence, no compatibility issue exists."
366,<android.appwidget.AppWidgetHost: void startListening()>,17,18,<android.appwidget.AppWidgetHost: void startListening()>,<android.appwidget.AppWidgetHost: void startListening()>,0,"{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        updatedIds = sService.startListening(mCallbacks, mPackageName, mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}","{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    final int userId = mContext.getUserId();
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        updatedIds = sService.startListening(mCallbacks, mPackageName, mHostId, updatedViews, userId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        if (updatedViews.get(i) != null) {
            updatedViews.get(i).setUser(new UserHandle(userId));
        }
        updateAppWidgetView(updatedIds[i], updatedViews.get(i), userId);
    }
}",1,"/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
","/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"In the late version, a new statement 'final int userId = mContext.getUserId();' is introduced. The method sService.startListening and updateAppWidgetView are being called with an additional parameter 'userId'. A further check 'if (updatedViews.get(i) != null) {' is added before a new setter is called on the updated views 'updatedViews.get(i).setUser(new UserHandle(userId));'.",#CI_description
371,<android.view.ViewGroup.ViewLocationHolder: void recycle()>,17,18,<android.view.ViewGroup.ViewLocationHolder: void recycle()>,<android.view.ViewGroup.ViewLocationHolder: void recycle()>,0,"{
    if (mIsPooled) {
        throw new IllegalStateException(""Instance already recycled."");
    }
    clear();
    synchronized (sPoolLock) {
        if (sPoolSize < MAX_POOL_SIZE) {
            mNext = sPool;
            mIsPooled = true;
            sPool = this;
            sPoolSize++;
        }
    }
}","{
    clear();
    sPool.release(this);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"Firstly, the early version had a throw statement based on a condition (mIsPooled) which is no longer present in the later version, hence the change in Control dependency (3). The return behaviour and the exceptions being thrown have changed as well, hence Return statement changed statement (1) and Other statement changed (4). The recycle() method in the late version is dependent on sPool.release(this) which is not present in the early version making the dependent API changed (5).","Even though changes exist, these do not cause a compatibility issue because the late version seems to take care of releasing and recycling, which was manually done in the early version. Thus the outcome for the end-user remains the same, only the method to achieve it has been simplified and no compatibility issue arises. Therefore, the CI type is 0."
373,<android.os.Environment: File getExternalStorageDirectory()>,17,18,<android.os.Environment: File getExternalStorageDirectory()>,<android.os.Environment: File getExternalStorageDirectory()>,0,"{
    throwIfSystem();
    return sCurrentUser.getExternalStorageDirectory();
}","{
    throwIfUserRequired();
    return sCurrentUser.getExternalStorageDirectory();
}",1,"/**
 * Gets the Android external storage directory.  This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened.  You can determine its current state with
 * {@link #getExternalStorageState()}.
 *
 * <p><em>Note: don't be confused by the word ""external"" here.  This
 * directory can better be thought as media/shared storage.  It is a
 * filesystem that can hold a relatively large amount of data and that
 * is shared across all applications (does not enforce permissions).
 * Traditionally this is an SD card, but it may also be implemented as
 * built-in storage in a device that is distinct from the protected
 * internal storage and can be mounted as a filesystem on a computer.</em></p>
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>In devices with multiple ""external"" storage directories (such as
 * both secure app storage and mountable shared storage), this directory
 * represents the ""primary"" external storage that the user will interact
 * with.</p>
 *
 * <p>Applications should not directly use this top-level directory, in
 * order to avoid polluting the user's root namespace.  Any files that are
 * private to the application should be placed in a directory returned
 * by {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled.  Other shared files should be placed
 * in one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.</p>
 *
 * <p>Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission. In
 * a future platform release, access to this path will require the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.</p>
 *
 * <p>This path may change between platform versions, so applications
 * should only persist relative paths.</p>
 *
 * <p>Here is an example of typical code to monitor the state of
 * external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
","/**
 * Gets the Android external storage directory.  This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened.  You can determine its current state with
 * {@link #getExternalStorageState()}.
 *
 * <p><em>Note: don't be confused by the word ""external"" here.  This
 * directory can better be thought as media/shared storage.  It is a
 * filesystem that can hold a relatively large amount of data and that
 * is shared across all applications (does not enforce permissions).
 * Traditionally this is an SD card, but it may also be implemented as
 * built-in storage in a device that is distinct from the protected
 * internal storage and can be mounted as a filesystem on a computer.</em></p>
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>In devices with multiple ""external"" storage directories (such as
 * both secure app storage and mountable shared storage), this directory
 * represents the ""primary"" external storage that the user will interact
 * with.</p>
 *
 * <p>Applications should not directly use this top-level directory, in
 * order to avoid polluting the user's root namespace.  Any files that are
 * private to the application should be placed in a directory returned
 * by {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled.  Other shared files should be placed
 * in one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.</p>
 *
 * <p>Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission. In
 * a future platform release, access to this path will require the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.</p>
 *
 * <p>This path may change between platform versions, so applications
 * should only persist relative paths.</p>
 *
 * <p>Here is an example of typical code to monitor the state of
 * external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The function calling before return statement has changed from throwIfSystem() to throwIfUserRequired(), so the change type is 2,4.","Because the throwIfSystem() and throwIfUserRequired() can throw different exceptions, so the Compatibility Issue type is 2."
374,<android.widget.Spinner: boolean performClick()>,17,18,<android.widget.Spinner: boolean performClick()>,<android.widget.Spinner: boolean performClick()>,0,"{
    boolean handled = super.performClick();
    if (!handled) {
        handled = true;
        if (!mPopup.isShowing()) {
            mPopup.show();
        }
    }
    return handled;
}","{
    boolean handled = super.performClick();
    if (!handled) {
        handled = true;
        if (!mPopup.isShowing()) {
            mPopup.show(getTextDirection(), getTextAlignment());
        }
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent method 'show' changed its signature by adding two parameters 'getTextDirection()', 'getTextAlignment()', so the change type is 5.",No Compatibility Issue exist because the addition of the parameters does not change the behavior of the dependent method 'show()'. The API will return the same type of result and handle the same type of exception.
375,"<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>",17,18,"<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>","<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>",0,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession(mContext.getMainLooper()).sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession().sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
","/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method invocation inside the try block has changed, specifically the call to `getWindowSession`. The early version gets the window session with `getWindowSession(mContext.getMainLooper())`, whereas the late version uses `getWindowSession()` without any arguments. Hence, the code change type is 5.","The change in API doesn't affect the potential return value/type of the method since it is void and it does not change the exception handling operation. So, it can be assumed that the change will not lead to a compatibility issue. Hence, the CI type is 0."
376,"<android.widget.RemoteViews.ReflectionActionWithoutParams: void apply(View,ViewGroup,OnClickHandler)>",17,18,"<android.widget.RemoteViews.ReflectionActionWithoutParams: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ReflectionActionWithoutParams: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class klass = view.getClass();
    Method method;
    try {
        method = klass.getMethod(this.methodName);
    } catch (NoSuchMethodException ex) {
        throw new ActionException(""view: "" + klass.getName() + "" doesn't have method: "" + this.methodName + ""()"");
    }
    if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""view: "" + klass.getName() + "" can't use method with RemoteViews: "" + this.methodName + ""()"");
    }
    try {
        // noinspection ConstantIfStatement
        if (false) {
            Log.d(""RemoteViews"", ""view: "" + klass.getName() + "" calling method: "" + this.methodName + ""()"");
        }
        method.invoke(view);
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}","{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class klass = view.getClass();
    Method method;
    try {
        method = klass.getMethod(this.methodName);
    } catch (NoSuchMethodException ex) {
        throw new ActionException(""view: "" + klass.getName() + "" doesn't have method: "" + this.methodName + ""()"");
    }
    if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""view: "" + klass.getName() + "" can't use method with RemoteViews: "" + this.methodName + ""()"");
    }
    try {
        // noinspection ConstantIfStatement
        if (false) {
            Log.d(LOG_TAG, ""view: "" + klass.getName() + "" calling method: "" + this.methodName + ""()"");
        }
        method.invoke(view);
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only the parameter inside Log.d has changed, from 'RemoteViews' to 'LOG_TAG', which is typically considered as 'other statement changed'. So the code change type is 4.","The change of the logging tag does not influence the potential behaviour, hence it is safe to say that no compatibility issue exists in this case."
377,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",17,18,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}","{
    final int userId = mContext.getUserId();
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setUserId(userId);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId, userId);
        if (views != null) {
            views.setUser(new UserHandle(mContext.getUserId()));
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version, a new variable 'userId' is introduced and the method 'setUserId(userId)' is called, which changes the other statement. Also, the return statement is impacted by these new statements, so the change type is 1,4.","'userId' is introduced and used in return statements, which could potentially lead to different return values. Therefore, the CI type is 1."
378,"<android.app.Notification.Builder: Builder addAction(int,CharSequence,PendingIntent)>",17,18,"<android.app.Notification.Builder: Builder addAction(int,CharSequence,PendingIntent)>","<android.app.Notification.Builder: Builder addAction(int,CharSequence,PendingIntent)>",0,"{
    mActions.add(new Action(icon, title, intent));
    return this;
}","{
    mActions.add(new Action(icon, safeCharSequence(title), intent));
    return this;
}",1,"/**
 * Add an action to this notification. Actions are typically displayed by
 * the system as a button adjacent to the notification content.
 *
 * @param icon Resource ID of a drawable that represents the action.
 * @param title Text describing the action.
 * @param intent PendingIntent to be fired when the action is invoked.
 */
","/**
 * Add an action to this notification. Actions are typically displayed by
 * the system as a button adjacent to the notification content.
 * <br>
 * A notification displays up to 3 actions, from left to right in the order they were added.
 *
 * @param icon Resource ID of a drawable that represents the action.
 * @param title Text describing the action.
 * @param intent PendingIntent to be fired when the action is invoked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The add() operation under mActions and the arguments in new Action() have changed, so the change type is 4,5.","The change in the method does not affect the return type, value or exception behavior of the API, so no compatibility issue is identified (Type 0)."
379,"<android.widget.Spinner: void layout(int,boolean)>",17,18,"<android.widget.Spinner: void layout(int,boolean)>","<android.widget.Spinner: void layout(int,boolean)>",0,"{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle the empty set by removing all views
    if (mItemCount == 0) {
        resetList();
        return;
    }
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    recycleAllViews();
    // Clear out old views
    removeAllViewsInLayout();
    // Make selected view and position it
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition);
    int width = sel.getMeasuredWidth();
    int selectedOffset = childrenLeft;
    final int layoutDirection = getLayoutDirection();
    final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
    switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
        case Gravity.CENTER_HORIZONTAL:
            selectedOffset = childrenLeft + (childrenWidth / 2) - (width / 2);
            break;
        case Gravity.RIGHT:
            selectedOffset = childrenLeft + childrenWidth - width;
            break;
    }
    sel.offsetLeftAndRight(selectedOffset);
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
}","{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle the empty set by removing all views
    if (mItemCount == 0) {
        resetList();
        return;
    }
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    recycleAllViews();
    // Clear out old views
    removeAllViewsInLayout();
    // Make selected view and position it
    mFirstPosition = mSelectedPosition;
    if (mAdapter != null) {
        View sel = makeAndAddView(mSelectedPosition);
        int width = sel.getMeasuredWidth();
        int selectedOffset = childrenLeft;
        final int layoutDirection = getLayoutDirection();
        final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
        switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
            case Gravity.CENTER_HORIZONTAL:
                selectedOffset = childrenLeft + (childrenWidth / 2) - (width / 2);
                break;
            case Gravity.RIGHT:
                selectedOffset = childrenLeft + childrenWidth - width;
                break;
        }
        sel.offsetLeftAndRight(selectedOffset);
    }
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
}",1,"/**
 * Creates and positions all views for this Spinner.
 *
 * @param delta Change in the selected position. +1 means selection is moving to the right,
 * so views are scrolling to the left. -1 means selection is moving to the left.
 */
","/**
 * Creates and positions all views for this Spinner.
 *
 * @param delta Change in the selected position. +1 means selection is moving to the right,
 * so views are scrolling to the left. -1 means selection is moving to the left.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new condition statement: 'if (mAdapter != null)', and the statements under this condition are changed. So the code change type is 3,4.","The new 'if' condition checks if 'mAdapter' is null. If 'mAdapter' is null, the following new block of code will not run, which may lead to the late version API returning a different result. Thus the CI type is 1."
380,<android.os.MessageQueue: void finalize()>,17,18,<android.os.MessageQueue: void finalize()>,<android.os.MessageQueue: void finalize()>,0,"{
    try {
        nativeDestroy();
    } finally {
        super.finalize();
    }
}","{
    try {
        dispose();
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method called within the try block has changed from nativeDestroy() to dispose(). The function of the code remains the same, but the underlying implementation used to achieve these functions is different. Therefore, the type of code change is 4 (Other statement changed).","Despite the change in method called, it doesn't present any compatibility issues as the overall behavior and objective of the function remains the same. Hence, it doesn't lead to any difference in return values/types or exception handling. Thus, the CI type is 0 (No Compatibility Issue exist)."
381,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",17,18,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>","<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",0,"{
    if (uri == null) {
        throw new NullPointerException(""uri == null"");
    }
    if (method == null) {
        throw new NullPointerException(""method == null"");
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        return provider.call(method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    if (uri == null) {
        throw new NullPointerException(""uri == null"");
    }
    if (method == null) {
        throw new NullPointerException(""method == null"");
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        return provider.call(mPackageName, method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
","/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call in 'provider.call()' has been changed by adding additional parameter 'mPackageName', so this is a change with type 1,5.","The change in the 'provider.call()' by adding an extra field 'mPackageName', can potentially result in a differing value returned by the API, which could potentially lead to a compatibility issue and hence, this is a CI of type 1."
382,<android.text.Layout: float getPrimaryHorizontal(int)>,17,18,<android.text.Layout: float getPrimaryHorizontal(int)>,<android.text.Layout: float getPrimaryHorizontal(int)>,0,"{
    boolean trailing = primaryIsTrailingPrevious(offset);
    return getHorizontal(offset, trailing);
}","{
    return getPrimaryHorizontal(offset, false);
}",1,"/**
 * Get the primary horizontal position for the specified text offset.
 * This is the location where a new character would be inserted in
 * the paragraph's primary direction.
 */
","/**
 * Get the primary horizontal position for the specified text offset.
 * This is the location where a new character would be inserted in
 * the paragraph's primary direction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the early version, the method calculates a boolean value 'trailing' by invoking the method primaryIsTrailingPrevious(offset), which is then used as a parameter to call the getHorizontal() method. In the late version, 'trailing' is now hardcoded to 'false', thus eliminating a potential variation in the outcome of getHorizontal(). So, the code change class is 1,4.",The hardcoding of 'false' as a parameter of getHorizontal() can potentially lead to different return values. That's why the CI class is 1.
383,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,17,18,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,0,"{
    nativeUnlockCanvasAndPost(canvas);
}","{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        nativeUnlockCanvasAndPost(mNativeSurface, canvas);
    }
}",1,"/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
","/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The control dependency has changed as new 'if' and 'synchronized' blocks were introduced. An exception throwing statement has been added. The late version now also uses a different method (nativeUnlockCanvasAndPost) with altered parameters (added mNativeSurface parameter), so the code change type is 2,3,5. ","The change of control dependency may cause the API to return a different value, and the newly added 'throw' may cause the exception to be thrown differently. Hence, the CI type is 1, 2."
385,<android.view.GLES20RenderLayer: HardwareCanvas start(Canvas)>,17,18,<android.view.GLES20RenderLayer: HardwareCanvas start(Canvas)>,<android.view.GLES20RenderLayer: HardwareCanvas start(Canvas)>,0,"{
    if (currentCanvas instanceof GLES20Canvas) {
        ((GLES20Canvas) currentCanvas).interrupt();
    }
    return getCanvas();
}","{
    if (currentCanvas instanceof GLES20Canvas) {
        ((GLES20Canvas) currentCanvas).interrupt();
    }
    HardwareCanvas canvas = getCanvas();
    canvas.setViewport(mWidth, mHeight);
    canvas.onPreDraw(null);
    return canvas;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version, extra statements are added after getting the HardwareCanvas object: canvas.setViewport(mWidth, mHeight) and canvas.onPreDraw(null), which potentially leads to behavior changes, classifying this as type 1 and type 4.","As extra steps are performed on the returned HardwareCanvas in the late version, it may affect the state of the returned object, potentially altering the behavior of this method and causing different return values, thus marking this as type 1 CI."
386,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,17,18,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,0,"{
    // we expect the cursor is already at the row we need to read from
    final long eventId = cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
    ContentValues cv = new ContentValues();
    cv.put(Events._ID, eventId);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, TITLE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DESCRIPTION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_LOCATION);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, STATUS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SELF_ATTENDEE_STATUS);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTSTART);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTEND);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DURATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_END_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ALL_DAY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, AVAILABILITY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_ALARM);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_EXTENDED_PROPERTIES);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_SYNC_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, ORIGINAL_INSTANCE_TIME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ORIGINAL_ALL_DAY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_DATE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, HAS_ATTENDEE_DATA);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_INVITE_OTHERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_MODIFY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_SEE_GUESTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_PACKAGE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_URI);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, UID_2445);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, IS_ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_SYNCED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    Entity entity = new Entity(cv);
    Cursor subCursor;
    if (mResolver != null) {
        subCursor = mResolver.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues reminderValues = new ContentValues();
            reminderValues.put(Reminders.MINUTES, subCursor.getInt(COLUMN_MINUTES));
            reminderValues.put(Reminders.METHOD, subCursor.getInt(COLUMN_METHOD));
            entity.addSubValue(Reminders.CONTENT_URI, reminderValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues attendeeValues = new ContentValues();
            attendeeValues.put(Attendees.ATTENDEE_NAME, subCursor.getString(COLUMN_ATTENDEE_NAME));
            attendeeValues.put(Attendees.ATTENDEE_EMAIL, subCursor.getString(COLUMN_ATTENDEE_EMAIL));
            attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP, subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
            attendeeValues.put(Attendees.ATTENDEE_TYPE, subCursor.getInt(COLUMN_ATTENDEE_TYPE));
            attendeeValues.put(Attendees.ATTENDEE_STATUS, subCursor.getInt(COLUMN_ATTENDEE_STATUS));
            attendeeValues.put(Attendees.ATTENDEE_IDENTITY, subCursor.getString(COLUMN_ATTENDEE_IDENTITY));
            attendeeValues.put(Attendees.ATTENDEE_ID_NAMESPACE, subCursor.getString(COLUMN_ATTENDEE_ID_NAMESPACE));
            entity.addSubValue(Attendees.CONTENT_URI, attendeeValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues extendedValues = new ContentValues();
            extendedValues.put(ExtendedProperties._ID, subCursor.getString(COLUMN_ID));
            extendedValues.put(ExtendedProperties.NAME, subCursor.getString(COLUMN_NAME));
            extendedValues.put(ExtendedProperties.VALUE, subCursor.getString(COLUMN_VALUE));
            entity.addSubValue(ExtendedProperties.CONTENT_URI, extendedValues);
        }
    } finally {
        subCursor.close();
    }
    cursor.moveToNext();
    return entity;
}","{
    // we expect the cursor is already at the row we need to read from
    final long eventId = cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
    ContentValues cv = new ContentValues();
    cv.put(Events._ID, eventId);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, TITLE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DESCRIPTION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_LOCATION);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, STATUS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SELF_ATTENDEE_STATUS);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTSTART);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTEND);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DURATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_END_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ALL_DAY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, AVAILABILITY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, EVENT_COLOR);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_COLOR_KEY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_ALARM);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_EXTENDED_PROPERTIES);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_SYNC_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, ORIGINAL_INSTANCE_TIME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ORIGINAL_ALL_DAY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_DATE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, HAS_ATTENDEE_DATA);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_INVITE_OTHERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_MODIFY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_SEE_GUESTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_PACKAGE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_URI);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, UID_2445);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, IS_ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, MUTATORS);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_SYNCED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    Entity entity = new Entity(cv);
    Cursor subCursor;
    if (mResolver != null) {
        subCursor = mResolver.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues reminderValues = new ContentValues();
            reminderValues.put(Reminders.MINUTES, subCursor.getInt(COLUMN_MINUTES));
            reminderValues.put(Reminders.METHOD, subCursor.getInt(COLUMN_METHOD));
            entity.addSubValue(Reminders.CONTENT_URI, reminderValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues attendeeValues = new ContentValues();
            attendeeValues.put(Attendees.ATTENDEE_NAME, subCursor.getString(COLUMN_ATTENDEE_NAME));
            attendeeValues.put(Attendees.ATTENDEE_EMAIL, subCursor.getString(COLUMN_ATTENDEE_EMAIL));
            attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP, subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
            attendeeValues.put(Attendees.ATTENDEE_TYPE, subCursor.getInt(COLUMN_ATTENDEE_TYPE));
            attendeeValues.put(Attendees.ATTENDEE_STATUS, subCursor.getInt(COLUMN_ATTENDEE_STATUS));
            attendeeValues.put(Attendees.ATTENDEE_IDENTITY, subCursor.getString(COLUMN_ATTENDEE_IDENTITY));
            attendeeValues.put(Attendees.ATTENDEE_ID_NAMESPACE, subCursor.getString(COLUMN_ATTENDEE_ID_NAMESPACE));
            entity.addSubValue(Attendees.CONTENT_URI, attendeeValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues extendedValues = new ContentValues();
            extendedValues.put(ExtendedProperties._ID, subCursor.getString(COLUMN_ID));
            extendedValues.put(ExtendedProperties.NAME, subCursor.getString(COLUMN_NAME));
            extendedValues.put(ExtendedProperties.VALUE, subCursor.getString(COLUMN_VALUE));
            entity.addSubValue(ExtendedProperties.CONTENT_URI, extendedValues);
        }
    } finally {
        subCursor.close();
    }
    cursor.moveToNext();
    return entity;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
387,<android.bluetooth.BluetoothSocket: void close()>,17,18,<android.bluetooth.BluetoothSocket: void close()>,<android.bluetooth.BluetoothSocket: void close()>,0,"{
    Log.d(TAG, ""close() in, this: "" + this + "", channel: "" + mPort + "", state: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (VDBG)
                Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket);
            if (mSocket != null) {
                if (VDBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null)
                mPfd.detachFd();
        }
    }
// TODO(BT) unbind proxy,
}","{
    if (VDBG)
        Log.d(TAG, ""close() in, this: "" + this + "", channel: "" + mPort + "", state: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (VDBG)
                Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket);
            if (mSocket != null) {
                if (VDBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null)
                mPfd.detachFd();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The log statement at the beginning of the method has been changed. Specifically, the condition deciding whether the log statement should be executed has been changed. Therefore, the change type is 4.","There is no compatibility issue in this change, as the change only affects the internal logging and does not affect the output (return values or exceptions) or behaviors of the method. Thus, the CI type is 0."
388,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",17,18,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",0,"{
    if (view == null)
        return;
    final Integer pos = position;
    if (mReferences.containsKey(pos)) {
        // Notify all the references for that position of the newly loaded RemoteViews
        final LinkedList<RemoteViewsFrameLayout> refs = mReferences.get(pos);
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler);
        }
        refs.clear();
        // Remove this set from the original mapping
        mReferences.remove(pos);
    }
}","{
    if (view == null)
        return;
    final Integer pos = position;
    if (mReferences.containsKey(pos)) {
        // Notify all the references for that position of the newly loaded RemoteViews
        final LinkedList<RemoteViewsFrameLayout> refs = mReferences.get(pos);
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler);
            if (mViewToLinkedList.containsKey(ref)) {
                mViewToLinkedList.remove(ref);
            }
        }
        refs.clear();
        // Remove this set from the original mapping
        mReferences.remove(pos);
    }
}",1,"/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
","/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement 'if (mViewToLinkedList.containsKey(ref)) { mViewToLinkedList.remove(ref); }' is added in the for-loop in the new version, so the code change type is 4.","Although a new statement is added in the for-loop, this change does not affect the return of the method and its exception handling, so no compatibility issue exists. The CI type is 0."
389,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,17,18,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void onSetConnectionId(int connectionId) {
            mConnectionId = connectionId;
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void onSetConnectionId(int connectionId) {
            mConnectionId = connectionId;
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The new method 'onKeyEvent(KeyEvent event)' was added in the implementation inside the IAccessibilityServiceClientWrapper class creation extending Callbacks, so the change type is 4.","Even though a method was added in the inner Callbacks class, this does not change the functionality, return type, or exception handling of the onBind(Intent) method, so it doesn't cause any compatibility issues. The CI type is 0."
390,"<android.os.Bundle: CharSequence getCharSequence(String,CharSequence)>",17,18,"<android.os.Bundle: CharSequence getCharSequence(String,CharSequence)>","<android.os.Bundle: CharSequence getCharSequence(String,CharSequence)>",0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (CharSequence) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""CharSequence"", e);
        return defaultValue;
    }
}","{
    final CharSequence cs = getCharSequence(key);
    return (cs == null) ? defaultValue : cs;
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String, or null
 * @param defaultValue Value to return if key does not exist
 * @return a CharSequence value, or null
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String, or null
 * @param defaultValue Value to return if key does not exist
 * @return the CharSequence value associated with the given key, or defaultValue
 * if no valid CharSequence object is currently mapped to that key.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3, 5",1,"The early implementation has more control dependencies ('if', 'try' and 'catch') and a more complex logic. Overall, the logic of the API has been simplified and changed in the late version. And we have a new method invocation, getCharSequence(key), which is a dependent API. Hence, the code change type is 1, 3, 5.","The late version of API has new simplified logic. It returns getCharSequence(key) while the early version returns an object 'o' from the mMap. So, there might be different return values and types compared to the early version. Therefore, the CI type is 1."
391,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",17,18,"<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>","<android.view.GLES20Canvas: boolean clipRegion(Region,Op)>",0,"{
    // TODO: Implement
    region.getBounds(mClipBounds);
    return nClipRect(mRenderer, mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom, op.nativeInt);
}","{
    return nClipRegion(mRenderer, region.mNativeRegion, op.nativeInt);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement and parameters have changed. Specifically, the method to get the bounds (region.getBounds) has been removed and replaced with nClipRegion, which uses different parameters, so the code change type is 1,5.","The change of the return statement potentially makes the API return a different value, so the CI type is 1."
395,<android.content.res.Resources: float getDimension(int)>,17,18,<android.content.res.Resources: float getDimension(int)>,<android.content.res.Resources: float getDimension(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimension(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimension(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}",1,"/**
 * Retrieve a dimensional for a particular resource ID.  Unit
 * conversions are based on the current {@link DisplayMetrics} associated
 * with the resources.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional for a particular resource ID.  Unit
 * conversions are based on the current {@link DisplayMetrics} associated
 * with the resources.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The synchronization object changed from 'mTmpValue' to 'mAccessLock', and a new piece of code has been added to check if 'mTmpValue' is null then initialize it. Therefore, the change type is control dependency change (3), and other statement change (4).","Although the implementation has changed in the late version, these changes will not cause the method to return a different value or throws a new exception that it didn't in the early version, because the return statement and exception handling remain the same. So, there's no Compatibility Issue, the CI type is 0."
396,"<android.webkit.AccessibilityInjectorFallback: boolean performAccessibilityAction(int,Bundle)>",17,18,"<android.webkit.AccessibilityInjectorFallback: boolean performAccessibilityAction(int,Bundle)>","<android.webkit.AccessibilityInjectorFallback: boolean performAccessibilityAction(int,Bundle)>",0,"{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                final int direction = getDirectionForAction(action);
                final int axis = getAxisForGranularity(arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT));
                return traverseGivenAxis(direction, axis, true, null);
            }
        case AccessibilityNodeInfo.ACTION_NEXT_HTML_ELEMENT:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_HTML_ELEMENT:
            {
                final int direction = getDirectionForAction(action);
                // TODO: Add support for moving by object.
                final int axis = NAVIGATION_AXIS_SENTENCE;
                return traverseGivenAxis(direction, axis, true, null);
            }
        default:
            return false;
    }
}","{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                final int direction = getDirectionForAction(action);
                final int axis = getAxisForGranularity(arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT));
                return traverseGivenAxis(direction, axis, true, null, true);
            }
        case AccessibilityNodeInfo.ACTION_NEXT_HTML_ELEMENT:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_HTML_ELEMENT:
            {
                final int direction = getDirectionForAction(action);
                // TODO: Add support for moving by object.
                final int axis = NAVIGATION_AXIS_SENTENCE;
                return traverseGivenAxis(direction, axis, true, null, true);
            }
        default:
            return false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method traverseGivenAxis gets an extra parameter in the late version which is a boolean 'true', making it a structural change under category 4. Also, the return statement involves this method and changes, falling under category 1.","The alteration in the method invocation 'traverseGivenAxis' by adding an additional parameter potentially modifies the behaviour of the API rendering the method to return a different value. Hence, it is classified as a compatibility issue of type 1."
397,"<android.content.ContentResolver: int delete(Uri,String,String[])>",17,18,"<android.content.ContentResolver: int delete(Uri,String,String[])>","<android.content.ContentResolver: int delete(Uri,String,String[])>",0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
","/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the return statement 'int rowsDeleted = provider.delete(url, where, selectionArgs);' a new parameter 'mPackageName' was added in late version, and also changes the dependent API, so the code change type is 1,5.","The modification in the return statement can lead to a different output since a new parameter was added, thus the CI type is 1."
398,"<android.widget.VideoView: int resolveAdjustedSize(int,int)>",17,18,"<android.widget.VideoView: int resolveAdjustedSize(int,int)>","<android.widget.VideoView: int resolveAdjustedSize(int,int)>",0,"{
    int result = desiredSize;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
    switch(specMode) {
        case MeasureSpec.UNSPECIFIED:
            /* Parent says we can be as big as we want. Just don't be larger
                 * than max size imposed on ourselves.
                 */
            result = desiredSize;
            break;
        case MeasureSpec.AT_MOST:
            /* Parent says we can be as big as we want, up to specSize.
                 * Don't be larger than specSize, and don't be larger than
                 * the max size imposed on ourselves.
                 */
            result = Math.min(desiredSize, specSize);
            break;
        case MeasureSpec.EXACTLY:
            // No choice. Do what we are told.
            result = specSize;
            break;
    }
    return result;
}","{
    return getDefaultSize(desiredSize, measureSpec);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The control flow 'switch' and its statements in the early version is replaced by a single return statement that calls an external method getDefaultSize(). This constitutes both a change in the return statement and the dependent API, leading to the change types 1,5.","The API could potentially return different values as the computation for the result vastly differs between the early and the later version due to the change in return statements. Hence, the CI type is 1."
399,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,int,IBackupManager)>",17,18,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data));
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    // Ensure that any SharedPreferences writes have landed *before*
    // we potentially try to back up the underlying files directly.
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data));
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // ... and then again after, as in the doBackup() case
        waitForSharedPrefs();
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version, a new method call 'waitForSharedPrefs()' is added inside the method but outside any control statement, we categorize this as 'other statement changed'(4). And two 'waitForSharedPrefs();' are added under the 'if' and 'finally' control statements, so the change type is also 'control dependency changes'(3).","The additions of 'waitForSharedPrefs();' do not alter the potential behaviors of this API. They do not change the return value or throw any different exceptions. Therefore, no compatibility issue exists, the CI type is 0."
400,"<android.app.DownloadManager.Request: Request setDestinationInExternalPublicDir(String,String)>",17,18,"<android.app.DownloadManager.Request: Request setDestinationInExternalPublicDir(String,String)>","<android.app.DownloadManager.Request: Request setDestinationInExternalPublicDir(String,String)>",0,"{
    File file = Environment.getExternalStoragePublicDirectory(dirType);
    if (file.exists()) {
        if (!file.isDirectory()) {
            throw new IllegalStateException(file.getAbsolutePath() + "" already exists and is not a directory"");
        }
    } else {
        if (!file.mkdir()) {
            throw new IllegalStateException(""Unable to create directory: "" + file.getAbsolutePath());
        }
    }
    setDestinationFromBase(file, subPath);
    return this;
}","{
    File file = Environment.getExternalStoragePublicDirectory(dirType);
    if (file == null) {
        throw new IllegalStateException(""Failed to get external storage public directory"");
    } else if (file.exists()) {
        if (!file.isDirectory()) {
            throw new IllegalStateException(file.getAbsolutePath() + "" already exists and is not a directory"");
        }
    } else {
        if (!file.mkdirs()) {
            throw new IllegalStateException(""Unable to create directory: "" + file.getAbsolutePath());
        }
    }
    setDestinationFromBase(file, subPath);
    return this;
}",1,"/**
 * Set the local destination for the downloaded file to a path within the public external
 * storage directory (as returned by
 * {@link Environment#getExternalStoragePublicDirectory(String)}.
 * <p>
 * The downloaded file is not scanned by MediaScanner.
 * But it can be made scannable by calling {@link #allowScanningByMediaScanner()}.
 *
 * @param dirType the directory type to pass to
 * {@link Environment#getExternalStoragePublicDirectory(String)}
 * @param subPath the path within the external directory, including the destination filename
 * @return this object
 */
","/**
 * Set the local destination for the downloaded file to a path within
 * the public external storage directory (as returned by
 * {@link Environment#getExternalStoragePublicDirectory(String)}).
 * <p>
 * The downloaded file is not scanned by MediaScanner. But it can be
 * made scannable by calling {@link #allowScanningByMediaScanner()}.
 *
 * @param dirType the directory type to pass to {@link Environment#getExternalStoragePublicDirectory(String)}
 * @param subPath the path within the external directory, including the
 * destination filename
 * @return this object
 * @throws IllegalStateException If the external storage directory
 * cannot be found or created.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The control and exception handling statement has changed in the late version, a new condition 'file == null' is added and 'mkdirs()' is used instead of 'mkdir()', so the code change type is 2,3.","There is a new 'throw' statement added in the condition 'file == null', and difference between 'mkdir()' and 'mkdirs()' can lead to different exception handling. Besides, condition change also affect the value to be returned. Therefore, It could cause potential Compatibility Issue 1 and 2."
402,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,17,18,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,0,"{
    if (mText == null) {
        Log.e(TAG, ""null synthesis text"");
        return false;
    }
    if (mText.length() >= MAX_SPEECH_ITEM_CHAR_LENGTH) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}","{
    if (mText == null) {
        Log.e(TAG, ""null synthesis text"");
        return false;
    }
    if (mText.length() >= TextToSpeech.getMaxSpeechInputLength()) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The check statement has changed from 'mText.length() >= MAX_SPEECH_ITEM_CHAR_LENGTH' to 'mText.length() >= TextToSpeech.getMaxSpeechInputLength()', this change includes not only a change in a logical statement but also a change in a dependent API, thus the change types are 4,5.","Given that the value of TextToSpeech.getMaxSpeechInputLength() may be different from MAX_SPEECH_ITEM_CHAR_LENGTH, the final return value 'false' or 'true' under certain conditions can be different between the versions, thus the CI type is 1."
403,<android.bluetooth.BluetoothSocket: int bindListen()>,17,18,<android.bluetooth.BluetoothSocket: int bindListen()>,<android.bluetooth.BluetoothSocket: int bindListen()>,0,"{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        // TODO(BT) right error code?
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (VDBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (VDBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (VDBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}","{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (VDBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (VDBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (VDBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"No changes were made between the early and late versions, so there were no specific types of code changes.","No changes were made between the early and late versions, so there is no compatibility issue."
404,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain()>,0,"{
    synchronized (sPoolLock) {
        if (sPool != null) {
            AccessibilityNodeInfo info = sPool;
            sPool = sPool.mNext;
            sPoolSize--;
            info.mNext = null;
            info.mIsInPool = false;
            return info;
        }
        return new AccessibilityNodeInfo();
    }
}","{
    AccessibilityNodeInfo info = sPool.acquire();
    return (info != null) ? info : new AccessibilityNodeInfo();
}",1,"/**
 * Returns a cached instance if such is available otherwise a new one.
 *
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available otherwise a new one.
 *
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The synchorinzed block and the 'if' statement inside has been removed and replaced by the sPool.acquire() statement, and the return statement has also been changed, so the change type is 1,4.","The return statement has been changed, potentially leading to different return values thus, the CI type is 1."
405,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",17,18,"<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void removeStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, user.getIdentifier());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is only in the line `intent.setAllowFds(false);` (early implementation) replaced to `intent.prepareToLeaveProcess();` (late implementation). This change type falls under code category 4, as it's other statement changed.","Despite the changes in the code, these changes do not alter the return values or the exception handling of the API. Therefore, there is no Compatibility Issue noted for this API between the two versions per rule number three. It's categorized as 0 for no compatibility issue exist."
406,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",17,18,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",0,"{
    try {
        return mContentProvider.bulkInsert(url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
","/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the code has changed. The method `mContentProvider.bulkInsert()` in the early version has been changed to `mContentProvider.bulkInsert(mPackageName, url, initialValues)` in the late version, where `mPackageName` is added as a new parameter. Hence, the code change type is 1 for return statement change and 5 for dependent API change.","The return statement has changed in the late version to include an extra parameter `mPackageName`. Since this new parameter influences what the `bulkInsert()` method returns, it will make the API potentially return a different value or type, so the CI type is 1."
407,"<android.webkit.CallbackProxy: boolean onJsConfirm(String,String)>",17,18,"<android.webkit.CallbackProxy: boolean onJsConfirm(String,String)>","<android.webkit.CallbackProxy: boolean onJsConfirm(String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return false;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message confirm = obtainMessage(JS_CONFIRM, result);
    confirm.getData().putString(""message"", message);
    confirm.getData().putString(""url"", url);
    sendMessageToUiThreadSync(confirm);
    return result.mJsResult.getResult();
}","{
    // been set.
    if (mWebChromeClient == null) {
        return false;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message confirm = obtainMessage(JS_DIALOG, result);
    confirm.getData().putString(""message"", message);
    confirm.getData().putString(""url"", url);
    confirm.getData().putInt(""type"", JsDialogHelper.CONFIRM);
    sendMessageToUiThreadSync(confirm);
    return result.mJsResult.getResult();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement doesn't change, but the first parameter of method obtainMessage() has changed from JS_CONFIRM to JS_DIALOG, and a new method 'putInt' has been added to confirm. So the change type should be 1,4.","The method obtainMessage() and the parameter it takes can potentially affect the results of this API, so the CI type we categorize here is type 1."
408,<android.app.Notification.Builder: Builder setContentText(CharSequence)>,17,18,<android.app.Notification.Builder: Builder setContentText(CharSequence)>,<android.app.Notification.Builder: Builder setContentText(CharSequence)>,0,"{
    mContentText = text;
    return this;
}","{
    mContentText = safeCharSequence(text);
    return this;
}",1,"/**
 * Set the second line of text in the platform notification template.
 */
","/**
 * Set the second line of text in the platform notification template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The method of assigning variable mContentText has changed from a direct assignment to a method 'safeCharSequence(text)' call. So the code change type is 4 and 5.,"The API after modification may return a different value because the method 'safeCharSequence(text)' might modify the input text, therefore a potential compatibility issue exists. The CI type is 1."
409,"<android.webkit.CallbackProxy: void onJsAlert(String,String)>",17,18,"<android.webkit.CallbackProxy: void onJsAlert(String,String)>","<android.webkit.CallbackProxy: void onJsAlert(String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message alert = obtainMessage(JS_ALERT, result);
    alert.getData().putString(""message"", message);
    alert.getData().putString(""url"", url);
    sendMessageToUiThreadSync(alert);
}","{
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message alert = obtainMessage(JS_DIALOG, result);
    alert.getData().putString(""message"", message);
    alert.getData().putString(""url"", url);
    alert.getData().putInt(""type"", JsDialogHelper.ALERT);
    sendMessageToUiThreadSync(alert);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There is a change in the statement parameter of obtainMessage from (JS_ALERT, result) to (JS_DIALOG, result), and a new line of code alert.getData().putInt(""type"", JsDialogHelper.ALERT) has been added, which makes the code change type 1 and 4.","The change in the parameter of obtainMessage and the new line of code could potentially affect the behavior of the API as it might return different values. Hence, the CI type is 1."
410,"<android.webkit.CallbackProxy: String onJsPrompt(String,String,String)>",17,18,"<android.webkit.CallbackProxy: String onJsPrompt(String,String,String)>","<android.webkit.CallbackProxy: String onJsPrompt(String,String,String)>",0,"{
    // been set.
    if (mWebChromeClient == null) {
        return null;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message prompt = obtainMessage(JS_PROMPT, result);
    prompt.getData().putString(""message"", message);
    prompt.getData().putString(""default"", defaultValue);
    prompt.getData().putString(""url"", url);
    sendMessageToUiThreadSync(prompt);
    return result.mJsResult.getStringResult();
}","{
    // been set.
    if (mWebChromeClient == null) {
        return null;
    }
    JsResultReceiver result = new JsResultReceiver();
    Message prompt = obtainMessage(JS_DIALOG, result);
    prompt.getData().putString(""message"", message);
    prompt.getData().putString(""default"", defaultValue);
    prompt.getData().putString(""url"", url);
    prompt.getData().putInt(""type"", JsDialogHelper.PROMPT);
    sendMessageToUiThreadSync(prompt);
    return result.mJsResult.getStringResult();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4, 5",1,"The string argument (JS_DIALOG vs JS_PROMPT) in obtainMessage() function has been changed and a new statement containing putInt() function is introduced. Thus, the code change type is both 4 and 5.","The change made to obtainMessage() and the introduction of putInt() could potentially affect the return result of the function getStringResult(). Therefore, the Compatibility Issue (CI) type is 1."
411,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>",17,18,"<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>","<android.content.res.Resources: XmlResourceParser loadXmlResourceParser(int,String)>",0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_STRING) {
            return loadXmlResourceParser(value.string.toString(), id, value.assetCookie, type);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The changes include switching the synchronized block from 'mTmpValue' to 'mAccessLock' and adding a new statement for null-checking 'mTmpValue', which falls under category 3 (control dependency changed), and category 4 (other statement changes).","These changes do not result in potential different return values or exception handlings, therefore, no Compatibility Issue exists, hence it falls under category 0."
412,"<android.widget.VideoView: void onMeasure(int,int)>",17,18,"<android.widget.VideoView: void onMeasure(int,int)>","<android.widget.VideoView: void onMeasure(int,int)>",0,"{
    // Log.i(""@@@@"", ""onMeasure"");
    int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
    int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
    if (mVideoWidth > 0 && mVideoHeight > 0) {
        if (mVideoWidth * height > width * mVideoHeight) {
            // Log.i(""@@@"", ""image too tall, correcting"");
            height = width * mVideoHeight / mVideoWidth;
        } else if (mVideoWidth * height < width * mVideoHeight) {
            // Log.i(""@@@"", ""image too wide, correcting"");
            width = height * mVideoWidth / mVideoHeight;
        } else {
        // Log.i(""@@@"", ""aspect ratio is correct: "" +
        // width+""/""+height+""=""+
        // mVideoWidth+""/""+mVideoHeight);
        }
    }
    // Log.i(""@@@@@@@@@@"", ""setting size: "" + width + 'x' + height);
    setMeasuredDimension(width, height);
}","{
    // Log.i(""@@@@"", ""onMeasure("" + MeasureSpec.toString(widthMeasureSpec) + "", ""
    // + MeasureSpec.toString(heightMeasureSpec) + "")"");
    int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
    int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
    if (mVideoWidth > 0 && mVideoHeight > 0) {
        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
        if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {
            // the size is fixed
            width = widthSpecSize;
            height = heightSpecSize;
            // for compatibility, we adjust size based on aspect ratio
            if (mVideoWidth * height < width * mVideoHeight) {
                // Log.i(""@@@"", ""image too wide, correcting"");
                width = height * mVideoWidth / mVideoHeight;
            } else if (mVideoWidth * height > width * mVideoHeight) {
                // Log.i(""@@@"", ""image too tall, correcting"");
                height = width * mVideoHeight / mVideoWidth;
            }
        } else if (widthSpecMode == MeasureSpec.EXACTLY) {
            // only the width is fixed, adjust the height to match aspect ratio if possible
            width = widthSpecSize;
            height = width * mVideoHeight / mVideoWidth;
            if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {
                // couldn't match aspect ratio within the constraints
                height = heightSpecSize;
            }
        } else if (heightSpecMode == MeasureSpec.EXACTLY) {
            // only the height is fixed, adjust the width to match aspect ratio if possible
            height = heightSpecSize;
            width = height * mVideoWidth / mVideoHeight;
            if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {
                // couldn't match aspect ratio within the constraints
                width = widthSpecSize;
            }
        } else {
            // neither the width nor the height are fixed, try to use actual video size
            width = mVideoWidth;
            height = mVideoHeight;
            if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {
                // too tall, decrease both width and height
                height = heightSpecSize;
                width = height * mVideoWidth / mVideoHeight;
            }
            if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {
                // too wide, decrease both width and height
                width = widthSpecSize;
                height = width * mVideoHeight / mVideoWidth;
            }
        }
    } else {
    // no size yet, just adopt the given spec sizes
    }
    setMeasuredDimension(width, height);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"In the later version, there are additional conditions under the 'if (mVideoWidth > 0 && mVideoHeight > 0)' statement and the control dependecy has significantly increased. Hence, the change type is 1,3.","The change in the control dependency might make the API return different values. Therefore, the CI type is 1."
414,"<android.app.NotificationManager: void notify(String,int,Notification)>",17,18,"<android.app.NotificationManager: void notify(String,int,Notification)>","<android.app.NotificationManager: void notify(String,int,Notification)>",0,"{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotificationWithTag(pkg, tag, id, notification, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}","{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getBasePackageName(), tag, id, notification, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}",1,"/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
","/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,There are several changes between the two versions:,"- The dependent API 'service.enqueueNotificationWithTag()' has been modified, as the number of parameters has changed, so it's a Dependent API Changed (5)."
416,<android.app.ContextImpl: void sendBroadcast(Intent)>,17,18,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method call to setAllowFds(false) has been replaced with prepareToLeaveProcess() in the Intent object. Also, the 9th parameter in the broadcastIntent() method has been replaced with AppOpsManager.OP_NONE. Hence, the change type is 4 (Other statement changed).","Although the method calls and parameters have been changed, these changes don't impact the return type or potential exceptions, since this function does not return anything and the exception handling remains the same. Thus, no compatibility issue (type 0) detected."
417,"<android.app.DownloadManager.Request: Request setDestinationInExternalFilesDir(Context,String,String)>",17,18,"<android.app.DownloadManager.Request: Request setDestinationInExternalFilesDir(Context,String,String)>","<android.app.DownloadManager.Request: Request setDestinationInExternalFilesDir(Context,String,String)>",0,"{
    setDestinationFromBase(context.getExternalFilesDir(dirType), subPath);
    return this;
}","{
    final File file = context.getExternalFilesDir(dirType);
    if (file == null) {
        throw new IllegalStateException(""Failed to get external storage files directory"");
    } else if (file.exists()) {
        if (!file.isDirectory()) {
            throw new IllegalStateException(file.getAbsolutePath() + "" already exists and is not a directory"");
        }
    } else {
        if (!file.mkdirs()) {
            throw new IllegalStateException(""Unable to create directory: "" + file.getAbsolutePath());
        }
    }
    setDestinationFromBase(file, subPath);
    return this;
}",1,"/**
 * Set the local destination for the downloaded file to a path within the application's
 * external files directory (as returned by {@link Context#getExternalFilesDir(String)}.
 * <p>
 * The downloaded file is not scanned by MediaScanner.
 * But it can be made scannable by calling {@link #allowScanningByMediaScanner()}.
 *
 * @param context the {@link Context} to use in determining the external files directory
 * @param dirType the directory type to pass to {@link Context#getExternalFilesDir(String)}
 * @param subPath the path within the external directory, including the destination filename
 * @return this object
 */
","/**
 * Set the local destination for the downloaded file to a path within
 * the application's external files directory (as returned by
 * {@link Context#getExternalFilesDir(String)}.
 * <p>
 * The downloaded file is not scanned by MediaScanner. But it can be
 * made scannable by calling {@link #allowScanningByMediaScanner()}.
 *
 * @param context the {@link Context} to use in determining the external
 * files directory
 * @param dirType the directory type to pass to
 * {@link Context#getExternalFilesDir(String)}
 * @param subPath the path within the external directory, including the
 * destination filename
 * @return this object
 * @throws IllegalStateException If the external storage directory
 * cannot be found or created.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The late implementation has introduced new exception handling statements (throw new IllegalStateException...), which is classified as change type 2. The newly added if..else control statements indicate a change in control dependencies, which falls under change type 3. Also, the invocation of method setDestinationFromBase is included in these appended control structures, classified as ""other statement change"" (type 4).","The newly introduced exception throwing statements could potentially cause this API to throw different exceptions, causing CI of type 2. On the other hand, the newly added control statements affect the execution of the 'return' statement. Therefore, under certain conditions, the late API version might return 'this' at a different state, causing the CI of type 1."
418,<android.os.Bundle: void unparcel()>,17,18,<android.os.Bundle: void unparcel()>,<android.os.Bundle: void unparcel()>,0,"{
    if (mParcelledData == null) {
        return;
    }
    int N = mParcelledData.readInt();
    if (N < 0) {
        return;
    }
    if (mMap == null) {
        mMap = new HashMap<String, Object>();
    }
    mParcelledData.readMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
}","{
    if (mParcelledData == null) {
        return;
    }
    int N = mParcelledData.readInt();
    if (N < 0) {
        return;
    }
    if (mMap == null) {
        mMap = new HashMap<String, Object>(N);
    }
    mParcelledData.readMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change here is that the HashMap 'mMap' is initialized with preset capacity 'N' in the late version. So, the code change type is 4.","Despite the occurrence of code changes, it does not potentially cause the API to return a different variable or throw a different exception, so the CI type is 0 which means no Compatibility Issue exists."
419,<android.animation.ValueAnimator: void setFloatValues(float)>,17,18,<android.animation.ValueAnimator: void setFloatValues(float)>,<android.animation.ValueAnimator: void setFloatValues(float)>,0,"{
    if (values == null || values.length == 0) {
        return;
    }
    if (mValues == null || mValues.length == 0) {
        setValues(new PropertyValuesHolder[] { PropertyValuesHolder.ofFloat("""", values) });
    } else {
        PropertyValuesHolder valuesHolder = mValues[0];
        valuesHolder.setFloatValues(values);
    }
    // New property/values/target should cause re-initialization prior to starting
    mInitialized = false;
}","{
    if (values == null || values.length == 0) {
        return;
    }
    if (mValues == null || mValues.length == 0) {
        setValues(PropertyValuesHolder.ofFloat("""", values));
    } else {
        PropertyValuesHolder valuesHolder = mValues[0];
        valuesHolder.setFloatValues(values);
    }
    // New property/values/target should cause re-initialization prior to starting
    mInitialized = false;
}",1,"/**
 * Sets float values that will be animated between. A single
 * value implies that that value is the one being animated to. However, this is not typically
 * useful in a ValueAnimator object because there is no way for the object to determine the
 * starting value for the animation (unlike ObjectAnimator, which can derive that value
 * from the target object and property being animated). Therefore, there should typically
 * be two or more values.
 *
 * <p>If there are already multiple sets of values defined for this ValueAnimator via more
 * than one PropertyValuesHolder object, this method will set the values for the first
 * of those objects.</p>
 *
 * @param values A set of values that the animation will animate between over time.
 */
","/**
 * Sets float values that will be animated between. A single
 * value implies that that value is the one being animated to. However, this is not typically
 * useful in a ValueAnimator object because there is no way for the object to determine the
 * starting value for the animation (unlike ObjectAnimator, which can derive that value
 * from the target object and property being animated). Therefore, there should typically
 * be two or more values.
 *
 * <p>If there are already multiple sets of values defined for this ValueAnimator via more
 * than one PropertyValuesHolder object, this method will set the values for the first
 * of those objects.</p>
 *
 * @param values A set of values that the animation will animate between over time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method called within the 'if (mValues == null || mValues.length == 0)' block has changed from 'setValues(new PropertyValuesHolder[] { PropertyValuesHolder.ofFloat("""", values) })' to 'setValues(PropertyValuesHolder.ofFloat("""", values))'. This falls under categories 4 and 5.","The change in how setValues is being called can return a different result as the input parameter type is changing, leading to a Compatibility Issue of type 1."
420,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",17,18,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(""RemoteViews"", ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (target != null && fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                while (parent != null && !(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) {
                    parent = (View) parent.getParent();
                }
                if (parent instanceof AppWidgetHostView || parent == null) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(""RemoteViews"", ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(""RemoteViews"", ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                final int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                final Rect rect = new Rect();
                rect.left = (int) (pos[0] * appScale + 0.5f);
                rect.top = (int) (pos[1] * appScale + 0.5f);
                rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(LOG_TAG, ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (target != null && fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                while (parent != null && !(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) {
                    parent = (View) parent.getParent();
                }
                if (parent instanceof AppWidgetHostView || parent == null) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(LOG_TAG, ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(LOG_TAG, ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                final int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                final Rect rect = new Rect();
                rect.left = (int) (pos[0] * appScale + 0.5f);
                rect.top = (int) (pos[1] * appScale + 0.5f);
                rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The log tag value (""RemoteViews"" to ""LOG_TAG"") is the only thing that has changed between these two versions. So, the code change type is 4.","The log tag is just a string parameter of the method Log.e(). This change won't affect the behaviour of the API's implememntation, so there is no Compatibility Issue."
421,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",17,18,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A statement (s.setChannelIdPrivateKey(mChannelIdPrivateKey)) that is setting the value of the channelIdPrivateKey property of the OpenSSLSocketImpl object has been added in the late version, so the code change type is 4.","The addition of the new method call ""s.setChannelIdPrivateKey(mChannelIdPrivateKey)"" in the later version potentially changes the state of the returned Socket object as compared to the earlier version, therefore the CI type is 1."
422,<android.appwidget.AppWidgetHost: void deleteAllHosts()>,17,18,<android.appwidget.AppWidgetHost: void deleteAllHosts()>,<android.appwidget.AppWidgetHost: void deleteAllHosts()>,0,"{
    try {
        sService.deleteAllHosts();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    deleteAllHosts(UserHandle.myUserId());
}",1,"/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
","/**
 * Remove all records about all hosts for your package.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The API has changed its implementation from interacting with the service through sService.deleteAllHosts(); to now deleteAllHosts(UserHandle.myUserId()); Therefore, both Return statement and Dependent API changed.","Given the complete change in the method used in the implementation, it is likely that the resulting behavior after calling the API has also changed leading to CI caused by potentially different return values or types."
423,<android.webkit.AccessibilityInjector.TextToSpeechWrapper: boolean isSpeaking()>,17,18,<android.webkit.AccessibilityInjector.TextToSpeechWrapper: boolean isSpeaking()>,<android.webkit.AccessibilityInjector.TextToSpeechWrapper: boolean isSpeaking()>,0,"{
    synchronized (mTextToSpeech) {
        if (!mReady) {
            return false;
        }
        return mTextToSpeech.isSpeaking();
    }
}","{
    synchronized (mTtsLock) {
        if (!mReady) {
            return false;
        }
        return mTextToSpeech.isSpeaking();
    }
}",1,,,-1,"[@JavascriptInterface, @SuppressWarnings(""unused"")]","[@JavascriptInterface, @SuppressWarnings(""unused"")]",-1,-1,-1,-1,-1,-1,4,0,"The parameter in the synchronized statement has changed from mTextToSpeech to mTtsLock, which is a change in other statements, so the code change type is 4.","Despite the change in the synchronized statement, there is no change in the return value of the function or the exceptions it might throw. Therefore, no compatibility issues exist and the CI type is 0."
424,"<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>",17,18,"<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>","<android.appwidget.AppWidgetManager: void updateAppWidgetOptions(int,Bundle)>",0,"{
    try {
        sService.updateAppWidgetOptions(appWidgetId, options);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.updateAppWidgetOptions(appWidgetId, options, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Update the extras for a given widget instance.
 *
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #getAppWidgetOptions(int)
 *
 * @param appWidgetId    The AppWidget instances for which to set the RemoteViews.
 * @param options         The options to associate with this widget
 */
","/**
 * Update the extras for a given widget instance.
 *
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #getAppWidgetOptions(int)
 *
 * @param appWidgetId    The AppWidget instances for which to set the RemoteViews.
 * @param options         The options to associate with this widget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The call to 'sService.updateAppWidgetOptions' method has been changed in the late version by adding one more parameter (mContext.getUserId()), making the change type 1,5.","The Compatibility Issue does not exist in this case because the calling of external function 'sService.updateAppWidgetOptions' with an extra argument does not alter the behavior or output of the current method 'updateAppWidgetOptions', nor influence how exceptions are thrown. So the CI type is 0."
425,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,17,18,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener);
            } catch (RemoteException e) {
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getBasePackageName());
            } catch (RemoteException e) {
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"A method that the current API implementation relies on, getService().addPrimaryClipChangedListener(), has been changed as an extra parameter `mContext.getBasePackageName()` is added. This change falls into categories 1 and 5.","The change involves modification of an invoked method within the API, adding an extra parameter. Depending on the value of `mContext.getBasePackageName()`, the execution of the API could possibly return different results. Therefore, the compatibility issue classification is 1."
426,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,17,18,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,0,"{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    mCurrentDrag.recycle();
                    mCurrentDrag = null;
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}","{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    if (mCurrentDrag != null) {
                        mCurrentDrag.recycle();
                        mCurrentDrag = null;
                    }
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}",1,"// TODO: Write real docs
","// TODO: Write real docs
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,The implementations of the method in the early and late version are the same. There is no change in the method.,"Since there is no difference between the implementations of the method in the early and late version, no compatibility issue exists."
429,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,17,18,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",0,"The statement ""intent.setAllowFds(false);"" in the first version has been replaced with ""intent.prepareToLeaveProcess();"" in the second version, leading to change in other statements and dependent API in the code. Therefore, the code change type is 1,5.","Despite the differences in the processes, the outcome for both methods remains the same - unbroadcast an Intent, thus there is no compatibility issue."
433,<android.view.accessibility.AccessibilityNodeInfo: boolean isEnabled()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isEnabled()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isEnabled()>,0,"{
    return getBooleanProperty(PROPERTY_ENABLED);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_ENABLED);
}",1,"/**
 * Gets whether this node is enabled.
 *
 * @return True if the node is enabled.
 */
","/**
 * Gets whether this node is enabled.
 *
 * @return True if the node is enabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getBooleanProperty(PROPERTY_ENABLED) to getBooleanProperty(BOOLEAN_PROPERTY_ENABLED), and the parameter of getBooleanProperty() also changed, so the code change type is 1,5.","The change of return statement could make this API potentially return a different value. Hence, the CI type is 1."
435,<android.os.ParcelFileDescriptor: void finalize()>,17,18,<android.os.ParcelFileDescriptor: void finalize()>,<android.os.ParcelFileDescriptor: void finalize()>,0,"{
    try {
        if (!mClosed) {
            close();
        }
    } finally {
        super.finalize();
    }
}","{
    if (mGuard != null) {
        mGuard.warnIfOpen();
    }
    try {
        if (!mClosed) {
            close();
        }
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A new 'if' control statement (if (mGuard != null)) and mGuard.warnIfOpen() operation are introduced in the late version, thus the code change types are 3,4.","This 'if' control statement and mGuard.warnIfOpen() operation change does not effect the return value or the exception handling of the method. Therefore, no compatibility issue exists, and the CI type is 0."
436,<android.os.WorkSource: boolean diff(WorkSource)>,17,18,<android.os.WorkSource: boolean diff(WorkSource)>,<android.os.WorkSource: boolean diff(WorkSource)>,0,"{
    int N = mNum;
    if (N != other.mNum) {
        return true;
    }
    final int[] uids1 = mUids;
    final int[] uids2 = other.mUids;
    for (int i = 0; i < N; i++) {
        if (uids1[i] != uids2[i]) {
            return true;
        }
    }
    return false;
}","{
    int N = mNum;
    if (N != other.mNum) {
        return true;
    }
    final int[] uids1 = mUids;
    final int[] uids2 = other.mUids;
    final String[] names1 = mNames;
    final String[] names2 = other.mNames;
    for (int i = 0; i < N; i++) {
        if (uids1[i] != uids2[i]) {
            return true;
        }
        if (names1 != null && names2 != null && !names1[i].equals(names2[i])) {
            return true;
        }
    }
    return false;
}",1,"/**
 * Compare this WorkSource with another.
 * @param other The WorkSource to compare against.
 * @return If there is a difference, true is returned.
 */
","/**
 * Compare this WorkSource with another.
 * @param other The WorkSource to compare against.
 * @return If there is a difference, true is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"New variables 'names1' and 'names2' are introduced and incorporated into the 'for' loop condition, thus the control dependency has changed. Furthermore, new ""return true;"" statement is added under the situation where names1[i] is not equal to names2[i]. So, the code change type is 3,1.","The introduction of new ""return true;"" statement under the new condition (""names1[i] does not equal to names2[i]"") increases situations where the function can return ""true"", which causes potential difference in the return value compared with the early version. Therefore, the CI type is 1."
437,"<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>",17,18,"<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>","<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>",0,"{
    try {
        service.setAllowFds(false);
        ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());
        if (cn != null) {
            if (cn.getPackageName().equals(""!"")) {
                throw new SecurityException(""Not allowed to start service "" + service + "" without permission "" + cn.getClassName());
            } else if (cn.getPackageName().equals(""!!"")) {
                throw new SecurityException(""Unable to start service "" + service + "": "" + cn.getClassName());
            }
        }
        return cn;
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        service.prepareToLeaveProcess();
        ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());
        if (cn != null) {
            if (cn.getPackageName().equals(""!"")) {
                throw new SecurityException(""Not allowed to start service "" + service + "" without permission "" + cn.getClassName());
            } else if (cn.getPackageName().equals(""!!"")) {
                throw new SecurityException(""Unable to start service "" + service + "": "" + cn.getClassName());
            }
        }
        return cn;
    } catch (RemoteException e) {
        return null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method service.setAllowFds(false) in the early version changed to service.prepareToLeaveProcess() in the late version, which belongs to the change of other statements (not a return statement, exception handling statement, and not a control dependency), so the code change type is 4.","Despite the method call change, this edit does not affect the return value or the exceptions being thrown. Thus, no Compatibility Issue (CI) exists and the CI type is 0."
438,<android.provider.CalendarContract.CalendarEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,17,18,<android.provider.CalendarContract.CalendarEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,<android.provider.CalendarContract.CalendarEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,0,"{
    // we expect the cursor is already at the row we need to read from
    final long calendarId = cursor.getLong(cursor.getColumnIndexOrThrow(_ID));
    // Create the content value
    ContentValues cv = new ContentValues();
    cv.put(_ID, calendarId);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_TYPE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.CALENDAR_DISPLAY_NAME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CALENDAR_COLOR);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, VISIBLE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SYNC_EVENTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.CALENDAR_LOCATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CALENDAR_TIME_ZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.OWNER_ACCOUNT);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CAN_ORGANIZER_RESPOND);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CAN_MODIFY_TIME_ZONE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.MAX_REMINDERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CAN_PARTIALLY_UPDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.ALLOWED_REMINDERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    // Create the Entity from the ContentValue
    Entity entity = new Entity(cv);
    // Set cursor to next row
    cursor.moveToNext();
    // Return the created Entity
    return entity;
}","{
    // we expect the cursor is already at the row we need to read from
    final long calendarId = cursor.getLong(cursor.getColumnIndexOrThrow(_ID));
    // Create the content value
    ContentValues cv = new ContentValues();
    cv.put(_ID, calendarId);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_TYPE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, MUTATORS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.CALENDAR_DISPLAY_NAME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CALENDAR_COLOR);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.CALENDAR_COLOR_KEY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, VISIBLE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SYNC_EVENTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.CALENDAR_LOCATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CALENDAR_TIME_ZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.OWNER_ACCOUNT);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CAN_ORGANIZER_RESPOND);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CAN_MODIFY_TIME_ZONE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.MAX_REMINDERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, Calendars.CAN_PARTIALLY_UPDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Calendars.ALLOWED_REMINDERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    // Create the Entity from the ContentValue
    Entity entity = new Entity(cv);
    // Set cursor to next row
    cursor.moveToNext();
    // Return the created Entity
    return entity;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"Some of the code statements within the implementation have been altered; specifically, DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, {CAL_SYNC2, CAL_SYNC3, CAL_SYNC4, CALENDAR_COLOR}), so the code change type is 4.","These changes within the code imply that the return value might be altered, therefore causing potential issues for backwards compatibility, so the Compatibility Issue type is 1."
440,<android.content.res.Resources: Drawable getDrawable(int)>,17,18,<android.content.res.Resources: Drawable getDrawable(int)>,<android.content.res.Resources: Drawable getDrawable(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        return loadDrawable(value, id);
    }
}","{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        } else {
            mTmpValue = null;
        }
        getValue(id, value, true);
    }
    Drawable res = loadDrawable(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return res;
}",1,"/**
 * Return a drawable object associated with a particular resource ID.
 * Various types of objects will be returned depending on the underlying
 * resource -- for example, a solid color, PNG image, scalable image, etc.
 * The Drawable API hides these implementation details.
 *
 * <p class=""note""><strong>Note:</strong> Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, this function
 * would not correctly retrieve the final configuration density when
 * the resource ID passed here is an alias to another Drawable resource.
 * This means that if the density configuration of the alias resource
 * is different than the actual resource, the density of the returned
 * Drawable would be incorrect, resulting in bad scaling.  To work
 * around this, you can instead retrieve the Drawable through
 * {@link TypedArray#getDrawable TypedArray.getDrawable}.  Use
 * {@link android.content.Context#obtainStyledAttributes(int[])
 * Context.obtainStyledAttributes} with
 * an array containing the resource ID of interest to create the TypedArray.</p>
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Drawable An object that can be used to draw this resource.
 */
","/**
 * Return a drawable object associated with a particular resource ID.
 * Various types of objects will be returned depending on the underlying
 * resource -- for example, a solid color, PNG image, scalable image, etc.
 * The Drawable API hides these implementation details.
 *
 * <p class=""note""><strong>Note:</strong> Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, this function
 * would not correctly retrieve the final configuration density when
 * the resource ID passed here is an alias to another Drawable resource.
 * This means that if the density configuration of the alias resource
 * is different than the actual resource, the density of the returned
 * Drawable would be incorrect, resulting in bad scaling.  To work
 * around this, you can instead retrieve the Drawable through
 * {@link TypedArray#getDrawable TypedArray.getDrawable}.  Use
 * {@link android.content.Context#obtainStyledAttributes(int[])
 * Context.obtainStyledAttributes} with
 * an array containing the resource ID of interest to create the TypedArray.</p>
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Drawable An object that can be used to draw this resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is a change in the control flow with a new 'if' statement introduced and synchronized block being altered which interprets to Control dependency change (3). Additionally, 'return' statement is modified slightly which corresponds to Return statement changed (1). There is also the introduction of a new variable 'res' which is not a return or exception handling statement and doesn't involve dependent APIs. Hence, it falls under Other statement change (4).",The alteration in return statement along with the change in internal control flow could lead the API to potentially return different values in different scenarios in the updated version. This presents a Compatibility Issue of type 1 leading to potential different return values.
441,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,17,18,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,0,"{
    final int userId = mContext.getUserId();
    try {
        final List<ApplicationInfo> applicationInfos = new ArrayList<ApplicationInfo>();
        ApplicationInfo lastItem = null;
        ParceledListSlice<ApplicationInfo> slice;
        do {
            final String lastKey = lastItem != null ? lastItem.packageName : null;
            slice = mPM.getInstalledApplications(flags, lastKey, userId);
            lastItem = slice.populateList(applicationInfos, ApplicationInfo.CREATOR);
        } while (!slice.isLastSlice());
        return applicationInfos;
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    final int userId = mContext.getUserId();
    try {
        ParceledListSlice<ApplicationInfo> slice = mPM.getInstalledApplications(flags, userId);
        return slice.getList();
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,"[@SuppressWarnings(""unchecked""), @Override]","[@SuppressWarnings(""unchecked""), @Override]",-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version, the list slicing loop and the population of the list are removed. In its place, mPM.getInstalledApplications and slice.getList() are used. Therefore, the change types are 1 (Return statement changed) and 4 (Other statement changed).","The change in the way the list is populated and returned might potentially lead to a different return value. Hence, the Compatibility Issue type is 1 (Compatibility Issue caused by potential different return values or types)."
442,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",17,18,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>","<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",0,"{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, getUserId());
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}","{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, null, getUserId());
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The method of invoking the dependent API `startInstrumentation()` has changed from 6 parameters in the early version to 7 parameters in the late version, so the code change type is 5.","As the method invoking the dependent API `startInstrumentation()` has changed, it is likely that the return value from the API call may potentially change between versions, leading to a potential compatibility issue of category 1."
443,"<android.content.res.Resources: int getIdentifier(String,String,String)>",17,18,"<android.content.res.Resources: int getIdentifier(String,String,String)>","<android.content.res.Resources: int getIdentifier(String,String,String)>",0,"{
    try {
        return Integer.parseInt(name);
    } catch (Exception e) {
    // Ignore
    }
    return mAssets.getResourceIdentifier(name, defType, defPackage);
}","{
    if (name == null) {
        throw new NullPointerException(""name is null"");
    }
    try {
        return Integer.parseInt(name);
    } catch (Exception e) {
    // Ignore
    }
    return mAssets.getResourceIdentifier(name, defType, defPackage);
}",1,"/**
 * Return a resource identifier for the given resource name.  A fully
 * qualified resource name is of the form ""package:type/entry"".  The first
 * two components (package and type) are optional if defType and
 * defPackage, respectively, are specified here.
 *
 * <p>Note: use of this function is discouraged.  It is much more
 * efficient to retrieve resources by identifier than by name.
 *
 * @param name The name of the desired resource.
 * @param defType Optional default resource type to find, if ""type/"" is
 * not included in the name.  Can be null to require an
 * explicit type.
 * @param defPackage Optional default package to find, if ""package:"" is
 * not included in the name.  Can be null to require an
 * explicit package.
 *
 * @return int The associated resource identifier.  Returns 0 if no such
 * resource was found.  (0 is not a valid resource ID.)
 */
","/**
 * Return a resource identifier for the given resource name.  A fully
 * qualified resource name is of the form ""package:type/entry"".  The first
 * two components (package and type) are optional if defType and
 * defPackage, respectively, are specified here.
 *
 * <p>Note: use of this function is discouraged.  It is much more
 * efficient to retrieve resources by identifier than by name.
 *
 * @param name The name of the desired resource.
 * @param defType Optional default resource type to find, if ""type/"" is
 * not included in the name.  Can be null to require an
 * explicit type.
 * @param defPackage Optional default package to find, if ""package:"" is
 * not included in the name.  Can be null to require an
 * explicit package.
 *
 * @return int The associated resource identifier.  Returns 0 if no such
 * resource was found.  (0 is not a valid resource ID.)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,2","1,2","A control statement and exception handling statement has been introduced in the late version, so the change type is 3,2.","The introduced control statement will throw a different exception when name == null, and this also potentially results in a different value return, thus the CI type is 1,2."
444,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",17,18,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",0,"{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessage(activity, message);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessage(a, message);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessage(activity, message, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessage(a, message, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a static {@link NdefMessage} to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message is only made available for NDEF push when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code &lt;meta-data>} element inside the {@code &lt;application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessage(ndefMessage, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the NDEF message and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically generate an NDEF message,
 * then set a callback using {@link #setNdefPushMessageCallback} instead
 * of a static message.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
","/**
 * Set a static {@link NdefMessage} to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message is only made available for NDEF push when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code &lt;meta-data>} element inside the {@code &lt;application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessage(ndefMessage, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the NDEF message and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically generate an NDEF message,
 * then set a callback using {@link #setNdefPushMessageCallback} instead
 * of a static message.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method setNdefPushMessage() of mNfcActivityManager has an additional parameter in the late version of the implementation, therefore, the code change type is 5.","The added parameter '0' in setNdefPushMessage() does not alter the return value or exception handling of the method, hence there is no compatibility issue, so the CI type is 0."
445,"<android.accounts.AccountManager.AmsTask.Response: void onError(int,String)>",17,18,"<android.accounts.AccountManager.AmsTask.Response: void onError(int,String)>","<android.accounts.AccountManager.AmsTask.Response: void onError(int,String)>",0,"{
    if (code == ERROR_CODE_CANCELED) {
        // the authenticator indicated that this request was canceled, do so now
        cancel(true);
        return;
    }
    setException(convertErrorToException(code, message));
}","{
    if (code == ERROR_CODE_CANCELED || code == ERROR_CODE_USER_RESTRICTED) {
        // the authenticator indicated that this request was canceled, do so now
        cancel(true);
        return;
    }
    setException(convertErrorToException(code, message));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,"1,2","The condition statement after 'if' has changed, so the code change type is 3.","As the condition statement checking 'code' has changed, the behaviors following this condition check, either 'cancel(true); return;' or 'setException(convertErrorToException(code, message));' could lead to different states, thus it potentially returns a different value (1) or throws a different exception (2)."
446,<android.view.View: void setHasTransientState(boolean)>,17,18,<android.view.View: void setHasTransientState(boolean)>,<android.view.View: void setHasTransientState(boolean)>,0,"{
    mTransientStateCount = hasTransientState ? mTransientStateCount + 1 : mTransientStateCount - 1;
    if (mTransientStateCount < 0) {
        mTransientStateCount = 0;
        Log.e(VIEW_LOG_TAG, ""hasTransientState decremented below 0: "" + ""unmatched pair of setHasTransientState calls"");
    }
    if ((hasTransientState && mTransientStateCount == 1) || (!hasTransientState && mTransientStateCount == 0)) {
        // update flag if we've just incremented up from 0 or decremented down to 0
        mPrivateFlags2 = (mPrivateFlags2 & ~PFLAG2_HAS_TRANSIENT_STATE) | (hasTransientState ? PFLAG2_HAS_TRANSIENT_STATE : 0);
        if (mParent != null) {
            try {
                mParent.childHasTransientStateChanged(this, hasTransientState);
            } catch (AbstractMethodError e) {
                Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
            }
        }
    }
}","{
    mTransientStateCount = hasTransientState ? mTransientStateCount + 1 : mTransientStateCount - 1;
    if (mTransientStateCount < 0) {
        mTransientStateCount = 0;
        Log.e(VIEW_LOG_TAG, ""hasTransientState decremented below 0: "" + ""unmatched pair of setHasTransientState calls"");
    } else if ((hasTransientState && mTransientStateCount == 1) || (!hasTransientState && mTransientStateCount == 0)) {
        // update flag if we've just incremented up from 0 or decremented down to 0
        mPrivateFlags2 = (mPrivateFlags2 & ~PFLAG2_HAS_TRANSIENT_STATE) | (hasTransientState ? PFLAG2_HAS_TRANSIENT_STATE : 0);
        if (mParent != null) {
            try {
                mParent.childHasTransientStateChanged(this, hasTransientState);
            } catch (AbstractMethodError e) {
                Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
            }
        }
    }
}",1,"/**
 * Set whether this view is currently tracking transient state that the
 * framework should attempt to preserve when possible. This flag is reference counted,
 * so every call to setHasTransientState(true) should be paired with a later call
 * to setHasTransientState(false).
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @param hasTransientState true if this view has transient state
 */
","/**
 * Set whether this view is currently tracking transient state that the
 * framework should attempt to preserve when possible. This flag is reference counted,
 * so every call to setHasTransientState(true) should be paired with a later call
 * to setHasTransientState(false).
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @param hasTransientState true if this view has transient state
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The code change is an introduction of 'else if' condition in the control dependency, so the code change type is 3.","The introduction of 'else if' condition could change the control flow of the code, and thus, the output behavior may be different under certain conditions which brings the CI type to 1."
448,<android.view.accessibility.AccessibilityNodeInfo: boolean isAccessibilityFocused()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isAccessibilityFocused()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isAccessibilityFocused()>,0,"{
    return getBooleanProperty(PROPERTY_ACCESSIBILITY_FOCUSED);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_ACCESSIBILITY_FOCUSED);
}",1,"/**
 * Gets whether this node is accessibility focused.
 *
 * @return True if the node is accessibility focused.
 */
","/**
 * Gets whether this node is accessibility focused.
 *
 * @return True if the node is accessibility focused.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The usage of a dependent API, namely `getBooleanProperty`, has changed. Specifically, the parameter passed to this API has changed from `PROPERTY_ACCESSIBILITY_FOCUSED` to `BOOLEAN_PROPERTY_ACCESSIBILITY_FOCUSED`. Hence, the categories of the code change are 1 (return statement changed) and 5 (dependent API changed).","Given the nature of the API's change (in particular, a different parameter is used in the `getBooleanProperty` call), the method can potentially return a different result in the later version compared to the earlier version. As such, this change could lead to compatibility issues, and it falls into category 1 (compatibility issues caused by potential different return values or types)."
449,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",17,18,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].setAllowFds(false);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData();
        intents[i].prepareToLeaveProcess();
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The first Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class)} Intent.setClass</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the loop, the method calls on intentions[i] from early version to late version have changed i.e. 'setAllowFds(false)' to 'migrateExtraStreamToClipData()' and 'prepareToLeaveProcess()' So, the code change type is 4,5.","As different methods are called on 'intents[i]' which might change the state of 'intents[i]' thereby influencing 'resolvedTypes[i]' and further influencing 'target' variable. Hence, potentially affecting the return values. Thus, the CI type is 1."
450,<android.app.ContextImpl: String getPackageName()>,17,18,<android.app.ContextImpl: String getPackageName()>,<android.app.ContextImpl: String getPackageName()>,0,"{
    if (mPackageInfo != null) {
        return mPackageInfo.getPackageName();
    }
    throw new RuntimeException(""Not supported in system context"");
}","{
    if (mPackageInfo != null) {
        return mPackageInfo.getPackageName();
    }
    // and this here is its name.
    return ""android"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2","1,2","The exception handling and return statement have both changed. The old version throws an exception if mPackageInfo is null, while the new version returns ""android"". Thus, the change type is 1,2.","The change in exception handling and return statement may cause the function to behave differently between the two versions. In the early version, a RuntimeException is thrown when mPackageInfo is null, while in the later version, the string ""android"" is returned instead. Thus, the CI type is 1,2."
451,<android.os.Bundle: CharSequence getCharSequence(String)>,17,18,<android.os.Bundle: CharSequence getCharSequence(String)>,<android.os.Bundle: CharSequence getCharSequence(String)>,0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (CharSequence) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""CharSequence"", e);
        return null;
    }
}","{
    unparcel();
    final Object o = mMap.get(key);
    try {
        return (CharSequence) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""CharSequence"", e);
        return null;
    }
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence value, or null
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, only the declaration of ""o"" is changed, being declared as final, which is categorized as 4 (Other statement changed)","The 'final' keyword here does not affect the return value or exceptions consequently, does not cause a compatibility issue. Hence, the code change does not lead to CI. As a result, the CI type is 0."
453,<android.view.ViewGroup.MarginLayoutParams: int getMarginStart()>,17,18,<android.view.ViewGroup.MarginLayoutParams: int getMarginStart()>,<android.view.ViewGroup.MarginLayoutParams: int getMarginStart()>,0,"{
    if (startMargin != DEFAULT_RELATIVE)
        return startMargin;
    switch(layoutDirection) {
        case View.LAYOUT_DIRECTION_RTL:
            return rightMargin;
        case View.LAYOUT_DIRECTION_LTR:
        default:
            return leftMargin;
    }
}","{
    if (startMargin != DEFAULT_MARGIN_RELATIVE)
        return startMargin;
    if ((mMarginFlags & NEED_RESOLUTION_MASK) == NEED_RESOLUTION_MASK) {
        doResolveMargins();
    }
    switch(mMarginFlags & LAYOUT_DIRECTION_MASK) {
        case View.LAYOUT_DIRECTION_RTL:
            return rightMargin;
        case View.LAYOUT_DIRECTION_LTR:
        default:
            return leftMargin;
    }
}",1,"/**
 * Returns the start margin in pixels.
 *
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 *
 * @return the start margin in pixels.
 */
","/**
 * Returns the start margin in pixels.
 *
 * @attr ref android.R.styleable#ViewGroup_MarginLayout_layout_marginStart
 *
 * @return the start margin in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the code implementation, the condition for the first 'if' statement has slightly changed. An 'if' condition and the method call doResolveMargins() have been added before the 'switch' statement. In addition, the condition for 'switch' has also changed. So the code change types are 1,3,4.","The changes in the return conditions (added condition and change of 'switch' condition), may result in a different return value. So the CI type is 1."
454,"<android.os.Bundle: String getString(String,String)>",17,18,"<android.os.Bundle: String getString(String,String)>","<android.os.Bundle: String getString(String,String)>",0,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (String) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""String"", e);
        return defaultValue;
    }
}","{
    final String s = getString(key);
    return (s == null) ? defaultValue : s;
}",1,"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String, or null
 * @param defaultValue Value to return if key does not exist
 * @return a String value, or null
 */
","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String, or null
 * @param defaultValue Value to return if key does not exist
 * @return the String value associated with the given key, or defaultValue
 * if no valid String object is currently mapped to that key.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the method has undergone significant changes with modified return statements. In the later version, the entire block of exception handling, along with some logic about getting the value from the ""mMap"", has been replaced with a single line of string acquisition and check. Therefore, the code change type falls into categories 1 and 4.","Due to the change in how the method operates, particularly the removed exception handling and the modification of the ""return"" statement, the method may potentially return different results in different versions. It could even potentially result in a NullPointerException if ""key"" is not found in the map. Therefore, this falls into the compatibility issue category 1."
455,"<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>",17,18,"<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // If the view isn't an AdapterView, setting a PendingIntent template doesn't make sense
    if (target instanceof AdapterView<?>) {
        AdapterView<?> av = (AdapterView<?>) target;
        // The PendingIntent template is stored in the view's tag.
        OnItemClickListener listener = new OnItemClickListener() {

            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The view should be a frame layout
                if (view instanceof ViewGroup) {
                    ViewGroup vg = (ViewGroup) view;
                    // so we need to go one layer deeper here.
                    if (parent instanceof AdapterViewAnimator) {
                        vg = (ViewGroup) vg.getChildAt(0);
                    }
                    if (vg == null)
                        return;
                    Intent fillInIntent = null;
                    int childCount = vg.getChildCount();
                    for (int i = 0; i < childCount; i++) {
                        Object tag = vg.getChildAt(i).getTag(com.android.internal.R.id.fillInIntent);
                        if (tag instanceof Intent) {
                            fillInIntent = (Intent) tag;
                            break;
                        }
                    }
                    if (fillInIntent == null)
                        return;
                    final float appScale = view.getContext().getResources().getCompatibilityInfo().applicationScale;
                    final int[] pos = new int[2];
                    view.getLocationOnScreen(pos);
                    final Rect rect = new Rect();
                    rect.left = (int) (pos[0] * appScale + 0.5f);
                    rect.top = (int) (pos[1] * appScale + 0.5f);
                    rect.right = (int) ((pos[0] + view.getWidth()) * appScale + 0.5f);
                    rect.bottom = (int) ((pos[1] + view.getHeight()) * appScale + 0.5f);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(view, pendingIntentTemplate, fillInIntent);
                }
            }
        };
        av.setOnItemClickListener(listener);
        av.setTag(pendingIntentTemplate);
    } else {
        Log.e(""RemoteViews"", ""Cannot setPendingIntentTemplate on a view which is not"" + ""an AdapterView (id: "" + viewId + "")"");
        return;
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // If the view isn't an AdapterView, setting a PendingIntent template doesn't make sense
    if (target instanceof AdapterView<?>) {
        AdapterView<?> av = (AdapterView<?>) target;
        // The PendingIntent template is stored in the view's tag.
        OnItemClickListener listener = new OnItemClickListener() {

            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The view should be a frame layout
                if (view instanceof ViewGroup) {
                    ViewGroup vg = (ViewGroup) view;
                    // so we need to go one layer deeper here.
                    if (parent instanceof AdapterViewAnimator) {
                        vg = (ViewGroup) vg.getChildAt(0);
                    }
                    if (vg == null)
                        return;
                    Intent fillInIntent = null;
                    int childCount = vg.getChildCount();
                    for (int i = 0; i < childCount; i++) {
                        Object tag = vg.getChildAt(i).getTag(com.android.internal.R.id.fillInIntent);
                        if (tag instanceof Intent) {
                            fillInIntent = (Intent) tag;
                            break;
                        }
                    }
                    if (fillInIntent == null)
                        return;
                    final float appScale = view.getContext().getResources().getCompatibilityInfo().applicationScale;
                    final int[] pos = new int[2];
                    view.getLocationOnScreen(pos);
                    final Rect rect = new Rect();
                    rect.left = (int) (pos[0] * appScale + 0.5f);
                    rect.top = (int) (pos[1] * appScale + 0.5f);
                    rect.right = (int) ((pos[0] + view.getWidth()) * appScale + 0.5f);
                    rect.bottom = (int) ((pos[1] + view.getHeight()) * appScale + 0.5f);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(view, pendingIntentTemplate, fillInIntent);
                }
            }
        };
        av.setOnItemClickListener(listener);
        av.setTag(pendingIntentTemplate);
    } else {
        Log.e(LOG_TAG, ""Cannot setPendingIntentTemplate on a view which is not"" + ""an AdapterView (id: "" + viewId + "")"");
        return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is purely cosmetic, as ""RemoteViews"" in the Log.e method has been replaced by ""LOG_TAG"", so the code change type is 4.","This purely cosmetic change does not affect the behaviour or return value of the API, so no Compatibility Issue exists. Therefore, the CI type is 0."
457,<android.content.res.Resources: int getColor(int)>,17,18,<android.content.res.Resources: int getColor(int)>,<android.content.res.Resources: int getColor(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            return value.data;
        } else if (value.type == TypedValue.TYPE_STRING) {
            ColorStateList csl = loadColorStateList(mTmpValue, id);
            return csl.getDefaultColor();
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    TypedValue value;
    synchronized (mAccessLock) {
        value = mTmpValue;
        if (value == null) {
            value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type >= TypedValue.TYPE_FIRST_INT && value.type <= TypedValue.TYPE_LAST_INT) {
            mTmpValue = value;
            return value.data;
        } else if (value.type != TypedValue.TYPE_STRING) {
            throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
        }
        mTmpValue = null;
    }
    ColorStateList csl = loadColorStateList(value, id);
    synchronized (mAccessLock) {
        if (mTmpValue == null) {
            mTmpValue = value;
        }
    }
    return csl.getDefaultColor();
}",1,"/**
 * Return a color integer associated with a particular resource ID.
 * If the resource holds a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
","/**
 * Return a color integer associated with a particular resource ID.
 * If the resource holds a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a single color value in the form 0xAARRGGBB.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The API behavior has changed significantly. There are changes in exception handling, control dependencies, return statements, and other statements. There are additional checks on variable 'value' and the synchronized part of code segment also has been updated.","The return statements change and introduction of a new exception handling mean the function behaves differently in two versions. Operrations in different versions may return distinct values and throw different exceptions. So, it is identified as compatibility issue 1 and 2."
459,<android.appwidget.AppWidgetHostView: View getDefaultView()>,17,18,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContext(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContextAsUser(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED, mUser);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method call createPackageContext() is replaced by createPackageContextAsUser() where an additional parameter 'mUser' is added, hence the detected change is type 5 (Dependent API changed).","This change can potentially lead to a different return value of the method, thus a potential Compatibility Issue exist due to different return values or types, hence it belongs to CI type 1."
461,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,17,18,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession(getMainLooper());
    mWindow.setSession(mSession);
    mScreenOn = ((PowerManager) getSystemService(Context.POWER_SERVICE)).isScreenOn();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mScreenOn = ((PowerManager) getSystemService(Context.POWER_SERVICE)).isScreenOn();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API WindowManagerGlobal.getWindowSession(getMainLooper()) has changed to WindowManagerGlobal.getWindowSession(), so the code change type is 5.","As the dependent API call WindowManagerGlobal.getWindowSession(getMainLooper()) changed to WindowManagerGlobal.getWindowSession(), it might return a different value. Therefore, the CI type is 1."
462,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>",17,18,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>","<android.text.util.Linkify: boolean addLinks(Spannable,int)>",0,"{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Patterns.WEB_URL, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Patterns.EMAIL_ADDRESS, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherLinks(links, text, Patterns.PHONE, new String[] { ""tel:"" }, sPhoneNumberMatchFilter, sPhoneNumberTransformFilter);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}","{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Patterns.WEB_URL, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Patterns.EMAIL_ADDRESS, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherTelLinks(links, text);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}",1,"/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 */
","/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,2,"The method ""gatherLinks()"" with ""Patterns.PHONE"" and ""tel:"" parameters has changed to a different method ""gatherTelLinks()"". This suggests a dependent API change, categorizing the change under category 5.","The changed method ""gatherTelLinks()"" might throw exceptions differently considering it's a different implementation compared to the previous ""gatherLinks()"". This could potentially cause a compatibility issue by altering exception handling, which leads to CI category 2."
464,<android.widget.Toast.TN: void handleShow()>,17,18,<android.widget.Toast.TN: void handleShow()>,<android.widget.Toast.TN: void handleShow()>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        mWM = (WindowManager) mView.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        Context context = mView.getContext().getApplicationContext();
        if (context == null) {
            context = mView.getContext();
        }
        mWM = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new variable definition 'Context context = mView.getContext().getApplicationContext();' and a new if statement for checking if context is null have been added in the late implementation. So the change types are 3,4.","Although there are variable additions and conditional checks, these changes will not affect the final output of the method or cause this method to throw any exceptions. Hence, no compatibility issues exist."
465,<android.view.accessibility.AccessibilityNodeInfo: boolean isPassword()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isPassword()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isPassword()>,0,"{
    return getBooleanProperty(PROPERTY_PASSWORD);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_PASSWORD);
}",1,"/**
 * Gets whether this node is a password.
 *
 * @return True if the node is a password.
 */
","/**
 * Gets whether this node is a password.
 *
 * @return True if the node is a password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter passed to getBooleanProperty() function has changed, resulting in a change in the return statement and the dependent API. Therefore, the type of code change is 1,5.","Since the parameter of getBooleanProperty() function altered, it means this method might return different results in the newer version leading to CI type 1."
466,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,17,18,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.release();
            break;
        case MSG_IME_FINISHED_EVENT:
            handleImeFinishedEvent(msg.arg1, msg.arg2 != 0);
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingContentInsets.equals(args.arg2) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                if (mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mHolder.getSurface())) {
                                    mFullRedrawNeeded = true;
                                }
                            } catch (Surface.OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    setAccessibilityFocus(null, null);
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_KEY:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_DISPATCH_SCREEN_STATE:
            {
                if (mView != null) {
                    handleScreenStateChange(msg.arg1 == 1);
                }
            }
            break;
        case MSG_INVALIDATE_DISPLAY_LIST:
            {
                invalidateDisplayLists();
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mHolder.getSurface());
                            } catch (Surface.OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    setAccessibilityFocus(null, null);
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_KEY:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_DISPATCH_SCREEN_STATE:
            {
                if (mView != null) {
                    handleScreenStateChange(msg.arg1 == 1);
                }
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
469,"<android.app.ContextImpl: boolean stopServiceAsUser(Intent,UserHandle)>",17,18,"<android.app.ContextImpl: boolean stopServiceAsUser(Intent,UserHandle)>","<android.app.ContextImpl: boolean stopServiceAsUser(Intent,UserHandle)>",0,"{
    try {
        service.setAllowFds(false);
        int res = ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());
        if (res < 0) {
            throw new SecurityException(""Not allowed to stop service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        service.prepareToLeaveProcess();
        int res = ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());
        if (res < 0) {
            throw new SecurityException(""Not allowed to stop service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The invocation of a method on the ""service"" object has changed from setAllowFds(false) to prepareToLeaveProcess() in the two versions. Hence, the code change type is 4.","There should not exist any potential compatibility issue. Since the object ""service"" has changed a method call, but the resultant return statement or the exception handling processes are not affected. Thus, the CI type is 0."
470,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",17,18,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false, getUserId());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, AppOpsManager.OP_NONE, false, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called on the `intent` object has changed from `setAllowFds(false)` to `prepareToLeaveProcess()`. In addition, in the method `broadcastIntent()`, the parameter has changed from `false` to `AppOpsManager.OP_NONE`. Therefore, the change type is 1,5.","The change of method and parameters might cause the method `sendBroadcast()` to behave differently in late version, potentially leading to a different return value or output. Therefore, the CI type is 1."
471,"<android.widget.Spinner.DropDownAdapter: View getDropDownView(int,View,ViewGroup)>",17,18,"<android.widget.Spinner.DropDownAdapter: View getDropDownView(int,View,ViewGroup)>","<android.widget.Spinner.DropDownAdapter: View getDropDownView(int,View,ViewGroup)>",0,"{
    return mAdapter == null ? null : mAdapter.getDropDownView(position, convertView, parent);
}","{
    return (mAdapter == null) ? null : mAdapter.getDropDownView(position, convertView, parent);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no actual code change. The only difference is the addition of parentheses which doesn't affect the behavior of the code.,"As there is no change in any return statement, in exception handling, or any other statement, so no compatibility issue could exist."
472,<android.animation.ValueAnimator: void setObjectValues(Object)>,17,18,<android.animation.ValueAnimator: void setObjectValues(Object)>,<android.animation.ValueAnimator: void setObjectValues(Object)>,0,"{
    if (values == null || values.length == 0) {
        return;
    }
    if (mValues == null || mValues.length == 0) {
        setValues(new PropertyValuesHolder[] { PropertyValuesHolder.ofObject("""", (TypeEvaluator) null, values) });
    } else {
        PropertyValuesHolder valuesHolder = mValues[0];
        valuesHolder.setObjectValues(values);
    }
    // New property/values/target should cause re-initialization prior to starting
    mInitialized = false;
}","{
    if (values == null || values.length == 0) {
        return;
    }
    if (mValues == null || mValues.length == 0) {
        setValues(PropertyValuesHolder.ofObject("""", null, values));
    } else {
        PropertyValuesHolder valuesHolder = mValues[0];
        valuesHolder.setObjectValues(values);
    }
    // New property/values/target should cause re-initialization prior to starting
    mInitialized = false;
}",1,"/**
 * Sets the values to animate between for this animation. A single
 * value implies that that value is the one being animated to. However, this is not typically
 * useful in a ValueAnimator object because there is no way for the object to determine the
 * starting value for the animation (unlike ObjectAnimator, which can derive that value
 * from the target object and property being animated). Therefore, there should typically
 * be two or more values.
 *
 * <p>If there are already multiple sets of values defined for this ValueAnimator via more
 * than one PropertyValuesHolder object, this method will set the values for the first
 * of those objects.</p>
 *
 * <p>There should be a TypeEvaluator set on the ValueAnimator that knows how to interpolate
 * between these value objects. ValueAnimator only knows how to interpolate between the
 * primitive types specified in the other setValues() methods.</p>
 *
 * @param values The set of values to animate between.
 */
","/**
 * Sets the values to animate between for this animation. A single
 * value implies that that value is the one being animated to. However, this is not typically
 * useful in a ValueAnimator object because there is no way for the object to determine the
 * starting value for the animation (unlike ObjectAnimator, which can derive that value
 * from the target object and property being animated). Therefore, there should typically
 * be two or more values.
 *
 * <p>If there are already multiple sets of values defined for this ValueAnimator via more
 * than one PropertyValuesHolder object, this method will set the values for the first
 * of those objects.</p>
 *
 * <p>There should be a TypeEvaluator set on the ValueAnimator that knows how to interpolate
 * between these value objects. ValueAnimator only knows how to interpolate between the
 * primitive types specified in the other setValues() methods.</p>
 *
 * @param values The set of values to animate between.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The call of setValues() function has been changed from new PropertyValuesHolder[] { PropertyValuesHolder.ofObject("""", (TypeEvaluator) null, values) } to PropertyValuesHolder.ofObject("""", null, values) in the if block. The dependent API has changed (used null instead of (TypeEvaluator) null), and it is an ""other"" type of change as well. So the change type is 1,4,5.","As the dependent API has changed, setValues() function might return different values in the early version and late version. Therefore, the CI type is 1."
473,<android.app.Notification.BigTextStyle: BigTextStyle bigText(CharSequence)>,17,18,<android.app.Notification.BigTextStyle: BigTextStyle bigText(CharSequence)>,<android.app.Notification.BigTextStyle: BigTextStyle bigText(CharSequence)>,0,"{
    mBigText = cs;
    return this;
}","{
    mBigText = safeCharSequence(cs);
    return this;
}",1,"/**
 * Provide the longer text to be displayed in the big form of the
 * template in place of the content text.
 */
","/**
 * Provide the longer text to be displayed in the big form of the
 * template in place of the content text.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changed by replacing mBigText = cs; to mBigText = safeCharSequence(cs); Hence, both another statement is changed (type 4) and the dependent API transformed from cs to safeCharSequence(cs) (type 5).","Though the function implementation changed, the potential behaviour of the function remains the same, i.e., it doesn't lead to a potential change in the return value or exceptions that the function may throw. Therefore, no Compatibility Issues arise from this change."
475,<android.view.VelocityTracker: VelocityTracker obtain()>,17,18,<android.view.VelocityTracker: VelocityTracker obtain()>,<android.view.VelocityTracker: VelocityTracker obtain()>,0,"{
    return sPool.acquire();
}","{
    VelocityTracker instance = sPool.acquire();
    return (instance != null) ? instance : new VelocityTracker(null);
}",1,"/**
 * Retrieve a new VelocityTracker object to watch the velocity of a
 * motion.  Be sure to call {@link #recycle} when done.  You should
 * generally only maintain an active object while tracking a movement,
 * so that the VelocityTracker can be re-used elsewhere.
 *
 * @return Returns a new VelocityTracker.
 */
","/**
 * Retrieve a new VelocityTracker object to watch the velocity of a
 * motion.  Be sure to call {@link #recycle} when done.  You should
 * generally only maintain an active object while tracking a movement,
 * so that the VelocityTracker can be re-used elsewhere.
 *
 * @return Returns a new VelocityTracker.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement in the late version API has changed where it introduces a new condition statement to check if the pooled instance is not null. If the instance is null, a new VelocityTracker object is assigned. The changes fall under the categories: Return statement change(1) and Control statement change(3).","The late version of the API can potentially return a different value which can either be the instance from the pool or a newly created VelocityTracker object (when the pooled instance is null). Thus, it can lead to a Compatibility Issue of type: potential different return values or types (1)."
476,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>",17,18,"<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>","<android.appwidget.AppWidgetManager: void partiallyUpdateAppWidget(int[],RemoteViews)>",0,"{
    try {
        sService.partiallyUpdateAppWidgetIds(appWidgetIds, views);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.partiallyUpdateAppWidgetIds(appWidgetIds, views, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Perform an incremental update or command on the widget(s) specified by appWidgetIds.
 *
 * This update  differs from {@link #updateAppWidget(int[], RemoteViews)} in that the
 * RemoteViews object which is passed is understood to be an incomplete representation of the
 * widget, and hence does not replace the cached representation of the widget. As of API
 * level 17, the new properties set within the views objects will be appended to the cached
 * representation of the widget, and hence will persist.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
","/**
 * Perform an incremental update or command on the widget(s) specified by appWidgetIds.
 *
 * This update  differs from {@link #updateAppWidget(int[], RemoteViews)} in that the
 * RemoteViews object which is passed is understood to be an incomplete representation of the
 * widget, and hence does not replace the cached representation of the widget. As of API
 * level 17, the new properties set within the views objects will be appended to the cached
 * representation of the widget, and hence will persist.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method 'sService.partiallyUpdateAppWidgetIds' has been changed to add another parameter 'mContext.getUserId()', which means the dependent API 'partiallyUpdateAppWidgetIds' has changed and the return value of the method might be changed. So the code change types are 1 and 5.","Since the dependent API 'partiallyUpdateAppWidgetIds' has been adjusted with an additional parameter, it may change the behavior and return a different result. Therefore, a compatibility issue is identified and it's caused by a potential difference in return values, which is type 1."
477,<android.content.ClipboardManager: ClipData getPrimaryClip()>,17,18,<android.content.ClipboardManager: ClipData getPrimaryClip()>,<android.content.ClipboardManager: ClipData getPrimaryClip()>,0,"{
    try {
        return getService().getPrimaryClip(mContext.getPackageName());
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return getService().getPrimaryClip(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Returns the current primary clip on the clipboard.
 */
","/**
 * Returns the current primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API has changed from getPrimaryClip(mContext.getPackageName()) to getPrimaryClip(mContext.getBasePackageName()) and the return statement also has been adjusted correspondingly. Therefore, the change type is 1,5.","The change of return statement will make the API potentially return a different value which leads to a compatibility issue of potential different return values or types, so the CI type is 1."
478,<android.view.accessibility.AccessibilityNodeInfo: boolean isChecked()>,17,18,<android.view.accessibility.AccessibilityNodeInfo: boolean isChecked()>,<android.view.accessibility.AccessibilityNodeInfo: boolean isChecked()>,0,"{
    return getBooleanProperty(PROPERTY_CHECKED);
}","{
    return getBooleanProperty(BOOLEAN_PROPERTY_CHECKED);
}",1,"/**
 * Gets whether this node is checked.
 *
 * @return True if the node is checked.
 */
","/**
 * Gets whether this node is checked.
 *
 * @return True if the node is checked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The call to getBooleanProperty in the return statement has changed its parameter from PROPERTY_CHECKED to BOOLEAN_PROPERTY_CHECKED, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
479,"<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>",17,18,"<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>","<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>",0,"{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isClickable()) {
                    performClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    performLongClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_FOCUS:
            {
                if (!hasFocus()) {
                    // Get out of touch mode since accessibility
                    // wants to move focus around.
                    getViewRootImpl().ensureTouchMode(false);
                    return requestFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
            {
                if (hasFocus()) {
                    clearFocus();
                    return !isFocused();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (!isSelected()) {
                    setSelected(true);
                    return isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (isSelected()) {
                    setSelected(false);
                    return !isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
            {
                if (!isAccessibilityFocused()) {
                    return requestAccessibilityFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
            {
                if (isAccessibilityFocused()) {
                    clearAccessibilityFocus();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    return nextAtGranularity(granularity);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    return previousAtGranularity(granularity);
                }
            }
            break;
    }
    return false;
}","{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isClickable()) {
                    performClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    performLongClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_FOCUS:
            {
                if (!hasFocus()) {
                    // Get out of touch mode since accessibility
                    // wants to move focus around.
                    getViewRootImpl().ensureTouchMode(false);
                    return requestFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
            {
                if (hasFocus()) {
                    clearFocus();
                    return !isFocused();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (!isSelected()) {
                    setSelected(true);
                    return isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (isSelected()) {
                    setSelected(false);
                    return !isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
            {
                if (!isAccessibilityFocused()) {
                    return requestAccessibilityFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
            {
                if (isAccessibilityFocused()) {
                    clearAccessibilityFocus();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    final boolean extendSelection = arguments.getBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN);
                    return traverseAtGranularity(granularity, true, extendSelection);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    final boolean extendSelection = arguments.getBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN);
                    return traverseAtGranularity(granularity, false, extendSelection);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                CharSequence text = getIterableTextForAccessibility();
                if (text == null) {
                    return false;
                }
                final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                // Only cursor position can be specified (selection length == 0)
                if ((getAccessibilitySelectionStart() != start || getAccessibilitySelectionEnd() != end) && (start == end)) {
                    setAccessibilitySelection(start, end);
                    notifyAccessibilityStateChanged();
                    return true;
                }
            }
            break;
    }
    return false;
}",1,"/**
 * @see #performAccessibilityAction(int, Bundle)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
","/**
 * @see #performAccessibilityAction(int, Bundle)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are multiple changes in the method 'performAccessibilityActionInternal'. It includes addition of case 'AccessibilityNodeInfo.ACTION_SET_SELECTION' and its corresponding return statements, and alteration in case 'AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY' and 'AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY'. There is also a change in parameters of traverseAtGranularity. These could be classified as 1,3,4.",The changes made in the method can result in API producing different return values. Hence CI type is 1.
480,<android.view.GestureDetector.GestureHandler: void handleMessage(Message)>,17,18,<android.view.GestureDetector.GestureHandler: void handleMessage(Message)>,<android.view.GestureDetector.GestureHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case SHOW_PRESS:
            mListener.onShowPress(mCurrentDownEvent);
            break;
        case LONG_PRESS:
            dispatchLongPress();
            break;
        case TAP:
            // If the user's finger is still down, do not count it as a tap
            if (mDoubleTapListener != null && !mStillDown) {
                mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent);
            }
            break;
        default:
            // never
            throw new RuntimeException(""Unknown message "" + msg);
    }
}","{
    switch(msg.what) {
        case SHOW_PRESS:
            mListener.onShowPress(mCurrentDownEvent);
            break;
        case LONG_PRESS:
            dispatchLongPress();
            break;
        case TAP:
            // If the user's finger is still down, do not count it as a tap
            if (mDoubleTapListener != null) {
                if (!mStillDown) {
                    mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent);
                } else {
                    mDeferConfirmSingleTap = true;
                }
            }
            break;
        default:
            // never
            throw new RuntimeException(""Unknown message "" + msg);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The additional 'if' statement logic has been included in the case TAP of the switch statement, making it a type 3 - Control dependency change. The change is specifically on the additional else branch.","However, this change does not lead to a compatibility issue as it doesn't alter the method's potential return values or exception handling behaviors. Therefore, the CI type is 0."
481,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>",17,18,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>","<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>",0,"{
    try {
        return mContentProvider.openFile(url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.openFile(mPackageName, url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method name of the dependent API has remained the same but an additional argument ""mPackageName"" has been introduced to the method ""mContentProvider.openFile"", thus the code change type is 1 (Return statement changed) and 5 (Dependent API changed).","The introduction of ""mPackageName"" as an additional argument to the method may cause the method to return a different value, thus leading to a potential Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
482,"<android.speech.tts.TextToSpeech.Connection: void onServiceConnected(ComponentName,IBinder)>",17,18,"<android.speech.tts.TextToSpeech.Connection: void onServiceConnected(ComponentName,IBinder)>","<android.speech.tts.TextToSpeech.Connection: void onServiceConnected(ComponentName,IBinder)>",0,"{
    Log.i(TAG, ""Connected to "" + name);
    synchronized (mStartLock) {
        if (mServiceConnection != null) {
            // Disconnect any previous service connection
            mServiceConnection.disconnect();
        }
        mServiceConnection = this;
        mService = ITextToSpeechService.Stub.asInterface(service);
        try {
            mService.setCallback(getCallerIdentity(), mCallback);
            dispatchOnInit(SUCCESS);
        } catch (RemoteException re) {
            Log.e(TAG, ""Error connecting to service, setCallback() failed"");
            dispatchOnInit(ERROR);
        }
    }
}","{
    synchronized (mStartLock) {
        mConnectingServiceConnection = null;
        Log.i(TAG, ""Connected to "" + name);
        if (mOnSetupConnectionAsyncTask != null) {
            mOnSetupConnectionAsyncTask.cancel(false);
        }
        mService = ITextToSpeechService.Stub.asInterface(service);
        mServiceConnection = Connection.this;
        mEstablished = false;
        mOnSetupConnectionAsyncTask = new SetupConnectionAsyncTask(name);
        mOnSetupConnectionAsyncTask.execute();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"There's a variety of changes happening in the code, including several control dependency changes (e.g., the introduction and deletion of several 'if' conditions), changes in other statements (e.g., logging statements, synchronization block content, and the introduction of 'SetupConnectionAsyncTask'), and changes in the APIs it relies on (e.g., the removal of 'setCallback' and 'dispatchOnInit' and the introduction of 'asInterface'). Thus, the change type is 3,4,5.","Despite the changes, none of them would lead to different variables being returned or exceptions being thrown, so there's no Compatibility Issue, thus the CI type is 0."
485,<android.view.InputDevice: String toString()>,17,18,<android.view.InputDevice: String toString()>,<android.view.InputDevice: String toString()>,0,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"A new statement 'description.append("" resolution="").append(range.mResolution);' has been added to the loop, so the change type is 1,4.","This change will make the API return different values in the new version if the previous versions because of the added string "" resolution=..."", so the CI type is 1."
486,<android.app.Notification.InboxStyle: InboxStyle setBigContentTitle(CharSequence)>,17,18,<android.app.Notification.InboxStyle: InboxStyle setBigContentTitle(CharSequence)>,<android.app.Notification.InboxStyle: InboxStyle setBigContentTitle(CharSequence)>,0,"{
    internalSetBigContentTitle(title);
    return this;
}","{
    internalSetBigContentTitle(safeCharSequence(title));
    return this;
}",1,"/**
 * Overrides ContentTitle in the big form of the template.
 * This defaults to the value passed to setContentTitle().
 */
","/**
 * Overrides ContentTitle in the big form of the template.
 * This defaults to the value passed to setContentTitle().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method internalSetBigContentTitle is called with a different argument in the late version of API verse early version, and the 'title' parameter is wrapped with a new method safeCharSequence. So the code change type is 1,5.","Due to the change of the title that might affect the result that internalSetBigContentTitle() returns, it is possible that this API would return a different results. So the CI type is 1."
487,<android.appwidget.AppWidgetHost: void deleteHost()>,17,18,<android.appwidget.AppWidgetHost: void deleteHost()>,<android.appwidget.AppWidgetHost: void deleteHost()>,0,"{
    try {
        sService.deleteHost(mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.deleteHost(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
","/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The statement inside the try block has changed, with an additional parameter added in the method sService.deleteHost(). Therefore, the code change type is 1,5.","Even though there's a change in the statement inside the try block, it does not lead to a different return value or exception handling. Hence, no Compatibility Issue exists, and the CI type is 0."
488,<android.hardware.input.InputManager: InputDevice getInputDevice(int)>,17,18,<android.hardware.input.InputManager: InputDevice getInputDevice(int)>,<android.hardware.input.InputManager: InputDevice getInputDevice(int)>,0,"{
    synchronized (mInputDevicesLock) {
        populateInputDevicesLocked();
        int index = mInputDevices.indexOfKey(id);
        if (index < 0) {
            return null;
        }
        InputDevice inputDevice = mInputDevices.valueAt(index);
        if (inputDevice == null) {
            try {
                inputDevice = mIm.getInputDevice(id);
            } catch (RemoteException ex) {
                throw new RuntimeException(""Could not get input device information."", ex);
            }
        }
        mInputDevices.setValueAt(index, inputDevice);
        return inputDevice;
    }
}","{
    synchronized (mInputDevicesLock) {
        populateInputDevicesLocked();
        int index = mInputDevices.indexOfKey(id);
        if (index < 0) {
            return null;
        }
        InputDevice inputDevice = mInputDevices.valueAt(index);
        if (inputDevice == null) {
            try {
                inputDevice = mIm.getInputDevice(id);
            } catch (RemoteException ex) {
                throw new RuntimeException(""Could not get input device information."", ex);
            }
            if (inputDevice != null) {
                mInputDevices.setValueAt(index, inputDevice);
            }
        }
        return inputDevice;
    }
}",1,"/**
 * Gets information about the input device with the specified id.
 * @param id The device id.
 * @return The input device or null if not found.
 */
","/**
 * Gets information about the input device with the specified id.
 * @param id The device id.
 * @return The input device or null if not found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, there is an added condition 'if (inputDevice != null)' compared to the early version. Inside this condition there is a statement that was previously not conditioned in the early version. So, change types are 3 and 4.","Due to the presence of the added condition 'if (inputDevice != null)', the assignment of 'inputDevice' to 'mInputDevices' at the specific index may not always happen unlike in the early version where it always happens. This can lead to potentially different return values when 'return inputDevice' is called leading to CI type 1."
493,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",17,18,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>","<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile != null) {
            cleanUp();
            throw new IllegalArgumentException(""FileSynthesisRequest.start() called twice"");
        }
        if (!maybeCleanupExistingFile(mFileName)) {
            return TextToSpeech.ERROR;
        }
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        try {
            mFile = new RandomAccessFile(mFileName, ""rw"");
            // Reserve space for WAV header
            mFile.write(new byte[WAV_HEADER_LENGTH]);
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to open "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mStarted) {
            cleanUp();
            throw new IllegalArgumentException(""FileSynthesisRequest.start() called twice"");
        }
        mStarted = true;
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        try {
            mFileChannel.write(ByteBuffer.allocate(WAV_HEADER_LENGTH));
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write wav header to output file descriptor"" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2",Multiple changes occured between the two versions: ,3) Exception message has been changed.
495,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,17,18,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,0,"{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            checkEglErrorsForced();
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    ManagedEGLContext managedContext = sEglContextStorage.get();
    mEglContext = managedContext != null ? managedContext.getContext() : null;
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(createManagedContext(mEglContext));
    }
}","{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            checkEglErrorsForced();
            sEglConfig = loadEglConfig();
        }
    }
    ManagedEGLContext managedContext = sEglContextStorage.get();
    mEglContext = managedContext != null ? managedContext.getContext() : null;
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(createManagedContext(mEglContext));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The code change occurs in the method 'chooseEglConfig()' and 'loadEglConfig()'. As the method proprietary of these methods, the change type is 1,5.","The code change would make the API potentially return a different value because of the different methods it invokes. Therefore, the CI type is 1."
496,"<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>",17,18,"<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>","<android.app.Notification.Builder: Builder setTicker(CharSequence,RemoteViews)>",0,"{
    mTickerText = tickerText;
    mTickerView = views;
    return this;
}","{
    mTickerText = safeCharSequence(tickerText);
    mTickerView = views;
    return this;
}",1,"/**
 * Set the text that is displayed in the status bar when the notification first
 * arrives, and also a RemoteViews object that may be displayed instead on some
 * devices.
 *
 * @see Notification#tickerText
 * @see Notification#tickerView
 */
","/**
 * Set the text that is displayed in the status bar when the notification first
 * arrives, and also a RemoteViews object that may be displayed instead on some
 * devices.
 *
 * @see Notification#tickerText
 * @see Notification#tickerView
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"In this code, the method 'safeCharSequence()' is used to sanitize the input 'tickerText' in the late implementation, while it is not in the early version. Both the values set to 'mTickerText' are different and the function 'safeCharSequence()' is newly used, so the code change includes Return statement changed (1), Other statement changed (4), and Dependent API changed (5).","There is no Compatibility Issue in this case, because this change doesn't affect the behaviour of the APIs. The use of 'safeCharSequence()' only sanitizes the input, but doesn't change the API behaviours. The changes technically cause the API to return a same ""Builder"" object with slightly different internal states, but it would not lead to compatibility issue, so we can classify it as '0'."
499,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",17,18,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a new method being called on 's' - (s.setChannelIdPrivateKey(mChannelIdPrivateKey);). So, the change type is 4.","Although a new statement has been added, it doesn't alter the return value or the exceptions the method might throw. Thus, there's no compatibility issue and the CI type is 0."
501,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",17,18,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // always use ourselves when inflating ViewStub later
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(this);
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    }
}","{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // always use ourselves when inflating ViewStub later
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(this);
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The trace API call, Trace.traceBegin(Trace.TRACE_TAG_VIEW, name) and Trace.traceEnd(Trace.TRACE_TAG_VIEW), in the implementation was introduced in late version, which does not affect return statements, exception handling statements, control dependency, or any dependent APIs. So the code change type is 4.","The introduced method calls to Trace.traceBegin and Trace.traceEnd do not alter the behavior of the method. Therefore, they do not introduce any compatibility issues. The CI type is 0."
502,<android.view.GLES20RecordingCanvas: GLES20RecordingCanvas obtain(GLES20DisplayList)>,17,18,<android.view.GLES20RecordingCanvas: GLES20RecordingCanvas obtain(GLES20DisplayList)>,<android.view.GLES20RecordingCanvas: GLES20RecordingCanvas obtain(GLES20DisplayList)>,0,"{
    GLES20RecordingCanvas canvas = sPool.acquire();
    canvas.mDisplayList = displayList;
    return canvas;
}","{
    GLES20RecordingCanvas canvas = sPool.acquire();
    if (canvas == null) {
        canvas = new GLES20RecordingCanvas();
    }
    canvas.mDisplayList = displayList;
    return canvas;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,1",0,"Condition of object canvas being null is checked and a new object is created if it's null in the late implementation. Also, the return statement has been modified. Therefore, the code change type is 3,1.","The newly added null check ensures that 'canvas' object will be initialized before it is used, avoiding potential null pointer exception scenarios but does not change the returned values or type nor does it create new exception handling. Hence, there's no compatibility issue introduced, so CI type is 0."
503,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",17,18,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.prepareToLeaveProcess();
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class)} Intent.setClass</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The method called on the 'intent' object changed from 'setAllowFds(false)' to 'prepareToLeaveProcess()'. This change type is 4 since it does not fall into the previously defined categories 1 to 3.,"This change does not impact the return values or types of the API, nor affect exception handling, and therefore does not constitute a compatibility issue. Hence, the CI type is 0."
504,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,17,18,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        return;
                    }
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            // mServedInputConnection.finishComposingText.
                            if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                                startInputInner(null, 0, 0, 0);
                            }
                        }
                    }
                }
                return;
            }
        case MSG_EVENT_TIMEOUT:
            {
                // Even though the message contains both the sequence number
                // and the PendingEvent object itself, we only pass the
                // sequence number to the timeoutEvent function because it's
                // possible for the PendingEvent object to be dequeued and
                // recycled concurrently.  To avoid a possible race, we make
                // a point of always looking up the PendingEvent within the
                // queue given only the sequence number of the event.
                timeoutEvent(msg.arg1);
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            // mServedInputConnection.finishComposingText.
                            if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                                startInputInner(null, 0, 0, 0);
                            }
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Different cases are implemented inside the `switch` statement, which indicates a control dependency change. Also, new lines have been added in the code, marking 'other statement changes'. Thus, the change types are 3 and 4.","None of these changes could cause the API to return different variables or throw a different exception, hence no Compatibility Issue (CI) exists."
505,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",17,18,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>","<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",0,"{
    String packageName = getPackageName();
    try {
        data.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess();
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method ""prepareToLeaveProcess()"" has been added in the late version, regarding the ""data"". Therefore, the classification is 4 given that other statements were changed, but not changing the control dependency, exception handling, return nor dependent APIs.","There is no CI detected as the added method does not affect the return value of the API. It does not throw any exception and does not change the control dependency in a way that alters the potential behavior. Thus, the CI type is classified as 0."
506,<android.content.res.Resources: Resources getSystem()>,17,18,<android.content.res.Resources: Resources getSystem()>,<android.content.res.Resources: Resources getSystem()>,0,"{
    synchronized (mSync) {
        Resources ret = mSystem;
        if (ret == null) {
            ret = new Resources();
            mSystem = ret;
        }
        return ret;
    }
}","{
    synchronized (sSync) {
        Resources ret = mSystem;
        if (ret == null) {
            ret = new Resources();
            mSystem = ret;
        }
        return ret;
    }
}",1,"/**
 * Return a global shared Resources object that provides access to only
 * system resources (no application resources), and is not configured for
 * the current screen (can not use dimension units, does not change based
 * on orientation, etc).
 */
","/**
 * Return a global shared Resources object that provides access to only
 * system resources (no application resources), and is not configured for
 * the current screen (can not use dimension units, does not change based
 * on orientation, etc).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The label for synchronization block has changed from 'mSync' to 'sSync', and this is just a change in synchronization object, which is categorized as 'Other statement changed'.","Since this change will not affect the synchronization of the block itself and will not lead to a different return value or throw a new exception, there is no Compatibility Issue."
510,<android.widget.DatePicker: boolean getCalendarViewShown()>,17,18,<android.widget.DatePicker: boolean getCalendarViewShown()>,<android.widget.DatePicker: boolean getCalendarViewShown()>,0,"{
    return mCalendarView.isShown();
}","{
    return (mCalendarView.getVisibility() == View.VISIBLE);
}",1,"/**
 * Gets whether the {@link CalendarView} is shown.
 *
 * @return True if the calendar view is shown.
 * @see #getCalendarView()
 */
","/**
 * Gets whether the {@link CalendarView} is shown.
 *
 * @return True if the calendar view is shown.
 * @see #getCalendarView()
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,The statement inside return statement has changed from mCalendarView.isShown() to (mCalendarView.getVisibility() == View.VISIBLE). This is a change in the return statement so the change type is 1. ,"Since the return statement has changed, the API potentially return different values in different versions, so the CI type is 1."
511,<android.view.Surface: boolean isValid()>,17,18,<android.view.Surface: boolean isValid()>,<android.view.Surface: boolean isValid()>,0,"{
    return nativeIsValid();
}","{
    synchronized (mLock) {
        if (mNativeSurface == 0)
            return false;
        return nativeIsValid(mNativeSurface);
    }
}",1,"/**
 * Returns true if this object holds a valid surface.
 *
 * @return True if it holds a physical surface, so lockCanvas() will succeed.
 * Otherwise returns false.
 */
","/**
 * Returns true if this object holds a valid surface.
 *
 * @return True if it holds a physical surface, so lockCanvas() will succeed.
 * Otherwise returns false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement changes from a fixed return of nativeIsValid() to return a boolean variable according to whether mNativeSurface equals 0, also a new control structure synchronized has been added, so the code change type is 1,3.","The late return statement may return different boolean results comparing with the early version following the new changes, thus leading to a different behaviour of API, so the CI type is 1."
514,<android.app.Notification.Builder: Builder setContentInfo(CharSequence)>,17,18,<android.app.Notification.Builder: Builder setContentInfo(CharSequence)>,<android.app.Notification.Builder: Builder setContentInfo(CharSequence)>,0,"{
    mContentInfo = info;
    return this;
}","{
    mContentInfo = safeCharSequence(info);
    return this;
}",1,"/**
 * A small piece of additional information pertaining to this notification.
 *
 * The platform template will draw this on the last line of the notification, at the far
 * right (to the right of a smallIcon if it has been placed there).
 */
","/**
 * A small piece of additional information pertaining to this notification.
 *
 * The platform template will draw this on the last line of the notification, at the far
 * right (to the right of a smallIcon if it has been placed there).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The way the variable `mContentInfo` is assigned has changed. In addition, in the late Version the API `safeCharSequence()` is called which is not called in the early version. Therefore, the code change type is 4,5.","The change in how `mContentInfo` is assigned can potentially lead to a change in the return value of the API, Therefore, the CI type is 1."
515,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",17,18,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"{
    if (mParent == null) {
        try {
            intent.setAllowFds(false);
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess();
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,intent.setAllowFds(false); in the early version has been changed to intent.migrateExtraStreamToClipData();  and intent.prepareToLeaveProcess(); in the late version. These changes are classifications 4 and 5.,"Despite the changes made, the API behavior remains consistent across both versions. This means that, regardless of the version, the return values and exceptions thrown should align. Therefore, there is no compatibility issue (CI type 0)."
516,"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>",17,18,"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>","<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>",0,"{
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message);
}","{
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message, 0);
}",1,"/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @deprecated use {@link #setNdefPushMessage} instead
 */
","/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",0,"A method invocation statement changes and extra parameter is added in the method setNdefPushMessage(). The change type is 1,5.","Despite the change in method invocation, it doesn't potentially affect the return type as the method does not return any value, and there's no exception handling changes as well. Therefore, there is no CI, so the CI type is 0."
517,<android.animation.ValueAnimator: void setIntValues(int)>,17,18,<android.animation.ValueAnimator: void setIntValues(int)>,<android.animation.ValueAnimator: void setIntValues(int)>,0,"{
    if (values == null || values.length == 0) {
        return;
    }
    if (mValues == null || mValues.length == 0) {
        setValues(new PropertyValuesHolder[] { PropertyValuesHolder.ofInt("""", values) });
    } else {
        PropertyValuesHolder valuesHolder = mValues[0];
        valuesHolder.setIntValues(values);
    }
    // New property/values/target should cause re-initialization prior to starting
    mInitialized = false;
}","{
    if (values == null || values.length == 0) {
        return;
    }
    if (mValues == null || mValues.length == 0) {
        setValues(PropertyValuesHolder.ofInt("""", values));
    } else {
        PropertyValuesHolder valuesHolder = mValues[0];
        valuesHolder.setIntValues(values);
    }
    // New property/values/target should cause re-initialization prior to starting
    mInitialized = false;
}",1,"/**
 * Sets int values that will be animated between. A single
 * value implies that that value is the one being animated to. However, this is not typically
 * useful in a ValueAnimator object because there is no way for the object to determine the
 * starting value for the animation (unlike ObjectAnimator, which can derive that value
 * from the target object and property being animated). Therefore, there should typically
 * be two or more values.
 *
 * <p>If there are already multiple sets of values defined for this ValueAnimator via more
 * than one PropertyValuesHolder object, this method will set the values for the first
 * of those objects.</p>
 *
 * @param values A set of values that the animation will animate between over time.
 */
","/**
 * Sets int values that will be animated between. A single
 * value implies that that value is the one being animated to. However, this is not typically
 * useful in a ValueAnimator object because there is no way for the object to determine the
 * starting value for the animation (unlike ObjectAnimator, which can derive that value
 * from the target object and property being animated). Therefore, there should typically
 * be two or more values.
 *
 * <p>If there are already multiple sets of values defined for this ValueAnimator via more
 * than one PropertyValuesHolder object, this method will set the values for the first
 * of those objects.</p>
 *
 * @param values A set of values that the animation will animate between over time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method parameter type of the setValues() method has changed. The second 'if' block in the early version uses an array of objects while the late version only uses a single object. Therefore, the change type is 1 and 5.","While there's a change in the method parameter of setValues(), it doesn't cause an impact that could potentially change the return type or the exception handling of the API itself. It doesn't affect the behavior of the getValues() API towards its callers, and hence, no compatibility issues are observed. CI type is 0."
518,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",17,18,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>","<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",0,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
","/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getWindowSession() in WindowManagerGlobal has changed from passing an argument to no arguments. This points to a change in a dependent API, thus the code change type is 5.","Despite the change in dependent API, there are no changes observed in the return types/values or exception handling statements of the given API. Therefore, there is no compatibility issue, resulting in CI type 0."
519,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,17,18,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,0,"{
    synchronized (sPoolLock) {
        if (sPool != null) {
            AccessibilityEvent event = sPool;
            sPool = sPool.mNext;
            sPoolSize--;
            event.mNext = null;
            event.mIsInPool = false;
            return event;
        }
        return new AccessibilityEvent();
    }
}","{
    AccessibilityEvent event = sPool.acquire();
    return (event != null) ? event : new AccessibilityEvent();
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statements in the early version have been replaced by a single return statement in the late version and the way AccessbilityEvent is obtained from the pool is changed too. Therefore, the predicted code change type can be 1,4.","As the way AccessbilityEvent is obtained from the pool has been changed, the API may potentially return a different value, so the CI type is 1."
520,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",17,18,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>","<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",0,"{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}","{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The order of calling 'dirty.offset()' and 'dirty.union()' has changed, and the declaration of 'left' and 'top' have moved downward in the late implementation. so the code change type is 3,4.","Due to the change of order and control dependency, the method may return a different value of 'mParent' or 'null'. So, a CI type is 1."
521,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,17,18,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,0,"{
    try {
        List<AppWidgetProviderInfo> providers = sService.getInstalledProviders();
        for (AppWidgetProviderInfo info : providers) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return providers;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    return getInstalledProviders(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);
}",1,"/**
 * Return a list of the AppWidget providers that are currently installed.
 */
","/**
 * Return a list of the AppWidget providers that are currently installed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire 'try...catch...' block has been replaced by a return statement which returns a call to 'getInstalledProviders(...)' with a new parameter. So there are changes in the return statement (as we have a new return statement), other statements (all the lines inside the 'try' block have been removed), and also a change in a dependent API (The dependent API 'getInstalledProviders' now has a parameter), so the change type is 1,4,5.","The replacement of the 'try...catch...' block by a simple return statement can potentially return a different value in the late version, so the type of Compatibility Issue is 1."
523,<android.content.res.Resources: int getDimensionPixelOffset(int)>,17,18,<android.content.res.Resources: int getDimensionPixelOffset(int)>,<android.content.res.Resources: int getDimensionPixelOffset(int)>,0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelOffset(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}","{
    synchronized (mAccessLock) {
        TypedValue value = mTmpValue;
        if (value == null) {
            mTmpValue = value = new TypedValue();
        }
        getValue(id, value, true);
        if (value.type == TypedValue.TYPE_DIMENSION) {
            return TypedValue.complexToDimensionPixelOffset(value.data, mMetrics);
        }
        throw new NotFoundException(""Resource ID #0x"" + Integer.toHexString(id) + "" type #0x"" + Integer.toHexString(value.type) + "" is not valid"");
    }
}",1,"/**
 * Retrieve a dimensional for a particular resource ID for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional for a particular resource ID for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @return Resource dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version implementation, the `synchronized` block is now locking on `mAccessLock` instead of `mTmpValue` which indicates a control dependency change (3). Also, there is a new check for whether `mTmpValue` is null and initialized if it is before being used to store the value as compared to the early version. This addition of a block with an `if` condition indicates other statement changes (4). ","Due to the added null check on `mTmpValue`, the method may potentially return different results depending on whether `mTmpValue` was null initially or not. Hence, these changes could lead to potential different return values (1)."
524,"<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>",17,18,"<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>","<android.speech.tts.FileSynthesisCallback: int audioAvailable(byte[],int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.audioAvailable("" + buffer + "","" + offset + "","" + length + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            mFile.write(buffer, offset, length);
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.audioAvailable("" + buffer + "","" + offset + "","" + length + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFileChannel == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            mFileChannel.write(ByteBuffer.wrap(buffer, offset, length));
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to output file descriptor"", ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The if condition changed from checking 'mFile' to 'mFileChannel' and the method implementation changed to mFileChannel.write() instead of mFile.write(). This classifies as code change type 1,5.","As the variable and the method it invokes have changed, this could potentially lead to a different return value, making the CI type 1."
525,"<android.view.ViewGroup.ViewLocationHolder: ViewLocationHolder obtain(ViewGroup,View)>",17,18,"<android.view.ViewGroup.ViewLocationHolder: ViewLocationHolder obtain(ViewGroup,View)>","<android.view.ViewGroup.ViewLocationHolder: ViewLocationHolder obtain(ViewGroup,View)>",0,"{
    ViewLocationHolder holder = null;
    synchronized (sPoolLock) {
        if (sPool != null) {
            holder = sPool;
            sPool = holder.mNext;
            holder.mNext = null;
            holder.mIsPooled = false;
            sPoolSize--;
        } else {
            holder = new ViewLocationHolder();
        }
        holder.init(root, view);
        return holder;
    }
}","{
    ViewLocationHolder holder = sPool.acquire();
    if (holder == null) {
        holder = new ViewLocationHolder();
    }
    holder.init(root, view);
    return holder;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The retrieval of 'holder' variable from 'sPool' has completely changed, the control dependent 'if' statement has changed and the dependent API 'sPool.acquire()' is introduced, so the change type is classified as 1, 3, 5.","Due to the changes in both control dependency and API that it is dependent on, the 'holder' variable being returned could potentially differ between the two versions leading to a potential Compatibility Issue with different return values, hence the CI type is 1."
526,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,17,18,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,0,"{
    throwIfSystem();
    return sCurrentUser.getExternalStoragePublicDirectory(type);
}","{
    throwIfUserRequired();
    return sCurrentUser.getExternalStoragePublicDirectory(type);
}",1,"/**
 * Get a top-level public external storage directory for placing files of
 * a particular type.  This is where the user will typically place and
 * manage their own files, so you should be careful about what you put here
 * to ensure you don't erase their files or get in the way of their own
 * organization.
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>Here is an example of typical code to manipulate a picture on
 * the public external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * public_picture}
 *
 * @param type The type of storage directory to return.  Should be one of
 * {@link #DIRECTORY_MUSIC}, {@link #DIRECTORY_PODCASTS},
 * {@link #DIRECTORY_RINGTONES}, {@link #DIRECTORY_ALARMS},
 * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_PICTURES},
 * {@link #DIRECTORY_MOVIES}, {@link #DIRECTORY_DOWNLOADS}, or
 * {@link #DIRECTORY_DCIM}.  May not be null.
 *
 * @return Returns the File path for the directory.  Note that this
 * directory may not yet exist, so you must make sure it exists before
 * using it such as with {@link File#mkdirs File.mkdirs()}.
 */
","/**
 * Get a top-level public external storage directory for placing files of
 * a particular type.  This is where the user will typically place and
 * manage their own files, so you should be careful about what you put here
 * to ensure you don't erase their files or get in the way of their own
 * organization.
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>Here is an example of typical code to manipulate a picture on
 * the public external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * public_picture}
 *
 * @param type The type of storage directory to return.  Should be one of
 * {@link #DIRECTORY_MUSIC}, {@link #DIRECTORY_PODCASTS},
 * {@link #DIRECTORY_RINGTONES}, {@link #DIRECTORY_ALARMS},
 * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_PICTURES},
 * {@link #DIRECTORY_MOVIES}, {@link #DIRECTORY_DOWNLOADS}, or
 * {@link #DIRECTORY_DCIM}.  May not be null.
 *
 * @return Returns the File path for the directory.  Note that this
 * directory may not yet exist, so you must make sure it exists before
 * using it such as with {@link File#mkdirs File.mkdirs()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The called function has changed from throwIfSystem() to throwIfUserRequired(), and the dependent API sCurrentUser.throwIfSystem() was changed to sCurrentUser.throwIfUserRequired(). So the code change type is 4,5.","This change may alter the circumstances under which an exception is thrown, potentially leading to different returned values. So the CI type is 1."
527,<android.view.View: boolean onHoverEvent(MotionEvent)>,17,18,<android.view.View: boolean onHoverEvent(MotionEvent)>,<android.view.View: boolean onHoverEvent(MotionEvent)>,0,"{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
            // focus as soon as the user stop hovering over the view.
            if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
                getViewRootImpl().setAccessibilityFocus(null, null);
            }
        }
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        return true;
    }
    return false;
}","{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
            // focus as soon as the user stop hovering over the view.
            if (mAttachInfo != null && !mAttachInfo.mHasWindowFocus) {
                getViewRootImpl().setAccessibilityFocus(null, null);
            }
        }
    }
    if (isHoverable()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
","/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no difference between the early version and the late version.,There is no compatibility issue between the two versions as there is no change in the implementation.
528,<android.view.ViewGroup.MarginLayoutParams: void setLayoutDirection(int)>,17,18,<android.view.ViewGroup.MarginLayoutParams: void setLayoutDirection(int)>,<android.view.ViewGroup.MarginLayoutParams: void setLayoutDirection(int)>,0,"{
    if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)
        return;
    this.layoutDirection = layoutDirection;
}","{
    if (layoutDirection != View.LAYOUT_DIRECTION_LTR && layoutDirection != View.LAYOUT_DIRECTION_RTL)
        return;
    if (layoutDirection != (mMarginFlags & LAYOUT_DIRECTION_MASK)) {
        mMarginFlags &= ~LAYOUT_DIRECTION_MASK;
        mMarginFlags |= (layoutDirection & LAYOUT_DIRECTION_MASK);
        if (isMarginRelative()) {
            mMarginFlags |= NEED_RESOLUTION_MASK;
        } else {
            mMarginFlags &= ~NEED_RESOLUTION_MASK;
        }
    }
}",1,"/**
 * Set the layout direction
 * @param layoutDirection the layout direction.
 * Should be either {@link View#LAYOUT_DIRECTION_LTR}
 * or {@link View#LAYOUT_DIRECTION_RTL}.
 */
","/**
 * Set the layout direction
 * @param layoutDirection the layout direction.
 * Should be either {@link View#LAYOUT_DIRECTION_LTR}
 * or {@link View#LAYOUT_DIRECTION_RTL}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"Several new operations on variable 'mMarginFlags' were added in the late version, so the code change type is 4.","The modification of 'mMarginFlags' will cause a behavioral change in the function (even though it does not directly change the return value or thrown exceptions). Therefore, the CI type is 1."
529,<android.app.Notification.InboxStyle: InboxStyle setSummaryText(CharSequence)>,17,18,<android.app.Notification.InboxStyle: InboxStyle setSummaryText(CharSequence)>,<android.app.Notification.InboxStyle: InboxStyle setSummaryText(CharSequence)>,0,"{
    internalSetSummaryText(cs);
    return this;
}","{
    internalSetSummaryText(safeCharSequence(cs));
    return this;
}",1,"/**
 * Set the first line of text after the detail section in the big form of the template.
 */
","/**
 * Set the first line of text after the detail section in the big form of the template.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The modification in the parameter of internalSetSummaryText() from [cs] to [safeCharSequence(cs)] is considered as a Dependent API change, hence the code change type is 5.","This modification in the implementation could potentially lead the API to return a different value, which creates a Compatibility Issue. Therefore, the CI type is 1."
530,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,17,18,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,<android.view.View: AccessibilityNodeInfo createAccessibilityNodeInfo()>,0,"{
    AccessibilityNodeProvider provider = getAccessibilityNodeProvider();
    if (provider != null) {
        return provider.createAccessibilityNodeInfo(View.NO_ID);
    } else {
        AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain(this);
        onInitializeAccessibilityNodeInfo(info);
        return info;
    }
}","{
    if (mAccessibilityDelegate != null) {
        return mAccessibilityDelegate.createAccessibilityNodeInfo(this);
    } else {
        return createAccessibilityNodeInfoInternal();
    }
}",1,"/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
","/**
 * Returns an {@link AccessibilityNodeInfo} representing this view from the
 * point of view of an {@link android.accessibilityservice.AccessibilityService}.
 * This method is responsible for obtaining an accessibility node info from a
 * pool of reusable instances and calling
 * {@link #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)} on this view to
 * initialize the former.
 * <p>
 * Note: The client is responsible for recycling the obtained instance by calling
 * {@link AccessibilityNodeInfo#recycle()} to minimize object creation.
 * </p>
 *
 * @return A populated {@link AccessibilityNodeInfo}.
 *
 * @see AccessibilityNodeInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation logic has changed. The early version implementation returns two different cases from getAccessibilityNodeProvider() and onInitializeAccessibilityNodeInfo(), while the late version uses mAccessibilityDelegate being null as a condition, and uses mAccessibilityDelegate.createAccessibilityNodeInfo(this) and createAccessibilityNodeInfoInternal() for return respectively. This is both a logical change(type 4) and a return statement change (type 1). Moreover, the dependent APIs have also changed(type 5).","With the changes in the logic and return statement, the API potentially returns a different value depending on the condition, hence the CI type is 1."
531,<android.os.WorkSource: boolean remove(WorkSource)>,17,18,<android.os.WorkSource: boolean remove(WorkSource)>,<android.os.WorkSource: boolean remove(WorkSource)>,0,"{
    int N1 = mNum;
    final int[] uids1 = mUids;
    final int N2 = other.mNum;
    final int[] uids2 = other.mUids;
    boolean changed = false;
    int i1 = 0;
    for (int i2 = 0; i2 < N2 && i1 < N1; i2++) {
        if (uids2[i2] == uids1[i1]) {
            N1--;
            if (i1 < N1)
                System.arraycopy(uids1, i1 + 1, uids1, i1, N1 - i1);
        }
        while (i1 < N1 && uids2[i2] > uids1[i1]) {
            i1++;
        }
    }
    mNum = N1;
    return changed;
}","{
    if (mNum <= 0 || other.mNum <= 0) {
        return false;
    }
    if (mNames == null && other.mNames == null) {
        return removeUids(other);
    } else {
        if (mNames == null) {
            throw new IllegalArgumentException(""Other "" + other + "" has names, but target "" + this + "" does not"");
        }
        if (other.mNames == null) {
            throw new IllegalArgumentException(""Target "" + this + "" has names, but other "" + other + "" does not"");
        }
        return removeUidsAndNames(other);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","Completely different code has been implemented in the late version of the API. Specifically, new conditions, new exception handling statements and return statements have been introduced. Hence, the code change type is 1,2,3,4.","The new implementation of the API introduces new exceptions, and different return statements, therefore, the late version API might behave differently compared to its early version. Thus, the CI types are 1,2."
532,<android.widget.ProgressBar: void onDraw(Canvas)>,17,18,<android.widget.ProgressBar: void onDraw(Canvas)>,<android.widget.ProgressBar: void onDraw(Canvas)>,0,"{
    super.onDraw(canvas);
    Drawable d = mCurrentDrawable;
    if (d != null) {
        // Translate canvas so a indeterminate circular progress bar with padding
        // rotates properly in its animation
        canvas.save();
        if (isLayoutRtl()) {
            canvas.translate(getWidth() - mPaddingRight, mPaddingTop);
            canvas.scale(-1.0f, 1.0f);
        } else {
            canvas.translate(mPaddingLeft, mPaddingTop);
        }
        long time = getDrawingTime();
        if (mHasAnimation) {
            mAnimation.getTransformation(time, mTransformation);
            float scale = mTransformation.getAlpha();
            try {
                mInDrawing = true;
                d.setLevel((int) (scale * MAX_LEVEL));
            } finally {
                mInDrawing = false;
            }
            postInvalidateOnAnimation();
        }
        d.draw(canvas);
        canvas.restore();
        if (mShouldStartAnimationDrawable && d instanceof Animatable) {
            ((Animatable) d).start();
            mShouldStartAnimationDrawable = false;
        }
    }
}","{
    super.onDraw(canvas);
    Drawable d = mCurrentDrawable;
    if (d != null) {
        // Translate canvas so a indeterminate circular progress bar with padding
        // rotates properly in its animation
        canvas.save();
        if (isLayoutRtl() && mMirrorForRtl) {
            canvas.translate(getWidth() - mPaddingRight, mPaddingTop);
            canvas.scale(-1.0f, 1.0f);
        } else {
            canvas.translate(mPaddingLeft, mPaddingTop);
        }
        long time = getDrawingTime();
        if (mHasAnimation) {
            mAnimation.getTransformation(time, mTransformation);
            float scale = mTransformation.getAlpha();
            try {
                mInDrawing = true;
                d.setLevel((int) (scale * MAX_LEVEL));
            } finally {
                mInDrawing = false;
            }
            postInvalidateOnAnimation();
        }
        d.draw(canvas);
        canvas.restore();
        if (mShouldStartAnimationDrawable && d instanceof Animatable) {
            ((Animatable) d).start();
            mShouldStartAnimationDrawable = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"An additional condition 'mMirrorForRtl' has been added into if(isLayoutRtl() && mMirrorForRtl), so the change type is 3.","In spite of the change, it will not change the potential behaviour of the API: the return type, value, and the exception. Thus, no Compatibility Issue exists, hence the CI type is 0."
533,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",17,18,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>","<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",0,"{
    try {
        return mContentProvider.call(method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}",1,"/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
","/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the return statement, 'mContentProvider.call' is changed to 'mContentProvider.call(mPackageName', so the types of the parameters that 'call' function takes have changed and it may also alter the return value. Therefore, the code change type is 1,5.","The change of parameter in the 'call' function potentially changes the return value of the API implementation, thereby leading to a CI. The CI type is 1."
534,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",17,18,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        throw new RuntimeException(e);
    } finally {
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A statement 'waitForSharedPrefs()' is introduced in late version, so the code change type is 4.","Even though 'waitForSharedPrefs()' statement is introduced, it does not change the API behavior. It ensures shared preferences writes are flushed to disk, so it does not lead to a potential compatibility issue. Thus, the CI type is 0."
