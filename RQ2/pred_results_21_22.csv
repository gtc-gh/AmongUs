Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",21,22,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>","<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",0,"{
    set(key.getNativeKey(), value);
}","{
    SetCommand s = sSetCommandMap.get(key);
    if (s != null) {
        s.setValue(this, value);
        return;
    }
    setBase(key, value);
}",1,,"/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The method implementation has changed from a direct call to set(key.getNativeKey(), value) to using a SetCommand object with a conditional check to either execute s.setValue(this, value) or setBase(key, value). This involves a control dependency change, other statement changes, and dependent API changed because it calls a different method (setBase) compared to the early version.","Despite the extensive code changes, including the addition of a control structure and different method calls, none of these changes can be determined to lead to a compatibility issue because there are no changes to the return type, values, or exception handling based on the provided code snippets. The change in control flow does not directly affect the return statement because this method returns void, and there are no exception changes detected between the two versions. There may be internal changes and improvements, but from the caller's perspective, the observable behavior remains the same, considering the method still sets a value for a given key. Therefore, according to the instruction, there is no compatibility issue."
6,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,21,22,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code between the two versions is an additional condition check (`characteristic.getValue() == null`) before the method proceeds with the write operation, which falls under 'Other statement changed' since it's neither a change in a return statement, exception handling, control dependency, nor dependent API.","This new condition check does not lead to a Compatibility Issue since it does not affect the behavior in a way that would cause the method to return a different type or value, or throw a different exception than it did before. If the `characteristic`'s value was null in the early version, the attempt to write the characteristic would still fail later when `mService.writeCharacteristic()` is called with a null value. Thus the CI type is 0."
8,<android.app.Notification.Action.WearableExtender: WearableExtender clone()>,21,22,<android.app.Notification.Action.WearableExtender: WearableExtender clone()>,<android.app.Notification.Action.WearableExtender: WearableExtender clone()>,0,"{
    WearableExtender that = new WearableExtender();
    that.mFlags = this.mFlags;
    return that;
}","{
    WearableExtender that = new WearableExtender();
    that.mFlags = this.mFlags;
    that.mInProgressLabel = this.mInProgressLabel;
    that.mConfirmLabel = this.mConfirmLabel;
    that.mCancelLabel = this.mCancelLabel;
    return that;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"New field assignments have been added to the Late_Implementation for mInProgressLabel, mConfirmLabel, and mCancelLabel, which constitutes a code change of type 4 (Other statement changed).","The additional field assignments could potentially affect the returned object's state, which would result in different behavior when the clone() method is called. Therefore, the addition of field assignments constitutes a Compatibility Issue due to the potential for different return values or types, making the CI type 1."
9,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,21,22,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        case MSG_COMPUTE_CLICK_POINT_IN_SCREEN:
            return ""MSG_COMPUTE_CLICK_POINT_IN_SCREEN"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There are no changes in the implementation between the two versions.,"Since there were no changes made, no compatibility issues could arise."
10,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",21,22,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    float left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    float left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is the removal of the 'bitmap.mBuffer' argument from the method call to 'nDrawBitmap'. Therefore, this change type is 4 (Other statement changed).","Removing the parameter 'bitmap.mBuffer' from the method call does not inherently affect the outcome of 'drawBitmap' since it is an internal implementation detail and there are no changes to the control flow or exception handling. So, there is no compatibility issue as the method's behavior from an external perspective should remain unchanged, hence type 0 (No Compatibility Issue)."
11,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,21,22,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter()>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter(""default"");
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter(""default"");
}",1,"/**
 * @deprecated Use {@link #createPrintDocumentAdapter(String)} which requires user
 * to provide a print document name.
 */
","/**
 * @deprecated Use {@link #createPrintDocumentAdapter(String)} which requires user
 * to provide a print document name.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The change is in a logging condition: `DebugFlags.TRACE_API` was been changed to `TRACE`. This is classified as an 'Other statement changed' because it is a change in the condition for logging, so the code change type is 4.","This change will not affect the behavior of the API in terms of the return value or the exceptions it might throw. The change is strictly in a debug log statement, which does not have any implications for API compatibility. Thus, there is no Compatibility Issue; the CI type is 0."
13,<android.animation.PropertyValuesHolder.MultiFloatValuesHolder: void setupSetter(Class)>,21,22,<android.animation.PropertyValuesHolder.MultiFloatValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.MultiFloatValuesHolder: void setupSetter(Class)>,0,"{
    if (mJniSetter != 0) {
        return;
    }
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Long jniSetterLong = propertyMap.get(mPropertyName);
            if (jniSetterLong != null) {
                mJniSetter = jniSetterLong;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            calculateValue(0f);
            float[] values = (float[]) getAnimatedValue();
            int numParams = values.length;
            try {
                mJniSetter = nGetMultipleFloatMethod(targetClass, methodName, numParams);
            } catch (NoSuchMethodError e) {
                // try without the 'set' prefix
                mJniSetter = nGetMultipleFloatMethod(targetClass, mPropertyName, numParams);
            }
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Long>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
}","{
    if (mJniSetter != 0) {
        return;
    }
    synchronized (sJNISetterPropertyMap) {
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        boolean wasInMap = false;
        if (propertyMap != null) {
            wasInMap = propertyMap.containsKey(mPropertyName);
            if (wasInMap) {
                Long jniSetter = propertyMap.get(mPropertyName);
                if (jniSetter != null) {
                    mJniSetter = jniSetter;
                }
            }
        }
        if (!wasInMap) {
            String methodName = getMethodName(""set"", mPropertyName);
            calculateValue(0f);
            float[] values = (float[]) getAnimatedValue();
            int numParams = values.length;
            try {
                mJniSetter = nGetMultipleFloatMethod(targetClass, methodName, numParams);
            } catch (NoSuchMethodError e) {
                // try without the 'set' prefix
                try {
                    mJniSetter = nGetMultipleFloatMethod(targetClass, mPropertyName, numParams);
                } catch (NoSuchMethodError e2) {
                // just try reflection next
                }
            }
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Long>();
                sJNISetterPropertyMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, mJniSetter);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",2,"The synchronisation mechanism changed from a ReentrantReadWriteLock to a synchronized block. There's also a logic change where 'if (mJniSetter == 0)' has been replaced with 'if (!wasInMap)'. Besides, an additional nested try-catch block has been added for the NoSuchMethodError exception, which changes the exception handling logic. Thus, the change types are 2, 3, and 4.","The exception handling behavior has changed because in the late version, the NoSuchMethodError will no longer fall-through to the unlocking of mPropertyMapLock (since it no longer exists), and an additional NoSuchMethodError catch has been added, potentially altering the flow of exceptions when errors occur. This represents a change in exception handling, so the CI type is 2."
14,<android.animation.AnimatorSet: AnimatorSet clone()>,21,22,<android.animation.AnimatorSet: AnimatorSet clone()>,<android.animation.AnimatorSet: AnimatorSet clone()>,0,"{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new HashMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>();
    anim.mSortedNodes = new ArrayList<Node>();
    anim.mReversible = mReversible;
    anim.mSetListener = null;
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    // <old, new>
    HashMap<Node, Node> nodeCloneMap = new HashMap<Node, Node>();
    for (Node node : mNodes) {
        Node nodeClone = node.clone();
        nodeCloneMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            ArrayList<AnimatorListener> listenersToRemove = null;
            for (AnimatorListener listener : cloneListeners) {
                if (listener instanceof AnimatorSetListener) {
                    if (listenersToRemove == null) {
                        listenersToRemove = new ArrayList<AnimatorListener>();
                    }
                    listenersToRemove.add(listener);
                }
            }
            if (listenersToRemove != null) {
                for (AnimatorListener listener : listenersToRemove) {
                    cloneListeners.remove(listener);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (Node node : mNodes) {
        Node nodeClone = nodeCloneMap.get(node);
        if (node.dependencies != null) {
            for (Dependency dependency : node.dependencies) {
                Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
                Dependency cloneDependency = new Dependency(clonedDependencyNode, dependency.rule);
                nodeClone.addDependency(cloneDependency);
            }
        }
    }
    return anim;
}","{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new HashMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mSortedNodes = new ArrayList<Node>(nodeCount);
    anim.mReversible = mReversible;
    anim.mSetListener = null;
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        node.mTmpClone = nodeClone;
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        final ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            for (int i = cloneListeners.size() - 1; i >= 0; i--) {
                final AnimatorListener listener = cloneListeners.get(i);
                if (listener instanceof AnimatorSetListener) {
                    cloneListeners.remove(i);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        final Node clone = node.mTmpClone;
        if (node.dependencies != null) {
            clone.dependencies = new ArrayList<Dependency>(node.dependencies.size());
            final int depSize = node.dependencies.size();
            for (int i = 0; i < depSize; i++) {
                final Dependency dependency = node.dependencies.get(i);
                Dependency cloneDependency = new Dependency(dependency.node.mTmpClone, dependency.rule);
                clone.dependencies.add(cloneDependency);
            }
        }
        if (node.nodeDependents != null) {
            clone.nodeDependents = new ArrayList<Node>(node.nodeDependents.size());
            for (Node dep : node.nodeDependents) {
                clone.nodeDependents.add(dep.mTmpClone);
            }
        }
        if (node.nodeDependencies != null) {
            clone.nodeDependencies = new ArrayList<Node>(node.nodeDependencies.size());
            for (Node dep : node.nodeDependencies) {
                clone.nodeDependencies.add(dep.mTmpClone);
            }
        }
    }
    for (int n = 0; n < nodeCount; n++) {
        mNodes.get(n).mTmpClone = null;
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
16,"<android.widget.ActionMenuPresenter.OverflowMenuButton: boolean setFrame(int,int,int,int)>",21,22,"<android.widget.ActionMenuPresenter.OverflowMenuButton: boolean setFrame(int,int,int,int)>","<android.widget.ActionMenuPresenter.OverflowMenuButton: boolean setFrame(int,int,int,int)>",0,"{
    final boolean changed = super.setFrame(l, t, r, b);
    // Set up the hotspot bounds to be centered on the image.
    final Drawable d = getDrawable();
    final Drawable bg = getBackground();
    if (d != null && bg != null) {
        final float[] pts = mTempPts;
        pts[0] = d.getBounds().centerX();
        getImageMatrix().mapPoints(pts);
        final int offset = (int) pts[0] - getWidth() / 2;
        bg.setHotspotBounds(offset, 0, getWidth() + offset, getHeight());
    }
    return changed;
}","{
    final boolean changed = super.setFrame(l, t, r, b);
    // Set up the hotspot bounds to square and centered on the image.
    final Drawable d = getDrawable();
    final Drawable bg = getBackground();
    if (d != null && bg != null) {
        final int width = getWidth();
        final int height = getHeight();
        final int halfEdge = Math.max(width, height) / 2;
        final int offsetX = getPaddingLeft() - getPaddingRight();
        final int offsetY = getPaddingTop() - getPaddingBottom();
        final int centerX = (width + offsetX) / 2;
        final int centerY = (height + offsetY) / 2;
        bg.setHotspotBounds(centerX - halfEdge, centerY - halfEdge, centerX + halfEdge, centerY + halfEdge);
    }
    return changed;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The implementation of setFrame has seen changes in the logic related to how the hotspot bounds are set. Thus, this would be classified under both Control dependency change (3) because of the changed conditions within the if statement and Other statement changed (4) due to the modifications in how the offset and center are calculated. Such changes do not affect the return type or the exceptions thrown.","There is no Compatibility Issue because the return value remains the same and there's no change in exception handling. The variable 'changed', which is returned at the end, has not been changed in any way by the modifications in the method body. This means that irrespective of the internal calculation changes, the method's output remains consistent between versions."
17,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,21,22,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,0,"{
    checkNotNull(surface, ""surface must not be null"");
    throw new UnsupportedOperationException(""Not implemented yet"");
// TODO: JNI function that checks the Surface's IGraphicBufferProducer state
}","{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize;
    int surfaceFormat = -1;
    try {
        surfaceSize = LegacyCameraDevice.getSurfaceSize(surface);
        surfaceFormat = LegacyCameraDevice.detectSurfaceType(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException(""Abandoned surface"", e);
    }
    // See if consumer is flexible.
    boolean isFlexible = LegacyCameraDevice.isFlexibleConsumer(surface);
    // Override RGB formats to IMPLEMENTATION_DEFINED, b/9487482
    if ((surfaceFormat >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceFormat <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
        surfaceFormat = LegacyMetadataMapper.HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
    }
    for (StreamConfiguration config : mConfigurations) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
","/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The early version of the implementation throws an UnsupportedOperationException indicating it was not implemented yet. In the late version, this has been replaced with an actual implementation checking different aspects of the provided Surface object. The method now has control flow statements, exception handling, and other statements, which did not exist in the early version. The change types are 1,2,3,4, all of them are involved because of the newly implemented method body.","The CI types are 1 and 2, because the new implementation can return both different values (true or false instead of always throwing an exception) and can throw a different exception (IllegalArgumentException instead of UnsupportedOperationException)."
19,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",21,22,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>","<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        checkRange(colors.length, colorOffset, count);
    }
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
}","{
    throwIfCannotDraw(bitmap);
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        checkRange(colors.length, colorOffset, count);
    }
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation between the early version and the late version of this method. The annotations also remain the same.,There is no Compatibility Issue because there is no change in the method implementation and annotations between the versions.
23,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",21,22,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",0,"{
    if (DBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mClientIf <= 0)
            return;
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}","{
    if (VDBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mClientIf <= 0)
            return;
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the modification of the constant from `DBG` to `VDBG`, which seems to be used for verbose/debug logging. Since this change doesn't affect the main logic of the method, the code change type is 4.","There is no Compatibility Issue here as the change does not impact the logic, return values, or exceptions in the method. The change is purely for logging purposes and will not change the method's behavior from an API consumer's perspective."
24,<android.widget.SearchView: CharSequence getQuery()>,21,22,<android.widget.SearchView: CharSequence getQuery()>,<android.widget.SearchView: CharSequence getQuery()>,0,"{
    return mQueryTextView.getText();
}","{
    return mSearchSrcTextView.getText();
}",1,"/**
 * Returns the query string currently in the text field.
 *
 * @return the query string
 */
","/**
 * Returns the query string currently in the text field.
 *
 * @return the query string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The code change involves a direct modification in the return statement, from mQueryTextView.getText() to mSearchSrcTextView.getText(), indicating the member variable being accessed has changed, thus the change type is 1,5.","The different member variable is being accessed to obtain the returned value, which means that the API could potentially return a different value. This constitutes a compatibility issue of type 1."
27,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",21,22,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",0,"{
    int delay = getDelay(rateUs);
    return registerListenerImpl(listener, sensor, delay, handler, 0, 0);
}","{
    int delay = getDelay(samplingPeriodUs);
    return registerListenerImpl(listener, sensor, delay, handler, 0, 0);
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
 * sensor. Events are delivered in continuous mode as soon as they are available. To reduce the
 * battery usage, use {@link #registerListener(SensorEventListener, Sensor, int, int)} which
 * enables batch mode for the sensor.
 *
 * <p class=""note""></p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.
 * Use {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead.
 * </p>
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rateUs
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microseconds.
 * Specifying the delay in microseconds only works from Android
 * 2.3 (API level 9) onwards. For earlier releases, you must use
 * one of the {@code SENSOR_DELAY_*} constants.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return <code>true</code> if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
 * sensor. Events are delivered in continuous mode as soon as they are available. To reduce the
 * power consumption, applications can use
 * {@link #registerListener(SensorEventListener, Sensor, int, int)} instead and specify a
 * positive non-zero maximum reporting latency.
 * <p class=""note"">
 * </p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}. Use
 * {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead. </p>
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param samplingPeriodUs The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be received faster or
 * slower than the specified rate. Usually events are received faster. The value must
 * be one of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST} or, the desired
 * delay between events in microseconds. Specifying the delay in microseconds only
 * works from Android 2.3 (API level 9) onwards. For earlier releases, you must use
 * one of the {@code SENSOR_DELAY_*} constants.
 * @param handler The {@link android.os.Handler Handler} the {@link android.hardware.SensorEvent
 * sensor events} will be delivered to.
 * @return <code>true</code> if the sensor is supported and successfully enabled.
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in the late implementation is only the renaming of a local variable from `rateUs` to `samplingPeriodUs`. This does not change any logic in the flow; it's just a renaming of a variable. Therefore, the code change type is 4.","This kind of change does not affect the behavior of the API since it's merely renaming a variable for clarity or consistency. Hence, there's no Compatibility Issue, so the CI type is 0."
28,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,21,22,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mLabelForId);
}",1,"/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
","/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation has significantly changed from directly doing multiple operations and checks to simply calling getNodeForAccessibilityId(mLabelForId), which indicates changes in return statement, control dependency, and it is dependent on another API (getNodeForAccessibilityId). Therefore, the code change types are 1, 3, and 5.","This change could possibly return a different AccessibilityNodeInfo object than before because the computation and the checks performed have been altered. The old implementation has additional logic that is now encapsulated inside the getNodeForAccessibilityId method. Depending on the implementation of this method, the return value could be different, and it could also change the exceptions that get thrown during the execution. The CI type is 1."
29,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,21,22,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    boolean result = false;
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }
    if (!result && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
        stopNestedScroll();
    }
    return result;
}","{
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don't have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }
    boolean result = false;
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }
        if (!result && onTouchEvent(event)) {
            result = true;
        }
    }
    if (!result && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
        stopNestedScroll();
    }
    return result;
}",1,"/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The early version of the implementation does not contain the code block checking `event.isTargetAccessibilityFocus()`, while the late version does. This additional check for accessibility focus is placed before any other processing and has the potential to return `false` immediately, bypassing the rest of the method.","The introduction of the new conditional block can change the behavior of the API by potentially returning `false` early, without executing the rest of the code that was always executed in the earlier version. This change could lead to a Compatibility Issue due to the potential different return values. Thus, CI type is 1."
31,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,21,22,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: String toString()>,0,"{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}","{
    return ""policy="" + policyToString(policy) + "", useProximitySensor="" + useProximitySensor + "", screenBrightness="" + screenBrightness + "", screenAutoBrightnessAdjustment="" + screenAutoBrightnessAdjustment + "", useAutoBrightness="" + useAutoBrightness + "", blockScreenOn="" + blockScreenOn + "", lowPowerMode="" + lowPowerMode + "", boostScreenBrightness="" + boostScreenBrightness + "", dozeScreenBrightness="" + dozeScreenBrightness + "", dozeScreenState="" + Display.stateToString(dozeScreenState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new field 'boostScreenBrightness' is added to the return statement. However, this change is only extending the returned string with an additional piece of information about the state of the object and does not affect the behavior of the method itself, other than the contents of the string. Therefore, the change type is 4.","This change does not affect how the method operates, just the content it reports, which for a `toString()` method is expected to reflect the state of the object at the time of calling. Since the function's return type remains `String` and it's typical for `toString()` methods to include more or different details between versions, there's no behavioral Compatibility Issue expected from this change (it doesn't affect the object's state or how it's used). The CI type is 0."
32,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",21,22,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>","<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",0,"{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
        dispatchDraw(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
        }
    } else {
        draw(canvas);
    }
    drawAccessibilityFocus(canvas);
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}","{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
        dispatchDraw(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
        }
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}",1,"/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
","/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
33,<android.widget.SearchView: int getInputType()>,21,22,<android.widget.SearchView: int getInputType()>,<android.widget.SearchView: int getInputType()>,0,"{
    return mQueryTextView.getInputType();
}","{
    return mSearchSrcTextView.getInputType();
}",1,"/**
 * Returns the input type set on the query text field.
 * @return the input type
 *
 * @attr ref android.R.styleable#SearchView_inputType
 */
","/**
 * Returns the input type set on the query text field.
 * @return the input type
 *
 * @attr ref android.R.styleable#SearchView_inputType
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method name that is being called to obtain the input type has been changed from mQueryTextView.getInputType() to mSearchSrcTextView.getInputType(), so the code change type is 5.","The change in the dependent method that is being called indicates that the API now relies on a potentially different member variable, which could potentially result in a different return value. This qualifies as a Compatibility Issue of type 1."
34,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,21,22,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""saveState"");
    return mProvider.saveState(outState);
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""saveState"");
    return mProvider.saveState(outState);
}",1,"/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */
","/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the static constant used for debugging from DebugFlags.TRACE_API to TRACE. This change does not affect the API's control flow or result, so the change type is 4.","Since the modification is strictly related to the debugging flag and does not alter the method's behavior seen by the caller, there is no compatibility issue. Thus, the CI type is 0."
35,"<android.widget.AutoCompleteTextView: void onFocusChanged(boolean,int,Rect)>",21,22,"<android.widget.AutoCompleteTextView: void onFocusChanged(boolean,int,Rect)>","<android.widget.AutoCompleteTextView: void onFocusChanged(boolean,int,Rect)>",0,"{
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
    // Perform validation if the view is losing focus.
    if (!focused) {
        performValidation();
    }
    if (!focused && !mPopup.isDropDownAlwaysVisible()) {
        dismissDropDown();
    }
}","{
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        return;
    }
    // Perform validation if the view is losing focus.
    if (!focused) {
        performValidation();
    }
    if (!focused && !mPopup.isDropDownAlwaysVisible()) {
        dismissDropDown();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"A new `if` statement was introduced that checks for `mTemporaryDetach` and returns early if it's true. This is a control dependency change, so the code change type is 3.","The new `if` statement introduced only affects the behavior when `mTemporaryDetach` is true. When `mTemporaryDetach` is true, `onFocusChanged` will return earlier than it did in the early version. However, since this decision is based completely on the new `mTemporaryDetach` field and doesn't alter existing return values or exception handling when `mTemporaryDetach` is false, there is no compatibility issue introduced by this change."
36,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",21,22,"<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.ChangeBounds: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        int startLeft = startBounds.left;
        int endLeft = endBounds.left;
        int startTop = startBounds.top;
        int endTop = endBounds.top;
        int startRight = startBounds.right;
        int endRight = endBounds.right;
        int startBottom = startBounds.bottom;
        int endBottom = endBounds.bottom;
        int startWidth = startRight - startLeft;
        int startHeight = startBottom - startTop;
        int endWidth = endRight - endLeft;
        int endHeight = endBottom - endTop;
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if (numChanges > 0) {
            if (!mResizeClip) {
                Animator anim;
                if (startWidth == endWidth && startHeight == endHeight) {
                    view.offsetLeftAndRight(startLeft - view.getLeft());
                    view.offsetTopAndBottom(startTop - view.getTop());
                    Path positionPath = getPathMotion().getPath(0, 0, endLeft - startLeft, endTop - startTop);
                    anim = ObjectAnimator.ofInt(view, new HorizontalOffsetProperty(), new VerticalOffsetProperty(), positionPath);
                } else {
                    if (startLeft != endLeft)
                        view.setLeft(startLeft);
                    if (startTop != endTop)
                        view.setTop(startTop);
                    if (startRight != endRight)
                        view.setRight(startRight);
                    if (startBottom != endBottom)
                        view.setBottom(startBottom);
                    ObjectAnimator topLeftAnimator = null;
                    if (startLeft != endLeft || startTop != endTop) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        topLeftAnimator = ObjectAnimator.ofInt(view, ""left"", ""top"", topLeftPath);
                    }
                    ObjectAnimator bottomRightAnimator = null;
                    if (startRight != endRight || startBottom != endBottom) {
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        bottomRightAnimator = ObjectAnimator.ofInt(view, ""right"", ""bottom"", bottomRightPath);
                    }
                    anim = TransitionUtils.mergeAnimators(topLeftAnimator, bottomRightAnimator);
                }
                if (view.getParent() instanceof ViewGroup) {
                    final ViewGroup parent = (ViewGroup) view.getParent();
                    parent.suppressLayout(true);
                    TransitionListener transitionListener = new TransitionListenerAdapter() {

                        boolean mCanceled = false;

                        @Override
                        public void onTransitionCancel(Transition transition) {
                            parent.suppressLayout(false);
                            mCanceled = true;
                        }

                        @Override
                        public void onTransitionEnd(Transition transition) {
                            if (!mCanceled) {
                                parent.suppressLayout(false);
                            }
                        }

                        @Override
                        public void onTransitionPause(Transition transition) {
                            parent.suppressLayout(false);
                        }

                        @Override
                        public void onTransitionResume(Transition transition) {
                            parent.suppressLayout(true);
                        }
                    };
                    addListener(transitionListener);
                }
                return anim;
            } else {
                if (startWidth != endWidth)
                    view.setRight(endLeft + Math.max(startWidth, endWidth));
                if (startHeight != endHeight)
                    view.setBottom(endTop + Math.max(startHeight, endHeight));
                // TODO: don't clobber TX/TY
                if (startLeft != endLeft)
                    view.setTranslationX(startLeft - endLeft);
                if (startTop != endTop)
                    view.setTranslationY(startTop - endTop);
                // Animate location with translationX/Y and size with clip bounds
                float transXDelta = endLeft - startLeft;
                float transYDelta = endTop - startTop;
                int widthDelta = endWidth - startWidth;
                int heightDelta = endHeight - startHeight;
                numChanges = 0;
                if (transXDelta != 0)
                    numChanges++;
                if (transYDelta != 0)
                    numChanges++;
                if (widthDelta != 0 || heightDelta != 0)
                    numChanges++;
                ObjectAnimator translationAnimator = null;
                if (transXDelta != 0 || transYDelta != 0) {
                    Path topLeftPath = getPathMotion().getPath(0, 0, transXDelta, transYDelta);
                    translationAnimator = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, View.TRANSLATION_Y, topLeftPath);
                }
                ObjectAnimator clipAnimator = null;
                if (widthDelta != 0 || heightDelta != 0) {
                    Rect tempStartBounds = new Rect(0, 0, startWidth, startHeight);
                    Rect tempEndBounds = new Rect(0, 0, endWidth, endHeight);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, tempStartBounds, tempEndBounds);
                }
                Animator anim = TransitionUtils.mergeAnimators(translationAnimator, clipAnimator);
                if (view.getParent() instanceof ViewGroup) {
                    final ViewGroup parent = (ViewGroup) view.getParent();
                    parent.suppressLayout(true);
                    TransitionListener transitionListener = new TransitionListenerAdapter() {

                        boolean mCanceled = false;

                        @Override
                        public void onTransitionCancel(Transition transition) {
                            parent.suppressLayout(false);
                            mCanceled = true;
                        }

                        @Override
                        public void onTransitionEnd(Transition transition) {
                            if (!mCanceled) {
                                parent.suppressLayout(false);
                            }
                        }

                        @Override
                        public void onTransitionPause(Transition transition) {
                            parent.suppressLayout(false);
                        }

                        @Override
                        public void onTransitionResume(Transition transition) {
                            parent.suppressLayout(true);
                        }
                    };
                    addListener(transitionListener);
                }
                anim.addListener(new AnimatorListenerAdapter() {

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        view.setClipBounds(null);
                    }
                });
                return anim;
            }
        }
    } else {
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X);
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y);
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X);
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y);
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            sceneRoot.getLocationInWindow(tempLocation);
            Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX - tempLocation[0], startY - tempLocation[1], endX - tempLocation[0], endY - tempLocation[1]);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}","{
    if (startValues == null || endValues == null) {
        return null;
    }
    Map<String, Object> startParentVals = startValues.values;
    Map<String, Object> endParentVals = endValues.values;
    ViewGroup startParent = (ViewGroup) startParentVals.get(PROPNAME_PARENT);
    ViewGroup endParent = (ViewGroup) endParentVals.get(PROPNAME_PARENT);
    if (startParent == null || endParent == null) {
        return null;
    }
    final View view = endValues.view;
    if (parentMatches(startParent, endParent)) {
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        final int startLeft = startBounds.left;
        final int endLeft = endBounds.left;
        final int startTop = startBounds.top;
        final int endTop = endBounds.top;
        final int startRight = startBounds.right;
        final int endRight = endBounds.right;
        final int startBottom = startBounds.bottom;
        final int endBottom = endBounds.bottom;
        final int startWidth = startRight - startLeft;
        final int startHeight = startBottom - startTop;
        final int endWidth = endRight - endLeft;
        final int endHeight = endBottom - endTop;
        Rect startClip = (Rect) startValues.values.get(PROPNAME_CLIP);
        Rect endClip = (Rect) endValues.values.get(PROPNAME_CLIP);
        int numChanges = 0;
        if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
            if (startLeft != endLeft || startTop != endTop)
                ++numChanges;
            if (startRight != endRight || startBottom != endBottom)
                ++numChanges;
        }
        if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
            ++numChanges;
        }
        if (numChanges > 0) {
            Animator anim;
            if (!mResizeClip) {
                view.setLeftTopRightBottom(startLeft, startTop, startRight, startBottom);
                if (numChanges == 2) {
                    if (startWidth == endWidth && startHeight == endHeight) {
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        anim = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                    } else {
                        final ViewBounds viewBounds = new ViewBounds(view);
                        Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                        ObjectAnimator topLeftAnimator = ObjectAnimator.ofObject(viewBounds, TOP_LEFT_PROPERTY, null, topLeftPath);
                        Path bottomRightPath = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                        ObjectAnimator bottomRightAnimator = ObjectAnimator.ofObject(viewBounds, BOTTOM_RIGHT_PROPERTY, null, bottomRightPath);
                        AnimatorSet set = new AnimatorSet();
                        set.playTogether(topLeftAnimator, bottomRightAnimator);
                        anim = set;
                        set.addListener(new AnimatorListenerAdapter() {

                            // We need a strong reference to viewBounds until the
                            // animator ends.
                            private ViewBounds mViewBounds = viewBounds;
                        });
                    }
                } else if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    anim = ObjectAnimator.ofObject(view, TOP_LEFT_ONLY_PROPERTY, null, topLeftPath);
                } else {
                    Path bottomRight = getPathMotion().getPath(startRight, startBottom, endRight, endBottom);
                    anim = ObjectAnimator.ofObject(view, BOTTOM_RIGHT_ONLY_PROPERTY, null, bottomRight);
                }
            } else {
                int maxWidth = Math.max(startWidth, endWidth);
                int maxHeight = Math.max(startHeight, endHeight);
                view.setLeftTopRightBottom(startLeft, startTop, startLeft + maxWidth, startTop + maxHeight);
                ObjectAnimator positionAnimator = null;
                if (startLeft != endLeft || startTop != endTop) {
                    Path topLeftPath = getPathMotion().getPath(startLeft, startTop, endLeft, endTop);
                    positionAnimator = ObjectAnimator.ofObject(view, POSITION_PROPERTY, null, topLeftPath);
                }
                final Rect finalClip = endClip;
                if (startClip == null) {
                    startClip = new Rect(0, 0, startWidth, startHeight);
                }
                if (endClip == null) {
                    endClip = new Rect(0, 0, endWidth, endHeight);
                }
                ObjectAnimator clipAnimator = null;
                if (!startClip.equals(endClip)) {
                    view.setClipBounds(startClip);
                    clipAnimator = ObjectAnimator.ofObject(view, ""clipBounds"", sRectEvaluator, startClip, endClip);
                    clipAnimator.addListener(new AnimatorListenerAdapter() {

                        private boolean mIsCanceled;

                        @Override
                        public void onAnimationCancel(Animator animation) {
                            mIsCanceled = true;
                        }

                        @Override
                        public void onAnimationEnd(Animator animation) {
                            if (!mIsCanceled) {
                                view.setClipBounds(finalClip);
                                view.setLeftTopRightBottom(endLeft, endTop, endRight, endBottom);
                            }
                        }
                    });
                }
                anim = TransitionUtils.mergeAnimators(positionAnimator, clipAnimator);
            }
            if (view.getParent() instanceof ViewGroup) {
                final ViewGroup parent = (ViewGroup) view.getParent();
                parent.suppressLayout(true);
                TransitionListener transitionListener = new TransitionListenerAdapter() {

                    boolean mCanceled = false;

                    @Override
                    public void onTransitionCancel(Transition transition) {
                        parent.suppressLayout(false);
                        mCanceled = true;
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        if (!mCanceled) {
                            parent.suppressLayout(false);
                        }
                    }

                    @Override
                    public void onTransitionPause(Transition transition) {
                        parent.suppressLayout(false);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        parent.suppressLayout(true);
                    }
                };
                addListener(transitionListener);
            }
            return anim;
        }
    } else {
        int startX = (Integer) startValues.values.get(PROPNAME_WINDOW_X);
        int startY = (Integer) startValues.values.get(PROPNAME_WINDOW_Y);
        int endX = (Integer) endValues.values.get(PROPNAME_WINDOW_X);
        int endY = (Integer) endValues.values.get(PROPNAME_WINDOW_Y);
        // TODO: also handle size changes: check bounds and animate size changes
        if (startX != endX || startY != endY) {
            sceneRoot.getLocationInWindow(tempLocation);
            Bitmap bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            view.draw(canvas);
            final BitmapDrawable drawable = new BitmapDrawable(bitmap);
            final float transitionAlpha = view.getTransitionAlpha();
            view.setTransitionAlpha(0);
            sceneRoot.getOverlay().add(drawable);
            Path topLeftPath = getPathMotion().getPath(startX - tempLocation[0], startY - tempLocation[1], endX - tempLocation[0], endY - tempLocation[1]);
            PropertyValuesHolder origin = PropertyValuesHolder.ofObject(DRAWABLE_ORIGIN_PROPERTY, null, topLeftPath);
            ObjectAnimator anim = ObjectAnimator.ofPropertyValuesHolder(drawable, origin);
            anim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    sceneRoot.getOverlay().remove(drawable);
                    view.setTransitionAlpha(transitionAlpha);
                }
            });
            return anim;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
37,<android.widget.ImageView: void setImageResource(int)>,21,22,<android.widget.ImageView: void setImageResource(int)>,<android.widget.ImageView: void setImageResource(int)>,0,"{
    if (mUri != null || mResource != resId) {
        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;
        updateDrawable(null);
        mResource = resId;
        mUri = null;
        resolveUri();
        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}","{
    // The resource configuration may have changed, so we should always
    // try to load the resource even if the resId hasn't changed.
    final int oldWidth = mDrawableWidth;
    final int oldHeight = mDrawableHeight;
    updateDrawable(null);
    mResource = resId;
    mUri = null;
    resolveUri();
    if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
        requestLayout();
    }
    invalidate();
}",1,"/**
 * Sets a drawable as the content of this ImageView.
 *
 * <p class=""note"">This does Bitmap reading and decoding on the UI
 * thread, which can cause a latency hiccup.  If that's a concern,
 * consider using {@link #setImageDrawable(android.graphics.drawable.Drawable)} or
 * {@link #setImageBitmap(android.graphics.Bitmap)} and
 * {@link android.graphics.BitmapFactory} instead.</p>
 *
 * @param resId the resource identifier of the drawable
 *
 * @attr ref android.R.styleable#ImageView_src
 */
","/**
 * Sets a drawable as the content of this ImageView.
 *
 * <p class=""note"">This does Bitmap reading and decoding on the UI
 * thread, which can cause a latency hiccup.  If that's a concern,
 * consider using {@link #setImageDrawable(android.graphics.drawable.Drawable)} or
 * {@link #setImageBitmap(android.graphics.Bitmap)} and
 * {@link android.graphics.BitmapFactory} instead.</p>
 *
 * @param resId the resource identifier of the drawable
 *
 * @attr ref android.R.styleable#ImageView_src
 */
",-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"3,4",0,"The change is in the removal of a conditional check (if statement), which implies that the code commonly executed only under specific conditions (when mUri is not null or mResource doesn't equal resId) will now always execute regardless of mUri or mResource values. There's also a comment added in the late version, signifying a change in implementation rationale. This results in both a control dependency change (3) and another statement change due to the removal of the if condition (4).","Although there is a change in the behavior (since the block of code inside the if condition is now always executed), there is no change in the method's external behavior in terms of the output or exceptions thrown. The method does not return any value or throw any different exceptions, so there is no compatibility issue (0)."
38,"<android.view.GLES20Canvas: void drawPatch(NinePatch,Rect,Paint)>",21,22,"<android.view.GLES20Canvas: void drawPatch(NinePatch,Rect,Paint)>","<android.view.GLES20Canvas: void drawPatch(NinePatch,Rect,Paint)>",0,"{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}","{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawPatch(mRenderer, bitmap.mNativeBitmap, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is the removal of the `bitmap.mBuffer` argument from the `nDrawPatch` method call. This is classified as 4 (Other statement changed) as it is a change in the arguments passed to a method call but is neither a control structure, return statement, exception handling statement, nor a dependent API change.","There's no Compatibility Issue as the change is an internal implementation detail and does not affect the API's signature, the values it returns, the exceptions it throws, or the behavior observable by calling the public API method in question."
41,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,21,22,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,0,"{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Long jniSetter = propertyMap.get(mPropertyName);
            if (jniSetter != null) {
                mJniSetter = jniSetter;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetFloatMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Long>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    synchronized (sJNISetterPropertyMap) {
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        boolean wasInMap = false;
        if (propertyMap != null) {
            wasInMap = propertyMap.containsKey(mPropertyName);
            if (wasInMap) {
                Long jniSetter = propertyMap.get(mPropertyName);
                if (jniSetter != null) {
                    mJniSetter = jniSetter;
                }
            }
        }
        if (!wasInMap) {
            String methodName = getMethodName(""set"", mPropertyName);
            try {
                mJniSetter = nGetFloatMethod(targetClass, methodName);
            } catch (NoSuchMethodError e) {
            // Couldn't find it via JNI - try reflection next. Probably means the method
            // doesn't exist, or the type is wrong. An error will be logged later if
            // reflection fails as well.
            }
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Long>();
                sJNISetterPropertyMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, mJniSetter);
        }
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The code changes include the replacement of a lock mechanism with synchronized block, moving the NoSuchMethodError try-catch block inside the conditional block, and adding a check for the presence of a property name in the propertyMap before attempting JNI retrieval or reflection. These changes fall into categories 2,3,4.",The refactored code introduces potential behavioral differences:
42,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,21,22,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: "" + mSourceNodeId);
        builder.append(""; accessibilityViewId: "" + getAccessibilityViewId(mSourceNodeId));
        builder.append(""; virtualDescendantId: "" + getVirtualDescendantId(mSourceNodeId));
        builder.append(""; mParentNodeId: "" + mParentNodeId);
        builder.append(""; traversalBefore: "").append(mTraversalBefore);
        builder.append(""; traversalAfter: "").append(mTraversalAfter);
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(childIds.get(i));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "" + mBoundsInParent);
    builder.append(""; boundsInScreen: "" + mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
44,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,21,22,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean removeAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,0,"{
    // Final CopyOnArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.remove(listener);
}","{
    // Final CopyOnWriteArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.remove(listener);
}",1,"/**
 * Unregisters an {@link AccessibilityStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
","/**
 * Unregisters an {@link AccessibilityStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the method implementation between the two versions. Only a comment has been corrected, which does not affect the method's behavior.","Since there's no change in the actual code, there is no Compatibility Issue between these versions."
45,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,21,22,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,0,"{
    switch(message.what) {
        case MSG_ON_START:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""onStart()"");
                }
                ((PrintDocumentAdapter) message.obj).onStart();
            }
            break;
        case MSG_ON_LAYOUT:
            {
                SomeArgs args = (SomeArgs) message.obj;
                PrintDocumentAdapter adapter = (PrintDocumentAdapter) args.arg1;
                PrintAttributes oldAttributes = (PrintAttributes) args.arg2;
                PrintAttributes newAttributes = (PrintAttributes) args.arg3;
                CancellationSignal cancellation = (CancellationSignal) args.arg4;
                LayoutResultCallback callback = (LayoutResultCallback) args.arg5;
                Bundle metadata = (Bundle) args.arg6;
                args.recycle();
                if (DEBUG) {
                    StringBuilder builder = new StringBuilder();
                    builder.append(""PrintDocumentAdapter#onLayout() {\n"");
                    builder.append(""\n  oldAttributes:"").append(oldAttributes);
                    builder.append(""\n  newAttributes:"").append(newAttributes);
                    builder.append(""\n  preview:"").append(metadata.getBoolean(PrintDocumentAdapter.EXTRA_PRINT_PREVIEW));
                    builder.append(""\n}"");
                    Log.i(LOG_TAG, builder.toString());
                }
                adapter.onLayout(oldAttributes, newAttributes, cancellation, callback, metadata);
            }
            break;
        case MSG_ON_WRITE:
            {
                SomeArgs args = (SomeArgs) message.obj;
                PrintDocumentAdapter adapter = (PrintDocumentAdapter) args.arg1;
                PageRange[] pages = (PageRange[]) args.arg2;
                ParcelFileDescriptor fd = (ParcelFileDescriptor) args.arg3;
                CancellationSignal cancellation = (CancellationSignal) args.arg4;
                WriteResultCallback callback = (WriteResultCallback) args.arg5;
                args.recycle();
                if (DEBUG) {
                    StringBuilder builder = new StringBuilder();
                    builder.append(""PrintDocumentAdapter#onWrite() {\n"");
                    builder.append(""\n  pages:"").append(Arrays.toString(pages));
                    builder.append(""\n}"");
                    Log.i(LOG_TAG, builder.toString());
                }
                adapter.onWrite(pages, fd, cancellation, callback);
            }
            break;
        case MSG_ON_FINISH:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""onFinish()"");
                }
                ((PrintDocumentAdapter) message.obj).onFinish();
                // should not be used anymore.
                synchronized (mLock) {
                    destroyLocked();
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + message.what);
            }
    }
}","{
    switch(message.what) {
        case MSG_ON_START:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""onStart()"");
                }
                ((PrintDocumentAdapter) message.obj).onStart();
            }
            break;
        case MSG_ON_LAYOUT:
            {
                SomeArgs args = (SomeArgs) message.obj;
                PrintDocumentAdapter adapter = (PrintDocumentAdapter) args.arg1;
                PrintAttributes oldAttributes = (PrintAttributes) args.arg2;
                PrintAttributes newAttributes = (PrintAttributes) args.arg3;
                CancellationSignal cancellation = (CancellationSignal) args.arg4;
                LayoutResultCallback callback = (LayoutResultCallback) args.arg5;
                Bundle metadata = (Bundle) args.arg6;
                args.recycle();
                if (DEBUG) {
                    StringBuilder builder = new StringBuilder();
                    builder.append(""PrintDocumentAdapter#onLayout() {\n"");
                    builder.append(""\n  oldAttributes:"").append(oldAttributes);
                    builder.append(""\n  newAttributes:"").append(newAttributes);
                    builder.append(""\n  preview:"").append(metadata.getBoolean(PrintDocumentAdapter.EXTRA_PRINT_PREVIEW));
                    builder.append(""\n}"");
                    Log.i(LOG_TAG, builder.toString());
                }
                adapter.onLayout(oldAttributes, newAttributes, cancellation, callback, metadata);
            }
            break;
        case MSG_ON_WRITE:
            {
                SomeArgs args = (SomeArgs) message.obj;
                PrintDocumentAdapter adapter = (PrintDocumentAdapter) args.arg1;
                PageRange[] pages = (PageRange[]) args.arg2;
                ParcelFileDescriptor fd = (ParcelFileDescriptor) args.arg3;
                CancellationSignal cancellation = (CancellationSignal) args.arg4;
                WriteResultCallback callback = (WriteResultCallback) args.arg5;
                args.recycle();
                if (DEBUG) {
                    StringBuilder builder = new StringBuilder();
                    builder.append(""PrintDocumentAdapter#onWrite() {\n"");
                    builder.append(""\n  pages:"").append(Arrays.toString(pages));
                    builder.append(""\n}"");
                    Log.i(LOG_TAG, builder.toString());
                }
                adapter.onWrite(pages, fd, cancellation, callback);
            }
            break;
        case MSG_ON_FINISH:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""onFinish()"");
                }
                ((PrintDocumentAdapter) message.obj).onFinish();
                // should not be used anymore.
                synchronized (mLock) {
                    destroyLocked();
                }
            }
            break;
        case MSG_ON_KILL:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""onKill()"");
                }
                String reason = (String) message.obj;
                throw new RuntimeException(reason);
            }
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + message.what);
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
48,<android.widget.DatePickerCalendarDelegate: void setMinDate(long)>,21,22,<android.widget.DatePickerCalendarDelegate: void setMinDate(long)>,<android.widget.DatePickerCalendarDelegate: void setMinDate(long)>,0,"{
    mTempDate.setTimeInMillis(minDate);
    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMinDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    if (mCurrentDate.before(mTempDate)) {
        mCurrentDate.setTimeInMillis(minDate);
        updatePickers();
        updateDisplay(false);
    }
    mMinDate.setTimeInMillis(minDate);
    mDayPickerView.goTo(getSelectedDay(), false, true, true);
}","{
    mTempDate.setTimeInMillis(minDate);
    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMinDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    if (mCurrentDate.before(mTempDate)) {
        mCurrentDate.setTimeInMillis(minDate);
        onDateChanged(false, true);
    }
    mMinDate.setTimeInMillis(minDate);
    mDayPickerView.setMinDate(minDate);
    mYearPickerView.setRange(mMinDate, mMaxDate);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation changes from calling updatePickers() and updateDisplay(false) to calling onDateChanged(false, true), setMinDate(minDate) on mDayPickerView, and setRange(mMinDate, mMaxDate) on mYearPickerView. These changes involve updating internal states and UI differently, hence categorized as 4.","As these changes relate to internal handling of date changes and visual updates and do not result in different return values or exceptions being thrown, there is no Compatibility Issue that could arise from these changes with respect to different return values or exception handlings."
51,<android.net.Network: void bindSocket(Socket)>,21,22,<android.net.Network: void bindSocket(Socket)>,<android.net.Network: void bindSocket(Socket)>,0,"{
    if (socket.isConnected()) {
        throw new SocketException(""Socket is connected"");
    }
    // Query a property of the underlying socket to ensure the underlying
    // socket exists so a file descriptor is available to bind to a network.
    socket.getReuseAddress();
    int err = NetworkUtils.bindSocketToNetwork(socket.getFileDescriptor$().getInt$(), netId);
    if (err != 0) {
        // bindSocketToNetwork returns negative errno.
        throw new ErrnoException(""Binding socket to network "" + netId, -err).rethrowAsSocketException();
    }
}","{
    // Apparently, the kernel doesn't update a connected TCP socket's routing upon mark changes.
    if (socket.isConnected()) {
        throw new SocketException(""Socket is connected"");
    }
    // Query a property of the underlying socket to ensure that the socket's file descriptor
    // exists, is available to bind to a network and is not closed.
    socket.getReuseAddress();
    bindSocketFd(socket.getFileDescriptor$());
}",1,"/**
 * Binds the specified {@link Socket} to this {@code Network}. All data traffic on the socket
 * will be sent on this {@code Network}, irrespective of any process-wide network binding set by
 * {@link ConnectivityManager#setProcessDefaultNetwork}. The socket must not be connected.
 */
","/**
 * Binds the specified {@link Socket} to this {@code Network}. All data traffic on the socket
 * will be sent on this {@code Network}, irrespective of any process-wide network binding set by
 * {@link ConnectivityManager#setProcessDefaultNetwork}. The socket must not be connected.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",0,There are multiple changes between the early and the late version:,"- There's no returned value, and no exceptions that the method itself generates has been modified or added in the late version, except for the propagation of exceptions that would already be thrown by the methods it invokes."
55,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",21,22,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    boolean usingRenderNodeProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!usingRenderNodeProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    usingRenderNodeProperties &= hasDisplayList;
    if (usingRenderNodeProperties) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
            usingRenderNodeProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!usingRenderNodeProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!usingRenderNodeProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (usingRenderNodeProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = usingRenderNodeProperties ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (usingRenderNodeProperties) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !usingRenderNodeProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (usingRenderNodeProperties) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + (mRight - mLeft), scrollY + (mBottom - mTop), multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!usingRenderNodeProperties) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!usingRenderNodeProperties && hasDisplayList) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !usingRenderNodeProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                int restoreAlpha = mLayerPaint.getAlpha();
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                mLayerPaint.setAlpha(restoreAlpha);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                    if (mOverlay != null && !mOverlay.isEmpty()) {
                        mOverlay.getOverlayView().draw(canvas);
                    }
                } else {
                    draw(canvas);
                }
                drawAccessibilityFocus(canvas);
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawRenderNode(renderNode, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        int restoreAlpha = 0;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
        } else {
            cachePaint = mLayerPaint;
            restoreAlpha = mLayerPaint.getAlpha();
        }
        cachePaint.setAlpha((int) (alpha * 255));
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        cachePaint.setAlpha(restoreAlpha);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    boolean usingRenderNodeProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!usingRenderNodeProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (usingRenderNodeProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    usingRenderNodeProperties &= hasDisplayList;
    if (usingRenderNodeProperties) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
            usingRenderNodeProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!usingRenderNodeProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!usingRenderNodeProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (usingRenderNodeProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = usingRenderNodeProperties ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (usingRenderNodeProperties) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !usingRenderNodeProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (usingRenderNodeProperties) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + (mRight - mLeft), scrollY + (mBottom - mTop), multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!usingRenderNodeProperties) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!usingRenderNodeProperties && hasDisplayList) {
        renderNode = getDisplayList();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !usingRenderNodeProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                int restoreAlpha = mLayerPaint.getAlpha();
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                mLayerPaint.setAlpha(restoreAlpha);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawRenderNode(renderNode, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        int restoreAlpha = 0;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
        } else {
            cachePaint = mLayerPaint;
            restoreAlpha = mLayerPaint.getAlpha();
        }
        cachePaint.setAlpha((int) (alpha * 255));
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        cachePaint.setAlpha(restoreAlpha);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
57,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",21,22,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean readOnly;
                readOnly = data.readInt() != 0;
                int resultCode = mountSecureContainer(id, key, ownerUid, readOnly);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = encryptStorage(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = changeEncryptionPassword(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPasswordType:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getPasswordType();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String result = getPassword();
                reply.writeNoException();
                reply.writeString(result);
                return true;
            }
        case TRANSACTION_clearPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                clearPassword();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = data.readString();
                setField(field, contents);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = getField(field);
                reply.writeNoException();
                reply.writeString(contents);
                return true;
            }
        case TRANSACTION_resizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String key;
                key = data.readString();
                int resultCode = resizeSecureContainer(id, sizeMb, key);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean readOnly;
                readOnly = data.readInt() != 0;
                int resultCode = mountSecureContainer(id, key, ownerUid, readOnly);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = encryptStorage(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                int type = data.readInt();
                String password = data.readString();
                int result = changeEncryptionPassword(type, password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPasswordType:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getPasswordType();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String result = getPassword();
                reply.writeNoException();
                reply.writeString(result);
                return true;
            }
        case TRANSACTION_clearPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                clearPassword();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_setField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = data.readString();
                setField(field, contents);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_getField:
            {
                data.enforceInterface(DESCRIPTOR);
                String field = data.readString();
                String contents = getField(field);
                reply.writeNoException();
                reply.writeString(contents);
                return true;
            }
        case TRANSACTION_resizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String key;
                key = data.readString();
                int resultCode = resizeSecureContainer(id, sizeMb, key);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_lastMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                long lastMaintenance = lastMaintenance();
                reply.writeNoException();
                reply.writeLong(lastMaintenance);
                return true;
            }
        case TRANSACTION_runMaintenance:
            {
                data.enforceInterface(DESCRIPTOR);
                runMaintenance();
                reply.writeNoException();
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
59,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",21,22,"<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Boolean> removeAccount(Account,AccountManagerCallback<Boolean>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.removeAccount(mResponse, account, false);
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException(""no result in response"");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}",1,"/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 */
","/**
 * Removes an account from the AccountManager.  Does nothing if the account
 * does not exist.  Does not delete the account from the server.
 * The authenticator may have its own policies preventing account
 * deletion, in which case the account will not be deleted.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The {@link Account} to remove
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account has been successfully removed
 * @deprecated use
 * {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}
 * instead
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",0,"The change involves modifying the parameter list in the call to mService.removeAccount method within the doWork() method, adding a `false` boolean value. This constitutes a change in the dependent API, so the code change type is 5. However, since the return type, exception thrown, and control flow do not change, and the modification is internal to the API implementation without altering the external behavior, there's also a change in the 'other statements', which corresponds to the code change type 4.","Despite the added parameter within the internal API call, the behavior exposed to the API client should remain consistentreturning a Future object that yields a Boolean. Consequently, the modification should not cause a compatibility issue related to different return values or types; therefore, the CI type is 0."
60,<android.animation.FloatKeyframeSet: FloatKeyframeSet clone()>,21,22,<android.animation.FloatKeyframeSet: FloatKeyframeSet clone()>,<android.animation.FloatKeyframeSet: FloatKeyframeSet clone()>,0,"{
    ArrayList<Keyframe> keyframes = mKeyframes;
    int numKeyframes = mKeyframes.size();
    FloatKeyframe[] newKeyframes = new FloatKeyframe[numKeyframes];
    for (int i = 0; i < numKeyframes; ++i) {
        newKeyframes[i] = (FloatKeyframe) keyframes.get(i).clone();
    }
    FloatKeyframeSet newSet = new FloatKeyframeSet(newKeyframes);
    return newSet;
}","{
    final List<Keyframe> keyframes = mKeyframes;
    final int numKeyframes = mKeyframes.size();
    FloatKeyframe[] newKeyframes = new FloatKeyframe[numKeyframes];
    for (int i = 0; i < numKeyframes; ++i) {
        newKeyframes[i] = (FloatKeyframe) keyframes.get(i).clone();
    }
    FloatKeyframeSet newSet = new FloatKeyframeSet(newKeyframes);
    return newSet;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no functional change between the early and late version of the API. The only changes are the added 'final' modifiers. 'final' keywords do not affect the functionality or output of the code; it's just a language construct to prevent reassignment.,"As there are no functional changes, there is no Compatibility Issue. The API behaves identically in both versions."
61,<android.widget.TextView: int getRightPaddingOffset()>,21,22,<android.widget.TextView: int getRightPaddingOffset()>,<android.widget.TextView: int getRightPaddingOffset()>,0,"{
    return -(getCompoundPaddingRight() - mPaddingRight) + (int) Math.max(0, mShadowDx + mShadowRadius);
}","{
    return -(getFudgedPaddingRight() - mPaddingRight) + (int) Math.max(0, mShadowDx + mShadowRadius);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change is the replacement of the method getCompoundPaddingRight() with getFudgedPaddingRight(). There are no changes to control structures, return statements or exception handling. Therefore, the change type is 5.","There is no indication that the replacement of getCompoundPaddingRight() with getFudgedPaddingRight() will lead to different behavior, as long as getFudgedPaddingRight() provides a value that's semantically equivalent for the purpose of this method in the context of the classs contract. Given the information, we cannot assume a CI, therefore the CI prediction is 0."
64,<android.service.notification.ZenModeConfig.DowntimeInfo: boolean equals(Object)>,21,22,<android.service.notification.ZenModeConfig.DowntimeInfo: boolean equals(Object)>,<android.service.notification.ZenModeConfig.DowntimeInfo: boolean equals(Object)>,0,"{
    if (!(o instanceof DowntimeInfo))
        return false;
    final DowntimeInfo other = (DowntimeInfo) o;
    return startHour == other.startHour && startMinute == other.startMinute && endHour == other.endHour && endMinute == other.endMinute;
}","{
    if (!(o instanceof DowntimeInfo))
        return false;
    final DowntimeInfo other = (DowntimeInfo) o;
    return startHour == other.startHour && startMinute == other.startMinute && endHour == other.endHour && endMinute == other.endMinute && Objects.equals(mode, other.mode) && none == other.none;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The change includes the addition of new equality checks in the return statement (Objects.equals(mode, other.mode) && none == other.none), hence the code change type is 1,4.","The additional checks in the return statement for mode and none properties indicate that the equals() method may return a different result for the same inputs between the two versions. Thus, there is a potential Compatibility Issue of type 1, as it can return a different boolean value."
69,<android.net.ProxyInfo: String toString()>,21,22,<android.net.ProxyInfo: String toString()>,<android.net.ProxyInfo: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    if (!Uri.EMPTY.equals(mPacFileUrl)) {
        sb.append(""PAC Script: "");
        sb.append(mPacFileUrl);
    } else if (mHost != null) {
        sb.append(""["");
        sb.append(mHost);
        sb.append(""] "");
        sb.append(Integer.toString(mPort));
        if (mExclusionList != null) {
            sb.append("" xl="").append(mExclusionList);
        }
    } else {
        sb.append(""[ProxyProperties.mHost == null]"");
    }
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    if (!Uri.EMPTY.equals(mPacFileUrl)) {
        sb.append(""PAC Script: "");
        sb.append(mPacFileUrl);
    }
    if (mHost != null) {
        sb.append(""["");
        sb.append(mHost);
        sb.append(""] "");
        sb.append(Integer.toString(mPort));
        if (mExclusionList != null) {
            sb.append("" xl="").append(mExclusionList);
        }
    } else {
        sb.append(""[ProxyProperties.mHost == null]"");
    }
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control dependency based on the condition `else if (mHost != null)` has been modified to be a separate `if (mHost != null)` block. This is a control dependency change, hence the code change type is 3.","The change in control dependency affects when each block of code is executed. Since the conditions that lead to the execution of code that appends strings to the StringBuilder `sb` have changed, the resulting string returned by the `toString()` method could be different. Therefore, a Compatibility Issue arises due to the potential for the method to return different values. The CI type is 1."
70,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",21,22,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, nativePaint);
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, left, top, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The parameter 'bitmap.mBuffer' was removed from the method call to nDrawBitmap(). This constitutes a change to one of the statements, so the code change type is 4.","Since the removed parameter does not alter the behavior in terms of different return values or types (as the method is void and doesnt return anything), and it does not change the way exceptions are thrown, there is no Compatibility Issue, so the CI type is 0."
71,<android.app.Notification.WearableExtender: Builder extend(Builder)>,21,22,<android.app.Notification.WearableExtender: Builder extend(Builder)>,<android.app.Notification.WearableExtender: Builder extend(Builder)>,0,"{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}","{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    if (mHintScreenTimeout != 0) {
        wearableBundle.putInt(KEY_HINT_SCREEN_TIMEOUT, mHintScreenTimeout);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}",1,"/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */
","/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the code has an additional block to check if `mHintScreenTimeout` is not zero and if so, it puts that into the wearableBundle. This is a new addition compared to the early version. Thus there has been an Other statement changed (as a new conditional block is added) and a Return statement changed (as the additional data in the bundle could potentially modify the returned `Builder` object).","The change could potentially lead to the API returning a `Builder` with a different state, as the state of the `Builder` is altered by including additional wearable data (`mHintScreenTimeout`) if it's non-zero. Hence, the API could return a different value due to this change, corresponding to CI type 1."
72,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,21,22,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mLabeledById);
}",1,"/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
","/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The method's implementation has changed from performing a sequence of checks and potentially fetching the node from an AccessibilityInteractionClient to now calling 'getNodeForAccessibilityId(mLabeledById)' directly. There's also a change in control dependency due to removal of 'if' condition. The dependent API 'getNodeForAccessibilityId' is called instead of 'AccessibilityInteractionClient.getInstance()' and other methods, making the changes type 3,5.","Since the control structure and the method being called have changed, and we do not have information on the implementation of 'getNodeForAccessibilityId', this could potentially lead to a different return value - causing a CI of type 1."
74,"<android.view.ViewGroup: void addView(View,int,LayoutParams)>",21,22,"<android.view.ViewGroup: void addView(View,int,LayoutParams)>","<android.view.ViewGroup: void addView(View,int,LayoutParams)>",0,"{
    if (DBG) {
        System.out.println(this + "" addView"");
    }
    // addViewInner() will call child.requestLayout() when setting the new LayoutParams
    // therefore, we call requestLayout() on ourselves before, so that the child's request
    // will be blocked at our level
    requestLayout();
    invalidate(true);
    addViewInner(child, index, params, false);
}","{
    if (DBG) {
        System.out.println(this + "" addView"");
    }
    if (child == null) {
        throw new IllegalArgumentException(""Cannot add a null child view to a ViewGroup"");
    }
    // addViewInner() will call child.requestLayout() when setting the new LayoutParams
    // therefore, we call requestLayout() on ourselves before, so that the child's request
    // will be blocked at our level
    requestLayout();
    invalidate(true);
    addViewInner(child, index, params, false);
}",1,"/**
 * Adds a child view with the specified layout parameters.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 *
 * @param child the child view to add
 * @param index the position at which to add the child
 * @param params the layout parameters to set on the child
 */
","/**
 * Adds a child view with the specified layout parameters.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 *
 * @param child the child view to add
 * @param index the position at which to add the child
 * @param params the layout parameters to set on the child
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new condition with a throw exception statement has been introduced (if (child == null)), changing the exception handling in the method, and hence the code change types are 2,3.","The new exception handling statement introduced (throw new IllegalArgumentException) may cause a Compatibility Issue as it changes the behavior of the method by throwing an exception in cases where it previously did not, which is a CI type 2."
77,<android.hardware.camera2.legacy.RequestThreadManager: void quit()>,21,22,<android.hardware.camera2.legacy.RequestThreadManager: void quit()>,<android.hardware.camera2.legacy.RequestThreadManager: void quit()>,0,"{
    Handler handler = mRequestThread.waitAndGetHandler();
    handler.sendMessageAtFrontOfQueue(handler.obtainMessage(MSG_CLEANUP));
    mRequestThread.quitSafely();
    try {
        mRequestThread.join();
    } catch (InterruptedException e) {
        Log.e(TAG, String.format(""Thread %s (%d) interrupted while quitting."", mRequestThread.getName(), mRequestThread.getId()));
    }
}","{
    if (!mQuit.getAndSet(true)) {
        // Avoid sending messages on dead thread's handler.
        Handler handler = mRequestThread.waitAndGetHandler();
        handler.sendMessageAtFrontOfQueue(handler.obtainMessage(MSG_CLEANUP));
        mRequestThread.quitSafely();
        try {
            mRequestThread.join();
        } catch (InterruptedException e) {
            Log.e(TAG, String.format(""Thread %s (%d) interrupted while quitting."", mRequestThread.getName(), mRequestThread.getId()));
        }
    }
}",1,"/**
 * Quit the request thread, and clean up everything.
 */
","/**
 * Quit the request thread, and clean up everything.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A control dependency has been introduced with an if-statement checking mQuit.getAndSet(true), and the rest of the code is nested inside of this check. The added control statement is a check to avoid running the contained code if mQuit is already set to true. This is the only change, so the code change type is 3.","The new check ensures that the quit process is only undergone if mQuit is not already true. If mQuit is true, the function does nothing and returns early, which is a new behavior introduced in the late version. However, the underlying behavior of the function when it actually performs the quit operation (the core purpose of this method) remains unchanged. The early return simply prevents redundant operations and does not affect the functional outcome (i.e., performing a quit operation that is intended to be performed only once per object's lifecycle). Therefore, this does not constitute a compatibility issue because it does not affect how the method behaves when it's allowed to perform its intended operation. The return type and exceptions thrown remain the same; hence, we have no compatibility issue."
79,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,21,22,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        if (!getOrCreateDeviceIdListLocked().contains(cameraId)) {
            throw new IllegalArgumentException(String.format(""Camera id %s does not match any"" + "" currently connected camera device"", cameraId));
        }
        int id = Integer.valueOf(cameraId);
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = getCameraServiceLocked();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                String[] outParameters = new String[1];
                cameraService.getLegacyParameters(id, /*out*/
                outParameters);
                String parameters = outParameters[0];
                CameraInfo info = new CameraInfo();
                cameraService.getCameraInfo(id, /*out*/
                info);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = new CameraMetadataNative();
                cameraService.getCameraCharacteristics(id, info);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        if (!getOrCreateDeviceIdListLocked().contains(cameraId)) {
            throw new IllegalArgumentException(String.format(""Camera id %s does not match any"" + "" currently connected camera device"", cameraId));
        }
        int id = Integer.valueOf(cameraId);
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                String[] outParameters = new String[1];
                cameraService.getLegacyParameters(id, /*out*/
                outParameters);
                String parameters = outParameters[0];
                CameraInfo info = new CameraInfo();
                cameraService.getCameraInfo(id, /*out*/
                info);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = new CameraMetadataNative();
                cameraService.getCameraCharacteristics(id, info);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera is disabled by device policy, or
 * the camera device has been disconnected.
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera is disabled by device policy, or
 * the camera device has been disconnected.
 * @throws SecurityException if the application does not have permission to
 * access the camera
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is in the way the `cameraService` is retrieved. In the early version, it is obtained using `getCameraServiceLocked()`, and in the late version, it is obtained using `CameraManagerGlobal.get().getCameraService()`. This change indicates a Dependent API change, so the code change type is 5.","Since the mechanism for retrieving the camera service has been updated, but the change does not affect the APIs output or the exceptions it can throw, there is no compatibility issue detected between the early and late version regarding different return values, types, or exception handling. Thus, the CI type is 0."
80,<android.app.Notification.Action.WearableExtender: Builder extend(Builder)>,21,22,<android.app.Notification.Action.WearableExtender: Builder extend(Builder)>,<android.app.Notification.Action.WearableExtender: Builder extend(Builder)>,0,"{
    Bundle wearableBundle = new Bundle();
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}","{
    Bundle wearableBundle = new Bundle();
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mInProgressLabel != null) {
        wearableBundle.putCharSequence(KEY_IN_PROGRESS_LABEL, mInProgressLabel);
    }
    if (mConfirmLabel != null) {
        wearableBundle.putCharSequence(KEY_CONFIRM_LABEL, mConfirmLabel);
    }
    if (mCancelLabel != null) {
        wearableBundle.putCharSequence(KEY_CANCEL_LABEL, mCancelLabel);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}",1,"/**
 * Apply wearable extensions to a notification action that is being built. This is
 * typically called by the {@link android.app.Notification.Action.Builder#extend}
 * method of {@link android.app.Notification.Action.Builder}.
 */
","/**
 * Apply wearable extensions to a notification action that is being built. This is
 * typically called by the {@link android.app.Notification.Action.Builder#extend}
 * method of {@link android.app.Notification.Action.Builder}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The changes include adding control flow conditions and adding other statements (putCharSequence calls) within the conditions, so the code change type is 3 for the control statement change and 4 for the other statements that have been added.","No Compatibility Issue arises from these changes, as they are adding extra data to a Bundle that is used for extended functionality. The core behavior of returning the same Builder object is not altered, so the returned type and exceptions thrown remain consistent between versions."
82,<android.widget.SearchView: int getImeOptions()>,21,22,<android.widget.SearchView: int getImeOptions()>,<android.widget.SearchView: int getImeOptions()>,0,"{
    return mQueryTextView.getImeOptions();
}","{
    return mSearchSrcTextView.getImeOptions();
}",1,"/**
 * Returns the IME options set on the query text field.
 * @return the ime options
 * @see TextView#setImeOptions(int)
 *
 * @attr ref android.R.styleable#SearchView_imeOptions
 */
","/**
 * Returns the IME options set on the query text field.
 * @return the ime options
 * @see TextView#setImeOptions(int)
 *
 * @attr ref android.R.styleable#SearchView_imeOptions
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The dependent API has changed from `mQueryTextView.getImeOptions()` to `mSearchSrcTextView.getImeOptions()`. The change type is 5 because it involves changing the object on which the method getImeOptions() is called.,"Assuming `mQueryTextView` and `mSearchSrcTextView` are equivalent in terms of functionality for the method `getImeOptions()`, which the method name suggests, no Compatibility Issue arises from the change itself, as long as the method signature of `getImeOptions()` remains the same. The code change updates the internal member variable that is used to call `getImeOptions()`, which should not affect the behavior as seen by the user of the API. Therefore, the API should still return the same value assuming these member variables are semantically equivalent, which leads to a determination of no Compatibility Issue. The return type and the possible values are expected to remain consistent before and after the change, due to the same method `getImeOptions()` being invoked."
83,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int)>",21,22,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int)>",0,"{
    return registerListener(listener, sensor, rateUs, null);
}","{
    return registerListener(listener, sensor, samplingPeriodUs, null);
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * <p class=""note""></p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.
 * Use {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead.
 * </p>
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rateUs
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}
 * or, the desired delay between events in microseconds.
 * Specifying the delay in microseconds only works from Android
 * 2.3 (API level 9) onwards. For earlier releases, you must use
 * one of the {@code SENSOR_DELAY_*} constants.
 *
 * @return <code>true</code> if the sensor is supported and successfully
 * enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int, Handler)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
 * sensor at the given sampling frequency.
 * <p>
 * The events will be delivered to the provided {@code SensorEventListener} as soon as they are
 * available. To reduce the power consumption, applications can use
 * {@link #registerListener(SensorEventListener, Sensor, int, int)} instead and specify a
 * positive non-zero maximum reporting latency.
 * </p>
 * <p>
 * In the case of non-wake-up sensors, the events are only delivered while the Application
 * Processor (AP) is not in suspend mode. See {@link Sensor#isWakeUpSensor()} for more details.
 * To ensure delivery of events from non-wake-up sensors even when the screen is OFF, the
 * application registering to the sensor must hold a partial wake-lock to keep the AP awake,
 * otherwise some events might be lost while the AP is asleep. Note that although events might
 * be lost while the AP is asleep, the sensor will still consume power if it is not explicitly
 * deactivated by the application. Applications must unregister their {@code
 * SensorEventListener}s in their activity's {@code onPause()} method to avoid consuming power
 * while the device is inactive.  See {@link #registerListener(SensorEventListener, Sensor, int,
 * int)} for more details on hardware FIFO (queueing) capabilities and when some sensor events
 * might be lost.
 * </p>
 * <p>
 * In the case of wake-up sensors, each event generated by the sensor will cause the AP to
 * wake-up, ensuring that each event can be delivered. Because of this, registering to a wake-up
 * sensor has very significant power implications. Call {@link Sensor#isWakeUpSensor()} to check
 * whether a sensor is a wake-up sensor. See
 * {@link #registerListener(SensorEventListener, Sensor, int, int)} for information on how to
 * reduce the power impact of registering to wake-up sensors.
 * </p>
 * <p class=""note"">
 * Note: Don't use this method with one-shot trigger sensors such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}. Use
 * {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead. Use
 * {@link Sensor#getReportingMode()} to obtain the reporting mode of a given sensor.
 * </p>
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param samplingPeriodUs The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be received faster or
 * slower than the specified rate. Usually events are received faster. The value must
 * be one of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST} or, the desired delay
 * between events in microseconds. Specifying the delay in microseconds only works
 * from Android 2.3 (API level 9) onwards. For earlier releases, you must use one of
 * the {@code SENSOR_DELAY_*} constants.
 * @return <code>true</code> if the sensor is supported and successfully enabled.
 * @see #registerListener(SensorEventListener, Sensor, int, Handler)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the name of the variable passed to the registerListener method (from rateUs to samplingPeriodUs). This is purely a renaming of the variable and does not affect the behavior or the functionality of the method. Hence, the code change type is 4.","There is no Compatibility Issue because the renaming of the variable does not alter the way the API behaves. Therefore, the type of CI is 0."
84,<android.animation.PropertyValuesHolder.MultiIntValuesHolder: void setupSetter(Class)>,21,22,<android.animation.PropertyValuesHolder.MultiIntValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.MultiIntValuesHolder: void setupSetter(Class)>,0,"{
    if (mJniSetter != 0) {
        return;
    }
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Long jniSetterLong = propertyMap.get(mPropertyName);
            if (jniSetterLong != null) {
                mJniSetter = jniSetterLong;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            calculateValue(0f);
            int[] values = (int[]) getAnimatedValue();
            int numParams = values.length;
            try {
                mJniSetter = nGetMultipleIntMethod(targetClass, methodName, numParams);
            } catch (NoSuchMethodError e) {
                // try without the 'set' prefix
                mJniSetter = nGetMultipleIntMethod(targetClass, mPropertyName, numParams);
            }
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Long>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
}","{
    if (mJniSetter != 0) {
        return;
    }
    synchronized (sJNISetterPropertyMap) {
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        boolean wasInMap = false;
        if (propertyMap != null) {
            wasInMap = propertyMap.containsKey(mPropertyName);
            if (wasInMap) {
                Long jniSetter = propertyMap.get(mPropertyName);
                if (jniSetter != null) {
                    mJniSetter = jniSetter;
                }
            }
        }
        if (!wasInMap) {
            String methodName = getMethodName(""set"", mPropertyName);
            calculateValue(0f);
            int[] values = (int[]) getAnimatedValue();
            int numParams = values.length;
            try {
                mJniSetter = nGetMultipleIntMethod(targetClass, methodName, numParams);
            } catch (NoSuchMethodError e) {
                // try without the 'set' prefix
                try {
                    mJniSetter = nGetMultipleIntMethod(targetClass, mPropertyName, numParams);
                } catch (NoSuchMethodError e2) {
                // couldn't find it.
                }
            }
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Long>();
                sJNISetterPropertyMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, mJniSetter);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",0,"The exception handling statements have been changed to include an additional nested try-catch for NoSuchMethodError, and the thread synchronization mechanism for accessing `sJNISetterPropertyMap` has been changed from a `ReadWriteLock` to a synchronized block. The additional check for `wasInMap` and the condition in the if-statement have also been modified; thus, the code change type is 2,3,4.","Although there are changes to exception handling and synchronization mechanism, these changes do not affect the external behavior regarding the return value of the method or the exceptions that could be thrown to the users of the API. The core logic of how `mJniSetter` is set remains the same, and the additional NoSuchMethodError catch block does not introduce a new kind of exception to be thrown by `setupSetter`. It still handles internal issues without exposing them to the user. Therefore, these alterations do not constitute a Compatibility Issue because they will not lead to different API behaviors from the perspective of an API consumer."
85,<android.appwidget.AppWidgetHost: void stopListening()>,21,22,<android.appwidget.AppWidgetHost: void stopListening()>,<android.appwidget.AppWidgetHost: void stopListening()>,0,"{
    try {
        sService.stopListening(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}","{
    try {
        sService.stopListening(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}",1,"/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
","/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has a Dependent API changed: The argument passed to sService.stopListening() method has changed from 'mContext.getOpPackageName()' to 'mContextOpPackageName', implying a change in the dependent API.","There is no Compatibility Issue since the method's side effects and behavior remain consistent. It still performs the same actions and throws the same exception type. Only the way the package name is obtained has changed, which does not affect the external behavior of the method from the caller's perspective."
87,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,21,22,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                perfromAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        case MSG_COMPUTE_CLICK_POINT_IN_SCREEN:
            {
                computeClickPointInScreenUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                perfromAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"No code between the early version and the late version has been changed. The structure and flow of the method remained the same, as did the method calls within the switch statement and the default case throwing an exception.","Since there is no change in the method's code, there is no compatibility issue between the two versions."
88,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,21,22,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean addAccessibilityStateChangeListener(AccessibilityStateChangeListener)>,0,"{
    // Final CopyOnArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.add(listener);
}","{
    // Final CopyOnWriteArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.add(listener);
}",1,"/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
","/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementation between the early and late versions; only a comment typo was corrected.,"Since there is no change in the code implementation, no compatibility issue could arise."
90,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>",21,22,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>","<android.app.LocalActivityManager: Window startActivity(String,Intent)>",0,"{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<Intent> intents = new ArrayList<Intent>(1);
                intents.add(intent);
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                mActivityThread.performNewIntents(r, intents);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}","{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<ReferrerIntent> intents = new ArrayList<>(1);
                intents.add(new ReferrerIntent(intent, mParent.getPackageName()));
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                mActivityThread.performNewIntents(r, intents);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}",1,"/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
","/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
91,<android.service.wallpaper.WallpaperService.Engine: void detach()>,21,22,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mDisplayManager != null) {
        mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement has been added for unregistering a display listener if `mDisplayManager` is not null. This is a new operational statement that was not present in the early version. Therefore, it is classified as type 4.","The added operational statement does not affect the API's return value or the exceptions it throws. It adds additional cleanup functionality. Hence, there is no Compatibility Issue since the API's externally observable behavior remains consistent between the two versions."
92,"<android.preference.SeekBarVolumizer.Receiver: void onReceive(Context,Intent)>",21,22,"<android.preference.SeekBarVolumizer.Receiver: void onReceive(Context,Intent)>","<android.preference.SeekBarVolumizer.Receiver: void onReceive(Context,Intent)>",0,"{
    if (!AudioManager.VOLUME_CHANGED_ACTION.equals(intent.getAction()))
        return;
    final int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
    final int streamValue = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1);
    if (mSeekBar != null && streamType == mStreamType && streamValue != -1) {
        mUiHandler.postUpdateSlider(streamValue);
    }
}","{
    final String action = intent.getAction();
    if (AudioManager.VOLUME_CHANGED_ACTION.equals(action)) {
        int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
        int streamValue = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1);
        final boolean streamMatch = mNotificationOrRing ? isNotificationOrRing(streamType) : (streamType == mStreamType);
        if (mSeekBar != null && streamMatch && streamValue != -1) {
            final boolean muted = mAudioManager.isStreamMute(mStreamType);
            mUiHandler.postUpdateSlider(streamValue, muted);
        }
    } else if (AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION.equals(action)) {
        if (mNotificationOrRing) {
            mRingerMode = mAudioManager.getRingerModeInternal();
        }
        if (mAffectedByRingerMode) {
            updateSlider();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","There are multiple changes between the early and late implementation: new local variable `action` is introduced and replaces the inlined `intent.getAction()` call, the logic for evaluating `streamMatch` has been altered to include `mNotificationOrRing` conditional check, and a new control path that handles a different action `AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION` is added. An additional parameter is passed to `mUiHandler.postUpdateSlider` method call, which is `muted`. The `isStreamMute` method and `getRingerModeInternal` method from `mAudioManager` are called, which weren't in the early version. The code change types include 1 (because of the additional parameter to `mUiHandler.postUpdateSlider`), 3 (due to the introduction of a new `if` construct and changes within existing `if` conditions), 4 (for introducing the new variable `action` and changing the way `streamMatch` is calculated), and 5 (since the implementation now depends on additional methods of `mAudioManager` which represents a dependent API).","The API now potentially returns different behaviors based on new conditions and calls to `mAudioManager`. There are Compatibility Issues due to potentially different return values or types (such as not returning immediately but instead executing new branches of the code when the action matches `AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION`), and the exception handling within the method has actually been changed (although not explicitly visible in the method itself, the call to `mUiHandler.postUpdateSlider(streamValue, muted);` could behave differently because of the additional `muted` parameter indicating a state that wasn't accounted for in the early version). This results in Compatibility Issue types 1 and 2."
94,"<android.view.View: void measure(int,int)>",21,22,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}","{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;
    final boolean isExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY && MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;
    final boolean matchingSize = isExactly && getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) && getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);
    if (forceLayout || !matchingSize && (widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec)) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimensionRaw((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
95,"<android.app.ApplicationErrorReport: ComponentName getErrorReportReceiver(Context,String,int)>",21,22,"<android.app.ApplicationErrorReport: ComponentName getErrorReportReceiver(Context,String,int)>","<android.app.ApplicationErrorReport: ComponentName getErrorReportReceiver(Context,String,int)>",0,"{
    // check if error reporting is enabled in secure settings
    int enabled = Settings.Global.getInt(context.getContentResolver(), Settings.Global.SEND_ACTION_APP_ERROR, 0);
    if (enabled == 0) {
        return null;
    }
    PackageManager pm = context.getPackageManager();
    // look for receiver in the installer package
    String candidate = pm.getInstallerPackageName(packageName);
    ComponentName result = getErrorReportReceiver(pm, packageName, candidate);
    if (result != null) {
        return result;
    }
    // error receiver
    if ((appFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        candidate = SystemProperties.get(SYSTEM_APPS_ERROR_RECEIVER_PROPERTY);
        result = getErrorReportReceiver(pm, packageName, candidate);
        if (result != null) {
            return result;
        }
    }
    // if there is a default receiver, try that
    candidate = SystemProperties.get(DEFAULT_ERROR_RECEIVER_PROPERTY);
    return getErrorReportReceiver(pm, packageName, candidate);
}","{
    // check if error reporting is enabled in secure settings
    int enabled = Settings.Global.getInt(context.getContentResolver(), Settings.Global.SEND_ACTION_APP_ERROR, 0);
    if (enabled == 0) {
        return null;
    }
    PackageManager pm = context.getPackageManager();
    // look for receiver in the installer package
    String candidate = null;
    ComponentName result = null;
    try {
        candidate = pm.getInstallerPackageName(packageName);
    } catch (IllegalArgumentException e) {
    // the package could already removed
    }
    if (candidate != null) {
        result = getErrorReportReceiver(pm, packageName, candidate);
        if (result != null) {
            return result;
        }
    }
    // error receiver
    if ((appFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        candidate = SystemProperties.get(SYSTEM_APPS_ERROR_RECEIVER_PROPERTY);
        result = getErrorReportReceiver(pm, packageName, candidate);
        if (result != null) {
            return result;
        }
    }
    // if there is a default receiver, try that
    candidate = SystemProperties.get(DEFAULT_ERROR_RECEIVER_PROPERTY);
    return getErrorReportReceiver(pm, packageName, candidate);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",1,"The late implementation introduces a try-catch block to handle IllegalArgumentException which was not present in the early version. This constitutes an exception handling statement change (2). Additionally, a control dependency change (3) is present because the subsequent check 'if (candidate != null)' and the statement 'result = getErrorReportReceiver(pm, packageName, candidate);' within this condition are now dependent on the successful execution of the try block, which did not exist previously. Lastly, the variable 'candidate' and 'result' are initialized to null explicitly in the late version without the catch block effect, which is another statement change (4) not affecting the overall control flow.","The late implementation may not throw an IllegalArgumentException to the caller when the package has been removed, in contrast to the early implementation which would allow the exception to propagate up the call stack because it was uncaught. This change can potentially lead to a Compatibility Issue (1) because the early version may result in an unhandled exception while the late version will not, leading to potentially different return values or different exception handling behavior."
99,"<android.hardware.camera2.legacy.ParameterUtils: Face convertFaceFromLegacy(Face,Rect,ZoomData)>",21,22,"<android.hardware.camera2.legacy.ParameterUtils: Face convertFaceFromLegacy(Face,Rect,ZoomData)>","<android.hardware.camera2.legacy.ParameterUtils: Face convertFaceFromLegacy(Face,Rect,ZoomData)>",0,"{
    checkNotNull(face, ""face must not be null"");
    Face api2Face;
    Camera.Area fakeArea = new Camera.Area(face.rect, /*weight*/
    1);
    WeightedRectangle faceRect = convertCameraAreaToActiveArrayRectangle(activeArray, zoomData, fakeArea);
    Point leftEye = face.leftEye, rightEye = face.rightEye, mouth = face.mouth;
    if (leftEye != null && rightEye != null && mouth != null) {
        leftEye = convertCameraPointToActiveArrayPoint(activeArray, zoomData, leftEye, /*usePreviewCrop*/
        true);
        rightEye = convertCameraPointToActiveArrayPoint(activeArray, zoomData, leftEye, /*usePreviewCrop*/
        true);
        mouth = convertCameraPointToActiveArrayPoint(activeArray, zoomData, leftEye, /*usePreviewCrop*/
        true);
        api2Face = faceRect.toFace(face.id, leftEye, rightEye, mouth);
    } else {
        api2Face = faceRect.toFace();
    }
    return api2Face;
}","{
    checkNotNull(face, ""face must not be null"");
    Face api2Face;
    Camera.Area fakeArea = new Camera.Area(face.rect, /*weight*/
    1);
    WeightedRectangle faceRect = convertCameraAreaToActiveArrayRectangle(activeArray, zoomData, fakeArea);
    Point leftEye = face.leftEye, rightEye = face.rightEye, mouth = face.mouth;
    if (leftEye != null && rightEye != null && mouth != null && leftEye.x != -2000 && leftEye.y != -2000 && rightEye.x != -2000 && rightEye.y != -2000 && mouth.x != -2000 && mouth.y != -2000) {
        leftEye = convertCameraPointToActiveArrayPoint(activeArray, zoomData, leftEye, /*usePreviewCrop*/
        true);
        rightEye = convertCameraPointToActiveArrayPoint(activeArray, zoomData, leftEye, /*usePreviewCrop*/
        true);
        mouth = convertCameraPointToActiveArrayPoint(activeArray, zoomData, leftEye, /*usePreviewCrop*/
        true);
        api2Face = faceRect.toFace(face.id, leftEye, rightEye, mouth);
    } else {
        api2Face = faceRect.toFace();
    }
    return api2Face;
}",1,"/**
 * Convert an api1 face into an active-array based api2 face.
 *
 * <p>Out-of-ranges scores and ids will be clipped to be within range (with a warning).</p>
 *
 * @param face a non-{@code null} api1 face
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param zoomData the calculated zoom data corresponding to this request
 *
 * @return a non-{@code null} api2 face
 *
 * @throws NullPointerException if the {@code face} was {@code null}
 */
","/**
 * Convert an api1 face into an active-array based api2 face.
 *
 * <p>Out-of-ranges scores and ids will be clipped to be within range (with a warning).</p>
 *
 * @param face a non-{@code null} api1 face
 * @param activeArraySize active array size of the sensor (e.g. max jpeg size)
 * @param zoomData the calculated zoom data corresponding to this request
 *
 * @return a non-{@code null} api2 face
 *
 * @throws NullPointerException if the {@code face} was {@code null}
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The change has happened in the condition statement of the 'if' block, which includes additional checks for coordinates not being equal to -2000 in the late version. Hence, the code change type is 3.","The added conditions in the 'if' block can alter the control flow. In cases where the left eye, right eye, or mouth's x or y values are -2000, the old version would proceed to convert these points and create a Face object with them. However, the new version will now skip this step and return a Face object without specific Point information, affecting the return value. Thus, the CI type is 1 due to potentially different return values based on the updated condition."
100,<android.net.Network: URLConnection openConnection(URL)>,21,22,<android.net.Network: URLConnection openConnection(URL)>,<android.net.Network: URLConnection openConnection(URL)>,0,"{
    maybeInitHttpClient();
    String protocol = url.getProtocol();
    OkHttpClient client;
    // TODO: Should the network's proxy be specified?
    if (protocol.equals(""http"")) {
        client = HttpHandler.createHttpOkHttpClient(null);
    } else if (protocol.equals(""https"")) {
        client = HttpsHandler.createHttpsOkHttpClient(null);
    } else {
        // passed another protocol.
        throw new MalformedURLException(""Invalid URL or unrecognized protocol "" + protocol);
    }
    return client.setSocketFactory(getSocketFactory()).setHostResolver(mHostResolver).setConnectionPool(mConnectionPool).open(url);
}","{
    final ConnectivityManager cm = ConnectivityManager.getInstance();
    // TODO: Should this be optimized to avoid fetching the global proxy for every request?
    ProxyInfo proxyInfo = cm.getGlobalProxy();
    if (proxyInfo == null) {
        // TODO: Should this be optimized to avoid fetching LinkProperties for every request?
        final LinkProperties lp = cm.getLinkProperties(this);
        if (lp != null)
            proxyInfo = lp.getHttpProxy();
    }
    java.net.Proxy proxy = null;
    if (proxyInfo != null) {
        proxy = proxyInfo.makeProxy();
    } else {
        proxy = java.net.Proxy.NO_PROXY;
    }
    return openConnection(url, proxy);
}",1,"/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
","/**
 * Opens the specified {@link URL} on this {@code Network}, such that all traffic will be sent
 * on this Network. The URL protocol must be {@code HTTP} or {@code HTTPS}.
 *
 * @return a {@code URLConnection} to the resource referred to by this URL.
 * @throws MalformedURLException if the URL protocol is not HTTP or HTTPS.
 * @throws IOException if an error occurs while opening the connection.
 * @see java.net.URL#openConnection()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2",The late version of the code introduces a completely different implementation:,- The method calls are done with different parameters and call chains.
102,<android.webkit.URLUtil: String guessUrl(String)>,21,22,<android.webkit.URLUtil: String guessUrl(String)>,<android.webkit.URLUtil: String guessUrl(String)>,0,"{
    String retVal = inUrl;
    WebAddress webAddress;
    if (DebugFlags.URL_UTIL)
        Log.v(LOGTAG, ""guessURL before queueRequest: "" + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith(""about:""))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith(""data:""))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith(""file:""))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith(""javascript:""))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(""."") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (DebugFlags.URL_UTIL) {
            Log.v(LOGTAG, ""smartUrlFilter: failed to parse url = "" + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.getHost().indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.setHost(""www."" + webAddress.getHost() + "".com"");
    }
    return webAddress.toString();
}","{
    String retVal = inUrl;
    WebAddress webAddress;
    if (TRACE)
        Log.v(LOGTAG, ""guessURL before queueRequest: "" + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith(""about:""))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith(""data:""))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith(""file:""))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith(""javascript:""))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(""."") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (TRACE) {
            Log.v(LOGTAG, ""smartUrlFilter: failed to parse url = "" + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.getHost().indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.setHost(""www."" + webAddress.getHost() + "".com"");
    }
    return webAddress.toString();
}",1,"/**
 * Cleans up (if possible) user-entered web addresses
 */
","/**
 * Cleans up (if possible) user-entered web addresses
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is in a logging statement, which uses TRACE instead of DebugFlags.URL_UTIL for the conditional check. This is a change involving debug logging, which does not affect the API's external behavior or the values it returns, so the code change type is 4.","Despite the changed logging detail, it will not cause any compatibility issues since it doesn't affect the return value of the method or its exception handling, thus the CI type is 0."
104,<android.view.View: void setClipBounds(Rect)>,21,22,<android.view.View: void setClipBounds(Rect)>,<android.view.View: void setClipBounds(Rect)>,0,"{
    if (clipBounds != null) {
        if (clipBounds.equals(mClipBounds)) {
            return;
        }
        if (mClipBounds == null) {
            invalidate();
            mClipBounds = new Rect(clipBounds);
        } else {
            invalidate(Math.min(mClipBounds.left, clipBounds.left), Math.min(mClipBounds.top, clipBounds.top), Math.max(mClipBounds.right, clipBounds.right), Math.max(mClipBounds.bottom, clipBounds.bottom));
            mClipBounds.set(clipBounds);
        }
    } else {
        if (mClipBounds != null) {
            invalidate();
            mClipBounds = null;
        }
    }
    mRenderNode.setClipBounds(mClipBounds);
}","{
    if (clipBounds == mClipBounds || (clipBounds != null && clipBounds.equals(mClipBounds))) {
        return;
    }
    if (clipBounds != null) {
        if (mClipBounds == null) {
            mClipBounds = new Rect(clipBounds);
        } else {
            mClipBounds.set(clipBounds);
        }
    } else {
        mClipBounds = null;
    }
    mRenderNode.setClipBounds(mClipBounds);
    invalidateViewProperty(false, false);
}",1,"/**
 * Sets a rectangular area on this view to which the view will be clipped
 * when it is drawn. Setting the value to null will remove the clip bounds
 * and the view will draw normally, using its full bounds.
 *
 * @param clipBounds The rectangular area, in the local coordinates of
 * this view, to which future drawing operations will be clipped.
 */
","/**
 * Sets a rectangular area on this view to which the view will be clipped
 * when it is drawn. Setting the value to null will remove the clip bounds
 * and the view will draw normally, using its full bounds.
 *
 * @param clipBounds The rectangular area, in the local coordinates of
 * this view, to which future drawing operations will be clipped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition statements have been refactored and optimized, and the invalidate() calls have been replaced with a single invalidateViewProperty() call outside of the condition branches. These changes are control dependency (due to refactoring of the condition statements) and other statement change types (due to alteration of invalidate() logic), so the code change type is 3,4.","Although the control flow and some statements have been modified, the functionality has not changed in a way that could lead to a different behavior of the API from a client's point of view. The setClipBounds(Rect clipBounds) method is concerned with setting the view's clipping bounds and then invalidating the view property. The refactor preserves this behavior and no additional behavior has been introduced that could result in a changed return value (since its a void method) or a change in the exceptions thrown. Thus, there is no Compatibility Issue; the CI type is 0."
105,<android.animation.ValueAnimator: boolean animationFrame(long)>,21,22,<android.animation.ValueAnimator: boolean animationFrame(long)>,<android.animation.ValueAnimator: boolean animationFrame(long)>,0,"{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}","{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (mDuration == 0 && mRepeatCount != INFINITE) {
                // Skip to the end
                mCurrentIteration = mRepeatCount;
                if (!mReversing) {
                    mPlayingBackwards = false;
                }
            }
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}",1,"/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code>, has been exceeded and the animation should be ended.
 */
","/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code>, has been exceeded and the animation should be ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There's no difference in the implementation of the early and late versions of the method. The only addition is a condition checking if `mDuration == 0 && mRepeatCount != INFINITE` without changing the flow of logic because it defaults to the same values as would naturally occur if that condition weren't present. Therefore the behavior is not altered.,"There is no compatibility issue, as the behavior of the method has not changed between the early and late versions. The additional condition in the late version does not introduce a scenario where the method would behave differently."
106,"<android.view.GLES20Canvas: void drawText(CharSequence,int,int,float,float,Paint)>",21,22,"<android.view.GLES20Canvas: void drawText(CharSequence,int,int,float,float,Paint)>","<android.view.GLES20Canvas: void drawText(CharSequence,int,int,float,float,Paint)>",0,"{
    if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
        nDrawText(mRenderer, text.toString(), start, end, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
    } else if (text instanceof GraphicsOperations) {
        ((GraphicsOperations) text).drawText(this, start, end, x, y, paint);
    } else {
        char[] buf = TemporaryBuffer.obtain(end - start);
        TextUtils.getChars(text, start, end, buf, 0);
        nDrawText(mRenderer, buf, 0, end - start, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
        TemporaryBuffer.recycle(buf);
    }
}","{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
        nDrawText(mRenderer, text.toString(), start, end, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
    } else if (text instanceof GraphicsOperations) {
        ((GraphicsOperations) text).drawText(this, start, end, x, y, paint);
    } else {
        char[] buf = TemporaryBuffer.obtain(end - start);
        TextUtils.getChars(text, start, end, buf, 0);
        nDrawText(mRenderer, buf, 0, end - start, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
        TemporaryBuffer.recycle(buf);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The late version introduces a new if block that can potentially throw an IndexOutOfBoundsException and a new control dependency for parameter bounds checking, so the code change type is 2,3.","The introduction of a new if block that throws IndexOutOfBoundsException is a CI because if the start, end, or the calculated range (end - start) is negative, or if the range exceeds the length of the text, an IndexOutOfBoundsException will be thrown in the new version whereas the old version would not throw an exception in this case. Therefore, the CI type is 2 due to the potential difference in exception handling."
111,<android.widget.AppSecurityPermissions.MyPermissionGroupInfo: Drawable loadGroupIcon(PackageManager)>,21,22,<android.widget.AppSecurityPermissions.MyPermissionGroupInfo: Drawable loadGroupIcon(PackageManager)>,<android.widget.AppSecurityPermissions.MyPermissionGroupInfo: Drawable loadGroupIcon(PackageManager)>,0,"{
    if (icon != 0) {
        return loadIcon(pm);
    } else {
        ApplicationInfo appInfo;
        try {
            appInfo = pm.getApplicationInfo(packageName, 0);
            return appInfo.loadIcon(pm);
        } catch (NameNotFoundException e) {
        }
    }
    return null;
}","{
    if (icon != 0) {
        return loadUnbadgedIcon(pm);
    } else {
        ApplicationInfo appInfo;
        try {
            appInfo = pm.getApplicationInfo(packageName, 0);
            return appInfo.loadUnbadgedIcon(pm);
        } catch (NameNotFoundException e) {
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method name called within the if statement and in the try block is changed from loadIcon to loadUnbadgedIcon, which indicates that the method used to load the icon has been modified, but this does not constitute a change in control flow or exception handling. Therefore, the code change types are 4,5.","These changes to the dependent methods used to load icons (from loadIcon to loadUnbadgedIcon) could potentially return different Drawable objects since a different method is being called. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
112,<android.bluetooth.BluetoothAdapter: IBluetooth getBluetoothService(IBluetoothManagerCallback)>,21,22,<android.bluetooth.BluetoothAdapter: IBluetooth getBluetoothService(IBluetoothManagerCallback)>,<android.bluetooth.BluetoothAdapter: IBluetooth getBluetoothService(IBluetoothManagerCallback)>,0,"{
    synchronized (mManagerCallback) {
        if (cb == null) {
            Log.w(TAG, ""getBluetoothService() called with no BluetoothManagerCallback"");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}","{
    synchronized (mProxyServiceStateCallbacks) {
        if (cb == null) {
            Log.w(TAG, ""getBluetoothService() called with no BluetoothManagerCallback"");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the object that is being synchronized on: from `mManagerCallback` to `mProxyServiceStateCallbacks`. This is a synchronization lock change, so the code change type is 4.","Despite the change in the synchronization lock, the external behavior of the API, including the return value and exceptions that might be thrown, does not change because of this modification. Therefore, there are no Compatibility Issues introduced by this change."
113,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,21,22,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,<android.hardware.display.DisplayManagerInternal.DisplayPowerRequest: boolean equals(DisplayPowerRequest)>,0,"{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}","{
    return other != null && policy == other.policy && useProximitySensor == other.useProximitySensor && screenBrightness == other.screenBrightness && screenAutoBrightnessAdjustment == other.screenAutoBrightnessAdjustment && useAutoBrightness == other.useAutoBrightness && blockScreenOn == other.blockScreenOn && lowPowerMode == other.lowPowerMode && boostScreenBrightness == other.boostScreenBrightness && dozeScreenBrightness == other.dozeScreenBrightness && dozeScreenState == other.dozeScreenState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The equals method now includes a comparison for the 'boostScreenBrightness' field which was not present in the early version, while all the other fields remain unchanged. This is indicated by the new presence of ""boostScreenBrightness == other.boostScreenBrightness"" in the late implementation. Therefore, the code change type is 1 due to the different return statement involving an additional equality check.","Considering the additional field comparison, the method could potentially return a different result for an otherwise identical 'DisplayPowerRequest' object if the value of 'boostScreenBrightness' differs between the two. This addition may result in objects that were previously considered equal no longer being so in situations where 'boostScreenBrightness' does not match. Thus, the compatibility issue type is 1, caused by potential different return values."
114,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,21,22,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,0,"{
    if (mView == null || !mAdded) {
        Slog.w(TAG, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if (!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isTerminalInputEvent(q.mEvent)) {
        // If this is a focused event and the window doesn't currently have input focus,
        // then drop this event.  This could be an event that came back from the previous
        // stage but the window has lost focus in the meantime.
        Slog.w(TAG, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}","{
    if (mView == null || !mAdded) {
        Slog.w(TAG, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus || mStopped) && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER)) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(TAG, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(TAG, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4","1,2","The condition `!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isTerminalInputEvent(q.mEvent)` has been altered to `(!mAttachInfo.mHasWindowFocus || mStopped) && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER)` and the subsequent nested conditionals have been restructured. There is an addition of calling `q.mEvent.cancel()` for terminal input events, which means both return statement and other statement have changed.","The alteration in control flow and the condition structure can lead to different return values for certain input events. Before, terminal input events would always be dropped if there was no window focus, but now they are merely cancelled and not dropped. Additionally, the `mStopped` condition introduces another state in which events might be dropped. This leads to a potential difference in both return values and exception handling (though this specific change does not involve exceptions directly, the use of `q.mEvent.cancel()` could potentially interact with exception handling elsewhere)."
116,"<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>",21,22,"<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>","<android.animation.AnimatorInflater: StateListAnimator loadStateListAnimator(Context,int)>",0,"{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createStateListAnimatorFromXml(context, parser, Xml.asAttributeSet(parser));
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null) {
            parser.close();
        }
    }
}","{
    final Resources resources = context.getResources();
    final ConfigurationBoundResourceCache<StateListAnimator> cache = resources.getStateListAnimatorCache();
    final Theme theme = context.getTheme();
    StateListAnimator animator = cache.get(id, theme);
    if (animator != null) {
        return animator;
    }
    XmlResourceParser parser = null;
    try {
        parser = resources.getAnimation(id);
        animator = createStateListAnimatorFromXml(context, parser, Xml.asAttributeSet(parser));
        if (animator != null) {
            animator.appendChangingConfigurations(getChangingConfigs(resources, id));
            final ConstantState<StateListAnimator> constantState = animator.createConstantState();
            if (constantState != null) {
                cache.put(id, theme, constantState);
                // return a clone so that the animator in constant state is never used.
                animator = constantState.newInstance(resources, theme);
            }
        }
        return animator;
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException(""Can't load state list animator resource ID #0x"" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null) {
            parser.close();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,There are multiple changes in the late implementation:,3) Creation and return of a new instance of the animator to ensure that the constant state is never used directly.
117,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",21,22,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>","<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",0,"{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new LinkAddress(address, prefixLength), null));
    mConfig.updateAllowedFamilies(address);
    return this;
}","{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new IpPrefix(address, prefixLength), null));
    mConfig.updateAllowedFamilies(address);
    return this;
}",1,"/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
","/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's a change in the code where `new RouteInfo(new LinkAddress(address, prefixLength), null)` is replaced with `new RouteInfo(new IpPrefix(address, prefixLength), null)`. Both `LinkAddress` and `IpPrefix` are used to encapsulate the IP address and the network prefix length, but the constructor being called is different. This change signifies that a different method or constructor is being used to create the `RouteInfo` object, which is a change in the dependent API (5). Besides, no control dependency has changed, no return statement has changed, and no exception handling statement has changed. Thus, other than a dependent API change, only the other statement changed (4).","There seems to be no Compatibility Issue since the method still throws the same exception for the same condition, and the returned object (this) remains unchanged. The change in how the `RouteInfo` object is created doesn't affect the behavior of the `addRoute` method as far as the API's contract is concerned. The internal representation may differ, but the method's observable behavior, from an API consumer's perspective, remains consistent. Hence, there is no Compatibility Issue (0)."
118,<android.widget.OverScroller.SplineOverScroller: boolean update()>,21,22,<android.widget.OverScroller.SplineOverScroller: boolean update()>,<android.widget.OverScroller.SplineOverScroller: boolean update()>,0,"{
    final long time = AnimationUtils.currentAnimationTimeMillis();
    final long currentTime = time - mStartTime;
    if (currentTime > mDuration) {
        return false;
    }
    double distance = 0.0;
    switch(mState) {
        case SPLINE:
            {
                final float t = (float) currentTime / mSplineDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                distance = distanceCoef * mSplineDistance;
                mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;
                break;
            }
        case BALLISTIC:
            {
                final float t = currentTime / 1000.0f;
                mCurrVelocity = mVelocity + mDeceleration * t;
                distance = mVelocity * t + mDeceleration * t * t / 2.0f;
                break;
            }
        case CUBIC:
            {
                final float t = (float) (currentTime) / mDuration;
                final float t2 = t * t;
                final float sign = Math.signum(mVelocity);
                distance = sign * mOver * (3.0f * t2 - 2.0f * t * t2);
                mCurrVelocity = sign * mOver * 6.0f * (-t + t2);
                break;
            }
    }
    mCurrentPosition = mStart + (int) Math.round(distance);
    return true;
}","{
    final long time = AnimationUtils.currentAnimationTimeMillis();
    final long currentTime = time - mStartTime;
    if (currentTime == 0) {
        // Skip work but report that we're still going if we have a nonzero duration.
        return mDuration > 0;
    }
    if (currentTime > mDuration) {
        return false;
    }
    double distance = 0.0;
    switch(mState) {
        case SPLINE:
            {
                final float t = (float) currentTime / mSplineDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                distance = distanceCoef * mSplineDistance;
                mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;
                break;
            }
        case BALLISTIC:
            {
                final float t = currentTime / 1000.0f;
                mCurrVelocity = mVelocity + mDeceleration * t;
                distance = mVelocity * t + mDeceleration * t * t / 2.0f;
                break;
            }
        case CUBIC:
            {
                final float t = (float) (currentTime) / mDuration;
                final float t2 = t * t;
                final float sign = Math.signum(mVelocity);
                distance = sign * mOver * (3.0f * t2 - 2.0f * t * t2);
                mCurrVelocity = sign * mOver * 6.0f * (-t + t2);
                break;
            }
    }
    mCurrentPosition = mStart + (int) Math.round(distance);
    return true;
}",1,"/*
         * Update the current position and velocity for current time. Returns
         * true if update has been done and false if animation duration has been
         * reached.
         */
","/*
         * Update the current position and velocity for current time. Returns
         * true if update has been done and false if animation duration has been
         * reached.
         */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There are both control dependency change and return statement change between the versions. Specifically, there's an additional check for when currentTime == 0, which can alter the return value based on the duration (mDuration > 0), and potentially skip the rest of the code block that would otherwise be executed. This is a control dependency and return statement change.","The change in control flow introduces a new behavior where if currentTime is 0, the method now potentially returns true if mDuration > 0, even though previously it would proceed to compute other values. This can lead to the API returning a different value than before in cases where currentTime is 0 and mDuration is nonzero, which constitutes a compatibility issue due to potentially different return values."
119,<android.view.View: void setLabelFor(int)>,21,22,<android.view.View: void setLabelFor(int)>,<android.view.View: void setLabelFor(int)>,0,"{
    mLabelForId = id;
    if (mLabelForId != View.NO_ID && mID == View.NO_ID) {
        mID = generateViewId();
    }
}","{
    if (mLabelForId == id) {
        return;
    }
    mLabelForId = id;
    if (mLabelForId != View.NO_ID && mID == View.NO_ID) {
        mID = generateViewId();
    }
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
}",1,"/**
 * Sets the id of a view for which this view serves as a label for
 * accessibility purposes.
 *
 * @param id The labeled view id.
 */
","/**
 * Sets the id of a view for which this view serves as a label for
 * accessibility purposes.
 *
 * @param id The labeled view id.
 */
",-1,[@RemotableViewMethod],[@RemotableViewMethod],-1,-1,-1,-1,-1,-1,"3,4",0,"The change includes the addition of an early 'return' when mLabelForId is equal to the input id, and a new call to notifyViewAccessibilityStateChangedIfNeeded() has been added. Therefore, the code change type is 3,4.","There is no Compatibility Issue because these changes won't cause the method to return a different value or throw a different exception. The method's return type is 'void', so no return value is affected, and there's no alteration in exception handling. The additional return statement only short-circuits the method execution when the condition is met, which doesn't change the API's behavior in a way that would cause previous client code to misbehave. Similarly, the added notification for accessibility state does not constitute a behavior change that would lead to a Compatibility Issue. Therefore, the CI type is 0."
120,"<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",21,22,"<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>","<com.android.server.backup.SystemBackupAgent: void onBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",0,"{
    // We only back up the data under the current ""wallpaper"" schema with metadata
    IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
    String[] files = new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO };
    String[] keys = new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY };
    if (wallpaper != null) {
        try {
            final String wallpaperName = wallpaper.getName();
            if (wallpaperName != null && wallpaperName.length() > 0) {
                // When the wallpaper has a name, back up the info by itself.
                // TODO: Don't rely on the innards of the service object like this!
                // TODO: Send a delete for any stored wallpaper image in this case?
                files = new String[] { WALLPAPER_INFO };
                keys = new String[] { WALLPAPER_INFO_KEY };
            }
        } catch (RemoteException re) {
            Slog.e(TAG, ""Couldn't get wallpaper name\n"" + re);
        }
    }
    addHelper(""wallpaper"", new WallpaperBackupHelper(SystemBackupAgent.this, files, keys));
    super.onBackup(oldState, data, newState);
}","{
    // We only back up the data under the current ""wallpaper"" schema with metadata
    IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
    String[] files = new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO };
    String[] keys = new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY };
    if (wallpaper != null) {
        try {
            final String wallpaperName = wallpaper.getName();
            if (wallpaperName != null && wallpaperName.length() > 0) {
                // When the wallpaper has a name, back up the info by itself.
                // TODO: Don't rely on the innards of the service object like this!
                // TODO: Send a delete for any stored wallpaper image in this case?
                files = new String[] { WALLPAPER_INFO };
                keys = new String[] { WALLPAPER_INFO_KEY };
            }
        } catch (RemoteException re) {
            Slog.e(TAG, ""Couldn't get wallpaper name\n"" + re);
        }
    }
    addHelper(""wallpaper"", new WallpaperBackupHelper(SystemBackupAgent.this, files, keys));
    addHelper(""recents"", new RecentsBackupHelper(SystemBackupAgent.this));
    super.onBackup(oldState, data, newState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The new method call addHelper(""recents"", new RecentsBackupHelper(SystemBackupAgent.this)); is added to the method body which doesn't change existing control flows, return statements, or exception handling. It is therefore categorized as an ""Other statement changed.""","Since this is an addition of a new helper without altering the existing behavior or control flow of the method, there would be no Compatibility Issue from this change. The new functionality is additive and does not modify the implementation behavior of the existing method."
121,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,21,22,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""restoreState"");
    return mProvider.restoreState(inState);
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""restoreState"");
    return mProvider.restoreState(inState);
}",1,"/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
","/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change here is the condition check for the logging, from DebugFlags.TRACE_API to TRACE, which is a change of static variable or constant used for debugging purposes. Hence, the change type is 4.","No Compatibility Issue arises from this change because the debugging log has no effect on the method's return value, control flow, or thrown exceptions. Therefore, the API's behavior remains the same in terms of its functionality."
122,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,21,22,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (needsMenuKey != o.needsMenuKey) {
        needsMenuKey = o.needsMenuKey;
        changes |= NEEDS_MENU_KEY_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
124,<android.view.WindowManager.LayoutParams: String toString()>,21,22,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (!surfaceInsets.equals(Insets.NONE)) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (preferredRefreshRate != 0) {
        sb.append("" preferredRefreshRate="");
        sb.append(preferredRefreshRate);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    if (!surfaceInsets.equals(Insets.NONE)) {
        sb.append("" surfaceInsets="").append(surfaceInsets);
    }
    if (needsMenuKey != NEEDS_MENU_UNSET) {
        sb.append("" needsMenuKey="");
        sb.append(needsMenuKey);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
128,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,21,22,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,0,"{
    if (mEnteringNames == null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
        }
        return true;
    }
}","{
    if (mEnteringNames == null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                decor.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        finalDecor.getViewTreeObserver().removeOnPreDrawListener(this);
                        if (mReturnExitCoordinator != null) {
                            mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                        }
                        return true;
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Changes have been made in the control flow and a new variable `delayExitBack` was introduced. A conditional block has been added if `delayExitBack && decor != null`, and there's a new anonymous class ViewTreeObserver.OnPreDrawListener with an `onPreDraw()` method that contains the `mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);` call. This leads to multiple statement changes, including a new control dependency change and other statement changes, so the code change type is 1,3,4.","The changes can lead to a potential Compatibility Issue due to different possible return behaviors. In the early version, `mReturnExitCoordinator.startExit(...)` is always called directly, but in the late version, it may be postponed until a pre-draw event occurs, which changes when the method `startExit(...)` is called. Hence, the API could return `true` before `startExit(...)` has actually been executed, which differs from its previous behavior where returning `true` meant `startExit(...)` had already been called. Therefore, the CI type is 1."
129,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",21,22,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>","<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",0,"{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException(""Requested authority "" + authority + "" doesn't match provider "" + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}","{
    if (!method.startsWith(""android:"")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException(""Requested authority "" + authority + "" doesn't match provider "" + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}",1,"/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
","/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
130,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",21,22,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round and outset info
                final WindowManager windowService = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                final Display display = windowService.getDefaultDisplay();
                final boolean shouldUseBottomOutset = display.getDisplayId() == Display.DEFAULT_DISPLAY;
                if (shouldUseBottomOutset && windowStyle.hasValue(R.styleable.Window_windowOutsetBottom)) {
                    if (mOutsetBottom == null)
                        mOutsetBottom = new TypedValue();
                    windowStyle.getValue(R.styleable.Window_windowOutsetBottom, mOutsetBottom);
                } else {
                    mOutsetBottom = null;
                }
                mWindowIsRound = getResources().getBoolean(com.android.internal.R.bool.config_windowIsRound);
                windowStyle.recycle();
                // detect emulator
                mIsEmulator = Build.HARDWARE.contains(""goldfish"");
                mIsCircularEmulator = SystemProperties.getBoolean(ViewRootImpl.PROPERTY_EMULATOR_CIRCULAR, false);
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    final boolean isRound = (mIsEmulator && mIsCircularEmulator) || mWindowIsRound;
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    if (mOutsetBottom != null) {
                        final DisplayMetrics metrics = getResources().getDisplayMetrics();
                        mFinalSystemInsets.bottom = ((int) mOutsetBottom.getDimension(metrics)) + mIWallpaperEngine.mDisplayPadding.bottom;
                    }
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, isRound);
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round and outset info
                final WindowManager windowService = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                final Display display = windowService.getDefaultDisplay();
                final boolean shouldUseBottomOutset = display.getDisplayId() == Display.DEFAULT_DISPLAY;
                if (shouldUseBottomOutset && windowStyle.hasValue(R.styleable.Window_windowOutsetBottom)) {
                    if (mOutsetBottom == null)
                        mOutsetBottom = new TypedValue();
                    windowStyle.getValue(R.styleable.Window_windowOutsetBottom, mOutsetBottom);
                } else {
                    mOutsetBottom = null;
                }
                mWindowIsRound = getResources().getBoolean(com.android.internal.R.bool.config_windowIsRound);
                windowStyle.recycle();
                // detect emulator
                mIsEmulator = Build.HARDWARE.contains(""goldfish"");
                mIsCircularEmulator = SystemProperties.getBoolean(ViewRootImpl.PROPERTY_EMULATOR_CIRCULAR, false);
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mStableInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    final boolean isRound = (mIsEmulator && mIsCircularEmulator) || mWindowIsRound;
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    if (mOutsetBottom != null) {
                        final DisplayMetrics metrics = getResources().getDisplayMetrics();
                        mFinalSystemInsets.bottom = ((int) mOutsetBottom.getDimension(metrics)) + mIWallpaperEngine.mDisplayPadding.bottom;
                    }
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, isRound);
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
132,<android.view.ViewGroup: void removeAllViewsInLayout()>,21,22,<android.view.ViewGroup: void removeAllViewsInLayout()>,<android.view.ViewGroup: void removeAllViewsInLayout()>,0,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}",1,"/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
","/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is removal of the conditional check ""if (view.isAccessibilityFocused())"" before calling ""view.clearAccessibilityFocus()"", so the code change type is 4.","Since every view is having its accessibility focus cleared irrespective of whether it previously had accessibility focus, this should not cause a compatibility issue regarding the return value or exception handling. Hence, the CI type is 0."
133,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,21,22,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessiiblity focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
135,"<android.text.StaticLayout: void generate(CharSequence,int,int,TextPaint,int,TextDirectionHeuristic,float,float,boolean,boolean,float,TruncateAt)>",21,22,"<android.text.StaticLayout: void generate(CharSequence,int,int,TextPaint,int,TextDirectionHeuristic,float,float,boolean,boolean,float,TruncateAt)>","<android.text.StaticLayout: void generate(CharSequence,int,int,TextPaint,int,TextDirectionHeuristic,float,float,boolean,boolean,float,TruncateAt)>",0,"{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars;
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                        moreChars = (endPos < spanEnd);
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e(""text"", ""output rest "" + here + "" to "" + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}","{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                    }
                    int ellipseEnd = endPos;
                    if (mMaximumVisibleLineCount == 1 && ellipsize == TextUtils.TruncateAt.MIDDLE) {
                        ellipseEnd = paraEnd;
                    }
                    v = out(source, here, ellipseEnd, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, true);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e(""text"", ""output rest "" + here + "" to "" + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e(""text"", ""output last "" + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
136,"<android.view.ViewGroup: boolean addViewInLayout(View,int,LayoutParams,boolean)>",21,22,"<android.view.ViewGroup: boolean addViewInLayout(View,int,LayoutParams,boolean)>","<android.view.ViewGroup: boolean addViewInLayout(View,int,LayoutParams,boolean)>",0,"{
    child.mParent = null;
    addViewInner(child, index, params, preventRequestLayout);
    child.mPrivateFlags = (child.mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    return true;
}","{
    if (child == null) {
        throw new IllegalArgumentException(""Cannot add a null child view to a ViewGroup"");
    }
    child.mParent = null;
    addViewInner(child, index, params, preventRequestLayout);
    child.mPrivateFlags = (child.mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    return true;
}",1,"/**
 * Adds a view during layout. This is useful if in your onLayout() method,
 * you need to add more views (as does the list view for example).
 *
 * If index is negative, it means put it at the end of the list.
 *
 * @param child the view to add to the group
 * @param index the index at which the child must be added
 * @param params the layout parameters to associate with the child
 * @param preventRequestLayout if true, calling this method will not trigger a
 * layout request on child
 * @return true if the child was added, false otherwise
 */
","/**
 * Adds a view during layout. This is useful if in your onLayout() method,
 * you need to add more views (as does the list view for example).
 *
 * If index is negative, it means put it at the end of the list.
 *
 * @param child the view to add to the group
 * @param index the index at which the child must be added
 * @param params the layout parameters to associate with the child
 * @param preventRequestLayout if true, calling this method will not trigger a
 * layout request on child
 * @return true if the child was added, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An exception handling statement (throw new IllegalArgumentException) is introduced and a condition statement (if child == null) is added, which would not directly result in a control dependency change, the changes are type 2 and 4.","The introduction of a new exception handling statement for a null check on `child` can lead to a different exception being thrown in the newer API version, indicating a CI of type 2."
137,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,21,22,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version implementation adds a new switch case (case MSG_DISPATCH_WINDOW_SHOWN), representing a change in a control dependency (the switch statement), and this also introduces a new return statement. Hence, the code change type consists of both 1 (return statement changed) and 4 (other statement changed).","Adding a new case in the switch statement leads to a new return value for a specific condition (when message.what is MSG_DISPATCH_WINDOW_SHOWN). The new return statement can result in a different return value for inputs that match this new case, thus a CI type of 1 for a potential difference in returned values."
138,"<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>",21,22,"<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>","<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>",0,"{
    View view = null;
    if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}","{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        Bitmap bitmap = (Bitmap) bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (bitmap == null) {
            return null;
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}",1,"/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
","/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version adds an additional check for the `snapshot` variable to determine if it is an instance of `Bundle`, adds more complex logic to configure an `ImageView` if it is, and also a new variable `imageView` is introduced to store the created `ImageView`. The control flow is altered significantly, and the `return` statements changed as well, hence the code change types are 1,3,4.","In the early version, if the passed `snapshot` is a `Bitmap`, it always returns a `View` with that `Bitmap` as a background. However, in the late version, if the `snapshot` is a `Bundle`, it might return `null` if no `Bitmap` is inside the `Bundle`, or it might return an `ImageView` instead of a generic `View`. If the `snapshot` is a `Bitmap`, it retains the same behavior as the early version. The late version can therefore return different types (null or ImageView vs. View), leading to a CI type of 1."
140,<android.widget.SimpleMonthAdapter: int getCount()>,21,22,<android.widget.SimpleMonthAdapter: int getCount()>,<android.widget.SimpleMonthAdapter: int getCount()>,0,"{
    final int diffYear = mController.getMaxYear() - mController.getMinYear();
    final int diffMonth = 1 + mController.getMaxMonth() - mController.getMinMonth() + 12 * diffYear;
    return diffMonth;
}","{
    final int diffYear = mMaxDate.get(Calendar.YEAR) - mMinDate.get(Calendar.YEAR);
    final int diffMonth = mMaxDate.get(Calendar.MONTH) - mMinDate.get(Calendar.MONTH);
    return diffMonth + 12 * diffYear + 1;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation of the method has changed with the variables 'diffYear' and 'diffMonth' now being computed from 'mMaxDate' and 'mMinDate' instead of directly using methods from 'mController'. This affects the control dependency because the way the difference in years and months is calculated has changed. The dependent APIs used to compute 'diffYear' and 'diffMonth' have also changed from 'mController.getMinYear()', 'mController.getMaxYear()', 'mController.getMinMonth()', and 'mController.getMaxMonth()' to 'mMinDate.get(Calendar.YEAR)', 'mMaxDate.get(Calendar.YEAR)', 'mMinDate.get(Calendar.MONTH)', and 'mMaxDate.get(Calendar.MONTH)'. So the change types are 1, 3, and 5.","Since the dependent APIs and the calculation have changed and may return different results, there is a potential for a different return value in the later version of the API. The CI type is 1."
142,"<android.content.Intent: Intent parseUri(String,int)>",21,22,"<android.content.Intent: Intent parseUri(String,int)>","<android.content.Intent: Intent parseUri(String,int)>",0,"{
    int i = 0;
    try {
        // Validate intent scheme for if requested.
        if ((flags & URI_INTENT_SCHEME) != 0) {
            if (!uri.startsWith(""intent:"")) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        // simple case
        i = uri.lastIndexOf(""#"");
        if (i == -1)
            return new Intent(ACTION_VIEW, Uri.parse(uri));
        // old format Intent URI
        if (!uri.startsWith(""#Intent;"", i))
            return getIntentOld(uri);
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        Intent baseIntent = intent;
        // fetch data part, if present
        String data = i >= 0 ? uri.substring(0, i) : null;
        String scheme = null;
        i += ""#Intent;"".length();
        // loop over contents of Intent, all name=value;
        while (!uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            if (eq < 0)
                eq = i - 1;
            int semi = uri.indexOf(';', i);
            String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : """";
            // action
            if (uri.startsWith(""action="", i)) {
                intent.setAction(value);
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                scheme = value;
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // selector
            if (semi == (i + 3) && uri.startsWith(""SEL"", i)) {
                intent = new Intent();
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (intent != baseIntent) {
            // The Intent had a selector; fix it up.
            baseIntent.setSelector(intent);
            intent = baseIntent;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}","{
    int i = 0;
    try {
        final boolean androidApp = uri.startsWith(""android-app:"");
        // Validate intent scheme if requested.
        if ((flags & (URI_INTENT_SCHEME | URI_ANDROID_APP_SCHEME)) != 0) {
            if (!uri.startsWith(""intent:"") && !androidApp) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        i = uri.lastIndexOf(""#"");
        // simple case
        if (i == -1) {
            if (!androidApp) {
                return new Intent(ACTION_VIEW, Uri.parse(uri));
            }
        // old format Intent URI
        } else if (!uri.startsWith(""#Intent;"", i)) {
            if (!androidApp) {
                return getIntentOld(uri, flags);
            } else {
                i = -1;
            }
        }
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        Intent baseIntent = intent;
        boolean explicitAction = false;
        boolean inSelector = false;
        // fetch data part, if present
        String scheme = null;
        String data;
        if (i >= 0) {
            data = uri.substring(0, i);
            // length of ""#Intent;""
            i += 8;
        } else {
            data = uri;
        }
        // loop over contents of Intent, all name=value;
        while (i >= 0 && !uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            if (eq < 0)
                eq = i - 1;
            int semi = uri.indexOf(';', i);
            String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : """";
            // action
            if (uri.startsWith(""action="", i)) {
                intent.setAction(value);
                if (!inSelector) {
                    explicitAction = true;
                }
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
                if ((flags & URI_ALLOW_UNSAFE) == 0) {
                    intent.mFlags &= ~IMMUTABLE_FLAGS;
                }
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                if (inSelector) {
                    intent.mData = Uri.parse(value + "":"");
                } else {
                    scheme = value;
                }
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // selector
            if (semi == (i + 3) && uri.startsWith(""SEL"", i)) {
                intent = new Intent();
                inSelector = true;
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (inSelector) {
            // The Intent had a selector; fix it up.
            if (baseIntent.mPackage == null) {
                baseIntent.setSelector(intent);
            }
            intent = baseIntent;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            } else if (data.startsWith(""android-app:"")) {
                if (data.charAt(12) == '/' && data.charAt(13) == '/') {
                    // Correctly formed android-app, first part is package name.
                    int end = data.indexOf('/', 14);
                    if (end < 0) {
                        // All we have is a package name.
                        intent.mPackage = data.substring(14);
                        if (!explicitAction) {
                            intent.setAction(ACTION_MAIN);
                        }
                        data = """";
                    } else {
                        // Target the Intent at the given package name always.
                        String authority = null;
                        intent.mPackage = data.substring(14, end);
                        int newEnd;
                        if ((end + 1) < data.length()) {
                            if ((newEnd = data.indexOf('/', end + 1)) >= 0) {
                                // Found a scheme, remember it.
                                scheme = data.substring(end + 1, newEnd);
                                end = newEnd;
                                if (end < data.length() && (newEnd = data.indexOf('/', end + 1)) >= 0) {
                                    // Found a authority, remember it.
                                    authority = data.substring(end + 1, newEnd);
                                    end = newEnd;
                                }
                            } else {
                                // All we have is a scheme.
                                scheme = data.substring(end + 1);
                            }
                        }
                        if (scheme == null) {
                            // If there was no scheme, then this just targets the package.
                            if (!explicitAction) {
                                intent.setAction(ACTION_MAIN);
                            }
                            data = """";
                        } else if (authority == null) {
                            data = scheme + "":"";
                        } else {
                            data = scheme + ""://"" + authority + data.substring(end);
                        }
                    }
                } else {
                    data = """";
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}",1,"/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
","/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0,
 * {@link #URI_INTENT_SCHEME}, or {@link #URI_ANDROID_APP_SCHEME}.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
143,"<android.appwidget.AppWidgetHost: void startAppWidgetConfigureActivityForResult(Activity,int,int,int,Bundle)>",21,22,"<android.appwidget.AppWidgetHost: void startAppWidgetConfigureActivityForResult(Activity,int,int,int,Bundle)>","<android.appwidget.AppWidgetHost: void startAppWidgetConfigureActivityForResult(Activity,int,int,int,Bundle)>",0,"{
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContext.getOpPackageName(), appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContextOpPackageName, appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Starts an app widget provider configure activity for result on behalf of the caller.
 * Use this method if the provider is in another profile as you are not allowed to start
 * an activity in another profile. You can optionally provide a request code that is
 * returned in {@link Activity#onActivityResult(int, int, android.content.Intent)} and
 * an options bundle to be passed to the started activity.
 * <p>
 * Note that the provided app widget has to be bound for this method to work.
 * </p>
 *
 * @param activity The activity from which to start the configure one.
 * @param appWidgetId The bound app widget whose provider's config activity to start.
 * @param requestCode Optional request code retuned with the result.
 * @param intentFlags Optional intent flags.
 *
 * @throws android.content.ActivityNotFoundException If the activity is not found.
 *
 * @see AppWidgetProviderInfo#getProfile()
 */
","/**
 * Starts an app widget provider configure activity for result on behalf of the caller.
 * Use this method if the provider is in another profile as you are not allowed to start
 * an activity in another profile. You can optionally provide a request code that is
 * returned in {@link Activity#onActivityResult(int, int, android.content.Intent)} and
 * an options bundle to be passed to the started activity.
 * <p>
 * Note that the provided app widget has to be bound for this method to work.
 * </p>
 *
 * @param activity The activity from which to start the configure one.
 * @param appWidgetId The bound app widget whose provider's config activity to start.
 * @param requestCode Optional request code retuned with the result.
 * @param intentFlags Optional intent flags.
 *
 * @throws android.content.ActivityNotFoundException If the activity is not found.
 *
 * @see AppWidgetProviderInfo#getProfile()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is in the parameter name from `mContext.getOpPackageName()` to `mContextOpPackageName` passed to the method call `createAppWidgetConfigIntentSender`. This indicates a change in a dependent API as the property or method being accessed may have been updated, hence the change type is 5.","There is no Compatibility Issue because the nature of change does not directly affect the return value or exception handling of the `startAppWidgetConfigureActivityForResult` method itself. The signature and behavior of the method remain unchanged, provided that `mContextOpPackageName` still returns the correct package name as `mContext.getOpPackageName()` did."
144,"<android.app.ActivityTransitionCoordinator: ArrayList<View> createSnapshots(Bundle,Collection<String>)>",21,22,"<android.app.ActivityTransitionCoordinator: ArrayList<View> createSnapshots(Bundle,Collection<String>)>","<android.app.ActivityTransitionCoordinator: ArrayList<View> createSnapshots(Bundle,Collection<String>)>",0,"{
    int numSharedElements = names.size();
    if (numSharedElements == 0) {
        return null;
    }
    ArrayList<View> snapshots = new ArrayList<View>(numSharedElements);
    Context context = getWindow().getContext();
    int[] decorLoc = new int[2];
    ViewGroup decorView = getDecor();
    if (decorView != null) {
        decorView.getLocationOnScreen(decorLoc);
    }
    for (String name : names) {
        Bundle sharedElementBundle = state.getBundle(name);
        if (sharedElementBundle != null) {
            Parcelable parcelable = sharedElementBundle.getParcelable(KEY_SNAPSHOT);
            View snapshot = null;
            if (parcelable != null && mListener != null) {
                snapshot = mListener.onCreateSnapshotView(context, parcelable);
            }
            if (snapshot != null) {
                setSharedElementState(snapshot, name, state, null, null, decorLoc);
            }
            snapshots.add(snapshot);
        }
    }
    return snapshots;
}","{
    int numSharedElements = names.size();
    ArrayList<View> snapshots = new ArrayList<View>(numSharedElements);
    if (numSharedElements == 0) {
        return snapshots;
    }
    Context context = getWindow().getContext();
    int[] decorLoc = new int[2];
    ViewGroup decorView = getDecor();
    if (decorView != null) {
        decorView.getLocationOnScreen(decorLoc);
    }
    Matrix tempMatrix = new Matrix();
    for (String name : names) {
        Bundle sharedElementBundle = state.getBundle(name);
        View snapshot = null;
        if (sharedElementBundle != null) {
            Parcelable parcelable = sharedElementBundle.getParcelable(KEY_SNAPSHOT);
            if (parcelable != null && mListener != null) {
                snapshot = mListener.onCreateSnapshotView(context, parcelable);
            }
            if (snapshot != null) {
                setSharedElementState(snapshot, name, state, tempMatrix, null, decorLoc);
            }
        }
        // Even null snapshots are added so they remain in the same order as shared elements.
        snapshots.add(snapshot);
    }
    return snapshots;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control flow is changed as the condition `if (numSharedElements == 0)` now returns a newly instantiated `ArrayList` instead of `null`. A new variable `Matrix tempMatrix` is introduced and is now used as an argument to `setSharedElementState`. There is also a comment added that explains the change in behavior regarding null snapshots, even though the comment itself does not affect the functionality. The change types include 1, 3 (since the introduction of a new variable could be a change in the state of the object and participation in control flow), and 4 (due to the addition of a comment).","There is a Compatibility Issue introduced by returning an empty `ArrayList` instead of `null`, leading to a situation where the method may return a different type of value before and after the change. The CI type is 1 due to the alteration in the return value for a specific condition."
145,"<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>",21,22,"<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>","<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>",0,"{
    final String ellipsis = (where == TruncateAt.END_SMALL) ? Resources.getSystem().getString(R.string.ellipsis_two_dots) : Resources.getSystem().getString(R.string.ellipsis);
    return ellipsize(text, paint, avail, where, preserveLength, callback, TextDirectionHeuristics.FIRSTSTRONG_LTR, ellipsis);
}","{
    return ellipsize(text, paint, avail, where, preserveLength, callback, TextDirectionHeuristics.FIRSTSTRONG_LTR, (where == TruncateAt.END_SMALL) ? ELLIPSIS_TWO_DOTS_STRING : ELLIPSIS_STRING);
}",1,"/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.  TextDirection
 * is determined by the first strong directional character.
 */
","/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.  TextDirection
 * is determined by the first strong directional character.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The logic for determining the ellipsis string has been moved directly into the return statement as a ternary operation, so the statements within the method's body have changed, which is classified as type 4.",No Compatibility Issue arises since the modified implementation does the same decision-making and should result in the same return value as before. The change is simply a refactoring for conciseness and hence does not affect the behavior as observed by the caller.
146,<android.webkit.WebView: HitTestResult getHitTestResult()>,21,22,<android.webkit.WebView: HitTestResult getHitTestResult()>,<android.webkit.WebView: HitTestResult getHitTestResult()>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""getHitTestResult"");
    return mProvider.getHitTestResult();
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""getHitTestResult"");
    return mProvider.getHitTestResult();
}",1,"/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the ""extra"" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
","/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the ""extra"" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change from DebugFlags.TRACE_API to TRACE is an internal flag change, which doesn't impact the return value or the exception handling of the method. Thus, the change type is 4.","As the internal flag change does not affect the return value or the way exceptions are thrown, there is no compatibility issue. The CI type is 0."
147,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",21,22,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    int left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    int left, top, right, bottom;
    if (src == null) {
        left = top = 0;
        right = bitmap.getWidth();
        bottom = bitmap.getHeight();
    } else {
        left = src.left;
        right = src.right;
        top = src.top;
        bottom = src.bottom;
    }
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method signature itself has not changed, but the deletion of bitmap.mBuffer from the nDrawBitmap() method call indicates a change in the underlying drawing implementation. This change is related to the arguments passed to a native method, which means that there was a change in the dependent API being called. The code change is classified as an ""Other statement changed"" because of the removal of an argument and as a ""Dependent API changed"" because the signature of the native method being called probably changed too.","However, this change does not constitute a Compatibility Issue since it doesn't cause the API to return a different value or type, nor does it introduce changes in exception handling. The API is intended to draw a bitmap on the canvas, and these implementation details are internal; the expected behavior of the API as observed by the caller would remain unchanged as long as the bitmap is drawn correctly. Thus, there is ""No Compatibility Issue"" (0) detected."
149,<android.hardware.location.GeofenceHardwareImpl.Reaper: int hashCode()>,21,22,<android.hardware.location.GeofenceHardwareImpl.Reaper: int hashCode()>,<android.hardware.location.GeofenceHardwareImpl.Reaper: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + (mCallback != null ? mCallback.hashCode() : 0);
    result = 31 * result + (mMonitorCallback != null ? mMonitorCallback.hashCode() : 0);
    result = 31 * result + mMonitoringType;
    return result;
}","{
    int result = 17;
    result = 31 * result + (mCallback != null ? mCallback.asBinder().hashCode() : 0);
    result = 31 * result + (mMonitorCallback != null ? mMonitorCallback.asBinder().hashCode() : 0);
    result = 31 * result + mMonitoringType;
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation change involves calling `asBinder().hashCode()` instead of just `hashCode()` on both `mCallback` and `mMonitorCallback`. This change does not alter the control flow nor introduces new return statements or exception handling; it modifies how the hash code is computed. Therefore, the code change type is 4.","Since hashCode() is expected to return different values when the objects are different and remains the same for the same objects, and `asBinder()` is another way to represent the binder object that the callbacks may refer to, it does not inherently introduce a compatibility issue as long as it adheres to the general contract of the hashCode method. It still returns a consistent hash code for the same object between invocations. Therefore, there is no compatibility issue regarding different return values or exception handlings, and the CI type is 0."
151,"<android.widget.ActionMenuView: void onLayout(boolean,int,int,int,int)>",21,22,"<android.widget.ActionMenuView: void onLayout(boolean,int,int,int,int)>","<android.widget.ActionMenuView: void onLayout(boolean,int,int,int,int)>",0,"{
    if (!mFormatItems) {
        super.onLayout(changed, left, top, right, bottom);
        return;
    }
    final int childCount = getChildCount();
    final int midVertical = (top + bottom) / 2;
    final int dividerWidth = getDividerWidth();
    int overflowWidth = 0;
    int nonOverflowWidth = 0;
    int nonOverflowCount = 0;
    int widthRemaining = right - left - getPaddingRight() - getPaddingLeft();
    boolean hasOverflow = false;
    final boolean isLayoutRtl = isLayoutRtl();
    for (int i = 0; i < childCount; i++) {
        final View v = getChildAt(i);
        if (v.getVisibility() == GONE) {
            continue;
        }
        LayoutParams p = (LayoutParams) v.getLayoutParams();
        if (p.isOverflowButton) {
            overflowWidth = v.getMeasuredWidth();
            if (hasDividerBeforeChildAt(i)) {
                overflowWidth += dividerWidth;
            }
            int height = v.getMeasuredHeight();
            int r;
            int l;
            if (isLayoutRtl) {
                l = getPaddingLeft() + p.leftMargin;
                r = l + overflowWidth;
            } else {
                r = getWidth() - getPaddingRight() - p.rightMargin;
                l = r - overflowWidth;
            }
            int t = midVertical - (height / 2);
            int b = t + height;
            v.layout(l, t, r, b);
            widthRemaining -= overflowWidth;
            hasOverflow = true;
        } else {
            final int size = v.getMeasuredWidth() + p.leftMargin + p.rightMargin;
            nonOverflowWidth += size;
            widthRemaining -= size;
            if (hasDividerBeforeChildAt(i)) {
                nonOverflowWidth += dividerWidth;
            }
            nonOverflowCount++;
        }
    }
    if (childCount == 1 && !hasOverflow) {
        // Center a single child
        final View v = getChildAt(0);
        final int width = v.getMeasuredWidth();
        final int height = v.getMeasuredHeight();
        final int midHorizontal = (right - left) / 2;
        final int l = midHorizontal - width / 2;
        final int t = midVertical - height / 2;
        v.layout(l, t, l + width, t + height);
        return;
    }
    final int spacerCount = nonOverflowCount - (hasOverflow ? 0 : 1);
    final int spacerSize = Math.max(0, spacerCount > 0 ? widthRemaining / spacerCount : 0);
    if (isLayoutRtl) {
        int startRight = getWidth() - getPaddingRight();
        for (int i = 0; i < childCount; i++) {
            final View v = getChildAt(i);
            final LayoutParams lp = (LayoutParams) v.getLayoutParams();
            if (v.getVisibility() == GONE || lp.isOverflowButton) {
                continue;
            }
            startRight -= lp.rightMargin;
            int width = v.getMeasuredWidth();
            int height = v.getMeasuredHeight();
            int t = midVertical - height / 2;
            v.layout(startRight - width, t, startRight, t + height);
            startRight -= width + lp.leftMargin + spacerSize;
        }
    } else {
        int startLeft = getPaddingLeft();
        for (int i = 0; i < childCount; i++) {
            final View v = getChildAt(i);
            final LayoutParams lp = (LayoutParams) v.getLayoutParams();
            if (v.getVisibility() == GONE || lp.isOverflowButton) {
                continue;
            }
            startLeft += lp.leftMargin;
            int width = v.getMeasuredWidth();
            int height = v.getMeasuredHeight();
            int t = midVertical - height / 2;
            v.layout(startLeft, t, startLeft + width, t + height);
            startLeft += width + lp.rightMargin + spacerSize;
        }
    }
}","{
    if (!mFormatItems) {
        super.onLayout(changed, left, top, right, bottom);
        return;
    }
    final int childCount = getChildCount();
    final int midVertical = (bottom - top) / 2;
    final int dividerWidth = getDividerWidth();
    int overflowWidth = 0;
    int nonOverflowWidth = 0;
    int nonOverflowCount = 0;
    int widthRemaining = right - left - getPaddingRight() - getPaddingLeft();
    boolean hasOverflow = false;
    final boolean isLayoutRtl = isLayoutRtl();
    for (int i = 0; i < childCount; i++) {
        final View v = getChildAt(i);
        if (v.getVisibility() == GONE) {
            continue;
        }
        LayoutParams p = (LayoutParams) v.getLayoutParams();
        if (p.isOverflowButton) {
            overflowWidth = v.getMeasuredWidth();
            if (hasDividerBeforeChildAt(i)) {
                overflowWidth += dividerWidth;
            }
            int height = v.getMeasuredHeight();
            int r;
            int l;
            if (isLayoutRtl) {
                l = getPaddingLeft() + p.leftMargin;
                r = l + overflowWidth;
            } else {
                r = getWidth() - getPaddingRight() - p.rightMargin;
                l = r - overflowWidth;
            }
            int t = midVertical - (height / 2);
            int b = t + height;
            v.layout(l, t, r, b);
            widthRemaining -= overflowWidth;
            hasOverflow = true;
        } else {
            final int size = v.getMeasuredWidth() + p.leftMargin + p.rightMargin;
            nonOverflowWidth += size;
            widthRemaining -= size;
            if (hasDividerBeforeChildAt(i)) {
                nonOverflowWidth += dividerWidth;
            }
            nonOverflowCount++;
        }
    }
    if (childCount == 1 && !hasOverflow) {
        // Center a single child
        final View v = getChildAt(0);
        final int width = v.getMeasuredWidth();
        final int height = v.getMeasuredHeight();
        final int midHorizontal = (right - left) / 2;
        final int l = midHorizontal - width / 2;
        final int t = midVertical - height / 2;
        v.layout(l, t, l + width, t + height);
        return;
    }
    final int spacerCount = nonOverflowCount - (hasOverflow ? 0 : 1);
    final int spacerSize = Math.max(0, spacerCount > 0 ? widthRemaining / spacerCount : 0);
    if (isLayoutRtl) {
        int startRight = getWidth() - getPaddingRight();
        for (int i = 0; i < childCount; i++) {
            final View v = getChildAt(i);
            final LayoutParams lp = (LayoutParams) v.getLayoutParams();
            if (v.getVisibility() == GONE || lp.isOverflowButton) {
                continue;
            }
            startRight -= lp.rightMargin;
            int width = v.getMeasuredWidth();
            int height = v.getMeasuredHeight();
            int t = midVertical - height / 2;
            v.layout(startRight - width, t, startRight, t + height);
            startRight -= width + lp.leftMargin + spacerSize;
        }
    } else {
        int startLeft = getPaddingLeft();
        for (int i = 0; i < childCount; i++) {
            final View v = getChildAt(i);
            final LayoutParams lp = (LayoutParams) v.getLayoutParams();
            if (v.getVisibility() == GONE || lp.isOverflowButton) {
                continue;
            }
            startLeft += lp.leftMargin;
            int width = v.getMeasuredWidth();
            int height = v.getMeasuredHeight();
            int t = midVertical - height / 2;
            v.layout(startLeft, t, startLeft + width, t + height);
            startLeft += width + lp.rightMargin + spacerSize;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
153,"<android.widget.SearchView: boolean onKeyDown(int,KeyEvent)>",21,22,"<android.widget.SearchView: boolean onKeyDown(int,KeyEvent)>","<android.widget.SearchView: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (mSearchable == null) {
        return false;
    }
    // if it's an action specified by the searchable activity, launch the
    // entered query with the action key
    SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
    if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
        launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mQueryTextView.getText().toString());
        return true;
    }
    return super.onKeyDown(keyCode, event);
}","{
    if (mSearchable == null) {
        return false;
    }
    // if it's an action specified by the searchable activity, launch the
    // entered query with the action key
    SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
    if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
        launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mSearchSrcTextView.getText().toString());
        return true;
    }
    return super.onKeyDown(keyCode, event);
}",1,"/**
 * Handles the key down event for dealing with action keys.
 *
 * @param keyCode This is the keycode of the typed key, and is the same value as
 * found in the KeyEvent parameter.
 * @param event The complete event record for the typed key
 *
 * @return true if the event was handled here, or false if not.
 */
","/**
 * Handles the key down event for dealing with action keys.
 *
 * @param keyCode This is the keycode of the typed key, and is the same value as
 * found in the KeyEvent parameter.
 * @param event The complete event record for the typed key
 *
 * @return true if the event was handled here, or false if not.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within `launchQuerySearch` has changed from using `mQueryTextView.getText().toString()` to `mSearchSrcTextView.getText().toString()`, which is a change in a member variable used, therefore it is a type 4 change. Additionally, it is a type 5 change because there's a dependency on the implementation of `getText()` method of two different member variables which may have been altered.","Even though the member variable used within the `launchQuerySearch` method call has changed, this alone would not be a compatibility issue unless the semantic meaning or behavior of `mQueryTextView` and `mSearchSrcTextView` has changed which cannot be inferred from the provided information. So, based on the given information, we cannot conclude that there's a Compatibility Issue, which is why the CI type is 0."
157,<android.view.ViewGroup: boolean isTransitionGroup()>,21,22,<android.view.ViewGroup: boolean isTransitionGroup()>,<android.view.ViewGroup: boolean isTransitionGroup()>,0,"{
    if ((mGroupFlags & FLAG_IS_TRANSITION_GROUP_SET) != 0) {
        return ((mGroupFlags & FLAG_IS_TRANSITION_GROUP) != 0);
    } else {
        return getBackground() != null || getTransitionName() != null;
    }
}","{
    if ((mGroupFlags & FLAG_IS_TRANSITION_GROUP_SET) != 0) {
        return ((mGroupFlags & FLAG_IS_TRANSITION_GROUP) != 0);
    } else {
        final ViewOutlineProvider outlineProvider = getOutlineProvider();
        return getBackground() != null || getTransitionName() != null || (outlineProvider != null && outlineProvider != ViewOutlineProvider.BACKGROUND);
    }
}",1,"/**
 * Returns true if this ViewGroup should be considered as a single entity for removal
 * when executing an Activity transition. If this is false, child elements will move
 * individually during the transition.
 * @return True if the ViewGroup should be acted on together during an Activity transition.
 * The default value is false when the background is null and true when the background
 * is not null or if {@link #getTransitionName()} is not null.
 */
","/**
 * Returns true if this ViewGroup should be considered as a single entity for removal
 * when executing an Activity transition. If this is false, child elements will move
 * individually during the transition.
 *
 * @return True if the ViewGroup should be acted on together during an Activity transition.
 * The default value is true when there is a non-null background or if
 * {@link #getTransitionName()} is not null or if a
 * non-null {@link android.view.ViewOutlineProvider} other than
 * {@link android.view.ViewOutlineProvider#BACKGROUND} was given to
 * {@link #setOutlineProvider(ViewOutlineProvider)} and false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new method call (getOutlineProvider()) and an additional condition in the 'else' block, which is a control dependency change (3) and an other statement change (4).","The change in the 'else' block, introducing a new condition with the 'outlineProvider' check, can potentially result in a different return value if the 'outlineProvider' is neither null nor ViewOutlineProvider.BACKGROUND. Thus, the CI type is 1 caused by potential different return values."
158,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,21,22,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,0,"{
    Rect bounds = mAttachInfo.mTmpInvalRect;
    getDrawingRect(bounds);
    info.setBoundsInParent(bounds);
    getBoundsOnScreen(bounds);
    info.setBoundsInScreen(bounds);
    ViewParent parent = getParentForAccessibility();
    if (parent instanceof View) {
        info.setParent((View) parent);
    }
    if (mID != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View label = rootView.findLabelForView(this, mID);
        if (label != null) {
            info.setLabeledBy(label);
        }
        if ((mAttachInfo.mAccessibilityFetchFlags & AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS) != 0 && Resources.resourceHasPackage(mID)) {
            try {
                String viewId = getResources().getResourceName(mID);
                info.setViewIdResourceName(viewId);
            } catch (Resources.NotFoundException nfe) {
            /* ignore */
            }
        }
    }
    if (mLabelForId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View labeled = rootView.findViewInsideOutShouldExist(this, mLabelForId);
        if (labeled != null) {
            info.setLabelFor(labeled);
        }
    }
    info.setVisibleToUser(isVisibleToUser());
    info.setPackageName(mContext.getPackageName());
    info.setClassName(View.class.getName());
    info.setContentDescription(getContentDescription());
    info.setEnabled(isEnabled());
    info.setClickable(isClickable());
    info.setFocusable(isFocusable());
    info.setFocused(isFocused());
    info.setAccessibilityFocused(isAccessibilityFocused());
    info.setSelected(isSelected());
    info.setLongClickable(isLongClickable());
    info.setLiveRegion(getAccessibilityLiveRegion());
    // TODO: These make sense only if we are in an AdapterView but all
    // views can be selected. Maybe from accessibility perspective
    // we should report as selectable view in an AdapterView.
    info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    if (isFocusable()) {
        if (isFocused()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_FOCUS);
        } else {
            info.addAction(AccessibilityNodeInfo.ACTION_FOCUS);
        }
    }
    if (!isAccessibilityFocused()) {
        info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    }
    if (isClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
    }
    if (isLongClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
    }
    CharSequence text = getIterableTextForAccessibility();
    if (text != null && text.length() > 0) {
        info.setTextSelection(getAccessibilitySelectionStart(), getAccessibilitySelectionEnd());
        info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH);
    }
}","{
    Rect bounds = mAttachInfo.mTmpInvalRect;
    getDrawingRect(bounds);
    info.setBoundsInParent(bounds);
    getBoundsOnScreen(bounds, true);
    info.setBoundsInScreen(bounds);
    ViewParent parent = getParentForAccessibility();
    if (parent instanceof View) {
        info.setParent((View) parent);
    }
    if (mID != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View label = rootView.findLabelForView(this, mID);
        if (label != null) {
            info.setLabeledBy(label);
        }
        if ((mAttachInfo.mAccessibilityFetchFlags & AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS) != 0 && Resources.resourceHasPackage(mID)) {
            try {
                String viewId = getResources().getResourceName(mID);
                info.setViewIdResourceName(viewId);
            } catch (Resources.NotFoundException nfe) {
            /* ignore */
            }
        }
    }
    if (mLabelForId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View labeled = rootView.findViewInsideOutShouldExist(this, mLabelForId);
        if (labeled != null) {
            info.setLabelFor(labeled);
        }
    }
    if (mAccessibilityTraversalBeforeId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View next = rootView.findViewInsideOutShouldExist(this, mAccessibilityTraversalBeforeId);
        if (next != null) {
            info.setTraversalBefore(next);
        }
    }
    if (mAccessibilityTraversalAfterId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View next = rootView.findViewInsideOutShouldExist(this, mAccessibilityTraversalAfterId);
        if (next != null) {
            info.setTraversalAfter(next);
        }
    }
    info.setVisibleToUser(isVisibleToUser());
    info.setPackageName(mContext.getPackageName());
    info.setClassName(View.class.getName());
    info.setContentDescription(getContentDescription());
    info.setEnabled(isEnabled());
    info.setClickable(isClickable());
    info.setFocusable(isFocusable());
    info.setFocused(isFocused());
    info.setAccessibilityFocused(isAccessibilityFocused());
    info.setSelected(isSelected());
    info.setLongClickable(isLongClickable());
    info.setLiveRegion(getAccessibilityLiveRegion());
    // TODO: These make sense only if we are in an AdapterView but all
    // views can be selected. Maybe from accessibility perspective
    // we should report as selectable view in an AdapterView.
    info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    if (isFocusable()) {
        if (isFocused()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_FOCUS);
        } else {
            info.addAction(AccessibilityNodeInfo.ACTION_FOCUS);
        }
    }
    if (!isAccessibilityFocused()) {
        info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    }
    if (isClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
    }
    if (isLongClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
    }
    CharSequence text = getIterableTextForAccessibility();
    if (text != null && text.length() > 0) {
        info.setTextSelection(getAccessibilitySelectionStart(), getAccessibilitySelectionEnd());
        info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH);
    }
}",1,"/**
 * @see #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
","/**
 * @see #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
159,<android.webkit.WebView: boolean pageUp(boolean)>,21,22,<android.webkit.WebView: boolean pageUp(boolean)>,<android.webkit.WebView: boolean pageUp(boolean)>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""pageUp"");
    return mProvider.pageUp(top);
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""pageUp"");
    return mProvider.pageUp(top);
}",1,"/**
 * Scrolls the contents of this WebView up by half the view size.
 *
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView up by half the view size.
 *
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the variable used in the logging functionality; it has changed from DebugFlags.TRACE_API to TRACE. This is categorized under other statement changed (4) as it does not affect the return value, exceptions, control dependencies, nor does it involve a dependent API change.","There is no Compatibility Issue caused by this change, as it strictly pertains to the internal logging mechanism and will not affect the API's functionality, return values or thrown exceptions. Thus, the CI is 0."
162,<android.bluetooth.BluetoothHeadset: boolean doBind()>,21,22,<android.bluetooth.BluetoothHeadset: boolean doBind()>,<android.bluetooth.BluetoothHeadset: boolean doBind()>,0,"{
    Intent intent = new Intent(IBluetoothHeadset.class.getName());
    ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
    intent.setComponent(comp);
    if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0, android.os.Process.myUserHandle())) {
        Log.e(TAG, ""Could not bind to Bluetooth Headset Service with "" + intent);
        return false;
    }
    return true;
}","{
    try {
        return mAdapter.getBluetoothManager().bindBluetoothProfileService(BluetoothProfile.HEADSET, mConnection);
    } catch (RemoteException e) {
        Log.e(TAG, ""Unable to bind HeadsetService"", e);
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early version of `doBind()` includes explicit Intent creation, service resolution, and binding, while the late version calls a method on `BluetoothAdapter` (`mAdapter`) to handle the entire process, which changes the return value type and involves a different dependent API; therefore, the changes are 1, 4 (for removal of intent operation and log error statements), and 5 (for usage of a different system service API).","A different call to bind the service is used, and as a result, the conditions under which `true` or `false` are returned may change between versions. Instead of manual checks and binding in the early version, the late version defers this to the `bindBluetoothProfileService` method, which may have different implementation details and failure conditions. Therefore, the potential different return values represent a compatibility issue of type 1. The change also removes the original exception handling for `bindServiceAsUser`, but since no new exceptions are introduced and the method should return `false` in the case of failure (handled equally in both versions), it is not considered a different exception handling CI."
163,<android.widget.TimePickerClockDelegate: void setCurrentMinute(Integer)>,21,22,<android.widget.TimePickerClockDelegate: void setCurrentMinute(Integer)>,<android.widget.TimePickerClockDelegate: void setCurrentMinute(Integer)>,0,"{
    if (currentMinute == getCurrentMinute()) {
        return;
    }
    mMinuteSpinner.setValue(currentMinute);
    onTimeChanged();
}","{
    if (mInitialMinute == currentMinute) {
        return;
    }
    mInitialMinute = currentMinute;
    updateHeaderMinute(currentMinute, true);
    mRadialTimePickerView.setCurrentMinute(currentMinute);
    mDelegator.invalidate();
    onTimeChanged();
}",1,,"/**
 * Set the current minute (0-59).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency has changed, as the condition in the 'if' statement now checks `mInitialMinute` instead of calling `getCurrentMinute()`. The method body also includes additional assignments and method calls (`updateHeaderMinute`, `mRadialTimePickerView.setCurrentMinute`, `mDelegator.invalidate()`), which were not present in the early version. This marks not only a change in control dependency but also other statement changes, therefore the change type is 3,4.","The condition for returning early has changed, and now depends on a different field (`mInitialMinute`). Additionally, new methods are called which were not in the early implementation. These changes can affect the behavior of the method: it may now perform additional actions and update other components, affecting the state of the object. Therefore, potential Compatibility Issue is identified as type 1, due to the possibility of different return values or object states after method execution."
168,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",21,22,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",0,"{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, matrix.native_instance, nativePaint);
}","{
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmap(mRenderer, bitmap.mNativeBitmap, matrix.native_instance, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"In the late version of the implementation, the 'bitmap.mBuffer' parameter has been removed from the nDrawBitmap method call, so the code change type is 4. Additionally, this removal signifies that the dependent API nDrawBitmap changed its expected parameters, which classifies the change as type 5 as well.","Even though there's a change in the parameter list of the nDrawBitmap method call (removal of 'bitmap.mBuffer'), there is no indication that the behavior of the API in terms of returned values or thrown exceptions will be altered, as the nDrawBitmap is a native method and its behavior with respect to the reduced parameters is not specified. Therefore, based on the information provided, we cannot assume there's a compatibility issue, so the CI type is 0."
169,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,21,22,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,<android.appwidget.AppWidgetHost: void deleteAppWidgetId(int)>,0,"{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContext.getOpPackageName(), appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}","{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContextOpPackageName, appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException(""system server dead?"", e);
        }
    }
}",1,"/**
 * Stop listening to changes for this AppWidget.
 */
","/**
 * Stop listening to changes for this AppWidget.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There's a change in the way the package name is retrieved; instead of calling mContext.getOpPackageName(), the code directly refers to mContextOpPackageName. This indicates a change to a dependent API (the way the package name is accessed).","There is no Compatibility Issue since the behavior of the method deleteAppWidgetId(int appWidgetId) has not been fundamentally altered. The method still performs the same functionalities as before, despite the fact that the package name is accessed differently inside the method. The exception handling and the logic remain the same, hence there's no change that leads to different return values, types, or exception handling."
170,<android.hardware.location.GeofenceHardwareImpl.Reaper: boolean equals(Object)>,21,22,<android.hardware.location.GeofenceHardwareImpl.Reaper: boolean equals(Object)>,<android.hardware.location.GeofenceHardwareImpl.Reaper: boolean equals(Object)>,0,"{
    if (obj == null)
        return false;
    if (obj == this)
        return true;
    Reaper rhs = (Reaper) obj;
    return rhs.mCallback == mCallback && rhs.mMonitorCallback == mMonitorCallback && rhs.mMonitoringType == mMonitoringType;
}","{
    if (obj == null)
        return false;
    if (obj == this)
        return true;
    Reaper rhs = (Reaper) obj;
    return binderEquals(rhs.mCallback, mCallback) && binderEquals(rhs.mMonitorCallback, mMonitorCallback) && rhs.mMonitoringType == mMonitoringType;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method used in the return statement changed from a direct reference equality check (==) to a method call (binderEquals), which implies a dependency on the implementation of the 'binderEquals' method, so the change type is 4,5.","The 'equals' method now uses a different approach for comparison, which may lead to different results when comparing the callbacks. This change is likely to cause a Compatibility Issue where the method potentially returns different values, so the CI type is 1."
172,<android.webkit.WebView: boolean pageDown(boolean)>,21,22,<android.webkit.WebView: boolean pageDown(boolean)>,<android.webkit.WebView: boolean pageDown(boolean)>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""pageDown"");
    return mProvider.pageDown(bottom);
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""pageDown"");
    return mProvider.pageDown(bottom);
}",1,"/**
 * Scrolls the contents of this WebView down by half the page size.
 *
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView down by half the page size.
 *
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in a debugging log statement where the condition changed from DebugFlags.TRACE_API to TRACE. This is an ""Other statement changed"" because it doesnt affect the actual return value, exception handling, control dependencies, or dependent API.",There is no Compatibility Issue as the change doesn't impact the API functionality; it only alters a debug logging statement which is not part of the functional specification of the API.
174,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",21,22,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",0,"{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy startUsingNetworkFeature for "" + networkType + "", "" + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        if (LEGACY_DBG) {
            Log.d(TAG, ""Looking for legacyRequest for netCap with hash: "" + netCap + "" ("" + netCap.hashCode() + "")"");
            Log.d(TAG, ""sLegacyRequests has:"");
            for (NetworkCapabilities nc : sLegacyRequests.keySet()) {
                Log.d(TAG, ""  "" + nc + "" ("" + nc.hashCode() + "")"");
            }
        }
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, ""renewing startUsingNetworkFeature request "" + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, ""starting startUsingNetworkFeature for request "" + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, "" request Failed"");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}","{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy startUsingNetworkFeature for "" + networkType + "", "" + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, ""renewing startUsingNetworkFeature request "" + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, ""starting startUsingNetworkFeature for request "" + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, "" request Failed"");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}",1,"/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
","/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the removal of the debug logging block inside the synchronized block, which consists of a conditional check for LEGACY_DBG and Log.d statements for debugging purposes. This change does not affect the functionality or behavior of the API, so the code change type is 4.","There is no compatibility issue since the change is limited to debug logging, which does not affect the return values nor exception handling of this API; therefore, the code operates equivalently in both versions in production. The compatibility issue type is 0."
176,"<android.view.ViewGroup: void addView(View,int)>",21,22,"<android.view.ViewGroup: void addView(View,int)>","<android.view.ViewGroup: void addView(View,int)>",0,"{
    LayoutParams params = child.getLayoutParams();
    if (params == null) {
        params = generateDefaultLayoutParams();
        if (params == null) {
            throw new IllegalArgumentException(""generateDefaultLayoutParams() cannot return null"");
        }
    }
    addView(child, index, params);
}","{
    if (child == null) {
        throw new IllegalArgumentException(""Cannot add a null child view to a ViewGroup"");
    }
    LayoutParams params = child.getLayoutParams();
    if (params == null) {
        params = generateDefaultLayoutParams();
        if (params == null) {
            throw new IllegalArgumentException(""generateDefaultLayoutParams() cannot return null"");
        }
    }
    addView(child, index, params);
}",1,"/**
 * Adds a child view. If no layout parameters are already set on the child, the
 * default parameters for this ViewGroup are set on the child.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 *
 * @param child the child view to add
 * @param index the position at which to add the child
 *
 * @see #generateDefaultLayoutParams()
 */
","/**
 * Adds a child view. If no layout parameters are already set on the child, the
 * default parameters for this ViewGroup are set on the child.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 *
 * @param child the child view to add
 * @param index the position at which to add the child
 *
 * @see #generateDefaultLayoutParams()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An additional exception handling statement has been added to check if 'child' is null, and a control dependency change with the newly introduced 'if' condition, so the change type is 2,3.","Due to the introduction of a new exception handling statement which checks for 'child == null' and throws an IllegalArgumentException, this represents a possible change in exceptions being thrown by the method, marking it as CI type 2."
177,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,21,22,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,0,"{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    int keyframeCount = keyframes == null ? 0 : keyframes.size();
    for (int i = 0; i < keyframeCount; i++) {
        Keyframe kf = keyframes.get(i);
        if (!kf.hasValue() || kf.valueWasSetOnStart()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                Object value = convertBack(mGetter.invoke(target));
                kf.setValue(value);
                kf.setValueWasSetOnStart(true);
            } catch (InvocationTargetException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            } catch (IllegalAccessException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            }
        }
    }
}","{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            List<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    // We can't just say 'else' here because the catch statement sets mProperty to null.
    if (mProperty == null) {
        Class targetClass = target.getClass();
        if (mSetter == null) {
            setupSetter(targetClass);
        }
        List<Keyframe> keyframes = mKeyframes.getKeyframes();
        int keyframeCount = keyframes == null ? 0 : keyframes.size();
        for (int i = 0; i < keyframeCount; i++) {
            Keyframe kf = keyframes.get(i);
            if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                if (mGetter == null) {
                    setupGetter(targetClass);
                    if (mGetter == null) {
                        // Already logged the error - just return to avoid NPE
                        return;
                    }
                }
                try {
                    Object value = convertBack(mGetter.invoke(target));
                    kf.setValue(value);
                    kf.setValueWasSetOnStart(true);
                } catch (InvocationTargetException e) {
                    Log.e(""PropertyValuesHolder"", e.toString());
                } catch (IllegalAccessException e) {
                    Log.e(""PropertyValuesHolder"", e.toString());
                }
            }
        }
    }
}",1,"/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
","/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The core change between the two versions is the refactoring of control flow. The late version introduces an additional check `if (mProperty == null)` to encapsulate the second block of logic which was previously part of an implied else branch as a result of a catch block in the early version. However, the logic itself remains the same.","No Compatibility Issue is detected here because the refactoring of control flow doesn't change the behavior of the API  it still executes the same logical steps in the same cases and exceptions are handled in the same way as before. The conditions that lead to method calls and the logic inside the try-catch blocks are unchanged, therefore there is no change in the API that could lead to a potential different return value or type, or a potential different exception handling."
178,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,21,22,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            drawFrame(mSurfaceTexture, holder.width, holder.height);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}","{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
179,<android.view.View: void onDrawScrollBars(Canvas)>,21,22,<android.view.View: void onDrawScrollBars(Canvas)>,<android.view.View: void onDrawScrollBars(Canvas)>,0,"{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.setAlpha(255);
        }
        final int viewFlags = mViewFlags;
        final boolean drawHorizontalScrollBar = (viewFlags & SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;
        final boolean drawVerticalScrollBar = (viewFlags & SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final int width = mRight - mLeft;
            final int height = mBottom - mTop;
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final int inside = (viewFlags & SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;
            int left;
            int top;
            int right;
            int bottom;
            if (drawHorizontalScrollBar) {
                int size = scrollBar.getSize(false);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final int verticalScrollBarGap = drawVerticalScrollBar ? getVerticalScrollbarWidth() : 0;
                top = scrollY + height - size - (mUserPaddingBottom & inside);
                left = scrollX + (mPaddingLeft & inside);
                right = scrollX + width - (mUserPaddingRight & inside) - verticalScrollBarGap;
                bottom = top + size;
                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
            if (drawVerticalScrollBar) {
                int size = scrollBar.getSize(true);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                int verticalScrollbarPosition = mVerticalScrollbarPosition;
                if (verticalScrollbarPosition == SCROLLBAR_POSITION_DEFAULT) {
                    verticalScrollbarPosition = isLayoutRtl() ? SCROLLBAR_POSITION_LEFT : SCROLLBAR_POSITION_RIGHT;
                }
                switch(verticalScrollbarPosition) {
                    default:
                    case SCROLLBAR_POSITION_RIGHT:
                        left = scrollX + width - size - (mUserPaddingRight & inside);
                        break;
                    case SCROLLBAR_POSITION_LEFT:
                        left = scrollX + (mUserPaddingLeft & inside);
                        break;
                }
                top = scrollY + (mPaddingTop & inside);
                right = left + size;
                bottom = scrollY + height - (mUserPaddingBottom & inside);
                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
        }
    }
}","{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.mutate().setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.mutate().setAlpha(255);
        }
        final int viewFlags = mViewFlags;
        final boolean drawHorizontalScrollBar = (viewFlags & SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;
        final boolean drawVerticalScrollBar = (viewFlags & SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final int width = mRight - mLeft;
            final int height = mBottom - mTop;
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final int inside = (viewFlags & SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;
            int left;
            int top;
            int right;
            int bottom;
            if (drawHorizontalScrollBar) {
                int size = scrollBar.getSize(false);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final int verticalScrollBarGap = drawVerticalScrollBar ? getVerticalScrollbarWidth() : 0;
                top = scrollY + height - size - (mUserPaddingBottom & inside);
                left = scrollX + (mPaddingLeft & inside);
                right = scrollX + width - (mUserPaddingRight & inside) - verticalScrollBarGap;
                bottom = top + size;
                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
            if (drawVerticalScrollBar) {
                int size = scrollBar.getSize(true);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                int verticalScrollbarPosition = mVerticalScrollbarPosition;
                if (verticalScrollbarPosition == SCROLLBAR_POSITION_DEFAULT) {
                    verticalScrollbarPosition = isLayoutRtl() ? SCROLLBAR_POSITION_LEFT : SCROLLBAR_POSITION_RIGHT;
                }
                switch(verticalScrollbarPosition) {
                    default:
                    case SCROLLBAR_POSITION_RIGHT:
                        left = scrollX + width - size - (mUserPaddingRight & inside);
                        break;
                    case SCROLLBAR_POSITION_LEFT:
                        left = scrollX + (mUserPaddingLeft & inside);
                        break;
                }
                top = scrollY + (mPaddingTop & inside);
                right = left + size;
                bottom = scrollY + height - (mUserPaddingBottom & inside);
                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
        }
    }
}",1,"/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
","/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
180,<android.bluetooth.BluetoothGattCharacteristic: String getStringValue(int)>,21,22,<android.bluetooth.BluetoothGattCharacteristic: String getStringValue(int)>,<android.bluetooth.BluetoothGattCharacteristic: String getStringValue(int)>,0,"{
    if (offset > mValue.length)
        return null;
    byte[] strBytes = new byte[mValue.length - offset];
    for (int i = 0; i != (mValue.length - offset); ++i) strBytes[i] = mValue[offset + i];
    return new String(strBytes);
}","{
    if (mValue == null || offset > mValue.length)
        return null;
    byte[] strBytes = new byte[mValue.length - offset];
    for (int i = 0; i != (mValue.length - offset); ++i) strBytes[i] = mValue[offset + i];
    return new String(strBytes);
}",1,"/**
 * Return the stored value of this characteristic.
 * <p>See {@link #getValue} for details.
 *
 * @param offset Offset at which the string value can be found.
 * @return Cached value of the characteristic
 */
","/**
 * Return the stored value of this characteristic.
 * <p>See {@link #getValue} for details.
 *
 * @param offset Offset at which the string value can be found.
 * @return Cached value of the characteristic
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The changes include an additional condition check for mValue being null in the if statement. This is a control dependency change, so the code change type is 3.","The change does not lead to a Compatibility Issue because, in the earlier implementation, if mValue is null, attempting to access its length property would result in a NullPointerException, and now it simply returns null. Thus, the behavior is the same for the null case, as it would have failed earlier as well, the CI type is 0."
182,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",21,22,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>","<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",0,"{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}","{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}",1,"/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
","/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
183,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,21,22,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,<android.appwidget.AppWidgetHost: int allocateAppWidgetId()>,0,"{
    try {
        return sService.allocateAppWidgetId(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        return sService.allocateAppWidgetId(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
","/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The argument passed to the method allocateAppWidgetId has changed from `mContext.getOpPackageName()` to `mContextOpPackageName`, indicating that the method `getOpPackageName()` is no longer being called; thus, this change type is 5 (dependent API changed).","Even though there is a change in the code, it does not constitute a compatibility issue because the method is still accessed, and the return value and exception handling remain the same between the versions. The API's behavior is consistent, given that `mContextOpPackageName` should hold the same value previously returned by `mContext.getOpPackageName()`. Hence, no CI is detected."
184,<android.webkit.WebView: int findAll(String)>,21,22,<android.webkit.WebView: int findAll(String)>,<android.webkit.WebView: int findAll(String)>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""findAll"");
    StrictMode.noteSlowCall(""findAll blocks UI: prefer findAllAsync"");
    return mProvider.findAll(find);
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""findAll"");
    StrictMode.noteSlowCall(""findAll blocks UI: prefer findAllAsync"");
    return mProvider.findAll(find);
}",1,"/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String ""find"" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */
","/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String ""find"" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The change is in a constant value used in the 'if' condition, DebugFlags.TRACE_API has been replaced with TRACE. The rest of the code remains the same, so the change type is 4 (Other statement changed).","As the change is merely a replacement of a constant used for logging purposes and does not affect the functionality of the method, there is no Compatibility Issue, and the CI type is 0 (No Compatibility Issue)."
185,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",21,22,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>","<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",0,"{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri), null);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API ActivityManagerNative.getDefault().checkUriPermission has an additional parameter in the late version. There is a new 'null' parameter added at the end of the method call, while the exception handling remains the same, so the code change type is 5.","There is no compatibility issue introduced despite the change in the dependent API, given that the extra parameter does not affect the method's return value for existing use cases (as the added parameter is null, which would typically mean 'default behavior' or 'no additional information'), and the exception handling has not changed. Therefore, the CI type is 0."
186,"<android.widget.SimpleMonthAdapter: View getView(int,View,ViewGroup)>",21,22,"<android.widget.SimpleMonthAdapter: View getView(int,View,ViewGroup)>","<android.widget.SimpleMonthAdapter: View getView(int,View,ViewGroup)>",0,"{
    SimpleMonthView v;
    HashMap<String, Integer> drawingParams = null;
    if (convertView != null) {
        v = (SimpleMonthView) convertView;
        // We store the drawing parameters in the view so it can be recycled
        drawingParams = (HashMap<String, Integer>) v.getTag();
    } else {
        v = new SimpleMonthView(mContext);
        // Set up the new view
        AbsListView.LayoutParams params = new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT, AbsListView.LayoutParams.MATCH_PARENT);
        v.setLayoutParams(params);
        v.setClickable(true);
        v.setOnDayClickListener(this);
        if (mCalendarTextColors != null) {
            v.setTextColor(mCalendarTextColors);
        }
    }
    if (drawingParams == null) {
        drawingParams = new HashMap<String, Integer>();
    } else {
        drawingParams.clear();
    }
    final int currentMonth = position + mController.getMinMonth();
    final int month = currentMonth % 12;
    final int year = currentMonth / 12 + mController.getMinYear();
    int selectedDay = -1;
    if (isSelectedDayInMonth(year, month)) {
        selectedDay = mSelectedDay.get(Calendar.DAY_OF_MONTH);
    }
    // Invokes requestLayout() to ensure that the recycled view is set with the appropriate
    // height/number of weeks before being displayed.
    v.reuse();
    final int enabledDayRangeStart;
    if (mController.getMinMonth() == month && mController.getMinYear() == year) {
        enabledDayRangeStart = mController.getMinDay();
    } else {
        enabledDayRangeStart = 1;
    }
    final int enabledDayRangeEnd;
    if (mController.getMaxMonth() == month && mController.getMaxYear() == year) {
        enabledDayRangeEnd = mController.getMaxDay();
    } else {
        enabledDayRangeEnd = 31;
    }
    v.setMonthParams(selectedDay, month, year, mController.getFirstDayOfWeek(), enabledDayRangeStart, enabledDayRangeEnd);
    v.invalidate();
    return v;
}","{
    final SimpleMonthView v;
    if (convertView != null) {
        v = (SimpleMonthView) convertView;
    } else {
        v = new SimpleMonthView(mContext);
        // Set up the new view
        final AbsListView.LayoutParams params = new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT, AbsListView.LayoutParams.MATCH_PARENT);
        v.setLayoutParams(params);
        v.setClickable(true);
        v.setOnDayClickListener(mOnDayClickListener);
        if (mCalendarTextColors != null) {
            v.setTextColor(mCalendarTextColors);
        }
    }
    final int minMonth = mMinDate.get(Calendar.MONTH);
    final int minYear = mMinDate.get(Calendar.YEAR);
    final int currentMonth = position + minMonth;
    final int month = currentMonth % 12;
    final int year = currentMonth / 12 + minYear;
    final int selectedDay;
    if (isSelectedDayInMonth(year, month)) {
        selectedDay = mSelectedDay.get(Calendar.DAY_OF_MONTH);
    } else {
        selectedDay = -1;
    }
    // Invokes requestLayout() to ensure that the recycled view is set with the appropriate
    // height/number of weeks before being displayed.
    v.reuse();
    final int enabledDayRangeStart;
    if (minMonth == month && minYear == year) {
        enabledDayRangeStart = mMinDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeStart = 1;
    }
    final int enabledDayRangeEnd;
    if (mMaxDate.get(Calendar.MONTH) == month && mMaxDate.get(Calendar.YEAR) == year) {
        enabledDayRangeEnd = mMaxDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeEnd = 31;
    }
    v.setMonthParams(selectedDay, month, year, mFirstDayOfWeek, enabledDayRangeStart, enabledDayRangeEnd);
    v.invalidate();
    return v;
}",1,,,-1,"[@SuppressWarnings(""unchecked""), @Override]","[@SuppressWarnings(""unchecked""), @Override]",-1,-1,-1,-1,-1,-1,"3,4",0,"The variable 'drawingParams' and its related code has been removed. The 'mController' calls have been replaced with direct 'mMinDate' and 'mMaxDate' member accesses, and the listener 'this' has been replaced by 'mOnDayClickListener'. This results in the change types being 3 (for the control dependency change due to the removal of the drawingParams condition and loop) and 4 (for the other changes made to the code). Since no dependent API or exception handling has been altered, and the value returned by getView() should not change as the logic for creating or reusing the SimpleMonthView and the logic for calculating the date parameters remains the same, these changes are classified under ""Other statement changed.""","There is no Compatibility Issue because the returned object 'v' is still of the same type 'SimpleMonthView', and all the changes do not affect the behavior of the returned 'v' object regarding its displayed content or layout parameters. The method's signature, return type, and the expectation for the 'v' object's state post-execution remain consistent despite the internal code changes."
187,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertising(AdvertiseSettings,AdvertiseData,AdvertiseData,AdvertiseCallback)>",21,22,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertising(AdvertiseSettings,AdvertiseData,AdvertiseData,AdvertiseCallback)>","<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertising(AdvertiseSettings,AdvertiseData,AdvertiseData,AdvertiseCallback)>",0,"{
    synchronized (mLeAdvertisers) {
        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        if (!mBluetoothAdapter.isMultipleAdvertisementSupported()) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_FEATURE_UNSUPPORTED);
            return;
        }
        if (totalBytes(advertiseData) > MAX_ADVERTISING_DATA_BYTES || totalBytes(scanResponse) > MAX_ADVERTISING_DATA_BYTES) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
            return;
        }
        if (mLeAdvertisers.containsKey(callback)) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);
            return;
        }
        IBluetoothGatt gatt;
        try {
            gatt = mBluetoothManager.getBluetoothGatt();
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
            return;
        }
        AdvertiseCallbackWrapper wrapper = new AdvertiseCallbackWrapper(callback, advertiseData, scanResponse, settings, gatt);
        wrapper.startRegisteration();
    }
}","{
    synchronized (mLeAdvertisers) {
        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
        if (callback == null) {
            throw new IllegalArgumentException(""callback cannot be null"");
        }
        if (!mBluetoothAdapter.isMultipleAdvertisementSupported() && !mBluetoothAdapter.isPeripheralModeSupported()) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_FEATURE_UNSUPPORTED);
            return;
        }
        boolean isConnectable = settings.isConnectable();
        if (totalBytes(advertiseData, isConnectable) > MAX_ADVERTISING_DATA_BYTES || totalBytes(scanResponse, false) > MAX_ADVERTISING_DATA_BYTES) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
            return;
        }
        if (mLeAdvertisers.containsKey(callback)) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);
            return;
        }
        IBluetoothGatt gatt;
        try {
            gatt = mBluetoothManager.getBluetoothGatt();
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
            return;
        }
        AdvertiseCallbackWrapper wrapper = new AdvertiseCallbackWrapper(callback, advertiseData, scanResponse, settings, gatt);
        wrapper.startRegisteration();
    }
}",1,"/**
 * Start Bluetooth LE Advertising. The {@code advertiseData} will be broadcasted if the
 * operation succeeds. The {@code scanResponse} is returned when a scanning device sends an
 * active scan request. This method returns immediately, the operation status is delivered
 * through {@code callback}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param settings Settings for Bluetooth LE advertising.
 * @param advertiseData Advertisement data to be advertised in advertisement packet.
 * @param scanResponse Scan response associated with the advertisement data.
 * @param callback Callback for advertising status.
 */
","/**
 * Start Bluetooth LE Advertising. The {@code advertiseData} will be broadcasted if the
 * operation succeeds. The {@code scanResponse} is returned when a scanning device sends an
 * active scan request. This method returns immediately, the operation status is delivered
 * through {@code callback}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param settings Settings for Bluetooth LE advertising.
 * @param advertiseData Advertisement data to be advertised in advertisement packet.
 * @param scanResponse Scan response associated with the advertisement data.
 * @param callback Callback for advertising status.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The code has changed in the checks for the adapter capabilities, adding a new condition ""isPeripheralModeSupported()"". Also, the totalBytes() method is now being called with different parameters, which could alter the behavior. These changes classify as both a control dependency change (3) and a dependent API change (5).","The added condition ""isPeripheralModeSupported()"" and the modified parameters passed to ""totalBytes()"" could cause the function to return under different conditions than before. This could lead to a ""postStartFailure"" being called when it was not before, or vice versa, depending on the availability of the peripheral mode. Therefore, this is a compatibility issue due to potential different return values (1)."
188,"<android.view.GLES20Canvas: void drawPatch(NinePatch,RectF,Paint)>",21,22,"<android.view.GLES20Canvas: void drawPatch(NinePatch,RectF,Paint)>","<android.view.GLES20Canvas: void drawPatch(NinePatch,RectF,Paint)>",0,"{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawPatch(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}","{
    Bitmap bitmap = patch.getBitmap();
    throwIfCannotDraw(bitmap);
    final long nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawPatch(mRenderer, bitmap.mNativeBitmap, patch.mNativeChunk, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The order of parameters passed to the method nDrawPatch() has changed, with bitmap.mBuffer being removed from the argument list. Since there are no return or exception handling statement changes and the control dependency did not change, the code change type is 4,5.","Although the parameter list to the native method nDrawPatch() has changed, the public API signature remains the same and neither the return value nor the exception handling has changed. As long as the removal of bitmap.mBuffer has no effect on how the method behaves from the caller's perspective in terms of the API's contract (its interface remains the same, and no new exceptions are declared), we could consider there is no Compatibility Issue. However, this assumes the implementation of nDrawPatch() can handle the changed parameter list without affecting the API's behavior. Without information about the implementation of the native method nDrawPatch(), this is an assumption, but based on the available information, it would be classified as no Compatibility Issue."
189,<android.preference.ListPreference: CharSequence getSummary()>,21,22,<android.preference.ListPreference: CharSequence getSummary()>,<android.preference.ListPreference: CharSequence getSummary()>,0,"{
    final CharSequence entry = getEntry();
    if (mSummary == null || entry == null) {
        return super.getSummary();
    } else {
        return String.format(mSummary, entry);
    }
}","{
    final CharSequence entry = getEntry();
    if (mSummary == null) {
        return super.getSummary();
    } else {
        return String.format(mSummary, entry == null ? """" : entry);
    }
}",1,"/**
 * Returns the summary of this ListPreference. If the summary
 * has a {@linkplain java.lang.String#format String formatting}
 * marker in it (i.e. ""%s"" or ""%1$s""), then the current entry
 * value will be substituted in its place.
 *
 * @return the summary with appropriate string substitution
 */
","/**
 * Returns the summary of this ListPreference. If the summary
 * has a {@linkplain java.lang.String#format String formatting}
 * marker in it (i.e. ""%s"" or ""%1$s""), then the current entry
 * value will be substituted in its place.
 *
 * @return the summary with appropriate string substitution
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"The conditional check for 'entry == null' has been removed, and a ternary operator has been added to handle the null case of 'entry' in the argument to String.format, which is a change in the control dependency and the return statement. So, the code change type is 1,3.","While the implementation has changed, the change does not introduce any potential Compatibility Issue because the same summary is ultimately returned whether 'entry' is `null` or an empty string when formatting with 'mSummary'. Hence, there's no CI."
190,<android.app.Notification.WearableExtender: WearableExtender clone()>,21,22,<android.app.Notification.WearableExtender: WearableExtender clone()>,<android.app.Notification.WearableExtender: WearableExtender clone()>,0,"{
    WearableExtender that = new WearableExtender();
    that.mActions = new ArrayList<Action>(this.mActions);
    that.mFlags = this.mFlags;
    that.mDisplayIntent = this.mDisplayIntent;
    that.mPages = new ArrayList<Notification>(this.mPages);
    that.mBackground = this.mBackground;
    that.mContentIcon = this.mContentIcon;
    that.mContentIconGravity = this.mContentIconGravity;
    that.mContentActionIndex = this.mContentActionIndex;
    that.mCustomSizePreset = this.mCustomSizePreset;
    that.mCustomContentHeight = this.mCustomContentHeight;
    that.mGravity = this.mGravity;
    return that;
}","{
    WearableExtender that = new WearableExtender();
    that.mActions = new ArrayList<Action>(this.mActions);
    that.mFlags = this.mFlags;
    that.mDisplayIntent = this.mDisplayIntent;
    that.mPages = new ArrayList<Notification>(this.mPages);
    that.mBackground = this.mBackground;
    that.mContentIcon = this.mContentIcon;
    that.mContentIconGravity = this.mContentIconGravity;
    that.mContentActionIndex = this.mContentActionIndex;
    that.mCustomSizePreset = this.mCustomSizePreset;
    that.mCustomContentHeight = this.mCustomContentHeight;
    that.mGravity = this.mGravity;
    that.mHintScreenTimeout = this.mHintScreenTimeout;
    return that;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A single assignment statement `that.mHintScreenTimeout = this.mHintScreenTimeout;` is added to the late version, representing a change type of 4.","The addition of a new field assignment does not change the control flow of the method or the type of object returned; it just adds additional state to the created object. Therefore, since the method will still return a `WearableExtender` object and does not alter the behavior of the existing code (nor does it affect the method's signature), there's no compatibility issue caused by potential different return types or exception handlings."
191,<android.content.Intent: Intent getIntentOld(String)>,21,22,<android.content.Intent: Intent getIntentOld(String)>,<android.content.Intent: Intent getIntentOld(String)>,0,"{
    Intent intent;
    int i = uri.lastIndexOf('#');
    if (i >= 0) {
        String action = null;
        final int intentFragmentStart = i;
        boolean isIntentFragment = false;
        i++;
        if (uri.regionMatches(i, ""action("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            int j = uri.indexOf(')', i);
            action = uri.substring(i, j);
            i = j + 1;
        }
        intent = new Intent(action);
        if (uri.regionMatches(i, ""categories("", 0, 11)) {
            isIntentFragment = true;
            i += 11;
            int j = uri.indexOf(')', i);
            while (i < j) {
                int sep = uri.indexOf('!', i);
                if (sep < 0 || sep > j)
                    sep = j;
                if (i < sep) {
                    intent.addCategory(uri.substring(i, sep));
                }
                i = sep + 1;
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""type("", 0, 5)) {
            isIntentFragment = true;
            i += 5;
            int j = uri.indexOf(')', i);
            intent.mType = uri.substring(i, j);
            i = j + 1;
        }
        if (uri.regionMatches(i, ""launchFlags("", 0, 12)) {
            isIntentFragment = true;
            i += 12;
            int j = uri.indexOf(')', i);
            intent.mFlags = Integer.decode(uri.substring(i, j)).intValue();
            i = j + 1;
        }
        if (uri.regionMatches(i, ""component("", 0, 10)) {
            isIntentFragment = true;
            i += 10;
            int j = uri.indexOf(')', i);
            int sep = uri.indexOf('!', i);
            if (sep >= 0 && sep < j) {
                String pkg = uri.substring(i, sep);
                String cls = uri.substring(sep + 1, j);
                intent.mComponent = new ComponentName(pkg, cls);
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""extras("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            final int closeParen = uri.indexOf(')', i);
            if (closeParen == -1)
                throw new URISyntaxException(uri, ""EXTRA missing trailing ')'"", i);
            while (i < closeParen) {
                // fetch the key value
                int j = uri.indexOf('=', i);
                if (j <= i + 1 || i >= closeParen) {
                    throw new URISyntaxException(uri, ""EXTRA missing '='"", i);
                }
                char type = uri.charAt(i);
                i++;
                String key = uri.substring(i, j);
                i = j + 1;
                // get type-value
                j = uri.indexOf('!', i);
                if (j == -1 || j >= closeParen)
                    j = closeParen;
                if (i >= j)
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                String value = uri.substring(i, j);
                i = j;
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                // add item to bundle
                try {
                    switch(type) {
                        case 'S':
                            intent.mExtras.putString(key, Uri.decode(value));
                            break;
                        case 'B':
                            intent.mExtras.putBoolean(key, Boolean.parseBoolean(value));
                            break;
                        case 'b':
                            intent.mExtras.putByte(key, Byte.parseByte(value));
                            break;
                        case 'c':
                            intent.mExtras.putChar(key, Uri.decode(value).charAt(0));
                            break;
                        case 'd':
                            intent.mExtras.putDouble(key, Double.parseDouble(value));
                            break;
                        case 'f':
                            intent.mExtras.putFloat(key, Float.parseFloat(value));
                            break;
                        case 'i':
                            intent.mExtras.putInt(key, Integer.parseInt(value));
                            break;
                        case 'l':
                            intent.mExtras.putLong(key, Long.parseLong(value));
                            break;
                        case 's':
                            intent.mExtras.putShort(key, Short.parseShort(value));
                            break;
                        default:
                            throw new URISyntaxException(uri, ""EXTRA has unknown type"", i);
                    }
                } catch (NumberFormatException e) {
                    throw new URISyntaxException(uri, ""EXTRA value can't be parsed"", i);
                }
                char ch = uri.charAt(i);
                if (ch == ')')
                    break;
                if (ch != '!')
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                i++;
            }
        }
        if (isIntentFragment) {
            intent.mData = Uri.parse(uri.substring(0, intentFragmentStart));
        } else {
            intent.mData = Uri.parse(uri);
        }
        if (intent.mAction == null) {
            // By default, if no action is specified, then use VIEW.
            intent.mAction = ACTION_VIEW;
        }
    } else {
        intent = new Intent(ACTION_VIEW, Uri.parse(uri));
    }
    return intent;
}","{
    return getIntentOld(uri, 0);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
195,<android.animation.IntKeyframeSet: IntKeyframeSet clone()>,21,22,<android.animation.IntKeyframeSet: IntKeyframeSet clone()>,<android.animation.IntKeyframeSet: IntKeyframeSet clone()>,0,"{
    ArrayList<Keyframe> keyframes = mKeyframes;
    int numKeyframes = mKeyframes.size();
    IntKeyframe[] newKeyframes = new IntKeyframe[numKeyframes];
    for (int i = 0; i < numKeyframes; ++i) {
        newKeyframes[i] = (IntKeyframe) keyframes.get(i).clone();
    }
    IntKeyframeSet newSet = new IntKeyframeSet(newKeyframes);
    return newSet;
}","{
    List<Keyframe> keyframes = mKeyframes;
    int numKeyframes = mKeyframes.size();
    IntKeyframe[] newKeyframes = new IntKeyframe[numKeyframes];
    for (int i = 0; i < numKeyframes; ++i) {
        newKeyframes[i] = (IntKeyframe) keyframes.get(i).clone();
    }
    IntKeyframeSet newSet = new IntKeyframeSet(newKeyframes);
    return newSet;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the functional code between the two versions. The type of the 'keyframes' variable changed from `ArrayList<Keyframe>` to `List<Keyframe>`, but this does not affect the implementation as the methods called are available in both types due to `List` being the interface implemented by `ArrayList`.","There is no Compatibility Issue as the behavior of the method has not changed. The reference type change does not affect the returning value or the exception handling of the method, and the API's behavior remains consistent between the two versions."
197,<android.view.View: void buildDrawingCache(boolean)>,21,22,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                    case DRAWING_CACHE_QUALITY_LOW:
                    case DRAWING_CACHE_QUALITY_HIGH:
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
            if (mOverlay != null && !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().draw(canvas);
            }
        } else {
            draw(canvas);
        }
        drawAccessibilityFocus(canvas);
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""buildDrawingCache/SW Layer for "" + getClass().getSimpleName());
        }
        try {
            buildDrawingCacheImpl(autoScale);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
199,"<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>",21,22,"<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>","<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>",0,"{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    int dx = child.mLeft - mScrollX;
    int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    if (rect.intersect(0, 0, mRight - mLeft, mBottom - mTop)) {
        if (mParent == null)
            return true;
        r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
        return mParent.getChildVisibleRect(this, r, offset);
    }
    return false;
}","{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    final int dx = child.mLeft - mScrollX;
    final int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    boolean rectIsVisible = true;
    if (mParent == null || (mParent instanceof ViewGroup && ((ViewGroup) mParent).getClipChildren())) {
        // Clip to bounds.
        rectIsVisible = rect.intersect(0, 0, width, height);
    }
    if (rectIsVisible && (mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        // Clip to padding.
        rectIsVisible = rect.intersect(mPaddingLeft, mPaddingTop, width - mPaddingRight, height - mPaddingBottom);
    }
    if (rectIsVisible && mClipBounds != null) {
        // Clip to clipBounds.
        rectIsVisible = rect.intersect(mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom);
    }
    r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
    if (rectIsVisible && mParent != null) {
        rectIsVisible = mParent.getChildVisibleRect(this, r, offset);
    }
    return rectIsVisible;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version implementation has introduced new local variables and if statements due to additional clipping logic (for clip children, padding, and clip bounds) and has refactored the 'rect.intersect' condition by creating a separate boolean `rectIsVisible`. The condition under which the method returns `true` or `false` has changed, and a new control dependency has been introduced with the addition of an if statement that checks the `mGroupFlags & CLIP_TO_PADDING_MASK` and `mClipBounds != null`. Thus, the code change type is 1 (as the final return value may change), 3 (due to changes in the control flow), and 4 (because of the new local variable declarations and refactored expressions).","The modifications in the implementation can potentially cause this API method to return different boolean values under the same conditions compared to the earlier version. The new clipping logic alters the circumstances under which `rectIsVisible` is set to `true` or `false`, and subsequently, what the method returns. This means there is a potential Compatibility Issue due to different return values, classified as type 1."
201,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,int,Handler)>",21,22,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,int,Handler)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,int,Handler)>",0,"{
    int delayUs = getDelay(rateUs);
    return registerListenerImpl(listener, sensor, delayUs, handler, maxBatchReportLatencyUs, 0);
}","{
    int delayUs = getDelay(samplingPeriodUs);
    return registerListenerImpl(listener, sensor, delayUs, handler, maxReportLatencyUs, 0);
}",1,"/**
 * Enables batch mode for a sensor with the given rate and maxBatchReportLatency.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object
 * that will receive the sensor events. If the application is interested in receiving
 * flush complete notifications, it should register with
 * {@link android.hardware.SensorEventListener SensorEventListener2} instead.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rateUs The desired delay between two consecutive events in microseconds. This is only
 * a hint to the system. Events may be received faster or slower than the specified
 * rate. Usually events are received faster. Can be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in
 * microseconds.
 * @param maxBatchReportLatencyUs An event in the batch can be delayed by at most
 * maxBatchReportLatency microseconds. More events can be batched if this value is
 * large. If this is set to zero, batch mode is disabled and events are delivered in
 * continuous mode as soon as they are available which is equivalent to calling
 * {@link #registerListener(SensorEventListener, Sensor, int)}.
 * @param handler The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be delivered to.
 *
 * @return <code>true</code> if batch mode is successfully enabled for this sensor,
 * <code>false</code> otherwise.
 * @see #registerListener(SensorEventListener, Sensor, int, int)
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
 * sensor at the given sampling frequency and the given maximum reporting latency.
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object
 * that will receive the sensor events. If the application is interested in receiving
 * flush complete notifications, it should register with
 * {@link android.hardware.SensorEventListener SensorEventListener2} instead.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param samplingPeriodUs The desired delay between two consecutive events in microseconds.
 * This is only a hint to the system. Events may be received faster or slower than
 * the specified rate. Usually events are received faster. Can be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in
 * microseconds.
 * @param maxReportLatencyUs Maximum time in microseconds that events can be delayed before
 * being reported to the application. A large value allows reducing the power
 * consumption associated with the sensor. If maxReportLatencyUs is set to zero,
 * events are delivered as soon as they are available, which is equivalent to calling
 * {@link #registerListener(SensorEventListener, Sensor, int)}.
 * @param handler The {@link android.os.Handler Handler} the {@link android.hardware.SensorEvent
 * sensor events} will be delivered to.
 * @return <code>true</code> if the sensor is supported and successfully enabled.
 * @see #registerListener(SensorEventListener, Sensor, int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method parameters have been renamed from `rateUs` to `samplingPeriodUs` and `maxBatchReportLatencyUs` to `maxReportLatencyUs`, and the local variable `delayUs` is assigned their values respectively. Since these are internal implementation details and the external behavior of the API has not changed, the change is classified as 4. Additionally, as the parameters are likely to be corresponding to the same values and just renamed for clarity or consistency, the dependent API `getDelay` would not be affected by such a rename. Therefore, the change is also classified as 5.","There is no Compatibility Issue since the changes within the method implementation do not affect the method's behavior from a caller's perspective. The method `registerListener` still takes a `SensorEventListener`, `Sensor`, sampling period, and `Handler` as input and returns a `boolean` value. The logic of how the delay is calculated and the listener is registered remains the same. The renaming of parameters does not change the method's contract or side effects; it is just a refactoring for internal clarity. Hence, no Compatibility Issue will arise from this change."
202,<android.app.ActivityOptions: Bundle toBundle()>,21,22,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}","{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"A new case ANIM_CUSTOM_IN_PLACE has been added to the switch statement with a corresponding bundle put operation (b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId)). There were also changes to the dependent API within the switch statement due to the addition of the new case, which is why the changes fall under types 3, 4, and 5.","Although there is a change in control dependency and other statements, such as the addition of a new case in the switch statement and its corresponding operation, there is no CI because the method's successful execution will still yield a Bundle with similar structure and the additional case does not affect the behavior of the existing cases. The method will handle the new type of animation without impacting the old ones. Hence, existing clients expecting the original bundle structure would not face any compatibility issues due to this addition."
205,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",21,22,"<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>","<com.android.server.backup.SystemBackupAgent: void onRestore(BackupDataInput,int,ParcelFileDescriptor)>",0,"{
    // On restore, we also support a previous data schema ""system_files""
    addHelper(""wallpaper"", new WallpaperBackupHelper(SystemBackupAgent.this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY }));
    addHelper(""system_files"", new WallpaperBackupHelper(SystemBackupAgent.this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}","{
    // On restore, we also support a previous data schema ""system_files""
    addHelper(""wallpaper"", new WallpaperBackupHelper(SystemBackupAgent.this, new String[] { WALLPAPER_IMAGE, WALLPAPER_INFO }, new String[] { WALLPAPER_IMAGE_KEY, WALLPAPER_INFO_KEY }));
    addHelper(""system_files"", new WallpaperBackupHelper(SystemBackupAgent.this, new String[] { WALLPAPER_IMAGE }, new String[] { WALLPAPER_IMAGE_KEY }));
    addHelper(""recents"", new RecentsBackupHelper(SystemBackupAgent.this));
    try {
        super.onRestore(data, appVersionCode, newState);
        IWallpaperManager wallpaper = (IWallpaperManager) ServiceManager.getService(Context.WALLPAPER_SERVICE);
        if (wallpaper != null) {
            try {
                wallpaper.settingsRestored();
            } catch (RemoteException re) {
                Slog.e(TAG, ""Couldn't restore settings\n"" + re);
            }
        }
    } catch (IOException ex) {
        // If there was a failure, delete everything for the wallpaper, this is too aggressive,
        // but this is hopefully a rare failure.
        Slog.d(TAG, ""restore failed"", ex);
        (new File(WALLPAPER_IMAGE)).delete();
        (new File(WALLPAPER_INFO)).delete();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code added a new helper with ""addHelper(""recents"", new RecentsBackupHelper(SystemBackupAgent.this));"", which is neither a return statement, exception handling statement nor a control dependency change. Thus, the change type is 4.","Since the added helper does not affect the return value or exception handling in this method itself, no compatibility issue arises from this change. Therefore, the CI type is 0."
207,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",21,22,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>","<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",0,"{
    checkThread();
    if (DebugFlags.TRACE_API) {
        StringBuilder headers = new StringBuilder();
        if (additionalHttpHeaders != null) {
            for (Map.Entry<String, String> entry : additionalHttpHeaders.entrySet()) {
                headers.append(entry.getKey() + "":"" + entry.getValue() + ""\n"");
            }
        }
        Log.d(LOGTAG, ""loadUrl(extra headers)="" + url + ""\n"" + headers);
    }
    mProvider.loadUrl(url, additionalHttpHeaders);
}","{
    checkThread();
    if (TRACE) {
        StringBuilder headers = new StringBuilder();
        if (additionalHttpHeaders != null) {
            for (Map.Entry<String, String> entry : additionalHttpHeaders.entrySet()) {
                headers.append(entry.getKey() + "":"" + entry.getValue() + ""\n"");
            }
        }
        Log.d(LOGTAG, ""loadUrl(extra headers)="" + url + ""\n"" + headers);
    }
    mProvider.loadUrl(url, additionalHttpHeaders);
}",1,"/**
 * Loads the given URL with the specified additional HTTP headers.
 *
 * @param url the URL of the resource to load
 * @param additionalHttpHeaders the additional headers to be used in the
 * HTTP request for this URL, specified as a map from name to
 * value. Note that if this map contains any of the headers
 * that are set by default by this WebView, such as those
 * controlling caching, accept types or the User-Agent, their
 * values may be overriden by this WebView's defaults.
 */
","/**
 * Loads the given URL with the specified additional HTTP headers.
 *
 * @param url the URL of the resource to load
 * @param additionalHttpHeaders the additional headers to be used in the
 * HTTP request for this URL, specified as a map from name to
 * value. Note that if this map contains any of the headers
 * that are set by default by this WebView, such as those
 * controlling caching, accept types or the User-Agent, their
 * values may be overriden by this WebView's defaults.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in a conditional statement where `DebugFlags.TRACE_API` is replaced by `TRACE`. This does not affect the behavior of the API because it is only changing the condition for a debug log statement. This is a change in the other statements, so the code change type is 4.","There is no compatibility issue arising from this change, because it neither affects the return value nor the exception handling of the API. The output and behavior of the API remain the same regardless of whether the logging is enabled or disabled. The code within the `if` statement only affects debugging and logging."
208,<android.widget.DatePickerCalendarDelegate: void setMaxDate(long)>,21,22,<android.widget.DatePickerCalendarDelegate: void setMaxDate(long)>,<android.widget.DatePickerCalendarDelegate: void setMaxDate(long)>,0,"{
    mTempDate.setTimeInMillis(maxDate);
    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMaxDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    if (mCurrentDate.after(mTempDate)) {
        mCurrentDate.setTimeInMillis(maxDate);
        updatePickers();
        updateDisplay(false);
    }
    mMaxDate.setTimeInMillis(maxDate);
    mDayPickerView.goTo(getSelectedDay(), false, true, true);
}","{
    mTempDate.setTimeInMillis(maxDate);
    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMaxDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    if (mCurrentDate.after(mTempDate)) {
        mCurrentDate.setTimeInMillis(maxDate);
        onDateChanged(false, true);
    }
    mMaxDate.setTimeInMillis(maxDate);
    mDayPickerView.setMaxDate(maxDate);
    mYearPickerView.setRange(mMinDate, mMaxDate);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The methods updatePickers() and updateDisplay(false) have been replaced by onDateChanged(false, true), and the call to mDayPickerView.goTo has been replaced with mDayPickerView.setMaxDate(maxDate) and mYearPickerView.setRange(mMinDate, mMaxDate). This results in both other statement changes and return statement changes, so the classification is 1,4.","This change could potentially lead to a different return value, since the behavior of the method is changing due to the change in method calls which affect how the state is updated. There might be different variable states after the execution of the method due to the differences in method calls. Therefore, the CI type is 1."
209,<android.content.Intent: String toUri(int)>,21,22,<android.content.Intent: String toUri(int)>,<android.content.Intent: String toUri(int)>,0,"{
    StringBuilder uri = new StringBuilder(128);
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    uri.append(""#Intent;"");
    toUriInner(uri, scheme, flags);
    if (mSelector != null) {
        uri.append(""SEL;"");
        // Note that for now we are not going to try to handle the
        // data part; not clear how to represent this as a URI, and
        // not much utility in it.
        mSelector.toUriInner(uri, null, flags);
    }
    uri.append(""end"");
    return uri.toString();
}","{
    StringBuilder uri = new StringBuilder(128);
    if ((flags & URI_ANDROID_APP_SCHEME) != 0) {
        if (mPackage == null) {
            throw new IllegalArgumentException(""Intent must include an explicit package name to build an android-app: "" + this);
        }
        uri.append(""android-app://"");
        uri.append(mPackage);
        String scheme = null;
        if (mData != null) {
            scheme = mData.getScheme();
            if (scheme != null) {
                uri.append('/');
                uri.append(scheme);
                String authority = mData.getEncodedAuthority();
                if (authority != null) {
                    uri.append('/');
                    uri.append(authority);
                    String path = mData.getEncodedPath();
                    if (path != null) {
                        uri.append(path);
                    }
                    String queryParams = mData.getEncodedQuery();
                    if (queryParams != null) {
                        uri.append('?');
                        uri.append(queryParams);
                    }
                    String fragment = mData.getEncodedFragment();
                    if (fragment != null) {
                        uri.append('#');
                        uri.append(fragment);
                    }
                }
            }
        }
        toUriFragment(uri, null, scheme == null ? Intent.ACTION_MAIN : Intent.ACTION_VIEW, mPackage, flags);
        return uri.toString();
    }
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    toUriFragment(uri, scheme, Intent.ACTION_VIEW, null, flags);
    return uri.toString();
}",1,"/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
","/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0,
 * {@link #URI_INTENT_SCHEME}, or {@link #URI_ANDROID_APP_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation changes significantly, including a new way to construct the URI string, a new exception being thrown, and new conditions around the use of `mPackage`. The change in the StringBuilder operations suggests that the return value could differ between versions, which classify the change as 1. The addition of a throw statement for an IllegalArgumentException classifies this as another type of change under number 4.","The new implementation throws an IllegalArgumentException if a package name is not explicitly included in the intent when certain flags are set, which differs from the early version. Therefore, the API may throw exceptions in scenarios where it did not previously, leading to a CI type 1 due to potential difference in return values and types caused by the newly introduced exception handling. Since the return value of the method is affected by this logic change and the new string-building logic, this adds up to potential changes in the return values or types."
210,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",21,22,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int,Theme)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d(""PreloadDrawable"", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this, theme);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d(""PreloadDrawable"", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        final Drawable clonedDr = cs.newDrawable(this);
        if (theme != null) {
            dr = clonedDr.mutate();
            dr.applyTheme(theme);
            dr.clearMutated();
        } else {
            dr = clonedDr;
        }
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The conditional logic that applies the theme to the drawable has changed. In the early version, theme application happens implicitly inside `cs.newDrawable(this, theme);`. In the late version, this process is broken down into steps: `clonedDr` is created and then conditionally mutated, themed, and the mutated state is cleared if `theme` is not null. Additionally, a method call to `cs.newDrawable(this)` is changed to `cs.newDrawable(this, theme)` in the new version, which is not a control statement. Thus, the code change types are 3 for control dependency change and 4 for other statements change.","The modification in how theming is applied to the drawable (mutate, applyTheme and clearMutated) can potentially lead to a different Drawable being returned if the theme is not null, which constitutes a Compatibility Issue because the appearance or properties of the Drawable could be different when themed in the late version as opposed to the unthemed in the early version. Therefore, a CI caused by potential different return values is identified and the CI type is 1."
212,<android.appwidget.AppWidgetHost: void startListening()>,21,22,<android.appwidget.AppWidgetHost: void startListening()>,<android.appwidget.AppWidgetHost: void startListening()>,0,"{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}","{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}",1,"/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
","/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change is in the variable name from `mContext.getOpPackageName()` to `mContextOpPackageName`. This is just a renaming of the variable and does not affect the functionality of the method. So the change type is 4.,There is no Compatibility Issue because the renaming of a variable does not change the behavior or the output of the method as long as the value referenced by the variable remains the same.
213,"<android.app.Activity: boolean onKeyDown(int,KeyEvent)>",21,22,"<android.app.Activity: boolean onKeyDown(int,KeyEvent)>","<android.app.Activity: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        if (getWindow().performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        Window w = getWindow();
        if (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) && w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}",1,"/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 * by calling {@link #onBackPressed()}, though the behavior varies based
 * on the application compatibility mode: for
 * {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 * it will set up the dispatch to call {@link #onKeyUp} where the action
 * will be performed; for earlier applications, it will perform the
 * action immediately in on-down, as those versions of the platform
 * behaved.
 *
 * <p>Other additional default key handling may be performed
 * if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
","/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 * by calling {@link #onBackPressed()}, though the behavior varies based
 * on the application compatibility mode: for
 * {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 * it will set up the dispatch to call {@link #onKeyUp} where the action
 * will be performed; for earlier applications, it will perform the
 * action immediately in on-down, as those versions of the platform
 * behaved.
 *
 * <p>Other additional default key handling may be performed
 * if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control flow has been slightly modified to include a call to `w.hasFeature(Window.FEATURE_OPTIONS_PANEL)` as part of the condition before calling `w.performPanelShortcut`. Additionally, a local variable `w` has been introduced to store the result of `getWindow()`, and the get call is no longer repeated. These modifications are considered as control dependency changed (3) and other statement changed (4). ","The changes made do not affect the return values or exception handling of the method. The addition of the `w.hasFeature(Window.FEATURE_OPTIONS_PANEL)` check and the introduction of the local variable `w` do not change the overall behavior of the method as they are related to internal optimization and code clarity. There is no change in the return value or the potential exceptions that could be thrown, therefore, there is no Compatibility Issue due to these changes."
215,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",21,22,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"{
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}","{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the code versions is the parameter name from mContext.getOpPackageName() to mContextOpPackageName inside the try block. This suggests a renaming of the variable but without any change in behavior, so the code change type is 4.",No Compatibility Issue is detected as the renaming of a variable does not affect the external behavior of the method. The method's contract and the way it throws exceptions remain the same.
216,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,21,22,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean addTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,0,"{
    // Final CopyOnArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.add(listener);
}","{
    // Final CopyOnWriteArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.add(listener);
}",1,"/**
 * Registers a {@link TouchExplorationStateChangeListener} for changes in
 * the global touch exploration state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
","/**
 * Registers a {@link TouchExplorationStateChangeListener} for changes in
 * the global touch exploration state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementation between the early and late version, just a comment typo correction from ""CopyOnArrayList"" to ""CopyOnWriteArrayList"", which does not affect the actual code execution.","Since there is no actual change in the implementation, no Compatibility Issue could arise."
218,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,21,22,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,0,"{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, ""WARNING: Surface's mNativeObject (0x"" + Long.toHexString(mNativeObject) + "") != mLockedObject (0x"" + Long.toHexString(mLockedObject) + "")"");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException(""Surface was not locked"");
        }
        try {
            nativeUnlockCanvasAndPost(mLockedObject, canvas);
        } finally {
            nativeRelease(mLockedObject);
            mLockedObject = 0;
        }
    }
}","{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mHwuiContext != null) {
            mHwuiContext.unlockAndPost(canvas);
        } else {
            unlockSwCanvasAndPost(canvas);
        }
    }
}",1,"/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
","/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The exception handling statement has been removed, which is ""throw new IllegalArgumentException..."", and the ""synchronized"" content has been completely changed, including removal of logging statements, exception throwing under certain conditions, and modification of the native method calls to a new method call (mHwuiContext.unlockAndPost(canvas)) or a new method (unlockSwCanvasAndPost(canvas)). There are changes in the control dependency statements since the ""if"" condition is modified, and also other statements have been changed. Since there is a new method (unlockSwCanvasAndPost) being introduced, which we can't see the implementation of, there's the possibility of dependent API change as well. Therefore, the change type should be classified as 2,3,4,5.","Compatibility issues can arise due to the removed ""IllegalArgumentException"" throw, which changes the conditions under which exceptions are thrown in the first place, therefore, potentially causing a different behavior in exception handling and hence a CI type of 2. Moreover, the behavior of the API now depends on whether 'mHwuiContext' is non-null or not, which leads to calling different underlying methods which could affect the return behavior - although here, since the method return type is void, it won't affect the return value but will affect the method's execution, it can still cause a compatibility issue (CI type 1)."
220,<android.widget.AbsListView: boolean shouldShowSelector()>,21,22,<android.widget.AbsListView: boolean shouldShowSelector()>,<android.widget.AbsListView: boolean shouldShowSelector()>,0,"{
    return (!isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
}","{
    return (isFocused() && !isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
}",1,"/**
 * Indicates whether this view is in a state where the selector should be drawn. This will
 * happen if we have focus but are not in touch mode, or we are in the middle of displaying
 * the pressed state for an item.
 *
 * @return True if the selector should be shown
 */
","/**
 * Indicates whether this view is in a state where the selector should be drawn. This will
 * happen if we have focus but are not in touch mode, or we are in the middle of displaying
 * the pressed state for an item.
 *
 * @return True if the selector should be shown
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The change is in the conditional expression of the return statement, where a new condition 'isFocused()' is added to the existing condition, leading to a control dependency change, the code change type is 3.","The added 'isFocused()' condition changes the criteria under which the method will return true. This alters the behavior of the API, potentially causing it to return a different value in the late version than in the early version when the view is not in touch mode but is focused. Therefore, the CI type is 1."
221,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,21,22,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void onSetConnectionId(int connectionId) {
            mConnectionId = connectionId;
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The `onSetConnectionId` method is replaced with the `init` method in the `Callbacks` anonymous inner class implementation, which changes the number of methods and their parameters in this class, and introduces new operations within `init`. This counts as an other statement change and also a dependent API change, hence the change type is 4,5.","Since the change is within the implementation of an anonymous inner class and does not affect the signature or the return type of the `onBind` method, and since it is internal to the workings of the `AccessibilityService`, there should be no Compatibility Issue for clients calling `onBind` method, provided they are not expecting `onSetConnectionId` to be called, which is not a public contract of `onBind`. Therefore, there is no Compatibility Issue, so the CI type is 0."
222,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",21,22,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>","<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",0,"{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, ""couldn't decode byte array."");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? ""video_id="" : ""image_id="";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}","{
    Bitmap bitmap = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, ""couldn't decode byte array."");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? ""video_id="" : ""image_id="";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (c != null)
                c.close();
            c = cr.query(uri, PROJECTION, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return null;
            }
            String filePath = c.getString(1);
            if (filePath != null) {
                if (isVideo) {
                    bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
                } else {
                    bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
                }
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}",1,"/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
","/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
223,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",21,22,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>","<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",0,"{
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method mContentProvider.openFile(...) is called with an additional parameter in the late version, so the code change type is 5.","The dependent API `mContentProvider.openFile(...)` has a change in the number of parameters it takes, which can potentially lead to a different behavior when handling the provided parameters. Therefore, the CI type is 1, since it's possible that the method will return a different value due to the change in calling parameters."
224,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",21,22,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>","<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",0,"{
    if (mGhostView != null) {
        mGhostView.invalidate(invalidateCache);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
        // Damage the entire IsolatedZVolume receiving this view's shadow.
        if (isHardwareAccelerated() && getZ() != 0) {
            damageShadowReceiver();
        }
    }
}","{
    if (mGhostView != null) {
        mGhostView.invalidate(true);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
        // Damage the entire IsolatedZVolume receiving this view's shadow.
        if (isHardwareAccelerated() && getZ() != 0) {
            damageShadowReceiver();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the parameter passed to `mGhostView.invalidate(true);` where the original parameter `invalidateCache` is replaced by the constant `true`. This change is to an argument of a method call inside the implementation, which is not classified as any of the specific change types like return statement, exception handling, control dependency, or API signature; hence, it's an Other statement changed (4).","Since the parameter passed to `mGhostView.invalidate()` is changed from a variable (`invalidateCache`) to a constant value (`true`), this does not qualify as a compatibility issue under the given rules. The method's behavior remains consistent because the `invalidate()` method within `mGhostView` would be invoked regardless of the value of `invalidateCache`. The only potential difference is in internal behavior of the GhostView's `invalidate` method, which we assume behaves correctly with both `true` and any value of `invalidateCache`. Therefore, there is no compatibility issue (0)."
226,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,int)>",21,22,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,int)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,int)>",0,"{
    int delay = getDelay(rateUs);
    return registerListenerImpl(listener, sensor, delay, null, maxBatchReportLatencyUs, 0);
}","{
    int delay = getDelay(samplingPeriodUs);
    return registerListenerImpl(listener, sensor, delay, null, maxReportLatencyUs, 0);
}",1,"/**
 * Enables batch mode for a sensor with the given rate and maxBatchReportLatency. If the
 * underlying hardware does not support batch mode, this defaults to
 * {@link #registerListener(SensorEventListener, Sensor, int)} and other parameters are
 * ignored. In non-batch mode, all sensor events must be reported as soon as they are detected.
 * While in batch mode, sensor events do not need to be reported as soon as they are detected.
 * They can be temporarily stored in batches and reported in batches, as long as no event is
 * delayed by more than ""maxBatchReportLatency"" microseconds. That is, all events since the
 * previous batch are recorded and returned all at once. This allows to reduce the amount of
 * interrupts sent to the SoC, and allows the SoC to switch to a lower power state (Idle) while
 * the sensor is capturing and batching data.
 * <p>
 * Registering to a sensor in batch mode will not prevent the SoC from going to suspend mode. In
 * this case, the sensor will continue to gather events and store it in a hardware FIFO. If the
 * FIFO gets full before the AP wakes up again, some events will be lost, as the older events
 * get overwritten by new events in the hardware FIFO. This can be avoided by holding a wake
 * lock. If the application holds a wake lock, the SoC will not go to suspend mode, so no events
 * will be lost, as the events will be reported before the FIFO gets full.
 * </p>
 * <p>
 * Batching is always best effort. If a different application requests updates in continuous
 * mode, this application will also get events in continuous mode. Batch mode updates can be
 * unregistered by calling {@link #unregisterListener(SensorEventListener)}.
 * </p>
 * <p class=""note"">
 * </p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}. Use
 * {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead. </p>
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object
 * that will receive the sensor events. If the application is interested in receiving
 * flush complete notifications, it should register with
 * {@link android.hardware.SensorEventListener SensorEventListener2} instead.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rateUs The desired delay between two consecutive events in microseconds. This is only
 * a hint to the system. Events may be received faster or slower than the specified
 * rate. Usually events are received faster. Can be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in
 * microseconds.
 * @param maxBatchReportLatencyUs An event in the batch can be delayed by at most
 * maxBatchReportLatency microseconds. More events can be batched if this value is
 * large. If this is set to zero, batch mode is disabled and events are delivered in
 * continuous mode as soon as they are available which is equivalent to calling
 * {@link #registerListener(SensorEventListener, Sensor, int)}.
 * @return <code>true</code> if batch mode is successfully enabled for this sensor,
 * <code>false</code> otherwise.
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #flush(SensorEventListener)
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
 * sensor at the given sampling frequency and the given maximum reporting latency.
 * <p>
 * This function is similar to {@link #registerListener(SensorEventListener, Sensor, int)} but
 * it allows events to stay temporarily in the hardware FIFO (queue) before being delivered. The
 * events can be stored in the hardware FIFO up to {@code maxReportLatencyUs} microseconds. Once
 * one of the events in the FIFO needs to be reported, all of the events in the FIFO are
 * reported sequentially. This means that some events will be reported before the maximum
 * reporting latency has elapsed.
 * </p><p>
 * When {@code maxReportLatencyUs} is 0, the call is equivalent to a call to
 * {@link #registerListener(SensorEventListener, Sensor, int)}, as it requires the events to be
 * delivered as soon as possible.
 * </p><p>
 * When {@code sensor.maxFifoEventCount()} is 0, the sensor does not use a FIFO, so the call
 * will also be equivalent to {@link #registerListener(SensorEventListener, Sensor, int)}.
 * </p><p>
 * Setting {@code maxReportLatencyUs} to a positive value allows to reduce the number of
 * interrupts the AP (Application Processor) receives, hence reducing power consumption, as the
 * AP can switch to a lower power state while the sensor is capturing the data. This is
 * especially important when registering to wake-up sensors, for which each interrupt causes the
 * AP to wake up if it was in suspend mode. See {@link Sensor#isWakeUpSensor()} for more
 * information on wake-up sensors.
 * </p>
 * <p class=""note"">
 * </p>
 * Note: Don't use this method with one-shot trigger sensors such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}. Use
 * {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead. </p>
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object
 * that will receive the sensor events. If the application is interested in receiving
 * flush complete notifications, it should register with
 * {@link android.hardware.SensorEventListener SensorEventListener2} instead.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param samplingPeriodUs The desired delay between two consecutive events in microseconds.
 * This is only a hint to the system. Events may be received faster or slower than
 * the specified rate. Usually events are received faster. Can be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in
 * microseconds.
 * @param maxReportLatencyUs Maximum time in microseconds that events can be delayed before
 * being reported to the application. A large value allows reducing the power
 * consumption associated with the sensor. If maxReportLatencyUs is set to zero,
 * events are delivered as soon as they are available, which is equivalent to calling
 * {@link #registerListener(SensorEventListener, Sensor, int)}.
 * @return <code>true</code> if the sensor is supported and successfully enabled.
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #flush(SensorEventListener)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variables `rateUs` and `samplingPeriodUs`, and `maxBatchReportLatencyUs` and `maxReportLatencyUs` have been renamed, but they are conceptually the same parameters passed to the same method, so it's just a variable renaming within the method's scope, which is classified as 4.","As variable renaming does not impact the behavior of the API and no actual logic has been changed, there is no Compatibility Issue; thereby, the CI situation is 0."
227,"<android.transition.Visibility: boolean areValuesChanged(TransitionValues,TransitionValues)>",21,22,"<android.transition.Visibility: boolean areValuesChanged(TransitionValues,TransitionValues)>","<android.transition.Visibility: boolean areValuesChanged(TransitionValues,TransitionValues)>",0,"{
    VisibilityInfo changeInfo = getVisibilityChangeInfo(oldValues, newValues);
    if (oldValues == null && newValues == null) {
        return false;
    }
    return changeInfo.visibilityChange && (changeInfo.startVisibility == View.VISIBLE || changeInfo.endVisibility == View.VISIBLE);
}","{
    if (oldValues == null && newValues == null) {
        return false;
    }
    if (oldValues != null && newValues != null && newValues.values.containsKey(PROPNAME_VISIBILITY) != oldValues.values.containsKey(PROPNAME_VISIBILITY)) {
        // have changed.
        return false;
    }
    VisibilityInfo changeInfo = getVisibilityChangeInfo(oldValues, newValues);
    return changeInfo.visibilityChange && (changeInfo.startVisibility == View.VISIBLE || changeInfo.endVisibility == View.VISIBLE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The introduction of a new control flow check that verifies if the `PROPNAME_VISIBILITY` key exists in both `oldValues` and `newValues` indicates a change in the control dependency (type 3). This additional check affects how the method processes the input parameters, but not necessarily the return value of the method when compared against the old version.","Although there's a change in the control flow, it doesn't introduce a compatibility issue regarding different return values because the checks are designed to return false for specific scenarios that would also ultimately not pass the final return conditions in the early version. Hence, both versions are aligned in that they return false when the values have not meaningfully changed between the old and the new state. Thus, no compatibility issue (CI type 0) is detected."
228,<android.view.ViewGroup: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,21,22,<android.view.ViewGroup: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,<android.view.ViewGroup: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,0,"{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (mAttachInfo != null) {
        final ArrayList<View> childrenForAccessibility = mAttachInfo.mTempArrayList;
        childrenForAccessibility.clear();
        addChildrenForAccessibility(childrenForAccessibility);
        final int childrenForAccessibilityCount = childrenForAccessibility.size();
        for (int i = 0; i < childrenForAccessibilityCount; i++) {
            final View child = childrenForAccessibility.get(i);
            info.addChildUnchecked(child);
        }
        childrenForAccessibility.clear();
    }
}","{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (getAccessibilityNodeProvider() != null) {
        return;
    }
    if (mAttachInfo != null) {
        final ArrayList<View> childrenForAccessibility = mAttachInfo.mTempArrayList;
        childrenForAccessibility.clear();
        addChildrenForAccessibility(childrenForAccessibility);
        final int childrenForAccessibilityCount = childrenForAccessibility.size();
        for (int i = 0; i < childrenForAccessibilityCount; i++) {
            final View child = childrenForAccessibility.get(i);
            info.addChildUnchecked(child);
        }
        childrenForAccessibility.clear();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The introduction of a new 'if' control statement with a 'return;' statement and the dependent API 'getAccessibilityNodeProvider()' can potentially cause different behavior, so the code change types are 1 and 3.","Due to the new 'return;' statement, the API could now potentially return early without adding children to the 'info' object when 'getAccessibilityNodeProvider()' is not null, which is a change in behavior compared to the early version where the method would always add children to the 'info' object. Therefore, this could lead to a Compatibility Issue as the method may not return the same results as in the previous version, and thus the CI type is 1."
229,"<android.transition.SidePropagation: long getStartDelay(ViewGroup,Transition,TransitionValues,TransitionValues)>",21,22,"<android.transition.SidePropagation: long getStartDelay(ViewGroup,Transition,TransitionValues,TransitionValues)>","<android.transition.SidePropagation: long getStartDelay(ViewGroup,Transition,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null && endValues == null) {
        return 0;
    }
    int directionMultiplier = 1;
    Rect epicenter = transition.getEpicenter();
    TransitionValues positionValues;
    if (endValues == null || getViewVisibility(startValues) == View.VISIBLE) {
        positionValues = startValues;
        directionMultiplier = -1;
    } else {
        positionValues = endValues;
    }
    int viewCenterX = getViewX(positionValues);
    int viewCenterY = getViewY(positionValues);
    int[] loc = new int[2];
    sceneRoot.getLocationOnScreen(loc);
    int left = loc[0] + Math.round(sceneRoot.getTranslationX());
    int top = loc[1] + Math.round(sceneRoot.getTranslationY());
    int right = left + sceneRoot.getWidth();
    int bottom = top + sceneRoot.getHeight();
    int epicenterX;
    int epicenterY;
    if (epicenter != null) {
        epicenterX = epicenter.centerX();
        epicenterY = epicenter.centerY();
    } else {
        epicenterX = (left + right) / 2;
        epicenterY = (top + bottom) / 2;
    }
    float distance = distance(viewCenterX, viewCenterY, epicenterX, epicenterY, left, top, right, bottom);
    float maxDistance = getMaxDistance(sceneRoot);
    float distanceFraction = distance / maxDistance;
    long duration = transition.getDuration();
    if (duration < 0) {
        duration = 300;
    }
    return Math.round(duration * directionMultiplier / mPropagationSpeed * distanceFraction);
}","{
    if (startValues == null && endValues == null) {
        return 0;
    }
    int directionMultiplier = 1;
    Rect epicenter = transition.getEpicenter();
    TransitionValues positionValues;
    if (endValues == null || getViewVisibility(startValues) == View.VISIBLE) {
        positionValues = startValues;
        directionMultiplier = -1;
    } else {
        positionValues = endValues;
    }
    int viewCenterX = getViewX(positionValues);
    int viewCenterY = getViewY(positionValues);
    int[] loc = new int[2];
    sceneRoot.getLocationOnScreen(loc);
    int left = loc[0] + Math.round(sceneRoot.getTranslationX());
    int top = loc[1] + Math.round(sceneRoot.getTranslationY());
    int right = left + sceneRoot.getWidth();
    int bottom = top + sceneRoot.getHeight();
    int epicenterX;
    int epicenterY;
    if (epicenter != null) {
        epicenterX = epicenter.centerX();
        epicenterY = epicenter.centerY();
    } else {
        epicenterX = (left + right) / 2;
        epicenterY = (top + bottom) / 2;
    }
    float distance = distance(sceneRoot, viewCenterX, viewCenterY, epicenterX, epicenterY, left, top, right, bottom);
    float maxDistance = getMaxDistance(sceneRoot);
    float distanceFraction = distance / maxDistance;
    long duration = transition.getDuration();
    if (duration < 0) {
        duration = 300;
    }
    return Math.round(duration * directionMultiplier / mPropagationSpeed * distanceFraction);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method call `distance(viewCenterX, viewCenterY, epicenterX, epicenterY, left, top, right, bottom)` has been changed to `distance(sceneRoot, viewCenterX, viewCenterY, epicenterX, epicenterY, left, top, right, bottom)` which indicates that the signature of the dependent method 'distance' has changed by adding an additional parameter 'sceneRoot', so the code change type is 4,5.","The dependent API 'distance' has had its signature changed by adding an extra parameter. As the calculation of distance might now consider 'sceneRoot' as part of the calculation, which could potentially change the return value of `getStartDelay`, the CI type is 1."
231,<android.widget.TextClock: boolean is24HourModeEnabled()>,21,22,<android.widget.TextClock: boolean is24HourModeEnabled()>,<android.widget.TextClock: boolean is24HourModeEnabled()>,0,"{
    return DateFormat.is24HourFormat(getContext());
}","{
    if (mShowCurrentUserTime) {
        return DateFormat.is24HourFormat(getContext(), ActivityManager.getCurrentUser());
    } else {
        return DateFormat.is24HourFormat(getContext());
    }
}",1,"/**
 * Indicates whether the system is currently using the 24-hour mode.
 *
 * When the system is in 24-hour mode, this view will use the pattern
 * returned by {@link #getFormat24Hour()}. In 12-hour mode, the pattern
 * returned by {@link #getFormat12Hour()} is used instead.
 *
 * If either one of the formats is null, the other format is used. If
 * both formats are null, the default formats for the current locale are used.
 *
 * @return true if time should be displayed in 24-hour format, false if it
 * should be displayed in 12-hour format.
 *
 * @see #setFormat12Hour(CharSequence)
 * @see #getFormat12Hour()
 * @see #setFormat24Hour(CharSequence)
 * @see #getFormat24Hour()
 */
","/**
 * Indicates whether the system is currently using the 24-hour mode.
 *
 * When the system is in 24-hour mode, this view will use the pattern
 * returned by {@link #getFormat24Hour()}. In 12-hour mode, the pattern
 * returned by {@link #getFormat12Hour()} is used instead.
 *
 * If either one of the formats is null, the other format is used. If
 * both formats are null, the default formats for the current locale are used.
 *
 * @return true if time should be displayed in 24-hour format, false if it
 * should be displayed in 12-hour format.
 *
 * @see #setFormat12Hour(CharSequence)
 * @see #getFormat12Hour()
 * @see #setFormat24Hour(CharSequence)
 * @see #getFormat24Hour()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The implementation has been altered by adding a conditional check (mShowCurrentUserTime) for the context in which the is24HourFormat method should be called and the dependent API is24HourFormat has a new parameter in one case. It includes a control dependency change (type 3), a modification in the return statement (type 1), and a change in a dependent API call with additional parameters (type 5).","The addition of the new conditional logic and modification in the dependent API call can lead to the method returning different values in the late version if mShowCurrentUserTime is true. Hence, this change is likely to bring a different behavior when the late version API is invoked, resulting in a Compatibility Issue of type 1."
239,<android.widget.SearchView: void onActionViewExpanded()>,21,22,<android.widget.SearchView: void onActionViewExpanded()>,<android.widget.SearchView: void onActionViewExpanded()>,0,"{
    if (mExpandedInActionView)
        return;
    mExpandedInActionView = true;
    mCollapsedImeOptions = mQueryTextView.getImeOptions();
    mQueryTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    mQueryTextView.setText("""");
    setIconified(false);
}","{
    if (mExpandedInActionView)
        return;
    mExpandedInActionView = true;
    mCollapsedImeOptions = mSearchSrcTextView.getImeOptions();
    mSearchSrcTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    mSearchSrcTextView.setText("""");
    setIconified(false);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed the name of the variable from `mQueryTextView` to `mSearchSrcTextView`. This change indicates a possible rename of the variable within the class, but does not alter the logic or control flow of the method. Hence, the change type is 4 for other statement changed, and 5 for dependent API changed.","Since the change is strictly a rename of a variable and assuming that `mQueryTextView` and `mSearchSrcTextView` reference the same object with no difference in behavior, there would be no Compatibility Issue with respect to the outward behavior of the API. The variable rename doesn't affect the return values, thrown exceptions, or control flow structure from an external point of view. Hence, the CI type is 0, indicating no compatibility issue."
240,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,21,22,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,0,"{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekTime < 0) {
            mStartTime = frameTime;
        } else {
            mStartTime = frameTime - mSeekTime;
            // Now that we're playing, reset the seek time
            mSeekTime = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The ""current time"" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}","{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (mDuration * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The ""current time"" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}",1,"/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */
","/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,The following changes are identified between the early and late versions:,- The assignment of `mSeekFraction = -1` replaced the similar line for `mSeekTime`.
242,<android.content.res.Resources: Drawable getDrawable(int)>,21,22,<android.content.res.Resources: Drawable getDrawable(int)>,<android.content.res.Resources: Drawable getDrawable(int)>,0,"{
    final Drawable d = getDrawable(id, null);
    if (d.canApplyTheme()) {
        Log.w(TAG, ""Drawable "" + getResourceName(id) + "" has unresolved theme "" + ""attributes! Consider using Resources.getDrawable(int, Theme) or "" + ""Context.getDrawable(int)."", new RuntimeException());
    }
    return d;
}","{
    final Drawable d = getDrawable(id, null);
    if (d != null && d.canApplyTheme()) {
        Log.w(TAG, ""Drawable "" + getResourceName(id) + "" has unresolved theme "" + ""attributes! Consider using Resources.getDrawable(int, Theme) or "" + ""Context.getDrawable(int)."", new RuntimeException());
    }
    return d;
}",1,"/**
 * Return a drawable object associated with a particular resource ID.
 * Various types of objects will be returned depending on the underlying
 * resource -- for example, a solid color, PNG image, scalable image, etc.
 * The Drawable API hides these implementation details.
 *
 * <p class=""note""><strong>Note:</strong> Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, this function
 * would not correctly retrieve the final configuration density when
 * the resource ID passed here is an alias to another Drawable resource.
 * This means that if the density configuration of the alias resource
 * is different than the actual resource, the density of the returned
 * Drawable would be incorrect, resulting in bad scaling.  To work
 * around this, you can instead retrieve the Drawable through
 * {@link TypedArray#getDrawable TypedArray.getDrawable}.  Use
 * {@link android.content.Context#obtainStyledAttributes(int[])
 * Context.obtainStyledAttributes} with
 * an array containing the resource ID of interest to create the TypedArray.</p>
 *
 * <p class=""note""><strong>Note:</strong> To obtain a themed drawable, use
 * {@link android.content.Context#getDrawable(int) Context.getDrawable(int)}
 * or {@link #getDrawable(int, Theme)} passing the desired theme.</p>
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @see #getDrawable(int, Theme)
 */
","/**
 * Return a drawable object associated with a particular resource ID.
 * Various types of objects will be returned depending on the underlying
 * resource -- for example, a solid color, PNG image, scalable image, etc.
 * The Drawable API hides these implementation details.
 *
 * <p class=""note""><strong>Note:</strong> Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN}, this function
 * would not correctly retrieve the final configuration density when
 * the resource ID passed here is an alias to another Drawable resource.
 * This means that if the density configuration of the alias resource
 * is different than the actual resource, the density of the returned
 * Drawable would be incorrect, resulting in bad scaling.  To work
 * around this, you can instead retrieve the Drawable through
 * {@link TypedArray#getDrawable TypedArray.getDrawable}.  Use
 * {@link android.content.Context#obtainStyledAttributes(int[])
 * Context.obtainStyledAttributes} with
 * an array containing the resource ID of interest to create the TypedArray.</p>
 *
 * <p class=""note""><strong>Note:</strong> To obtain a themed drawable, use
 * {@link android.content.Context#getDrawable(int) Context.getDrawable(int)}
 * or {@link #getDrawable(int, Theme)} passing the desired theme.</p>
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 * @return Drawable An object that can be used to draw this resource.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @see #getDrawable(int, Theme)
 * @deprecated Use {@link #getDrawable(int, Theme)} instead.
 */
",-1,,"[@Deprecated, @Nullable]",-1,-1,-1,-1,-1,-1,3,0,"The code change includes adding a null check for the variable 'd' before invoking the canApplyTheme() method. This change is a control dependency change, thus the code change type is 3.","There is no compatibility issue since the additional null check only prevents a potential NullPointerException. If 'd' is null, the if statement will be bypassed, and the method will return null as before. This added check does not change the intended behavior or the possible return values of the API method; it only enhances stability, so the CI type is 0."
244,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",21,22,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",0,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null);
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the sytem.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the sytem.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the method call `activity.attach` where an additional `null` parameter has been added. This is an other statement change, so the code change type is 4.","The change does not affect the behavior from the callers perspective since neither the method's return type nor the way exceptions are handled has been modified. An extra `null` parameter in the internal call of `activity.attach` method does not inherently change the return value or the exceptions thrown by the `newActivity` method itself, so there is no compatibility issue."
245,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",21,22,"<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>","<android.widget.AbsSeekBar: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (isEnabled()) {
        int progress = getProgress();
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (progress <= 0)
                    break;
                animateSetProgress(progress - mKeyProgressIncrement);
                onKeyChange();
                return true;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (progress >= getMax())
                    break;
                animateSetProgress(progress + mKeyProgressIncrement);
                onKeyChange();
                return true;
        }
    }
    return super.onKeyDown(keyCode, event);
}","{
    if (isEnabled()) {
        int progress = getProgress();
        switch(keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (progress <= 0)
                    break;
                setProgress(progress - mKeyProgressIncrement, true);
                onKeyChange();
                return true;
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (progress >= getMax())
                    break;
                setProgress(progress + mKeyProgressIncrement, true);
                onKeyChange();
                return true;
        }
    }
    return super.onKeyDown(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method call changed from animateSetProgress(progress - mKeyProgressIncrement) to setProgress(progress - mKeyProgressIncrement, true) and animateSetProgress(progress + mKeyProgressIncrement) to setProgress(progress + mKeyProgressIncrement, true). This indicates a change in the dependent API being called, so the code change type is 5.","Despite the change in method calls, there is no difference in the behavior related to what the method returns or the exception it might throw. Both versions of the code return true if the key events are KEYCODE_DPAD_LEFT or KEYCODE_DPAD_RIGHT and return super.onKeyDown(keyCode, event) otherwise. The change from animateSetProgress to setProgress, even with the additional boolean parameter, does not imply that the return value or exception throwing behavior of onKeyDown will change. Therefore, there is no compatibility issue, and the CI type is 0."
246,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter(String)>,21,22,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter(String)>,<android.webkit.WebView: PrintDocumentAdapter createPrintDocumentAdapter(String)>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter(documentName);
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""createPrintDocumentAdapter"");
    return mProvider.createPrintDocumentAdapter(documentName);
}",1,"/**
 * Creates a PrintDocumentAdapter that provides the content of this Webview for printing.
 *
 * The adapter works by converting the Webview contents to a PDF stream. The Webview cannot
 * be drawn during the conversion process - any such draws are undefined. It is recommended
 * to use a dedicated off screen Webview for the printing. If necessary, an application may
 * temporarily hide a visible WebView by using a custom PrintDocumentAdapter instance
 * wrapped around the object returned and observing the onStart and onFinish methods. See
 * {@link android.print.PrintDocumentAdapter} for more information.
 *
 * @param documentName  The user-facing name of the printed document. See
 * {@link android.print.PrintDocumentInfo}
 */
","/**
 * Creates a PrintDocumentAdapter that provides the content of this Webview for printing.
 *
 * The adapter works by converting the Webview contents to a PDF stream. The Webview cannot
 * be drawn during the conversion process - any such draws are undefined. It is recommended
 * to use a dedicated off screen Webview for the printing. If necessary, an application may
 * temporarily hide a visible WebView by using a custom PrintDocumentAdapter instance
 * wrapped around the object returned and observing the onStart and onFinish methods. See
 * {@link android.print.PrintDocumentAdapter} for more information.
 *
 * @param documentName  The user-facing name of the printed document. See
 * {@link android.print.PrintDocumentInfo}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change observed in the code is that DebugFlags.TRACE_API has been replaced with TRACE, which appears to be a change in a constant's name or the way it's accessed. So the code change type is 4.","The change is solely related to logging and does not affect the execution flow, return values or types, or exception handling of the API method; thus, there is no Compatibility Issue."
248,"<android.hardware.camera2.utils.ArrayUtils: List<Integer> convertStringListToIntList(List<String>,String[],int[])>",21,22,"<android.hardware.camera2.utils.ArrayUtils: List<Integer> convertStringListToIntList(List<String>,String[],int[])>","<android.hardware.camera2.utils.ArrayUtils: List<Integer> convertStringListToIntList(List<String>,String[],int[])>",0,"{
    if (list == null) {
        return null;
    }
    List<Integer> convertedList = new ArrayList<>(list.size());
    for (String str : list) {
        int strIndex = getArrayIndex(convertFrom, str);
        // Guard against unexpected values
        if (strIndex < 0) {
            Log.w(TAG, ""Ignoring invalid value "" + str);
            continue;
        }
        // Ignore values we can't map into (intentional)
        if (strIndex < convertTo.length) {
            convertedList.add(convertTo[strIndex]);
        }
    }
    return convertedList;
}","{
    if (list == null) {
        return null;
    }
    List<Integer> convertedList = new ArrayList<>(list.size());
    for (String str : list) {
        int strIndex = getArrayIndex(convertFrom, str);
        // Guard against unexpected values
        if (strIndex < 0) {
            if (VERBOSE)
                Log.v(TAG, ""Ignoring invalid value "" + str);
            continue;
        }
        // Ignore values we can't map into (intentional)
        if (strIndex < convertTo.length) {
            convertedList.add(convertTo[strIndex]);
        }
    }
    return convertedList;
}",1,"/**
 * Create an {@code List<Integer>} from the {@code List<>} by using {@code convertFrom} and
 * {@code convertTo} as a one-to-one map (via the index).
 *
 * <p>Strings not appearing in {@code convertFrom} are ignored (with a logged warning);
 * strings appearing in {@code convertFrom} but not {@code convertTo} are silently
 * dropped.</p>
 *
 * @param list Source list of strings
 * @param convertFrom Conversion list of strings
 * @param convertTo Conversion list of ints
 * @return A list of ints where the values correspond to the ones in {@code convertTo}
 * or {@code null} if {@code list} was {@code null}
 */
","/**
 * Create an {@code List<Integer>} from the {@code List<>} by using {@code convertFrom} and
 * {@code convertTo} as a one-to-one map (via the index).
 *
 * <p>Strings not appearing in {@code convertFrom} are ignored (with a logged warning);
 * strings appearing in {@code convertFrom} but not {@code convertTo} are silently
 * dropped.</p>
 *
 * @param list Source list of strings
 * @param convertFrom Conversion list of strings
 * @param convertTo Conversion list of ints
 * @return A list of ints where the values correspond to the ones in {@code convertTo}
 * or {@code null} if {@code list} was {@code null}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of the verbose check around the log statement. This does not affect the logic of the method or the values being returned, only the level of logging detail, so the code change type is 4.","The code change does not affect the API's behavior in terms of return values or exception handling, hence no Compatibility Issue exists and the CI type is 0."
249,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,21,22,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,0,"{
    String value = Settings.System.getString(context.getContentResolver(), Settings.System.TIME_12_24);
    if (value == null) {
        Locale locale = context.getResources().getConfiguration().locale;
        synchronized (sLocaleLock) {
            if (sIs24HourLocale != null && sIs24HourLocale.equals(locale)) {
                return sIs24Hour;
            }
        }
        java.text.DateFormat natural = java.text.DateFormat.getTimeInstance(java.text.DateFormat.LONG, locale);
        if (natural instanceof SimpleDateFormat) {
            SimpleDateFormat sdf = (SimpleDateFormat) natural;
            String pattern = sdf.toPattern();
            if (pattern.indexOf('H') >= 0) {
                value = ""24"";
            } else {
                value = ""12"";
            }
        } else {
            value = ""12"";
        }
        synchronized (sLocaleLock) {
            sIs24HourLocale = locale;
            sIs24Hour = value.equals(""24"");
        }
        return sIs24Hour;
    }
    return value.equals(""24"");
}","{
    return is24HourFormat(context, UserHandle.myUserId());
}",1,"/**
 * Returns true if user preference is set to 24-hour format.
 * @param context the context to use for the content resolver
 * @return true if 24 hour time format is selected, false otherwise.
 */
","/**
 * Returns true if user preference is set to 24-hour format.
 * @param context the context to use for the content resolver
 * @return true if 24 hour time format is selected, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has been completely changed from a specific logic handling to a call to another method is24HourFormat(context, UserHandle.myUserId()). The code change type is 1,5 because the return statement has changed, and a dependent API is24HourFormat with an additional parameter is invoked.","The complete change in method logic will definitely potentially return a different value, so the CI type is 1."
251,<android.transition.Slide: void setSlideEdge(int)>,21,22,<android.transition.Slide: void setSlideEdge(int)>,<android.transition.Slide: void setSlideEdge(int)>,0,"{
    switch(slideEdge) {
        case Gravity.LEFT:
            mSlideCalculator = sCalculateLeft;
            break;
        case Gravity.TOP:
            mSlideCalculator = sCalculateTop;
            break;
        case Gravity.RIGHT:
            mSlideCalculator = sCalculateRight;
            break;
        case Gravity.BOTTOM:
            mSlideCalculator = sCalculateBottom;
            break;
        default:
            throw new IllegalArgumentException(""Invalid slide direction"");
    }
    mSlideEdge = slideEdge;
    SidePropagation propagation = new SidePropagation();
    propagation.setSide(slideEdge);
    setPropagation(propagation);
}","{
    switch(slideEdge) {
        case Gravity.LEFT:
            mSlideCalculator = sCalculateLeft;
            break;
        case Gravity.TOP:
            mSlideCalculator = sCalculateTop;
            break;
        case Gravity.RIGHT:
            mSlideCalculator = sCalculateRight;
            break;
        case Gravity.BOTTOM:
            mSlideCalculator = sCalculateBottom;
            break;
        case Gravity.START:
            mSlideCalculator = sCalculateStart;
            break;
        case Gravity.END:
            mSlideCalculator = sCalculateEnd;
            break;
        default:
            throw new IllegalArgumentException(""Invalid slide direction"");
    }
    mSlideEdge = slideEdge;
    SidePropagation propagation = new SidePropagation();
    propagation.setSide(slideEdge);
    setPropagation(propagation);
}",1,"/**
 * Change the edge that Views appear and disappear from.
 *
 * @param slideEdge The edge of the scene to use for Views appearing and disappearing. One of
 * {@link android.view.Gravity#LEFT}, {@link android.view.Gravity#TOP},
 * {@link android.view.Gravity#RIGHT}, {@link android.view.Gravity#BOTTOM}.
 * @attr ref android.R.styleable#Slide_slideEdge
 */
","/**
 * Change the edge that Views appear and disappear from.
 *
 * @param slideEdge The edge of the scene to use for Views appearing and disappearing. One of
 * {@link android.view.Gravity#LEFT}, {@link android.view.Gravity#TOP},
 * {@link android.view.Gravity#RIGHT}, {@link android.view.Gravity#BOTTOM},
 * {@link android.view.Gravity#START}, {@link android.view.Gravity#END}.
 * @attr ref android.R.styleable#Slide_slideEdge
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The switch statement has two additional cases (Gravity.START and Gravity.END) compared to the early version and the implementation within these cases has been added (assignments to mSlideCalculator), so the code change types are 3 for the control dependency change and 4 for other statement changes.","The changes allow for new slide edge values (Gravity.START and Gravity.END) to be handled without raising an exception. The previous code would have thrown an IllegalArgumentException for these new values, but now they are valid inputs to the method. As a result, methods that used to throw an exception for these values will now complete without throwing, which alters the exception control flow of the method. However, if the input slideEdge is not one of the newly supported types (Gravity.START and Gravity.END), the behavior will remain unchanged from the early version. There is no CI for return values, as the method is void and does not return any value. The potential change in exception handling is accounted for in the API enhancements, thus there should be no unintended CI due to this specific change."
252,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,21,22,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,0,"{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getNetworkBoundToProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}","{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getNetworkBoundToProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // Set HTTP proxy system properties to match network.
        // TODO: Deprecate this static method and replace it with a non-static version.
        Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 */
","/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of the Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy()); is the only change in the implementation, which does not affect the return value or exception handling, therefore, the code change type is 4.","There is no Compatibility Issue since the newly introduced statement will not result in different return values or cause different exceptions to be thrown when comparing the behavior of this method between the two versions, thus the CI type is 0."
253,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,21,22,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,0,"{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}","{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, ""bluetooth le advertising not supported"");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}",1,"/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
","/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new condition was added in the if statement (`!isPeripheralModeSupported()`) and a call to Log.e(...) has been inserted, hence the code change types are 3 for control dependency change and 4 for other statement change.","Due to the addition of an extra condition, `!isPeripheralModeSupported()`, there is a potential change in the control dependency which affects when the method may return null. This can result in a different behavior because the method may now return null in scenarios where it previously returned a `BluetoothLeAdvertiser` object if `isPeripheralModeSupported()` returns false. Therefore, the CI type is 1 because different return values are possible."
256,<android.webkit.WebView: Picture capturePicture()>,21,22,<android.webkit.WebView: Picture capturePicture()>,<android.webkit.WebView: Picture capturePicture()>,0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""capturePicture"");
    return mProvider.capturePicture();
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""capturePicture"");
    return mProvider.capturePicture();
}",1,"/**
 * Gets a new picture that captures the current contents of this WebView.
 * The picture is of the entire document being displayed, and is not
 * limited to the area currently displayed by this WebView. Also, the
 * picture is a static copy and is unaffected by later changes to the
 * content being displayed.
 * <p>
 * Note that due to internal changes, for API levels between
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and
 * {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH} inclusive, the
 * picture does not include fixed position elements or scrollable divs.
 * <p>
 * Note that from {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} the returned picture
 * should only be drawn into bitmap-backed Canvas - using any other type of Canvas will involve
 * additional conversion at a cost in memory and performance. Also the
 * {@link android.graphics.Picture#createFromStream} and
 * {@link android.graphics.Picture#writeToStream} methods are not supported on the
 * returned object.
 *
 * @deprecated Use {@link #onDraw} to obtain a bitmap snapshot of the WebView, or
 * {@link #saveWebArchive} to save the content to a file.
 *
 * @return a picture that captures the current contents of this WebView
 */
","/**
 * Gets a new picture that captures the current contents of this WebView.
 * The picture is of the entire document being displayed, and is not
 * limited to the area currently displayed by this WebView. Also, the
 * picture is a static copy and is unaffected by later changes to the
 * content being displayed.
 * <p>
 * Note that due to internal changes, for API levels between
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and
 * {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH} inclusive, the
 * picture does not include fixed position elements or scrollable divs.
 * <p>
 * Note that from {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} the returned picture
 * should only be drawn into bitmap-backed Canvas - using any other type of Canvas will involve
 * additional conversion at a cost in memory and performance. Also the
 * {@link android.graphics.Picture#createFromStream} and
 * {@link android.graphics.Picture#writeToStream} methods are not supported on the
 * returned object.
 *
 * @deprecated Use {@link #onDraw} to obtain a bitmap snapshot of the WebView, or
 * {@link #saveWebArchive} to save the content to a file.
 *
 * @return a picture that captures the current contents of this WebView
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The implementation changed the constant '`DebugFlags.TRACE_API`' to '`TRACE`', affecting the condition for logging. This change is internal and does not affect the method's external behaviour, therefore it's classified as 4.","Since the only change is related to an internal debugging flag, which would not affect the return values or exceptions thrown by this API under normal use, there is no Compatibility Issue; thus CI type is 0."
261,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,21,22,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mScreenOn = ((PowerManager) getSystemService(Context.POWER_SERVICE)).isScreenOn();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mDisplayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
    mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Several statements were added for initializing 'mDisplayManager' and 'mDisplay' and registering a 'DisplayListener', none of which alter the method's return type, value, or its exception handling. This qualifies as other statement changes.","These additional statements do not constitute a change in the outward behavior of the API in terms of changing return values or exception handling, therefore there is no compatibility issue in this scenario."
263,"<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>",21,22,"<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int stopUsingNetworkFeature(int,String)>",0,"{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy stopUsingNetworkFeature for "" + networkType + "", "" + feature);
        return -1;
    }
    NetworkCallback networkCallback = removeRequestForFeature(netCap);
    if (networkCallback != null) {
        Log.d(TAG, ""stopUsingNetworkFeature for "" + networkType + "", "" + feature);
        unregisterNetworkCallback(networkCallback);
    }
    return 1;
}","{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, ""Can't satisfy stopUsingNetworkFeature for "" + networkType + "", "" + feature);
        return -1;
    }
    if (removeRequestForFeature(netCap)) {
        Log.d(TAG, ""stopUsingNetworkFeature for "" + networkType + "", "" + feature);
    }
    return 1;
}",1,"/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
","/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the late version has changes in the if condition ""if (networkCallback != null)"" is changed to a condition ""if (removeRequestForFeature(netCap))"", which reflects a change in the control dependency because the behavior inside the if block may now occur under different conditions. Moreover, the method signature and behavior of ""removeRequestForFeature"" might have changed as it previously returned a NetworkCallback and now returns a boolean. Besides, the variable `networkCallback` being assigned the return value of ""removeRequestForFeature(netCap)"" and later used is missing in the late version, indicating an altered other statement. Hence, the code change type is 1,4,5.","The return value of the method could potentially differ in two versions because the execution of ""unregisterNetworkCallback(networkCallback)"" is now dependent on a different condition which is evaluated directly inside the if statement. As ""removeRequestForFeature(netCap)"" directly returns a boolean and based on this result, ""unregisterNetworkCallback(networkCallback)"" may or may not be called. The removal of NetworkCallback object usage indicates the dependent API ""removeRequestForFeature"" changed as well. Thus the API in the late version could potentially behave differently, leading to a compatibility issue due to different return values. The CI type is 1."
264,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,21,22,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,<android.preference.SeekBarVolumizer.Receiver: void setListening(boolean)>,0,"{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}","{
    if (mListening == listening)
        return;
    mListening = listening;
    if (listening) {
        final IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
        filter.addAction(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION);
        mContext.registerReceiver(this, filter);
    } else {
        mContext.unregisterReceiver(this);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change involves adding a new action filter inside an if statement, which classifies it as both control dependency change (3) and other statement changed (4).","The changes made do not affect the return value nor the exceptions thrown by the method, as they only modify the behavior of the filter when registering the receiver. The conditions under which the receiver is registered or unregistered have not changed. Therefore, there is no Compatibility Issue caused by potential different return values or exception handlings."
266,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,21,22,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                final WindowManager.LayoutParams lp = mWindowAttributes;
                                final Rect surfaceInsets = lp != null ? lp.surfaceInsets : null;
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mSurface, surfaceInsets);
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
267,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,21,22,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,0,"{
    if (!mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            GhostView.addGhost(view, decor);
            ViewGroup parent = (ViewGroup) view.getParent();
            if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                parent.getViewTreeObserver().addOnPreDrawListener(listener);
                mGhostViewListeners.add(listener);
            }
        }
    }
}","{
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    setSharedElementMatrices();
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            GhostView.addGhost(view, decor);
            ViewGroup parent = (ViewGroup) view.getParent();
            if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                parent.getViewTreeObserver().addOnPreDrawListener(listener);
                mGhostViewListeners.add(listener);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new condition (mWindow == null) was added to the early exit check, and a new method call (setSharedElementMatrices()) was added in the late version; therefore, the change type is 4.","The new null check for mWindow simply adds a condition to an existing return statement without changing what is returned (as the method is void). This doesn't introduce a different return type or value, just avoids a potential NullPointerException. The added call to setSharedElementMatrices() might affect internal state but doesn't directly affect the return type or exception handling of moveSharedElementsToOverlay(). No Compatibility Issue is detected because these changes do not lead to an API behaving differently in terms of the values it returns or the exceptions it throws."
268,<android.bluetooth.BluetoothHeadset: void close()>,21,22,<android.bluetooth.BluetoothHeadset: void close()>,<android.bluetooth.BluetoothHeadset: void close()>,0,"{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, """", re);
            }
        }
    }
    mServiceListener = null;
}","{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    mServiceListener = null;
    doUnbind();
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version of the implementation has replaced the block that unbinds the service inside the `synchronized(mConnection)` block with a call to `doUnbind()`. This change includes moving 'mService = null;' inside the `doUnbind()` method, and wraps the `unbindService(mConnection)` invocation, thus potentially refactoring repetitive code into a single method for better organization and reuse.","Since the method `doUnbind()` is likely an internal refactoring that does not inherently change the behavior that external code relies on, and assuming that `doUnbind()` internally correctly sets `mService` to null and calls `context.unbindService(mConnection)` as before, there should be No Compatibility Issue. The behavior when it comes to closing the Bluetooth headset should remain consistent, therefore no potential different return values or types, nor different exception handlings are expected."
269,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>",21,22,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>","<android.webkit.WebView: boolean showFindDialog(String,boolean)>",0,"{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""showFindDialog"");
    return mProvider.showFindDialog(text, showIme);
}","{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, ""showFindDialog"");
    return mProvider.showFindDialog(text, showIme);
}",1,"/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */
","/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The code change involves the conditional check for a debugging flag. The flag 'DebugFlags.TRACE_API' has been replaced with 'TRACE'. This is not changing the behavior or the output of the method but rather the internal logging mechanism, which does not affect the method's execution from an API consumer's perspective. Therefore, the changes fall under the category of 'Other statement changed'.","No Compatibility Issue would arise from this internal change since it doesn't alter the public facing behavior or output of the method. It is purely a change in the debugging flag, which doesn't impact the functionality of the method as it can be seen by the callers. Hence, there is no Compatibility Issue detected."
274,<android.animation.Animator: Animator clone()>,21,22,<android.animation.Animator: Animator clone()>,<android.animation.Animator: Animator clone()>,0,"{
    try {
        final Animator anim = (Animator) super.clone();
        if (mListeners != null) {
            ArrayList<AnimatorListener> oldListeners = mListeners;
            anim.mListeners = new ArrayList<AnimatorListener>();
            int numListeners = oldListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                anim.mListeners.add(oldListeners.get(i));
            }
        }
        if (mPauseListeners != null) {
            ArrayList<AnimatorPauseListener> oldListeners = mPauseListeners;
            anim.mPauseListeners = new ArrayList<AnimatorPauseListener>();
            int numListeners = oldListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                anim.mPauseListeners.add(oldListeners.get(i));
            }
        }
        return anim;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}","{
    try {
        final Animator anim = (Animator) super.clone();
        if (mListeners != null) {
            anim.mListeners = new ArrayList<AnimatorListener>(mListeners);
        }
        if (mPauseListeners != null) {
            anim.mPauseListeners = new ArrayList<AnimatorPauseListener>(mPauseListeners);
        }
        return anim;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,There is a change in how the 'mListeners' and 'mPauseListeners' are cloned by using new ArrayList<>(...) directly instead of manually copying each element. This is an Other statement changed and also a Return statement changed since it affects the state of the object being returned.,"The cloned Animator object in the late version contains ArrayLists that are initialized differently (via copy constructor) which could potentially behave differently if the ArrayList implementation changes its internal copying mechanism. Therefore, a Compatibility Issue can arise due to the potential difference in the cloned object's state, which corresponds to CI type 1."
276,<android.animation.KeyframeSet: KeyframeSet clone()>,21,22,<android.animation.KeyframeSet: KeyframeSet clone()>,<android.animation.KeyframeSet: KeyframeSet clone()>,0,"{
    ArrayList<Keyframe> keyframes = mKeyframes;
    int numKeyframes = mKeyframes.size();
    Keyframe[] newKeyframes = new Keyframe[numKeyframes];
    for (int i = 0; i < numKeyframes; ++i) {
        newKeyframes[i] = keyframes.get(i).clone();
    }
    KeyframeSet newSet = new KeyframeSet(newKeyframes);
    return newSet;
}","{
    List<Keyframe> keyframes = mKeyframes;
    int numKeyframes = mKeyframes.size();
    final Keyframe[] newKeyframes = new Keyframe[numKeyframes];
    for (int i = 0; i < numKeyframes; ++i) {
        newKeyframes[i] = keyframes.get(i).clone();
    }
    KeyframeSet newSet = new KeyframeSet(newKeyframes);
    return newSet;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The change from ArrayList to List for the type of a local variable 'keyframes' and the addition of final modifier to the variable 'newKeyframes' do not affect the functionality, because List is a supertype of ArrayList and final modifier is related to compile-time immutability of the reference, which has no impact on the method's behavior.",There is no Compatibility Issue since the changes do not affect the method's external behavior or output.
277,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,21,22,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,0,"{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Long jniSetter = propertyMap.get(mPropertyName);
            if (jniSetter != null) {
                mJniSetter = jniSetter;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetIntMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Long>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // Couldn't find it via JNI - try reflection next. Probably means the method
    // doesn't exist, or the type is wrong. An error will be logged later if
    // reflection fails as well.
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    synchronized (sJNISetterPropertyMap) {
        HashMap<String, Long> propertyMap = sJNISetterPropertyMap.get(targetClass);
        boolean wasInMap = false;
        if (propertyMap != null) {
            wasInMap = propertyMap.containsKey(mPropertyName);
            if (wasInMap) {
                Long jniSetter = propertyMap.get(mPropertyName);
                if (jniSetter != null) {
                    mJniSetter = jniSetter;
                }
            }
        }
        if (!wasInMap) {
            String methodName = getMethodName(""set"", mPropertyName);
            try {
                mJniSetter = nGetIntMethod(targetClass, methodName);
            } catch (NoSuchMethodError e) {
            // Couldn't find it via JNI - try reflection next. Probably means the method
            // doesn't exist, or the type is wrong. An error will be logged later if
            // reflection fails as well.
            }
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Long>();
                sJNISetterPropertyMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, mJniSetter);
        }
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",2,"The method changed from using a ReentrantReadWriteLock (mPropertyMapLock) to using a synchronized block on sJNISetterPropertyMap directly. Also, there was a change from no explicit exception handling for the method call nGetIntMethod to having a catch block for NoSuchMethodError, although it does not perform any action. These changes affect both exception handling and control dependency, so the change types are 2,3.","The change in exception handling strategy, from not catching NoSuchMethodError for nGetIntMethod to catching it, could potentially lead to different exceptions being thrown by the API. Even though the catch block is empty, it changes the flow of execution by not propagating the NoSuchMethodError outside the method, which might have been the case in the earlier implementation if such an error occurred. Hence, the CI type is 2."
280,"<android.content.Intent: Intent createChooser(Intent,CharSequence)>",21,22,"<android.content.Intent: Intent createChooser(Intent,CharSequence)>","<android.content.Intent: Intent createChooser(Intent,CharSequence)>",0,"{
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_INTENT, target);
    if (title != null) {
        intent.putExtra(EXTRA_TITLE, title);
    }
    // Migrate any clip data and flags from target.
    int permFlags = target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_PERSISTABLE_URI_PERMISSION | FLAG_GRANT_PREFIX_URI_PERMISSION);
    if (permFlags != 0) {
        ClipData targetClipData = target.getClipData();
        if (targetClipData == null && target.getData() != null) {
            ClipData.Item item = new ClipData.Item(target.getData());
            String[] mimeTypes;
            if (target.getType() != null) {
                mimeTypes = new String[] { target.getType() };
            } else {
                mimeTypes = new String[] {};
            }
            targetClipData = new ClipData(null, mimeTypes, item);
        }
        if (targetClipData != null) {
            intent.setClipData(targetClipData);
            intent.addFlags(permFlags);
        }
    }
    return intent;
}","{
    return createChooser(target, title, null);
}",1,"/**
 * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
 *
 * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
 * target intent, also optionally supplying a title.  If the target
 * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
 * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
 * set in the returned chooser intent, with its ClipData set appropriately:
 * either a direct reflection of {@link #getClipData()} if that is non-null,
 * or a new ClipData built from {@link #getData()}.
 *
 * @param target The Intent that the user will be selecting an activity
 * to perform.
 * @param title Optional title that will be displayed in the chooser.
 * @return Return a new Intent object that you can hand to
 * {@link Context#startActivity(Intent) Context.startActivity()} and
 * related methods.
 */
","/**
 * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
 *
 * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
 * target intent, also optionally supplying a title.  If the target
 * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
 * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
 * set in the returned chooser intent, with its ClipData set appropriately:
 * either a direct reflection of {@link #getClipData()} if that is non-null,
 * or a new ClipData built from {@link #getData()}.
 *
 * @param target The Intent that the user will be selecting an activity
 * to perform.
 * @param title Optional title that will be displayed in the chooser.
 * @return Return a new Intent object that you can hand to
 * {@link Context#startActivity(Intent) Context.startActivity()} and
 * related methods.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation in the late version calls another method createChooser(target, title, null), replacing all the inline logic that was present in the early version for constructing the Intent. It depends on another API (dependent API changed) and also changes the entire return statement (return statement changed), so the change type is 1,5.","Since the late version method delegates to another method (createChooser(target, title, null)) and doesnt contain the logic to build the Intent itself, this could lead to a different Intent being returned based on what the overloaded createChooser method does. Therefore, it could cause a Compatibility Issue by potentially returning a different value, and the CI type is 1."
281,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(List<Surface>)>,21,22,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(List<Surface>)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(List<Surface>)>,0,"{
    if (outputs != null) {
        for (Surface output : outputs) {
            if (output == null) {
                Log.e(TAG, ""configureOutputs - null outputs are not allowed"");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            // Validate surface size and format.
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    // WAR: Override default format to IMPLEMENTATION_DEFINED for b/9487482
                    if ((surfaceType >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
                        // YUV_420_888 is always present in LEGACY for all IMPLEMENTATION_DEFINED
                        // output sizes, and is publicly visible in the API (i.e.
                        // {@code #getOutputSizes} works here).
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    String reason = (sizes == null) ? ""format is invalid."" : (""size not in valid set: "" + Arrays.toString(sizes));
                    Log.e(TAG, String.format(""Surface with size (w=%d, h=%d) and format 0x%x is"" + "" not valid, %s"", s.getWidth(), s.getHeight(), surfaceType, reason));
                    return BAD_VALUE;
                }
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, ""Surface bufferqueue is abandoned, cannot configure as output: "", e);
                return BAD_VALUE;
            }
        }
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(outputs);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs != null ? new ArrayList<>(outputs) : null;
    } else {
        return CameraBinderDecorator.INVALID_OPERATION;
    }
    return CameraBinderDecorator.NO_ERROR;
}","{
    List<Pair<Surface, Size>> sizedSurfaces = new ArrayList<>();
    if (outputs != null) {
        for (Surface output : outputs) {
            if (output == null) {
                Log.e(TAG, ""configureOutputs - null outputs are not allowed"");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            // Validate surface size and format.
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                boolean flexibleConsumer = isFlexibleConsumer(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    // WAR: Override default format to IMPLEMENTATION_DEFINED for b/9487482
                    if ((surfaceType >= LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888 && surfaceType <= LegacyMetadataMapper.HAL_PIXEL_FORMAT_BGRA_8888)) {
                        // YUV_420_888 is always present in LEGACY for all
                        // IMPLEMENTATION_DEFINED output sizes, and is publicly visible in the
                        // API (i.e. {@code #getOutputSizes} works here).
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    if (flexibleConsumer && (s = findClosestSize(s, sizes)) != null) {
                        sizedSurfaces.add(new Pair<>(output, s));
                    } else {
                        String reason = (sizes == null) ? ""format is invalid."" : (""size not in valid set: "" + Arrays.toString(sizes));
                        Log.e(TAG, String.format(""Surface with size (w=%d, h=%d) and format "" + ""0x%x is not valid, %s"", s.getWidth(), s.getHeight(), surfaceType, reason));
                        return BAD_VALUE;
                    }
                } else {
                    sizedSurfaces.add(new Pair<>(output, s));
                }
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, ""Surface bufferqueue is abandoned, cannot configure as output: "", e);
                return BAD_VALUE;
            }
        }
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(sizedSurfaces);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs != null ? new ArrayList<>(outputs) : null;
    } else {
        return CameraBinderDecorator.INVALID_OPERATION;
    }
    return CameraBinderDecorator.NO_ERROR;
}",1,"/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
","/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
282,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,21,22,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is a new condition added in the if statement (descriptor.getValue() == null) which is part of the control dependency change, and a change that could potentially change the return value, so the change type is 1,3.","The added conditional check (descriptor.getValue() == null) introduces a new case where the method would return false, which is different from the early version where this condition was not checked. Thus, this could lead to a different return value, and the CI type is 1."
283,"<android.hardware.camera2.CameraManager: void registerAvailabilityCallback(AvailabilityCallback,Handler)>",21,22,"<android.hardware.camera2.CameraManager: void registerAvailabilityCallback(AvailabilityCallback,Handler)>","<android.hardware.camera2.CameraManager: void registerAvailabilityCallback(AvailabilityCallback,Handler)>",0,"{
    if (handler == null) {
        Looper looper = Looper.myLooper();
        if (looper == null) {
            throw new IllegalArgumentException(""No handler given, and current thread has no looper!"");
        }
        handler = new Handler(looper);
    }
    synchronized (mLock) {
        Handler oldHandler = mCallbackMap.put(callback, handler);
        // For new callbacks, provide initial availability information
        if (oldHandler == null) {
            mServiceListener.updateCallbackLocked(callback, handler);
        }
    }
}","{
    if (handler == null) {
        Looper looper = Looper.myLooper();
        if (looper == null) {
            throw new IllegalArgumentException(""No handler given, and current thread has no looper!"");
        }
        handler = new Handler(looper);
    }
    CameraManagerGlobal.get().registerAvailabilityCallback(callback, handler);
}",1,"/**
 * Register a callback to be notified about camera device availability.
 *
 * <p>Registering the same callback again will replace the handler with the
 * new one provided.</p>
 *
 * <p>The first time a callback is registered, it is immediately called
 * with the availability status of all currently known camera devices.</p>
 *
 * @param callback the new callback to send camera availability notices to
 * @param handler The handler on which the callback should be invoked, or
 * {@code null} to use the current thread's {@link android.os.Looper looper}.
 */
","/**
 * Register a callback to be notified about camera device availability.
 *
 * <p>Registering the same callback again will replace the handler with the
 * new one provided.</p>
 *
 * <p>The first time a callback is registered, it is immediately called
 * with the availability status of all currently known camera devices.</p>
 *
 * <p>Since this callback will be registered with the camera service, remember to unregister it
 * once it is no longer needed; otherwise the callback will continue to receive events
 * indefinitely and it may prevent other resources from being released. Specifically, the
 * callbacks will be invoked independently of the general activity lifecycle and independently
 * of the state of individual CameraManager instances.</p>
 *
 * @param callback the new callback to send camera availability notices to
 * @param handler The handler on which the callback should be invoked, or
 * {@code null} to use the current thread's {@link android.os.Looper looper}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The synchronization block and the logic inside it have been replaced with a single method call to CameraManagerGlobal.get().registerAvailabilityCallback(callback, handler), so the change type is 4,5.","Even though there are significant code changes, there is no evidence from the changes that the behavior of the API in terms of return type or exceptions that could be thrown would be altered for the developer using the API. Hence, pred_CI is classified as 0 (No Compatibility Issue)."
284,<android.appwidget.AppWidgetHost: void deleteHost()>,21,22,<android.appwidget.AppWidgetHost: void deleteHost()>,<android.appwidget.AppWidgetHost: void deleteHost()>,0,"{
    try {
        sService.deleteHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        sService.deleteHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
","/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change occurs in the way the package name is retrieved (from mContext.getOpPackageName() to mContextOpPackageName), which implies a change in the variable used to retrieve the package name information, so the code change type is 4.","There is no indication that the change in the source of the package name (from a method call to a variable access) would lead to different behavior from a client's perspective because both should reliably return the same package name. Thus, there is no compatibility issue, and the CI type is 0."
285,<android.widget.CompoundButton: boolean performClick()>,21,22,<android.widget.CompoundButton: boolean performClick()>,<android.widget.CompoundButton: boolean performClick()>,0,"{
    /*
         * XXX: These are tiny, need some surrounding 'expanded touch area',
         * which will need to be implemented in Button if we only override
         * performClick()
         */
    /* When clicked, toggle the state */
    toggle();
    return super.performClick();
}","{
    toggle();
    final boolean handled = super.performClick();
    if (!handled) {
        // View only makes a sound effect if the onClickListener was
        // called, so we'll need to make one here instead.
        playSoundEffect(SoundEffectConstants.CLICK);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The new variable 'handled' is introduced to store the result of super.performClick() and a new condition checking 'if (!handled)' along with the method call playSoundEffect(SoundEffectConstants.CLICK), so the change type is 1,4.","Since in the late implementation the super.performClick() result is now used in a conditional check to determine whether to play a sound effect, this alteration can impact the user experience (in terms of auditory feedback when the button is clicked) and potentially the application's logic expecting this behavior, therefore, it is considered as type 1 (Return statement changed) CI. However, the return type and value (true or false) are not affected by this code change, hence the behaviour in terms of the return value is not altered."
288,"<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>",21,22,"<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>","<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>",0,"{
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}","{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}",1,"/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
","/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version introduces a new block of code specifically for handling instances of `ImageView`. New control structures (an additional initial `if` check for the sharedElement type and its internal `if` conditions), processing logic (creating a `Bundle`, extracting and storing `ImageView` properties), and a return statement that returns a different type (a `Bundle` instead of a `Bitmap`) have been added, while the original return statement for non-`ImageView` cases remains unmodified. Thus, the change types are 1 (for a different return type in some cases), 3 (a new control flow for `ImageView`), and 4 (new statements for handling `ImageView`).","A Compatibility Issue could arise due to the added logic that pertains to `ImageView` elements. In the late version, when the sharedElement is an `ImageView` with a certain configuration, the API now returns a `Bundle` containing the bitmap and additional details about the `ImageView`, instead of directly returning a `Bitmap` as in the early version. Consequently, the API now potentially returns a different value or type based on the conditions met, which satisfies the criteria for type 1 CI."
289,<android.view.View: void setBackgroundDrawable(Drawable)>,21,22,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawables();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPadding();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        applyBackgroundTint();
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawablesInternal();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPaddingInternal();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        applyBackgroundTint();
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}",1,"/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,,,,
290,<android.widget.PopupWindow: void setContentView(View)>,21,22,<android.widget.PopupWindow: void setContentView(View)>,<android.widget.PopupWindow: void setContentView(View)>,0,"{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null && mContentView != null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null && mContentView != null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
}","{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null && mContentView != null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null && mContentView != null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
    // app hasn't already set the attachedInDecor.
    if (mContext != null && !mAttachedInDecorSet) {
        // Attach popup window in decor frame of parent window by default for
        // {@link Build.VERSION_CODES.LOLLIPOP_MR1} or greater. Keep current
        // behavior of not attaching to decor frame for older SDKs.
        setAttachedInDecor(mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP_MR1);
    }
}",1,"/**
 * <p>Change the popup's content. The content is represented by an instance
 * of {@link android.view.View}.</p>
 *
 * <p>This method has no effect if called when the popup is showing.</p>
 *
 * @param contentView the new content for the popup
 *
 * @see #getContentView()
 * @see #isShowing()
 */
","/**
 * <p>Change the popup's content. The content is represented by an instance
 * of {@link android.view.View}.</p>
 *
 * <p>This method has no effect if called when the popup is showing.</p>
 *
 * @param contentView the new content for the popup
 *
 * @see #getContentView()
 * @see #isShowing()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The change consists of adding a comment and a new conditional block ,    setAttachedInDecor(mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP_MR1);
291,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,21,22,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,<android.view.accessibility.AccessibilityManager: boolean removeTouchExplorationStateChangeListener(TouchExplorationStateChangeListener)>,0,"{
    // Final CopyOnArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.remove(listener);
}","{
    // Final CopyOnWriteArrayList - no lock needed.
    return mTouchExplorationStateChangeListeners.remove(listener);
}",1,"/**
 * Unregisters a {@link TouchExplorationStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
","/**
 * Unregisters a {@link TouchExplorationStateChangeListener}.
 *
 * @param listener The listener.
 * @return True if successfully unregistered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the actual code of the method besides the comment, which does not affect the implementation, so the code change type is 0.","Since there is no change in the implementation, there is no Compatibility Issue, hence CI type is 0."
293,<android.animation.ValueAnimator: ValueAnimator clone()>,21,22,<android.animation.ValueAnimator: ValueAnimator clone()>,<android.animation.ValueAnimator: ValueAnimator clone()>,0,"{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
        int numListeners = oldListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            anim.mUpdateListeners.add(oldListeners.get(i));
        }
    }
    anim.mSeekTime = -1;
    anim.mPlayingBackwards = false;
    anim.mCurrentIteration = 0;
    anim.mInitialized = false;
    anim.mPlayingState = STOPPED;
    anim.mStartedDelay = false;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}","{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>(mUpdateListeners);
    }
    anim.mSeekFraction = -1;
    anim.mPlayingBackwards = false;
    anim.mReversing = false;
    anim.mCurrentIteration = 0;
    anim.mInitialized = false;
    anim.mPlayingState = STOPPED;
    anim.mStartedDelay = false;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The change includes modifications to the initialization of 'mUpdateListeners' from a copy loop to a direct invocation of the ArrayList constructor with the given collection and a change from 'mSeekTime' to 'mSeekFraction'. Also, a new field 'mReversing' is set to false which was not present in the previous version. The 'for' loop, cloning 'oldValues', and putting values in 'anim.mValuesMap', however, remain unchanged. These changes affect return statements, other statements, control dependencies, and a dependent API due to the constructor change. Thus, the code change type is 1,3,4,5.","Since the field 'mSeekFraction' is introduced in place of 'mSeekTime' and there's a change in how 'mUpdateListeners' are cloned (which could potentially hold a subclass of AnimatorUpdateListener with overridden equals method), there could be differences in the cloned animator object's state. Therefore, the API may return a ValueAnimator object that behaves differently. The CI type is 1."
295,<android.app.ActivityOptions: void update(ActivityOptions)>,21,22,<android.app.ActivityOptions: void update(ActivityOptions)>,<android.app.ActivityOptions: void update(ActivityOptions)>,0,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
298,"<android.widget.DayPickerView: boolean performAccessibilityAction(int,Bundle)>",21,22,"<android.widget.DayPickerView: boolean performAccessibilityAction(int,Bundle)>","<android.widget.DayPickerView: boolean performAccessibilityAction(int,Bundle)>",0,"{
    if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD && action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        return super.performAccessibilityAction(action, arguments);
    }
    // Figure out what month is showing.
    int firstVisiblePosition = getFirstVisiblePosition();
    int month = firstVisiblePosition % 12;
    int year = firstVisiblePosition / 12 + mController.getMinYear();
    Calendar day = Calendar.getInstance();
    day.set(year, month, 1);
    // Scroll either forward or backward one month.
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
        day.add(Calendar.MONTH, 1);
        if (day.get(Calendar.MONTH) == 12) {
            day.set(Calendar.MONTH, 0);
            day.add(Calendar.YEAR, 1);
        }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        View firstVisibleView = getChildAt(0);
        // to the first day of first visible month.
        if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {
            // There's an off-by-one somewhere, so the top of the first visible item will
            // actually be -1 when it's at the exact top.
            day.add(Calendar.MONTH, -1);
            if (day.get(Calendar.MONTH) == -1) {
                day.set(Calendar.MONTH, 11);
                day.add(Calendar.YEAR, -1);
            }
        }
    }
    // Go to that month.
    announceForAccessibility(getMonthAndYearString(day));
    goTo(day, true, false, true);
    mPerformingScroll = true;
    return true;
}","{
    if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD && action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        return super.performAccessibilityAction(action, arguments);
    }
    // Figure out what month is showing.
    final int firstVisiblePosition = getFirstVisiblePosition();
    final int month = firstVisiblePosition % 12;
    final int year = firstVisiblePosition / 12 + mMinDate.get(Calendar.YEAR);
    final Calendar day = Calendar.getInstance();
    day.set(year, month, 1);
    // Scroll either forward or backward one month.
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
        day.add(Calendar.MONTH, 1);
        if (day.get(Calendar.MONTH) == 12) {
            day.set(Calendar.MONTH, 0);
            day.add(Calendar.YEAR, 1);
        }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        View firstVisibleView = getChildAt(0);
        // to the first day of first visible month.
        if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {
            // There's an off-by-one somewhere, so the top of the first visible item will
            // actually be -1 when it's at the exact top.
            day.add(Calendar.MONTH, -1);
            if (day.get(Calendar.MONTH) == -1) {
                day.set(Calendar.MONTH, 11);
                day.add(Calendar.YEAR, -1);
            }
        }
    }
    // Go to that month.
    announceForAccessibility(getMonthAndYearString(day));
    goTo(day.getTimeInMillis(), true, false, true);
    mPerformingScroll = true;
    return true;
}",1,"/**
 * When scroll forward/backward events are received, announce the newly scrolled-to month.
 */
","/**
 * When scroll forward/backward events are received, announce the newly scrolled-to month.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The late version made a modification to how the year is calculated by changing mController.getMinYear() to mMinDate.get(Calendar.YEAR). Additionally, the goTo method's parameter changed from 'goTo(day, true, false, true)' to 'goTo(day.getTimeInMillis(), true, false, true)', indicating a change in the way the date is passed to the method. Hence, the change types involved are 3 (control dependency change due to the logic that affects variable initialization) and 5 (dependent API changed due to the different parameter used in the method call).","Despite the changes made, there is no compatibility issue in terms of different return values or different exception handlings (types 1 and 2 CI) because the final behavior (scrolling to a certain date and returning true) remains the same. The changes do not affect the return value or the exceptions thrown by the API. The change in calculation only affects internal state, and the goTo method signature remains compatible due to the use of the same date encapsulated in a different format (Calendar instance versus milliseconds)."
299,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,21,22,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mParentNodeId);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of getting the parent node information has changed from a complex condition check and multiple method calls to a single method call to getNodeForAccessibilityId(mParentNodeId). The details inside getNodeForAccessibilityId are not shown, meaning we can consider the dependent API changed. The code change types are 1 and 5.","The change of the implementation suggests that the return value could be different due to changes in the method used to retrieve the parent node information. Therefore, there's the potential for a different return value, meaning the CI type is 1."
