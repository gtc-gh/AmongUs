Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,<android.database.sqlite.SQLiteCompiledSql: void finalize()>,14,15,<android.database.sqlite.SQLiteCompiledSql: void finalize()>,<android.database.sqlite.SQLiteCompiledSql: void finalize()>,0,"{
    try {
        if (nStatement == 0)
            return;
        // queue of statements to be finalized later
        if (mDatabase.isInQueueOfStatementsToBeFinalized(nStatement)) {
            return;
        }
        // in that case, don't print any warning.
        if (mInUse && StrictMode.vmSqliteObjectLeaksEnabled()) {
            int len = mSqlStmt.length();
            StrictMode.onSqliteObjectLeaked(""Releasing statement in a finalizer. Please ensure "" + ""that you explicitly call close() on your cursor: "" + mSqlStmt.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
        }
        releaseSqlStatement();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (nStatement == 0)
            return;
        // queue of statements to be finalized later
        if (mDatabase.isInQueueOfStatementsToBeFinalized(nStatement)) {
            return;
        }
        // in that case, don't print any warning.
        if (mInUse && mStackTrace != null) {
            int len = mSqlStmt.length();
            StrictMode.onSqliteObjectLeaked(""Releasing statement in a finalizer. Please ensure "" + ""that you explicitly call close() on your cursor: "" + mSqlStmt.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
        }
        releaseSqlStatement();
    } finally {
        super.finalize();
    }
}",1,"/**
 * Make sure that the native resource is cleaned up.
 */
","/**
 * Make sure that the native resource is cleaned up.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The condition statement in 'if' has changed from 'StrictMode.vmSqliteObjectLeaksEnabled()' to 'mStackTrace != null', so the code change type is 3.","Although the condition has changed, it doesn't affect the return value nor exception handling of the API, so there's no Compatibility Issue."
2,"<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>",14,15,"<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>",0,"{
    if (mActivity == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle);
            }
        }
        if (mNeedMenuInvalidate && mActivity != null && mCurState == Fragment.RESUMED) {
            mActivity.invalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}","{
    if (mActivity == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle);
                if (f.mLoaderManager != null) {
                    loadersRunning |= f.mLoaderManager.hasRunningLoaders();
                }
            }
        }
        if (!loadersRunning) {
            startPendingDeferredFragments();
        }
        if (mNeedMenuInvalidate && mActivity != null && mCurState == Fragment.RESUMED) {
            mActivity.invalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are two changes between the two implementations. First, the introduction of a new local variable ""loadersRunning"" and its manipulation within the loop (influence of loop execution) is a change in control dependency, so category 3 is taken. Secondly, the introduction of a method ""startPendingDeferredFragments()"" when the ""loadersRunning"" is false is identified as other statement change, thus, category 4 is chosen.","The newly added control dependency and other statements could lead to the method behaving differently, due to different return points and potential exceptions. Such changes could potentially cause the API to return at a different point or throw a different exception, hence CI type 1 is identified."
3,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int)>",14,15,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int)>","<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int)>",0,"{
    // Fragments that are not currently added will sit in the onCreate() state.
    if (!f.mAdded && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                }
                f.mActivity = mActivity;
                f.mFragmentManager = mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                mActivity.onAttachFragment(f);
                if (!f.mRetaining) {
                    f.mCalled = false;
                    f.onCreate(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onCreate()"");
                    }
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mActivity.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throw new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" for fragment "" + f);
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.mCalled = false;
                    f.onActivityCreated(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onActivityCreated()"");
                    }
                    if (f.mView != null) {
                        f.restoreViewState();
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.mCalled = false;
                    f.performStart();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStart()"");
                    }
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mCalled = false;
                    f.mResumed = true;
                    f.onResume();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onResume()"");
                    }
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.mCalled = false;
                    f.onPause();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onPause()"");
                    }
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.mCalled = false;
                    f.performStop();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStop()"");
                    }
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.mCalled = false;
                    f.performDestroyView();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroyView()"");
                    }
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.mCalled = false;
                            f.onDestroy();
                            if (!f.mCalled) {
                                throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroy()"");
                            }
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!f.mRetaining) {
                            makeInactive(f);
                        } else {
                            f.mActivity = null;
                            f.mFragmentManager = null;
                        }
                    }
                }
        }
    }
    f.mState = newState;
}","{
    // Fragments that are not currently added will sit in the onCreate() state.
    if (!f.mAdded && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mActivity = mActivity;
                f.mFragmentManager = mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                mActivity.onAttachFragment(f);
                if (!f.mRetaining) {
                    f.mCalled = false;
                    f.onCreate(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onCreate()"");
                    }
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mActivity.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throw new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" for fragment "" + f);
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.mCalled = false;
                    f.onActivityCreated(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onActivityCreated()"");
                    }
                    if (f.mView != null) {
                        f.restoreViewState();
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.mCalled = false;
                    f.performStart();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStart()"");
                    }
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mCalled = false;
                    f.mResumed = true;
                    f.onResume();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onResume()"");
                    }
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.mCalled = false;
                    f.onPause();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onPause()"");
                    }
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.mCalled = false;
                    f.performStop();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStop()"");
                    }
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.mCalled = false;
                    f.performDestroyView();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroyView()"");
                    }
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.mCalled = false;
                            f.onDestroy();
                            if (!f.mCalled) {
                                throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroy()"");
                            }
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!f.mRetaining) {
                            makeInactive(f);
                        } else {
                            f.mActivity = null;
                            f.mFragmentManager = null;
                        }
                    }
                }
        }
    }
    f.mState = newState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
4,<android.server.BluetoothService: void removeProfileState(String)>,14,15,<android.server.BluetoothService: void removeProfileState(String)>,<android.server.BluetoothService: void removeProfileState(String)>,0,"{
    mDeviceProfileState.remove(address);
}","{
    BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
    if (state == null)
        return;
    state.quit();
    mDeviceProfileState.remove(address);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"Control dependency change is observed as a new 'if' condition is introduced which controls the code execution. Also, there is an introduction of 'state.quit()' which is another statement change. Therefore, the code change types are 3, 4.","There is no Compatibility Issue as the main behavior of the method, which is to remove the profile state, remains intact in both versions. The introduced changes are to restrict removal operation on a non-existent state (null state), which does not alter the main functionality, and 'state.quit()' doesn't throw any new exception or return a different result. Therefore, no Compatibility Issue is detected."
5,<android.server.BluetoothAdapterStateMachine.BluetoothOn: boolean processMessage(Message)>,14,15,<android.server.BluetoothAdapterStateMachine.BluetoothOn: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.BluetoothOn: boolean processMessage(Message)>,0,"{
    log(""BluetoothOn process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_OFF:
            if ((Boolean) message.obj) {
                persistSwitchSetting(false);
            }
            if (mBluetoothService.isDiscovering()) {
                mBluetoothService.cancelDiscovery();
            }
            if (!mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
                transitionTo(mPerProcessState);
                deferMessage(obtainMessage(TURN_HOT));
                break;
            }
        // $FALL-THROUGH$ to AIRPLANE_MODE_ON
        case AIRPLANE_MODE_ON:
            transitionTo(mSwitching);
            broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
            if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
                mBluetoothService.disconnectDevices();
                sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT, DEVICES_DISCONNECT_TIMEOUT_TIME);
            } else {
                mBluetoothService.switchConnectable(false);
                sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            }
            // we turn all the way to PowerOff with AIRPLANE_MODE_ON
            if (message.what == AIRPLANE_MODE_ON) {
                // We inform all the per process callbacks
                allProcessesCallback(false);
                deferMessage(obtainMessage(AIRPLANE_MODE_ON));
            }
            break;
        case AIRPLANE_MODE_OFF:
        case USER_TURN_ON:
            Log.w(TAG, ""BluetoothOn received: "" + message.what);
            break;
        case PER_PROCESS_TURN_ON:
            perProcessCallback(true, (IBluetoothStateChangeCallback) message.obj);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                // reset the state machine and send it TURN_ON_CONTINUE message
                recoverStateMachine(USER_TURN_ON, false);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""BluetoothOn process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_OFF:
            if ((Boolean) message.obj) {
                persistSwitchSetting(false);
            }
            if (mBluetoothService.isDiscovering()) {
                mBluetoothService.cancelDiscovery();
            }
            if (!mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
                transitionTo(mPerProcessState);
                deferMessage(obtainMessage(TURN_HOT));
                break;
            }
        // $FALL-THROUGH$ to AIRPLANE_MODE_ON
        case AIRPLANE_MODE_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
            transitionTo(mSwitching);
            if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
                mBluetoothService.disconnectDevices();
                sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT, DEVICES_DISCONNECT_TIMEOUT_TIME);
            } else {
                mBluetoothService.switchConnectable(false);
                sendMessageDelayed(POWER_DOWN_TIMEOUT, POWER_DOWN_TIMEOUT_TIME);
            }
            // we turn all the way to PowerOff with AIRPLANE_MODE_ON
            if (message.what == AIRPLANE_MODE_ON) {
                // We inform all the per process callbacks
                allProcessesCallback(false);
                deferMessage(obtainMessage(AIRPLANE_MODE_ON));
            }
            break;
        case AIRPLANE_MODE_OFF:
        case USER_TURN_ON:
            Log.w(TAG, ""BluetoothOn received: "" + message.what);
            break;
        case PER_PROCESS_TURN_ON:
            perProcessCallback(true, (IBluetoothStateChangeCallback) message.obj);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                // reset the state machine and send it TURN_ON_CONTINUE message
                recoverStateMachine(USER_TURN_ON, false);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The code changes in the switch case AIRPLANE_MODE_ON, where the position of the broadcastState(BluetoothAdapter.STATE_TURNING_OFF); and transitionTo(mSwitching); have been swapped. This belongs to the change type 3: Control dependency changed.","As only the order of broadcastState and transitionTo has been swapped in case AIRPLANE_MODE_ON and it doesn't impact the type or values returned by the method, also it doesn't change the exceptions thrown, therefore, no compatibility issue exists. CI type is 0."
6,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,14,15,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mAccessibilityViewId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnection, mAccessibilityWindowId, mAccessibilityViewId, action);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mAccessibilityViewId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mAccessibilityWindowId, mAccessibilityViewId, action);
}",1,"/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The parameter while calling a method (client.performAccessibilityAction) has been changed, so the code change type is 4."," Due to the change in method calling parameters, the return value of client.performAccessibilityAction might change which will directly impact the return value of the method performAction(int). Thus, the CI type is 1."
7,<android.widget.PopupWindow: void dismiss()>,14,15,<android.widget.PopupWindow: void dismiss()>,<android.widget.PopupWindow: void dismiss()>,0,"{
    if (isShowing() && mPopupView != null) {
        unregisterForScrollChanged();
        try {
            mWindowManager.removeView(mPopupView);
        } finally {
            if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
                ((ViewGroup) mPopupView).removeView(mContentView);
            }
            mPopupView = null;
            mIsShowing = false;
            if (mOnDismissListener != null) {
                mOnDismissListener.onDismiss();
            }
        }
    }
}","{
    if (isShowing() && mPopupView != null) {
        mIsShowing = false;
        unregisterForScrollChanged();
        try {
            mWindowManager.removeView(mPopupView);
        } finally {
            if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
                ((ViewGroup) mPopupView).removeView(mContentView);
            }
            mPopupView = null;
            if (mOnDismissListener != null) {
                mOnDismissListener.onDismiss();
            }
        }
    }
}",1,"/**
 * <p>Dispose of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
 * this method will have no effect.</p>
 *
 * @see #showAsDropDown(android.view.View)
 */
","/**
 * <p>Dispose of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
 * this method will have no effect.</p>
 *
 * @see #showAsDropDown(android.view.View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the order of statements in the block. The 'mIsShowing = false;' statement, which was previously located after the `try` statement, has now been moved before `unregisterForScrollChanged();`. This is classified as type 4 - Other statement changed.","Despite changes in the order of statement execution, this does not affect the behavior of the API. Therefore, it doesn't seem to result in any compatibility issue."
9,<android.app.FragmentManagerImpl: boolean execPendingActions()>,14,15,<android.app.FragmentManagerImpl: boolean execPendingActions()>,<android.app.FragmentManagerImpl: boolean execPendingActions()>,0,"{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mActivity.mHandler.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                return didSomething;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mActivity.mHandler.removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
}","{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mActivity.mHandler.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mActivity.mHandler.removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    if (mHavePendingDeferredStart) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mLoaderManager != null) {
                loadersRunning |= f.mLoaderManager.hasRunningLoaders();
            }
        }
        if (!loadersRunning) {
            mHavePendingDeferredStart = false;
            startPendingDeferredFragments();
        }
    }
    return didSomething;
}",1,"/**
 * Only call from main thread!
 */
","/**
 * Only call from main thread!
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",1,"There is an introduction of a new block of code checking if `mHavePendingDeferredStart` is true. This changes the control dependency (type 3) as the ending part of the code is now executed dependent on this condition. Additionally, these are new statements being added to the method, hence, type 4 changes are also present.","The introduced statements can potentially affect the ""didSomething"" flag and therefore change the return value of the method. So, the CI type is 1."
10,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,14,15,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,0,"{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (mSelectingText) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        recordButtons(null, hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if ((mMapTrackballToArrowKeys && (ev.getMetaState() & KeyEvent.META_SHIFT_ON) == 0) || AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time, ev.getMetaState());
    return true;
}","{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (mSelectingText) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if ((mMapTrackballToArrowKeys && (ev.getMetaState() & KeyEvent.META_SHIFT_ON) == 0) || AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time, ev.getMetaState());
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,Both the early and late version of the implementations are exactly the same.,"Given that there are no changes in both versions of the method implementation, no compatibility issues exist."
12,<android.widget.TextView: boolean onTextContextMenuItem(int)>,14,15,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_COPY_URL:
            URLSpan[] urls = ((Spanned) mText).getSpans(min, max, URLSpan.class);
            if (urls.length >= 1) {
                ClipData clip = null;
                for (int i = 0; i < urls.length; i++) {
                    Uri uri = Uri.parse(urls[0].getURL());
                    if (clip == null) {
                        clip = ClipData.newRawUri(null, uri);
                    } else {
                        clip.addItem(new ClipData.Item(uri));
                    }
                }
                if (clip != null) {
                    setPrimaryClip(clip);
                }
            }
            stopSelectionActionMode();
            return true;
        case ID_SELECTION_MODE:
            if (mSelectionActionMode != null) {
                // Selection mode is already started, simply change selected part.
                selectCurrentWord();
            } else {
                startSelectionActionMode();
            }
            return true;
        case ID_SELECT_ALL:
            // This does not enter text selection mode. Text is highlighted, so that it can be
            // bulk edited, like selectAllOnFocus does. Returns true even if text is empty.
            selectAll();
            return true;
        case ID_PASTE:
            paste(min, max);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            ((Editable) mText).delete(min, max);
            stopSelectionActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopSelectionActionMode();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            // This does not enter text selection mode. Text is highlighted, so that it can be
            // bulk edited, like selectAllOnFocus does. Returns true even if text is empty.
            selectAll();
            return true;
        case ID_PASTE:
            paste(min, max);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            stopSelectionActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopSelectionActionMode();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be {@link android.R.id#copyUrl}, {@link android.R.id#selectTextMode},
 * {@link android.R.id#selectAll}, {@link android.R.id#paste}, {@link android.R.id#cut}
 * or {@link android.R.id#copy}.
 *
 * @return true if the context menu item action was performed.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy} or {@link android.R.id#paste}.
 *
 * @return true if the context menu item action was performed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency within the switch statement has changed (case ID_COPY_URL and ID_SELECTION_MODE deleted, and method ((Editable)mText).delete(min, max) changed to deleteText_internal(min, max)). Therefore the code change type is 3,4.","Changes in switch cases and the method called in ID_CUT case could make the API potentially return a different value (false instead of true) depending on id. Hence, the CI type is 1."
14,<android.speech.tts.TextToSpeechService.SynthesisToFileSpeechItem: int playImpl()>,14,15,<android.speech.tts.TextToSpeechService.SynthesisToFileSpeechItem: int playImpl()>,<android.speech.tts.TextToSpeechService.SynthesisToFileSpeechItem: int playImpl()>,0,"{
    int status = super.playImpl();
    if (status == TextToSpeech.SUCCESS) {
        dispatchUtteranceCompleted();
    }
    return status;
}","{
    dispatchOnStart();
    int status = super.playImpl();
    if (status == TextToSpeech.SUCCESS) {
        dispatchOnDone();
    } else {
        dispatchOnError();
    }
    return status;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is an added method dispatchOnStart() and change to what is conditionally executed, now invoking either dispatchOnDone() if status equals TextToSpeech.SUCCESS, or dispatchOnError() otherwise, so the code change types are 1 (as the sequence of method calls in the return path is changed), 3 (as control path is changed) and 4 (as new method calls are introduced).","The alterations made in the code affects the sequencing and conditional execution of certain methods, which can result in different behaviours, potentially causing the API to return different types or values. Hence, there is a potential Compatibility Issue of class 1."
16,<android.widget.TextView: void setEnabled(boolean)>,14,15,<android.widget.TextView: void setEnabled(boolean)>,<android.widget.TextView: void setEnabled(boolean)>,0,"{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
    prepareCursorControllers();
    if (enabled) {
        // Make sure IME is updated with current editor info.
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null)
            imm.restartInput(this);
    }
}","{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
    prepareCursorControllers();
    if (enabled) {
        // Make sure IME is updated with current editor info.
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null)
            imm.restartInput(this);
    }
    // start or stop the cursor blinking as appropriate
    makeBlink();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method 'makeBlink()' is added in the late implementation. It does not belong to 'return' or 'exception' or 'control dependency', so the change type is 4.","The new method 'makeBlink()' does not contribute to the return or throw values of this API implementation, so no CI issue is identified, and the CI type is 0."
17,<android.view.View: boolean dispatchDragEvent(DragEvent)>,14,15,<android.view.View: boolean dispatchDragEvent(DragEvent)>,<android.view.View: boolean dispatchDragEvent(DragEvent)>,0,"{
    // noinspection SimplifiableIfStatement
    if (mOnDragListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnDragListener.onDrag(this, event)) {
        return true;
    }
    return onDragEvent(event);
}","{
    // noinspection SimplifiableIfStatement
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnDragListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnDragListener.onDrag(this, event)) {
        return true;
    }
    return onDragEvent(event);
}",1,"/**
 * Detects if this View is enabled and has a drag event listener.
 * If both are true, then it calls the drag event listener with the
 * {@link android.view.DragEvent} it received. If the drag event listener returns
 * {@code true}, then dispatchDragEvent() returns {@code true}.
 * <p>
 * For all other cases, the method calls the
 * {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} drag event handler
 * method and returns its result.
 * </p>
 * <p>
 * This ensures that a drag event is always consumed, even if the View does not have a drag
 * event listener. However, if the View has a listener and the listener returns true, then
 * onDragEvent() is not called.
 * </p>
 */
","/**
 * Detects if this View is enabled and has a drag event listener.
 * If both are true, then it calls the drag event listener with the
 * {@link android.view.DragEvent} it received. If the drag event listener returns
 * {@code true}, then dispatchDragEvent() returns {@code true}.
 * <p>
 * For all other cases, the method calls the
 * {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} drag event handler
 * method and returns its result.
 * </p>
 * <p>
 * This ensures that a drag event is always consumed, even if the View does not have a drag
 * event listener. However, if the View has a listener and the listener returns true, then
 * onDragEvent() is not called.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The variable used in if statement has changed from 'mOnDragListener' to 'li.mOnDragListener'. Also, a new variable 'li' is introduced based on 'mListenerInfo'. So, the code change type is 4,5.","As the 'mOnDragListener' is being replaced by 'li.mOnDragListener', the behavior of the returned value in the 'if' statement may change, causing potentially different return values. As a result, the CI type is 1."
18,<android.widget.TextView.SuggestionsPopupWindow: void show()>,14,15,<android.widget.TextView.SuggestionsPopupWindow: void show()>,<android.widget.TextView.SuggestionsPopupWindow: void show()>,0,"{
    if (!(mText instanceof Editable))
        return;
    updateSuggestions();
    mCursorWasVisibleBeforeSuggestions = mCursorVisible;
    setCursorVisible(false);
    super.show();
}","{
    if (!(mText instanceof Editable))
        return;
    updateSuggestions();
    mCursorWasVisibleBeforeSuggestions = mCursorVisible;
    setCursorVisible(false);
    mIsShowingUp = true;
    super.show();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late version, one more line ""mIsShowingUp = true;"" is added before ""super.show();"", which falls under other statement changed.","This added statement only changes an internal status and does not impact the returned value or the types of exception thrown by the API, hence no Compatibility Issue exists."
20,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,14,15,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnTouchListener.onTouch(this, event)) {
            return true;
        }
        if (onTouchEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {
            return true;
        }
        if (onTouchEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}",1,"/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"From the early to the late version, a new object `li` was introduced. The new object `li` was taken from `mListenerInfo`. The check condition `(mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnTouchListener.onTouch(this, event))` was also modified to take into account `li`. The changes include alternation in control logic and a change of return logic as it is based on the new data member, so thus the changes are classified as 1,3, and 4.","The introduction of the new member `li` and the changed condition to return `true` can potentially change the actual value returned from the API, leading to different behaviors. Hence it could cause a compatibility issue of type 1."
21,"<android.server.BluetoothService: BluetoothDeviceProfileState addProfileState(String,boolean)>",14,15,"<android.server.BluetoothService: BluetoothDeviceProfileState addProfileState(String,boolean)>","<android.server.BluetoothService: BluetoothDeviceProfileState addProfileState(String,boolean)>",0,"{
    BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
    if (state != null)
        return state;
    state = new BluetoothDeviceProfileState(mContext, address, this, mA2dpService, setTrust);
    mDeviceProfileState.put(address, state);
    state.start();
    return state;
}","{
    BluetoothDeviceProfileState state = new BluetoothDeviceProfileState(mContext, address, this, mA2dpService, setTrust);
    mDeviceProfileState.put(address, state);
    state.start();
    return state;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control statement, which checks if the state is not null, and the return statement inside that statement have been deleted, hence the code change type is 3,4.","The removal of the control statement and return statement inside that could potentially lead to the API returning different variables, leading to a change in behaviour, therefore classifying this as a CI of type 1."
22,"<android.webkit.WebTextView: void onTextChanged(CharSequence,int,int,int)>",14,15,"<android.webkit.WebTextView: void onTextChanged(CharSequence,int,int,int)>","<android.webkit.WebTextView: void onTextChanged(CharSequence,int,int,int)>",0,"{
    super.onTextChanged(s, start, before, count);
    String postChange = s.toString();
    // limit on text length from registering the onTextChanged event.
    if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0, mMaxLength).equals(postChange))) {
        return;
    }
    mPreChange = postChange;
    if (0 == count) {
        if (before > 0) {
            // For this and all changes to the text, update our cache
            updateCachedTextfield();
            if (mGotDelete) {
                mGotDelete = false;
                int oldEnd = start + before;
                if (mDelSelEnd == oldEnd && (mDelSelStart == start || (mDelSelStart == oldEnd && before == 1))) {
                    // If the selection is set up properly before the
                    // delete, send the DOM events.
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL));
                    return;
                }
            }
            // This was simply a delete or a cut, so just delete the
            // selection.
            mWebView.deleteSelection(start, start + before);
        }
        mGotDelete = false;
        // changed, we should return.
        return;
    }
    // Ensure that this flag gets cleared, since with autocorrect on, a
    // delete key press may have a more complex result than deleting one
    // character or the existing selection, so it will not get cleared
    // above.
    mGotDelete = false;
    // don't replace the unchanged text.
    if (count > 1 && before == count - 1) {
        String replaceButOne = s.subSequence(start, start + before).toString();
        String replacedString = getText().subSequence(start, start + before).toString();
        if (replaceButOne.equals(replacedString)) {
            // we're just adding one character
            start += before;
            before = 0;
            count = 1;
        }
    }
    // Find the last character being replaced.  If it can be represented by
    // events, we will pass them to native so we can see javascript events.
    // Otherwise, replace the text being changed in the textfield.
    KeyEvent[] events = null;
    if (count == 1) {
        TextUtils.getChars(s, start + count - 1, start + count, mCharacter, 0);
        KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        events = kmap.getEvents(mCharacter);
    }
    boolean useKeyEvents = (events != null);
    if (useKeyEvents) {
        // trackball or auto-correct.
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onTextChanged start="" + start + "" start + before="" + (start + before));
        }
        if (!mInSetTextAndKeepSelection) {
            mWebView.setSelection(start, start + before);
        }
        int length = events.length;
        for (int i = 0; i < length; i++) {
            // here either.
            if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
                sendDomEvent(events[i]);
            }
        }
    } else {
        String replace = s.subSequence(start, start + count).toString();
        mWebView.replaceTextfieldText(start, start + before, replace, start + count, start + count);
    }
    updateCachedTextfield();
}","{
    super.onTextChanged(s, start, before, count);
    String postChange = s.toString();
    // limit on text length from registering the onTextChanged event.
    if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0, mMaxLength).equals(postChange))) {
        return;
    }
    if (0 == count) {
        if (before > 0) {
            // For this and all changes to the text, update our cache
            updateCachedTextfield();
            if (mGotDelete) {
                mGotDelete = false;
                int oldEnd = start + before;
                if (mDelSelEnd == oldEnd && (mDelSelStart == start || (mDelSelStart == oldEnd && before == 1))) {
                    // If the selection is set up properly before the
                    // delete, send the DOM events.
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL));
                    return;
                }
            }
            // This was simply a delete or a cut, so just delete the
            // selection.
            mWebView.deleteSelection(start, start + before);
        }
        mGotDelete = false;
        // changed, we should return.
        return;
    }
    // Ensure that this flag gets cleared, since with autocorrect on, a
    // delete key press may have a more complex result than deleting one
    // character or the existing selection, so it will not get cleared
    // above.
    mGotDelete = false;
    // don't replace the unchanged text.
    if (count > 1 && before == count - 1) {
        String replaceButOne = mPreChange.subSequence(start, start + before).toString();
        String replacedString = s.subSequence(start, start + before).toString();
        if (replaceButOne.equals(replacedString)) {
            // we're just adding one character
            start += before;
            before = 0;
            count = 1;
        }
    }
    mPreChange = postChange;
    // Find the last character being replaced.  If it can be represented by
    // events, we will pass them to native so we can see javascript events.
    // Otherwise, replace the text being changed in the textfield.
    KeyEvent[] events = null;
    if (count == 1) {
        TextUtils.getChars(s, start + count - 1, start + count, mCharacter, 0);
        KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        events = kmap.getEvents(mCharacter);
    }
    boolean useKeyEvents = (events != null);
    if (useKeyEvents) {
        // trackball or auto-correct.
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onTextChanged start="" + start + "" start + before="" + (start + before));
        }
        if (!mInSetTextAndKeepSelection) {
            mWebView.setSelection(start, start + before);
        }
        int length = events.length;
        for (int i = 0; i < length; i++) {
            // here either.
            if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
                sendDomEvent(events[i]);
            }
        }
    } else {
        String replace = s.subSequence(start, start + count).toString();
        mWebView.replaceTextfieldText(start, start + before, replace, start + count, start + count);
    }
    updateCachedTextfield();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The assignment of `mPreChange` is moved after an 'if' condition, and a string assignment `String replaceButOne = mPreChange.subSequence(start, start + before).toString();` is added within the conditional. The code change types are 3 for the control dependency change (as the `mPreChange` assignment is now under an extra control condition) and 4 for other statement change.","The delayed assignment of `mPreChange` and the additional `replaceButOne` creation may affect the `return` behaviour. This may cause the API to return at a different situation or potentially return a different value, leading to CI type 1."
24,<android.view.View: OnFocusChangeListener getOnFocusChangeListener()>,14,15,<android.view.View: OnFocusChangeListener getOnFocusChangeListener()>,<android.view.View: OnFocusChangeListener getOnFocusChangeListener()>,0,"{
    return mOnFocusChangeListener;
}","{
    ListenerInfo li = mListenerInfo;
    return li != null ? li.mOnFocusChangeListener : null;
}",1,"/**
 * Returns the focus-change callback registered for this view.
 *
 * @return The callback, or null if one is not registered.
 */
","/**
 * Returns the focus-change callback registered for this view.
 *
 * @return The callback, or null if one is not registered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been altered and now includes a ternary operator, hence the type of code change is 1.","The alteration in the return mechanism can potentially lead to different returned values, which results in the CI being classified as type 1."
25,<android.webkit.ZoomManager: void animateZoom(Canvas)>,14,15,<android.webkit.ZoomManager: void animateZoom(Canvas)>,<android.webkit.ZoomManager: void animateZoom(Canvas)>,0,"{
    mInitialZoomOverview = false;
    if (mZoomScale == 0) {
        Log.w(LOGTAG, ""A WebView is attempting to perform a fixed length "" + ""zoom animation when no zoom is in progress"");
        return;
    }
    float zoomScale;
    int interval = (int) (SystemClock.uptimeMillis() - mZoomStart);
    if (interval < ZOOM_ANIMATION_LENGTH) {
        float ratio = (float) interval / ZOOM_ANIMATION_LENGTH;
        zoomScale = 1.0f / (mInvInitialZoomScale + (mInvFinalZoomScale - mInvInitialZoomScale) * ratio);
        mWebView.invalidate();
    } else {
        zoomScale = mZoomScale;
        // set mZoomScale to be 0 as we have finished animating
        mZoomScale = 0;
        mWebView.onFixedLengthZoomAnimationEnd();
    }
    // calculate the intermediate scroll position. Since we need to use
    // zoomScale, we can't use the WebView's pinLocX/Y functions directly.
    float scale = zoomScale * mInvInitialZoomScale;
    int tx = Math.round(scale * (mInitialScrollX + mZoomCenterX) - mZoomCenterX);
    tx = -WebView.pinLoc(tx, mWebView.getViewWidth(), Math.round(mWebView.getContentWidth() * zoomScale)) + mWebView.getScrollX();
    int titleHeight = mWebView.getTitleHeight();
    int ty = Math.round(scale * (mInitialScrollY + mZoomCenterY - titleHeight) - (mZoomCenterY - titleHeight));
    ty = -(ty <= titleHeight ? Math.max(ty, 0) : WebView.pinLoc(ty - titleHeight, mWebView.getViewHeight(), Math.round(mWebView.getContentHeight() * zoomScale)) + titleHeight) + mWebView.getScrollY();
    if (mHardwareAccelerated) {
        mWebView.updateScrollCoordinates(mWebView.getScrollX() - tx, mWebView.getScrollY() - ty);
        setZoomScale(zoomScale, false);
        if (mZoomScale == 0) {
            // We've reached the end of the zoom animation.
            mInHWAcceleratedZoom = false;
        }
    } else {
        canvas.translate(tx, ty);
        canvas.scale(zoomScale, zoomScale);
    }
}","{
    mInitialZoomOverview = false;
    if (mZoomScale == 0) {
        Log.w(LOGTAG, ""A WebView is attempting to perform a fixed length "" + ""zoom animation when no zoom is in progress"");
        return;
    }
    float zoomScale;
    int interval = (int) (SystemClock.uptimeMillis() - mZoomStart);
    if (interval < ZOOM_ANIMATION_LENGTH) {
        float ratio = (float) interval / ZOOM_ANIMATION_LENGTH;
        zoomScale = 1.0f / (mInvInitialZoomScale + (mInvFinalZoomScale - mInvInitialZoomScale) * ratio);
        mWebView.invalidate();
    } else {
        zoomScale = mZoomScale;
        // set mZoomScale to be 0 as we have finished animating
        mZoomScale = 0;
        mWebView.onFixedLengthZoomAnimationEnd();
    }
    // calculate the intermediate scroll position. Since we need to use
    // zoomScale, we can't use the WebView's pinLocX/Y functions directly.
    float scale = zoomScale * mInvInitialZoomScale;
    int tx = Math.round(scale * (mInitialScrollX + mZoomCenterX) - mZoomCenterX);
    tx = -WebView.pinLoc(tx, mWebView.getViewWidth(), Math.round(mWebView.getContentWidth() * zoomScale)) + mWebView.getScrollX();
    int titleHeight = mWebView.getTitleHeight();
    int ty = Math.round(scale * (mInitialScrollY + mZoomCenterY - titleHeight) - (mZoomCenterY - titleHeight));
    ty = -(ty <= titleHeight ? Math.max(ty, 0) : WebView.pinLoc(ty - titleHeight, mWebView.getViewHeight(), Math.round(mWebView.getContentHeight() * zoomScale)) + titleHeight) + mWebView.getScrollY();
    if (mHardwareAccelerated) {
        mWebView.updateScrollCoordinates(mWebView.getScrollX() - tx, mWebView.getScrollY() - ty);
        // By adding webView matrix, we need to offset the canvas a bit
        // to make the animation smooth.
        canvas.translate(tx, ty);
        setZoomScale(zoomScale, false);
        if (mZoomScale == 0) {
            // We've reached the end of the zoom animation.
            mInHWAcceleratedZoom = false;
            // Ensure that the zoom level is pushed to WebCore. This has not
            // yet occurred because we prevent it from happening while
            // mInHWAcceleratedZoom is true.
            mWebView.sendViewSizeZoom(false);
        }
    } else {
        canvas.translate(tx, ty);
        canvas.scale(zoomScale, zoomScale);
    }
}",1,"/**
 * This method is called by the WebView's drawing code when a fixed length zoom
 * animation is occurring. Its purpose is to animate the zooming of the canvas
 * to the desired scale which was specified in startZoomAnimation(...).
 *
 * A fixed length animation begins when startZoomAnimation(...) is called and
 * continues until the ZOOM_ANIMATION_LENGTH time has elapsed. During that
 * interval each time the WebView draws it calls this function which is
 * responsible for generating the animation.
 *
 * Additionally, the WebView can check to see if such an animation is currently
 * in progress by calling isFixedLengthAnimationInProgress().
 */
","/**
 * This method is called by the WebView's drawing code when a fixed length zoom
 * animation is occurring. Its purpose is to animate the zooming of the canvas
 * to the desired scale which was specified in startZoomAnimation(...).
 *
 * A fixed length animation begins when startZoomAnimation(...) is called and
 * continues until the ZOOM_ANIMATION_LENGTH time has elapsed. During that
 * interval each time the WebView draws it calls this function which is
 * responsible for generating the animation.
 *
 * Additionally, the WebView can check to see if such an animation is currently
 * in progress by calling isFixedLengthAnimationInProgress().
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, a new comment, a new method invocation mWebView.sendViewSizeZoom(false), and a canvas.translation() are added under the condition statement if (mHardwareAccelerated) {}. The change type is 4.","These changes don't cause potential different return value or type. Also, the modified statements don't throw any exceptions. Therefore, no compatibility issues exist (CI type 0)."
28,<android.widget.TextView: Parcelable onSaveInstanceState()>,14,15,<android.widget.TextView: Parcelable onSaveInstanceState()>,<android.widget.TextView: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            SuggestionSpan[] suggestionSpans = sp.getSpans(0, sp.length(), SuggestionSpan.class);
            for (int i = 0; i < suggestionSpans.length; i++) {
                int flags = suggestionSpans[i].getFlags();
                if ((flags & SuggestionSpan.FLAG_EASY_CORRECT) != 0 && (flags & SuggestionSpan.FLAG_MISSPELLED) != 0) {
                    sp.removeSpan(suggestionSpans[i]);
                }
            }
            sp.removeSpan(mSuggestionRangeSpan);
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = mError;
        return ss;
    }
    return superState;
}","{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            removeMisspelledSpans(sp);
            sp.removeSpan(mSuggestionRangeSpan);
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = mError;
        return ss;
    }
    return superState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"Code related to 'suggestionSpans' has been moved to a new dependent method 'removeMisspelledSpans(sp)', and the implementation of how to deal with 'suggestionSpans' has changed, so the code change type is 4,5.","The change in how 'suggestionSpans' are handled will potentially lead to different values of 'ss.text', thus the return statement could be different, resulting in a CI type of 1."
29,<android.server.BluetoothAdapterStateMachine.PowerOff: boolean processMessage(Message)>,14,15,<android.server.BluetoothAdapterStateMachine.PowerOff: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.PowerOff: boolean processMessage(Message)>,0,"{
    log(""PowerOff process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            // starts turning on BT module, broadcast this out
            transitionTo(mWarmUp);
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            if (prepareBluetooth()) {
                // this is user request, save the setting
                if ((Boolean) message.obj) {
                    persistSwitchSetting(true);
                }
                // We will continue turn the BT on all the way to the BluetoothOn state
                deferMessage(obtainMessage(TURN_ON_CONTINUE));
            } else {
                Log.e(TAG, ""failed to prepare bluetooth, abort turning on"");
                transitionTo(mPowerOff);
                broadcastState(BluetoothAdapter.STATE_OFF);
            }
            break;
        case TURN_HOT:
            if (prepareBluetooth()) {
                transitionTo(mWarmUp);
            }
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                // starts turning on BT module, broadcast this out
                transitionTo(mWarmUp);
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
                if (prepareBluetooth()) {
                    // We will continue turn the BT on all the way to the BluetoothOn state
                    deferMessage(obtainMessage(TURN_ON_CONTINUE));
                    transitionTo(mWarmUp);
                } else {
                    Log.e(TAG, ""failed to prepare bluetooth, abort turning on"");
                    transitionTo(mPowerOff);
                    broadcastState(BluetoothAdapter.STATE_OFF);
                }
            } else if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                sendMessage(TURN_HOT);
            }
            break;
        case PER_PROCESS_TURN_ON:
            if (prepareBluetooth()) {
                transitionTo(mWarmUp);
            }
            deferMessage(obtainMessage(PER_PROCESS_TURN_ON));
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case USER_TURN_OFF:
            Log.w(TAG, ""PowerOff received: "" + message.what);
        case // ignore
        AIRPLANE_MODE_ON:
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""PowerOff process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            // starts turning on BT module, broadcast this out
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            transitionTo(mWarmUp);
            if (prepareBluetooth()) {
                // this is user request, save the setting
                if ((Boolean) message.obj) {
                    persistSwitchSetting(true);
                }
                // We will continue turn the BT on all the way to the BluetoothOn state
                deferMessage(obtainMessage(TURN_ON_CONTINUE));
            } else {
                Log.e(TAG, ""failed to prepare bluetooth, abort turning on"");
                transitionTo(mPowerOff);
                broadcastState(BluetoothAdapter.STATE_OFF);
            }
            break;
        case TURN_HOT:
            if (prepareBluetooth()) {
                transitionTo(mWarmUp);
            }
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                // starts turning on BT module, broadcast this out
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
                transitionTo(mWarmUp);
                if (prepareBluetooth()) {
                    // We will continue turn the BT on all the way to the BluetoothOn state
                    deferMessage(obtainMessage(TURN_ON_CONTINUE));
                    transitionTo(mWarmUp);
                } else {
                    Log.e(TAG, ""failed to prepare bluetooth, abort turning on"");
                    transitionTo(mPowerOff);
                    broadcastState(BluetoothAdapter.STATE_OFF);
                }
            } else if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
                sendMessage(TURN_HOT);
            }
            break;
        case PER_PROCESS_TURN_ON:
            if (prepareBluetooth()) {
                transitionTo(mWarmUp);
            }
            deferMessage(obtainMessage(PER_PROCESS_TURN_ON));
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case USER_TURN_OFF:
            Log.w(TAG, ""PowerOff received: "" + message.what);
        case // ignore
        AIRPLANE_MODE_ON:
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"There is a control dependency change in the switch block of the method, specifically in the case for USER_TURN_ON. The order of two statements inside the block has been switched; 'broadcastState(BluetoothAdapter.STATE_TURNING_ON)' is now called before 'transitionTo(mWarmUp)'.","This change does not cause a compatibility issue since it does not affect the return value of the method, nor does it affect the exception handling. The sequence of operations within a case statement doesn't impact the overall return value of the method. Hence, no Compatibility Issue (CI) exists for this API."
31,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,14,15,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,0,"{
    enforceSealed();
    final int childAccessibilityViewId = mChildAccessibilityIds.get(index);
    if (!canPerformRequestOverConnection(childAccessibilityViewId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnection, mAccessibilityWindowId, childAccessibilityViewId);
}","{
    enforceSealed();
    final int childAccessibilityViewId = mChildAccessibilityIds.get(index);
    if (!canPerformRequestOverConnection(childAccessibilityViewId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mAccessibilityWindowId, childAccessibilityViewId);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The only change lies in the last return statement, where the method findAccessibilityNodeInfoByAccessibilityId() is called with a different argument, changing from 'mConnection' to 'mConnectionId'. Therefore, the code change falls into category 4 (other statement changed) and category 5 (dependent API changed).","The change in the findAccessibilityNodeInfoByAccessibilityId() method's argument may cause the method to return a different value. Hence, the compatibility issue type is as follows: 1 (Compatibility Issue caused by potential different return values or types)."
32,"<android.server.BluetoothService: int addRfcommServiceRecord(String,ParcelUuid,int,IBinder)>",14,15,"<android.server.BluetoothService: int addRfcommServiceRecord(String,ParcelUuid,int,IBinder)>","<android.server.BluetoothService: int addRfcommServiceRecord(String,ParcelUuid,int,IBinder)>",0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return -1;
    if (serviceName == null || uuid == null || channel < 1 || channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
        return -1;
    }
    if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
        Log.w(TAG, ""Attempted to register a reserved UUID: "" + uuid);
        return -1;
    }
    int handle = addRfcommServiceRecordNative(serviceName, uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(), (short) channel);
    if (DBG)
        Log.d(TAG, ""new handle "" + Integer.toHexString(handle));
    if (handle == -1) {
        return -1;
    }
    int pid = Binder.getCallingPid();
    mServiceRecordToPid.put(new Integer(handle), new Pair<Integer, IBinder>(pid, b));
    try {
        b.linkToDeath(new Reaper(handle, pid, RFCOMM_RECORD_REAPER), 0);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return handle;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return -1;
    if (serviceName == null || uuid == null || channel < 1 || channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
        return -1;
    }
    if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
        Log.w(TAG, ""Attempted to register a reserved UUID: "" + uuid);
        return -1;
    }
    int handle = addRfcommServiceRecordNative(serviceName, uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(), (short) channel);
    if (DBG)
        Log.d(TAG, ""new handle "" + Integer.toHexString(handle));
    if (handle == -1) {
        return -1;
    }
    ServiceRecordClient client = new ServiceRecordClient();
    client.pid = Binder.getCallingPid();
    client.binder = b;
    client.death = new Reaper(handle, client.pid, RFCOMM_RECORD_REAPER);
    mServiceRecordToPid.put(new Integer(handle), client);
    try {
        b.linkToDeath(client.death, 0);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        client.death = null;
    }
    return handle;
}",1,"/**
 * b is a handle to a Binder instance, so that this service can be notified
 * for Applications that terminate unexpectedly, to clean there service
 * records
 */
","/**
 * b is a handle to a Binder instance, so that this service can be notified
 * for Applications that terminate unexpectedly, to clean there service
 * records
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the early version, the code creates a Pair object with the pid and the binder, while in the late version it creates a new instance of ServiceRecordClient and uses it to store the pid, binder, and a new Reaper object. Other than this change, all other code remains the same. So the change type is 4.","Despite the changes made in the structure of the code, the return value and exception handling do not change between these two versions, meaning no compatibility issue exists. Hence, the CI type is 0."
35,<android.webkit.WebView: Rect sendOurVisibleRect()>,14,15,<android.webkit.WebView: Rect sendOurVisibleRect()>,<android.webkit.WebView: Rect sendOurVisibleRect()>,0,"{
    if (mZoomManager.isPreventingWebkitUpdates())
        return mLastVisibleRectSent;
    Rect rect = new Rect();
    calcOurContentVisibleRect(rect);
    // Rect.equals() checks for null input.
    if (!rect.equals(mLastVisibleRectSent)) {
        if (!mBlockWebkitViewMessages) {
            Point pos = new Point(rect.left, rect.top);
            mWebViewCore.removeMessages(EventHub.SET_SCROLL_OFFSET);
            mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET, nativeMoveGeneration(), mSendScrollEvent ? 1 : 0, pos);
        }
        mLastVisibleRectSent = rect;
        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
    }
    Rect globalRect = new Rect();
    if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""sendOurVisibleRect=("" + globalRect.left + "","" + globalRect.top + "",r="" + globalRect.right + "",b="" + globalRect.bottom);
        }
        // and mouse events could return view + screen relative points.
        if (!mBlockWebkitViewMessages) {
            mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS, globalRect);
        }
        mLastGlobalRect = globalRect;
    }
    return rect;
}","{
    if (mZoomManager.isPreventingWebkitUpdates())
        return mLastVisibleRectSent;
    calcOurContentVisibleRect(mVisibleRect);
    // Rect.equals() checks for null input.
    if (!mVisibleRect.equals(mLastVisibleRectSent)) {
        if (!mBlockWebkitViewMessages) {
            mScrollOffset.set(mVisibleRect.left, mVisibleRect.top);
            mWebViewCore.removeMessages(EventHub.SET_SCROLL_OFFSET);
            mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET, nativeMoveGeneration(), mSendScrollEvent ? 1 : 0, mScrollOffset);
        }
        mLastVisibleRectSent.set(mVisibleRect);
        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
    }
    if (getGlobalVisibleRect(mGlobalVisibleRect) && !mGlobalVisibleRect.equals(mLastGlobalRect)) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""sendOurVisibleRect=("" + mGlobalVisibleRect.left + "","" + mGlobalVisibleRect.top + "",r="" + mGlobalVisibleRect.right + "",b="" + mGlobalVisibleRect.bottom);
        }
        // and mouse events could return view + screen relative points.
        if (!mBlockWebkitViewMessages) {
            mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS, mGlobalVisibleRect);
        }
        mLastGlobalRect.set(mGlobalVisibleRect);
    }
    return mVisibleRect;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The code change is related to how objects (like rect, globalRect) are initialized and manipulated (object allocation changed to setting values), but neither return, exception handling, control dependency, nor dependent APIs are changed, thus the code change type is 4.","However, the manipulation of these objects does influence the return value of this method, which leads to potential different behaviours and thus the CI type is 1."
36,<android.widget.NumberPicker: void setDisplayedValues(String[])>,14,15,<android.widget.NumberPicker: void setDisplayedValues(String[])>,<android.widget.NumberPicker: void setDisplayedValues(String[])>,0,"{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    initializeSelectorWheelIndices();
}","{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    initializeSelectorWheelIndices();
    tryComputeMaxWidth();
}",1,"/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 */
","/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new function call ""tryComputeMaxWidth();"" has been added to the latest version of the code. Therefore, the change type is 4.","The added function call ""tryComputeMaxWidth();"" does not affect the return value or exception handling of the function. Hence, no compatibility issue (CI) is detected, and the CI type is 0."
40,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,14,15,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (hasSelectionController()) {
        getSelectionController().onTouchEvent(event);
    }
    if (action == MotionEvent.ACTION_DOWN) {
        mLastDownPositionX = event.getX();
        mLastDownPositionY = event.getY();
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mIgnoreActionUpEvent = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mDiscardNextActionUp = false;
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && !shouldIgnoreActionUpEvent() && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && mTextIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length != 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || mTextIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!mTextIsSelectable) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            boolean selectAllGotFocus = mSelectAllOnFocus && didTouchFocusSelect();
            hideControllers();
            if (!selectAllGotFocus && mText.length() > 0) {
                if (mSpellChecker != null) {
                    // When the cursor moves, the word that was typed may need spell check
                    mSpellChecker.onSelectionChanged();
                }
                if (isCursorInsideEasyCorrectionSpan()) {
                    showSuggestions();
                } else if (hasInsertionController()) {
                    getInsertionController().show();
                }
            }
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (hasSelectionController()) {
        getSelectionController().onTouchEvent(event);
    }
    if (action == MotionEvent.ACTION_DOWN) {
        mLastDownPositionX = event.getX();
        mLastDownPositionY = event.getY();
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mIgnoreActionUpEvent = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mDiscardNextActionUp = false;
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && !shouldIgnoreActionUpEvent() && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && mTextIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length != 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || mTextIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!mTextIsSelectable && mSoftInputShownOnFocus) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            boolean selectAllGotFocus = mSelectAllOnFocus && didTouchFocusSelect();
            hideControllers();
            if (!selectAllGotFocus && mText.length() > 0) {
                if (mSpellChecker != null) {
                    // When the cursor moves, the word that was typed may need spell check
                    mSpellChecker.onSelectionChanged();
                }
                if (!extractedTextModeWillBeStarted()) {
                    if (isCursorInsideEasyCorrectionSpan()) {
                        showSuggestions();
                    } else if (hasInsertionController()) {
                        getInsertionController().show();
                    }
                }
            }
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The 'if' condition check for '!mTextIsSelectable' has added a new requirement 'mSoftInputShownOnFocus' and a new 'if' condition '!extractedTextModeWillBeStarted()' has been introduced, so the code change type is 3.","The added condition checks only modify the internal process and does not change the return value or exception handling of this method, therefore, no compatibility issues arise."
46,"<android.webkit.WebView: void onOverScrolled(int,int,boolean,boolean)>",14,15,"<android.webkit.WebView: void onOverScrolled(int,int,boolean,boolean)>","<android.webkit.WebView: void onOverScrolled(int,int,boolean,boolean)>",0,"{
    // updating.
    if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
        nativeScrollLayer(mScrollingLayer, scrollX, scrollY);
        mScrollingLayerRect.left = scrollX;
        mScrollingLayerRect.top = scrollY;
        invalidate();
        return;
    }
    mInOverScrollMode = false;
    int maxX = computeMaxScrollX();
    int maxY = computeMaxScrollY();
    if (maxX == 0) {
        // do not over scroll x if the page just fits the screen
        scrollX = pinLocX(scrollX);
    } else if (scrollX < 0 || scrollX > maxX) {
        mInOverScrollMode = true;
    }
    if (scrollY < 0 || scrollY > maxY) {
        mInOverScrollMode = true;
    }
    int oldX = mScrollX;
    int oldY = mScrollY;
    super.scrollTo(scrollX, scrollY);
    if (mOverScrollGlow != null) {
        mOverScrollGlow.pullGlow(mScrollX, mScrollY, oldX, oldY, maxX, maxY);
    }
}","{
    // updating.
    if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
        scrollLayerTo(scrollX, scrollY);
        return;
    }
    mInOverScrollMode = false;
    int maxX = computeMaxScrollX();
    int maxY = computeMaxScrollY();
    if (maxX == 0) {
        // do not over scroll x if the page just fits the screen
        scrollX = pinLocX(scrollX);
    } else if (scrollX < 0 || scrollX > maxX) {
        mInOverScrollMode = true;
    }
    if (scrollY < 0 || scrollY > maxY) {
        mInOverScrollMode = true;
    }
    int oldX = mScrollX;
    int oldY = mScrollY;
    super.scrollTo(scrollX, scrollY);
    if (mOverScrollGlow != null) {
        mOverScrollGlow.pullGlow(mScrollX, mScrollY, oldX, oldY, maxX, maxY);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the API has changed. Specifically, within the condition block (mTouchMode == TOUCH_DRAG_LAYER_MODE), the original method called (nativeScrollLayer()) has been replaced by a new one (scrollLayerTo()), and the assignment to mScrollingLayerRect left and top and call to invalidate() are removed. These changes are captured by the categories 'Other statement changed' and 'Dependent API changed', leading to the code change classification 4,5.","The change in the dependent API and the removal of a statement could potentially affect the returned result of the method, leading to a different behaviour. Hence, there is a 'Compatibility Issue caused by potential different return values or types', resulting in the CI classification 1."
47,<android.view.View: boolean destroyLayer()>,14,15,<android.view.View: boolean destroyLayer()>,<android.view.View: boolean destroyLayer()>,0,"{
    if (mHardwareLayer != null) {
        mHardwareLayer.destroy();
        mHardwareLayer = null;
        return true;
    }
    return false;
}","{
    if (mHardwareLayer != null) {
        mHardwareLayer.destroy();
        mHardwareLayer = null;
        invalidate(true);
        invalidateParentCaches();
        return true;
    }
    return false;
}",1,"/**
 * Destroys this View's hardware layer if possible.
 *
 * @return True if the layer was destroyed, false otherwise.
 *
 * @see #setLayerType(int, android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
","/**
 * Destroys this View's hardware layer if possible.
 *
 * @return True if the layer was destroyed, false otherwise.
 *
 * @see #setLayerType(int, android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two new function invocations (invalidate(true) and invalidateParentCaches()) were introduced in late implementation, this type of change is regarded as ""other statement changed"".","Even though there are new statements introduced in the method, they are not affecting how the method behaves in terms of return statement or exception handling. Hence, no compatibility issue is detected."
49,"<android.app.LoaderManagerImpl.LoaderInfo: void onLoadComplete(Loader<Object>,Object)>",14,15,"<android.app.LoaderManagerImpl.LoaderInfo: void onLoadComplete(Loader<Object>,Object)>","<android.app.LoaderManagerImpl.LoaderInfo: void onLoadComplete(Loader<Object>,Object)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""onLoadComplete: "" + this);
    if (mDestroyed) {
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- destroyed"");
        return;
    }
    if (mLoaders.get(mId) != this) {
        // We don't care about it.
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- not active"");
        return;
    }
    LoaderInfo pending = mPendingLoader;
    if (pending != null) {
        // it.  So now it is time, switch over to the new loader.
        if (DEBUG)
            Log.v(TAG, ""  Switching to pending loader: "" + pending);
        mPendingLoader = null;
        mLoaders.put(mId, null);
        destroy();
        installLoader(pending);
        return;
    }
    // we try to destroy it.
    if (mData != data || !mHaveData) {
        mData = data;
        mHaveData = true;
        if (mStarted) {
            callOnLoadFinished(loader, data);
        }
    }
    // if (DEBUG) Log.v(TAG, ""  onLoadFinished returned: "" + this);
    // We have now given the application the new loader with its
    // loaded data, so it should have stopped using the previous
    // loader.  If there is a previous loader on the inactive list,
    // clean it up.
    LoaderInfo info = mInactiveLoaders.get(mId);
    if (info != null && info != this) {
        info.mDeliveredData = false;
        info.destroy();
        mInactiveLoaders.remove(mId);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""onLoadComplete: "" + this);
    if (mDestroyed) {
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- destroyed"");
        return;
    }
    if (mLoaders.get(mId) != this) {
        // We don't care about it.
        if (DEBUG)
            Log.v(TAG, ""  Ignoring load complete -- not active"");
        return;
    }
    LoaderInfo pending = mPendingLoader;
    if (pending != null) {
        // it.  So now it is time, switch over to the new loader.
        if (DEBUG)
            Log.v(TAG, ""  Switching to pending loader: "" + pending);
        mPendingLoader = null;
        mLoaders.put(mId, null);
        destroy();
        installLoader(pending);
        return;
    }
    // we try to destroy it.
    if (mData != data || !mHaveData) {
        mData = data;
        mHaveData = true;
        if (mStarted) {
            callOnLoadFinished(loader, data);
        }
    }
    // if (DEBUG) Log.v(TAG, ""  onLoadFinished returned: "" + this);
    // We have now given the application the new loader with its
    // loaded data, so it should have stopped using the previous
    // loader.  If there is a previous loader on the inactive list,
    // clean it up.
    LoaderInfo info = mInactiveLoaders.get(mId);
    if (info != null && info != this) {
        info.mDeliveredData = false;
        info.destroy();
        mInactiveLoaders.remove(mId);
    }
    if (mActivity != null && !hasRunningLoaders()) {
        mActivity.mFragments.startPendingDeferredFragments();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late version, a new snippet of code, which checks if mActivity is not null and if there are no running loaders, and then starts pending deferred fragments of mActivity's fragments, has been introduced. This corresponds to the change type 4  Other statement changed.","Despite the change in the implementation, this change does not affect the return or exception behavior of the API, hence, there is no compatibility issue  the type is 0."
51,<android.accessibilityservice.AccessibilityService.IEventListenerWrapper: void executeMessage(Message)>,14,15,<android.accessibilityservice.AccessibilityService.IEventListenerWrapper: void executeMessage(Message)>,<android.accessibilityservice.AccessibilityService.IEventListenerWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ON_ACCESSIBILITY_EVENT:
            AccessibilityEvent event = (AccessibilityEvent) message.obj;
            if (event != null) {
                mTarget.onAccessibilityEvent(event);
                event.recycle();
            }
            return;
        case DO_ON_INTERRUPT:
            mTarget.onInterrupt();
            return;
        case DO_SET_SET_CONNECTION:
            mConnection = ((IAccessibilityServiceConnection) message.obj);
            mTarget.onServiceConnected();
            return;
        default:
            Log.w(LOG_TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ON_ACCESSIBILITY_EVENT:
            AccessibilityEvent event = (AccessibilityEvent) message.obj;
            if (event != null) {
                mTarget.onAccessibilityEvent(event);
                event.recycle();
            }
            return;
        case DO_ON_INTERRUPT:
            mTarget.onInterrupt();
            return;
        case DO_SET_SET_CONNECTION:
            final int connectionId = message.arg1;
            IAccessibilityServiceConnection connection = (IAccessibilityServiceConnection) message.obj;
            if (connection != null) {
                AccessibilityInteractionClient.getInstance().addConnection(connectionId, connection);
                mConnectionId = connectionId;
                mTarget.onServiceConnected();
            } else {
                AccessibilityInteractionClient.getInstance().removeConnection(connectionId);
                mConnectionId = AccessibilityInteractionClient.NO_ID;
            // TODO: Do we need a onServiceDisconnected callback?
            }
            return;
        default:
            Log.w(LOG_TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"In the third case of the switch statement, a new int type variable 'connectionId' is added, and the control statements under it are changed significantly (new if-else control dependency is introduced and the statement under it also changed a lot). So, the code change type is 1,3,4.","Despite the changes in the method's behavior, no compatibility issues arise because the changes don't alter the return value or exception handling of the method. The changes only affect the internal logic of the method but have no influence over the behavior observed by the client. Thus, the CI type is 0."
57,"<android.view.View: void setLayerType(int,Paint)>",14,15,"<android.view.View: void setLayerType(int,Paint)>","<android.view.View: void setLayerType(int,Paint)>",0,"{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    if (layerType == mLayerType) {
        if (layerType != LAYER_TYPE_NONE && paint != mLayerPaint) {
            mLayerPaint = paint == null ? new Paint() : paint;
            invalidateParentCaches();
            invalidate(true);
        }
        return;
    }
    // Destroy any previous software drawing cache if needed
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            destroyLayer();
        // fall through - unaccelerated views may use software layer mechanism instead
        case LAYER_TYPE_SOFTWARE:
            destroyDrawingCache();
            break;
        default:
            break;
    }
    mLayerType = layerType;
    final boolean layerDisabled = mLayerType == LAYER_TYPE_NONE;
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mLocalDirtyRect = layerDisabled ? null : new Rect();
    invalidateParentCaches();
    invalidate(true);
}","{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    if (layerType == mLayerType) {
        if (layerType != LAYER_TYPE_NONE && paint != mLayerPaint) {
            mLayerPaint = paint == null ? new Paint() : paint;
            invalidateParentCaches();
            invalidate(true);
        }
        return;
    }
    // Destroy any previous software drawing cache if needed
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            destroyLayer();
        // fall through - non-accelerated views may use software layer mechanism instead
        case LAYER_TYPE_SOFTWARE:
            destroyDrawingCache();
            break;
        default:
            break;
    }
    mLayerType = layerType;
    final boolean layerDisabled = mLayerType == LAYER_TYPE_NONE;
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mLocalDirtyRect = layerDisabled ? null : new Rect();
    invalidateParentCaches();
    invalidate(true);
}",1,"/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE disabled}, {@link #LAYER_TYPE_SOFTWARE software} or
 * {@link #LAYER_TYPE_HARDWARE hardware}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
 * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
 * equivalent to setting a hardware layer on this view and providing a paint with
 * the desired alpha value.<p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE disabled},
 * {@link #LAYER_TYPE_SOFTWARE software} and {@link #LAYER_TYPE_HARDWARE hardware}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The ype of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
","/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE disabled}, {@link #LAYER_TYPE_SOFTWARE software} or
 * {@link #LAYER_TYPE_HARDWARE hardware}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
 * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
 * equivalent to setting a hardware layer on this view and providing a paint with
 * the desired alpha value.<p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE disabled},
 * {@link #LAYER_TYPE_SOFTWARE software} and {@link #LAYER_TYPE_HARDWARE hardware}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The ype of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,No implementation change between the Early_Implementation and Late_Implementation other than a comment change.,"The code changes from version to version does not result in a change of the potential behaviour of the API. Thus, there are no Compatibility Issues."
58,<android.inputmethodservice.KeyboardView: boolean onHoverEvent(MotionEvent)>,14,15,<android.inputmethodservice.KeyboardView: boolean onHoverEvent(MotionEvent)>,<android.inputmethodservice.KeyboardView: boolean onHoverEvent(MotionEvent)>,0,"{
    // location generates hover and touch events.
    if (mAccessibilityManager.isTouchExplorationEnabled() && event.getPointerCount() == 1) {
        final int action = event.getAction();
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                event.setAction(MotionEvent.ACTION_DOWN);
                break;
            case MotionEvent.ACTION_HOVER_MOVE:
                event.setAction(MotionEvent.ACTION_MOVE);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                event.setAction(MotionEvent.ACTION_UP);
                break;
        }
        onTouchEventInternal(event);
        event.setAction(action);
    }
    return super.onHoverEvent(event);
}","{
    if (mAccessibilityManager.isTouchExplorationEnabled() && event.getPointerCount() == 1) {
        final int action = event.getAction();
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
            case MotionEvent.ACTION_HOVER_MOVE:
                final int touchX = (int) event.getX() - mPaddingLeft;
                int touchY = (int) event.getY() - mPaddingTop;
                if (touchY >= -mVerticalCorrection) {
                    touchY += mVerticalCorrection;
                }
                final int keyIndex = getKeyIndices(touchX, touchY, null);
                showPreview(keyIndex);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                showPreview(NOT_A_KEY);
                break;
        }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return value changes from `super.onHoverEvent` to `true`. In the 'switch' control statement, the 'case: ACTION_HOVER_ENTER' and 'case: ACTION_HOVER_MOVE' have been changed to incorporate additional computations and method invocations. The onTouchEventInternal(event) method call is removed. Therefore, the code change types are 1,3,4.","The change of the return statement along with the new computations and method invocations introduced and removal of onTouchEventInternal can potentially result in different return values, hence the CI type is 1."
60,<android.webkit.ZoomManager: float getDefaultScale()>,14,15,<android.webkit.ZoomManager: float getDefaultScale()>,<android.webkit.ZoomManager: float getDefaultScale()>,0,"{
    return mInitialScale > 0 ? mInitialScale : mDefaultScale;
}","{
    return mDefaultScale;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement in the method implementation has been changed, the conditional return in the early version has been replaced with a simple return statement in the late version, so the code change type is 1 (Return statement changed). ","This change could affect the return value of the function. In the early version, the function could return either mInitialScale or mDefaultScale based on a condition. In the late version, it only returns mDefaultScale. This change could lead to potential different return values, so the CI type is 1 (Compatibility Issue caused by potential different return values)."
64,<android.webkit.ZoomManager: float getReadingLevelScale()>,14,15,<android.webkit.ZoomManager: float getReadingLevelScale()>,<android.webkit.ZoomManager: float getReadingLevelScale()>,0,"{
    WebSettings settings = mWebView.getSettings();
    final float doubleTapZoomFactor = settings != null ? settings.getDoubleTapZoom() / 100.f : 1.0f;
    return mDisplayDensity * doubleTapZoomFactor;
}","{
    return mDisplayDensity * mDoubleTapZoomFactor;
}",1,"/**
 * Returns the zoom scale used for reading text on a double-tap.
 */
","/**
 * Returns the zoom scale used for reading text on a double-tap.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The early version used to get a local 'doubleTapZoomFactor' from a dependent API, and then multiplied it with 'mDisplayDensity', while the late version directly used a member variable 'mDoubleTapZoomFactor' and multiplied it with 'mDisplayDensity'. This is a change in other statements and a change in the dependent APIs.","Even though the logic of the method is similar, the change of the way to get 'doubleTapZoomFactor' and the change of the dependent API 'settings.getDoubleTapZoom()' can potentially lead to a different return value. Hence the Compatibility Issue here is caued by the potential different return values or types."
65,"<android.database.AbstractCursor: void fillWindow(int,CursorWindow)>",14,15,"<android.database.AbstractCursor: void fillWindow(int,CursorWindow)>","<android.database.AbstractCursor: void fillWindow(int,CursorWindow)>",0,"{
    if (position < 0 || position >= getCount()) {
        return;
    }
    window.acquireReference();
    try {
        int oldpos = mPos;
        mPos = position - 1;
        window.clear();
        window.setStartPosition(position);
        int columnNum = getColumnCount();
        window.setNumColumns(columnNum);
        while (moveToNext() && window.allocRow()) {
            for (int i = 0; i < columnNum; i++) {
                String field = getString(i);
                if (field != null) {
                    if (!window.putString(field, mPos, i)) {
                        window.freeLastRow();
                        break;
                    }
                } else {
                    if (!window.putNull(mPos, i)) {
                        window.freeLastRow();
                        break;
                    }
                }
            }
        }
        mPos = oldpos;
    } catch (IllegalStateException e) {
    // simply ignore it
    } finally {
        window.releaseReference();
    }
}","{
    DatabaseUtils.cursorFillWindow(this, position, window);
}",1,"/**
 * Copy data from cursor to CursorWindow
 * @param position start position of data
 * @param window
 */
",,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","Between the early and late implementations, there are many changes. Firstly, the return statement of the API changes, shifting from returning different elements under conditional checks to always returning the same implementation 'DatabaseUtils.cursorFillWindow(this, position, window);'. There are also numerous statements that are deleted in the late version, including if statements and variable assignments. This is classified as Other statement changes (4). Lastly, there is also a change in the dependent API, as the late version relies on the 'DatabaseUtils.cursorFillWindow()' which is different from the early version. Therefore, the code changes can be grouped under the types 1,4,5.","The modification of the return statements could lead to different return values when the same inputs are supplied, which identifies a compatibility issue of type 1. Additionally, in the early version of the API, when the API may throw an 'IllegalStateException' it is simply ignored. In the late version, as the control has been completely moved to 'DatabaseUtils.cursorFillWindow()', it's unclear how the exception is handled. Due to the uncertainty and difference in exception handling, there is a compatibility issue which belongs to type 2."
66,<android.widget.TextView: void onEditorAction(int)>,14,15,<android.widget.TextView: void onEditorAction(int)>,<android.widget.TextView: void onEditorAction(int)>,0,"{
    final InputContentType ict = mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_FORWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_FORWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_BACKWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_BACKWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            clearFocus();
            return;
        }
    }
    Handler h = getHandler();
    if (h != null) {
        long eventTime = SystemClock.uptimeMillis();
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
    }
}","{
    final InputContentType ict = mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_FORWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_FORWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_BACKWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_BACKWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            return;
        }
    }
    Handler h = getHandler();
    if (h != null) {
        long eventTime = SystemClock.uptimeMillis();
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
    }
}",1,"/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
","/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code changes between the two versions of the API.,"Since no changes were made in the second version of the API, no compatibility issue exists."
67,"<android.webkit.WebView: void setNewPicture(DrawData,boolean)>",14,15,"<android.webkit.WebView: void setNewPicture(DrawData,boolean)>","<android.webkit.WebView: void setNewPicture(DrawData,boolean)>",0,"{
    if (mNativeClass == 0) {
        if (mDelaySetPicture != null) {
            throw new IllegalStateException(""Tried to setNewPicture with"" + "" a delay picture already set! (memory leak)"");
        }
        // Not initialized yet, delay set
        mDelaySetPicture = draw;
        return;
    }
    WebViewCore.ViewState viewState = draw.mViewState;
    boolean isPictureAfterFirstLayout = viewState != null;
    if (updateBaseLayer) {
        // Request a callback on pageSwap (to reposition the webtextview)
        boolean registerPageSwapCallback = !mZoomManager.isFixedLengthAnimationInProgress() && inEditingMode();
        setBaseLayer(draw.mBaseLayer, draw.mInvalRegion, getSettings().getShowVisualIndicator(), isPictureAfterFirstLayout, registerPageSwapCallback);
    }
    final Point viewSize = draw.mViewSize;
    if (isPictureAfterFirstLayout) {
        // Reset the last sent data here since dealing with new page.
        mLastWidthSent = 0;
        mZoomManager.onFirstLayout(draw);
        if (!mDrawHistory) {
            // Do not send the scroll event for this particular
            // scroll message.  Note that a scroll event may
            // still be fired if the user scrolls before the
            // message can be handled.
            mSendScrollEvent = false;
            setContentScrollTo(viewState.mScrollX, viewState.mScrollY);
            mSendScrollEvent = true;
            // As we are on a new page, remove the WebTextView. This
            // is necessary for page loads driven by webkit, and in
            // particular when the user was on a password field, so
            // the WebTextView was visible.
            clearTextEntry();
        }
    }
    // We update the layout (i.e. request a layout from the
    // view system) if the last view size that we sent to
    // WebCore matches the view size of the picture we just
    // received in the fixed dimension.
    final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
    // Don't send scroll event for picture coming from webkit,
    // since the new picture may cause a scroll event to override
    // the saved history scroll position.
    mSendScrollEvent = false;
    recordNewContentSize(draw.mContentSize.x, draw.mContentSize.y, updateLayout);
    mSendScrollEvent = true;
    if (DebugFlags.WEB_VIEW) {
        Rect b = draw.mInvalRegion.getBounds();
        Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
    }
    invalidateContentRect(draw.mInvalRegion.getBounds());
    if (mPictureListener != null) {
        mPictureListener.onNewPicture(WebView.this, capturePicture());
    }
    // update the zoom information based on the new picture
    mZoomManager.onNewPicture(draw);
    if (draw.mFocusSizeChanged && inEditingMode()) {
        mFocusSizeChanged = true;
    }
    if (isPictureAfterFirstLayout) {
        mViewManager.postReadyToDrawAll();
    }
}","{
    if (mNativeClass == 0) {
        if (mDelaySetPicture != null) {
            throw new IllegalStateException(""Tried to setNewPicture with"" + "" a delay picture already set! (memory leak)"");
        }
        // Not initialized yet, delay set
        mDelaySetPicture = draw;
        return;
    }
    WebViewCore.ViewState viewState = draw.mViewState;
    boolean isPictureAfterFirstLayout = viewState != null;
    if (updateBaseLayer) {
        // Request a callback on pageSwap (to reposition the webtextview)
        boolean registerPageSwapCallback = !mZoomManager.isFixedLengthAnimationInProgress() && inEditingMode();
        setBaseLayer(draw.mBaseLayer, draw.mInvalRegion, getSettings().getShowVisualIndicator(), isPictureAfterFirstLayout, registerPageSwapCallback);
    }
    final Point viewSize = draw.mViewSize;
    // We update the layout (i.e. request a layout from the
    // view system) if the last view size that we sent to
    // WebCore matches the view size of the picture we just
    // received in the fixed dimension.
    final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
    // Don't send scroll event for picture coming from webkit,
    // since the new picture may cause a scroll event to override
    // the saved history scroll position.
    mSendScrollEvent = false;
    recordNewContentSize(draw.mContentSize.x, draw.mContentSize.y, updateLayout);
    if (isPictureAfterFirstLayout) {
        // Reset the last sent data here since dealing with new page.
        mLastWidthSent = 0;
        mZoomManager.onFirstLayout(draw);
        int scrollX = viewState.mShouldStartScrolledRight ? getContentWidth() : viewState.mScrollX;
        int scrollY = viewState.mScrollY;
        setContentScrollTo(scrollX, scrollY);
        if (!mDrawHistory) {
            // As we are on a new page, remove the WebTextView. This
            // is necessary for page loads driven by webkit, and in
            // particular when the user was on a password field, so
            // the WebTextView was visible.
            clearTextEntry();
        }
    }
    mSendScrollEvent = true;
    if (DebugFlags.WEB_VIEW) {
        Rect b = draw.mInvalRegion.getBounds();
        Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
    }
    invalidateContentRect(draw.mInvalRegion.getBounds());
    if (mPictureListener != null) {
        mPictureListener.onNewPicture(WebView.this, capturePicture());
    }
    // update the zoom information based on the new picture
    mZoomManager.onNewPicture(draw);
    if (draw.mFocusSizeChanged && inEditingMode()) {
        mFocusSizeChanged = true;
    }
    if (isPictureAfterFirstLayout) {
        mViewManager.postReadyToDrawAll();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control statements have been modified, specifically the condition 'if (isPictureAfterFirstLayout)' and a new variable scrollX has been introduced in the late version, thus the code change class is 3,4.","The changes impact how scrollX and scrollY are calculated, and these variables are involved in the method setContentScrollTo(scrollX,scrollY). Thus the behaviour of the method setNewPicture and what it returns may be different. Therefore, the CI type is 1."
69,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",14,15,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>","<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",0,"{
    verifyDbIsOpen();
    BlockGuard.getThreadPolicy().onReadFromDisk();
    long timeStart = 0;
    if (false || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteDatabase db = getDbConnection(sql);
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(db, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (false || mSlowQueryThreshold != -1) {
            // Force query execution
            int count = -1;
            if (cursor != null) {
                count = cursor.getCount();
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (false || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>"") + "", count is "" + count);
            }
        }
        releaseDbConnection(db);
    }
    return cursor;
}","{
    verifyDbIsOpen();
    BlockGuard.getThreadPolicy().onReadFromDisk();
    SQLiteDatabase db = getDbConnection(sql);
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(db, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        releaseDbConnection(db);
    }
    return cursor;
}",1,"/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
","/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed in terms of the removed if condition for checking mSlowQueryThreshold and tracking query execution time. However, this is not categorized as a control dependency change since the control structure (if, while, for etc.) of the code did not change, rather it was removed completely. Therefore, the change type is 4 which is ""Other statement changed"".","The removal of the tracking of query execution time and logging it, does not affect the function's overall behaviour. This change will not cause a compatibility issue between the two versions as the return type and exception handling did not change. Therefore, no compatibility issue (CI) exists."
70,<android.inputmethodservice.KeyboardView: boolean onTouchEvent(MotionEvent)>,14,15,<android.inputmethodservice.KeyboardView: boolean onTouchEvent(MotionEvent)>,<android.inputmethodservice.KeyboardView: boolean onTouchEvent(MotionEvent)>,0,"{
    // location generates hover and touch events.
    if (mAccessibilityManager.isTouchExplorationEnabled()) {
        return true;
    }
    return onTouchEventInternal(event);
}","{
    // Convert multi-pointer up/down events to single up/down events to
    // deal with the typical multi-pointer behavior of two-thumb typing
    final int pointerCount = me.getPointerCount();
    final int action = me.getAction();
    boolean result = false;
    final long now = me.getEventTime();
    if (pointerCount != mOldPointerCount) {
        if (pointerCount == 1) {
            // Send a down event for the latest pointer
            MotionEvent down = MotionEvent.obtain(now, now, MotionEvent.ACTION_DOWN, me.getX(), me.getY(), me.getMetaState());
            result = onModifiedTouchEvent(down, false);
            down.recycle();
            // If it's an up action, then deliver the up as well.
            if (action == MotionEvent.ACTION_UP) {
                result = onModifiedTouchEvent(me, true);
            }
        } else {
            // Send an up event for the last pointer
            MotionEvent up = MotionEvent.obtain(now, now, MotionEvent.ACTION_UP, mOldPointerX, mOldPointerY, me.getMetaState());
            result = onModifiedTouchEvent(up, true);
            up.recycle();
        }
    } else {
        if (pointerCount == 1) {
            result = onModifiedTouchEvent(me, false);
            mOldPointerX = me.getX();
            mOldPointerY = me.getY();
        } else {
            // Don't do anything when 2 pointers are down and moving.
            result = true;
        }
    }
    mOldPointerCount = pointerCount;
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statement has been changed from return onTouchEventInternal(event) to a new logic that processes multi-pointer touch events. This involves changes in both control statements, and other additional statements too. So the change type is 1,3,4.",The behavioural change in touch event handling and its potential different return value make this change a type 1 CI.
71,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",14,15,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + ""keyCode="" + keyCode + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // don't implement accelerator keys here; defer to host application
    if (event.isCtrlPressed()) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // to act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
        if (event.hasNoModifiers()) {
            pageUp(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageUp(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
        if (event.hasNoModifiers()) {
            pageDown(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageDown(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
        pageUp(true);
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
        pageDown(true);
        return true;
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), true, event.getMetaState());
            return true;
        }
        if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_UP:
                    pageUp(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_DOWN:
                    pageDown(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(0, mScrollY, true, 0);
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(mContentWidth, mScrollY, true, 0);
            }
        }
        if (mSelectingText) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        boolean wantsKeyEvents = nativeCursorNodePointer() == 0 || nativeCursorWantsKeyEvents();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            recordButtons(null, hasFocus() && hasWindowFocus(), true, true);
            if (!wantsKeyEvents)
                return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        if (!wantsKeyEvents)
            return false;
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus.
        mWebViewCore.sendMessage(EventHub.FAKE_CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + ""keyCode="" + keyCode + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // don't implement accelerator keys here; defer to host application
    if (event.isCtrlPressed()) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // to act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
        if (event.hasNoModifiers()) {
            pageUp(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageUp(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
        if (event.hasNoModifiers()) {
            pageDown(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageDown(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
        pageUp(true);
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
        pageDown(true);
        return true;
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), true, event.getMetaState());
            return true;
        }
        if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_UP:
                    pageUp(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_DOWN:
                    pageDown(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(0, mScrollY, true, 0);
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(mContentWidth, mScrollY, true, 0);
            }
        }
        if (mSelectingText) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        boolean wantsKeyEvents = nativeCursorNodePointer() == 0 || nativeCursorWantsKeyEvents();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            if (!wantsKeyEvents)
                return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        if (!wantsKeyEvents)
            return false;
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus.
        mWebViewCore.sendMessage(EventHub.FAKE_CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
72,<android.view.textservice.SpellCheckerSession: void close()>,14,15,<android.view.textservice.SpellCheckerSession: void close()>,<android.view.textservice.SpellCheckerSession: void close()>,0,"{
    mIsUsed = false;
    try {
        mTextServicesManager.finishSpellCheckerService(mSpellCheckerSessionListenerImpl);
    } catch (RemoteException e) {
    // do nothing
    }
}","{
    mIsUsed = false;
    try {
        mSpellCheckerSessionListenerImpl.close();
        mTextServicesManager.finishSpellCheckerService(mSpellCheckerSessionListenerImpl);
    } catch (RemoteException e) {
    // do nothing
    }
}",1,"/**
 * Finish this session and allow TextServicesManagerService to disconnect the bound spell
 * checker.
 */
","/**
 * Finish this session and allow TextServicesManagerService to disconnect the bound spell
 * checker.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, a new statement mSpellCheckerSessionListenerImpl.close() has been added which is not a return statement, exception statement or control dependency statement, so the change type is 4.","Even though a new statement is added in the late version, this change doesn't affect the API behavior in terms of return type/value or exception handling. Therefore, there is no compatibility issue in this case, so the CI type is 0."
73,<android.app.ApplicationPackageManager: Drawable getActivityIcon(Intent)>,14,15,<android.app.ApplicationPackageManager: Drawable getActivityIcon(Intent)>,<android.app.ApplicationPackageManager: Drawable getActivityIcon(Intent)>,0,"{
    if (intent.getComponent() != null) {
        return getActivityIcon(intent.getComponent());
    }
    ResolveInfo info = resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null) {
        return info.activityInfo.loadIcon(this);
    }
    throw new NameNotFoundException(intent.toURI());
}","{
    if (intent.getComponent() != null) {
        return getActivityIcon(intent.getComponent());
    }
    ResolveInfo info = resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null) {
        return info.activityInfo.loadIcon(this);
    }
    throw new NameNotFoundException(intent.toUri(0));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The input parameter for the 'toUri' method in the 'throw' statement has changed from 'toURI()' to 'toUri(0)', therefore, the change type is 4.","Due to the change of input parameter in the 'toUri' method, the 'throw' statement may produce a different message in the exception, so the CI type is 1."
74,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",14,15,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.add(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                InputQueue.registerInputChannel(mInputChannel, mInputHandler, Looper.myQueue());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, false, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.add(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                InputQueue.registerInputChannel(mInputChannel, mInputHandler, Looper.myQueue());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerImpl.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
75,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",14,15,"<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>","<android.speech.tts.TextToSpeechService.SynthHandler: int enqueueSpeechItem(int,SpeechItem)>",0,"{
    if (!speechItem.isValid()) {
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallingApp());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallingApp();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        return TextToSpeech.ERROR;
    }
}","{
    if (!speechItem.isValid()) {
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallingApp());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallingApp();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, ""SynthThread has quit"");
        speechItem.dispatchOnError();
        return TextToSpeech.ERROR;
    }
}",1,"/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
","/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4","1,2","In the late version, two new statements 'speechItem.dispatchOnError()' have been added inside 'if' blocks, which falls under Return statement and Other statement categories so the code change type is 1,4.","The newly added 'speechItem.dispatchOnError()' could potentially affect the return value of the function. In addition, it may also throw a different exception. So, the Compatibility Issue type is 1,2."
77,<android.content.Intent: Intent setPackage(String)>,14,15,<android.content.Intent: Intent setPackage(String)>,<android.content.Intent: Intent setPackage(String)>,0,"{
    mPackage = packageName;
    return this;
}","{
    if (packageName != null && mSelector != null) {
        throw new IllegalArgumentException(""Can't set package name when selector is already set"");
    }
    mPackage = packageName;
    return this;
}",1,"/**
 * (Usually optional) Set an explicit application package name that limits
 * the components this Intent will resolve to.  If left to the default
 * value of null, all components in all applications will considered.
 * If non-null, the Intent can only match the components in the given
 * application package.
 *
 * @param packageName The name of the application package to handle the
 * intent, or null to allow any application package.
 *
 * @return Returns the same Intent object, for chaining multiple calls
 * into a single statement.
 *
 * @see #getPackage
 * @see #resolveActivity
 */
","/**
 * (Usually optional) Set an explicit application package name that limits
 * the components this Intent will resolve to.  If left to the default
 * value of null, all components in all applications will considered.
 * If non-null, the Intent can only match the components in the given
 * application package.
 *
 * @param packageName The name of the application package to handle the
 * intent, or null to allow any application package.
 *
 * @return Returns the same Intent object, for chaining multiple calls
 * into a single statement.
 *
 * @see #getPackage
 * @see #resolveActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","A new 'if' statement and exception handling has been added in late version, so the code change type is 2,3.","In the late version, an IllegalArgumentException might be thrown when condition satisfies. In addition, the setting of 'mPackage' can be affected by the introduced 'if' statement, so the 'return this' can be different potentially. Thus, the CI type is 1,2."
81,"<android.view.ViewGroup: boolean drawChild(Canvas,View,long)>",14,15,"<android.view.ViewGroup: boolean drawChild(Canvas,View,long)>","<android.view.ViewGroup: boolean drawChild(Canvas,View,long)>",0,"{
    boolean more = false;
    final int cl = child.mLeft;
    final int ct = child.mTop;
    final int cr = child.mRight;
    final int cb = child.mBottom;
    final boolean childHasIdentityMatrix = child.hasIdentityMatrix();
    final int flags = mGroupFlags;
    if ((flags & FLAG_CLEAR_TRANSFORMATION) == FLAG_CLEAR_TRANSFORMATION) {
        mChildTransformation.clear();
        mGroupFlags &= ~FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    Transformation invalidationTransform;
    final Animation a = child.getAnimation();
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = mDrawLayers ? child.getLayerType() : LAYER_TYPE_NONE;
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & FLAG_CHILDREN_DRAWN_WITH_CACHE) == FLAG_CHILDREN_DRAWN_WITH_CACHE || (flags & FLAG_ALWAYS_DRAWN_WITH_CACHE) == FLAG_ALWAYS_DRAWN_WITH_CACHE) {
        caching = true;
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    if (a != null) {
        final boolean initialized = a.isInitialized();
        if (!initialized) {
            a.initialize(cr - cl, cb - ct, getWidth(), getHeight());
            a.initializeInvalidateRegion(0, 0, cr - cl, cb - ct);
            child.onAnimationStart();
        }
        more = a.getTransformation(drawingTime, mChildTransformation, scalingRequired ? mAttachInfo.mApplicationScale : 1f);
        if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
            if (mInvalidationTransformation == null) {
                mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = mChildTransformation;
        }
        transformToApply = mChildTransformation;
        concatMatrix = a.willChangeTransformationMatrix();
        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) == FLAG_OPTIMIZE_INVALIDATE) {
                    mGroupFlags |= FLAG_INVALIDATE_REQUIRED;
                } else if ((flags & FLAG_INVALIDATE_REQUIRED) == 0) {
                    // The child need to draw an animation, potentially offscreen, so
                    // make sure we do not cancel invalidate requests
                    mPrivateFlags |= DRAW_ANIMATION;
                    invalidate(cl, ct, cr, cb);
                }
            } else {
                if (mInvalidateRegion == null) {
                    mInvalidateRegion = new RectF();
                }
                final RectF region = mInvalidateRegion;
                a.getInvalidateRegion(0, 0, cr - cl, cb - ct, region, invalidationTransform);
                // The child need to draw an animation, potentially offscreen, so
                // make sure we do not cancel invalidate requests
                mPrivateFlags |= DRAW_ANIMATION;
                final int left = cl + (int) region.left;
                final int top = ct + (int) region.top;
                invalidate(left, top, left + (int) (region.width() + .5f), top + (int) (region.height() + .5f));
            }
        }
    } else if ((flags & FLAG_SUPPORT_STATIC_TRANSFORMATIONS) == FLAG_SUPPORT_STATIC_TRANSFORMATIONS) {
        final boolean hasTransform = getChildStaticTransformation(child, mChildTransformation);
        if (hasTransform) {
            final int transformType = mChildTransformation.getTransformationType();
            transformToApply = transformType != Transformation.TYPE_IDENTITY ? mChildTransformation : null;
            concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    child.mPrivateFlags |= DRAWN;
    if (!concatMatrix && canvas.quickReject(cl, ct, cr, cb, Canvas.EdgeType.BW) && (child.mPrivateFlags & DRAW_ANIMATION) == 0) {
        return more;
    }
    float alpha = child.getAlpha();
    // Bail out early if the view does not need to be drawn
    if (alpha <= ViewConfiguration.ALPHA_THRESHOLD && (child.mPrivateFlags & ALPHA_SET) == 0 && !(child instanceof SurfaceView)) {
        return more;
    }
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        child.mRecreateDisplayList = (child.mPrivateFlags & INVALIDATED) == INVALIDATED;
        child.mPrivateFlags &= ~INVALIDATED;
    }
    child.computeScroll();
    final int sx = child.mScrollX;
    final int sy = child.mScrollY;
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                child.buildDrawingCache(true);
            }
            cache = child.getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    child.buildDrawingCache(true);
                    cache = child.getDrawingCache(true);
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = child.canHaveDisplayList();
                    break;
            }
        }
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    final int restoreTo = canvas.save();
    if (offsetForScroll) {
        canvas.translate(cl - sx, ct - sy);
    } else {
        canvas.translate(cl, ct);
        if (scalingRequired) {
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    if (transformToApply != null || alpha < 1.0f || !child.hasIdentityMatrix()) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    // Undo the scroll translation, apply the transformation matrix,
                    // then redo the scroll translate to get the correct result.
                    canvas.translate(-transX, -transY);
                    canvas.concat(transformToApply.getMatrix());
                    canvas.translate(transX, transY);
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1.0f) {
                    alpha *= transformToApply.getAlpha();
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix) {
                canvas.translate(-transX, -transY);
                canvas.concat(child.getMatrix());
                canvas.translate(transX, transY);
            }
        }
        if (alpha < 1.0f) {
            mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!child.onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    child.mPrivateFlags |= ALPHA_SET;
                }
            }
        }
    } else if ((child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
        child.onSetAlpha(255);
        child.mPrivateFlags &= ~ALPHA_SET;
    }
    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (cr - cl), sy + (cb - ct));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, cr - cl, cb - ct);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (hasDisplayList) {
        displayList = child.getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE) {
            final HardwareLayer layer = child.getHardwareLayer();
            if (layer != null && layer.isValid()) {
                child.mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, child.mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, child.mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((child.mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                    if (ViewDebug.TRACE_HIERARCHY) {
                        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
                    }
                    child.mPrivateFlags &= ~DIRTY_MASK;
                    child.dispatchDraw(canvas);
                } else {
                    child.draw(canvas);
                }
            } else {
                child.mPrivateFlags &= ~DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, cr - cl, cb - ct, null);
            }
        }
    } else if (cache != null) {
        child.mPrivateFlags &= ~DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = mCachePaint;
            if (alpha < 1.0f) {
                cachePaint.setAlpha((int) (alpha * 255));
                mGroupFlags |= FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & FLAG_ALPHA_LOWER_THAN_ONE) == FLAG_ALPHA_LOWER_THAN_ONE) {
                cachePaint.setAlpha(255);
                mGroupFlags &= ~FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = child.mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    canvas.restoreToCount(restoreTo);
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            child.onSetAlpha(255);
        }
        finishAnimatingView(child, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        invalidate(true);
        if (a.hasAlpha() && (child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            child.invalidate(true);
        }
    }
    child.mRecreateDisplayList = false;
    return more;
}","{
    boolean more = false;
    final int cl = child.mLeft;
    final int ct = child.mTop;
    final int cr = child.mRight;
    final int cb = child.mBottom;
    final boolean childHasIdentityMatrix = child.hasIdentityMatrix();
    final int flags = mGroupFlags;
    if ((flags & FLAG_CLEAR_TRANSFORMATION) == FLAG_CLEAR_TRANSFORMATION) {
        mChildTransformation.clear();
        mGroupFlags &= ~FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    Transformation invalidationTransform;
    final Animation a = child.getAnimation();
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = mDrawLayers ? child.getLayerType() : LAYER_TYPE_NONE;
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & FLAG_CHILDREN_DRAWN_WITH_CACHE) == FLAG_CHILDREN_DRAWN_WITH_CACHE || (flags & FLAG_ALWAYS_DRAWN_WITH_CACHE) == FLAG_ALWAYS_DRAWN_WITH_CACHE) {
        caching = true;
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    if (a != null) {
        final boolean initialized = a.isInitialized();
        if (!initialized) {
            a.initialize(cr - cl, cb - ct, getWidth(), getHeight());
            a.initializeInvalidateRegion(0, 0, cr - cl, cb - ct);
            child.onAnimationStart();
        }
        more = a.getTransformation(drawingTime, mChildTransformation, scalingRequired ? mAttachInfo.mApplicationScale : 1f);
        if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
            if (mInvalidationTransformation == null) {
                mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = mChildTransformation;
        }
        transformToApply = mChildTransformation;
        concatMatrix = a.willChangeTransformationMatrix();
        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) == FLAG_OPTIMIZE_INVALIDATE) {
                    mGroupFlags |= FLAG_INVALIDATE_REQUIRED;
                } else if ((flags & FLAG_INVALIDATE_REQUIRED) == 0) {
                    // The child need to draw an animation, potentially offscreen, so
                    // make sure we do not cancel invalidate requests
                    mPrivateFlags |= DRAW_ANIMATION;
                    invalidate(cl, ct, cr, cb);
                }
            } else {
                if (mInvalidateRegion == null) {
                    mInvalidateRegion = new RectF();
                }
                final RectF region = mInvalidateRegion;
                a.getInvalidateRegion(0, 0, cr - cl, cb - ct, region, invalidationTransform);
                // The child need to draw an animation, potentially offscreen, so
                // make sure we do not cancel invalidate requests
                mPrivateFlags |= DRAW_ANIMATION;
                final int left = cl + (int) region.left;
                final int top = ct + (int) region.top;
                invalidate(left, top, left + (int) (region.width() + .5f), top + (int) (region.height() + .5f));
            }
        }
    } else if ((flags & FLAG_SUPPORT_STATIC_TRANSFORMATIONS) == FLAG_SUPPORT_STATIC_TRANSFORMATIONS) {
        final boolean hasTransform = getChildStaticTransformation(child, mChildTransformation);
        if (hasTransform) {
            final int transformType = mChildTransformation.getTransformationType();
            transformToApply = transformType != Transformation.TYPE_IDENTITY ? mChildTransformation : null;
            concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    child.mPrivateFlags |= DRAWN;
    if (!concatMatrix && canvas.quickReject(cl, ct, cr, cb, Canvas.EdgeType.BW) && (child.mPrivateFlags & DRAW_ANIMATION) == 0) {
        return more;
    }
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        child.mRecreateDisplayList = (child.mPrivateFlags & INVALIDATED) == INVALIDATED;
        child.mPrivateFlags &= ~INVALIDATED;
    }
    child.computeScroll();
    final int sx = child.mScrollX;
    final int sy = child.mScrollY;
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                child.buildDrawingCache(true);
            }
            cache = child.getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    child.buildDrawingCache(true);
                    cache = child.getDrawingCache(true);
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = child.canHaveDisplayList();
                    break;
            }
        }
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    final int restoreTo = canvas.save();
    if (offsetForScroll) {
        canvas.translate(cl - sx, ct - sy);
    } else {
        canvas.translate(cl, ct);
        if (scalingRequired) {
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = child.getAlpha();
    if (transformToApply != null || alpha < 1.0f || !child.hasIdentityMatrix()) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    // Undo the scroll translation, apply the transformation matrix,
                    // then redo the scroll translate to get the correct result.
                    canvas.translate(-transX, -transY);
                    canvas.concat(transformToApply.getMatrix());
                    canvas.translate(transX, transY);
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1.0f) {
                    alpha *= transformToApply.getAlpha();
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix) {
                canvas.translate(-transX, -transY);
                canvas.concat(child.getMatrix());
                canvas.translate(transX, transY);
            }
        }
        if (alpha < 1.0f) {
            mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!child.onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    child.mPrivateFlags |= ALPHA_SET;
                }
            }
        }
    } else if ((child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
        child.onSetAlpha(255);
        child.mPrivateFlags &= ~ALPHA_SET;
    }
    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (cr - cl), sy + (cb - ct));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, cr - cl, cb - ct);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (hasDisplayList) {
        displayList = child.getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE) {
            final HardwareLayer layer = child.getHardwareLayer();
            if (layer != null && layer.isValid()) {
                child.mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, child.mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, child.mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((child.mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                    if (ViewDebug.TRACE_HIERARCHY) {
                        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
                    }
                    child.mPrivateFlags &= ~DIRTY_MASK;
                    child.dispatchDraw(canvas);
                } else {
                    child.draw(canvas);
                }
            } else {
                child.mPrivateFlags &= ~DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, cr - cl, cb - ct, null);
            }
        }
    } else if (cache != null) {
        child.mPrivateFlags &= ~DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                mCachePaint = cachePaint;
            }
            if (alpha < 1.0f) {
                cachePaint.setAlpha((int) (alpha * 255));
                mGroupFlags |= FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & FLAG_ALPHA_LOWER_THAN_ONE) == FLAG_ALPHA_LOWER_THAN_ONE) {
                cachePaint.setAlpha(255);
                mGroupFlags &= ~FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = child.mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    canvas.restoreToCount(restoreTo);
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            child.onSetAlpha(255);
        }
        finishAnimatingView(child, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        invalidate(true);
        if (a.hasAlpha() && (child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            child.invalidate(true);
        }
    }
    child.mRecreateDisplayList = false;
    return more;
}",1,"/**
 * Draw one child of this View Group. This method is responsible for getting
 * the canvas in the right state. This includes clipping, translating so
 * that the child's scrolled origin is at 0, 0, and applying any animation
 * transformations.
 *
 * @param canvas The canvas on which to draw the child
 * @param child Who to draw
 * @param drawingTime The time at which draw is occuring
 * @return True if an invalidate() was issued
 */
","/**
 * Draw one child of this View Group. This method is responsible for getting
 * the canvas in the right state. This includes clipping, translating so
 * that the child's scrolled origin is at 0, 0, and applying any animation
 * transformations.
 *
 * @param canvas The canvas on which to draw the child
 * @param child Who to draw
 * @param drawingTime The time at which draw is occuring
 * @return True if an invalidate() was issued
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
83,"<android.content.Intent: Intent parseUri(String,int)>",14,15,"<android.content.Intent: Intent parseUri(String,int)>","<android.content.Intent: Intent parseUri(String,int)>",0,"{
    int i = 0;
    try {
        // Validate intent scheme for if requested.
        if ((flags & URI_INTENT_SCHEME) != 0) {
            if (!uri.startsWith(""intent:"")) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        // simple case
        i = uri.lastIndexOf(""#"");
        if (i == -1)
            return new Intent(ACTION_VIEW, Uri.parse(uri));
        // old format Intent URI
        if (!uri.startsWith(""#Intent;"", i))
            return getIntentOld(uri);
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        // fetch data part, if present
        String data = i >= 0 ? uri.substring(0, i) : null;
        String scheme = null;
        i += ""#Intent;"".length();
        // loop over contents of Intent, all name=value;
        while (!uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            int semi = uri.indexOf(';', eq);
            String value = Uri.decode(uri.substring(eq + 1, semi));
            // action
            if (uri.startsWith(""action="", i)) {
                intent.setAction(value);
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                scheme = value;
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}","{
    int i = 0;
    try {
        // Validate intent scheme for if requested.
        if ((flags & URI_INTENT_SCHEME) != 0) {
            if (!uri.startsWith(""intent:"")) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        // simple case
        i = uri.lastIndexOf(""#"");
        if (i == -1)
            return new Intent(ACTION_VIEW, Uri.parse(uri));
        // old format Intent URI
        if (!uri.startsWith(""#Intent;"", i))
            return getIntentOld(uri);
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        Intent baseIntent = intent;
        // fetch data part, if present
        String data = i >= 0 ? uri.substring(0, i) : null;
        String scheme = null;
        i += ""#Intent;"".length();
        // loop over contents of Intent, all name=value;
        while (!uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            if (eq < 0)
                eq = i - 1;
            int semi = uri.indexOf(';', i);
            String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : """";
            // action
            if (uri.startsWith(""action="", i)) {
                intent.setAction(value);
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                scheme = value;
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // selector
            if (semi == (i + 3) && uri.startsWith(""SEL"", i)) {
                intent = new Intent();
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (intent != baseIntent) {
            // The Intent had a selector; fix it up.
            baseIntent.setSelector(intent);
            intent = baseIntent;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}",1,"/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
","/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 1",1,"The change happens when a new Intent instance is created 'intent = new Intent();' in the 'while' loop when URI starts with ""SEL"", and a new condition is added before setting the intent data. Also, a new line 'Intent baseIntent = intent;' is added and used in 'if (intent != baseIntent)'. These changes affect both control flow and return statements, hence the class is 3, 1. ","Given the changes, the result of 'return intent;' could potentially vary between versions, i.e., the baseIntent or a different intent instance when URI starts with ""SEL"". Thus, it constitutes a CI of class 1, the API potentially returns a different value in the late version."
85,<android.view.View: void getLocationInWindow(int[])>,14,15,<android.view.View: void getLocationInWindow(int[])>,<android.view.View: void getLocationInWindow(int[])>,0,"{
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of "" + ""two integers"");
    }
    location[0] = mLeft;
    location[1] = mTop;
    if (mTransformationInfo != null) {
        location[0] += (int) (mTransformationInfo.mTranslationX + 0.5f);
        location[1] += (int) (mTransformationInfo.mTranslationY + 0.5f);
    }
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        location[0] += view.mLeft - view.mScrollX;
        location[1] += view.mTop - view.mScrollY;
        if (view.mTransformationInfo != null) {
            location[0] += (int) (view.mTransformationInfo.mTranslationX + 0.5f);
            location[1] += (int) (view.mTransformationInfo.mTranslationY + 0.5f);
        }
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        location[1] -= vr.mCurScrollY;
    }
}","{
    // When the view is not attached to a window, this method does not make sense
    if (mAttachInfo == null)
        return;
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of two integers"");
    }
    float[] position = mAttachInfo.mTmpTransformLocation;
    position[0] = position[1] = 0.0f;
    if (!hasIdentityMatrix()) {
        getMatrix().mapPoints(position);
    }
    position[0] += mLeft;
    position[1] += mTop;
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        position[0] -= view.mScrollX;
        position[1] -= view.mScrollY;
        if (!view.hasIdentityMatrix()) {
            view.getMatrix().mapPoints(position);
        }
        position[0] += view.mLeft;
        position[1] += view.mTop;
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        position[1] -= vr.mCurScrollY;
    }
    location[0] = (int) (position[0] + 0.5f);
    location[1] = (int) (position[1] + 0.5f);
}",1,"/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
","/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"An early termination return statement has been added, the method of positioning and calculation have been dramatically changed, multiple variables and calculation methods also changed, therefore the code change type is 1,3,4.","Considering the mutations done in the code (introducing entirely new variables and methods for calculation, also the introduction of the return statement), it is certain that the API will not behave the same way as before, therefore, the CI type is 1."
88,<android.service.textservice.SpellCheckerService.InternalISpellCheckerSession: void onCancel()>,14,15,<android.service.textservice.SpellCheckerService.InternalISpellCheckerSession: void onCancel()>,<android.service.textservice.SpellCheckerService.InternalISpellCheckerSession: void onCancel()>,0,"{
    mSession.onCancel();
}","{
    int pri = Process.getThreadPriority(Process.myTid());
    try {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        mSession.onCancel();
    } finally {
        Process.setThreadPriority(pri);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The API wrapped the previous implementation with a try-finally block to set thread priority, so the code change type is 4 (other statement changed).","Even though the processing priority has been modified, it doesn't change the output or throwing exceptions of this API. Therefore, no Compatibility Issue exists, so the CI type is 0."
89,"<android.webkit.WebView: void initiateTextFieldDrag(float,float,long)>",14,15,"<android.webkit.WebView: void initiateTextFieldDrag(float,float,long)>","<android.webkit.WebView: void initiateTextFieldDrag(float,float,long)>",0,"{
    if (!inEditingMode()) {
        return;
    }
    mLastTouchX = Math.round(x + mWebTextView.getLeft() - mScrollX);
    mLastTouchY = Math.round(y + mWebTextView.getTop() - mScrollY);
    mLastTouchTime = eventTime;
    if (!mScroller.isFinished()) {
        abortAnimation();
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
    }
    mSnapScrollMode = SNAP_NONE;
    mVelocityTracker = VelocityTracker.obtain();
    mTouchMode = TOUCH_DRAG_START_MODE;
}","{
    if (!inEditingMode()) {
        return;
    }
    mLastTouchX = Math.round(x + mWebTextView.getLeft() - mScrollX);
    mLastTouchY = Math.round(y + mWebTextView.getTop() - mScrollY);
    mLastTouchTime = eventTime;
    if (!mScroller.isFinished()) {
        abortAnimation();
    }
    mSnapScrollMode = SNAP_NONE;
    mVelocityTracker = VelocityTracker.obtain();
    mTouchMode = TOUCH_DRAG_START_MODE;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A statement 'mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY)' was removed in late implementation, so the change type is 4.","The removal of the 'mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY)' statement does not lead to different return values or different exception handling, thus no Compatibility Issue exists here; CI type is 0."
92,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,14,15,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled() || !mFlingable) {
        return false;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mLastMotionEventY = mLastDownEventY = event.getY();
            removeAllCallbacks();
            mShowInputControlsAnimator.cancel();
            mDimSelectorWheelAnimator.cancel();
            mBeginEditOnUpEvent = false;
            mAdjustScrollerOnUpEvent = true;
            if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {
                boolean scrollersFinished = mFlingScroller.isFinished() && mAdjustScroller.isFinished();
                if (!scrollersFinished) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mBeginEditOnUpEvent = scrollersFinished;
                mAdjustScrollerOnUpEvent = true;
                hideInputControls();
                return true;
            }
            if (isEventInViewHitRect(event, mInputText) || (!mIncrementButton.isShown() && isEventInViewHitRect(event, mIncrementButton)) || (!mDecrementButton.isShown() && isEventInViewHitRect(event, mDecrementButton))) {
                mAdjustScrollerOnUpEvent = false;
                setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
                hideInputControls();
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = event.getY();
            int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
            if (deltaDownY > mTouchSlop) {
                mBeginEditOnUpEvent = false;
                onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
                hideInputControls();
                return true;
            }
            break;
    }
    return false;
}","{
    if (!isEnabled() || !mFlingable) {
        return false;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mLastMotionEventY = mLastDownEventY = event.getY();
            removeAllCallbacks();
            mShowInputControlsAnimator.cancel();
            mDimSelectorWheelAnimator.cancel();
            mBeginEditOnUpEvent = false;
            mAdjustScrollerOnUpEvent = true;
            if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {
                mSelectorWheelPaint.setAlpha(SELECTOR_WHEEL_BRIGHT_ALPHA);
                boolean scrollersFinished = mFlingScroller.isFinished() && mAdjustScroller.isFinished();
                if (!scrollersFinished) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mBeginEditOnUpEvent = scrollersFinished;
                mAdjustScrollerOnUpEvent = true;
                hideInputControls();
                return true;
            }
            if (isEventInVisibleViewHitRect(event, mIncrementButton) || isEventInVisibleViewHitRect(event, mDecrementButton)) {
                return false;
            }
            mAdjustScrollerOnUpEvent = false;
            setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
            hideInputControls();
            return true;
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = event.getY();
            int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
            if (deltaDownY > mTouchSlop) {
                mBeginEditOnUpEvent = false;
                onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
                hideInputControls();
                return true;
            }
            break;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the 'case MotionEvent.ACTION_DOWN' branch, a new operation (mSelectorWheelPaint.setAlpha(SELECTOR_WHEEL_BRIGHT_ALPHA)) has been added. The condition in the 'if' statement, which is inside the 'case MotionEvent.ACTION_DOWN' branch, is changed from testing if an event is within the hit rectangle of a view to testing if an event is within the hit rectangle of a visible view. Also, when this condition is met, it returns false instead of true. Therefore, the code change types are 1 (return statement changed), 3 (control dependency changed) and 4 (other statement changed).","In the 'case MotionEvent.ACTION_DOWN' branch, the original 'return true' is replaced by 'return false' in the condition 'if (isEventInVisibleViewHitRect(event, mIncrementButton) || isEventInVisibleViewHitRect(event, mDecrementButton))'. Consequently, the late version of the API is likely to return a potentially different value (false instead of true), so the CI type is 1 (Compatibility Issue caused by potential different return values)."
93,"<android.webkit.WebViewDatabase: ArrayList<String> getFormData(String,String)>",14,15,"<android.webkit.WebViewDatabase: ArrayList<String> getFormData(String,String)>","<android.webkit.WebViewDatabase: ArrayList<String> getFormData(String,String)>",0,"{
    ArrayList<String> values = new ArrayList<String>();
    if (url == null || name == null || !checkInitialized()) {
        return values;
    }
    final String urlSelection = ""("" + FORMURL_URL_COL + "" == ?)"";
    final String dataSelection = ""("" + FORMDATA_URLID_COL + "" == ?) AND ("" + FORMDATA_NAME_COL + "" == ?)"";
    synchronized (mFormLock) {
        Cursor cursor = null;
        try {
            cursor = mDatabase.query(mTableNames[TABLE_FORMURL_ID], ID_PROJECTION, urlSelection, new String[] { url }, null, null, null);
            if (cursor.moveToFirst()) {
                long urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
                Cursor dataCursor = null;
                try {
                    dataCursor = mDatabase.query(mTableNames[TABLE_FORMDATA_ID], new String[] { ID_COL, FORMDATA_VALUE_COL }, dataSelection, new String[] { Long.toString(urlid), name }, null, null, null);
                    if (dataCursor.moveToFirst()) {
                        int valueCol = dataCursor.getColumnIndex(FORMDATA_VALUE_COL);
                        do {
                            values.add(dataCursor.getString(valueCol));
                        } while (dataCursor.moveToNext());
                    }
                } catch (IllegalStateException e) {
                    Log.e(LOGTAG, ""getFormData dataCursor"", e);
                } finally {
                    if (dataCursor != null)
                        dataCursor.close();
                }
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""getFormData cursor"", e);
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return values;
    }
}","{
    ArrayList<String> values = new ArrayList<String>();
    if (url == null || name == null || !checkInitialized()) {
        return values;
    }
    final String urlSelection = ""("" + FORMURL_URL_COL + "" == ?)"";
    final String dataSelection = ""("" + FORMDATA_URLID_COL + "" == ?) AND ("" + FORMDATA_NAME_COL + "" == ?)"";
    synchronized (mFormLock) {
        Cursor cursor = null;
        try {
            cursor = mDatabase.query(mTableNames[TABLE_FORMURL_ID], ID_PROJECTION, urlSelection, new String[] { url }, null, null, null);
            while (cursor.moveToNext()) {
                long urlid = cursor.getLong(cursor.getColumnIndex(ID_COL));
                Cursor dataCursor = null;
                try {
                    dataCursor = mDatabase.query(mTableNames[TABLE_FORMDATA_ID], new String[] { ID_COL, FORMDATA_VALUE_COL }, dataSelection, new String[] { Long.toString(urlid), name }, null, null, null);
                    if (dataCursor.moveToFirst()) {
                        int valueCol = dataCursor.getColumnIndex(FORMDATA_VALUE_COL);
                        do {
                            values.add(dataCursor.getString(valueCol));
                        } while (dataCursor.moveToNext());
                    }
                } catch (IllegalStateException e) {
                    Log.e(LOGTAG, ""getFormData dataCursor"", e);
                } finally {
                    if (dataCursor != null)
                        dataCursor.close();
                }
            }
        } catch (IllegalStateException e) {
            Log.e(LOGTAG, ""getFormData cursor"", e);
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return values;
    }
}",1,"/**
 * Get all the values for a form entry with ""name"" in a given site
 *
 * @param url The url of the site
 * @param name The name of the form entry
 * @return A list of values. Return empty list if nothing is found.
 */
","/**
 * Get all the values for a form entry with ""name"" in a given site
 *
 * @param url The url of the site
 * @param name The name of the form entry
 * @return A list of values. Return empty list if nothing is found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The control statement 'if (cursor.moveToFirst())' is changed to 'while (cursor.moveToNext())' which alters the looping behaviour. Therefore the code change type is 3.,"Considering the change in the control statement, this changes the behaviour of the 'values' creation process. Due to the new looping condition, the returned 'values' might contain different elements, thus the CI type is 1."
95,<android.webkit.WebView: void notifyFindDialogDismissed()>,14,15,<android.webkit.WebView: void notifyFindDialogDismissed()>,<android.webkit.WebView: void notifyFindDialogDismissed()>,0,"{
    mFindCallback = null;
    if (mWebViewCore == null) {
        return;
    }
    clearMatches();
    setFindIsUp(false);
    // Now that the dialog has been removed, ensure that we scroll to a
    // location that is not beyond the end of the page.
    pinScrollTo(mScrollX, mScrollY, false, 0);
    invalidate();
}","{
    mFindCallback = null;
    mCachedOverlappingActionModeHeight = -1;
    if (mWebViewCore == null) {
        return;
    }
    clearMatches();
    setFindIsUp(false);
    // Now that the dialog has been removed, ensure that we scroll to a
    // location that is not beyond the end of the page.
    pinScrollTo(mScrollX, mScrollY, false, 0);
    invalidate();
}",1,"/**
 * Called when the find ActionMode ends.
 */
","/**
 * Called when the find ActionMode ends.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement (mCachedOverlappingActionModeHeight = -1;) was added in the late version, thus the code change type is 4. ","This added statement wouldn't change the return value or the exception handling of the method, so no compatibility issue exists in this case and thus the type is 0."
96,<android.speech.tts.FileSynthesisCallback: int done()>,14,15,<android.speech.tts.FileSynthesisCallback: int done()>,<android.speech.tts.FileSynthesisCallback: int done()>,0,"{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            // Write WAV header at start of file
            mFile.seek(0);
            int dataLength = (int) (mFile.length() - WAV_HEADER_LENGTH);
            mFile.write(makeWavHeader(mSampleRateInHz, mAudioFormat, mChannelCount, dataLength));
            closeFile();
            mDone = true;
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            // Write WAV header at start of file
            mFile.seek(0);
            int dataLength = (int) (mFile.length() - WAV_HEADER_LENGTH);
            mFile.write(makeWavHeader(mSampleRateInHz, mAudioFormat, mChannelCount, dataLength));
            closeFileAndWidenPermissions();
            mDone = true;
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The statement 'closeFile();' is replaced with 'closeFileAndWidenPermissions();'. This new method name is different, but it does not change any return statements, exception handling statements, or control dependency statements. So the code change type is 4.","This change does not lead to the API returning a different value or type, or throwing a different exception. Therefore, no Compatibility Issue exists. The CI type is 0."
98,<android.widget.SpellChecker.SpellParser: void parse()>,14,15,<android.widget.SpellChecker.SpellParser: void parse()>,<android.widget.SpellChecker.SpellParser: void parse()>,0,"{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start = editable.getSpanStart(mRange);
    final int end = editable.getSpanEnd(mRange);
    mWordIterator.setCharSequence(editable, start, end);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        editable.removeSpan(mRange);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int nbWordsChecked = 0;
    boolean scheduleOtherSpellCheck = false;
    while (wordStart <= end) {
        if (wordEnd >= start && wordEnd > wordStart) {
            // Previous spans (ended on start / started on end) removed, not valid anymore
            if (wordStart < start && wordEnd > start) {
                removeSpansAt(editable, start, spellCheckSpans);
                removeSpansAt(editable, start, suggestionSpans);
            }
            if (wordStart < end && wordEnd > end) {
                removeSpansAt(editable, end, spellCheckSpans);
                removeSpansAt(editable, end, suggestionSpans);
            }
            // Do not create new boundary spans if they already exist
            boolean createSpellCheckSpan = true;
            if (wordEnd == start) {
                for (int i = 0; i < spellCheckSpans.length; i++) {
                    final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                    if (spanEnd == start) {
                        createSpellCheckSpan = false;
                        break;
                    }
                }
            }
            if (wordStart == end) {
                for (int i = 0; i < spellCheckSpans.length; i++) {
                    final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                    if (spanStart == end) {
                        createSpellCheckSpan = false;
                        break;
                    }
                }
            }
            if (createSpellCheckSpan) {
                if (nbWordsChecked == MAX_SPELL_BATCH_SIZE) {
                    scheduleOtherSpellCheck = true;
                    break;
                }
                addSpellCheckSpan(editable, wordStart, wordEnd);
                nbWordsChecked++;
            }
        }
        // iterate word by word
        wordEnd = mWordIterator.following(wordEnd);
        if (wordEnd == BreakIterator.DONE)
            break;
        wordStart = mWordIterator.getBeginning(wordEnd);
        if (wordStart == BreakIterator.DONE) {
            break;
        }
    }
    if (scheduleOtherSpellCheck) {
        editable.setSpan(mRange, wordStart, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    } else {
        editable.removeSpan(mRange);
    }
    spellCheck();
}","{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start = editable.getSpanStart(mRange);
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        editable.removeSpan(mRange);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    while (wordStart <= end) {
        if (wordEnd >= start && wordEnd > wordStart) {
            if (wordCount >= MAX_NUMBER_OF_WORDS) {
                scheduleOtherSpellCheck = true;
                break;
            }
            // Previous spans (ended on start / started on end) removed, not valid anymore
            if (wordStart < start && wordEnd > start) {
                removeSpansAt(editable, start, spellCheckSpans);
                removeSpansAt(editable, start, suggestionSpans);
            }
            if (wordStart < end && wordEnd > end) {
                removeSpansAt(editable, end, spellCheckSpans);
                removeSpansAt(editable, end, suggestionSpans);
            }
            // Do not create new boundary spans if they already exist
            boolean createSpellCheckSpan = true;
            if (wordEnd == start) {
                for (int i = 0; i < spellCheckSpans.length; i++) {
                    final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                    if (spanEnd == start) {
                        createSpellCheckSpan = false;
                        break;
                    }
                }
            }
            if (wordStart == end) {
                for (int i = 0; i < spellCheckSpans.length; i++) {
                    final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                    if (spanStart == end) {
                        createSpellCheckSpan = false;
                        break;
                    }
                }
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, wordStart, wordEnd);
            }
            wordCount++;
        }
        // iterate word by word
        int originalWordEnd = wordEnd;
        wordEnd = mWordIterator.following(wordEnd);
        if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
            wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
            mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
            wordEnd = mWordIterator.following(originalWordEnd);
        }
        if (wordEnd == BreakIterator.DONE)
            break;
        wordStart = mWordIterator.getBeginning(wordEnd);
        if (wordStart == BreakIterator.DONE) {
            break;
        }
    }
    if (scheduleOtherSpellCheck) {
        editable.setSpan(mRange, wordStart, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    } else {
        editable.removeSpan(mRange);
    }
    spellCheck();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new local variable 'wordIteratorWindowEnd' was introduced and used in the control dependency 'if'. Additionally, an 'if' branch has been added, resulting in more conditions to be checked and more operations to be executed, this change modified the logic of the code but doesn't appear to change its core function. Hence the code change type is 3,4.","Although the logic of the code has been changed, the possible return values and exception handlings remain unchanged in both the early and late versions of the code. Thus, there is no compatibility issue."
99,<android.view.inputmethod.InputMethodManager: void startInputInner()>,14,15,<android.view.inputmethod.InputMethodManager: void startInputInner()>,<android.view.inputmethod.InputMethodManager: void startInputInner()>,0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // from under us, so just bail.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view!"");
        return;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            public void run() {
                startInputInner();
            }
        });
        return;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return;
        }
        // If we already have a text box, then this view is already
        // connected so we want to restart it.
        final boolean initial = mCurrentTextBoxAttribute == null;
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        mServedInputConnection = ic;
        IInputContext servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic);
        } else {
            servedContext = null;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" initial="" + initial);
            InputBindResult res = mService.startInput(mClient, servedContext, tba, initial, true);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                } else if (mCurMethod == null) {
                    // This means there is no input method available.
                    if (DEBUG)
                        Log.v(TAG, ""ABORT input: no input method!"");
                    return;
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // from under us, so just bail.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view!"");
        return;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            public void run() {
                startInputInner();
            }
        });
        return;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return;
        }
        // If we already have a text box, then this view is already
        // connected so we want to restart it.
        final boolean initial = mCurrentTextBoxAttribute == null;
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        mServedInputConnection = ic;
        IInputContext servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" initial="" + initial);
            InputBindResult res = mService.startInput(mClient, servedContext, tba, initial, true);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                } else if (mCurMethod == null) {
                    // This means there is no input method available.
                    if (DEBUG)
                        Log.v(TAG, ""ABORT input: no input method!"");
                    return;
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new parameter 'this' is added to the call of the constructor of ControlledInputConnectionWrapper class: ControlledInputConnectionWrapper(vh.getLooper(), ic, this). Hence the change type is 4) Under 'Other statement changed'.","There is no compatibility issue involved in this change. Adding a parameter to the call of a constructor in the implementation but not changing the output type or exception thrown by the method means the method behaves the same for its callers. Though the internal processing changed, it doesn't affect how the method interacts with its callers. Hence, no compatibility issue detected."
101,<android.view.HardwareRenderer.Gl20Renderer: void trimMemory(int)>,14,15,<android.view.HardwareRenderer.Gl20Renderer: void trimMemory(int)>,<android.view.HardwareRenderer.Gl20Renderer: void trimMemory(int)>,0,"{
    if (sEgl == null || sEglConfig == null)
        return;
    EGLContext eglContext = sEglContextStorage.get();
    // We do not have OpenGL objects
    if (eglContext == null) {
        return;
    } else {
        synchronized (sPbufferLock) {
            // to clear our OpenGL objects
            if (sPbuffer == null) {
                sPbuffer = sEgl.eglCreatePbufferSurface(sEglDisplay, sEglConfig, new int[] { EGL_WIDTH, 1, EGL_HEIGHT, 1, EGL_NONE });
            }
        }
        sEgl.eglMakeCurrent(sEglDisplay, sPbuffer, sPbuffer, eglContext);
    }
    switch(level) {
        case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:
        case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:
        case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
            GLES20Canvas.flushCaches(GLES20Canvas.FLUSH_CACHES_MODERATE);
            break;
        case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
            GLES20Canvas.flushCaches(GLES20Canvas.FLUSH_CACHES_FULL);
            break;
    }
}","{
    if (sEgl == null || sEglConfig == null)
        return;
    Gl20RendererEglContext managedContext = sEglContextStorage.get();
    // We do not have OpenGL objects
    if (managedContext == null) {
        return;
    } else {
        usePbufferSurface(managedContext.getContext());
    }
    switch(level) {
        case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:
        case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:
        case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
            GLES20Canvas.flushCaches(GLES20Canvas.FLUSH_CACHES_MODERATE);
            break;
        case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
            GLES20Canvas.flushCaches(GLES20Canvas.FLUSH_CACHES_FULL);
            break;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,The return statements have not changed. The type change (EGLContext to Gl20RendererEglContext) and the introduction of usePbufferSurface(managedContext.getContext()) in place of the previous synchronized block indicate both an Other statement change (4) and a Dependent API change (5).,"There is no Compatibility Issue because the return statements have not changed, and no exception is thrown differently in the two versions."
104,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>",14,15,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>","<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder)>",0,"{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            mDied = false;
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is not disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    // If there is a new service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    }
}","{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            mDied = false;
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is not disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    // If there is a new service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"A condition has been added at the beginning of the code block within the synchronized statement. Any connections received while the service dispatcher is forgotten will be early-exited, therefore the change type is 3.","As the new condition causes an early return when the mForgotten variable is true, the behavior of the method has changed. The late version implementation won't necessarily return the same as the early version, hence the CI type is 1."
105,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,14,15,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mAccessibilityViewId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByViewText(mConnection, text, mAccessibilityWindowId, mAccessibilityViewId);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mAccessibilityViewId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByViewText(mConnectionId, text, mAccessibilityWindowId, mAccessibilityViewId);
}",1,"/**
 * Finds {@link AccessibilityNodeInfo}s by text. The match is case
 * insensitive containment. The search is relative to this info i.e.
 * this info is the root of the traversed tree.
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param text The searched text.
 * @return A list of node info.
 */
","/**
 * Finds {@link AccessibilityNodeInfo}s by text. The match is case
 * insensitive containment. The search is relative to this info i.e.
 * this info is the root of the traversed tree.
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param text The searched text.
 * @return A list of node info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The type of parameter in method findAccessibilityNodeInfosByViewText() has changed from mConnection to mConnectionId, thus the change type of the code is 4,5.","Because the method findAccessibilityNodeInfosByViewText() is executed with different parameters between the two versions, the return results may be different too. Therefore, the CI type is 1."
107,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",14,15,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = (BluetoothHeadset) proxy;
        if (headset != null) {
            headset.close();
        }
    }
}","{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the early version, the method only considers if the profile is a BluetoothProfile.HEADSET. In the late version, it checks multiple profiles, and a new control check 'proxy == null' has been introduced. Apart from this, some new method invocations and case conditions are also introduced in the late versions, so the code change types are 3,4.","Owing to the changes in the control dependency and introduction of new case conditions and new method invocations, the late version potentially returns differently compared to the early version especially when the proxy is null or the profile is not a BluetoothProfile.HEADSET. Therefore, the Compatibility Issue type is 1."
108,<android.webkit.WebView: void onDraw(Canvas)>,14,15,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"{
    // initialized. In either case, just draw the background color and return
    if (mNativeClass == 0) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    if (canvas.isHardwareAccelerated()) {
        mZoomManager.setHardwareAccelerated();
    }
    int saveCount = canvas.save();
    if (mInOverScrollMode && !getSettings().getUseWebViewBackgroundForOverscrollBackground()) {
        drawOverScrollBackground(canvas);
    }
    if (mTitleBar != null) {
        canvas.translate(0, getTitleHeight());
    }
    boolean drawJavaRings = !mTouchHighlightRegion.isEmpty() && (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_DONE_MODE);
    boolean drawNativeRings = !drawJavaRings;
    if (USE_WEBKIT_RINGS) {
        drawNativeRings = !drawJavaRings && !isInTouchMode();
    }
    drawContent(canvas, drawNativeRings);
    canvas.restoreToCount(saveCount);
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    mWebViewCore.signalRepaintDone();
    if (mOverScrollGlow != null && mOverScrollGlow.drawEdgeGlows(canvas)) {
        invalidate();
    }
    // paint the highlight in the end
    if (drawJavaRings) {
        long delay = System.currentTimeMillis() - mTouchHighlightRequested;
        if (delay < ViewConfiguration.getTapTimeout()) {
            Rect r = mTouchHighlightRegion.getBounds();
            postInvalidateDelayed(delay, r.left, r.top, r.right, r.bottom);
        } else {
            if (mTouchHightlightPaint == null) {
                mTouchHightlightPaint = new Paint();
                mTouchHightlightPaint.setColor(HIGHLIGHT_COLOR);
            }
            RegionIterator iter = new RegionIterator(mTouchHighlightRegion);
            Rect r = new Rect();
            while (iter.next(r)) {
                canvas.drawRect(r, mTouchHightlightPaint);
            }
        }
    }
    if (DEBUG_TOUCH_HIGHLIGHT) {
        if (getSettings().getNavDump()) {
            if ((mTouchHighlightX | mTouchHighlightY) != 0) {
                if (mTouchCrossHairColor == null) {
                    mTouchCrossHairColor = new Paint();
                    mTouchCrossHairColor.setColor(Color.RED);
                }
                canvas.drawLine(mTouchHighlightX - mNavSlop, mTouchHighlightY - mNavSlop, mTouchHighlightX + mNavSlop + 1, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
                canvas.drawLine(mTouchHighlightX + mNavSlop + 1, mTouchHighlightY - mNavSlop, mTouchHighlightX - mNavSlop, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
            }
        }
    }
}","{
    // initialized. In either case, just draw the background color and return
    if (mNativeClass == 0) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    if (canvas.isHardwareAccelerated()) {
        if (mIncrementEGLContextHack == false) {
            mIncrementEGLContextHack = true;
            EGL10 egl = (EGL10) EGLContext.getEGL();
            EGLDisplay eglDisplay = egl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            int[] version = new int[2];
            egl.eglInitialize(eglDisplay, version);
        }
        mZoomManager.setHardwareAccelerated();
    }
    int saveCount = canvas.save();
    if (mInOverScrollMode && !getSettings().getUseWebViewBackgroundForOverscrollBackground()) {
        drawOverScrollBackground(canvas);
    }
    if (mTitleBar != null) {
        canvas.translate(0, getTitleHeight());
    }
    boolean drawJavaRings = !mTouchHighlightRegion.isEmpty() && (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_DONE_MODE);
    boolean drawNativeRings = !drawJavaRings;
    if (USE_WEBKIT_RINGS) {
        drawNativeRings = !drawJavaRings && !isInTouchMode();
    }
    drawContent(canvas, drawNativeRings);
    canvas.restoreToCount(saveCount);
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    mWebViewCore.signalRepaintDone();
    if (mOverScrollGlow != null && mOverScrollGlow.drawEdgeGlows(canvas)) {
        invalidate();
    }
    // paint the highlight in the end
    if (drawJavaRings) {
        long delay = System.currentTimeMillis() - mTouchHighlightRequested;
        if (delay < ViewConfiguration.getTapTimeout()) {
            Rect r = mTouchHighlightRegion.getBounds();
            postInvalidateDelayed(delay, r.left, r.top, r.right, r.bottom);
        } else {
            if (mTouchHightlightPaint == null) {
                mTouchHightlightPaint = new Paint();
                mTouchHightlightPaint.setColor(HIGHLIGHT_COLOR);
            }
            RegionIterator iter = new RegionIterator(mTouchHighlightRegion);
            Rect r = new Rect();
            while (iter.next(r)) {
                canvas.drawRect(r, mTouchHightlightPaint);
            }
        }
    }
    if (DEBUG_TOUCH_HIGHLIGHT) {
        if (getSettings().getNavDump()) {
            if ((mTouchHighlightX | mTouchHighlightY) != 0) {
                if (mTouchCrossHairColor == null) {
                    mTouchCrossHairColor = new Paint();
                    mTouchCrossHairColor.setColor(Color.RED);
                }
                canvas.drawLine(mTouchHighlightX - mNavSlop, mTouchHighlightY - mNavSlop, mTouchHighlightX + mNavSlop + 1, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
                canvas.drawLine(mTouchHighlightX + mNavSlop + 1, mTouchHighlightY - mNavSlop, mTouchHighlightX - mNavSlop, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Under the condition of 'if (canvas.isHardwareAccelerated())', new assignments and method calls have been added, so the code change type is 3,4.","Although the code changes, the new codes do not affect the returned value and exceptions of the API, so there is no Compatibility Issue."
110,<android.widget.NumberPicker: void setMinValue(int)>,14,15,<android.widget.NumberPicker: void setMinValue(int)>,<android.widget.NumberPicker: void setMinValue(int)>,0,"{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
}","{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
}",1,"/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value.
 */
","/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method tryComputeMaxWidth() is called at the end of the later version implementation, therefore, it is classified as a 4 - Other statement changed.","The addition of the method tryComputeMaxWidth() has no effect on the return value of setMinValue(int), and it doesn't potentially throw a new exception. Hence, there is no Compatibility Issue (0 - No Compatibility Issue exist)."
116,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",14,15,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>","<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",0,"{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate;
    if (timeZone != null) {
        startDate = new Time(timeZone);
    } else if (useUTC) {
        startDate = new Time(Time.TIMEZONE_UTC);
    } else {
        startDate = new Time();
    }
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endDate = new Time(timeZone);
        } else if (useUTC) {
            endDate = new Time(Time.TIMEZONE_UTC);
        } else {
            endDate = new Time();
        }
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    // adjust the date.
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}","{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate;
    if (timeZone != null) {
        startDate = new Time(timeZone);
    } else if (useUTC) {
        startDate = new Time(Time.TIMEZONE_UTC);
    } else {
        startDate = new Time();
    }
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endDate = new Time(timeZone);
        } else if (useUTC) {
            endDate = new Time(Time.TIMEZONE_UTC);
        } else {
            endDate = new Time();
        }
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    // adjust the date.
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}",1,"/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
","/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
118,"<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>",14,15,"<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>","<android.view.ViewGroup: boolean getChildVisibleRect(View,Rect,Point)>",0,"{
    int dx = child.mLeft - mScrollX;
    int dy = child.mTop - mScrollY;
    if (offset != null) {
        offset.x += dx;
        offset.y += dy;
    }
    r.offset(dx, dy);
    return r.intersect(0, 0, mRight - mLeft, mBottom - mTop) && (mParent == null || mParent.getChildVisibleRect(this, r, offset));
}","{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    int dx = child.mLeft - mScrollX;
    int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    if (rect.intersect(0, 0, mRight - mLeft, mBottom - mTop)) {
        if (mParent == null)
            return true;
        r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
        return mParent.getChildVisibleRect(this, r, offset);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The new implementation has extensive modification including the addition of new variables and computations as well as change in controls such as ""if"" and ""return"" statements, thus the code change types are 1,3,4.","The altered logic and computations will potentially affect the value returned by the API, hence the CI type is 1. Specifically, it could return different boolean value in different conditions."
123,<android.content.Intent: String toUri(int)>,14,15,<android.content.Intent: String toUri(int)>,<android.content.Intent: String toUri(int)>,0,"{
    StringBuilder uri = new StringBuilder(128);
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    uri.append(""#Intent;"");
    if (scheme != null) {
        uri.append(""scheme="").append(scheme).append(';');
    }
    if (mAction != null) {
        uri.append(""action="").append(Uri.encode(mAction)).append(';');
    }
    if (mCategories != null) {
        for (String category : mCategories) {
            uri.append(""category="").append(Uri.encode(category)).append(';');
        }
    }
    if (mType != null) {
        uri.append(""type="").append(Uri.encode(mType, ""/"")).append(';');
    }
    if (mFlags != 0) {
        uri.append(""launchFlags=0x"").append(Integer.toHexString(mFlags)).append(';');
    }
    if (mPackage != null) {
        uri.append(""package="").append(Uri.encode(mPackage)).append(';');
    }
    if (mComponent != null) {
        uri.append(""component="").append(Uri.encode(mComponent.flattenToShortString(), ""/"")).append(';');
    }
    if (mSourceBounds != null) {
        uri.append(""sourceBounds="").append(Uri.encode(mSourceBounds.flattenToString())).append(';');
    }
    if (mExtras != null) {
        for (String key : mExtras.keySet()) {
            final Object value = mExtras.get(key);
            char entryType = value instanceof String ? 'S' : value instanceof Boolean ? 'B' : value instanceof Byte ? 'b' : value instanceof Character ? 'c' : value instanceof Double ? 'd' : value instanceof Float ? 'f' : value instanceof Integer ? 'i' : value instanceof Long ? 'l' : value instanceof Short ? 's' : '\0';
            if (entryType != '\0') {
                uri.append(entryType);
                uri.append('.');
                uri.append(Uri.encode(key));
                uri.append('=');
                uri.append(Uri.encode(value.toString()));
                uri.append(';');
            }
        }
    }
    uri.append(""end"");
    return uri.toString();
}","{
    StringBuilder uri = new StringBuilder(128);
    String scheme = null;
    if (mData != null) {
        String data = mData.toString();
        if ((flags & URI_INTENT_SCHEME) != 0) {
            final int N = data.length();
            for (int i = 0; i < N; i++) {
                char c = data.charAt(i);
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '-') {
                    continue;
                }
                if (c == ':' && i > 0) {
                    // Valid scheme.
                    scheme = data.substring(0, i);
                    uri.append(""intent:"");
                    data = data.substring(i + 1);
                    break;
                }
                // No scheme.
                break;
            }
        }
        uri.append(data);
    } else if ((flags & URI_INTENT_SCHEME) != 0) {
        uri.append(""intent:"");
    }
    uri.append(""#Intent;"");
    toUriInner(uri, scheme, flags);
    if (mSelector != null) {
        uri.append(""SEL;"");
        // Note that for now we are not going to try to handle the
        // data part; not clear how to represent this as a URI, and
        // not much utility in it.
        mSelector.toUriInner(uri, null, flags);
    }
    uri.append(""end"");
    return uri.toString();
}",1,"/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
","/**
 * Convert this Intent into a String holding a URI representation of it.
 * The returned URI string has been properly URI encoded, so it can be
 * used with {@link Uri#parse Uri.parse(String)}.  The URI contains the
 * Intent's data as the base URI, with an additional fragment describing
 * the action, categories, type, flags, package, component, and extras.
 *
 * <p>You can convert the returned string back to an Intent with
 * {@link #getIntent}.
 *
 * @param flags Additional operating flags.  Either 0 or
 * {@link #URI_INTENT_SCHEME}.
 *
 * @return Returns a URI encoding URI string describing the entire contents
 * of the Intent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement changed from directly constructing the uri with different conditions and appends to using a function `toUriInner(uri, scheme, flags)` to handle the uri. Also, an additional condition check and append for `mSelector` is introduced, so the change type is 1,4.","As the uri constructing section has been changed and rewritten by a function and there is a newly introduced part for `mSelector`, the return values can possibly be different. Thus, the CI type is 1."
124,"<android.provider.Telephony.Threads: long getOrCreateThreadId(Context,Set<String>)>",14,15,"<android.provider.Telephony.Threads: long getOrCreateThreadId(Context,Set<String>)>","<android.provider.Telephony.Threads: long getOrCreateThreadId(Context,Set<String>)>",0,"{
    Uri.Builder uriBuilder = THREAD_ID_CONTENT_URI.buildUpon();
    for (String recipient : recipients) {
        if (Mms.isEmailAddress(recipient)) {
            recipient = Mms.extractAddrSpec(recipient);
        }
        uriBuilder.appendQueryParameter(""recipient"", recipient);
    }
    Uri uri = uriBuilder.build();
    // if (DEBUG) Log.v(TAG, ""getOrCreateThreadId uri: "" + uri);
    Cursor cursor = SqliteWrapper.query(context, context.getContentResolver(), uri, ID_PROJECTION, null, null, null);
    if (DEBUG) {
        Log.v(TAG, ""getOrCreateThreadId cursor cnt: "" + cursor.getCount());
    }
    if (cursor != null) {
        try {
            if (cursor.moveToFirst()) {
                return cursor.getLong(0);
            } else {
                Log.e(TAG, ""getOrCreateThreadId returned no rows!"");
            }
        } finally {
            cursor.close();
        }
    }
    Log.e(TAG, ""getOrCreateThreadId failed with uri "" + uri.toString());
    throw new IllegalArgumentException(""Unable to find or allocate a thread ID."");
}","{
    Uri.Builder uriBuilder = THREAD_ID_CONTENT_URI.buildUpon();
    for (String recipient : recipients) {
        if (Mms.isEmailAddress(recipient)) {
            recipient = Mms.extractAddrSpec(recipient);
        }
        uriBuilder.appendQueryParameter(""recipient"", recipient);
    }
    Uri uri = uriBuilder.build();
    // if (DEBUG) Log.v(TAG, ""getOrCreateThreadId uri: "" + uri);
    Cursor cursor = SqliteWrapper.query(context, context.getContentResolver(), uri, ID_PROJECTION, null, null, null);
    if (cursor != null) {
        try {
            if (cursor.moveToFirst()) {
                return cursor.getLong(0);
            } else {
                Log.e(TAG, ""getOrCreateThreadId returned no rows!"");
            }
        } finally {
            cursor.close();
        }
    }
    Log.e(TAG, ""getOrCreateThreadId failed with uri "" + uri.toString());
    throw new IllegalArgumentException(""Unable to find or allocate a thread ID."");
}",1,"/**
 * Given the recipients list and subject of an unsaved message,
 * return its thread ID.  If the message starts a new thread,
 * allocate a new thread ID.  Otherwise, use the appropriate
 * existing thread ID.
 *
 * Find the thread ID of the same set of recipients (in
 * any order, without any additions). If one
 * is found, return it.  Otherwise, return a unique thread ID.
 */
","/**
 * Given the recipients list and subject of an unsaved message,
 * return its thread ID.  If the message starts a new thread,
 * allocate a new thread ID.  Otherwise, use the appropriate
 * existing thread ID.
 *
 * Find the thread ID of the same set of recipients (in
 * any order, without any additions). If one
 * is found, return it.  Otherwise, return a unique thread ID.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the code between the two versions.,"Since there is no change in the API, there are no Compatibility Issues in the two version difference."
125,<android.database.sqlite.SQLiteQuery: int fillWindow(CursorWindow)>,14,15,<android.database.sqlite.SQLiteQuery: int fillWindow(CursorWindow)>,<android.database.sqlite.SQLiteQuery: int fillWindow(CursorWindow)>,0,"{
    mDatabase.lock(mSql);
    long timeStart = SystemClock.uptimeMillis();
    try {
        acquireReference();
        try {
            window.acquireReference();
            int numRows = nativeFillWindow(nHandle, nStatement, window.mWindowPtr, window.getStartPosition(), mOffsetIndex);
            mDatabase.logTimeStat(mSql, timeStart);
            return numRows;
        } catch (IllegalStateException e) {
            // simply ignore it
            return 0;
        } catch (SQLiteDatabaseCorruptException e) {
            mDatabase.onCorruption();
            throw e;
        } catch (SQLiteException e) {
            Log.e(TAG, ""exception: "" + e.getMessage() + ""; query: "" + mSql);
            throw e;
        } finally {
            window.releaseReference();
        }
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    mDatabase.lock(mSql);
    long timeStart = SystemClock.uptimeMillis();
    try {
        acquireReference();
        try {
            window.acquireReference();
            int startPos = window.getStartPosition();
            int numRows = nativeFillWindow(nHandle, nStatement, window.mWindowPtr, startPos, mOffsetIndex);
            if (SQLiteDebug.DEBUG_LOG_SLOW_QUERIES) {
                long elapsed = SystemClock.uptimeMillis() - timeStart;
                if (SQLiteDebug.shouldLogSlowQuery(elapsed)) {
                    Log.d(TAG, ""fillWindow took "" + elapsed + "" ms: window=\"""" + window + ""\"", startPos="" + startPos + "", offset="" + mOffsetIndex + "", filledRows="" + window.getNumRows() + "", countedRows="" + numRows + "", query=\"""" + mSql + ""\"""" + "", args=["" + (mBindArgs != null ? TextUtils.join("", "", mBindArgs.values()) : """") + ""]"");
                }
            }
            mDatabase.logTimeStat(mSql, timeStart);
            return numRows;
        } catch (IllegalStateException e) {
            // simply ignore it
            return 0;
        } catch (SQLiteDatabaseCorruptException e) {
            mDatabase.onCorruption();
            throw e;
        } catch (SQLiteException e) {
            Log.e(TAG, ""exception: "" + e.getMessage() + ""; query: "" + mSql);
            throw e;
        } finally {
            window.releaseReference();
        }
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an extra block of code inside the 'try' statement in the Late Version Implementation which is responsible for logging slow queries, so the code change type is 4.","The additional code does not seem to impact the logical behavior of the existing API. It is only logging additional information about slow queries, therefore, there is no compatibility issue (CI type 0)."
126,<android.view.HardwareRenderer.GlRenderer: GL createEglSurface(SurfaceHolder)>,14,15,<android.view.HardwareRenderer.GlRenderer: GL createEglSurface(SurfaceHolder)>,<android.view.HardwareRenderer.GlRenderer: GL createEglSurface(SurfaceHolder)>,0,"{
    // Check preconditions.
    if (sEgl == null) {
        throw new RuntimeException(""egl not initialized"");
    }
    if (sEglDisplay == null) {
        throw new RuntimeException(""eglDisplay not initialized"");
    }
    if (sEglConfig == null) {
        throw new RuntimeException(""eglConfig not initialized"");
    }
    if (Thread.currentThread() != mEglThread) {
        throw new IllegalStateException(""HardwareRenderer cannot be used "" + ""from multiple threads"");
    }
    // In case we need to destroy an existing surface
    destroySurface();
    // Create an EGL surface we can render into.
    if (!createSurface(holder)) {
        return null;
    }
    /*
             * Before we can issue GL commands, we need to make sure
             * the context is current and bound to a surface.
             */
    if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
        throw new Surface.OutOfResourcesException(""eglMakeCurrent failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
    }
    // with EGL_SWAP_BEHAVIOR_PRESERVED_BIT set
    if (sDirtyRegions) {
        if (!(mDirtyRegionsEnabled = GLES20Canvas.preserveBackBuffer())) {
            Log.w(LOG_TAG, ""Backbuffer cannot be preserved"");
        }
    } else if (sDirtyRegionsRequested) {
        // If mDirtyRegions is not set, our EGL configuration does not
        // have EGL_SWAP_BEHAVIOR_PRESERVED_BIT; however, the default
        // swap behavior might be EGL_BUFFER_PRESERVED, which means we
        // want to set mDirtyRegions. We try to do this only if dirty
        // regions were initially requested as part of the device
        // configuration (see RENDER_DIRTY_REGIONS)
        mDirtyRegionsEnabled = GLES20Canvas.isBackBufferPreserved();
    }
    return mEglContext.getGL();
}","{
    // Check preconditions.
    if (sEgl == null) {
        throw new RuntimeException(""egl not initialized"");
    }
    if (sEglDisplay == null) {
        throw new RuntimeException(""eglDisplay not initialized"");
    }
    if (sEglConfig == null) {
        throw new RuntimeException(""eglConfig not initialized"");
    }
    if (Thread.currentThread() != mEglThread) {
        throw new IllegalStateException(""HardwareRenderer cannot be used "" + ""from multiple threads"");
    }
    // In case we need to destroy an existing surface
    destroySurface();
    // Create an EGL surface we can render into.
    if (!createSurface(holder)) {
        return null;
    }
    /*
             * Before we can issue GL commands, we need to make sure
             * the context is current and bound to a surface.
             */
    if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
        throw new Surface.OutOfResourcesException(""eglMakeCurrent failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
    }
    initCaches();
    // with EGL_SWAP_BEHAVIOR_PRESERVED_BIT set
    if (sDirtyRegions) {
        if (!(mDirtyRegionsEnabled = GLES20Canvas.preserveBackBuffer())) {
            Log.w(LOG_TAG, ""Backbuffer cannot be preserved"");
        }
    } else if (sDirtyRegionsRequested) {
        // If mDirtyRegions is not set, our EGL configuration does not
        // have EGL_SWAP_BEHAVIOR_PRESERVED_BIT; however, the default
        // swap behavior might be EGL_BUFFER_PRESERVED, which means we
        // want to set mDirtyRegions. We try to do this only if dirty
        // regions were initially requested as part of the device
        // configuration (see RENDER_DIRTY_REGIONS)
        mDirtyRegionsEnabled = GLES20Canvas.isBackBufferPreserved();
    }
    return mEglContext.getGL();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method named `initCaches()` is introduced in the late version which doesn't affect the return statement, change exception handling nor change control dependency. So the code change type is 4.","The new method `initCaches`() introduced doesn't affect the behaviour of the API because it does not change the return value/type nor throws a different exception, hence, it's safe to say that there is no CI exists, so the CI type is 0."
127,<android.view.View: void removeOnAttachStateChangeListener(OnAttachStateChangeListener)>,14,15,<android.view.View: void removeOnAttachStateChangeListener(OnAttachStateChangeListener)>,<android.view.View: void removeOnAttachStateChangeListener(OnAttachStateChangeListener)>,0,"{
    if (mOnAttachStateChangeListeners == null) {
        return;
    }
    mOnAttachStateChangeListeners.remove(listener);
}","{
    ListenerInfo li = mListenerInfo;
    if (li == null || li.mOnAttachStateChangeListeners == null) {
        return;
    }
    li.mOnAttachStateChangeListeners.remove(listener);
}",1,"/**
 * Remove a listener for attach state changes. The listener will receive no further
 * notification of window attach/detach events.
 *
 * @param listener Listener to remove
 * @see #addOnAttachStateChangeListener(OnAttachStateChangeListener)
 */
","/**
 * Remove a listener for attach state changes. The listener will receive no further
 * notification of window attach/detach events.
 *
 * @param listener Listener to remove
 * @see #addOnAttachStateChangeListener(OnAttachStateChangeListener)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early version checks if 'mOnAttachStateChangeListeners' is null then immediately returns. whereas the later version checks if 'li' or 'li.mOnAttachStateChangeListeners' is null then immediately returns. Also, 'mOnAttachStateChangeListeners' has been changed to 'li.mOnAttachStateChangeListeners'. So, the code change type is 1,4.","The change of 'if' condition and variable will potentially make the API end the execution without removing the listener or remove the listener from a different object, leading to potential different behaviors. So, the CI type is 1."
128,"<android.view.SurfaceView.MyWindow: void resized(int,int,Rect,Rect,boolean,Configuration)>",14,15,"<android.view.SurfaceView.MyWindow: void resized(int,int,Rect,Rect,boolean,Configuration)>","<android.view.SurfaceView.MyWindow: void resized(int,int,Rect,Rect,boolean,Configuration)>",0,"{
    SurfaceView surfaceView = mSurfaceView.get();
    if (surfaceView != null) {
        if (localLOGV)
            Log.v(""SurfaceView"", surfaceView + "" got resized: w="" + w + "" h="" + h + "", cur w="" + mCurWidth + "" h="" + mCurHeight);
        surfaceView.mSurfaceLock.lock();
        try {
            if (reportDraw) {
                surfaceView.mUpdateWindowNeeded = true;
                surfaceView.mReportDrawNeeded = true;
                surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
            } else if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
                surfaceView.mUpdateWindowNeeded = true;
                surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
            }
        } finally {
            surfaceView.mSurfaceLock.unlock();
        }
    }
}","{
    SurfaceView surfaceView = mSurfaceView.get();
    if (surfaceView != null) {
        if (DEBUG)
            Log.v(""SurfaceView"", surfaceView + "" got resized: w="" + w + "" h="" + h + "", cur w="" + mCurWidth + "" h="" + mCurHeight);
        surfaceView.mSurfaceLock.lock();
        try {
            if (reportDraw) {
                surfaceView.mUpdateWindowNeeded = true;
                surfaceView.mReportDrawNeeded = true;
                surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
            } else if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
                surfaceView.mUpdateWindowNeeded = true;
                surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
            }
        } finally {
            surfaceView.mSurfaceLock.unlock();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable localLOGV has been replaced by DEBUG in the log statement. Therefore, the change type is 4.","Since the change is only about the log statement and doesn't affect how API behaves (return value or exception handling), there is no compatibility issue (CI type is 0)."
129,<android.view.View: void removeOnLayoutChangeListener(OnLayoutChangeListener)>,14,15,<android.view.View: void removeOnLayoutChangeListener(OnLayoutChangeListener)>,<android.view.View: void removeOnLayoutChangeListener(OnLayoutChangeListener)>,0,"{
    if (mOnLayoutChangeListeners == null) {
        return;
    }
    mOnLayoutChangeListeners.remove(listener);
}","{
    ListenerInfo li = mListenerInfo;
    if (li == null || li.mOnLayoutChangeListeners == null) {
        return;
    }
    li.mOnLayoutChangeListeners.remove(listener);
}",1,"/**
 * Remove a listener for layout changes.
 *
 * @param listener The listener for layout bounds change.
 */
","/**
 * Remove a listener for layout changes.
 *
 * @param listener The listener for layout bounds change.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the way listeners are accessed and removed. In the early version, it directly accesses the mOnLayoutChangeListeners and removes the listener. In the late version, it accesses the listener via ListenerInfo object. So, it's class 4 - Other statement changed.","Even though the listener is accessed differently, it is still the same listener which is being removed. Hence, the result of this method (removing a listener) doesn't change. So, there are no compatibility issues."
132,"<android.widget.TextView.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",14,15,"<android.widget.TextView.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>","<android.widget.TextView.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",0,"{
    TextView textView = (TextView) view;
    Editable editable = (Editable) mText;
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
        int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
        if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
            // Do not leave two adjacent spaces after deletion, or one at beginning of text
            if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                spanUnionEnd = spanUnionEnd + 1;
            }
            editable.replace(spanUnionStart, spanUnionEnd, """");
        }
        hide();
        return;
    }
    final int spanStart = editable.getSpanStart(suggestionInfo.suggestionSpan);
    final int spanEnd = editable.getSpanEnd(suggestionInfo.suggestionSpan);
    if (spanStart < 0 || spanEnd < 0) {
        // Span has been removed
        hide();
        return;
    }
    final String originalText = mText.toString().substring(spanStart, spanEnd);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
        intent.putExtra(""word"", originalText);
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        getContext().startActivity(intent);
        // There is no way to know if the word was indeed added. Re-check.
        editable.removeSpan(suggestionInfo.suggestionSpan);
        updateSpellCheckSpans(spanStart, spanEnd);
    } else {
        // SuggestionSpans are removed by replace: save them before
        SuggestionSpan[] suggestionSpans = editable.getSpans(spanStart, spanEnd, SuggestionSpan.class);
        final int length = suggestionSpans.length;
        int[] suggestionSpansStarts = new int[length];
        int[] suggestionSpansEnds = new int[length];
        int[] suggestionSpansFlags = new int[length];
        for (int i = 0; i < length; i++) {
            final SuggestionSpan suggestionSpan = suggestionSpans[i];
            suggestionSpansStarts[i] = editable.getSpanStart(suggestionSpan);
            suggestionSpansEnds[i] = editable.getSpanEnd(suggestionSpan);
            suggestionSpansFlags[i] = editable.getSpanFlags(suggestionSpan);
        }
        final int suggestionStart = suggestionInfo.suggestionStart;
        final int suggestionEnd = suggestionInfo.suggestionEnd;
        final String suggestion = textView.getText().subSequence(suggestionStart, suggestionEnd).toString();
        editable.replace(spanStart, spanEnd, suggestion);
        suggestionInfo.removeMisspelledFlag();
        // Notify source IME of the suggestion pick. Do this before swaping texts.
        if (!TextUtils.isEmpty(suggestionInfo.suggestionSpan.getNotificationTargetClassName())) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null) {
                imm.notifySuggestionPicked(suggestionInfo.suggestionSpan, originalText, suggestionInfo.suggestionIndex);
            }
        }
        // Swap text content between actual text and Suggestion span
        String[] suggestions = suggestionInfo.suggestionSpan.getSuggestions();
        suggestions[suggestionInfo.suggestionIndex] = originalText;
        // Restore previous SuggestionSpans
        final int lengthDifference = suggestion.length() - (spanEnd - spanStart);
        for (int i = 0; i < length; i++) {
            // way to assign them a valid range after replacement
            if (suggestionSpansStarts[i] <= spanStart && suggestionSpansEnds[i] >= spanEnd) {
                editable.setSpan(suggestionSpans[i], suggestionSpansStarts[i], suggestionSpansEnds[i] + lengthDifference, suggestionSpansFlags[i]);
            }
        }
        // Move cursor at the end of the replaced word
        Selection.setSelection(editable, spanEnd + lengthDifference);
    }
    hide();
}","{
    Editable editable = (Editable) mText;
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
        int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
        if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
            // Do not leave two adjacent spaces after deletion, or one at beginning of text
            if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                spanUnionEnd = spanUnionEnd + 1;
            }
            deleteText_internal(spanUnionStart, spanUnionEnd);
        }
        hide();
        return;
    }
    final int spanStart = editable.getSpanStart(suggestionInfo.suggestionSpan);
    final int spanEnd = editable.getSpanEnd(suggestionInfo.suggestionSpan);
    if (spanStart < 0 || spanEnd <= spanStart) {
        // Span has been removed
        hide();
        return;
    }
    final String originalText = mText.toString().substring(spanStart, spanEnd);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
        intent.putExtra(""word"", originalText);
        intent.putExtra(""locale"", getTextServicesLocale().toString());
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        getContext().startActivity(intent);
        // There is no way to know if the word was indeed added. Re-check.
        // TODO The ExtractEditText should remove the span in the original text instead
        editable.removeSpan(suggestionInfo.suggestionSpan);
        updateSpellCheckSpans(spanStart, spanEnd, false);
    } else {
        // SuggestionSpans are removed by replace: save them before
        SuggestionSpan[] suggestionSpans = editable.getSpans(spanStart, spanEnd, SuggestionSpan.class);
        final int length = suggestionSpans.length;
        int[] suggestionSpansStarts = new int[length];
        int[] suggestionSpansEnds = new int[length];
        int[] suggestionSpansFlags = new int[length];
        for (int i = 0; i < length; i++) {
            final SuggestionSpan suggestionSpan = suggestionSpans[i];
            suggestionSpansStarts[i] = editable.getSpanStart(suggestionSpan);
            suggestionSpansEnds[i] = editable.getSpanEnd(suggestionSpan);
            suggestionSpansFlags[i] = editable.getSpanFlags(suggestionSpan);
            // Remove potential misspelled flags
            int suggestionSpanFlags = suggestionSpan.getFlags();
            if ((suggestionSpanFlags & SuggestionSpan.FLAG_MISSPELLED) > 0) {
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_MISSPELLED;
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_EASY_CORRECT;
                suggestionSpan.setFlags(suggestionSpanFlags);
            }
        }
        final int suggestionStart = suggestionInfo.suggestionStart;
        final int suggestionEnd = suggestionInfo.suggestionEnd;
        final String suggestion = suggestionInfo.text.subSequence(suggestionStart, suggestionEnd).toString();
        replaceText_internal(spanStart, spanEnd, suggestion);
        // Notify source IME of the suggestion pick. Do this before swaping texts.
        if (!TextUtils.isEmpty(suggestionInfo.suggestionSpan.getNotificationTargetClassName())) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null) {
                imm.notifySuggestionPicked(suggestionInfo.suggestionSpan, originalText, suggestionInfo.suggestionIndex);
            }
        }
        // Swap text content between actual text and Suggestion span
        String[] suggestions = suggestionInfo.suggestionSpan.getSuggestions();
        suggestions[suggestionInfo.suggestionIndex] = originalText;
        // Restore previous SuggestionSpans
        final int lengthDifference = suggestion.length() - (spanEnd - spanStart);
        for (int i = 0; i < length; i++) {
            // way to assign them a valid range after replacement
            if (suggestionSpansStarts[i] <= spanStart && suggestionSpansEnds[i] >= spanEnd) {
                setSpan_internal(suggestionSpans[i], suggestionSpansStarts[i], suggestionSpansEnds[i] + lengthDifference, suggestionSpansFlags[i]);
            }
        }
        // Move cursor at the end of the replaced word
        final int newCursorPosition = spanEnd + lengthDifference;
        setCursorPosition_internal(newCursorPosition, newCursorPosition);
    }
    hide();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The function ""editable.replace(spanUnionStart, spanUnionEnd, """")"" has been replaced with ""deleteText_internal(spanUnionStart, spanUnionEnd)"", and the function ""editable.replace(spanStart, spanEnd, suggestion)"" has been replaced with ""replaceText_internal(spanStart, spanEnd, suggestion)"". The condition in the second if-statment has been changed from ""spanEnd < 0"" to ""spanEnd <= spanStart"". ""TextView textView = (TextView) view"" has been removed while ""intent.putExtra(""locale"", getTextServicesLocale().toString())"", ""updateSpellCheckSpans(spanStart, spanEnd, false)"" and ""setCursorPosition_internal(newCursorPosition, newCursorPosition)"" have been added in the late version. Therefore, the code change type is 1,3,4,5.","The change of control dependency, return statements and introduction/removal of certain statements could lead to different bahaviour when the late version API is invoked, thus the CI type is 1."
133,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,14,15,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,0,"{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.onSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    return result;
}","{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.onSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        // Only add this if it's not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There are a couple of lines that were added in the late version - specifically the addition of User Visible Hint information into the bundle 'result'. Hence, the code change types are 1 and 4","The change in return statement related to adding User Visible Hint into the bundle 'result' will make the API potentially return a different value in Bundle type. Hence, the CI type is 1."
134,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,14,15,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,0,"{
    if (TextUtils.isEmpty(mText)) {
        Log.w(TAG, ""Got empty text"");
        return false;
    }
    if (mText.length() >= MAX_SPEECH_ITEM_CHAR_LENGTH) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}","{
    if (mText == null) {
        Log.wtf(TAG, ""Got null text"");
        return false;
    }
    if (mText.length() >= MAX_SPEECH_ITEM_CHAR_LENGTH) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition statement in 'if' changed from TextUtils.isEmpty(mText) to mText == null, so the code change type is 3.","Due to the change in the condition in 'if' statement, the early version will return 'false' when mText is empty or mText is null. However, the late version only returns 'false' when mText is null. So, the return value could be different between these two versions when mText is empty, so the CI type is 1."
137,<android.view.ViewGroup: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,14,15,<android.view.ViewGroup: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,<android.view.ViewGroup: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,0,"{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    // marked as the logical root of a view hierarchy, do not go any deeper.
    if ((!(getParent() instanceof ViewRootImpl)) && (mPrivateFlags & IS_ROOT_NAMESPACE) != 0) {
        return;
    }
    for (int i = 0, count = mChildrenCount; i < count; i++) {
        View child = mChildren[i];
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
            info.addChild(child);
        }
    }
}","{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    for (int i = 0, count = mChildrenCount; i < count; i++) {
        View child = mChildren[i];
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE && (child.mPrivateFlags & IS_ROOT_NAMESPACE) == 0) {
            info.addChild(child);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency, specifically one 'if' condition statement, has been removed, and a condition was added to the 'if' statement inside the 'for' loop. Additionally, the 'return' statement was deleted. Thus, the code change type is 3,4.","The removal of a 'return' statement and changes in the 'if' condition undergone in the 'for' loop could potentially lead to the method adding different children to the 'info' resulting in different outcome. Thus, the CI type is 1."
139,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",14,15,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            mDPadCenterIsDown = false;
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (mOnClickListener == null) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            mEnterKeyIsDown = false;
            if (event.hasNoModifiers()) {
                if (mInputContentType != null && mInputContentType.onEditorActionListener != null && mInputContentType.enterDown) {
                    mInputContentType.enterDown = false;
                    if (mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (mOnClickListener == null) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mInput != null)
        if (mInput.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && mSoftInputShownOnFocus) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mInputContentType != null && mInputContentType.onEditorActionListener != null && mInputContentType.enterDown) {
                    mInputContentType.enterDown = false;
                    if (mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mInput != null)
        if (mInput.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There are changes in the control dependency 'if' conditions and in some other statements within the 'case' statements. Instead of checking mOnClickListener == null, it now checks !hasOnClickListeners(). There's also a removal of mDPadCenterIsDown = false; and mEnterKeyIsDown = false; plus a change from imm != null to imm != null && mSoftInputShownOnFocus.  Thus the change type is 3 for control dependency changed and 4 for other statements changed.","As the control dependency 'if' conditions and other statements within the 'case' statements have changed, the API has a potential different behaviour when these control flows are triggered, such as returning a different value or following a different control path. Thus, the Compatibility Issue type is 1 which means potential different return values or types."
140,<android.bluetooth.BluetoothDeviceProfileState.BondedDevice: boolean processMessage(Message)>,14,15,<android.bluetooth.BluetoothDeviceProfileState.BondedDevice: boolean processMessage(Message)>,<android.bluetooth.BluetoothDeviceProfileState.BondedDevice: boolean processMessage(Message)>,0,"{
    log(""ACL Connected State -> Processing Message: "" + message.what);
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
        case DISCONNECT_HFP_OUTGOING:
            transitionTo(mOutgoingHandsfree);
            break;
        case CONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case DISCONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case CONNECT_A2DP_OUTGOING:
        case DISCONNECT_A2DP_OUTGOING:
            transitionTo(mOutgoingA2dp);
            break;
        case CONNECT_A2DP_INCOMING:
        case DISCONNECT_A2DP_INCOMING:
            transitionTo(mIncomingA2dp);
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            transitionTo(mOutgoingHid);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            transitionTo(mIncomingHid);
            break;
        case DISCONNECT_PBAP_OUTGOING:
            processCommand(DISCONNECT_PBAP_OUTGOING);
            break;
        case UNPAIR:
            if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HFP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mA2dpState != BluetoothA2dp.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_A2DP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mService.getInputDeviceConnectionState(mDevice) != BluetoothInputDevice.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HID_OUTGOING);
                deferMessage(message);
                break;
            }
            processCommand(UNPAIR);
            break;
        case AUTO_CONNECT_PROFILES:
            if (isPhoneDocked(mDevice)) {
                // Don't auto connect to docks.
                break;
            } else {
                if (mHeadsetService == null) {
                    mAutoConnectionPending = true;
                } else if (mHeadsetService.getPriority(mDevice) == BluetoothHeadset.PRIORITY_AUTO_CONNECT && mHeadsetService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mHeadsetService.connect(mDevice);
                }
                if (mA2dpService != null && mA2dpService.getPriority(mDevice) == BluetoothA2dp.PRIORITY_AUTO_CONNECT && mA2dpService.getDevicesMatchingConnectionStates(new int[] { BluetoothA2dp.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mA2dpService.connect(mDevice);
                }
                if (mService.getInputDevicePriority(mDevice) == BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
                    mService.connectInputDevice(mDevice);
                }
            }
            break;
        case CONNECT_OTHER_PROFILES:
            if (isPhoneDocked(mDevice)) {
                break;
            }
            if (message.arg1 == CONNECT_A2DP_OUTGOING) {
                if (mA2dpService != null && mA2dpService.getConnectedDevices().size() == 0) {
                    Log.i(TAG, ""A2dp:Connect Other Profiles"");
                    mA2dpService.connect(mDevice);
                }
            } else if (message.arg1 == CONNECT_HFP_OUTGOING) {
                if (mHeadsetService == null) {
                    deferMessage(message);
                } else {
                    if (mHeadsetService.getConnectedDevices().size() == 0) {
                        Log.i(TAG, ""Headset:Connect Other Profiles"");
                        mHeadsetService.connect(mDevice);
                    }
                }
            }
            break;
        case TRANSITION_TO_STABLE:
            // ignore.
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    log(""ACL Connected State -> Processing Message: "" + message.what);
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
        case DISCONNECT_HFP_OUTGOING:
            transitionTo(mOutgoingHandsfree);
            break;
        case CONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case DISCONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case CONNECT_A2DP_OUTGOING:
        case DISCONNECT_A2DP_OUTGOING:
            transitionTo(mOutgoingA2dp);
            break;
        case CONNECT_A2DP_INCOMING:
        case DISCONNECT_A2DP_INCOMING:
            transitionTo(mIncomingA2dp);
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            transitionTo(mOutgoingHid);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            transitionTo(mIncomingHid);
            break;
        case DISCONNECT_PBAP_OUTGOING:
            processCommand(DISCONNECT_PBAP_OUTGOING);
            break;
        case UNPAIR:
            if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HFP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mA2dpState != BluetoothA2dp.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_A2DP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mService.getInputDeviceConnectionState(mDevice) != BluetoothInputDevice.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HID_OUTGOING);
                deferMessage(message);
                break;
            }
            processCommand(UNPAIR);
            break;
        case AUTO_CONNECT_PROFILES:
            if (isPhoneDocked(mDevice)) {
                // Don't auto connect to docks.
                break;
            } else {
                if (mHeadsetService == null) {
                    mAutoConnectionPending = true;
                } else if (mHeadsetService.getPriority(mDevice) == BluetoothHeadset.PRIORITY_AUTO_CONNECT && mHeadsetService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mHeadsetService.connect(mDevice);
                }
                if (mA2dpService != null && mA2dpService.getPriority(mDevice) == BluetoothA2dp.PRIORITY_AUTO_CONNECT && mA2dpService.getDevicesMatchingConnectionStates(new int[] { BluetoothA2dp.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mA2dpService.connect(mDevice);
                }
                if (mService.getInputDevicePriority(mDevice) == BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
                    mService.connectInputDevice(mDevice);
                }
            }
            break;
        case CONNECT_OTHER_PROFILES:
            if (isPhoneDocked(mDevice)) {
                break;
            }
            if (message.arg1 == CONNECT_A2DP_OUTGOING) {
                if (mA2dpService != null && mA2dpService.getConnectedDevices().size() == 0) {
                    Log.i(TAG, ""A2dp:Connect Other Profiles"");
                    mA2dpService.connect(mDevice);
                }
            } else if (message.arg1 == CONNECT_HFP_OUTGOING) {
                if (mHeadsetService == null) {
                    deferMessage(message);
                } else {
                    if (mHeadsetService.getConnectedDevices().size() == 0) {
                        Log.i(TAG, ""Headset:Connect Other Profiles"");
                        mHeadsetService.connect(mDevice);
                    }
                }
            }
            break;
        case TRANSITION_TO_STABLE:
            // ignore.
            break;
        case SM_QUIT_CMD:
            mContext.unregisterReceiver(mBroadcastReceiver);
            mBroadcastReceiver = null;
            mAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mHeadsetService);
            mBluetoothProfileServiceListener = null;
            mOutgoingHandsfree = null;
            mPbap = null;
            mPbapService.close();
            mPbapService = null;
            mIncomingHid = null;
            mOutgoingHid = null;
            mIncomingHandsfree = null;
            mOutgoingHandsfree = null;
            mIncomingA2dp = null;
            mOutgoingA2dp = null;
            mBondedDevice = null;
            // is handled so return NOT_HANDLED as a workaround.
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","A new case SM_QUIT_CMD has been added inside the switch statement, which has several new control statements and other code changes, such as context unregistering and object closing. The change types are 3 for the additional control dependencies and 4 for other code changes.","The newly added case has a return NOT_HANDLED statement which is different from the typical return HANDLED statement. Thus, it's considered a potential cause for different return values, causing a change in behavior. Additionally, if an exception occurs during unregisterReceiver, closeProfileProxy, or mPbapService.close() operations in the new case, the exception handling will be different between the two versions. Thus, the CI types are both 1 and 2."
141,<android.view.View: boolean performClick()>,14,15,<android.view.View: boolean performClick()>,<android.view.View: boolean performClick()>,0,"{
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    if (mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnClickListener.onClick(this);
        return true;
    }
    return false;
}","{
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        return true;
    }
    return false;
}",1,"/**
 * Call this view's OnClickListener, if it is defined.
 *
 * @return True there was an assigned OnClickListener that was called, false
 * otherwise is returned.
 */
","/**
 * Call this view's OnClickListener, if it is defined.  Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @return True there was an assigned OnClickListener that was called, false
 * otherwise is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new variable 'li' was created and used, and the reference to 'mOnClickListener' was changed to 'li.mOnClickListener', so the code change type is 3,4.","Despite the changes made to the method, the same result will be returned based on the same input. Thus, there is no compatibility issue caused by potential different return values or types or by potential different exception handlings, and the CI type is 0."
143,<android.speech.tts.PlaybackSynthesisCallback: void stop()>,14,15,<android.speech.tts.PlaybackSynthesisCallback: void stop()>,<android.speech.tts.PlaybackSynthesisCallback: void stop()>,0,"{
    if (DBG)
        Log.d(TAG, ""stop()"");
    // Note that mLogger.mError might be true too at this point.
    mLogger.onStopped();
    SynthesisMessageParams token = null;
    synchronized (mStateLock) {
        if (mStopped) {
            Log.w(TAG, ""stop() called twice"");
            return;
        }
        // an error before it called start().
        if (mToken == null) {
            // In all other cases, mAudioTrackHandler.stop() will
            // result in onComplete being called.
            mLogger.onWriteData();
        } else {
            token = mToken;
        }
        mStopped = true;
    }
    if (token != null) {
        // This might result in the synthesis thread being woken up, at which
        // point it will write an additional buffer to the token - but we
        // won't worry about that because the audio playback queue will be cleared
        // soon after (see SynthHandler#stop(String).
        token.clearBuffers();
    }
}","{
    stopImpl(false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has been completely changed from a detailed one to a simple one line method call of stopImpl(false). Therefore, the code change types are 1 (Return Statements Changed) and 5 (Dependent API Changed).","The change in implementation can potentially lead to different behaviours of the method in the late version compared to the early version. Therefore, a Compatibility Issue exists which is caused by potential different return values (Type 1)."
146,<android.hardware.Camera.Parameters: void setWhiteBalance(String)>,14,15,<android.hardware.Camera.Parameters: void setWhiteBalance(String)>,<android.hardware.Camera.Parameters: void setWhiteBalance(String)>,0,"{
    set(KEY_WHITE_BALANCE, value);
    set(KEY_AUTO_WHITEBALANCE_LOCK, FALSE);
}","{
    String oldValue = get(KEY_WHITE_BALANCE);
    if (same(value, oldValue))
        return;
    set(KEY_WHITE_BALANCE, value);
    set(KEY_AUTO_WHITEBALANCE_LOCK, FALSE);
}",1,"/**
 * Sets the white balance. Changing the setting will release the
 * auto-white balance lock.
 *
 * @param value new white balance.
 * @see #getWhiteBalance()
 * @see #setAutoWhiteBalanceLock(boolean)
 */
","/**
 * Sets the white balance. Changing the setting will release the
 * auto-white balance lock. It is recommended not to change white
 * balance and AWB lock at the same time.
 *
 * @param value new white balance.
 * @see #getWhiteBalance()
 * @see #setAutoWhiteBalanceLock(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The late version introduces a new return statement and changes control dependency with a 'if' statement. So the code change type is 1,3.","The introduction of a new 'return' statement in the late version can affect the method execution and potentially lead to a different value returned by the method, so the CI type is 1."
148,<android.widget.SearchView: void onActionViewExpanded()>,14,15,<android.widget.SearchView: void onActionViewExpanded()>,<android.widget.SearchView: void onActionViewExpanded()>,0,"{
    mExpandedInActionView = true;
    mCollapsedImeOptions = mQueryTextView.getImeOptions();
    mQueryTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    setIconified(false);
}","{
    if (mExpandedInActionView)
        return;
    mExpandedInActionView = true;
    mCollapsedImeOptions = mQueryTextView.getImeOptions();
    mQueryTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    mQueryTextView.setText("""");
    setIconified(false);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement and a new assignment line of code (mQueryTextView.setText("""")) were introduced in the late version. Hence, the change type is 1,3.","The introduction of a new return statement and the change in assignment could potentially lead the API to different behaviors, thereby causing a Compatibility Issue (CI); thus, the CI type is 1."
151,<android.widget.NumberPicker: void setMaxValue(int)>,14,15,<android.widget.NumberPicker: void setMaxValue(int)>,<android.widget.NumberPicker: void setMaxValue(int)>,0,"{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
}","{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
}",1,"/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value.
 */
","/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,A new method call `tryComputeMaxWidth();` has been added at the end of the method so the code change type is 4.,"The addition of the method call `tryComputeMaxWidth();` doesn't result in an observed compatibility issue based on the current API implementation. Therefore, no Compatibility Issue exists (CI type 0)."
154,<android.view.KeyCharacterMap: KeyCharacterMap load(int)>,14,15,<android.view.KeyCharacterMap: KeyCharacterMap load(int)>,<android.view.KeyCharacterMap: KeyCharacterMap load(int)>,0,"{
    synchronized (sInstances) {
        KeyCharacterMap map = sInstances.get(deviceId);
        if (map == null) {
            // might throw
            int ptr = nativeLoad(deviceId);
            map = new KeyCharacterMap(deviceId, ptr);
            sInstances.put(deviceId, map);
        }
        return map;
    }
}","{
    synchronized (sInstances) {
        KeyCharacterMap map = sInstances.get(deviceId);
        if (map == null) {
            String kcm = null;
            if (deviceId != VIRTUAL_KEYBOARD) {
                InputDevice device = InputDevice.getDevice(deviceId);
                if (device != null) {
                    kcm = device.getKeyCharacterMapFile();
                }
            }
            if (kcm == null || kcm.length() == 0) {
                kcm = ""/system/usr/keychars/Virtual.kcm"";
            }
            // might throw
            int ptr = nativeLoad(kcm);
            map = new KeyCharacterMap(deviceId, ptr);
            sInstances.put(deviceId, map);
        }
        return map;
    }
}",1,"/**
 * Loads the key character maps for the keyboard with the specified device id.
 *
 * @param deviceId The device id of the keyboard.
 * @return The associated key character map.
 * @throws {@link UnavailableException} if the key character map
 * could not be loaded because it was malformed or the default key character map
 * is missing from the system.
 */
","/**
 * Loads the key character maps for the keyboard with the specified device id.
 *
 * @param deviceId The device id of the keyboard.
 * @return The associated key character map.
 * @throws {@link UnavailableException} if the key character map
 * could not be loaded because it was malformed or the default key character map
 * is missing from the system.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The new code has added extra if conditions, so a control dependency change has occurred (class 3). Also, the local variable kcm is added to store the result of external method calls, which is classed as other statement changes (class 4).","While the structure of the method has changed, the outcome for both the early and late version API is the same i.e., the return type of the method has not changed and it will still return the same map object. Therefore, no compatibility issue exists (class 0)."
155,<android.app.LoaderManagerImpl: void destroyLoader(int)>,14,15,<android.app.LoaderManagerImpl: void destroyLoader(int)>,<android.app.LoaderManagerImpl: void destroyLoader(int)>,0,"{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    if (DEBUG)
        Log.v(TAG, ""destroyLoader in "" + this + "" of "" + id);
    int idx = mLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mLoaders.valueAt(idx);
        mLoaders.removeAt(idx);
        info.destroy();
    }
    idx = mInactiveLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mInactiveLoaders.valueAt(idx);
        mInactiveLoaders.removeAt(idx);
        info.destroy();
    }
}","{
    if (mCreatingLoader) {
        throw new IllegalStateException(""Called while creating a loader"");
    }
    if (DEBUG)
        Log.v(TAG, ""destroyLoader in "" + this + "" of "" + id);
    int idx = mLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mLoaders.valueAt(idx);
        mLoaders.removeAt(idx);
        info.destroy();
    }
    idx = mInactiveLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mInactiveLoaders.valueAt(idx);
        mInactiveLoaders.removeAt(idx);
        info.destroy();
    }
    if (mActivity != null && !hasRunningLoaders()) {
        mActivity.mFragments.startPendingDeferredFragments();
    }
}",1,"/**
 * Rip down, tear apart, shred to pieces a current Loader ID.  After returning
 * from this function, any Loader objects associated with this ID are
 * destroyed.  Any data associated with them is destroyed.  You better not
 * be using it when you do this.
 * @param id Identifier of the Loader to be destroyed.
 */
","/**
 * Rip down, tear apart, shred to pieces a current Loader ID.  After returning
 * from this function, any Loader objects associated with this ID are
 * destroyed.  Any data associated with them is destroyed.  You better not
 * be using it when you do this.
 * @param id Identifier of the Loader to be destroyed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There's a new if condition in the late version, which checks if (mActivity != null && !hasRunningLoaders()). If both conditions are true, a new method startPendingDeferredFragments() is executed on mActivity.mFragments. This means the change types are 3 (Control dependency change) and 4 (Other statement changed).","Despite the fact that new operations are carried out in the late version of the API, they are unlikely to affect the outcome of the method or produce different exceptions. The method's behavior remains fairly consistent between the two versions. Hence, there's no Compatibility Issue (0)."
156,<android.view.View: HardwareLayer getHardwareLayer()>,14,15,<android.view.View: HardwareLayer getHardwareLayer()>,<android.view.View: HardwareLayer getHardwareLayer()>,0,"{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {
        return null;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.setEmpty();
        } else if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
            mHardwareLayer.resize(width, height);
            mLocalDirtyRect.setEmpty();
        }
        HardwareCanvas currentCanvas = mAttachInfo.mHardwareCanvas;
        final HardwareCanvas canvas = mHardwareLayer.start(currentCanvas);
        mAttachInfo.mHardwareCanvas = canvas;
        try {
            canvas.setViewport(width, height);
            canvas.onPreDraw(mLocalDirtyRect);
            mLocalDirtyRect.setEmpty();
            final int restoreCount = canvas.save();
            computeScroll();
            canvas.translate(-mScrollX, -mScrollY);
            mPrivateFlags |= DRAWN | DRAWING_CACHE_VALID;
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                mPrivateFlags &= ~DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
            canvas.restoreToCount(restoreCount);
        } finally {
            canvas.onPostDraw();
            mHardwareLayer.end(currentCanvas);
            mAttachInfo.mHardwareCanvas = currentCanvas;
        }
    }
    return mHardwareLayer;
}","{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {
        return null;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.setEmpty();
        } else if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
            mHardwareLayer.resize(width, height);
            mLocalDirtyRect.setEmpty();
        }
        // The layer is not valid if the underlying GPU resources cannot be allocated
        if (!mHardwareLayer.isValid()) {
            return null;
        }
        HardwareCanvas currentCanvas = mAttachInfo.mHardwareCanvas;
        final HardwareCanvas canvas = mHardwareLayer.start(currentCanvas);
        // Make sure all the GPU resources have been properly allocated
        if (canvas == null) {
            mHardwareLayer.end(currentCanvas);
            return null;
        }
        mAttachInfo.mHardwareCanvas = canvas;
        try {
            canvas.setViewport(width, height);
            canvas.onPreDraw(mLocalDirtyRect);
            mLocalDirtyRect.setEmpty();
            final int restoreCount = canvas.save();
            computeScroll();
            canvas.translate(-mScrollX, -mScrollY);
            mPrivateFlags |= DRAWN | DRAWING_CACHE_VALID;
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                mPrivateFlags &= ~DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
            canvas.restoreToCount(restoreCount);
        } finally {
            canvas.onPostDraw();
            mHardwareLayer.end(currentCanvas);
            mAttachInfo.mHardwareCanvas = currentCanvas;
        }
    }
    return mHardwareLayer;
}",1,"/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
","/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There are new return statement 'return null' under two new if conditions, which are '!mHardwareLayer.isValid()' and 'canvas == null', so the code change type is 1,3.","The late version introduces new return points under new control conditions that makes the API potentially return a different value. As a result, the CI type is 1."
159,<android.view.View: boolean performLongClick()>,14,15,<android.view.View: boolean performLongClick()>,<android.view.View: boolean performLongClick()>,0,"{
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
    boolean handled = false;
    if (mOnLongClickListener != null) {
        handled = mOnLongClickListener.onLongClick(View.this);
    }
    if (!handled) {
        handled = showContextMenu();
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return handled;
}","{
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
    boolean handled = false;
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnLongClickListener != null) {
        handled = li.mOnLongClickListener.onLongClick(View.this);
    }
    if (!handled) {
        handled = showContextMenu();
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return handled;
}",1,"/**
 * Call this view's OnLongClickListener, if it is defined. Invokes the context menu if the
 * OnLongClickListener did not consume the event.
 *
 * @return True if one of the above receivers consumed the event, false otherwise.
 */
","/**
 * Call this view's OnLongClickListener, if it is defined. Invokes the context menu if the
 * OnLongClickListener did not consume the event.
 *
 * @return True if one of the above receivers consumed the event, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"Some variables in the implementation changed from 'mOnLongClickListener' to 'li.mOnLongClickListener', and a new variable 'li' was introduced. The change is classified as 'Other statement changed' and 'Dependent API changed'.","With the change of the variables used and the introduction of the new variable 'li', the return value of 'handled' could be potentially affected, leading to a different return value. Therefore, the type of Compatibility Issue is 'Compatibility Issue caused by potential different return values'."
161,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>",14,15,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>","<android.webkit.WebView: boolean showFindDialog(String,boolean)>",0,"{
    checkThread();
    FindActionModeCallback callback = new FindActionModeCallback(mContext);
    if (getParent() == null || startActionMode(callback) == null) {
        // Could not start the action mode, so end Find on page
        return false;
    }
    mFindCallback = callback;
    setFindIsUp(true);
    mFindCallback.setWebView(this);
    if (showIme) {
        mFindCallback.showSoftInput();
    } else if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
        return true;
    }
    if (text == null) {
        text = mLastFind;
    }
    if (text != null) {
        mFindCallback.setText(text);
    }
    return true;
}","{
    checkThread();
    FindActionModeCallback callback = new FindActionModeCallback(mContext);
    if (getParent() == null || startActionMode(callback) == null) {
        // Could not start the action mode, so end Find on page
        return false;
    }
    mCachedOverlappingActionModeHeight = -1;
    mFindCallback = callback;
    setFindIsUp(true);
    mFindCallback.setWebView(this);
    if (showIme) {
        mFindCallback.showSoftInput();
    } else if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
        return true;
    }
    if (text == null) {
        text = mLastFind;
    }
    if (text != null) {
        mFindCallback.setText(text);
    }
    return true;
}",1,"/**
 * Start an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 * @param text If non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme If true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return boolean True if the find dialog is shown, false otherwise.
 */
","/**
 * Start an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 * @param text If non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme If true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return boolean True if the find dialog is shown, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement 'mCachedOverlappingActionModeHeight = -1;' is added, so the change type is 4.","The value assignment to the new variable 'mCachedOverlappingActionModeHeight' doesn't affect the return values or the exception handling of the method, so there is no existing Compatibility Issue in the given situation, hence the CI type is 0."
162,"<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>",14,15,"<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>","<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>",0,"{
    if (globalSearch) {
        startGlobalSearch(initialQuery, selectInitialQuery, appSearchData);
        return;
    }
    ensureSearchDialog();
    mSearchDialog.show(initialQuery, selectInitialQuery, launchActivity, appSearchData);
}","{
    startSearch(initialQuery, selectInitialQuery, launchActivity, appSearchData, globalSearch, null);
}",1,"/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */
","/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation of the method uses a condition check to call different methods accordingly, while the late implementation has removed the conditional check and directly invokes the startSearch() method. Hence, the code change type is 1 (return statement changed) and 4 (other statement changed).","With the transformation of the method's implementation, the return type might potentially be different, especially when the globalSearch value is true. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
164,<android.database.AbstractCursor: int getType(int)>,14,15,<android.database.AbstractCursor: int getType(int)>,<android.database.AbstractCursor: int getType(int)>,0,"{
    throw new UnsupportedOperationException();
}","{
    // getString to retrieve them.
    return FIELD_TYPE_STRING;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","The `throw` statement has been deleted and a new return statement `return FIELD_TYPE_STRING;` has been added, so the code change type is both 1 (Return statement changed) and 2 (Exception handling statement changed).","The early version of the function always throws an exception, while the updated function returns a constant value. This significant change in behavior could lead to the API potentially returning a different value and handling exceptions differently, which means the CI type is both 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
165,<android.view.View: void buildLayer()>,14,15,<android.view.View: void buildLayer()>,<android.view.View: void buildLayer()>,0,"{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    if (mAttachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            getHardwareLayer();
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}","{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    if (mAttachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate()) {
                getHardwareLayer();
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}",1,"/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
","/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The condition to execute the code 'getHardwareLayer()' has been updated in the late version. This modification is categorized as a Control Dependency Change (type 3).,"The additional condition could alter the behaviour of the method, specifically it may prevent 'getHardwareLayer()' from being called, which directly affects the method's return status. This may cause a Compatibility Issue of type 1 (potential different return values or types)."
166,"<android.service.textservice.SpellCheckerService.InternalISpellCheckerSession: void onGetSuggestionsMultiple(TextInfo[],int,boolean)>",14,15,"<android.service.textservice.SpellCheckerService.InternalISpellCheckerSession: void onGetSuggestionsMultiple(TextInfo[],int,boolean)>","<android.service.textservice.SpellCheckerService.InternalISpellCheckerSession: void onGetSuggestionsMultiple(TextInfo[],int,boolean)>",0,"{
    try {
        mListener.onGetSuggestions(mSession.onGetSuggestionsMultiple(textInfos, suggestionsLimit, sequentialWords));
    } catch (RemoteException e) {
    }
}","{
    int pri = Process.getThreadPriority(Process.myTid());
    try {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        mListener.onGetSuggestions(mSession.onGetSuggestionsMultiple(textInfos, suggestionsLimit, sequentialWords));
    } catch (RemoteException e) {
    } finally {
        Process.setThreadPriority(pri);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There are two new statements introduced in the late version, which are to set the thread priority, so the code change type is: 4.","The changes made in thread priority do not affect the return value nor change the exception handling mechanism. Hence, there is no compatibility issue. The CI type is: 0."
167,<android.server.BluetoothAdapterStateMachine.HotOff: boolean processMessage(Message)>,14,15,<android.server.BluetoothAdapterStateMachine.HotOff: boolean processMessage(Message)>,<android.server.BluetoothAdapterStateMachine.HotOff: boolean processMessage(Message)>,0,"{
    log(""HotOff process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            if ((Boolean) message.obj) {
                persistSwitchSetting(true);
            }
        // $FALL-THROUGH$
        case TURN_ON_CONTINUE:
            mBluetoothService.switchConnectable(true);
            transitionTo(mSwitching);
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            break;
        case AIRPLANE_MODE_ON:
        case TURN_COLD:
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                transitionTo(mSwitching);
                mBluetoothService.switchConnectable(true);
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            }
            break;
        case PER_PROCESS_TURN_ON:
            transitionTo(mPerProcessState);
            // Resend the PER_PROCESS_TURN_ON message so that the callback
            // can be sent through.
            deferMessage(message);
            mBluetoothService.switchConnectable(true);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case // ignore
        USER_TURN_OFF:
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                recoverStateMachine(TURN_HOT, null);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}","{
    log(""HotOff process message: "" + message.what);
    boolean retValue = HANDLED;
    switch(message.what) {
        case USER_TURN_ON:
            broadcastState(BluetoothAdapter.STATE_TURNING_ON);
            if ((Boolean) message.obj) {
                persistSwitchSetting(true);
            }
        // $FALL-THROUGH$
        case TURN_ON_CONTINUE:
            mBluetoothService.switchConnectable(true);
            transitionTo(mSwitching);
            break;
        case AIRPLANE_MODE_ON:
        case TURN_COLD:
            shutoffBluetooth();
            transitionTo(mPowerOff);
            broadcastState(BluetoothAdapter.STATE_OFF);
            break;
        case AIRPLANE_MODE_OFF:
            if (getBluetoothPersistedSetting()) {
                broadcastState(BluetoothAdapter.STATE_TURNING_ON);
                transitionTo(mSwitching);
                mBluetoothService.switchConnectable(true);
            }
            break;
        case PER_PROCESS_TURN_ON:
            transitionTo(mPerProcessState);
            // Resend the PER_PROCESS_TURN_ON message so that the callback
            // can be sent through.
            deferMessage(message);
            mBluetoothService.switchConnectable(true);
            break;
        case PER_PROCESS_TURN_OFF:
            perProcessCallback(false, (IBluetoothStateChangeCallback) message.obj);
            break;
        case // ignore
        USER_TURN_OFF:
            break;
        case POWER_STATE_CHANGED:
            if ((Boolean) message.obj) {
                recoverStateMachine(TURN_HOT, null);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return retValue;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the switch cases for USER_TURN_ON, TURN_ON_CONTINUE, AIRPLANE_MODE_OFF and PER_PROCESS_TURN_ON, there are changes in the operations performed and sequence of method calls. So, the code change falls under the categories 3 (Control dependency changed) and 4 (Other statement changed).","The order and conditions under which certain methods are invoked have changed, which can potentially lead to differences in the API's behavior. The return value of the API could potentially be affected by these changes in internal operations, therefore the CI type is 1."
169,<android.view.InputDevice: String toString()>,14,15,<android.view.InputDevice: String toString()>,<android.view.InputDevice: String toString()>,0,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Key Character Map: "").append(mKeyCharacterMapFile).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There is one additional line in the late version implementation which is 'description.append(""  Key Character Map: "").append(mKeyCharacterMapFile).append(""\n"");'. So, the code change type is 1 (Return statement changed).","Since there is an additional line of code appending to the 'description', the final return value of 'description.toString()' may be different in the late version. Thus, the compatibility issue type is 1 (Compatibility Issue caused by potential different return values or types)."
171,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter()>,14,15,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter()>,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter()>,0,"{
    Log.w(TAG, ""WARNING: NfcAdapter.getDefaultAdapter() is deprecated, use "" + ""NfcAdapter.getDefaultAdapter(Context) instead"", new Exception());
    return getSingleton();
}","{
    Log.w(TAG, ""WARNING: NfcAdapter.getDefaultAdapter() is deprecated, use "" + ""NfcAdapter.getDefaultAdapter(Context) instead"", new Exception());
    return NfcAdapter.getNfcAdapter(null);
}",1,"/**
 * Get a handle to the default NFC Adapter on this Android device.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 * @deprecated use {@link #getDefaultAdapter(Context)}
 */
","/**
 * Legacy NfcAdapter getter, always use {@link #getDefaultAdapter(Context)} instead.<p>
 * This method was deprecated at API level 10 (Gingerbread MR1) because a context is required
 * for many NFC API methods. Those methods will fail when called on an NfcAdapter
 * object created from this method.<p>
 * @deprecated use {@link #getDefaultAdapter(Context)}
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"There is a change in the return statement, trading getSingleton() for NfcAdapter.getNfcAdapter(null), and also a dependent API (singleton) has been replaced by NfcAdapter.getNfcAdapter(null), so the code change type is 1,5.","Since the return statement changes, the API potentially returns a different value, therefore a Compatibility Issue of type 1 could exist."
172,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,14,15,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,0,"{
    /* use getSystemService() instead of just instantiating to take
         * advantage of the context's cached NfcManager & NfcAdapter */
    NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
    return manager.getDefaultAdapter();
}","{
    if (context == null) {
        throw new IllegalArgumentException(""context cannot be null"");
    }
    context = context.getApplicationContext();
    /* use getSystemService() instead of just instantiating to take
         * advantage of the context's cached NfcManager & NfcAdapter */
    NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
    if (manager == null) {
        // NFC not available
        return null;
    }
    return manager.getDefaultAdapter();
}",1,"/**
 * Helper to get the default NFC Adapter.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 * <p>
 * This helper is the equivalent of:
 * <pre>{@code
 * NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
 * NfcAdapter adapter = manager.getDefaultAdapter();
 * }</pre>
 * @param context the calling application's context
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 */
","/**
 * Helper to get the default NFC Adapter.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 * <p>
 * This helper is the equivalent of:
 * <pre>{@code
 * NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
 * NfcAdapter adapter = manager.getDefaultAdapter();
 * }</pre>
 * @param context the calling application's context
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","In the late implementation, if the context is null, an exception will be thrown. If the manager is null, null will be returned. The condition of the while loop has now changed, so the code change is of types 1,2,3.","The addition of new return and throw statements might cause the API to behave differently. Hence, the compatibility issue is of type 1,2."
173,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,14,15,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    // noinspection SimplifiableIfStatement
    if (mOnHoverListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnHoverListener.onHover(this, event)) {
        return true;
    }
    return onHoverEvent(event);
}","{
    // noinspection SimplifiableIfStatement
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnHoverListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnHoverListener.onHover(this, event)) {
        return true;
    }
    return onHoverEvent(event);
}",1,"/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"In the Early_Version, the 'mOnHoverListener' is directly called. In the Late_Version, a new object 'li' (of ListenerInfo type) is introduced, and the 'mOnHoverListener' is called through 'li' (li.mOnHoverListener), so the code change type is 4.","Since the way that the 'mOnHoverListener' is called has changed, it could potentially change the behaviour of this API, especially when the mListenerInfo is manipulated before calling this API. Therefore, the CI type is 1."
175,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,14,15,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,0,"{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    mEglContext = sEglContextStorage.get();
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(mEglContext);
    }
}","{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    Gl20Renderer.Gl20RendererEglContext managedContext = sEglContextStorage.get();
    mEglContext = managedContext != null ? managedContext.getContext() : null;
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(new Gl20Renderer.Gl20RendererEglContext(mEglContext));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"One new line has been added in the late version instantiation which is ""Gl20Renderer.Gl20RendererEglContext managedContext = sEglContextStorage.get();"" and  mEglContext has been modified from ""mEglContext = sEglContextStorage.get();"" to ""mEglContext = managedContext != null ? managedContext.getContext() : null;"". Thus, falls under category 4 (Other statement changed). And in line of ""sEglContextStorage.set(new Gl20Renderer.Gl20RendererEglContext(mEglContext));"", the return statement shared the context of late implementation which is a return statement change.","The change in return statement of ""sEglContextStorage.set(new Gl20Renderer.Gl20RendererEglContext(mEglContext));"" could potentially return different values, as mEglContext is set to a new value using a ternary operation and thus there is a potential for compatibility issues under category 1 (Compatibility Issue caused by potential different return values or types)."
177,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,14,15,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,<android.view.inputmethod.InputMethodManager.ControlledInputConnectionWrapper: boolean isActive()>,0,"{
    return mActive;
}","{
    return mParentInputMethodManager.mActive;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from return mActive to returning mParentInputMethodManager.mActive, and the dependent API has also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
179,<android.database.sqlite.SQLiteCursor: void finalize()>,14,15,<android.database.sqlite.SQLiteCursor: void finalize()>,<android.database.sqlite.SQLiteCursor: void finalize()>,0,"{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (StrictMode.vmSqliteObjectLeaksEnabled()) {
                int len = mQuery.mSql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (false) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (mStackTrace != null) {
                int len = mQuery.mSql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (false) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}",1,"/**
 * Release the native resources, if they haven't been released yet.
 */
","/**
 * Release the native resources, if they haven't been released yet.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency on 'if' statement has changed: the condition has changed from StrictMode.vmSqliteObjectLeaksEnabled() to mStackTrace != null, so the code change type is 3.","Although the condition in the 'if' statement has changed, but it does not affect the return value or exception handling of the API. Thus, no Compatibility Issues exist."
180,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,14,15,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,0,"{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
        // Blocking messages from webkit
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case PREVENT_DEFAULT_TIMEOUT:
            {
                // to continue handling touch events
                if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
                    cancelWebCoreTouchEvent(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY), true);
                }
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mScrollingLayer == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    mScrollingLayerRect.left += mAutoScrollX;
                    mScrollingLayerRect.top += mAutoScrollY;
                    nativeScrollLayer(mScrollingLayer, mScrollingLayerRect.left, mScrollingLayerRect.top);
                    invalidate();
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case UPDATE_SELECTION:
            {
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                    updateSelection();
                }
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // set by updateSelection()
                mInitialHitTestResult = null;
                if (mTouchMode == TOUCH_INIT_MODE) {
                    if (!getSettings().supportTouchOnly() && mPreventDefault != PREVENT_DEFAULT_YES) {
                        mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                        updateSelection();
                    } else {
                        // set to TOUCH_SHORTPRESS_MODE so that it won't
                        // trigger double tap any more
                        mTouchMode = TOUCH_SHORTPRESS_MODE;
                    }
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
                    removeTouchHighlight();
                }
                if (inFullScreenMode() || mDeferTouchProcess) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = WebViewCore.ACTION_LONGPRESS;
                    ted.mIds = new int[1];
                    ted.mIds[0] = 0;
                    ted.mPoints = new Point[1];
                    ted.mPoints[0] = new Point(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY));
                    ted.mPointsInView = new Point[1];
                    ted.mPointsInView[0] = new Point(mLastTouchX, mLastTouchY);
                    // metaState for long press is tricky. Should it be the
                    // state when the press started or when the press was
                    // released? Or some intermediary key state? For
                    // simplicity for now, we don't set it.
                    ted.mMetaState = 0;
                    ted.mReprocess = mDeferTouchProcess;
                    ted.mNativeLayer = nativeScrollableLayer(ted.mPoints[0].x, ted.mPoints[0].y, ted.mNativeLayerRect, null);
                    ted.mSequence = mTouchEventQueue.nextTouchSequence();
                    mTouchEventQueue.preQueueTouchEventData(ted);
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                doShortPress();
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || (!imm.isActive(WebView.this) && (!inEditingMode() || !imm.isActive(mWebTextView)))) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                if (msg.arg1 == 1) {
                    spawnContentScrollTo(p.x, p.y);
                } else {
                    setContentScrollTo(p.x, p.y);
                }
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case REPLACE_BASE_CONTENT:
            {
                nativeReplaceBaseContent(msg.arg1);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                setNewPicture(draw, true);
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            String drawableDir = BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR, mContext);
            nativeCreate(msg.arg1, drawableDir);
            if (mDelaySetPicture != null) {
                setNewPicture(mDelaySetPicture, true);
                mDelaySetPicture = null;
            }
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.arg2 == mTextGeneration) {
                    String text = (String) msg.obj;
                    if (null == text) {
                        text = """";
                    }
                    mWebTextView.setTextAndKeepSelection(text);
                }
            }
            break;
        case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
            displaySoftKeyboard(true);
        // fall through to UPDATE_TEXT_SELECTION_MSG_ID
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case FORM_DID_BLUR:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                hideSoftKeyboard();
            }
            break;
        case RETURN_LABEL:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setHint((String) msg.obj);
                InputMethodManager imm = InputMethodManager.peekInstance();
                // active, restart it so that its hint text is updated.
                if (imm != null && imm.isActive(mWebTextView)) {
                    imm.restartInput(mWebTextView);
                }
            }
            break;
        case UNHANDLED_NAV_KEY:
            navHandledKey(msg.arg1, 1, false, 0);
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                updateWebTextViewPosition();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case RESUME_WEBCORE_PRIORITY:
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (inFullScreenMode()) {
                break;
            }
            TouchEventData ted = (TouchEventData) msg.obj;
            if (mTouchEventQueue.enqueueTouchEvent(ted)) {
                // WebCore is responding to us; remove pending timeout.
                // It will be re-posted when needed.
                removeMessages(PREVENT_DEFAULT_TIMEOUT);
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case FIND_AGAIN:
            // Ignore if find has been dismissed.
            if (mFindIsUp && mFindCallback != null) {
                mFindCallback.findAll();
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
        case AWAKEN_SCROLL_BARS:
            if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
                awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS), ViewConfiguration.getScrollDefaultDelay());
            }
            break;
        case DO_MOTION_UP:
            doMotionUp(msg.arg1, msg.arg2);
            break;
        case SCREEN_ON:
            setKeepScreenOn(msg.arg1 == 1);
            break;
        case ENTER_FULLSCREEN_VIDEO:
            int layerId = msg.arg1;
            String url = (String) msg.obj;
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.enterFullScreenVideo(layerId, url);
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int orientation = msg.arg1;
                int npp = msg.arg2;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebView.this, orientation, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.show();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case DOM_FOCUS_CHANGED:
            if (inEditingMode()) {
                nativeClearCursor();
                rebuildWebTextView();
            }
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int x = mScrollX;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                if (width < viewWidth) {
                    // center align
                    x += left + width / 2 - mScrollX - viewWidth / 2;
                } else {
                    x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
                }
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeightImpl());
                scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case SELECTION_STRING_CHANGED:
            if (mAccessibilityInjector != null) {
                String selectionString = (String) msg.obj;
                mAccessibilityInjector.onSelectionStringChange(selectionString);
            }
            break;
        case SET_TOUCH_HIGHLIGHT_RECTS:
            @SuppressWarnings(""unchecked"") ArrayList<Rect> rects = (ArrayList<Rect>) msg.obj;
            setTouchHighlightRects(rects);
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mWebTextView != null) {
                mWebTextView.setAutoFillable(mAutoFillData.getQueryId());
                rebuildWebTextView();
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mWebTextView != null) {
                // Clear the WebTextView adapter when AutoFill finishes
                // so that the drop down gets cleared.
                mWebTextView.setAdapterCustom(null);
            }
            break;
        case SELECT_AT:
            nativeSelectAt(msg.arg1, msg.arg2);
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
        // Blocking messages from webkit
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case PREVENT_DEFAULT_TIMEOUT:
            {
                // to continue handling touch events
                if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
                    cancelWebCoreTouchEvent(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY), true);
                }
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mCurrentScrollingLayerId == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    scrollLayerTo(mScrollingLayerRect.left + mAutoScrollX, mScrollingLayerRect.top + mAutoScrollY);
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case UPDATE_SELECTION:
            {
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                    updateSelection();
                }
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // set by updateSelection()
                mInitialHitTestResult = null;
                if (mTouchMode == TOUCH_INIT_MODE) {
                    if (!getSettings().supportTouchOnly() && mPreventDefault != PREVENT_DEFAULT_YES) {
                        mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                        updateSelection();
                    } else {
                        // set to TOUCH_SHORTPRESS_MODE so that it won't
                        // trigger double tap any more
                        mTouchMode = TOUCH_SHORTPRESS_MODE;
                    }
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
                    removeTouchHighlight();
                }
                if (inFullScreenMode() || mDeferTouchProcess) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = WebViewCore.ACTION_LONGPRESS;
                    ted.mIds = new int[1];
                    ted.mIds[0] = 0;
                    ted.mPoints = new Point[1];
                    ted.mPoints[0] = new Point(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY));
                    ted.mPointsInView = new Point[1];
                    ted.mPointsInView[0] = new Point(mLastTouchX, mLastTouchY);
                    // metaState for long press is tricky. Should it be the
                    // state when the press started or when the press was
                    // released? Or some intermediary key state? For
                    // simplicity for now, we don't set it.
                    ted.mMetaState = 0;
                    ted.mReprocess = mDeferTouchProcess;
                    ted.mNativeLayer = nativeScrollableLayer(ted.mPoints[0].x, ted.mPoints[0].y, ted.mNativeLayerRect, null);
                    ted.mSequence = mTouchEventQueue.nextTouchSequence();
                    mTouchEventQueue.preQueueTouchEventData(ted);
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                doShortPress();
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || (!imm.isActive(WebView.this) && (!inEditingMode() || !imm.isActive(mWebTextView)))) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                if (msg.arg1 == 1) {
                    spawnContentScrollTo(p.x, p.y);
                } else {
                    setContentScrollTo(p.x, p.y);
                }
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case UPDATE_ZOOM_DENSITY:
            {
                final float density = (Float) msg.obj;
                mZoomManager.updateDefaultZoomDensity(density);
                break;
            }
        case REPLACE_BASE_CONTENT:
            {
                nativeReplaceBaseContent(msg.arg1);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                setNewPicture(draw, true);
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            String drawableDir = BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR, mContext);
            WindowManager windowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
            Display display = windowManager.getDefaultDisplay();
            nativeCreate(msg.arg1, drawableDir, ActivityManager.isHighEndGfx(display));
            if (mDelaySetPicture != null) {
                setNewPicture(mDelaySetPicture, true);
                mDelaySetPicture = null;
            }
            if (mIsPaused) {
                nativeSetPauseDrawing(mNativeClass, true);
            }
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.arg2 == mTextGeneration) {
                    String text = (String) msg.obj;
                    if (null == text) {
                        text = """";
                    }
                    mWebTextView.setTextAndKeepSelection(text);
                }
            }
            break;
        case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
            displaySoftKeyboard(true);
        // fall through to UPDATE_TEXT_SELECTION_MSG_ID
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case FORM_DID_BLUR:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                hideSoftKeyboard();
            }
            break;
        case RETURN_LABEL:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setHint((String) msg.obj);
                InputMethodManager imm = InputMethodManager.peekInstance();
                // active, restart it so that its hint text is updated.
                if (imm != null && imm.isActive(mWebTextView)) {
                    imm.restartInput(mWebTextView);
                }
            }
            break;
        case UNHANDLED_NAV_KEY:
            navHandledKey(msg.arg1, 1, false, 0);
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                updateWebTextViewPosition();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (inFullScreenMode()) {
                break;
            }
            TouchEventData ted = (TouchEventData) msg.obj;
            if (mTouchEventQueue.enqueueTouchEvent(ted)) {
                // WebCore is responding to us; remove pending timeout.
                // It will be re-posted when needed.
                removeMessages(PREVENT_DEFAULT_TIMEOUT);
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case FIND_AGAIN:
            // Ignore if find has been dismissed.
            if (mFindIsUp && mFindCallback != null) {
                mFindCallback.findAll();
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
        case AWAKEN_SCROLL_BARS:
            if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
                awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS), ViewConfiguration.getScrollDefaultDelay());
            }
            break;
        case DO_MOTION_UP:
            doMotionUp(msg.arg1, msg.arg2);
            break;
        case SCREEN_ON:
            setKeepScreenOn(msg.arg1 == 1);
            break;
        case ENTER_FULLSCREEN_VIDEO:
            int layerId = msg.arg1;
            String url = (String) msg.obj;
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.enterFullScreenVideo(layerId, url);
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int orientation = msg.arg1;
                int npp = msg.arg2;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebView.this, orientation, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.show();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case DOM_FOCUS_CHANGED:
            if (inEditingMode()) {
                nativeClearCursor();
                rebuildWebTextView();
            }
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int x = mScrollX;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                if (width < viewWidth) {
                    // center align
                    x += left + width / 2 - mScrollX - viewWidth / 2;
                } else {
                    x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
                }
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeightImpl());
                scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case SELECTION_STRING_CHANGED:
            if (mAccessibilityInjector != null) {
                String selectionString = (String) msg.obj;
                mAccessibilityInjector.onSelectionStringChange(selectionString);
            }
            break;
        case SET_TOUCH_HIGHLIGHT_RECTS:
            @SuppressWarnings(""unchecked"") ArrayList<Rect> rects = (ArrayList<Rect>) msg.obj;
            setTouchHighlightRects(rects);
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mWebTextView != null) {
                mWebTextView.setAutoFillable(mAutoFillData.getQueryId());
                rebuildWebTextView();
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mWebTextView != null) {
                // Clear the WebTextView adapter when AutoFill finishes
                // so that the drop down gets cleared.
                mWebTextView.setAdapterCustom(null);
            }
            break;
        case SELECT_AT:
            nativeSelectAt(msg.arg1, msg.arg2);
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
184,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,14,15,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,0,"{
    enforceSealed();
    if (mSourceWindowId == View.NO_ID || mSourceViewId == View.NO_ID || mConnection == null) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnection, mSourceWindowId, mSourceViewId);
}","{
    enforceSealed();
    if (mConnectionId == UNDEFINED || mSourceWindowId == UNDEFINED || mSourceViewId == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceViewId);
}",1,"/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 *
 * </p>
 * @return The info of the source.
 */
","/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The condition statement inside the 'if' statement has changed. Also, an attribute 'mConnection' has been replaced with 'mConnectionId' in both 'if' statement and return statement. Therefore, the change type is 3,4,5.","Due to the change of the condition statement and the difference of the attribute used in return statement between the two versions, it could potentially result in the API returning different values. Thus, the CI type is 1."
185,"<android.content.Intent: int fillIn(Intent,int)>",14,15,"<android.content.Intent: int fillIn(Intent,int)>","<android.content.Intent: int fillIn(Intent,int)>",0,"{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new HashSet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        mPackage = other.mPackage;
        changes |= FILL_IN_PACKAGE;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}","{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new HashSet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}",1,"/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data URI and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * and {@link #FILL_IN_COMPONENT} to override the restriction where the
 * corresponding field will not be replaced if it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT} is explicitly
 * specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * and {@link #FILL_IN_COMPONENT} indicating which fields were changed.
 */
","/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data URI and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} to override the restriction where the
 * corresponding field will not be replaced if it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT} is explicitly
 * specified.  The selector will only be copied if {@link #FILL_IN_SELECTOR} is
 * explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are changes in the logic (condition checking has been added in if (other.mPackage != null && ...), and there are additional statements (e.g., mSelector = new Intent(other.mSelector);mPackage = null;changes |= FILL_IN_SELECTOR;), so the change types are 3 and 4.","The changes in the conditions (e.g., if the mSelector is null) and the introducing of new variables and statements potentially lead to different return values of ""changes"", hence the CI type is 1."
186,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",14,15,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>","<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",0,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    final IBinder fWindowToken = windowToken;
    final float fXOffset = xOffset;
    final float fYOffset = yOffset;
    sGlobals.getHandler().post(new Runnable() {

        public void run() {
            try {
                // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
                ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(fWindowToken, fXOffset, fYOffset, mWallpaperXStep, mWallpaperYStep);
            // Log.v(TAG, ""...app returning after sending offsets!"");
            } catch (RemoteException e) {
            // Ignore.
            } catch (IllegalArgumentException e) {
            // Since this is being posted, it's possible that this windowToken is no longer
            // valid, for example, if setWallpaperOffsets is called just before rotation.
            }
        }
    });
}",1,"/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
","/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"In the Late Version implementation, a new exception block (catch (IllegalArgumentException e)) has been added to handle the possible IllegalArgumentException, which is not in the Early Version code; Also, control dependency structure is changed as an additional 'Runnable' interface was introduced to encapsulate the context. Thus, the code change is classified under type 2 (Exception handling statement changed) and type 3 (Control dependency changed).","The new introduced exception handling could potentially give different behavior in exception scenarios. Therefore, we might have Compatibility Issue caused by potential different exception handlings, which is classified as type 2."
187,<android.speech.tts.TextToSpeech: int setOnUtteranceCompletedListener(OnUtteranceCompletedListener)>,14,15,<android.speech.tts.TextToSpeech: int setOnUtteranceCompletedListener(OnUtteranceCompletedListener)>,<android.speech.tts.TextToSpeech: int setOnUtteranceCompletedListener(OnUtteranceCompletedListener)>,0,"{
    mUtteranceCompletedListener = listener;
    return TextToSpeech.SUCCESS;
}","{
    mUtteranceProgressListener = UtteranceProgressListener.from(listener);
    return TextToSpeech.SUCCESS;
}",1,"/**
 * Sets the listener that will be notified when synthesis of an utterance completes.
 *
 * @param listener The listener to use.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
","/**
 * Sets the listener that will be notified when synthesis of an utterance completes.
 *
 * @param listener The listener to use.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 *
 * @deprecated Use {@link #setOnUtteranceProgressListener(UtteranceProgressListener)}
 * instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,The type of `listener` being saved has changed from 'OnUtteranceCompletedListener' to 'UtteranceProgressListener'. The function `from()` is used to convert it in the late version. This can be categorised as both change types 1 and 5.,"The change relating to the type of `listener` being saved can potentially lead to a different behaviour of the API, hence classifying it under CI type 1."
189,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,14,15,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mAccessibilityViewId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnection, mAccessibilityWindowId, mParentAccessibilityViewId);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentAccessibilityViewId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mAccessibilityWindowId, mParentAccessibilityViewId);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The control condition inside 'if' statement has changed and there is change in the variable passed in the return method client.findAccessibilityNodeInfoByAccessibilityId(). Hence, the categories of change are 1,4.","Due to the changes in control condition, it might lead the method to return a different value and also the change in the parameter mConnection to mConnectionId in return statement can give different return type or value, causing a potential CI of type 1."
190,<android.view.View: boolean dispatchKeyEvent(KeyEvent)>,14,15,<android.view.View: boolean dispatchKeyEvent(KeyEvent)>,<android.view.View: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onKeyEvent(event, 0);
    }
    // noinspection SimplifiableIfStatement
    if (mOnKeyListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
        return true;
    }
    if (event.dispatch(this, mAttachInfo != null ? mAttachInfo.mKeyDispatchState : null, this)) {
        return true;
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onKeyEvent(event, 0);
    }
    // Give any attached key listener a first crack at the event.
    // noinspection SimplifiableIfStatement
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnKeyListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
        return true;
    }
    if (event.dispatch(this, mAttachInfo != null ? mAttachInfo.mKeyDispatchState : null, this)) {
        return true;
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}",1,"/**
 * Dispatch a key event to the next view on the focus path. This path runs
 * from the top of the view tree down to the currently focused view. If this
 * view has focus, it will dispatch to itself. Otherwise it will dispatch
 * the next node down the focus path. This method also fires any key
 * listeners.
 *
 * @param event The key event to be dispatched.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Dispatch a key event to the next view on the focus path. This path runs
 * from the top of the view tree down to the currently focused view. If this
 * view has focus, it will dispatch to itself. Otherwise it will dispatch
 * the next node down the focus path. This method also fires any key
 * listeners.
 *
 * @param event The key event to be dispatched.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change in code is due to the introduction of the ListenerInfo object 'li'. Instead of directly using 'mOnKeyListener', the new version uses 'li.mOnKeyListener'. This modification could be categorised as 'Other statement changed'.","Even though the usage of the listener has been modified, the behaviour and output of the function remains unchanged. Therefore, there are no Compatibility Issues present."
