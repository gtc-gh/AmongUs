Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,"<android.provider.DocumentsContract: Uri moveDocument(ContentResolver,Uri,Uri,Uri)>",28,29,"<android.provider.DocumentsContract: Uri moveDocument(ContentResolver,Uri,Uri,Uri)>","<android.provider.DocumentsContract: Uri moveDocument(ContentResolver,Uri,Uri,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(sourceDocumentUri.getAuthority());
    try {
        return moveDocument(client, sourceDocumentUri, sourceParentDocumentUri, targetParentDocumentUri);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to move document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, sourceDocumentUri);
        in.putParcelable(DocumentsContract.EXTRA_PARENT_URI, sourceParentDocumentUri);
        in.putParcelable(DocumentsContract.EXTRA_TARGET_URI, targetParentDocumentUri);
        final Bundle out = content.call(sourceDocumentUri.getAuthority(), METHOD_MOVE_DOCUMENT, null, in);
        return out.getParcelable(DocumentsContract.EXTRA_URI);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to move document"", e);
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Moves the given document under a new parent.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_MOVE}
 * @param sourceParentDocumentUri parent document of the document to move.
 * @param targetParentDocumentUri document which will become a new parent of the source
 * document.
 * @return the moved document, or {@code null} if failed.
 */
","/**
 * Moves the given document under a new parent.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_MOVE}
 * @param sourceParentDocumentUri parent document of the document to move.
 * @param targetParentDocumentUri document which will become a new parent of the source
 * document.
 * @return the moved document, or {@code null} if failed.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The method implementation has completely changed. It no longer acquires a ContentProviderClient before attempting the move, and directly calls the 'content' with the METHOD_MOVE_DOCUMENT. The return statement also changed, and dependent API changed with a new way of preparing the input Bundle and receiving the output. Additionally, the catch block statement is modified, with the 'rethrowIfNecessary' function now missing the 'resolver' parameter. The code change types are 1, 4, 5.","This change introduces both potential different return values or types and different exception handlings. Previously, the method returned the result of another 'moveDocument' method or null in case of an exception. Now, it constructs a Bundle to pass to a 'call' method, and then extracts a Uri from the returned Bundle. Exception handling also changed from potential logging to rethrowing the exception without providing the 'resolver'. So the Compatibility Issue types are 1, 2."
1,"<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>",28,29,"<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>","<android.app.admin.DevicePolicyManager: boolean setPermissionGrantState(ComponentName,String,String,int)>",0,"{
    throwIfParentInstance(""setPermissionGrantState"");
    try {
        return mService.setPermissionGrantState(admin, mContext.getPackageName(), packageName, permission, grantState);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setPermissionGrantState"");
    try {
        CompletableFuture<Boolean> result = new CompletableFuture<>();
        mService.setPermissionGrantState(admin, mContext.getPackageName(), packageName, permission, grantState, new RemoteCallback((b) -> result.complete(b != null)));
        // Timeout
        BackgroundThread.getHandler().sendMessageDelayed(obtainMessage(CompletableFuture::complete, result, false), 20_000);
        return result.get();
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    } catch (InterruptedException | ExecutionException e) {
        throw new RuntimeException(e);
    }
}",1,"/**
 * Sets the grant state of a runtime permission for a specific application. The state can be
 * {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,
 * {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user
 * cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which
 * the permission is granted and the user cannot manage it through the UI. This method can only
 * be called by a profile owner, device owner, or a delegate given the
 * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
 * <p/>
 * Note that user cannot manage other permissions in the affected group through the UI
 * either and their granted state will be kept as the current value. Thus, it's recommended that
 * you set the grant state of all the permissions in the affected group.
 * <p/>
 * Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke
 * the permission. It retains the previous grant, if any.
 * <p/>
 * Permissions can be granted or revoked only for applications built with a
 * {@code targetSdkVersion} of {@link android.os.Build.VERSION_CODES#M} or later.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to grant or revoke a permission to.
 * @param permission The permission to grant or revoke.
 * @param grantState The permission grant state which is one of
 * {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},
 * {@link #PERMISSION_GRANT_STATE_GRANTED},
 * @return whether the permission was successfully granted or revoked.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #PERMISSION_GRANT_STATE_DENIED
 * @see #PERMISSION_GRANT_STATE_DEFAULT
 * @see #PERMISSION_GRANT_STATE_GRANTED
 * @see #setDelegatedScopes
 * @see #DELEGATION_PERMISSION_GRANT
 */
","/**
 * Sets the grant state of a runtime permission for a specific application. The state can be
 * {@link #PERMISSION_GRANT_STATE_DEFAULT default} in which a user can manage it through the UI,
 * {@link #PERMISSION_GRANT_STATE_DENIED denied}, in which the permission is denied and the user
 * cannot manage it through the UI, and {@link #PERMISSION_GRANT_STATE_GRANTED granted} in which
 * the permission is granted and the user cannot manage it through the UI. This method can only
 * be called by a profile owner, device owner, or a delegate given the
 * {@link #DELEGATION_PERMISSION_GRANT} scope via {@link #setDelegatedScopes}.
 * <p/>
 * Note that user cannot manage other permissions in the affected group through the UI
 * either and their granted state will be kept as the current value. Thus, it's recommended that
 * you set the grant state of all the permissions in the affected group.
 * <p/>
 * Setting the grant state to {@link #PERMISSION_GRANT_STATE_DEFAULT default} does not revoke
 * the permission. It retains the previous grant, if any.
 * <p/>
 * Device admins with a {@code targetSdkVersion} &lt; {@link android.os.Build.VERSION_CODES#Q}
 * cannot grant and revoke permissions for applications built with a {@code targetSdkVersion}
 * &lt; {@link android.os.Build.VERSION_CODES#M}.
 * <p/>
 * Admins with a {@code targetSdkVersion} &ge; {@link android.os.Build.VERSION_CODES#Q} can
 * grant and revoke permissions of all apps. Similar to the user revoking a permission from a
 * application built with a {@code targetSdkVersion} &lt;
 * {@link android.os.Build.VERSION_CODES#M} the app-op matching the permission is set to
 * {@link android.app.AppOpsManager#MODE_IGNORED}, but the permission stays granted.
 *
 * @param admin Which profile or device owner this request is associated with.
 * @param packageName The application to grant or revoke a permission to.
 * @param permission The permission to grant or revoke.
 * @param grantState The permission grant state which is one of
 * {@link #PERMISSION_GRANT_STATE_DENIED}, {@link #PERMISSION_GRANT_STATE_DEFAULT},
 * {@link #PERMISSION_GRANT_STATE_GRANTED},
 * @return whether the permission was successfully granted or revoked.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 * @see #PERMISSION_GRANT_STATE_DENIED
 * @see #PERMISSION_GRANT_STATE_DEFAULT
 * @see #PERMISSION_GRANT_STATE_GRANTED
 * @see #setDelegatedScopes
 * @see #DELEGATION_PERMISSION_GRANT
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The method implementation in the late version involved several changes. The return statement is changed to include a new asynchronous mechanism with CompletableFuture<Boolean>, and the introduction of new exception handling (catching InterruptedException and ExecutionException), also there is a new control structure for a timeout mechanism with sendMessageDelayed. Additionally, the dependent API setPermissionGrantState has been overloaded with a new parameter of callback, which is a significant change to the dependent method, so the code change type is 1,2,3,4,5.","The change in how the return value is obtained and the introduction of new exception handling indicate that the method could both return different values or types and throw different exceptions than before. This potentially affects the behavior of the API, leading to different outcomes for the callers of this method, so the CI type is 1,2."
2,"<android.util.LongSparseArray: void setValueAt(int,E)>",28,29,"<android.util.LongSparseArray: void setValueAt(int,E)>","<android.util.LongSparseArray: void setValueAt(int,E)>",0,"{
    if (mGarbage) {
        gc();
    }
    mValues[index] = value;
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mGarbage) {
        gc();
    }
    mValues[index] = value;
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"The late version introduces an additional check for the index against mSize and a throw statement for an ArrayIndexOutOfBoundsException, which is a modification in the exception handling and control dependency. In addition, new dependent API UtilConfig.sThrowExceptionForUpperArrayOutOfBounds is being used which did not exist before. Hence, the code change types are 2,3,5.","The introduced index check and throw statement could result in a new ArrayIndexOutOfBoundsException being thrown when using the late version API with an out-of-bounds index, which is not the case with the early version. As a result, this constitutes a potential Compatibility Issue due to different exception handlings, which is type 2."
4,<android.app.Notification.StandardTemplateParams: StandardTemplateParams fillTextsFrom(Builder)>,28,29,<android.app.Notification.StandardTemplateParams: StandardTemplateParams fillTextsFrom(Builder)>,<android.app.Notification.StandardTemplateParams: StandardTemplateParams fillTextsFrom(Builder)>,0,"{
    Bundle extras = b.mN.extras;
    this.title = b.processLegacyText(extras.getCharSequence(EXTRA_TITLE), ambient);
    // Big text notifications should contain their content when viewed in ambient mode.
    CharSequence text = extras.getCharSequence(EXTRA_BIG_TEXT);
    if (!ambient || TextUtils.isEmpty(text)) {
        text = extras.getCharSequence(EXTRA_TEXT);
    }
    this.text = b.processLegacyText(text, ambient);
    return this;
}","{
    Bundle extras = b.mN.extras;
    this.title = b.processLegacyText(extras.getCharSequence(EXTRA_TITLE));
    CharSequence text = extras.getCharSequence(EXTRA_BIG_TEXT);
    if (TextUtils.isEmpty(text)) {
        text = extras.getCharSequence(EXTRA_TEXT);
    }
    this.text = b.processLegacyText(text);
    this.summaryText = extras.getCharSequence(EXTRA_SUB_TEXT);
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method calls to `processLegacyText()` have changed by removing the `ambient` parameter, and a new variable `summaryText` is assigned in the late implementation. This means that the late version lacks the handling of the `ambient` condition and the signature of `processLegacyText` has potentially changed. The second part of the change falls under other statement changed. Therefore, the change types are 1,4.","The removal of the `ambient` dependency may affect the text processing, causing the API to potentially return different values (for `title` and `text`) since the ambient condition no longer alters the behavior. The addition of `summaryText` assignment in the late version also introduces a new field being set, which signifies a change in behavior. Hence the CI type is 1."
5,"<android.hardware.radio.Utils: Set<T> createSet(Parcel,Creator<T>)>",28,29,"<android.hardware.radio.Utils: Set<T> createSet(Parcel,Creator<T>)>","<android.hardware.radio.Utils: Set<T> createSet(Parcel,Creator<T>)>",0,"{
    int size = in.readInt();
    Set<T> set = new HashSet<>();
    while (size-- > 0) {
        set.add(in.readTypedObject(c));
    }
    return set;
}","{
    int size = in.readInt();
    Set<T> set = new HashSet<>(size);
    while (size-- > 0) {
        set.add(in.readTypedObject(c));
    }
    return set;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of the initial capacity 'size' to the HashSet constructor call. This change does not affect the return value or exception handling of the method but optimizes the creation of the Set based on the expected number of elements. Therefore, the change type is 4.","This change does not introduce a Compatibility Issue since it doesn't affect the returned value. It merely optimizes the internal storage of the HashSet without changing its external behavior. Thus, there is no Compatibility Issue."
6,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",28,29,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>","<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    if (mAttachInfo.mDragSurface != null) {
        mAttachInfo.mDragSurface.release();
    }
    mAttachInfo.mDragSurface = new Surface();
    mAttachInfo.mDragToken = null;
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession(root.mSurface);
    final SurfaceControl surface = new SurfaceControl.Builder(session).setName(""drag surface"").setSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).build();
    try {
        mAttachInfo.mDragSurface.copyFrom(surface);
        final Canvas canvas = mAttachInfo.mDragSurface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            mAttachInfo.mDragSurface.unlockCanvasAndPost(canvas);
        }
        // Cache the local state object for delivery with DragEvents
        root.setLocalDragState(myLocalState);
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        mAttachInfo.mDragToken = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surface, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + mAttachInfo.mDragToken);
        }
        return mAttachInfo.mDragToken != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (mAttachInfo.mDragToken == null) {
            mAttachInfo.mDragSurface.destroy();
            mAttachInfo.mDragSurface = null;
            root.setLocalDragState(null);
        }
        session.kill();
    }
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (!mAttachInfo.mViewRootImpl.mSurface.isValid()) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession();
    final SurfaceControl surfaceControl = new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).build();
    final Surface surface = new Surface();
    surface.copyFrom(surfaceControl);
    IBinder token = null;
    try {
        final Canvas canvas = surface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            surface.unlockCanvasAndPost(canvas);
        }
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token);
        }
        if (token != null) {
            if (mAttachInfo.mDragSurface != null) {
                mAttachInfo.mDragSurface.release();
            }
            mAttachInfo.mDragSurface = surface;
            mAttachInfo.mDragToken = token;
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
        }
        return token != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (token == null) {
            surface.destroy();
        }
        session.kill();
    }
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
7,<android.widget.AbsSeekBar: Mode getTickMarkTintMode()>,28,29,<android.widget.AbsSeekBar: Mode getTickMarkTintMode()>,<android.widget.AbsSeekBar: Mode getTickMarkTintMode()>,0,"{
    return mTickMarkTintMode;
}","{
    return mTickMarkBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mTickMarkBlendMode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the tick mark drawable,
 * if specified.
 *
 * @return the blending mode used to apply the tint to the tick mark drawable
 * @attr ref android.R.styleable#SeekBar_tickMarkTintMode
 * @see #setTickMarkTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the tick mark drawable,
 * if specified.
 *
 * @return the blending mode used to apply the tint to the tick mark drawable
 * @attr ref android.R.styleable#SeekBar_tickMarkTintMode
 * @see #setTickMarkTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from a direct variable return to a conditional return which includes a method call to convert `mTickMarkBlendMode` to a `PorterDuff.Mode`. Additionally, there is a dependent API change where `BlendMode.blendModeToPorterDuffMode()` is being used. Hence, the code change type is 1,5.","Because the way the value is returned has changed, including the conditional logic and the method call used in the return statement, the API can potentially return a different type or value. Therefore, the CI type is 1."
8,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,int,PointerProperties[],PointerCoords[],int,int,float,float,int,int,int,int)>",28,29,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,int,PointerProperties[],PointerCoords[],int,int,float,float,int,int,int,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,int,PointerProperties[],PointerCoords[],int,int,float,float,int,int,int,int)>",0,"{
    MotionEvent ev = obtain();
    ev.mNativePtr = nativeInitialize(ev.mNativePtr, deviceId, source, action, flags, edgeFlags, metaState, buttonState, 0, 0, xPrecision, yPrecision, downTime * NS_PER_MS, eventTime * NS_PER_MS, pointerCount, pointerProperties, pointerCoords);
    return ev;
}","{
    return obtain(downTime, eventTime, action, pointerCount, pointerProperties, pointerCoords, metaState, buttonState, xPrecision, yPrecision, deviceId, edgeFlags, source, DEFAULT_DISPLAY, flags);
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param pointerCount The number of pointers that will be in this event.
 * @param pointerProperties An array of <em>pointerCount</em> values providing
 * a {@link PointerProperties} property object for each pointer, which must
 * include the pointer identifier.
 * @param pointerCoords An array of <em>pointerCount</em> values providing
 * a {@link PointerCoords} coordinate object for each pointer.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param buttonState The state of buttons that are pressed.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 * @param source The source of this event.
 * @param flags The motion event flags.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param pointerCount The number of pointers that will be in this event.
 * @param pointerProperties An array of <em>pointerCount</em> values providing
 * a {@link PointerProperties} property object for each pointer, which must
 * include the pointer identifier.
 * @param pointerCoords An array of <em>pointerCount</em> values providing
 * a {@link PointerCoords} coordinate object for each pointer.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param buttonState The state of buttons that are pressed.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 * @param source The source of this event.
 * @param flags The motion event flags.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed as it now calls a different overload of the obtain() method, directly passing parameters to it rather than first creating the MotionEvent ev and then initializing it. The method signature for the nativeInitialize method and the method used to obtain the MotionEvent have been changed from nativeInitialize to obtain with different parameters, so the code change type is 1,5.","Given that the way the MotionEvent is being obtained and initialized has fundamentally changed, by using different method overloads and arguments, this can potentially lead to different values being returned from the API, hence the CI type is 1."
11,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,28,29,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,0,"{
    try {
        ActivityManager.getService().startLocalVoiceInteraction(mToken, privateOptions);
    } catch (RemoteException re) {
    }
}","{
    try {
        ActivityTaskManager.getService().startLocalVoiceInteraction(mToken, privateOptions);
    } catch (RemoteException re) {
    }
}",1,"/**
 * Starts a local voice interaction session. When ready,
 * {@link #onLocalVoiceInteractionStarted()} is called. You can pass a bundle of private options
 * to the registered voice interaction service.
 * @param privateOptions a Bundle of private arguments to the current voice interaction service
 */
","/**
 * Starts a local voice interaction session. When ready,
 * {@link #onLocalVoiceInteractionStarted()} is called. You can pass a bundle of private options
 * to the registered voice interaction service.
 * @param privateOptions a Bundle of private arguments to the current voice interaction service
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API used in the implementation has changed from ActivityManager.getService() to ActivityTaskManager.getService(), which is related to how the service is accessed. No other parts of the code have changed, so the change type is 5.","Even though there is a change in the dependent API, there is no change in the signature of the 'startLocalVoiceInteraction' method itself, and the code does not contain any new or modified return statements or exception handling. As such, there is no evidence to suggest a potential change in the behavior of the API just because of the change in service management. Therefore, there is no compatibility issue detected, hence the pred_CI type is 0."
13,"<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options)>",28,29,"<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options)>","<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options)>",0,"{
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, false);
}","{
    return getThumbnail(cr, imageId, kind, options);
}",1,"/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param groupId the id of group to which this request belongs
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image
 * associated with origId doesn't exist or memory is not enough.
 */
","/**
 * Return thumbnail representing a specific image item. If a
 * thumbnail doesn't exist, this method will block until it's
 * generated. Callers are responsible for their own in-memory
 * caching of returned values.
 *
 * @param imageId the image item to obtain a thumbnail for.
 * @param kind optimal thumbnail size desired.
 * @return decoded thumbnail, or {@code null} if problem was
 * encountered.
 * @deprecated Callers should migrate to using
 * {@link ContentResolver#loadThumbnail}, since it
 * offers richer control over requested thumbnail sizes
 * and cancellation behavior.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling InternalThumbnails.getThumbnail(...) with multiple parameters to calling getThumbnail(...) with different parameters. The method signature and the number of parameters in the dependent API being called have been altered, indicating a change in the dependent API. Therefore, the change types are 1 and 5.","The change in the method being called in the return statement could lead to the API returning a different value due to the new signature of the getThumbnail method, which has fewer parameters and potentially a different implementation. This results in a CI type of 1."
14,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,28,29,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The code change consists of modifying the lock object in a synchronized block from `synchronized (mDeviceBusy)` to `synchronized (mDeviceBusyLock)`. This change affects which lock is being used but does not affect the API's return values or the exceptions it throws.,There is no Compatibility Issue caused by this change as it does not affect the API's behavior in terms of what it returns or the exceptions it may throw. It is an internal synchronization change.
15,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,28,29,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,<android.view.inputmethod.InputMethodManager: boolean shouldOfferSwitchingToNextInputMethod(IBinder)>,0,"{
    return shouldOfferSwitchingToNextInputMethodInternal(imeToken);
}","{
    return InputMethodPrivilegedOperationsRegistry.get(imeToken).shouldOfferSwitchingToNextInputMethod();
}",1,"/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @deprecated Use {@link InputMethodService#shouldOfferSwitchingToNextInputMethod()}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
","/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @deprecated Use {@link InputMethodService#shouldOfferSwitchingToNextInputMethod()}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",1,The method called within the return statement has changed from shouldOfferSwitchingToNextInputMethodInternal(imeToken) to InputMethodPrivilegedOperationsRegistry.get(imeToken).shouldOfferSwitchingToNextInputMethod() in the late implementation. This indicates that the implementation relies on a different method (or possibly a different object) to achieve its functionality. The code change types are 4 and 5.,"The change in the dependent method within the return statement introduces a potential change in the return value because the new method call might have a different logic or side effects. Therefore, the CI type is 1 related to the potential difference in return values."
16,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,28,29,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: String getMessageName(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        case MSG_PREPARE_FOR_EXTRA_DATA_REQUEST:
            return ""MSG_PREPARE_FOR_EXTRA_DATA_REQUEST"";
        case MSG_APP_PREPARATION_FINISHED:
            return ""MSG_APP_PREPARATION_FINISHED"";
        case MSG_APP_PREPARATION_TIMEOUT:
            return ""MSG_APP_PREPARATION_TIMEOUT"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            return ""MSG_PERFORM_ACCESSIBILITY_ACTION"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID"";
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            return ""MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT"";
        case MSG_FIND_FOCUS:
            return ""MSG_FIND_FOCUS"";
        case MSG_FOCUS_SEARCH:
            return ""MSG_FOCUS_SEARCH"";
        case MSG_PREPARE_FOR_EXTRA_DATA_REQUEST:
            return ""MSG_PREPARE_FOR_EXTRA_DATA_REQUEST"";
        case MSG_APP_PREPARATION_FINISHED:
            return ""MSG_APP_PREPARATION_FINISHED"";
        case MSG_APP_PREPARATION_TIMEOUT:
            return ""MSG_APP_PREPARATION_TIMEOUT"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS"";
        case MSG_NOTIFY_OUTSIDE_TOUCH:
            return ""MSG_NOTIFY_OUTSIDE_TOUCH"";
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"Two new case statements (MSG_CLEAR_ACCESSIBILITY_FOCUS, MSG_NOTIFY_OUTSIDE_TOUCH) are added to the switch control structure, therefore the code change types are 1,3.","Despite new cases being added to the switch statement, there's no Compatibility Issue because these additions do not affect the handling of previously defined cases. The behavior for the existing message types remains unchanged, and the default case still throws an exception for any unknown message types as it did before. The new cases provide support for additional message types without altering the existing API contract."
18,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",28,29,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(LOG_TAG, ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(LOG_TAG, ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId());
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent, isAsync);
        v.setRemoteViewsOnClickHandler(handler);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent, isAsync);
        v.setRemoteViewsOnClickHandler(handler);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(LOG_TAG, ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(LOG_TAG, ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId()).putExtra(EXTRA_REMOTEADAPTER_ON_LIGHT_BACKGROUND, hasFlags(FLAG_USE_LIGHT_BACKGROUND_LAYOUT));
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent, isAsync);
        v.setRemoteViewsOnClickHandler(handler);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent, isAsync);
        v.setRemoteViewsOnClickHandler(handler);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change here is the addition of an extra putExtra call on the intent, which means that a new value is being added to the Intent object. There are no changes in the return statements, exception handling, control flow dependencies, or the structure of the API. Thus, the change type is 4.","There is no Compatibility Issue since the extra data added to the Intent does not affect the value returned by the method, nor the exceptions it throws. The method's behavior in terms of its inputs and outputs remains consistent between versions, meaning that it has the same operational semantics despite the internal change of adding more data to an Intent object. Hence, the CI type is 0."
19,<android.hardware.camera2.params.StreamConfigurationMap: int hashCode()>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: int hashCode()>,<android.hardware.camera2.params.StreamConfigurationMap: int hashCode()>,0,"{
    // XX: do we care about order?
    return HashCodeHelpers.hashCodeGeneric(mConfigurations, mMinFrameDurations, mStallDurations, mDepthConfigurations, mHighSpeedVideoConfigurations);
}","{
    // XX: do we care about order?
    return HashCodeHelpers.hashCodeGeneric(mConfigurations, mMinFrameDurations, mStallDurations, mDepthConfigurations, mDepthMinFrameDurations, mDepthStallDurations, mDynamicDepthConfigurations, mDynamicDepthMinFrameDurations, mDynamicDepthStallDurations, mHeicConfigurations, mHeicMinFrameDurations, mHeicStallDurations, mHighSpeedVideoConfigurations);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The method hashCode() has been changed by adding more parameters to the HashCodeHelpers.hashCodeGeneric() call; therefore, the code change type is 1 for the modified return statement, and 4 for the changed composition of parameters affecting the execution of other statements.","Although there is a change in the hashCode() implementation, changing the components used to generate the hash code will not cause a compatibility issue because the contract for the hashCode() method does not guarantee that the value will be the same across different implementations. It does not affect the API's behavior in terms of returning different results in response to the same inputs across different calls; the hash code is simply expected to be consistent during a single execution run. Thus, no compatibility issue arises in this situation."
20,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",28,29,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>","<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + "":"" + virtualId + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (mForAugmentedAutofillOnly) {
            if (sVerbose)
                Log.v(TAG, ""notifyValueChanged(): ignoring on augmented only mode"");
            return;
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + "":"" + virtualId + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
","/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new if condition has been added to check for `mForAugmentedAutofillOnly`, so the code change type is 3 due to the addition of a control statement.","The new if condition does not lead to a Compatibility Issue because it doesn't affect the existing behavior when `mForAugmentedAutofillOnly` is not true. The code execution for existing clients relying on the old version behaviour will remain unchanged as long as they are not in augmented only mode, hence no CI."
23,<android.widget.Editor.TextRenderNode: boolean needsRecord()>,28,29,<android.widget.Editor.TextRenderNode: boolean needsRecord()>,<android.widget.Editor.TextRenderNode: boolean needsRecord()>,0,"{
    return isDirty || !renderNode.isValid();
}","{
    return isDirty || !renderNode.hasDisplayList();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call within the return statement has changed from renderNode.isValid() to renderNode.hasDisplayList(). This indicates that a different method is being called on the 'renderNode' object, which is not a change in the return statement or a control structure but an other statement change (4). Also, since the method called on the dependent 'renderNode' object has changed, it is a dependent API change (5).","The change in the method called on 'renderNode' could cause the return value of 'needsRecord()' to differ between the two versions because 'isValid()' might have different semantics compared to 'hasDisplayList()'. Therefore, there is a potential for a different return value, making it a compatibility issue of type 1."
25,<android.app.NotificationChannelGroup: boolean equals(Object)>,28,29,<android.app.NotificationChannelGroup: boolean equals(Object)>,<android.app.NotificationChannelGroup: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannelGroup that = (NotificationChannelGroup) o;
    if (isBlocked() != that.isBlocked())
        return false;
    if (getId() != null ? !getId().equals(that.getId()) : that.getId() != null)
        return false;
    if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) {
        return false;
    }
    if (getDescription() != null ? !getDescription().equals(that.getDescription()) : that.getDescription() != null) {
        return false;
    }
    return getChannels() != null ? getChannels().equals(that.getChannels()) : that.getChannels() == null;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannelGroup that = (NotificationChannelGroup) o;
    return isBlocked() == that.isBlocked() && mUserLockedFields == that.mUserLockedFields && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(getDescription(), that.getDescription()) && Objects.equals(getChannels(), that.getChannels());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method's logic has been refactored but the logic is fundamentally the same. The 'if' conditions checking individual fields for equality have been replaced with a single return statement that uses logical AND to combine the conditions, and Objects.equals is used for null-safe object comparisons instead of the ternary operations used previously. Also, a new field 'mUserLockedFields' is being compared that did not exist in the earlier version, so the change type is 3,4.","Even though there's a change in the implementation, the changes do not alter the behavior or logic related to how the equality is determined between objects. Since all the operations should yield the same boolean result as before (because logical operations are equivalent and Objects.equals provides null-safe equality checks just as the ternary operations did), there's no Compatibility Issue; so the CI type is 0."
26,<android.util.Xml: XmlSerializer newSerializer()>,28,29,<android.util.Xml: XmlSerializer newSerializer()>,<android.util.Xml: XmlSerializer newSerializer()>,0,"{
    try {
        return XmlSerializerFactory.instance.newSerializer();
    } catch (XmlPullParserException e) {
        throw new AssertionError(e);
    }
}","{
    return XmlObjectFactory.newXmlSerializer();
}",1,"/**
 * Creates a new xml serializer.
 */
","/**
 * Creates a new xml serializer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed; the method which creates a new XmlSerializer instance has changed from XmlSerializerFactory.instance.newSerializer() to XmlObjectFactory.newXmlSerializer(). This constitutes a change in the Dependent API, so the code change types are 1 and 5.","Because the implementation of the method used to instantiate the XmlSerializer has changed, and there's no indication that the behavior or the returned type of the new method is identical, this could potentially return a different type of XmlSerializer. Hence, there's a potential Compatibility Issue of a different returned value or type, classified as 1."
28,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,28,29,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getHealthDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    Log.e(TAG, ""getDevicesMatchingConnectionStates(): BluetoothHealth is deprecated"");
    return new ArrayList<>();
}",1,"/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param states Array of states. States can be one of {@link #STATE_CONNECTED}, {@link
 * #STATE_CONNECTING}, {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */
","/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param states Array of states. States can be one of {@link #STATE_CONNECTED}, {@link
 * #STATE_CONNECTING}, {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been changed to always return a new ArrayList, and other statements including a check (isEnabled()), a try-catch block, and logging have been removed with an unconditional log message added. Therefore, the changes involve a return statement change and other statement changes, so the code change is classified as 1,4.","Because the late version no longer checks if the service is enabled or tries to get devices from the service, it will always return a new empty ArrayList compared to potentially a filled list in the early version. This results in a method that potentially returns different values, which classifies as a CI type 1."
29,<android.view.View: void cancelDragAndDrop()>,28,29,<android.view.View: void cancelDragAndDrop()>,<android.view.View: void cancelDragAndDrop()>,0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""cancelDragAndDrop"");
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""cancelDragAndDrop called on a detached view."");
        return;
    }
    if (mAttachInfo.mDragToken != null) {
        try {
            mAttachInfo.mSession.cancelDragAndDrop(mAttachInfo.mDragToken);
        } catch (Exception e) {
            Log.e(VIEW_LOG_TAG, ""Unable to cancel drag"", e);
        }
        mAttachInfo.mDragToken = null;
    } else {
        Log.e(VIEW_LOG_TAG, ""No active drag to cancel"");
    }
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""cancelDragAndDrop"");
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""cancelDragAndDrop called on a detached view."");
        return;
    }
    if (mAttachInfo.mDragToken != null) {
        try {
            mAttachInfo.mSession.cancelDragAndDrop(mAttachInfo.mDragToken, false);
        } catch (Exception e) {
            Log.e(VIEW_LOG_TAG, ""Unable to cancel drag"", e);
        }
        mAttachInfo.mDragToken = null;
    } else {
        Log.e(VIEW_LOG_TAG, ""No active drag to cancel"");
    }
}",1,"/**
 * Cancels an ongoing drag and drop operation.
 * <p>
 * A {@link android.view.DragEvent} object with
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_ENDED} and
 * {@link android.view.DragEvent#getResult()} value of {@code false}
 * will be sent to every
 * View that received {@link android.view.DragEvent#ACTION_DRAG_STARTED}
 * even if they are not currently visible.
 * </p>
 * <p>
 * This method can be called on any View in the same window as the View on which
 * {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object, int) startDragAndDrop}
 * was called.
 * </p>
 */
","/**
 * Cancels an ongoing drag and drop operation.
 * <p>
 * A {@link android.view.DragEvent} object with
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_ENDED} and
 * {@link android.view.DragEvent#getResult()} value of {@code false}
 * will be sent to every
 * View that received {@link android.view.DragEvent#ACTION_DRAG_STARTED}
 * even if they are not currently visible.
 * </p>
 * <p>
 * This method can be called on any View in the same window as the View on which
 * {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object, int) startDragAndDrop}
 * was called.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the late version's implementation is adding a boolean parameter 'false' to the method call `mAttachInfo.mSession.cancelDragAndDrop(mAttachInfo.mDragToken, false)`; this is a change in the dependent API being called, so the code change type is 4,5.","There's no compatibility issue with this change as the existing behavior of the API is not directly affectedit doesn't introduce a new return value or type, nor does it change exception handling or add new control structures. The added false parameter is related to the internal behavior of the cancelDragAndDrop method; thus, it isn't directly affecting the API's contract. If the internal behavior of the cancelDragAndDrop with the new parameter is consistent with the behavior without the parameter, then it would not constitute a CI. However, without more details on the behavior of the method `cancelDragAndDrop` with the added parameter, it's presumed to not have a direct impact on the current API's compatibility."
31,<android.bluetooth.BluetoothSocket: int getConnectionType()>,28,29,<android.bluetooth.BluetoothSocket: int getConnectionType()>,<android.bluetooth.BluetoothSocket: int getConnectionType()>,0,"{
    return mType;
}","{
    if (mType == TYPE_L2CAP_LE) {
        // Treat the LE CoC to be the same type as L2CAP.
        return TYPE_L2CAP;
    }
    return mType;
}",1,"/**
 * Get the type of the underlying connection.
 *
 * @return one of {@link #TYPE_RFCOMM}, {@link #TYPE_SCO} or {@link #TYPE_L2CAP}
 */
","/**
 * Get the type of the underlying connection.
 *
 * @return one of {@link #TYPE_RFCOMM}, {@link #TYPE_SCO} or {@link #TYPE_L2CAP}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The late version introduces a new control dependency 'if' statement to check the type and potentially modify the return value. So the code change types are 1 (return statement changed because of the additional 'if') and 3 (control dependency changed).,"Due to the added 'if' control structure that changes the return value based on the condition, there is a change in the return value of the API method depending on the value of `mType`. If `mType` is `TYPE_L2CAP_LE`, the returned value will be `TYPE_L2CAP` instead in the newer version. Therefore, this change can lead to a different behavior, and the CI type is 1."
33,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectCustomSlowCalls()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectCustomSlowCalls()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectCustomSlowCalls()>,0,"{
    return enable(DETECT_CUSTOM);
}","{
    return enable(DETECT_THREAD_CUSTOM);
}",1,"/**
 * Enable detection of slow calls.
 */
","/**
 * Enable detection of slow calls.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from enable(DETECT_CUSTOM) to enable(DETECT_THREAD_CUSTOM), indicating that the method being invoked and its parameters have been updated. Additionally, an annotation [@NonNull] has been added in the late version. So the code change type is 1 for the return statement changed, and type 5 for the dependent API changed (assuming the enable() method's signature has changed).","The modification in the return statement due to the change from enable(DETECT_CUSTOM) to enable(DETECT_THREAD_CUSTOM) indicates that the API now potentially returns different values or captures different types of custom slow calls. The introduction of the [@NonNull] annotation does not by itself cause a compatibility issue, since it is an indicator of method behavior rather than a change in the method's logic that would impact its runtime behavior. Therefore, the CI type is 1, caused by the potential different return values or types due to the change in the implementation of the enable method."
34,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitNetwork()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitNetwork()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitNetwork()>,0,"{
    return disable(DETECT_NETWORK);
}","{
    return disable(DETECT_THREAD_NETWORK);
}",1,"/**
 * Disable detection of network operations.
 */
","/**
 * Disable detection of network operations.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The API implementation shows that the parameter passed to the method disable() has changed from DETECT_NETWORK to DETECT_THREAD_NETWORK. Since the method disable() appears to be a dependent API and its input parameter has changed, change type 1,5 is applicable.","The change in the parameter passed to the method disable() suggests that the behavior of the permitNetwork() method could be different in the late version, as it possibly alters which network operations are being permitted. Therefore, this could lead to a compatibility issue where the resulting ThreadPolicy.Builder object behaves differently due to different settings being applied, hence CI type 1 is detected."
37,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,0,"{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    StreamConfiguration[] configs = surfaceDataspace != HAL_DATASPACE_DEPTH ? mConfigurations : mDepthConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}","{
    checkNotNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    StreamConfiguration[] configs = surfaceDataspace == HAL_DATASPACE_DEPTH ? mDepthConfigurations : surfaceDataspace == HAL_DATASPACE_DYNAMIC_DEPTH ? mDynamicDepthConfigurations : surfaceDataspace == HAL_DATASPACE_HEIF ? mHeicConfigurations : mConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
","/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"There is a change in the assignment of 'configs'. In the late version, the data space checks have been expanded to include additional cases (`HAL_DATASPACE_DYNAMIC_DEPTH` and `HAL_DATASPACE_HEIF`). This is a control dependency change since the decision of which configuration array to use now depends on more conditions. Furthermore, since the assignment logic of 'configs' variable depends on methods such as `getSurfaceDataspace()` from the `SurfaceUtils` class, this change could also account for a dependent API change, so the change types here are 3 and 5.","Although there is a change in the control flow, this change does not introduce any CI because it doesn't affect the return values for the existing condition (`HAL_DATASPACE_DEPTH`). The new conditions and added configuration arrays (`mDynamicDepthConfigurations` and `mHeicConfigurations`) only extend the functionality to new data spaces without altering the behavior for the previously handled data spaces in the early version. Thus, this change does not lead to a different output for earlier conditions, and no CI is expected for this change. The CI type is 0."
38,<android.content.ContentValues: Double getAsDouble(String)>,28,29,<android.content.ContentValues: Double getAsDouble(String)>,<android.content.ContentValues: Double getAsDouble(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).doubleValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Double.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Double value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Double: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return value != null ? ((Number) value).doubleValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Double.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Double value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Double: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Double.
 *
 * @param key the value to get
 * @return the Double value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Double.
 *
 * @param key the value to get
 * @return the Double value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the member variable name from 'mValues' to 'mMap'. The logic and return type remain completely unchanged, so the code change type is 4.","There are no changes to the way the method behaves or the values it returns. The underlying data structure being accessed has changed, but the overall contract of the method has not, so there are no potential Compatibility Issues, hence CI type is 0."
39,<android.widget.TextView: TextClassifier getTextClassificationSession()>,28,29,<android.widget.TextView: TextClassifier getTextClassificationSession()>,<android.widget.TextView: TextClassifier getTextClassificationSession()>,0,"{
    if (mTextClassificationSession == null || mTextClassificationSession.isDestroyed()) {
        final TextClassificationManager tcm = mContext.getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            final String widgetType;
            if (isTextEditable()) {
                widgetType = TextClassifier.WIDGET_TYPE_EDITTEXT;
            } else if (isTextSelectable()) {
                widgetType = TextClassifier.WIDGET_TYPE_TEXTVIEW;
            } else {
                widgetType = TextClassifier.WIDGET_TYPE_UNSELECTABLE_TEXTVIEW;
            }
            final TextClassificationContext textClassificationContext = new TextClassificationContext.Builder(mContext.getPackageName(), widgetType).build();
            if (mTextClassifier != null) {
                mTextClassificationSession = tcm.createTextClassificationSession(textClassificationContext, mTextClassifier);
            } else {
                mTextClassificationSession = tcm.createTextClassificationSession(textClassificationContext);
            }
        } else {
            mTextClassificationSession = TextClassifier.NO_OP;
        }
    }
    return mTextClassificationSession;
}","{
    if (mTextClassificationSession == null || mTextClassificationSession.isDestroyed()) {
        final TextClassificationManager tcm = mContext.getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            final String widgetType;
            if (isTextEditable()) {
                widgetType = TextClassifier.WIDGET_TYPE_EDITTEXT;
            } else if (isTextSelectable()) {
                widgetType = TextClassifier.WIDGET_TYPE_TEXTVIEW;
            } else {
                widgetType = TextClassifier.WIDGET_TYPE_UNSELECTABLE_TEXTVIEW;
            }
            mTextClassificationContext = new TextClassificationContext.Builder(mContext.getPackageName(), widgetType).build();
            if (mTextClassifier != null) {
                mTextClassificationSession = tcm.createTextClassificationSession(mTextClassificationContext, mTextClassifier);
            } else {
                mTextClassificationSession = tcm.createTextClassificationSession(mTextClassificationContext);
            }
        } else {
            mTextClassificationSession = TextClassifier.NO_OP;
        }
    }
    return mTextClassificationSession;
}",1,"/**
 * Returns a session-aware text classifier.
 * This method creates one if none already exists or the current one is destroyed.
 */
","/**
 * Returns a session-aware text classifier.
 * This method creates one if none already exists or the current one is destroyed.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The assignment to mTextClassificationContext was introduced in the late version instead of the local variable, textClassificationContext. However, since mTextClassificationContext seems to be used only within the scope of this method (same as textClassificationContext was), and ultimately, mTextClassificationSession remains the return value, the change does not affect the return statement directly. There's no change in how exceptions are handled or return logic; thus, the change type is 4.","There is no Compatibility Issue here because the actual behavior and contract of the method haven't changed: it would still return the same mTextClassificationSession object. The object gets constructed the same way whether it stores the intermediate TextClassificationContext in a local variable or in an instance variable, assuming the instance variable is not used outside the scope of this method or modified before this method's execution. Thus, the introduction of an instance variable does not change the method's external behavior."
40,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,28,29,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}","{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method used to obtain the service instance changed from 'mService' to 'getService()', this is a change in the dependent API, so the code change type is 5.","Assuming 'getService()' is functionally equivalent to accessing 'mService' directly and there is no change in behavior except how the service object is obtained, there would be no compatibility issue, so the CI type is 0."
42,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,long,ParcelFileDescriptor,int,IBackupManager)>",28,29,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,long,ParcelFileDescriptor,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,long,ParcelFileDescriptor,int,IBackupManager)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    // Ensure that any side-effect SharedPreferences writes have landed *before*
    // we may be about to rewrite the file out from underneath
    waitForSharedPrefs();
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    // Ensure that any side-effect SharedPreferences writes have landed *before*
    // we may be about to rewrite the file out from underneath
    waitForSharedPrefs();
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change consists of changing the method called in the 'try' block from `callbackBinder.opComplete` to `callbackBinder.opCompleteForUser` and passing an additional argument `getBackupUserId()`. The additional statements are of the type 4 (Other statement changed) and 5 (Dependent API changed), since the dependent API `opComplete` has been replaced with `opCompleteForUser`.","Although the implementation called a different method in the 'try' block, it would not result in a CI regarding return values or exception handlings because this change occurs within a 'finally' block after the actual operation of the method has been conducted. There is no change on how exceptions are thrown or how values are returned from the method. The change is only concerning the clean-up and callback notification code which does not affect the outward facing behavior or contract of the `doRestore` method. Therefore, there is no Compatibility Issue."
43,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,28,29,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,0,"{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Os.pipe2(ifAtLeastQ(O_CLOEXEC));
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
","/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called within the try block has changed from Os.pipe() to Os.pipe2(ifAtLeastQ(O_CLOEXEC)). This indicates a change in the implementation of how the pipe is created but not a change in the method's control flow or return type. Therefore, the change type is 4, as it is an 'other statement changed' and 5 since it's a 'dependent API changed'.","There is no Compatibility Issue, given there's no alteration in the exception handling, return statement or control structure that would affect the outward behavior from an API consumer's point of view. Even though a different method (pipe2 instead of pipe) is used to create the pipe, this change is internal and does not affect the signature or the expected results of the method if both pipe methods fulfill the same purpose. Hence, the type is 0."
44,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",28,29,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>","<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",0,"{
    final CharSequence source = b.mText;
    final int bufStart = b.mStart;
    final int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    final boolean fallbackLineSpacing = b.mFallbackLineSpacing;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    final boolean addLastLineSpacing = b.mAddLastLineLineSpacing;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    FloatArray widths = new FloatArray();
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    final int[] indents;
    if (mLeftIndents != null || mRightIndents != null) {
        final int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
        final int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
        final int indentsLen = Math.max(leftLen, rightLen);
        indents = new int[indentsLen];
        for (int i = 0; i < leftLen; i++) {
            indents[i] = mLeftIndents[i];
        }
        for (int i = 0; i < rightLen; i++) {
            indents[i] += mRightIndents[i];
        }
    } else {
        indents = null;
    }
    final long nativePtr = nInit(b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
    b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE, indents, mLeftPaddings, mRightPaddings);
    PrecomputedText.ParagraphInfo[] paragraphInfo = null;
    final Spanned spanned = (source instanceof Spanned) ? (Spanned) source : null;
    if (source instanceof PrecomputedText) {
        PrecomputedText precomputed = (PrecomputedText) source;
        if (precomputed.canUseMeasuredResult(bufStart, bufEnd, textDir, paint, b.mBreakStrategy, b.mHyphenationFrequency)) {
            // Some parameters are different from the ones when measured text is created.
            paragraphInfo = precomputed.getParagraphInfo();
        }
    }
    if (paragraphInfo == null) {
        final PrecomputedText.Params param = new PrecomputedText.Params(paint, textDir, b.mBreakStrategy, b.mHyphenationFrequency);
        paragraphInfo = PrecomputedText.createMeasuredParagraphs(source, param, bufStart, bufEnd, false);
    }
    try {
        for (int paraIndex = 0; paraIndex < paragraphInfo.length; paraIndex++) {
            final int paraStart = paraIndex == 0 ? bufStart : paragraphInfo[paraIndex - 1].paragraphEnd;
            final int paraEnd = paragraphInfo[paraIndex].paragraphEnd;
            int firstWidthLineCount = 1;
            int firstWidth = outerWidth;
            int restWidth = outerWidth;
            LineHeightSpan[] chooseHt = null;
            if (spanned != null) {
                LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
                for (int i = 0; i < sp.length; i++) {
                    LeadingMarginSpan lms = sp[i];
                    firstWidth -= sp[i].getLeadingMargin(true);
                    restWidth -= sp[i].getLeadingMargin(false);
                    // leading margin spans, not just this particular one
                    if (lms instanceof LeadingMarginSpan2) {
                        LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                        firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                    }
                }
                chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
                if (chooseHt.length == 0) {
                    // So that out() would not assume it has any contents
                    chooseHt = null;
                } else {
                    if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                        chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                    }
                    for (int i = 0; i < chooseHt.length; i++) {
                        int o = spanned.getSpanStart(chooseHt[i]);
                        if (o < paraStart) {
                            // starts in this layout, before the
                            // current paragraph
                            chooseHtv[i] = getLineTop(getLineForOffset(o));
                        } else {
                            // starts in this paragraph
                            chooseHtv[i] = v;
                        }
                    }
                }
            }
            // tab stop locations
            int[] variableTabStops = null;
            if (spanned != null) {
                TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                if (spans.length > 0) {
                    int[] stops = new int[spans.length];
                    for (int i = 0; i < spans.length; i++) {
                        stops[i] = spans[i].getTabStop();
                    }
                    Arrays.sort(stops, 0, stops.length);
                    variableTabStops = stops;
                }
            }
            final MeasuredParagraph measuredPara = paragraphInfo[paraIndex].measured;
            final char[] chs = measuredPara.getChars();
            final int[] spanEndCache = measuredPara.getSpanEndCache().getRawArray();
            final int[] fmCache = measuredPara.getFontMetrics().getRawArray();
            // TODO: Stop keeping duplicated width copy in native and Java.
            widths.resize(chs.length);
            // measurement has to be done before performing line breaking
            // but we don't want to recompute fontmetrics or span ranges the
            // second time, so we cache those and then use those stored values
            int breakCount = nComputeLineBreaks(nativePtr, // Inputs
            chs, measuredPara.getNativePtr(), paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, mLineCount, // Outputs
            lineBreaks, lineBreaks.breaks.length, lineBreaks.breaks, lineBreaks.widths, lineBreaks.ascents, lineBreaks.descents, lineBreaks.flags, widths.getRawArray());
            final int[] breaks = lineBreaks.breaks;
            final float[] lineWidths = lineBreaks.widths;
            final float[] ascents = lineBreaks.ascents;
            final float[] descents = lineBreaks.descents;
            final int[] flags = lineBreaks.flags;
            final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
            final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
            if (0 < remainingLineCount && remainingLineCount < breakCount && ellipsisMayBeApplied) {
                // Calculate width and flag.
                float width = 0;
                // XXX May need to also have starting hyphen edit
                int flag = 0;
                for (int i = remainingLineCount - 1; i < breakCount; i++) {
                    if (i == breakCount - 1) {
                        width += lineWidths[i];
                    } else {
                        for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                            width += widths.get(j);
                        }
                    }
                    flag |= flags[i] & TAB_MASK;
                }
                // Treat the last line and overflowed lines as a single line.
                breaks[remainingLineCount - 1] = breaks[breakCount - 1];
                lineWidths[remainingLineCount - 1] = width;
                flags[remainingLineCount - 1] = flag;
                breakCount = remainingLineCount;
            }
            // here is the offset of the starting character of the line we are currently
            // measuring
            int here = paraStart;
            int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
            int fmCacheIndex = 0;
            int spanEndCacheIndex = 0;
            int breakIndex = 0;
            for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
                // retrieve end of span
                spanEnd = spanEndCache[spanEndCacheIndex++];
                // retrieve cached metrics, order matches above
                fm.top = fmCache[fmCacheIndex * 4 + 0];
                fm.bottom = fmCache[fmCacheIndex * 4 + 1];
                fm.ascent = fmCache[fmCacheIndex * 4 + 2];
                fm.descent = fmCache[fmCacheIndex * 4 + 3];
                fmCacheIndex++;
                if (fm.top < fmTop) {
                    fmTop = fm.top;
                }
                if (fm.ascent < fmAscent) {
                    fmAscent = fm.ascent;
                }
                if (fm.descent > fmDescent) {
                    fmDescent = fm.descent;
                }
                if (fm.bottom > fmBottom) {
                    fmBottom = fm.bottom;
                }
                // skip breaks ending before current span range
                while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                    breakIndex++;
                }
                while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                    int endPos = paraStart + breaks[breakIndex];
                    boolean moreChars = (endPos < bufEnd);
                    final int ascent = fallbackLineSpacing ? Math.min(fmAscent, Math.round(ascents[breakIndex])) : fmAscent;
                    final int descent = fallbackLineSpacing ? Math.max(fmDescent, Math.round(descents[breakIndex])) : fmDescent;
                    v = out(source, here, endPos, ascent, descent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, chs, widths.getRawArray(), paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                    if (endPos < spanEnd) {
                        // preserve metrics for current span
                        fmTop = fm.top;
                        fmBottom = fm.bottom;
                        fmAscent = fm.ascent;
                        fmDescent = fm.descent;
                    } else {
                        fmTop = fmBottom = fmAscent = fmDescent = 0;
                    }
                    here = endPos;
                    breakIndex++;
                    if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                        return;
                    }
                }
            }
            if (paraEnd == bufEnd) {
                break;
            }
        }
        if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
            final MeasuredParagraph measuredPara = MeasuredParagraph.buildForBidi(source, bufEnd, bufEnd, textDir, null);
            paint.getFontMetricsInt(fm);
            v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
        }
    } finally {
        nFinish(nativePtr);
    }
}","{
    final CharSequence source = b.mText;
    final int bufStart = b.mStart;
    final int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    final boolean fallbackLineSpacing = b.mFallbackLineSpacing;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    final boolean addLastLineSpacing = b.mAddLastLineLineSpacing;
    int lineBreakCapacity = 0;
    int[] breaks = null;
    float[] lineWidths = null;
    float[] ascents = null;
    float[] descents = null;
    boolean[] hasTabs = null;
    int[] hyphenEdits = null;
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    final int[] indents;
    if (mLeftIndents != null || mRightIndents != null) {
        final int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
        final int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
        final int indentsLen = Math.max(leftLen, rightLen);
        indents = new int[indentsLen];
        for (int i = 0; i < leftLen; i++) {
            indents[i] = mLeftIndents[i];
        }
        for (int i = 0; i < rightLen; i++) {
            indents[i] += mRightIndents[i];
        }
    } else {
        indents = null;
    }
    final LineBreaker lineBreaker = new LineBreaker.Builder().setBreakStrategy(b.mBreakStrategy).setHyphenationFrequency(b.mHyphenationFrequency).setJustificationMode(b.mJustificationMode).setIndents(indents).build();
    LineBreaker.ParagraphConstraints constraints = new LineBreaker.ParagraphConstraints();
    PrecomputedText.ParagraphInfo[] paragraphInfo = null;
    final Spanned spanned = (source instanceof Spanned) ? (Spanned) source : null;
    if (source instanceof PrecomputedText) {
        PrecomputedText precomputed = (PrecomputedText) source;
        @PrecomputedText.Params.CheckResultUsableResult final int checkResult = precomputed.checkResultUsable(bufStart, bufEnd, textDir, paint, b.mBreakStrategy, b.mHyphenationFrequency);
        switch(checkResult) {
            case PrecomputedText.Params.UNUSABLE:
                break;
            case PrecomputedText.Params.NEED_RECOMPUTE:
                final PrecomputedText.Params newParams = new PrecomputedText.Params.Builder(paint).setBreakStrategy(b.mBreakStrategy).setHyphenationFrequency(b.mHyphenationFrequency).setTextDirection(textDir).build();
                precomputed = PrecomputedText.create(precomputed, newParams);
                paragraphInfo = precomputed.getParagraphInfo();
                break;
            case PrecomputedText.Params.USABLE:
                // Some parameters are different from the ones when measured text is created.
                paragraphInfo = precomputed.getParagraphInfo();
                break;
        }
    }
    if (paragraphInfo == null) {
        final PrecomputedText.Params param = new PrecomputedText.Params(paint, textDir, b.mBreakStrategy, b.mHyphenationFrequency);
        paragraphInfo = PrecomputedText.createMeasuredParagraphs(source, param, bufStart, bufEnd, false);
    }
    for (int paraIndex = 0; paraIndex < paragraphInfo.length; paraIndex++) {
        final int paraStart = paraIndex == 0 ? bufStart : paragraphInfo[paraIndex - 1].paragraphEnd;
        final int paraEnd = paragraphInfo[paraIndex].paragraphEnd;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        // tab stop locations
        float[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                float[] stops = new float[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = (float) spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        final MeasuredParagraph measuredPara = paragraphInfo[paraIndex].measured;
        final char[] chs = measuredPara.getChars();
        final int[] spanEndCache = measuredPara.getSpanEndCache().getRawArray();
        final int[] fmCache = measuredPara.getFontMetrics().getRawArray();
        constraints.setWidth(restWidth);
        constraints.setIndent(firstWidth, firstWidthLineCount);
        constraints.setTabStops(variableTabStops, TAB_INCREMENT);
        LineBreaker.Result res = lineBreaker.computeLineBreaks(measuredPara.getMeasuredText(), constraints, mLineCount);
        int breakCount = res.getLineCount();
        if (lineBreakCapacity < breakCount) {
            lineBreakCapacity = breakCount;
            breaks = new int[lineBreakCapacity];
            lineWidths = new float[lineBreakCapacity];
            ascents = new float[lineBreakCapacity];
            descents = new float[lineBreakCapacity];
            hasTabs = new boolean[lineBreakCapacity];
            hyphenEdits = new int[lineBreakCapacity];
        }
        for (int i = 0; i < breakCount; ++i) {
            breaks[i] = res.getLineBreakOffset(i);
            lineWidths[i] = res.getLineWidth(i);
            ascents[i] = res.getLineAscent(i);
            descents[i] = res.getLineDescent(i);
            hasTabs[i] = res.hasLineTab(i);
            hyphenEdits[i] = packHyphenEdit(res.getStartLineHyphenEdit(i), res.getEndLineHyphenEdit(i));
        }
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (0 < remainingLineCount && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width
            float width = 0;
            // XXX May need to also have starting hyphen edit
            boolean hasTab = false;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += measuredPara.getCharWidthAt(j);
                    }
                }
                hasTab |= hasTabs[i];
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            hasTabs[remainingLineCount - 1] = hasTab;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently
        // measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                final int ascent = fallbackLineSpacing ? Math.min(fmAscent, Math.round(ascents[breakIndex])) : fmAscent;
                final int descent = fallbackLineSpacing ? Math.max(fmDescent, Math.round(descents[breakIndex])) : fmDescent;
                v = out(source, here, endPos, ascent, descent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabs[breakIndex], hyphenEdits[breakIndex], needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, chs, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd) {
            break;
        }
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        final MeasuredParagraph measuredPara = MeasuredParagraph.buildForBidi(source, bufEnd, bufEnd, textDir, null);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, 0, needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
46,<android.widget.ImageView: Mode getImageTintMode()>,28,29,<android.widget.ImageView: Mode getImageTintMode()>,<android.widget.ImageView: Mode getImageTintMode()>,0,"{
    return mDrawableTintMode;
}","{
    return mDrawableBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mDrawableBlendMode) : null;
}",1,"/**
 * Gets the blending mode used to apply the tint to the image Drawable
 * @return the blending mode used to apply the tint to the image Drawable
 * @attr ref android.R.styleable#ImageView_tintMode
 * @see #setImageTintMode(PorterDuff.Mode)
 */
","/**
 * Gets the blending mode used to apply the tint to the image Drawable
 * @return the blending mode used to apply the tint to the image Drawable
 * @attr ref android.R.styleable#ImageView_tintMode
 * @see #setImageTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@Nullable, @InspectableProperty(name = ""tintMode"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from directly returning `mDrawableTintMode` to returning a value converted from `mDrawableBlendMode` using `BlendMode.blendModeToPorterDuffMode(mDrawableBlendMode)` or `null` if `mDrawableBlendMode` is `null`. This change suggests that there was a change within the dependent API as well, since it now relies on `BlendMode.blendModeToPorterDuffMode` to get the result. Therefore, the change types are 1,5.","The changed return statement results in the API potentially returning different types or values (previously the direct value of `mDrawableTintMode`, now a derived value or `null`). This indicates that there could potentially be a change in behavior from the early to the late version of the API, which would classify the CI type as 1."
47,<android.database.sqlite.SQLiteDatabase: boolean deleteDatabase(File)>,28,29,<android.database.sqlite.SQLiteDatabase: boolean deleteDatabase(File)>,<android.database.sqlite.SQLiteDatabase: boolean deleteDatabase(File)>,0,"{
    if (file == null) {
        throw new IllegalArgumentException(""file must not be null"");
    }
    boolean deleted = false;
    deleted |= file.delete();
    deleted |= new File(file.getPath() + ""-journal"").delete();
    deleted |= new File(file.getPath() + ""-shm"").delete();
    deleted |= new File(file.getPath() + ""-wal"").delete();
    File dir = file.getParentFile();
    if (dir != null) {
        final String prefix = file.getName() + ""-mj"";
        File[] files = dir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File candidate) {
                return candidate.getName().startsWith(prefix);
            }
        });
        if (files != null) {
            for (File masterJournal : files) {
                deleted |= masterJournal.delete();
            }
        }
    }
    return deleted;
}","{
    return deleteDatabase(file, /*removeCheckFile=*/
    true);
}",1,"/**
 * Deletes a database including its journal file and other auxiliary files
 * that may have been created by the database engine.
 *
 * @param file The database file path.
 * @return True if the database was successfully deleted.
 */
","/**
 * Deletes a database including its journal file and other auxiliary files
 * that may have been created by the database engine.
 *
 * @param file The database file path.
 * @return True if the database was successfully deleted.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation provided a detailed deletion process using manual file path construction and deletion while the late implementation simply calls a single method 'deleteDatabase' with the file and a boolean flag as parameters. The implementation has been completely replaced and the dependent API has changed, so the code change type is 1,5.","The change from a direct implementation of file deletion to calling another method with additional parameters indicates a potential return of different values, particularly if the behavior of the 'deleteDatabase' method is different from the original inline implementation. Thus, the CI type is 1."
48,<android.app.Activity: boolean navigateUpTo(Intent)>,28,29,<android.app.Activity: boolean navigateUpTo(Intent)>,<android.app.Activity: boolean navigateUpTo(Intent)>,0,"{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        try {
            upIntent.prepareToLeaveProcess(this);
            return ActivityManager.getService().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}","{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        try {
            upIntent.prepareToLeaveProcess(this);
            return ActivityTaskManager.getService().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}",1,"/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
","/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed the service used from ActivityManager.getService() to ActivityTaskManager.getService(), which is a different API being called. This represents a change type of 4 (Other statement changed), and since it's a call to a different API, it is also a type 5 (Dependent API changed).","Although the underlying service call has changed, the change does not alter the method's control flow, exception handling, or return values, provided that ActivityTaskManager.getService() is intended as a direct replacement for ActivityManager.getService(). Thus, assuming that the replacement API provides the same functionality and throws the same exceptions, there would be no Compatibility Issue, which is type 0."
49,"<android.content.Intent: Intent parseIntent(Resources,XmlPullParser,AttributeSet)>",28,29,"<android.content.Intent: Intent parseIntent(Resources,XmlPullParser,AttributeSet)>","<android.content.Intent: Intent parseIntent(Resources,XmlPullParser,AttributeSet)>",0,"{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals(TAG_CATEGORIES)) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals(TAG_EXTRA)) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra(TAG_EXTRA, attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}","{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    intent.setIdentifier(sa.getString(com.android.internal.R.styleable.Intent_identifier));
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals(TAG_CATEGORIES)) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals(TAG_EXTRA)) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra(TAG_EXTRA, attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}",1,"/**
 * Parses the ""intent"" element (and its children) from XML and instantiates
 * an Intent object.  The given XML parser should be located at the tag
 * where parsing should start (often named ""intent""), from which the
 * basic action, data, type, and package and class name will be
 * retrieved.  The function will then parse in to any child elements,
 * looking for <category android:name=""xxx""> tags to add categories and
 * <extra android:name=""xxx"" android:value=""yyy""> to attach extra data
 * to the intent.
 *
 * @param resources The Resources to use when inflating resources.
 * @param parser The XML parser pointing at an ""intent"" tag.
 * @param attrs The AttributeSet interface for retrieving extended
 * attribute data at the current <var>parser</var> location.
 * @return An Intent object matching the XML data.
 * @throws XmlPullParserException If there was an XML parsing error.
 * @throws IOException If there was an I/O error.
 */
","/**
 * Parses the ""intent"" element (and its children) from XML and instantiates
 * an Intent object.  The given XML parser should be located at the tag
 * where parsing should start (often named ""intent""), from which the
 * basic action, data, type, and package and class name will be
 * retrieved.  The function will then parse in to any child elements,
 * looking for <category android:name=""xxx""> tags to add categories and
 * <extra android:name=""xxx"" android:value=""yyy""> to attach extra data
 * to the intent.
 *
 * @param resources The Resources to use when inflating resources.
 * @param parser The XML parser pointing at an ""intent"" tag.
 * @param attrs The AttributeSet interface for retrieving extended
 * attribute data at the current <var>parser</var> location.
 * @return An Intent object matching the XML data.
 * @throws XmlPullParserException If there was an XML parsing error.
 * @throws IOException If there was an I/O error.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"The setIdentifier call has been added, making it a change to invoke a different method on the 'intent' object, and other statements which do not seem to affect the control flow or the logic of method execution were unchanged; thus the code change type is 4,5.","The additional setter method (setIdentifier) allows setting a new property on the 'intent' object, which will affect the state of the 'intent' object returned by the method. Therefore, there is a compatibility issue as the method now returns an 'intent' object with potentially different state, and the CI type is 1."
50,"<android.app.ActivityThread.ApplicationThread: void dumpDbInfo(ParcelFileDescriptor,String[])>",28,29,"<android.app.ActivityThread.ApplicationThread: void dumpDbInfo(ParcelFileDescriptor,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpDbInfo(ParcelFileDescriptor,String[])>",0,"{
    if (mSystemThread) {
        // Ensure this invocation is asynchronous to prevent writer waiting if buffer cannot
        // be consumed. But it must duplicate the file descriptor first, since caller might
        // be closing it.
        final ParcelFileDescriptor dup;
        try {
            dup = pfd.dup();
        } catch (IOException e) {
            Log.w(TAG, ""Could not dup FD "" + pfd.getFileDescriptor().getInt$());
            return;
        } finally {
            IoUtils.closeQuietly(pfd);
        }
        AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    dumpDatabaseInfo(dup, args);
                } finally {
                    IoUtils.closeQuietly(dup);
                }
            }
        });
    } else {
        dumpDatabaseInfo(pfd, args);
        IoUtils.closeQuietly(pfd);
    }
}","{
    if (mSystemThread) {
        // Ensure this invocation is asynchronous to prevent writer waiting if buffer cannot
        // be consumed. But it must duplicate the file descriptor first, since caller might
        // be closing it.
        final ParcelFileDescriptor dup;
        try {
            dup = pfd.dup();
        } catch (IOException e) {
            Log.w(TAG, ""Could not dup FD "" + pfd.getFileDescriptor().getInt$());
            return;
        } finally {
            IoUtils.closeQuietly(pfd);
        }
        AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    dumpDatabaseInfo(dup, args, true);
                } finally {
                    IoUtils.closeQuietly(dup);
                }
            }
        });
    } else {
        dumpDatabaseInfo(pfd, args, false);
        IoUtils.closeQuietly(pfd);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method `dumpDatabaseInfo` was called with different arguments, a boolean value is added to the method call in the late implementation. The signature of `dumpDatabaseInfo` seems to have been changed to accept an additional boolean parameter. This change is an Other statement changed (4) because the call's structure got altered, also a Dependent API changed (5) because it relies on a change in the signature of `dumpDatabaseInfo` and a Return statement changed (1) because a different overload of the method might return different values.",The change to the method call could lead to a different behaviour since now the method receives additional information that may alter its logic or output. This could cause a Compatibility Issue due to potentially different return values or types (1).
51,<android.content.ClipboardManager: boolean hasPrimaryClip()>,28,29,<android.content.ClipboardManager: boolean hasPrimaryClip()>,<android.content.ClipboardManager: boolean hasPrimaryClip()>,0,"{
    try {
        return mService.hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.hasPrimaryClip(mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
","/**
 * Returns true if there is currently a primary clip on the clipboard.
 *
 * <em>If the application is not the default IME or the does not have input focus this will
 * return {@code false}.</em>
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method mService.hasPrimaryClip() now takes an additional parameter in the late version, which indicates a change in the dependent API, making the code change type 5.","Despite the change in the dependent API, the behavior of the API for checking the presence of a primary clip (returning true or false) remains the same, therefore there is no Compatibility Issue related to return values or exception handlings. The CI type is 0."
52,<android.os.Message: Message obtain(Message)>,28,29,<android.os.Message: Message obtain(Message)>,<android.os.Message: Message obtain(Message)>,0,"{
    Message m = obtain();
    m.what = orig.what;
    m.arg1 = orig.arg1;
    m.arg2 = orig.arg2;
    m.obj = orig.obj;
    m.replyTo = orig.replyTo;
    m.sendingUid = orig.sendingUid;
    if (orig.data != null) {
        m.data = new Bundle(orig.data);
    }
    m.target = orig.target;
    m.callback = orig.callback;
    return m;
}","{
    Message m = obtain();
    m.what = orig.what;
    m.arg1 = orig.arg1;
    m.arg2 = orig.arg2;
    m.obj = orig.obj;
    m.replyTo = orig.replyTo;
    m.sendingUid = orig.sendingUid;
    m.workSourceUid = orig.workSourceUid;
    if (orig.data != null) {
        m.data = new Bundle(orig.data);
    }
    m.target = orig.target;
    m.callback = orig.callback;
    return m;
}",1,"/**
 * Same as {@link #obtain()}, but copies the values of an existing
 * message (including its target) into the new one.
 * @param orig Original message to copy.
 * @return A Message object from the global pool.
 */
","/**
 * Same as {@link #obtain()}, but copies the values of an existing
 * message (including its target) into the new one.
 * @param orig Original message to copy.
 * @return A Message object from the global pool.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed slightly with the addition of a new field assignment m.workSourceUid = orig.workSourceUid, which is not a change to a return statement, an exception handling statement, nor does it affect control dependencies. It is merely an assignment to a new field, hence the code change is classified as 4.","The change is an additional field being copied from the original message to the obtained message, which should not affect how the method behaves from the caller's perspective. Thus, it should not lead to a compatibility issue related to different return values/types or exception handlings. Therefore, there is no compatibility issue, and the CI type is 0."
53,"<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>,URLSpan)>",28,29,"<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>,URLSpan)>","<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>,URLSpan)>",0,"{
    mLinks.add(new TextLink(start, end, entityScores, urlSpan));
    return this;
}","{
    return addLink(start, end, entityScores, Bundle.EMPTY, urlSpan);
}",1,"/**
 * @see #addLink(int, int, Map)
 * @param urlSpan An optional URLSpan to delegate to. NOTE: Not parcelled.
 */
","/**
 * @see #addLink(int, int, Map)
 * @param urlSpan An optional URLSpan to delegate to. NOTE: Not parcelled.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The late implementation calls another overload of the method addLink with an additional argument (Bundle.EMPTY), which implies a change in the dependent API, hence the code change type is 5.","There seems to be no difference in how exceptions are handled, nor is there any change in the value that could be returned from the method since `this` is returned in both versions. There is no indication that the overload of addLink being called in the late version would behave differently in terms of the output provided to the caller. Therefore, there is no compatibility issue related to return values or exception handling; the CI type is 0."
54,<android.content.ClipboardManager: void clearPrimaryClip()>,28,29,<android.content.ClipboardManager: void clearPrimaryClip()>,<android.content.ClipboardManager: void clearPrimaryClip()>,0,"{
    try {
        mService.clearPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.clearPrimaryClip(mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Clears any current primary clip on the clipboard.
 *
 * @see #setPrimaryClip(ClipData)
 */
","/**
 * Clears any current primary clip on the clipboard.
 *
 * @see #setPrimaryClip(ClipData)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is in the argument list of the method mService.clearPrimaryClip() where in the late version an additional argument mContext.getUserId() has been added to the existing mContext.getOpPackageName(). This is a dependent API change, so the code change type is 5.","The addition of an extra argument to the method does not alter the behavior of the API in terms of its execution flow or exception handling, so there will be no Compatibility Issue caused by potentially different return values or types or different exceptions. Thus, the CI type is 0."
55,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,0,"{
    enforceSealed();
    return getNodeForAccessibilityId(mLabelForId);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mLabelForId);
}",1,"/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
","/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method getNodeForAccessibilityId(...) being called has changed its parameter list from one parameter (mLabelForId) to three parameters (mConnectionId, mWindowId, mLabelForId), which indicates a change in the dependent API. This is why the code change types are 1 and 5.","The method getLabelFor() potentially returns a different value because of the change in parameters of the dependent method getNodeForAccessibilityId(...). This alteration to the dependent API can affect the behavior of getLabelFor(), thus causing it to potentially return a different AccessibilityNodeInfo object. Therefore, the CI type is 1."
57,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,28,29,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,0,"{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = new FileDescriptor();
        int intfd = Os.fcntlInt(original, (isAtLeastQ() ? F_DUPFD_CLOEXEC : F_DUPFD), 0);
        dup.setInt$(intfd);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */
","/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementation changes from using Os.dup(original) to Os.fcntlInt(...) with additional condition checks (isAtLeastQ()), allocation of a new FileDescriptor and setting an integer file descriptor (dup.setInt$(intfd)). These are control dependency changes (due to the condition check), other statement changes (due to new variable initialization and method invocation), and dependent API changes because it relies on a different OS call that might behave differently (Os.dup versus Os.fcntlInt). The code change type is therefore 1,3,4,5.","These changes in the API could lead to the API returning a different value, due to the different system calls being used (dup versus fcntlInt) for file descriptor duplication and due to the additional condition that checks the OS version for setting flags. Hence, the potential CI type is 1."
58,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getConnectedDevices()>,28,29,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getConnectedDevices()>,0,"{
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}","{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation between the early and late versions. The method body and the annotations are identical, therefore, no change is detected.","Since there is no change in the code, there can't be any compatibility issues between the versions."
59,<android.view.autofill.AutofillManager: UserData getUserData()>,28,29,<android.view.autofill.AutofillManager: UserData getUserData()>,<android.view.autofill.AutofillManager: UserData getUserData()>,0,"{
    try {
        return mService.getUserData();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    try {
        final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
        mService.getUserData(receiver);
        return receiver.getParcelableResult();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}",1,"/**
 * Gets the user data used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return value previously set by {@link #setUserData(UserData)} or {@code null} if it was
 * reset or if the caller currently does not have an enabled autofill service for the user.
 */
","/**
 * Gets the user data used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return value previously set by {@link #setUserData(UserData)} or {@code null} if it was
 * reset or if the caller currently does not have an enabled autofill service for the user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The method in the try block changed from directly returning the result of mService.getUserData() to creating a SyncResultReceiver object, calling mService.getUserData(receiver), and then returning the result from the receiver object. There's a change in the dependent API (mService.getUserData method) from a direct method call to an overloading method where it takes a SyncResultReceiver object as a parameter. Thus, the code change type is 1 for the return statement changed, and 5 for the dependent API changed.","The change in the implementation of getting user data through a SyncResultReceiver object can potentially return a different object type or value because the way the data is fetched has been altered. Additionally, there is a possibility that the behavior of the receiver.getParcelableResult() method may be different from the previous direct call to mService.getUserData(). Therefore, the CI type is 1 for the potential different return values or types."
60,"<android.app.Service: void startForeground(int,Notification)>",28,29,"<android.app.Service: void startForeground(int,Notification)>","<android.app.Service: void startForeground(int,Notification)>",0,"{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0, FOREGROUND_SERVICE_TYPE_MANIFEST);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * If your service is started (running through {@link Context#startService(Intent)}), then
 * also make this service run in the foreground, supplying the ongoing
 * notification to be shown to the user while in this state.
 * By default started services are background, meaning that their process won't be given
 * foreground CPU scheduling (unless something else in that process is foreground) and,
 * if the system needs to kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You use
 * {@link #startForeground} if killing your service would be disruptive to the user, such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * <p>Note that calling this method does <em>not</em> put the service in the started state
 * itself, even though the name sounds like it.  You must always call
 * {@link #startService(Intent)} first to tell the system it should keep the service running,
 * and then use this method to tell it to keep it running harder.</p>
 *
 * <p>Apps targeting API {@link android.os.Build.VERSION_CODES#P} or later must request
 * the permission {@link android.Manifest.permission#FOREGROUND_SERVICE} in order to use
 * this API.</p>
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 *
 * @see #stopForeground(boolean)
 */
","/**
 * If your service is started (running through {@link Context#startService(Intent)}), then
 * also make this service run in the foreground, supplying the ongoing
 * notification to be shown to the user while in this state.
 * By default started services are background, meaning that their process won't be given
 * foreground CPU scheduling (unless something else in that process is foreground) and,
 * if the system needs to kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You use
 * {@link #startForeground} if killing your service would be disruptive to the user, such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * <p>Note that calling this method does <em>not</em> put the service in the started state
 * itself, even though the name sounds like it.  You must always call
 * {@link #startService(Intent)} first to tell the system it should keep the service running,
 * and then use this method to tell it to keep it running harder.</p>
 *
 * <p>Apps targeting API {@link android.os.Build.VERSION_CODES#P} or later must request
 * the permission {@link android.Manifest.permission#FOREGROUND_SERVICE} in order to use
 * this API.</p>
 *
 * <p>Apps built with SDK version {@link android.os.Build.VERSION_CODES#Q} or later can specify
 * the foreground service types using attribute {@link android.R.attr#foregroundServiceType} in
 * service element of manifest file. The value of attribute
 * {@link android.R.attr#foregroundServiceType} can be multiple flags ORed together.</p>
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 *
 * @see #stopForeground(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method 'setServiceForeground' is called with an additional parameter 'FOREGROUND_SERVICE_TYPE_MANIFEST' in the late version, so the change type is 5 (Dependent API changed).","Since there are no changes in the control flow or exception handling and the change does not affect the return type or value (the method is void), there is no compatibility issue. The change to the dependent API does not inherently affect the behavior of this API in terms of return value or exception handling. Therefore, it is assumed that the system will handle the new parameter appropriately without affecting the clients using this Service method, and the CI type is 0 (No compatibility issue)."
62,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",28,29,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            result = ActivityManager.getService().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            result = ActivityTaskManager.getService().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API used within the method, `ActivityManager.getService()`, is changed to `ActivityTaskManager.getService()`. This is a change in the dependent API, so the code change type is 5.","Assuming that `ActivityTaskManager.getService()` is intended to be functionally equivalent to `ActivityManager.getService()` and does not alter the behavior of the API from the caller's perspective, there would be no Compatibility Issue. Therefore, the CI type is 0. However, without information about the behavior of the new `ActivityTaskManager.getService()` method, it is assumed to be a simple rename/refactor with no functional changes."
63,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(int)>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(int)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(int)>,0,"{
    checkArgumentFormat(format);
    int internalFormat = imageFormatToInternal(format);
    int dataspace = imageFormatToDataspace(format);
    if (dataspace == HAL_DATASPACE_DEPTH) {
        return mDepthOutputFormats.indexOfKey(internalFormat) >= 0;
    } else {
        return getFormatsMap(/*output*/
        true).indexOfKey(internalFormat) >= 0;
    }
}","{
    checkArgumentFormat(format);
    int internalFormat = imageFormatToInternal(format);
    int dataspace = imageFormatToDataspace(format);
    if (dataspace == HAL_DATASPACE_DEPTH) {
        return mDepthOutputFormats.indexOfKey(internalFormat) >= 0;
    } else if (dataspace == HAL_DATASPACE_DYNAMIC_DEPTH) {
        return mDynamicDepthOutputFormats.indexOfKey(internalFormat) >= 0;
    } else if (dataspace == HAL_DATASPACE_HEIF) {
        return mHeicOutputFormats.indexOfKey(internalFormat) >= 0;
    } else {
        return getFormatsMap(/*output*/
        true).indexOfKey(internalFormat) >= 0;
    }
}",1,"/**
 * Determine whether or not output surfaces with a particular user-defined format can be passed
 * {@link CameraDevice#createCaptureSession createCaptureSession}.
 *
 * <p>This method determines that the output {@code format} is supported by the camera device;
 * each output {@code surface} target may or may not itself support that {@code format}.
 * Refer to the class which provides the surface for additional documentation.</p>
 *
 * <p>Formats for which this returns {@code true} are guaranteed to exist in the result
 * returned by {@link #getOutputSizes}.</p>
 *
 * @param format an image format from either {@link ImageFormat} or {@link PixelFormat}
 * @return
 * {@code true} iff using a {@code surface} with this {@code format} will be
 * supported with {@link CameraDevice#createCaptureSession}
 *
 * @throws IllegalArgumentException
 * if the image format was not a defined named constant
 * from either {@link ImageFormat} or {@link PixelFormat}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see CameraDevice#createCaptureSession
 */
","/**
 * Determine whether or not output surfaces with a particular user-defined format can be passed
 * {@link CameraDevice#createCaptureSession createCaptureSession}.
 *
 * <p>This method determines that the output {@code format} is supported by the camera device;
 * each output {@code surface} target may or may not itself support that {@code format}.
 * Refer to the class which provides the surface for additional documentation.</p>
 *
 * <p>Formats for which this returns {@code true} are guaranteed to exist in the result
 * returned by {@link #getOutputSizes}.</p>
 *
 * @param format an image format from either {@link ImageFormat} or {@link PixelFormat}
 * @return
 * {@code true} iff using a {@code surface} with this {@code format} will be
 * supported with {@link CameraDevice#createCaptureSession}
 *
 * @throws IllegalArgumentException
 * if the image format was not a defined named constant
 * from either {@link ImageFormat} or {@link PixelFormat}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see CameraDevice#createCaptureSession
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The control dependency has changed by introducing new conditions for 'dataspace' that checks additional dataspace types such as HAL_DATASPACE_DYNAMIC_DEPTH and HAL_DATASPACE_HEIF, plus the introduction of new maps like mDynamicDepthOutputFormats and mHeicOutputFormats being checked under these conditions represents a dependent API change as well. Therefore, the code change types are 3 and 5.","Due to the added conditions for different data spaces and new logic to check related output formats, the API could potentially return different boolean values when the 'dataspace' variable matches the new conditions that were not present in the early version. This implies a CI type of 1 because of the potential for different return values."
64,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,28,29,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,0,"{
    final CharSequence title = mBundle.getCharSequence(KEY_TITLE);
    final CharSequence negative = mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
    if (TextUtils.isEmpty(title)) {
        throw new IllegalArgumentException(""Title must be set and non-empty"");
    } else if (TextUtils.isEmpty(negative)) {
        throw new IllegalArgumentException(""Negative text must be set and non-empty"");
    }
    return new BiometricPrompt(mContext, mBundle, mPositiveButtonInfo, mNegativeButtonInfo);
}","{
    final CharSequence title = mBundle.getCharSequence(KEY_TITLE);
    final CharSequence negative = mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
    final boolean useDefaultTitle = mBundle.getBoolean(KEY_USE_DEFAULT_TITLE);
    final boolean enableFallback = mBundle.getBoolean(KEY_ALLOW_DEVICE_CREDENTIAL);
    if (TextUtils.isEmpty(title) && !useDefaultTitle) {
        throw new IllegalArgumentException(""Title must be set and non-empty"");
    } else if (TextUtils.isEmpty(negative) && !enableFallback) {
        throw new IllegalArgumentException(""Negative text must be set and non-empty"");
    } else if (!TextUtils.isEmpty(negative) && enableFallback) {
        throw new IllegalArgumentException(""Can't have both negative button behavior"" + "" and device credential enabled"");
    }
    return new BiometricPrompt(mContext, mBundle, mPositiveButtonInfo, mNegativeButtonInfo);
}",1,"/**
 * Creates a {@link BiometricPrompt}.
 * @return a {@link BiometricPrompt}
 * @throws IllegalArgumentException if any of the required fields are not set.
 */
","/**
 * Creates a {@link BiometricPrompt}.
 * @return a {@link BiometricPrompt}
 * @throws IllegalArgumentException if any of the required fields are not set.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",1,"The late implementation has introduced two new variable initializations (useDefaultTitle and enableFallback), as well as additional condition checks associated with these variables in 'if' statements, which are changes in control dependency (type 3) and other statements (type 4).","The new conditions introduced change the circumstances under which exceptions might be thrown, which creates a compatibility issue (type 1) by potentially altering the exceptions thrown (type 2) and changing the conditions under which the method returns a value (type 1)."
65,<android.os.ZygoteProcess.ZygoteState: boolean matches(String)>,28,29,<android.os.ZygoteProcess.ZygoteState: boolean matches(String)>,<android.os.ZygoteProcess.ZygoteState: boolean matches(String)>,0,"{
    return abiList.contains(abi);
}","{
    return mAbiList.contains(abi);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is merely a renaming of a variable from abiList to mAbiList, which does not affect the method's logic or return type, hence code change type is 4.",There is no Compatibility Issue because the change in the variable name does not affect the behavior of the method from an API consumer's point of view; the method signature remains the same and the logic is unaltered.
66,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int)>",28,29,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int)>","<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int)>",0,"{
    return showSoftInput(view, flags, null);
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.showSoftInput(view, flags);
    }
    return showSoftInput(view, flags, null);
}",1,"/**
 * Synonym for {@link #showSoftInput(View, int, ResultReceiver)} without
 * a result receiver: explicitly request that the current input method's
 * soft input area be shown to the user, if needed.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 */
","/**
 * Synonym for {@link #showSoftInput(View, int, ResultReceiver)} without
 * a result receiver: explicitly request that the current input method's
 * soft input area be shown to the user, if needed.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"There's new control flow introduced to check for a context mismatch and potentially use a different InputMethodManager instance, also a call to a new method getFallbackInputMethodManagerIfNecessary(view). These are changes of type 3 (Control dependency changed) and 5 (Dependent API changed).","Given that the late version includes additional logic to possibly return a result from a different InputMethodManager instance based on the context check, this could lead to a different return value. Therefore, it is a CI of type 1 (Compatibility Issue caused by potential different return values)."
67,"<android.text.PrecomputedText: PrecomputedText create(CharSequence,Params)>",28,29,"<android.text.PrecomputedText: PrecomputedText create(CharSequence,Params)>","<android.text.PrecomputedText: PrecomputedText create(CharSequence,Params)>",0,"{
    ParagraphInfo[] paraInfo = createMeasuredParagraphs(text, params, 0, text.length(), true);
    return new PrecomputedText(text, 0, text.length(), params, paraInfo);
}","{
    ParagraphInfo[] paraInfo = null;
    if (text instanceof PrecomputedText) {
        final PrecomputedText hintPct = (PrecomputedText) text;
        final PrecomputedText.Params hintParams = hintPct.getParams();
        @Params.CheckResultUsableResult final int checkResult = hintParams.checkResultUsable(params.mPaint, params.mTextDir, params.mBreakStrategy, params.mHyphenationFrequency);
        switch(checkResult) {
            case Params.USABLE:
                return hintPct;
            case Params.NEED_RECOMPUTE:
                // hyphenation frequency must be the same.
                if (params.getBreakStrategy() == hintParams.getBreakStrategy() && params.getHyphenationFrequency() == hintParams.getHyphenationFrequency()) {
                    paraInfo = createMeasuredParagraphsFromPrecomputedText(hintPct, params, true);
                }
                break;
            case Params.UNUSABLE:
        }
    }
    if (paraInfo == null) {
        paraInfo = createMeasuredParagraphs(text, params, 0, text.length(), true);
    }
    return new PrecomputedText(text, 0, text.length(), params, paraInfo);
}",1,"/**
 * Create a new {@link PrecomputedText} which will pre-compute text measurement and glyph
 * positioning information.
 * <p>
 * This can be expensive, so computing this on a background thread before your text will be
 * presented can save work on the UI thread.
 * </p>
 *
 * Note that any {@link android.text.NoCopySpan} attached to the text won't be passed to the
 * created PrecomputedText.
 *
 * @param text the text to be measured
 * @param params parameters that define how text will be precomputed
 * @return A {@link PrecomputedText}
 */
","/**
 * Create a new {@link PrecomputedText} which will pre-compute text measurement and glyph
 * positioning information.
 * <p>
 * This can be expensive, so computing this on a background thread before your text will be
 * presented can save work on the UI thread.
 * </p>
 *
 * Note that any {@link android.text.NoCopySpan} attached to the text won't be passed to the
 * created PrecomputedText.
 *
 * @param text the text to be measured
 * @param params parameters that define how text will be precomputed
 * @return A {@link PrecomputedText}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version added control flow to check if the given CharSequence is an instance of PrecomputedText and has matching parameters which can affect the returned value. It now potentially returns the hint PrecomputedText instead of always creating a new one and additional logic has been added before calling 'createMeasuredParagraphs'. This includes a 'switch' statement which is new control dependency. Furthermore, the method 'createMeasuredParagraphsFromPrecomputedText' is introduced which is not present in the early version. Therefore, the change involves return statement change, control dependency change, and other statement change, so the code change type is 1,3,4.","The added control flow and new return possibility make the API return a different value under certain conditions. There now could be a case where the same input parameters to the method would result in returning an existing 'PrecomputedText' object in the late version while it would have resulted in a new object in the early version. This could lead to changes in the object that is returned by the method. Hence, the CI type is 1."
69,<android.app.ActivityManager: int getLockTaskModeState()>,28,29,<android.app.ActivityManager: int getLockTaskModeState()>,<android.app.ActivityManager: int getLockTaskModeState()>,0,"{
    try {
        return getService().getLockTaskModeState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getTaskService().getLockTaskModeState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
","/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method that is being called has changed from getService().getLockTaskModeState() to getTaskService().getLockTaskModeState(), which indicates a change in the dependent API. Therefore, the change type is 5.","There is no indication that the behavior or contract of getLockTaskModeState() has changed, despite the change in how the service is retrieved. The surrounding try-catch block and the logic remain the same, which means there's no compatibility issue introduced directly by this change. Thus, the CI type is 0."
71,<android.app.ActivityManager.TaskDescription: String toString()>,28,29,<android.app.ActivityManager.TaskDescription: String toString()>,<android.app.ActivityManager.TaskDescription: String toString()>,0,"{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconRes: "" + mIconRes + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mColorBackground + "" navigationBarColor: "" + mNavigationBarColor;
}","{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconRes: "" + mIconRes + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mStatusBarColor + (mEnsureStatusBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" navigationBarColor: "" + mNavigationBarColor + (mEnsureNavigationBarContrastWhenTransparent ? "" (contrast when transparent)"" : """");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The change includes appending additional strings to the return value, specifically related to 'mEnsureStatusBarContrastWhenTransparent' and 'mEnsureNavigationBarContrastWhenTransparent'. This leads to a different structure of the returned String. Apart from the return statement change, the change is also due to string concatenation which is not control dependent or exception handling. Therefore, the code change types are 1 (return statement changed) and 4 (other statement changed).","The late version of the API appends new conditions to the return statement that adds substrings based on certain properties ('mEnsureStatusBarContrastWhenTransparent' and 'mEnsureNavigationBarContrastWhenTransparent'). Therefore, it potentially returns a different value than the early version. Hence, the CI type is 1 (potential different return values)."
72,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,28,29,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                final boolean hoverExitPending = event.isHoverExitPending();
                event.setHoverExitPending(true);
                dispatchTransformedGenericPointerEvent(event, // move
                child);
                event.setHoverExitPending(hoverExitPending);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it and the view group
    // itself is not currently being hover-exited.
    boolean newHoveredSelf = !handled && (action != MotionEvent.ACTION_HOVER_EXIT) && !event.isHoverExitPending();
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}","{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                final boolean hoverExitPending = event.isHoverExitPending();
                event.setHoverExitPending(true);
                dispatchTransformedGenericPointerEvent(event, // move
                child);
                event.setHoverExitPending(hoverExitPending);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it and the view group
    // itself is not currently being hover-exited.
    boolean newHoveredSelf = !handled && (action != MotionEvent.ACTION_HOVER_EXIT) && !event.isHoverExitPending();
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}",1,,,-1,"[@SuppressWarnings({ ""ConstantConditions"" }), @Override]","[@SuppressWarnings({ ""ConstantConditions"" }), @Override]",-1,-1,-1,-1,-1,-1,,,,
73,<android.app.Activity: int getMaxNumPictureInPictureActions()>,28,29,<android.app.Activity: int getMaxNumPictureInPictureActions()>,<android.app.Activity: int getMaxNumPictureInPictureActions()>,0,"{
    try {
        return ActivityManagerNative.getDefault().getMaxNumPictureInPictureActions(mToken);
    } catch (RemoteException e) {
        return 0;
    }
}","{
    try {
        return ActivityTaskManager.getService().getMaxNumPictureInPictureActions(mToken);
    } catch (RemoteException e) {
        return 0;
    }
}",1,"/**
 * Return the number of actions that will be displayed in the picture-in-picture UI when the
 * user interacts with the activity currently in picture-in-picture mode. This number may change
 * if the global configuration changes (ie. if the device is plugged into an external display),
 * but will always be larger than three.
 */
","/**
 * Return the number of actions that will be displayed in the picture-in-picture UI when the
 * user interacts with the activity currently in picture-in-picture mode. This number may change
 * if the global configuration changes (ie. if the device is plugged into an external display),
 * but will always be larger than three.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getMaxNumPictureInPictureActions is being called on a different service (ActivityManagerNative.getDefault() vs. ActivityTaskManager.getService()), indicating a change in the Dependent API. Thus, the code change type is 5.","There is no Compatibility Issue, because the try block still attempts to perform the same operation and return the same value, and the catch block handles the exception in the same way by returning 0. The underlying implementation details change, but from the perspective of the API user, the behavior remains the same. Hence, the Compatibility Issue type is 0."
75,"<android.provider.DocumentsContract: IntentSender createWebLinkIntent(ContentResolver,Uri,Bundle)>",28,29,"<android.provider.DocumentsContract: IntentSender createWebLinkIntent(ContentResolver,Uri,Bundle)>","<android.provider.DocumentsContract: IntentSender createWebLinkIntent(ContentResolver,Uri,Bundle)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(uri.getAuthority());
    try {
        return createWebLinkIntent(client, uri, options);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to create a web link intent"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, uri);
        // avoid overriding the Uri.
        if (options != null) {
            in.putBundle(EXTRA_OPTIONS, options);
        }
        final Bundle out = content.call(uri.getAuthority(), METHOD_CREATE_WEB_LINK_INTENT, null, in);
        return out.getParcelable(DocumentsContract.EXTRA_RESULT);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to create a web link intent"", e);
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Creates an intent for obtaining a web link for the specified document.
 *
 * <p>Note, that due to internal limitations, if there is already a web link
 * intent created for the specified document but with different options,
 * then it may be overriden.
 *
 * <p>Providers are required to show confirmation UI for all new permissions granted
 * for the linked document.
 *
 * <p>If list of recipients is known, then it should be passed in options as
 * {@link Intent#EXTRA_EMAIL} as a list of email addresses. Note, that
 * this is just a hint for the provider, which can ignore the list. In either
 * case the provider is required to show a UI for letting the user confirm
 * any new permission grants.
 *
 * <p>Note, that the entire <code>options</code> bundle will be sent to the provider
 * backing the passed <code>uri</code>. Make sure that you trust the provider
 * before passing any sensitive information.
 *
 * <p>Since this API may show a UI, it cannot be called from background.
 *
 * <p>In order to obtain the Web Link use code like this:
 * <pre><code>
 * void onSomethingHappened() {
 * IntentSender sender = DocumentsContract.createWebLinkIntent(<i>...</i>);
 * if (sender != null) {
 * startIntentSenderForResult(
 * sender,
 * WEB_LINK_REQUEST_CODE,
 * null, 0, 0, 0, null);
 * }
 * }
 *
 * <i>(...)</i>
 *
 * void onActivityResult(int requestCode, int resultCode, Intent data) {
 * if (requestCode == WEB_LINK_REQUEST_CODE && resultCode == RESULT_OK) {
 * Uri weblinkUri = data.getData();
 * <i>...</i>
 * }
 * }
 * </code></pre>
 *
 * @param uri uri for the document to create a link to.
 * @param options Extra information for generating the link.
 * @return an intent sender to obtain the web link, or null if the document
 * is not linkable, or creating the intent sender failed.
 * @see DocumentsProvider#createWebLinkIntent(String, Bundle)
 * @see Intent#EXTRA_EMAIL
 */
","/**
 * Creates an intent for obtaining a web link for the specified document.
 *
 * <p>Note, that due to internal limitations, if there is already a web link
 * intent created for the specified document but with different options,
 * then it may be overridden.
 *
 * <p>Providers are required to show confirmation UI for all new permissions granted
 * for the linked document.
 *
 * <p>If list of recipients is known, then it should be passed in options as
 * {@link Intent#EXTRA_EMAIL} as a list of email addresses. Note, that
 * this is just a hint for the provider, which can ignore the list. In either
 * case the provider is required to show a UI for letting the user confirm
 * any new permission grants.
 *
 * <p>Note, that the entire <code>options</code> bundle will be sent to the provider
 * backing the passed <code>uri</code>. Make sure that you trust the provider
 * before passing any sensitive information.
 *
 * <p>Since this API may show a UI, it cannot be called from background.
 *
 * <p>In order to obtain the Web Link use code like this:
 * <pre><code>
 * void onSomethingHappened() {
 * IntentSender sender = DocumentsContract.createWebLinkIntent(<i>...</i>);
 * if (sender != null) {
 * startIntentSenderForResult(
 * sender,
 * WEB_LINK_REQUEST_CODE,
 * null, 0, 0, 0, null);
 * }
 * }
 *
 * <i>(...)</i>
 *
 * void onActivityResult(int requestCode, int resultCode, Intent data) {
 * if (requestCode == WEB_LINK_REQUEST_CODE && resultCode == RESULT_OK) {
 * Uri weblinkUri = data.getData();
 * <i>...</i>
 * }
 * }
 * </code></pre>
 *
 * @param uri uri for the document to create a link to.
 * @param options Extra information for generating the link.
 * @return an intent sender to obtain the web link, or null if the document
 * is not linkable, or creating the intent sender failed.
 * @see DocumentsProvider#createWebLinkIntent(String, Bundle)
 * @see Intent#EXTRA_EMAIL
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2",The implementation has changed significantly: ,"- The method `rethrowIfNecessary(resolver, e)` has been changed to `rethrowIfNecessary(e)`, which implies a change in the method signature being invoked."
76,<android.service.notification.Condition: String toString()>,28,29,<android.service.notification.Condition: String toString()>,<android.service.notification.Condition: String toString()>,0,"{
    return new StringBuilder(Condition.class.getSimpleName()).append('[').append(""id="").append(id).append("",summary="").append(summary).append("",line1="").append(line1).append("",line2="").append(line2).append("",icon="").append(icon).append("",state="").append(stateToString(state)).append("",flags="").append(flags).append(']').toString();
}","{
    return new StringBuilder(Condition.class.getSimpleName()).append('[').append(""state="").append(stateToString(state)).append("",id="").append(id).append("",summary="").append(summary).append("",line1="").append(line1).append("",line2="").append(line2).append("",icon="").append(icon).append("",flags="").append(flags).append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is the reordering of string parts that are being appended to the StringBuilder, but since all parts and their associated text are present in both versions, just in a different order, this is categorized as 4.","There is no Compatibility Issue, as the order of concatenated strings in a toString() method does not affect the functionality of the method. It only changes the order of the information in the returned string, which is not typically relied upon for programmatic decision-making, hence it is not a behavioral change. The method still returns a String representing the same data, therefore, the CI type is 0."
77,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,28,29,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,<android.app.InstantAppResolverService.ServiceHandler: void handleMessage(Message)>,0,"{
    final int action = message.what;
    switch(action) {
        case MSG_GET_INSTANT_APP_RESOLVE_INFO:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final String token = (String) args.arg3;
                final Intent intent = (Intent) args.arg4;
                final int sequence = message.arg1;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase1 request;"" + "" prefix: "" + Arrays.toString(digestPrefix));
                }
                onGetInstantAppResolveInfo(intent, digestPrefix, token, new InstantAppResolutionCallback(sequence, callback));
            }
            break;
        case MSG_GET_INSTANT_APP_INTENT_FILTER:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final String token = (String) args.arg3;
                final Intent intent = (Intent) args.arg4;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase2 request;"" + "" prefix: "" + Arrays.toString(digestPrefix));
                }
                onGetInstantAppIntentFilter(intent, digestPrefix, token, new InstantAppResolutionCallback(-1, /*sequence*/
                callback));
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}","{
    final int action = message.what;
    switch(action) {
        case MSG_GET_INSTANT_APP_RESOLVE_INFO:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final int userId = (int) args.arg3;
                final String token = (String) args.arg4;
                final Intent intent = (Intent) args.arg5;
                final int sequence = message.arg1;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase1 request;"" + "" prefix: "" + Arrays.toString(digestPrefix) + "", userId: "" + userId);
                }
                onGetInstantAppResolveInfo(intent, digestPrefix, UserHandle.of(userId), token, new InstantAppResolutionCallback(sequence, callback));
            }
            break;
        case MSG_GET_INSTANT_APP_INTENT_FILTER:
            {
                final SomeArgs args = (SomeArgs) message.obj;
                final IRemoteCallback callback = (IRemoteCallback) args.arg1;
                final int[] digestPrefix = (int[]) args.arg2;
                final int userId = (int) args.arg3;
                final String token = (String) args.arg4;
                final Intent intent = (Intent) args.arg5;
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, ""["" + token + ""] Phase2 request;"" + "" prefix: "" + Arrays.toString(digestPrefix) + "", userId: "" + userId);
                }
                onGetInstantAppIntentFilter(intent, digestPrefix, UserHandle.of(userId), token, new InstantAppResolutionCallback(-1, /*sequence*/
                callback));
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + action);
            }
    }
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The change in the handleMessage method includes reordering of arguments and addition of a new argument. The third and fourth arguments in the early version 'args.arg3' and 'args.arg4' represent 'String token' and 'Intent intent', respectively. In the late version, these have moved to the fourth and fifth positions 'args.arg4' and 'args.arg5', and a new third argument 'int userId' has been introduced. These changes affect the control dependency, as they alter the method call onGetInstantAppResolveInfo() and onGetInstantAppIntentFilter() in each case branch, counting as Control dependency change (3). Other statements, such as debug logging inside the if (DEBUG_INSTANT) block, have also been altered to include the userId in the log message, which counts as an Other statement changed (4). The method calls have changed the signature due to the addition of new arguments and a different class being used, UserHandle.of(userId), which counts as a Dependent API changed (5).","The introduction of a new parameter alters the behavior of the calls to onGetInstantAppResolveInfo() and onGetInstantAppIntentFilter() methods. These dependent APIs could potentially behave differently, leading to Compatibility Issue due to potential different return values or types (1). Additionally, the exception handling has not changed, but the addition of UserHandle.of(userId) could potentially throw a RuntimeException if the userId is invalid when constructing the UserHandle object, leading to a second type of Compatibility Issue caused by potential different exception handlings (2)."
78,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitDiskReads()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitDiskReads()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitDiskReads()>,0,"{
    return disable(DETECT_DISK_READ);
}","{
    return disable(DETECT_THREAD_DISK_READ);
}",1,"/**
 * Disable detection of disk reads.
 */
","/**
 * Disable detection of disk reads.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling disable(DETECT_DISK_READ) to calling disable(DETECT_THREAD_DISK_READ), indicating a change in the dependent API. This change is reflected in both the return statement and dependent API, so the code change types are 1,5.","With the change in the method name of the disable() call from DETECT_DISK_READ to DETECT_THREAD_DISK_READ, this signifies a potential change in behavior as it might disable a different set of checks or operations which could result in the API returning different values. Therefore, this constitutes a compatibility issue of type 1."
79,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>",28,29,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>",0,"{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister client.
                    mBluetoothGatt.unregisterClient(scannerId);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, ActivityThread.currentOpPackageName());
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else if (status == ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY) {
            // applicaiton was scanning too frequently
            mScannerId = -2;
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}","{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister scanner.
                    mBluetoothGatt.unregisterScanner(scannerId);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, ActivityThread.currentOpPackageName());
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else if (status == ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY) {
            // applicaiton was scanning too frequently
            mScannerId = -2;
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the method name from unregisterClient(scannerId) to unregisterScanner(scannerId), within the try block, which does not alter control flow or return values, so the code change type is 4.","Since the method call change does not affect how exceptions are handled and does not change the return type or value, no Compatibility Issue arises from this code change."
80,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,28,29,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    // TODO: Decide whether to detect non SDK API usage beyond a certain API level.
    return this;
}","{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    if (targetSdk >= Build.VERSION_CODES.Q) {
        detectCredentialProtectedWhileLocked();
    }
    return this;
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
 * other closable objects but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
 * other closable objects but will likely expand in future releases.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new conditional block added to check if the targetSdk is greater than or equal to Build.VERSION_CODES.Q, and the method detectCredentialProtectedWhileLocked() is called if that condition is true. It also includes the addition of a @NonNull annotation, which is not a change in the code implementation, so it is not relevant for the Compatibility Issue detection. Because of the 'return this;' statement at the end of both method implementations that effectively remains unchanged, the type of code change is 3 and 4 for adding a conditional and calling a new method without changing any existing behavior or logic.","There is no Compatibility Issue introduced in this change because the method's behavior is extended in a backward-compatible manner. Existing functionality is not modified, and no new return types or exceptions are introduced that could cause a different behavior in existing code. The new method detectCredentialProtectedWhileLocked() will only be called for applications targeting SDK version Q or later. For applications targeting earlier SDK versions, the method behaves as it did before. Therefore, the CI type is 0."
81,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,28,29,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,0,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return ""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new case statement (FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK) has been added to the switch control structure, introducing a new return value, so the change type is 1,3.","The introduction of a new return value (FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK) for the additional flag case might cause the late version of the API to return a different value when this flag is used, therefore, the CI type is 1."
82,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",28,29,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        Log.e(TAG, ""getProfileProxy(): BluetoothHealth is deprecated"");
        return false;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        if (isHearingAidProfileSupported()) {
            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        }
        return false;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH}, {@link
 * BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}. {@link BluetoothProfile#GATT} or
 * {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP},
 * {@link BluetoothProfile#GATT}, {@link BluetoothProfile#HEARING_AID}, or {@link
 * BluetoothProfile#GATT_SERVER}. Clients must implement {@link
 * BluetoothProfile.ServiceListener} to get notified of the connection status and to get the
 * proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, {@link
 * BluetoothProfile#HEARING_AID} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
83,<android.service.voice.VoiceInteractionSession: void doDestroy()>,28,29,<android.service.voice.VoiceInteractionSession: void doDestroy()>,<android.service.voice.VoiceInteractionSession: void doDestroy()>,0,"{
    onDestroy();
    if (mInitialized) {
        mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
        if (mWindowAdded) {
            mWindow.dismiss();
            mWindowAdded = false;
        }
        mInitialized = false;
    }
}","{
    onDestroy();
    if (mKillCallback != null) {
        try {
            mKillCallback.cancel();
        } catch (RemoteException e) {
        /* ignore */
        }
        mKillCallback = null;
    }
    if (mInitialized) {
        mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
        if (mWindowAdded) {
            mWindow.dismiss();
            mWindowAdded = false;
        }
        mInitialized = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's an introduction of a new condition block involving 'mKillCallback' which is handled differently from the previous version. However, this does not affect the method's return type nor does it throw a new exception; it's an internal state change. So the change type is 4.","While there is a change in how the internal state is handled with the addition of a new block that involves 'mKillCallback', it does not affect the method return type or exception handling directly visible to the callers, which means there is no Compatibility Issue; thus, CI type is 0."
84,<android.nfc.NfcAdapter: boolean isNdefPushEnabled()>,28,29,<android.nfc.NfcAdapter: boolean isNdefPushEnabled()>,<android.nfc.NfcAdapter: boolean isNdefPushEnabled()>,0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    try {
        return sService.isNdefPushEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return false;
        }
    }
    try {
        return sService.isNdefPushEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}",1,"/**
 * Return true if the NDEF Push (Android Beam) feature is enabled.
 * <p>This function will return true only if both NFC is enabled, and the
 * NDEF Push feature is enabled.
 * <p>Note that if NFC is enabled but NDEF Push is disabled then this
 * device can still <i>receive</i> NDEF messages, it just cannot send them.
 * <p>Applications cannot directly toggle the NDEF Push feature, but they
 * can request Settings UI allowing the user to toggle NDEF Push using
 * <code>startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS))</code>
 * <p>Example usage in an Activity that requires NDEF Push:
 * <p><pre>
 * protected void onResume() {
 * super.onResume();
 * if (!nfcAdapter.isEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFC_SETTINGS));
 * } else if (!nfcAdapter.isNdefPushEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS));
 * }
 * }</pre>
 *
 * @see android.provider.Settings#ACTION_NFCSHARING_SETTINGS
 * @return true if NDEF Push feature is enabled
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Return true if the NDEF Push (Android Beam) feature is enabled.
 * <p>This function will return true only if both NFC is enabled, and the
 * NDEF Push feature is enabled.
 * <p>Note that if NFC is enabled but NDEF Push is disabled then this
 * device can still <i>receive</i> NDEF messages, it just cannot send them.
 * <p>Applications cannot directly toggle the NDEF Push feature, but they
 * can request Settings UI allowing the user to toggle NDEF Push using
 * <code>startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS))</code>
 * <p>Example usage in an Activity that requires NDEF Push:
 * <p><pre>
 * protected void onResume() {
 * super.onResume();
 * if (!nfcAdapter.isEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFC_SETTINGS));
 * } else if (!nfcAdapter.isNdefPushEnabled()) {
 * startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS));
 * }
 * }</pre>
 *
 * @see android.provider.Settings#ACTION_NFCSHARING_SETTINGS
 * @return true if NDEF Push feature is enabled
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated this feature is deprecated. File sharing can work using other technology like
 * Bluetooth.
 */
",-1,,[@java.lang.Deprecated],-1,-1,-1,-1,-1,-1,"3,4",1,"A new conditional check and a corresponding return statement have been added within a synchronized block, which pertains to a control dependency change (3), and an Other statement changed (4).","The introduction of a new condition (if (!sHasBeamFeature)) along with an immediate return statement could potentially result in the API returning a different value than it did previously (false instead of the result of sService.isNdefPushEnabled()), so the CI type is 1."
85,"<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>",28,29,"<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>","<android.content.ContentResolver: String[] getStreamTypes(Uri,String)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mimeTypeFilter, ""mimeTypeFilter"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(mimeTypeFilter, ""mimeTypeFilter"");
    try {
        if (mWrapped != null)
            return mWrapped.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Query for the possible MIME types for the representations the given
 * content URL can be returned when opened as as stream with
 * {@link #openTypedAssetFileDescriptor}.  Note that the types here are
 * not necessarily a superset of the type returned by {@link #getType} --
 * many content providers cannot return a raw stream for the structured
 * data that they contain.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
 * such as *&#47;*, to query for all available MIME types that match the
 * pattern.
 * @return Returns an array of MIME type strings for all available
 * data streams that match the given mimeTypeFilter.  If there are none,
 * null is returned.
 */
","/**
 * Query for the possible MIME types for the representations the given
 * content URL can be returned when opened as as stream with
 * {@link #openTypedAssetFileDescriptor}.  Note that the types here are
 * not necessarily a superset of the type returned by {@link #getType} --
 * many content providers cannot return a raw stream for the structured
 * data that they contain.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
 * such as *&#47;*, to query for all available MIME types that match the
 * pattern.
 * @return Returns an array of MIME type strings for all available
 * data streams that match the given mimeTypeFilter.  If there are none,
 * null is returned.
 */
",-1,[@Nullable],"[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"3,4",0,"There is a new try-catch block added to the late implementation, which checks and potentially calls `mWrapped.getStreamTypes(url, mimeTypeFilter)` before proceeding to acquire a provider. Also, there's an additional null check control flow introduced with `if (mWrapped != null)`. These changes are under the category 3 (Control dependency changed) and 4 (Other statement changed).","Despite the early and late implementations having differences in their control flow due to the added conditional check `if (mWrapped != null)` and the additional try-catch block, there are no changes that would lead to a potential different return value or exception handling. Both implementations ultimately perform the same checks and return `null` in the same circumstances (when the provider is `null` or a `RemoteException` occurs). Thus, there is no Compatibility Issue; CI type is 0."
86,<android.util.StatsLog: boolean logStop(int)>,28,29,<android.util.StatsLog: boolean logStop(int)>,<android.util.StatsLog: boolean logStop(int)>,0,"{
    synchronized (StatsLog.class) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG)
                    Slog.d(TAG, ""Failed to find statsd when logging stop"");
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__STOP);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG)
                Slog.d(TAG, ""Failed to connect to statsd when logging stop"");
            return false;
        }
    }
}","{
    synchronized (sLogLock) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG) {
                    Slog.d(TAG, ""Failed to find statsd when logging stop"");
                }
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__STOP);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG) {
                Slog.d(TAG, ""Failed to connect to statsd when logging stop"");
            }
            return false;
        }
    }
}",1,"/**
 * Logs a stop event.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */
","/**
 * Logs a stop event.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change that has been made is in the synchronized block, where it synchronizes on `StatsLog.class` in the early version and `sLogLock` in the late version. This change falls under other statement (specifically the synchronization lock object), hence the code change type is 4.","This change does not affect the return value or the exception handling of the method; it only modifies the object on which the method is synchronized. Therefore, it does not introduce a Compatibility Issue, thus the CI type is 0."
88,<android.provider.MediaStore.Audio.Playlists: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Audio.Playlists: Uri getContentUri(String)>,<android.provider.MediaStore.Audio.Playlists: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/playlists"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""audio"").appendPath(""playlists"").build();
}",1,"/**
 * Get the content:// style URI for the audio playlists table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio playlists table on the given volume
 */
","/**
 * Get the content:// style URI for the audio playlists table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio playlists table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of returning the Uri has changed from using Uri.parse with string concatenation to using a builder pattern with AUTHORITY_URI. This reflects a change in statement (using different methods to build the Uri) and potentially a dependency change if AUTHORITY_URI is different between versions, so the code change type is 4,5.","The method now uses a different approach to construct the Uri, which can potentially lead to a different Uri value being returned. The change in the way the Uri is constructed could lead to a compatibility issue if the constructed Uri behaves differently in any way, therefore the CI type is 1."
90,<android.transition.TransitionSet: TransitionSet addTransition(Transition)>,28,29,<android.transition.TransitionSet: TransitionSet addTransition(Transition)>,<android.transition.TransitionSet: TransitionSet addTransition(Transition)>,0,"{
    if (transition != null) {
        mTransitions.add(transition);
        transition.mParent = this;
        if (mDuration >= 0) {
            transition.setDuration(mDuration);
        }
    }
    return this;
}","{
    if (transition != null) {
        addTransitionInternal(transition);
        if (mDuration >= 0) {
            transition.setDuration(mDuration);
        }
        if ((mChangeFlags & FLAG_CHANGE_INTERPOLATOR) != 0) {
            transition.setInterpolator(getInterpolator());
        }
        if ((mChangeFlags & FLAG_CHANGE_PROPAGATION) != 0) {
            transition.setPropagation(getPropagation());
        }
        if ((mChangeFlags & FLAG_CHANGE_PATH_MOTION) != 0) {
            transition.setPathMotion(getPathMotion());
        }
        if ((mChangeFlags & FLAG_CHANGE_EPICENTER) != 0) {
            transition.setEpicenterCallback(getEpicenterCallback());
        }
    }
    return this;
}",1,"/**
 * Adds child transition to this set. The order in which this child transition
 * is added relative to other child transitions that are added, in addition to
 * the {@link #getOrdering() ordering} property, determines the
 * order in which the transitions are started.
 *
 * <p>If this transitionSet has a {@link #getDuration() duration} set on it, the
 * child transition will inherit that duration. Transitions are assumed to have
 * a maximum of one transitionSet parent.</p>
 *
 * @param transition A non-null child transition to be added to this set.
 * @return This transitionSet object.
 */
","/**
 * Adds child transition to this set. The order in which this child transition
 * is added relative to other child transitions that are added, in addition to
 * the {@link #getOrdering() ordering} property, determines the
 * order in which the transitions are started.
 *
 * <p>If this transitionSet has a {@link #getDuration() duration},
 * {@link #getInterpolator() interpolator}, {@link #getPropagation() propagation delay},
 * {@link #getPathMotion() path motion}, or
 * {@link #setEpicenterCallback(EpicenterCallback) epicenter callback}
 * set on it, the child transition will inherit the values that are set.
 * Transitions are assumed to have a maximum of one transitionSet parent.</p>
 *
 * @param transition A non-null child transition to be added to this set.
 * @return This transitionSet object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The method now calls `addTransitionInternal(transition)` instead of directly adding to `mTransitions`, and there are checks with possible additional method calls based on `mChangeFlags`. These changes constitute modifications to control dependency (type 3) as additional conditions have been introduced, other statements have been altered or added (type 4), and a dependent API `addTransitionInternal(transition)` is invoked (type 5).","Although there are changes in how the transition is added and configured, these changes do not affect the return value of the method. The method signature stays the same, it still returns `this`, and there are no new exception handling changes that would lead to CI. Therefore, there's no Compatibility Issue (type 0)."
93,<android.os.Build: String getRadioVersion()>,28,29,<android.os.Build: String getRadioVersion()>,<android.os.Build: String getRadioVersion()>,0,"{
    return SystemProperties.get(TelephonyProperties.PROPERTY_BASEBAND_VERSION, null);
}","{
    String propVal = SystemProperties.get(TelephonyProperties.PROPERTY_BASEBAND_VERSION);
    return TextUtils.isEmpty(propVal) ? null : propVal;
}",1,"/**
 * Returns the version string for the radio firmware.  May return
 * null (if, for instance, the radio is not currently on).
 */
","/**
 * Returns the version string for the radio firmware.  May return
 * null (if, for instance, the radio is not currently on).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are several changes. A new variable declaration, propVal, has been introduced. A null check was added for propVal with TextUtils.isEmpty(propVal), and a ternary operator was used to determine the return value. These are control dependency changes (3) as well as other statement changes (4) due to the introduction of new variable and conditional logic. The return statement now also checks for an empty string, changing the method's return value behavior as opposed to the early version, where null could be returned directly. Hence, this is a return statement change as well (1).","Since the late version introduces a check for whether the radio version is empty and returns null if it is (as opposed to potentially returning an empty string in the early version), the API potentially returns different values. Therefore, the CI type is 1."
95,<android.view.WindowInsets: boolean isConsumed()>,28,29,<android.view.WindowInsets: boolean isConsumed()>,<android.view.WindowInsets: boolean isConsumed()>,0,"{
    return mSystemWindowInsetsConsumed && mWindowDecorInsetsConsumed && mStableInsetsConsumed && mDisplayCutoutConsumed;
}","{
    return mSystemWindowInsetsConsumed && mStableInsetsConsumed && mDisplayCutoutConsumed;
}",1,"/**
 * Check if these insets have been fully consumed.
 *
 * <p>Insets are considered ""consumed"" if the applicable <code>consume*</code> methods
 * have been called such that all insets have been set to zero. This affects propagation of
 * insets through the view hierarchy; insets that have not been fully consumed will continue
 * to propagate down to child views.</p>
 *
 * <p>The result of this method is equivalent to the return value of
 * {@link View#fitSystemWindows(android.graphics.Rect)}.</p>
 *
 * @return true if the insets have been fully consumed.
 */
","/**
 * Check if these insets have been fully consumed.
 *
 * <p>Insets are considered ""consumed"" if the applicable <code>consume*</code> methods
 * have been called such that all insets have been set to zero. This affects propagation of
 * insets through the view hierarchy; insets that have not been fully consumed will continue
 * to propagate down to child views.</p>
 *
 * <p>The result of this method is equivalent to the return value of
 * {@link View#fitSystemWindows(android.graphics.Rect)}.</p>
 *
 * @return true if the insets have been fully consumed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed because the condition 'mWindowDecorInsetsConsumed' has been removed from the logical AND operation, so the code change type is 1.","The removal of 'mWindowDecorInsetsConsumed' from the condition used in the return statement means that the method could return a different value than it did in the early version, indicating a potential different return value or type, so the CI type is 1."
96,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",28,29,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
        if (layerType != LAYER_TYPE_NONE) {
            // If not drawing with RenderNode, treat HW layers as SW
            layerType = LAYER_TYPE_SOFTWARE;
            buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
        if (layerType != LAYER_TYPE_NONE) {
            // If not drawing with RenderNode, treat HW layers as SW
            layerType = LAYER_TYPE_SOFTWARE;
            buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.hasDisplayList()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((RecordingCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
98,<android.app.ActivityThread.ActivityClientRecord: String getStateString()>,28,29,<android.app.ActivityThread.ActivityClientRecord: String getStateString()>,<android.app.ActivityThread.ActivityClientRecord: String getStateString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""ActivityClientRecord{"");
    sb.append(""paused="").append(paused);
    sb.append("", stopped="").append(stopped);
    sb.append("", hideForNow="").append(hideForNow);
    sb.append("", startsNotResumed="").append(startsNotResumed);
    sb.append("", isForward="").append(isForward);
    sb.append("", pendingConfigChanges="").append(pendingConfigChanges);
    sb.append("", preserveWindow="").append(mPreserveWindow);
    if (activity != null) {
        sb.append("", Activity{"");
        sb.append(""resumed="").append(activity.mResumed);
        sb.append("", stopped="").append(activity.mStopped);
        sb.append("", finished="").append(activity.isFinishing());
        sb.append("", destroyed="").append(activity.isDestroyed());
        sb.append("", startedActivity="").append(activity.mStartedActivity);
        sb.append("", temporaryPause="").append(activity.mTemporaryPause);
        sb.append("", changingConfigurations="").append(activity.mChangingConfigurations);
        sb.append(""}"");
    }
    sb.append(""}"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""ActivityClientRecord{"");
    sb.append(""paused="").append(paused);
    sb.append("", stopped="").append(stopped);
    sb.append("", hideForNow="").append(hideForNow);
    sb.append("", startsNotResumed="").append(startsNotResumed);
    sb.append("", isForward="").append(isForward);
    sb.append("", pendingConfigChanges="").append(pendingConfigChanges);
    sb.append("", preserveWindow="").append(mPreserveWindow);
    if (activity != null) {
        sb.append("", Activity{"");
        sb.append(""resumed="").append(activity.mResumed);
        sb.append("", stopped="").append(activity.mStopped);
        sb.append("", finished="").append(activity.isFinishing());
        sb.append("", destroyed="").append(activity.isDestroyed());
        sb.append("", startedActivity="").append(activity.mStartedActivity);
        sb.append("", changingConfigurations="").append(activity.mChangingConfigurations);
        sb.append(""}"");
    }
    sb.append(""}"");
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There are no code changes between the early version and late version.,"Since there's no change in the code, there cannot be any compatibility issue between the two versions."
99,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",28,29,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>","<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",0,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mStorageManager.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce);
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mStorageManager.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce, getObbInfo(canonicalPath));
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
","/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call to mStorageManager.mountObb(...) includes a new parameter getObbInfo(canonicalPath) in the late version, which is a change to a dependent API invocation, so the code change type is 4,5.","The addition of the parameter does not alter the return type nor does it introduce a potential for a new or different exception as the exception handling remains the same. Therefore, there's no compatibility issue introduced by this change, leading to CI type 0."
101,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,28,29,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,0,"{
    try {
        return getService().getTasks(maxNum);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getTaskService().getTasks(maxNum);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call within the 'try' block has changed from getService().getTasks(maxNum) to getTaskService().getTasks(maxNum). No other part of the code was altered. So, the code change type is 5.","The change is in the method being called to retrieve the task service, but as long as this change does not affect the behavior observed by the caller (such as changing the returned value or the exceptions thrown which it does not in this case), it does not introduce a compatibility issue. Thus, CI type is 0."
102,"<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",28,29,"<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>","<android.widget.Editor.TextActionModeCallback: boolean onActionItemClicked(ActionMode,MenuItem)>",0,"{
    getSelectionActionModeHelper().onSelectionAction(item.getItemId());
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    if (item.getGroupId() == TextView.ID_ASSIST && onAssistMenuItemClicked(item)) {
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}","{
    getSelectionActionModeHelper().onSelectionAction(item.getItemId(), item.getTitle().toString());
    if (mProcessTextIntentActionsHandler.performMenuItemAction(item)) {
        return true;
    }
    Callback customCallback = getCustomCallback();
    if (customCallback != null && customCallback.onActionItemClicked(mode, item)) {
        return true;
    }
    if (item.getGroupId() == TextView.ID_ASSIST && onAssistMenuItemClicked(item)) {
        return true;
    }
    return mTextView.onTextContextMenuItem(item.getItemId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change is an extra parameter passed to the method getSelectionActionModeHelper().onSelectionAction(), where `item.getTitle().toString()` is added in the late version. So the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue since the change does not affect the return value of the method or the exception handling. The change only passes an additional parameter to the `onSelectionAction` method, but the logic and return values of `onActionItemClicked` remain the same."
103,<android.view.WindowInsets: WindowInsets consumeStableInsets()>,28,29,<android.view.WindowInsets: WindowInsets consumeStableInsets()>,<android.view.WindowInsets: WindowInsets consumeStableInsets()>,0,"{
    final WindowInsets result = new WindowInsets(this);
    result.mStableInsets = EMPTY_RECT;
    result.mStableInsetsConsumed = true;
    return result;
}","{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, null, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this));
}",1,"/**
 * Returns a copy of this WindowInsets with the stable insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
","/**
 * Returns a copy of this WindowInsets with the stable insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement's construction of the `WindowInsets` object has significantly changed between the two implementations. Instead of simply resetting the stable insets to an empty rectangle and setting a flag, the late version uses a more complex construction involving additional state checks and a potentially modified 'displayCutoutCopyConstructorArgument'. This indicates a change in the dependent API that constructs `WindowInsets` and thus a change in how the object's state is initialized, which are changes in types 1 and 5.","These differences in the way the `WindowInsets` object is constructed may lead to different return values between the two versions, which is why the CI type is 1."
104,<android.view.ViewGroup: WindowInsets dispatchApplyWindowInsets(WindowInsets)>,28,29,<android.view.ViewGroup: WindowInsets dispatchApplyWindowInsets(WindowInsets)>,<android.view.ViewGroup: WindowInsets dispatchApplyWindowInsets(WindowInsets)>,0,"{
    insets = super.dispatchApplyWindowInsets(insets);
    if (!insets.isConsumed()) {
        final int count = getChildCount();
        for (int i = 0; i < count; i++) {
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);
            if (insets.isConsumed()) {
                break;
            }
        }
    }
    return insets;
}","{
    insets = super.dispatchApplyWindowInsets(insets);
    if (View.sBrokenInsetsDispatch) {
        return brokenDispatchApplyWindowInsets(insets);
    } else {
        return newDispatchApplyWindowInsets(insets);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The implementation has changed the logic by introducing a new control dependency (the 'if' statement checking the 'View.sBrokenInsetsDispatch' static field), as well as new return statements that call 'brokenDispatchApplyWindowInsets(insets)' or 'newDispatchApplyWindowInsets(insets)' based on that condition. This classifies as both a control dependency change (3) and a return statement changed (1).","Due to the new logical branch introduced by the 'if' statement, there is a change in how the WindowInsets object is processed, resulting in a potential change in the return value. Thus, a CI is detected due to the potential for different return values (1)."
105,<android.bluetooth.BluetoothHidDevice: void close()>,28,29,<android.bluetooth.BluetoothHidDevice: void close()>,<android.bluetooth.BluetoothHidDevice: void close()>,0,"{
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
    synchronized (mConnection) {
        doUnbind();
    }
    mServiceListener = null;
}","{
    mProfileConnector.disconnect();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has been completely replaced with a call to mProfileConnector.disconnect(). This changes the sequence of operations and removes the previous direct interaction with the Bluetooth manager service, so the change type is 4,5.","Even though the internal implementation has changed, the external behavior of the public API ""void close()"" should remain the same: closing the Bluetooth HID Device. There's no indication that the semantics of the method have changed from its original purpose, and thus, no new exceptions or different return types/values are expected. Since there are no differences in behavior observable to a caller of the method, there is no compatibility issue, so the CI type is 0."
109,<android.view.textclassifier.TextClassifier.EntityConfig: Collection<String> resolveEntityListModifications(Collection<String>)>,28,29,<android.view.textclassifier.TextClassifier.EntityConfig: Collection<String> resolveEntityListModifications(Collection<String>)>,<android.view.textclassifier.TextClassifier.EntityConfig: Collection<String> resolveEntityListModifications(Collection<String>)>,0,"{
    final Set<String> finalSet = new HashSet();
    if (mUseHints) {
        finalSet.addAll(entities);
    }
    finalSet.addAll(mIncludedEntityTypes);
    finalSet.removeAll(mExcludedEntityTypes);
    return finalSet;
}","{
    final Set<String> finalSet = new HashSet<>();
    if (mIncludeTypesFromTextClassifier) {
        finalSet.addAll(entityTypes);
    }
    finalSet.addAll(mIncludedTypes);
    finalSet.removeAll(mExcludedTypes);
    return finalSet;
}",1,"/**
 * Returns a list of the final set of entities to find.
 *
 * @param entities Entities we think should be found before factoring in includes/excludes
 *
 * This method is intended for use by TextClassifier implementations.
 */
","/**
 * Returns a final list of entity types to find.
 *
 * @param entityTypes Entity types we think should be found before factoring in
 * includes/excludes
 *
 * This method is intended for use by TextClassifier implementations.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"Variables are renamed but their types and how they are used remain the same (entities to entityTypes, mIncludedEntityTypes to mIncludedTypes, mExcludedEntityTypes to mExcludedTypes), which means underlying logic did not change. Hence, the code change type is 4 and 5.","Even though there are variable renaming occurrences, these do not affect the behavior of the API; thus, they do not introduce compatibility issues as the logic of the method remains consistent between the two versions. Therefore, there is no CI."
110,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,28,29,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getHeightHint();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getHeightHint(mContext.getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
","/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API sGlobals.mService.getHeightHint() has been changed to include an additional parameter, modifying it to sGlobals.mService.getHeightHint(mContext.getDisplayId()), so the code change type is 5.","Although there is a change in which dependent API is being called, this change does not inherently cause a compatibility issue as long as the new parameter passed (mContext.getDisplayId()) does not alter the expected behavior of the API. Therefore, there is no compatibility issue."
112,<android.widget.TextView: void sendAfterTextChanged(Editable)>,28,29,<android.widget.TextView: void sendAfterTextChanged(Editable)>,<android.widget.TextView: void sendAfterTextChanged(Editable)>,0,"{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
    // Always notify AutoFillManager - it will return right away if autofill is disabled.
    notifyAutoFillManagerAfterTextChangedIfNeeded();
    hideErrorIfUnchanged();
}","{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
    notifyListeningManagersAfterTextChanged();
    hideErrorIfUnchanged();
}",1,"/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */
","/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The call notifyAutoFillManagerAfterTextChangedIfNeeded() is replaced with notifyListeningManagersAfterTextChanged(). This is a change in method call but not a change in the control structure, exception handling, or return statement. Thus, the code change type is 4 (Other statement changed). Additionally, since the method called has changed, if notifyListeningManagersAfterTextChanged() has different behavior from notifyAutoFillManagerAfterTextChangedIfNeeded(), it may count as a Dependent API changed, which is code change type 5.","Since there are no changes to the control flow, return statements, or exception handling that would affect the behavior of the method as it pertains to the caller, and since this method does not return a value, we could assume that despite the change in the called method, it is intended to have the same type of side effect on the state of the system, and thus there is No Compatibility Issue, which is CI type 0. However, without information on the implementation of notifyListeningManagersAfterTextChanged() vs notifyAutoFillManagerAfterTextChangedIfNeeded(), it cannot be definitively stated that there is no change in behavior, but based on the common practice and naming, it is likely that the change was meant to preserve existing functionality while extending or refactoring internals."
113,<android.net.Uri: String decode(String)>,28,29,<android.net.Uri: String decode(String)>,<android.net.Uri: String decode(String)>,0,"{
    if (s == null) {
        return null;
    }
    return UriCodec.decode(s, false, StandardCharsets.UTF_8, false);
}","{
    if (s == null) {
        return null;
    }
    return UriCodec.decode(s, false, /* convertPlus */
    StandardCharsets.UTF_8, false);
}",1,"/**
 * Decodes '%'-escaped octets in the given string using the UTF-8 scheme.
 * Replaces invalid octets with the unicode replacement character
 * (""\\uFFFD"").
 *
 * @param s encoded string to decode
 * @return the given string with escaped octets decoded, or null if
 * s is null
 */
","/**
 * Decodes '%'-escaped octets in the given string using the UTF-8 scheme.
 * Replaces invalid octets with the unicode replacement character
 * (""\\uFFFD"").
 *
 * @param s encoded string to decode
 * @return the given string with escaped octets decoded, or null if
 * s is null
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There has been no change in the implementation except for a comment added for documenting the purpose of the boolean parameter in the UriCodec.decode() invocation. Comments do not affect the execution of code, so there is no change.","Since there have been no changes in the actual executable code, there are no potential Compatibility Issues; the method behaves identically between the two versions."
114,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,0,"{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null);
}","{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The parameter list in canPerformRequestOverConnection() method call has changed, with the addition of mConnectionId and mWindowId as parameters (from canPerformRequestOverConnection(mSourceNodeId) to canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)), and this is a control dependency change. This signature change is also a dependent API change because the definition of canPerformRequestOverConnection() that this API depends upon has been modified, so the change types are 3 and 5.","Although the dependent API canPerformRequestOverConnection() signature has been changed, the new parameters mConnectionId, mWindowId are always passed to the method along with mSourceNodeId, and these are member variables that appear to already contain the necessary context for the API to work correctly. The control flow seems to be unaffected, and there is no change in return statements or exception handling from the perspective of this methods caller. Therefore, no compatibility issue is expected based on the changes between the versions, so the pred_CI is 0."
115,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitAll()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitAll()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitAll()>,0,"{
    return disable(ALL_THREAD_DETECT_BITS);
}","{
    return disable(DETECT_THREAD_ALL);
}",1,"/**
 * Disable the detection of everything.
 */
","/**
 * Disable the detection of everything.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter passed to the disable() method has changed from ALL_THREAD_DETECT_BITS to DETECT_THREAD_ALL, indicating a change in the dependent API or a change in the semantics of what is being disabled, so the code change type is 1,5.","This change in the parameter might lead to different behavior or a different return value of the permitAll() method, thus causing a CI of type 1."
118,"<android.app.admin.DevicePolicyManager: void setNetworkLoggingEnabled(ComponentName,boolean)>",28,29,"<android.app.admin.DevicePolicyManager: void setNetworkLoggingEnabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setNetworkLoggingEnabled(ComponentName,boolean)>",0,"{
    throwIfParentInstance(""setNetworkLoggingEnabled"");
    try {
        mService.setNetworkLoggingEnabled(admin, enabled);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setNetworkLoggingEnabled"");
    try {
        mService.setNetworkLoggingEnabled(admin, mContext.getPackageName(), enabled);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by a device owner to control the network logging feature.
 *
 * <p> Network logs contain DNS lookup and connect() library call events. The following library
 * functions are recorded while network logging is active:
 * <ul>
 * <li>{@code getaddrinfo()}</li>
 * <li>{@code gethostbyname()}</li>
 * <li>{@code connect()}</li>
 * </ul>
 *
 * <p> Network logging is a low-overhead tool for forensics but it is not guaranteed to use
 * full system call logging; event reporting is enabled by default for all processes but not
 * strongly enforced.
 * Events from applications using alternative implementations of libc, making direct kernel
 * calls, or deliberately obfuscating traffic may not be recorded.
 *
 * <p> Some common network events may not be reported. For example:
 * <ul>
 * <li>Applications may hardcode IP addresses to reduce the number of DNS lookups, or use
 * an alternative system for name resolution, and so avoid calling
 * {@code getaddrinfo()} or {@code gethostbyname}.</li>
 * <li>Applications may use datagram sockets for performance reasons, for example
 * for a game client. Calling {@code connect()} is unnecessary for this kind of
 * socket, so it will not trigger a network event.</li>
 * </ul>
 *
 * <p> It is possible to directly intercept layer 3 traffic leaving the device using an
 * always-on VPN service.
 * See {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)}
 * and {@link android.net.VpnService} for details.
 *
 * <p><strong>Note:</strong> The device owner won't be able to retrieve network logs if there
 * are unaffiliated secondary users or profiles on the device, regardless of whether the
 * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
 * all users to become affiliated. Therefore it's recommended that affiliation ids are set for
 * new users as soon as possible after provisioning via {@link #setAffiliationIds}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param enabled whether network logging should be enabled or not.
 * @throws SecurityException if {@code admin} is not a device owner.
 * @see #setAffiliationIds
 * @see #retrieveNetworkLogs
 */
","/**
 * Called by a device owner or delegated app with {@link #DELEGATION_NETWORK_LOGGING} to
 * control the network logging feature.
 *
 * <p> Network logs contain DNS lookup and connect() library call events. The following library
 * functions are recorded while network logging is active:
 * <ul>
 * <li>{@code getaddrinfo()}</li>
 * <li>{@code gethostbyname()}</li>
 * <li>{@code connect()}</li>
 * </ul>
 *
 * <p> Network logging is a low-overhead tool for forensics but it is not guaranteed to use
 * full system call logging; event reporting is enabled by default for all processes but not
 * strongly enforced.
 * Events from applications using alternative implementations of libc, making direct kernel
 * calls, or deliberately obfuscating traffic may not be recorded.
 *
 * <p> Some common network events may not be reported. For example:
 * <ul>
 * <li>Applications may hardcode IP addresses to reduce the number of DNS lookups, or use
 * an alternative system for name resolution, and so avoid calling
 * {@code getaddrinfo()} or {@code gethostbyname}.</li>
 * <li>Applications may use datagram sockets for performance reasons, for example
 * for a game client. Calling {@code connect()} is unnecessary for this kind of
 * socket, so it will not trigger a network event.</li>
 * </ul>
 *
 * <p> It is possible to directly intercept layer 3 traffic leaving the device using an
 * always-on VPN service.
 * See {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)}
 * and {@link android.net.VpnService} for details.
 *
 * <p><strong>Note:</strong> The device owner won't be able to retrieve network logs if there
 * are unaffiliated secondary users or profiles on the device, regardless of whether the
 * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
 * all users to become affiliated. Therefore it's recommended that affiliation ids are set for
 * new users as soon as possible after provisioning via {@link #setAffiliationIds}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by a delegated app.
 * @param enabled whether network logging should be enabled or not.
 * @throws SecurityException if {@code admin} is not a device owner.
 * @see #setAffiliationIds
 * @see #retrieveNetworkLogs
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API mService.setNetworkLoggingEnabled() has changed by introducing an additional argument (mContext.getPackageName()), so the code change type is 5.","Although the method mService.setNetworkLoggingEnabled() now takes an additional argument, the behavior of the DevicePolicyManager.setNetworkLoggingEnabled() method, from the perspective of an application calling this method, does not change since it does not affect the parameters or return type or exception handling of the DevicePolicyManager.setNetworkLoggingEnabled(). Thus, it does not cause a Compatibility Issue based on the given information."
121,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,0,"{
    enforceSealed();
    return getNodeForAccessibilityId(mLabeledById);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mLabeledById);
}",1,"/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
","/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method getNodeForAccessibilityId has changed in terms of the parameters it takes: previously it took one parameter and now it takes three parameters. This represents a change in Return statement and the Dependent API change, so the change type is 1,5.","Due to the additional parameters in the called method 'getNodeForAccessibilityId(mConnectionId, mWindowId, mLabeledById)' which would potentially affect the returned AccessibilityNodeInfo object, the CI type is 1."
124,"<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>",28,29,"<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>","<android.view.LayoutInflater: View createViewFromTag(View,String,Context,AttributeSet,boolean)>",0,"{
    if (name.equals(""view"")) {
        name = attrs.getAttributeValue(null, ""class"");
    }
    // Apply a theme wrapper, if allowed and one is specified.
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
    }
    if (name.equals(TAG_1995)) {
        // Let's party like it's 1995!
        return new BlinkLayout(context, attrs);
    }
    try {
        View view;
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }
        if (view == null && mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }
        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }
        return view;
    } catch (InflateException e) {
        throw e;
    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    }
}","{
    if (name.equals(""view"")) {
        name = attrs.getAttributeValue(null, ""class"");
    }
    // Apply a theme wrapper, if allowed and one is specified.
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
    }
    try {
        View view = tryCreateView(parent, name, context, attrs);
        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf('.')) {
                    view = onCreateView(context, parent, name, attrs);
                } else {
                    view = createView(context, name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }
        return view;
    } catch (InflateException e) {
        throw e;
    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(getParserStateDescription(context, attrs) + "": Error inflating class "" + name, e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    }
}",1,"/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
","/**
 * Creates a view from a tag name using the supplied attribute set.
 * <p>
 * <strong>Note:</strong> Default visibility so the BridgeInflater can
 * override it.
 *
 * @param parent the parent view, used to inflate layout params
 * @param name the name of the XML tag used to define the view
 * @param context the inflation context for the view, typically the
 * {@code parent} or base layout inflater context
 * @param attrs the attribute set for the XML tag used to define the view
 * @param ignoreThemeAttr {@code true} to ignore the {@code android:theme}
 * attribute (if set) for the view being inflated,
 * {@code false} otherwise
 */
",-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The control flow has changed due to the introduction of a new method `tryCreateView`, the call to `onCreateView` and `createView` has additional context argument passed in `onCreateView` and reordered arguments in `createView`. Also, the throw statements for `ClassNotFoundException` and `Exception` now call `getParserStateDescription` instead of directly accessing `attrs.getPositionDescription()`. A method implementation and call have been changed, as well as the exception message details which rely on a different method now. So, this is a complex change involving return statement, control dependency, other statements, and a dependent API.","This could potentially cause a Compatibility Issue as the method return value might be changed due to the introduction of `tryCreateView` and changes to the methods `onCreateView` and `createView`. If `tryCreateView` or these modified methods behave differently, the final returned `View` object could differ. Additionally, a change in exception messages can affect exception handling in client code if they rely on message content. Therefore, there could be a Compatibility Issue due to different return values or types."
126,"<android.util.Xml: void parse(String,ContentHandler)>",28,29,"<android.util.Xml: void parse(String,ContentHandler)>","<android.util.Xml: void parse(String,ContentHandler)>",0,"{
    try {
        XMLReader reader = new ExpatReader();
        reader.setContentHandler(contentHandler);
        reader.parse(new InputSource(new StringReader(xml)));
    } catch (IOException e) {
        throw new AssertionError(e);
    }
}","{
    try {
        XMLReader reader = XmlObjectFactory.newXMLReader();
        reader.setContentHandler(contentHandler);
        reader.parse(new InputSource(new StringReader(xml)));
    } catch (IOException e) {
        throw new AssertionError(e);
    }
}",1,"/**
 * Parses the given xml string and fires events on the given SAX handler.
 */
","/**
 * Parses the given xml string and fires events on the given SAX handler.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to create an XMLReader instance has changed from `new ExpatReader()` to `XmlObjectFactory.newXMLReader()`. There is no change in the return type or exception handling. Therefore, the code change type is 5 as it involves a dependent API changed.","There are no changes in the return statements, expected exceptions thrown, or control flow that would lead to a different behavior for the client code. Therefore, no compatibility issue should be expected, hence, the CI type is 0."
127,"<android.os.DropBoxManager: Entry getNextEntry(String,long)>",28,29,"<android.os.DropBoxManager: Entry getNextEntry(String,long)>","<android.os.DropBoxManager: Entry getNextEntry(String,long)>",0,"{
    try {
        return mService.getNextEntry(tag, msec);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getNextEntry(tag, msec, mContext.getOpPackageName());
    } catch (SecurityException e) {
        if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
            throw e;
        } else {
            Log.w(TAG, e.getMessage());
            return null;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the next entry from the drop box <em>after</em> the specified time.
 * Requires <code>android.permission.READ_LOGS</code>.  You must always call
 * {@link Entry#close()} on the return value!
 *
 * @param tag of entry to look for, null for all tags
 * @param msec time of the last entry seen
 * @return the next entry, or null if there are no more entries
 */
","/**
 * Gets the next entry from the drop box <em>after</em> the specified time.
 * You must always call {@link Entry#close()} on the return value!
 *
 * @param tag of entry to look for, null for all tags
 * @param msec time of the last entry seen
 * @return the next entry, or null if there are no more entries
 */
",-1,,"[@RequiresPermission(allOf = { READ_LOGS, PACKAGE_USAGE_STATS }), @Nullable]",-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The method 'mService.getNextEntry' called in the early version is changed to include an additional parameter 'mContext.getOpPackageName()' in the late version, indicating a change in the dependent API (type 5). Additionally, a new exception handling for 'SecurityException' has been introduced which includes a conditional check on 'targetSdkVersion' and different behaviors based on it, resulting in changes in both the exception handling statement (type 2) and the control flow (type 4). Lastly, the introduction of a new return statement within the 'SecurityException' catch block represents a return statement change (type 1).","The introduction of additional parameter in the call to 'mService.getNextEntry' and 'SecurityException' handling with different potential outcomes based on the version check could cause different return values and exception behaviors in the late version. Depending on the context and the 'targetSdkVersion', the late version may return null or throw a 'SecurityException' where the early version would not, leading to potential CI of types 1 and 2 due to different return values and exception handlings."
130,"<android.util.ArrayMap: V setValueAt(int,V)>",28,29,"<android.util.ArrayMap: V setValueAt(int,V)>","<android.util.ArrayMap: V setValueAt(int,V)>",0,"{
    index = (index << 1) + 1;
    V old = (V) mArray[index];
    mArray[index] = value;
    return old;
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    index = (index << 1) + 1;
    V old = (V) mArray[index];
    mArray[index] = value;
    return old;
}",1,"/**
 * Set the value at a given index in the array.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @param value The new value to store at this index.
 * @return Returns the previous value at the given index.
 */
","/**
 * Set the value at a given index in the array.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @param value The new value to store at this index.
 * @return Returns the previous value at the given index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There is an additional exception handling mechanism introduced, which checks for the array index bound and potentially throws an ArrayIndexOutOfBoundsException, this is type 2. Also, since theres a conditional check added before the main logic of the method, it also classifies as other statement change, which is type 4.","The newly introduced exception handling can cause a new type of exception (ArrayIndexOutOfBoundsException) to be thrown before the method's original logic if the condition is met. This constitutes a potential CI since the behavior of the API could differ due to this change, causing a new exception to be thrown where it was not thrown previously, making the CI type 2."
131,<android.content.ContentValues: Set<String> keySet()>,28,29,<android.content.ContentValues: Set<String> keySet()>,<android.content.ContentValues: Set<String> keySet()>,0,"{
    return mValues.keySet();
}","{
    return mMap.keySet();
}",1,"/**
 * Returns a set of all of the keys
 *
 * @return a set of all of the keys
 */
","/**
 * Returns a set of all of the keys
 *
 * @return a set of all of the keys
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement changed from accessing `mValues` to accessing `mMap`, which indicates a change in the internal data structure being accessed; hence, the change types are 4 (Other statement changed) and 5 (Dependent API changed).","Since the internal data structure from which the keys are being fetched has changed, the method could potentially return a different set of keys, even if the two data structures are intended to represent the same data. Thus, the CI type is 1 due to the potential of the method returning a different set of strings."
132,<android.app.Activity: void setShowWhenLocked(boolean)>,28,29,<android.app.Activity: void setShowWhenLocked(boolean)>,<android.app.Activity: void setShowWhenLocked(boolean)>,0,"{
    try {
        ActivityManager.getService().setShowWhenLocked(mToken, showWhenLocked);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to call setShowWhenLocked"", e);
    }
}","{
    try {
        ActivityTaskManager.getService().setShowWhenLocked(mToken, showWhenLocked);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Specifies whether an {@link Activity} should be shown on top of the the lock screen whenever
 * the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
 * to the stopped state if it is started while the lockscreen is up, but with this flag set the
 * activity will remain in the resumed state visible on-top of the lock screen. This value can
 * be set as a manifest attribute using {@link android.R.attr#showWhenLocked}.
 *
 * @param showWhenLocked {@code true} to show the {@link Activity} on top of the lock screen;
 * {@code false} otherwise.
 * @see #setTurnScreenOn(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 */
","/**
 * Specifies whether an {@link Activity} should be shown on top of the lock screen whenever
 * the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
 * to the stopped state if it is started while the lockscreen is up, but with this flag set the
 * activity will remain in the resumed state visible on-top of the lock screen. This value can
 * be set as a manifest attribute using {@link android.R.attr#showWhenLocked}.
 *
 * @param showWhenLocked {@code true} to show the {@link Activity} on top of the lock screen;
 * {@code false} otherwise.
 * @see #setTurnScreenOn(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The method called within the try block has changed from ActivityManager.getService().setShowWhenLocked to ActivityTaskManager.getService().setShowWhenLocked, which indicates a change in the dependent API (code change type 5). Additionally, the exception handling has been modified from logging the exception to throwing it, which is categorized as an exception handling statement change (code change type 2).","The alteration in exception handling can result in a different exception being thrown (instead of just logging the exception, the new implementation throws it), leading to potential compatibility issues (CI type 2)."
133,<android.provider.MediaStore.Video.Thumbnails: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Video.Thumbnails: Uri getContentUri(String)>,<android.provider.MediaStore.Video.Thumbnails: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/video/thumbnails"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""video"").appendPath(""thumbnails"").build();
}",1,"/**
 * Get the content:// style URI for the image media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the image media table on the given volume
 */
","/**
 * Get the content:// style URI for the image media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the image media table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation changed from using `Uri.parse` to using a chain of `buildUpon`, `appendPath`, and `build` methods on `AUTHORITY_URI`, so the code change type is 4.","There is no Compatibility Issue since the end result, which is the returned Uri, should represent the same resource despite being constructed by different means. Hence, the APIs behavior remains effectively the same, and the code change should not lead to a Compatibility Issue."
134,<android.util.SparseBooleanArray: boolean valueAt(int)>,28,29,<android.util.SparseBooleanArray: boolean valueAt(int)>,<android.util.SparseBooleanArray: boolean valueAt(int)>,0,"{
    return mValues[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return mValues[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseBooleanArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseBooleanArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"A new control dependency (an 'if' statement that checks the index bounds and throws an exception) has been added with an additional statement that throws an exception in the late version. This makes the code change type 3,4.","This change introduces the potential for a different exception to be thrown under certain conditions in the late version that would not have occurred in the early version. It could throw an ArrayIndexOutOfBoundsException if the index is out of bounds and the corresponding configuration flag is set. Therefore, the CI type is 2."
135,"<android.app.NotificationManager: Map<String, AutomaticZenRule> getAutomaticZenRules()>",28,29,"<android.app.NotificationManager: Map<String, AutomaticZenRule> getAutomaticZenRules()>","<android.app.NotificationManager: Map<String, AutomaticZenRule> getAutomaticZenRules()>",0,"{
    INotificationManager service = getService();
    try {
        List<ZenModeConfig.ZenRule> rules = service.getZenRules();
        Map<String, AutomaticZenRule> ruleMap = new HashMap<>();
        for (ZenModeConfig.ZenRule rule : rules) {
            ruleMap.put(rule.id, new AutomaticZenRule(rule.name, rule.component, rule.conditionId, zenModeToInterruptionFilter(rule.zenMode), rule.enabled, rule.creationTime));
        }
        return ruleMap;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INotificationManager service = getService();
    try {
        List<ZenModeConfig.ZenRule> rules = service.getZenRules();
        Map<String, AutomaticZenRule> ruleMap = new HashMap<>();
        for (ZenModeConfig.ZenRule rule : rules) {
            ruleMap.put(rule.id, new AutomaticZenRule(rule.name, rule.component, rule.configurationActivity, rule.conditionId, rule.zenPolicy, zenModeToInterruptionFilter(rule.zenMode), rule.enabled, rule.creationTime));
        }
        return ruleMap;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns AutomaticZenRules owned by the caller.
 *
 * <p>
 * Throws a SecurityException if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
","/**
 * Returns AutomaticZenRules owned by the caller.
 *
 * <p>
 * Throws a SecurityException if policy access is granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The new constructor of AutomaticZenRule is called with additional parameters (rule.configurationActivity and rule.zenPolicy), but the structure of the method itself and the flow control have not changed, indicating a change in the other statement and dependent API change, which are classified as type 4 and type 5 changes respectively.","Since the constructor for AutomaticZenRule is called with different parameters, which likely change how AutomaticZenRules are constructed and what information they contain, there is a potential that the returned Map<String, AutomaticZenRule> includes AutomaticZenRules with additional or different data comparing to the early version. Therefore, a Compatibility Issue of type 1 is present because the return value may be different."
138,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,28,29,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            // exception in case cameraId is a hidden physical camera.
            if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                try {
                    info.setCameraId(Integer.parseInt(cameraId));
                } catch (NumberFormatException e) {
                    Log.e(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
                }
                info.setDisplaySize(displaySize);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The camera characteristics creation has new logic implemented. The introduction of `getDisplaySize()`, `isHiddenPhysicalCamera(cameraId)`, adjustments to the parameters passed to `createCharacteristics()`, and the setting of camera ID and display size on `info` represent control dependency changes and other statement changes. Additionally, since new methods `getDisplaySize()` and `isHiddenPhysicalCamera()` are invoked, this could affect the dependent APIs, thus making it a dependent API change as well. The changes span across multiple lines and include multiple aspects of the implementation, so the types are 3, 4, and 5.","These changes could lead to different `CameraCharacteristics` objects being returned based on the new methods and the data they provide, and subsequently altering the return value of the API. Therefore, it's a Compatibility Issue caused by potential different return values or types, classified as type 1."
139,"<android.provider.MediaStore.Audio.Artists.Albums: Uri getContentUri(String,long)>",28,29,"<android.provider.MediaStore.Audio.Artists.Albums: Uri getContentUri(String,long)>","<android.provider.MediaStore.Audio.Artists.Albums: Uri getContentUri(String,long)>",0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/artists/"" + artistId + ""/albums"");
}","{
    return ContentUris.withAppendedId(Audio.Artists.getContentUri(volumeName), artistId).buildUpon().appendPath(""albums"").build();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The way the Uri is constructed has been entirely changed from direct parsing of a string to utilizing ContentUris.withAppendedId() and other Uri builder methods. Furthermore, the method Audio.Artists.getContentUri(volumeName) is used, which is not present in the early implementation, thus the code change type is 4,5 (Other statement changed, Dependent API changed).","The return Uri is being created differently; previously with direct string concatenation and parsing, and now with builder chain methods that include a new dependent API (Audio.Artists.getContentUri(volumeName)). These changes can potentially return different Uri objects when the method is called, which constitutes a different return value. Hence, the CI type is 1."
140,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectDiskReads()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectDiskReads()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectDiskReads()>,0,"{
    return enable(DETECT_DISK_READ);
}","{
    return enable(DETECT_THREAD_DISK_READ);
}",1,"/**
 * Enable detection of disk reads.
 */
","/**
 * Enable detection of disk reads.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from enable(DETECT_DISK_READ) to enable(DETECT_THREAD_DISK_READ), also the parameter for the enable() method has been modified, indicating a change in the dependent API. Therefore, the change types are 1 (Return statement changed) and 5 (Dependent API changed).","The change in the parameter passed to the enable() method implies a change in behavior that could result in different values being returned by the API. Thus, there is a potential compatibility issue of type 1 (Compatibility Issue caused by potential different return values)."
141,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,28,29,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                if (distance > slopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mCurrentMotionEvent != null) {
        mCurrentMotionEvent.recycle();
    }
    mCurrentMotionEvent = MotionEvent.obtain(ev);
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            mHasRecordedClassification = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), mCurrentDownEvent.getDownTime() + ViewConfiguration.getLongPressTimeout());
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final int motionClassification = ev.getClassification();
            final boolean hasPendingLongPress = mHandler.hasMessages(LONG_PRESS);
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                final boolean shouldInhibitDefaultAction = hasPendingLongPress && ambiguousGesture;
                if (shouldInhibitDefaultAction) {
                    // Inhibit default long press
                    final float multiplier = ViewConfiguration.getAmbiguousGestureMultiplier();
                    if (distance > slopSquare) {
                        // The default action here is to remove long press. But if the touch
                        // slop below gets increased, and we never exceed the modified touch
                        // slop while still receiving AMBIGUOUS_GESTURE, we risk that *nothing*
                        // will happen in response to user input. To prevent this,
                        // reschedule long press with a modified timeout.
                        mHandler.removeMessages(LONG_PRESS);
                        final long longPressTimeout = ViewConfiguration.getLongPressTimeout();
                        mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), ev.getDownTime() + (long) (longPressTimeout * multiplier));
                    }
                    // Inhibit default scroll. If a gesture is ambiguous, we prevent scroll
                    // until the gesture is resolved.
                    // However, for safety, simply increase the touch slop in case the
                    // classification is erroneous. Since the value is squared, multiply twice.
                    slopSquare *= multiplier * multiplier;
                }
                if (distance > slopSquare) {
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
            if (deepPress && hasPendingLongPress) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessage(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS, 0));
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
142,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,28,29,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final int missingMethods = msg.arg1;
                final boolean restarting = msg.arg2 != 0;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final AtomicBoolean isUnbindIssued = (AtomicBoolean) args.arg4;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, missingMethods, isUnbindIssued) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, restarting, /* restarting */
                startInputToken);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final AtomicBoolean isUnbindIssued = (AtomicBoolean) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, isUnbindIssued) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken, moreArgs.argi2 == 1);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,,,,
144,<android.view.inputmethod.InputMethodManager: boolean isActive(View)>,28,29,<android.view.inputmethod.InputMethodManager: boolean isActive(View)>,<android.view.inputmethod.InputMethodManager: boolean isActive(View)>,0,"{
    checkFocus();
    synchronized (mH) {
        return (mServedView == view || (mServedView != null && mServedView.checkInputConnectionProxy(view))) && mCurrentTextBoxAttribute != null;
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.isActive(view);
    }
    checkFocus();
    synchronized (mH) {
        return (mServedView == view || (mServedView != null && mServedView.checkInputConnectionProxy(view))) && mCurrentTextBoxAttribute != null;
    }
}",1,"/**
 * Return true if the given view is the currently active view for the
 * input method.
 */
","/**
 * Return true if the given view is the currently active view for the
 * input method.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The late version includes additional code before the existing checkFocus() and synchronized block which retrieves a different InputMethodManager via getFallbackInputMethodManagerIfNecessary(view) and subsequently calls isActive(view) on it. This introduces a new control dependency (`if` condition), a new return statement, and the use of a new dependent API (getFallbackInputMethodManagerIfNecessary), which accounts for the changes 1,3,5.","Since this updated implementation could potentially return a result of `isActive(view)` from a different InputMethodManager, this could lead to a different value being returned. Therefore, there is a Compatibility Issue due to potential different return values, classified as 1."
145,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,28,29,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mWindowAdded="" + mWindowAdded + "" mWindowCreated="" + mWindowCreated + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mWindowWasVisible = mWindowVisible;
        mInShowWindow = true;
        showWindowInner(showInput);
    } catch (BadTokenException e) {
        // while there is a DO_SHOW_SOFT_INPUT message in the IIMethodWrapper queue.
        if (DEBUG)
            Log.v(TAG, ""BadTokenException: IME is done."");
        mWindowVisible = false;
        mWindowAdded = false;
        // InputMethodService#requestShowSelf(int) should always be used instead.
        throw e;
    } finally {
        // TODO: Is it OK to set true when we get BadTokenException?
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mViewsCreated="" + mViewsCreated + "" mDecorViewVisible="" + mDecorViewVisible + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    mDecorViewWasVisible = mDecorViewVisible;
    mInShowWindow = true;
    boolean isPreRenderedAndInvisible = mIsPreRendered && !mWindowVisible;
    final int previousImeWindowStatus = (mDecorViewVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? (isPreRenderedAndInvisible ? IME_INVISIBLE : IME_VISIBLE) : 0);
    startViews(prepareWindow(showInput));
    final int nextImeWindowStatus = mapToImeWindowStatus();
    if (previousImeWindowStatus != nextImeWindowStatus) {
        setImeWindowStatus(nextImeWindowStatus, mBackDisposition);
    }
    // compute visibility
    onWindowShown();
    mIsPreRendered = mCanPreRender;
    if (mIsPreRendered) {
        onPreRenderedWindowVisibilityChanged(true);
    } else {
        // Pre-rendering not supported.
        if (DEBUG)
            Log.d(TAG, ""No pre-rendering supported"");
        mWindowVisible = true;
    }
    // When IME is not pre-rendered, this will actually show the IME.
    if ((previousImeWindowStatus & IME_ACTIVE) == 0) {
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
    }
    maybeNotifyPreRendered();
    mDecorViewWasVisible = true;
    mInShowWindow = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2",Multiple changes are observed in the implementation between the two versions:,"- Introduction of new local variables (`isPreRenderedAndInvisible`, `previousImeWindowStatus`, `nextImeWindowStatus`) to store the state (Other statement changed - 4)"
148,<android.widget.CompoundButton: Mode getButtonTintMode()>,28,29,<android.widget.CompoundButton: Mode getButtonTintMode()>,<android.widget.CompoundButton: Mode getButtonTintMode()>,0,"{
    return mButtonTintMode;
}","{
    return mButtonBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mButtonBlendMode) : null;
}",1,"/**
 * @return the blending mode used to apply the tint to the button drawable
 * @attr ref android.R.styleable#CompoundButton_buttonTintMode
 * @see #setButtonTintMode(PorterDuff.Mode)
 */
","/**
 * @return the blending mode used to apply the tint to the button drawable
 * @attr ref android.R.styleable#CompoundButton_buttonTintMode
 * @see #setButtonTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty(name = ""buttonTintMode""), @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed to convert 'mButtonBlendMode' using 'BlendMode.blendModeToPorterDuffMode(mButtonBlendMode)' instead of directly returning 'mButtonTintMode', and the dependent API 'BlendMode.blendModeToPorterDuffMode()' is called, hence the code change type is 1,5.","The change of the return statement causes the late version of the API to potentially return a different value than the early version. This change introduces a new code path and a dependent method which could return a different result. Thus, the CI type is 1."
150,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,28,29,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,<android.view.AccessibilityInteractionController.PrivateHandler: void handleMessage(Message)>,0,"{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                performAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        case MSG_PREPARE_FOR_EXTRA_DATA_REQUEST:
            {
                prepareForExtraDataRequestUiThread(message);
            }
            break;
        case MSG_APP_PREPARATION_FINISHED:
            {
                requestPreparerDoneUiThread(message);
            }
            break;
        case MSG_APP_PREPARATION_TIMEOUT:
            {
                requestPreparerTimeoutUiThread();
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}","{
    final int type = message.what;
    switch(type) {
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_ACCESSIBILITY_ID:
            {
                findAccessibilityNodeInfoByAccessibilityIdUiThread(message);
            }
            break;
        case MSG_PERFORM_ACCESSIBILITY_ACTION:
            {
                performAccessibilityActionUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFOS_BY_VIEW_ID:
            {
                findAccessibilityNodeInfosByViewIdUiThread(message);
            }
            break;
        case MSG_FIND_ACCESSIBILITY_NODE_INFO_BY_TEXT:
            {
                findAccessibilityNodeInfosByTextUiThread(message);
            }
            break;
        case MSG_FIND_FOCUS:
            {
                findFocusUiThread(message);
            }
            break;
        case MSG_FOCUS_SEARCH:
            {
                focusSearchUiThread(message);
            }
            break;
        case MSG_PREPARE_FOR_EXTRA_DATA_REQUEST:
            {
                prepareForExtraDataRequestUiThread(message);
            }
            break;
        case MSG_APP_PREPARATION_FINISHED:
            {
                requestPreparerDoneUiThread(message);
            }
            break;
        case MSG_APP_PREPARATION_TIMEOUT:
            {
                requestPreparerTimeoutUiThread();
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS:
            {
                clearAccessibilityFocusUiThread();
            }
            break;
        case MSG_NOTIFY_OUTSIDE_TOUCH:
            {
                notifyOutsideTouchUiThread();
            }
            break;
        default:
            throw new IllegalArgumentException(""Unknown message type: "" + type);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Two cases (MSG_CLEAR_ACCESSIBILITY_FOCUS and MSG_NOTIFY_OUTSIDE_TOUCH) have been added to the switch statement (control dependency change), and they call new methods (clearAccessibilityFocusUiThread() and notifyOutsideTouchUiThread(), respectively). However, none of the existing cases, default case or the throw statement have been modified. Therefore, the change is classified as 3 (control dependency change) and 4 (other statement changed).","There is no Compatibility Issue caused by these changes because the added cases and their corresponding methods will handle new message types that were previously unhandled and would have led to an IllegalArgumentException being thrown (as per the default case). Existing functionality and message types are unaffected, which means there should be no change in behavior for previously defined message types and thus no different return values or types, no different exception handlings for pre-existing code paths."
151,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitUnbufferedIo()>,0,"{
    return disable(DETECT_UNBUFFERED_IO);
}","{
    return disable(DETECT_THREAD_UNBUFFERED_IO);
}",1,"/**
 * Disable detection of unbuffered input/output operations.
 */
","/**
 * Disable detection of unbuffered input/output operations.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method disable() is called with a different constant (DETECT_UNBUFFERED_IO vs DETECT_THREAD_UNBUFFERED_IO), suggesting that the dependent API has changed (5). The late implementation also includes an addition of a non-null annotation (4), and the return statement change suggests the method returns a different value (1).","The change from DETECT_UNBUFFERED_IO to DETECT_THREAD_UNBUFFERED_IO implies a potentially different behavior in disabling certain features of the policy, which could result in different values being returned. The addition of the NonNull annotation suggests that the method is now expected not to return null, indicating a compatibility issue due to potential different return values (1)."
152,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,28,29,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = getInputMethodManager();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
153,"<android.provider.MediaStore: Uri getDocumentUri(Context,Uri)>",28,29,"<android.provider.MediaStore: Uri getDocumentUri(Context,Uri)>","<android.provider.MediaStore: Uri getDocumentUri(Context,Uri)>",0,"{
    try {
        final ContentResolver resolver = context.getContentResolver();
        final String path = getFilePath(resolver, mediaUri);
        final List<UriPermission> uriPermissions = resolver.getPersistedUriPermissions();
        return getDocumentUri(resolver, path, uriPermissions);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}","{
    final ContentResolver resolver = context.getContentResolver();
    final List<UriPermission> uriPermissions = resolver.getPersistedUriPermissions();
    try (ContentProviderClient client = resolver.acquireContentProviderClient(AUTHORITY)) {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, mediaUri);
        in.putParcelableList(DocumentsContract.EXTRA_URI_PERMISSIONS, uriPermissions);
        final Bundle out = client.call(GET_DOCUMENT_URI_CALL, null, in);
        return out.getParcelable(DocumentsContract.EXTRA_URI);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
}",1,"/**
 * Gets a URI backed by a {@link DocumentsProvider} that points to the same media
 * file as the specified mediaUri. This allows apps who have permissions to access
 * media files in Storage Access Framework to perform file operations through that
 * on media files.
 * <p>
 * Note: this method doesn't grant any URI permission. Callers need to obtain
 * permission before calling this method. One way to obtain permission is through
 * a 3-step process:
 * <ol>
 * <li>Call {@link android.os.storage.StorageManager#getStorageVolume(File)} to
 * obtain the {@link android.os.storage.StorageVolume} of a media file;</li>
 *
 * <li>Invoke the intent returned by
 * {@link android.os.storage.StorageVolume#createAccessIntent(String)} to
 * obtain the access of the volume or one of its specific subdirectories;</li>
 *
 * <li>Check whether permission is granted and take persistent permission.</li>
 * </ol>
 * @param mediaUri the media URI which document URI is requested
 * @return the document URI
 */
","/**
 * Return a {@link DocumentsProvider} Uri that is an equivalent to the given
 * {@link MediaStore} Uri.
 * <p>
 * This allows apps with Storage Access Framework permissions to convert
 * between {@link MediaStore} and {@link DocumentsProvider} Uris that refer
 * to the same underlying item. Note that this method doesn't grant any new
 * permissions; callers must already hold permissions obtained with
 * {@link Intent#ACTION_OPEN_DOCUMENT} or related APIs.
 *
 * @param mediaUri The {@link MediaStore} Uri to convert.
 * @return An equivalent {@link DocumentsProvider} Uri. Returns {@code null}
 * if no equivalent was found.
 * @see #getMediaUri(Context, Uri)
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The late version API has several changes: ,"- The early version has a catch block that throws a RuntimeException, which is unaltered; hence, exception handling is not changed. "
154,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,28,29,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null, 0);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null, 0);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null, 0);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null, 0);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}",1,"/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */
","/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,"A new conditional check for sHasBeamFeature has been added and a return statement is introduced if sHasBeamFeature is false, so the code change types are Control dependency changed (3) and Other statement changed (4).","Although there is a new control flow and early return, if sHasBeamFeature is false the method simply exits early with no action. This behavior is not a compatibility issue because it does not lead to the API returning a different value or type nor does it lead to throwing a different exception compared to the previous version; it just prevents the execution of any subsequent code if the feature is not available. Therefore, there is no Compatibility Issue (0)."
155,<android.app.AutomaticZenRule: int hashCode()>,28,29,<android.app.AutomaticZenRule: int hashCode()>,<android.app.AutomaticZenRule: int hashCode()>,0,"{
    return Objects.hash(enabled, name, interruptionFilter, conditionId, owner, creationTime);
}","{
    return Objects.hash(enabled, name, interruptionFilter, conditionId, owner, configurationActivity, mZenPolicy, mModified, creationTime);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() method's implementation has changed by adding new fields to the Objects.hash() call, so the change type is 1 and 4 because of the other changed statement within the method.","The change in the hashCode() method leads to a different return value due to the inclusion of additional fields in the hash calculation. Hence, there is a compatibility issue of type 1."
156,"<android.bluetooth.BluetoothHealth: ParcelFileDescriptor getMainChannelFd(BluetoothDevice,BluetoothHealthAppConfiguration)>",28,29,"<android.bluetooth.BluetoothHealth: ParcelFileDescriptor getMainChannelFd(BluetoothDevice,BluetoothHealthAppConfiguration)>","<android.bluetooth.BluetoothHealth: ParcelFileDescriptor getMainChannelFd(BluetoothDevice,BluetoothHealthAppConfiguration)>",0,"{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.getMainChannelFd(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}","{
    Log.e(TAG, ""getMainChannelFd(): BluetoothHealth is deprecated"");
    return null;
}",1,"/**
 * Get the file descriptor of the main channel associated with the remote device
 * and application configuration.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * <p> Its the responsibility of the caller to close the ParcelFileDescriptor
 * when done.
 *
 * @param device The remote Bluetooth health device
 * @param config The application configuration
 * @return null on failure, ParcelFileDescriptor on success.
 */
","/**
 * Get the file descriptor of the main channel associated with the remote device
 * and application configuration.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * <p> Its the responsibility of the caller to close the ParcelFileDescriptor
 * when done.
 *
 * @param device The remote Bluetooth health device
 * @param config The application configuration
 * @return null on failure, ParcelFileDescriptor on success.
 *
 * @deprecated Health Device Profile (HDP) and MCAP protocol are no longer used. New
 * apps should use Bluetooth Low Energy based solutions such as {@link BluetoothGatt},
 * {@link BluetoothAdapter#listenUsingL2capChannel()(int)}, or
 * {@link BluetoothDevice#createL2capChannel(int)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The entire block of conditionals and try-catch logic has been removed and replaced with a single line that returns null, and a log statement indicating deprecation has been added. Therefore, both the return statement and other statements have changed (code change type 1,4).","Since the new implementation always returns null and logs a deprecation message, the behavior of the method has changed, which means that for any input, the method will no longer attempt to perform its previous functionality but will simply return null. This represents a change in the potential return value of the API, so the CI type is 1."
157,<android.speech.tts.TextToSpeechService.SynthesisToFileOutputStreamSpeechItem: void playImpl()>,28,29,<android.speech.tts.TextToSpeechService.SynthesisToFileOutputStreamSpeechItem: void playImpl()>,<android.speech.tts.TextToSpeechService.SynthesisToFileOutputStreamSpeechItem: void playImpl()>,0,"{
    dispatchOnStart();
    super.playImpl();
    try {
        mFileOutputStream.close();
    } catch (IOException e) {
        Log.w(TAG, ""Failed to close output file"", e);
    }
}","{
    super.playImpl();
    try {
        mFileOutputStream.close();
    } catch (IOException e) {
        Log.w(TAG, ""Failed to close output file"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The method dispatchOnStart() call at the beginning of the method has been removed, yet there are no other changes in the method body. This affects the control flow of the method, resulting in changes to the control dependency, so the code change type is 3.","There is no return statement or exception handling statement changed, and while the removal of dispatchOnStart() does affect the sequence of operations within the method, it does not directly lead to a change in the values returned by the method or the exceptions it throws. Therefore, there is no Compatibility Issue, corresponding to 0."
161,<android.view.accessibility.AccessibilityManager: void removeAccessibilityRequestPreparer(AccessibilityRequestPreparer)>,28,29,<android.view.accessibility.AccessibilityManager: void removeAccessibilityRequestPreparer(AccessibilityRequestPreparer)>,<android.view.accessibility.AccessibilityManager: void removeAccessibilityRequestPreparer(AccessibilityRequestPreparer)>,0,"{
    if (mRequestPreparerLists == null) {
        return;
    }
    int viewId = preparer.getView().getAccessibilityViewId();
    List<AccessibilityRequestPreparer> requestPreparerList = mRequestPreparerLists.get(viewId);
    if (requestPreparerList != null) {
        requestPreparerList.remove(preparer);
        if (requestPreparerList.isEmpty()) {
            mRequestPreparerLists.remove(viewId);
        }
    }
}","{
    if (mRequestPreparerLists == null) {
        return;
    }
    int viewId = preparer.getAccessibilityViewId();
    List<AccessibilityRequestPreparer> requestPreparerList = mRequestPreparerLists.get(viewId);
    if (requestPreparerList != null) {
        requestPreparerList.remove(preparer);
        if (requestPreparerList.isEmpty()) {
            mRequestPreparerLists.remove(viewId);
        }
    }
}",1,"/**
 * Unregisters a {@link AccessibilityRequestPreparer}.
 */
","/**
 * Unregisters a {@link AccessibilityRequestPreparer}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the way 'viewId' is retrieved from the 'preparer'. It changed from calling 'preparer.getView().getAccessibilityViewId()' to 'preparer.getAccessibilityViewId()', so the change types are 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue because even though the method used to acquire 'viewId' has been modified, it should yield the same result if the 'preparer' object adheres to the expected behavior. The internal logic and workflow of the method remain the same and won't affect the functionality from a caller's perspective. This is a refactor or optimization rather than a behavioral change."
163,<android.app.NotificationManager.Policy: boolean equals(Object)>,28,29,<android.app.NotificationManager.Policy: boolean equals(Object)>,<android.app.NotificationManager.Policy: boolean equals(Object)>,0,"{
    if (!(o instanceof Policy))
        return false;
    if (o == this)
        return true;
    final Policy other = (Policy) o;
    return other.priorityCategories == priorityCategories && other.priorityCallSenders == priorityCallSenders && other.priorityMessageSenders == priorityMessageSenders && other.suppressedVisualEffects == suppressedVisualEffects;
}","{
    if (!(o instanceof Policy))
        return false;
    if (o == this)
        return true;
    final Policy other = (Policy) o;
    return other.priorityCategories == priorityCategories && other.priorityCallSenders == priorityCallSenders && other.priorityMessageSenders == priorityMessageSenders && suppressedVisualEffectsEqual(suppressedVisualEffects, other.suppressedVisualEffects);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the equality check for suppressedVisualEffects. The early version directly compares the variables, while the late version calls the method suppressedVisualEffectsEqual to do the comparison. This points to a change in the method used for comparison (Other statement changed - 4) and indicates a change in the dependent API (Dependent API changed - 5) since a new method is called.","Even though there is a change in how the comparison is performed, the purpose of the equals method remains to return a boolean indicating equality, which is based on the same fields in both versions. Assuming the new suppressedVisualEffectsEqual method provides equivalent functionality to a direct comparison (e.g., accounting for potential bitwise comparison nuances in suppressedVisualEffects), there would be no Compatibility Issue because the same logical outcome is expected from the equals method. Therefore, there is no change that could lead to different return values or exceptions being thrown."
164,"<android.view.autofill.AutofillManager.CompatibilityBridge: AccessibilityEvent onAccessibilityEvent(AccessibilityEvent,boolean,int)>",28,29,"<android.view.autofill.AutofillManager.CompatibilityBridge: AccessibilityEvent onAccessibilityEvent(AccessibilityEvent,boolean,int)>","<android.view.autofill.AutofillManager.CompatibilityBridge: AccessibilityEvent onAccessibilityEvent(AccessibilityEvent,boolean,int)>",0,"{
    switch(event.getEventType()) {
        case AccessibilityEvent.TYPE_VIEW_FOCUSED:
            {
                synchronized (mLock) {
                    if (mFocusedWindowId == event.getWindowId() && mFocusedNodeId == event.getSourceNodeId()) {
                        return event;
                    }
                    if (mFocusedWindowId != AccessibilityWindowInfo.UNDEFINED_WINDOW_ID && mFocusedNodeId != AccessibilityNodeInfo.UNDEFINED_NODE_ID) {
                        notifyViewExited(mFocusedWindowId, mFocusedNodeId);
                        mFocusedWindowId = AccessibilityWindowInfo.UNDEFINED_WINDOW_ID;
                        mFocusedNodeId = AccessibilityNodeInfo.UNDEFINED_NODE_ID;
                        mFocusedBounds.set(0, 0, 0, 0);
                    }
                    final int windowId = event.getWindowId();
                    final long nodeId = event.getSourceNodeId();
                    if (notifyViewEntered(windowId, nodeId, mFocusedBounds)) {
                        mFocusedWindowId = windowId;
                        mFocusedNodeId = nodeId;
                    }
                }
            }
            break;
        case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
            {
                synchronized (mLock) {
                    if (mFocusedWindowId == event.getWindowId() && mFocusedNodeId == event.getSourceNodeId()) {
                        notifyValueChanged(event.getWindowId(), event.getSourceNodeId());
                    }
                }
            }
            break;
        case AccessibilityEvent.TYPE_VIEW_CLICKED:
            {
                synchronized (mLock) {
                    notifyViewClicked(event.getWindowId(), event.getSourceNodeId());
                }
            }
            break;
        case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
            {
                final AutofillClient client = getClient();
                if (client != null) {
                    synchronized (mLock) {
                        if (client.autofillClientIsFillUiShowing()) {
                            notifyViewEntered(mFocusedWindowId, mFocusedNodeId, mFocusedBounds);
                        }
                        updateTrackedViewsLocked();
                    }
                }
            }
            break;
    }
    return accessibilityEnabled ? event : null;
}","{
    final int type = event.getEventType();
    if (sVerbose) {
        // NOTE: this is waaay spammy, but that's life.
        Log.v(TAG, ""onAccessibilityEvent("" + AccessibilityEvent.eventTypeToString(type) + ""): virtualId="" + AccessibilityNodeInfo.getVirtualDescendantId(event.getSourceNodeId()) + "", client="" + getClient());
    }
    switch(type) {
        case AccessibilityEvent.TYPE_VIEW_FOCUSED:
            {
                synchronized (mLock) {
                    if (mFocusedWindowId == event.getWindowId() && mFocusedNodeId == event.getSourceNodeId()) {
                        return event;
                    }
                    if (mFocusedWindowId != AccessibilityWindowInfo.UNDEFINED_WINDOW_ID && mFocusedNodeId != AccessibilityNodeInfo.UNDEFINED_NODE_ID) {
                        notifyViewExited(mFocusedWindowId, mFocusedNodeId);
                        mFocusedWindowId = AccessibilityWindowInfo.UNDEFINED_WINDOW_ID;
                        mFocusedNodeId = AccessibilityNodeInfo.UNDEFINED_NODE_ID;
                        mFocusedBounds.set(0, 0, 0, 0);
                    }
                    final int windowId = event.getWindowId();
                    final long nodeId = event.getSourceNodeId();
                    if (notifyViewEntered(windowId, nodeId, mFocusedBounds)) {
                        mFocusedWindowId = windowId;
                        mFocusedNodeId = nodeId;
                    }
                }
            }
            break;
        case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
            {
                synchronized (mLock) {
                    if (mFocusedWindowId == event.getWindowId() && mFocusedNodeId == event.getSourceNodeId()) {
                        notifyValueChanged(event.getWindowId(), event.getSourceNodeId());
                    }
                }
            }
            break;
        case AccessibilityEvent.TYPE_VIEW_CLICKED:
            {
                synchronized (mLock) {
                    notifyViewClicked(event.getWindowId(), event.getSourceNodeId());
                }
            }
            break;
        case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:
            {
                final AutofillClient client = getClient();
                if (client != null) {
                    synchronized (mLock) {
                        if (client.autofillClientIsFillUiShowing()) {
                            notifyViewEntered(mFocusedWindowId, mFocusedNodeId, mFocusedBounds);
                        }
                        updateTrackedViewsLocked();
                    }
                }
            }
            break;
    }
    return accessibilityEnabled ? event : null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only additional log statements using Log.v() have been introduced without changing the logic of the method or any return statements or exception handling. Therefore, the code change type is 4, which is ""Other statement changed.""","The added log statements do not affect the actual behavior or the output of the method itself regarding its return value or exception handling; they're purely for verbose logging. Therefore, there is no compatibility issue, and the CI type is 0, ""No Compatibility Issue."""
165,<android.app.RemoteInput.Builder: Builder setAllowFreeFormInput(boolean)>,28,29,<android.app.RemoteInput.Builder: Builder setAllowFreeFormInput(boolean)>,<android.app.RemoteInput.Builder: Builder setAllowFreeFormInput(boolean)>,0,"{
    setFlag(mFlags, allowFreeFormTextInput);
    return this;
}","{
    setFlag(FLAG_ALLOW_FREE_FORM_INPUT, allowFreeFormTextInput);
    return this;
}",1,"/**
 * Specifies whether the user can provide arbitrary text values.
 *
 * @param allowFreeFormTextInput The default is {@code true}.
 * If you specify {@code false}, you must either provide a non-null
 * and non-empty array to {@link #setChoices}, or enable a data result
 * in {@code setAllowDataType}. Otherwise an
 * {@link IllegalArgumentException} is thrown
 * @return this object for method chaining
 */
","/**
 * Specifies whether the user can provide arbitrary text values.
 *
 * @param allowFreeFormTextInput The default is {@code true}.
 * If you specify {@code false}, you must either provide a non-null
 * and non-empty array to {@link #setChoices}, or enable a data result
 * in {@code setAllowDataType}. Otherwise an
 * {@link IllegalArgumentException} is thrown
 * @return this object for method chaining
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation uses a different constant (FLAG_ALLOW_FREE_FORM_INPUT) instead of mFlags when calling setFlag(), so the change type is 4. It also represents a change to a dependent API because the constant used in the method argument has changed, so the change type includes 5.","There is no compatibility issue since the return type of the method has not changed, and there is no modification in the return statement or exception handling that would lead to a change in the behavior of the method. The functional outcome inside setFlag() is expected to remain consistent despite the change in how the flag is being set, provided FLAG_ALLOW_FREE_FORM_INPUT is equivalent to what mFlags represented in the context of setting the free form input flag."
167,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",28,29,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>","<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",0,"{
    showStatusIconInternal(imeToken, packageName, iconId);
}","{
    InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIcon(packageName, iconId);
}",1,"/**
 * @deprecated Use {@link InputMethodService#showStatusIcon(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
","/**
 * @deprecated Use {@link InputMethodService#showStatusIcon(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from calling showStatusIconInternal(...) in the early version to calling InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIcon(...) in the late version. This is a change in the method call of a dependent API, which is a change type 4,5.","There is no direct indication of a different return value or an added/removed exception handling, and there have been no changes to the return type or signatures that would indicate this. Assuming the semantics of the new method called are intended to maintain backward compatibility by achieving the same effect, there is no Compatibility Issue, so the CI type is 0. However, this assumption is based on the expectation that the new API performs the same function as the deprecated one but this should be verified with additional contextual information about API behavior."
168,"<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String,String,String,String)>",28,29,"<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String,String,String,String)>","<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String,String,String,String)>",0,"{
    String[] projection = computeProjection(projectionIn);
    StringBuilder where = new StringBuilder();
    boolean hasBaseWhereClause = mWhereClause != null && mWhereClause.length() > 0;
    if (hasBaseWhereClause) {
        where.append(mWhereClause.toString());
        where.append(')');
    }
    // Tack on the user's selection, if present.
    if (selection != null && selection.length() > 0) {
        if (hasBaseWhereClause) {
            where.append("" AND "");
        }
        where.append('(');
        where.append(selection);
        where.append(')');
    }
    return buildQueryString(mDistinct, mTables, projection, where.toString(), groupBy, having, sortOrder, limit);
}","{
    String[] projection = computeProjection(projectionIn);
    String where = computeWhere(selection);
    return buildQueryString(mDistinct, mTables, projection, where, groupBy, having, sortOrder, limit);
}",1,"/**
 * Construct a SELECT statement suitable for use in a group of
 * SELECT statements that will be joined through UNION operators
 * in buildUnionQuery.
 *
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to
 * prevent reading data from storage that isn't going to be
 * used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself).  Passing null will return all rows for the given
 * URL.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY itself).
 * Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
","/**
 * Construct a {@code SELECT} statement suitable for use in a group of
 * {@code SELECT} statements that will be joined through {@code UNION} operators
 * in buildUnionQuery.
 *
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to
 * prevent reading data from storage that isn't going to be
 * used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself).  Passing null will return all rows for the given
 * URL.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL {@code GROUP BY} clause (excluding the {@code GROUP BY} itself).
 * Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL {@code HAVING} clause (excluding the {@code HAVING} itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * {@code ORDER BY} clause (excluding the {@code ORDER BY} itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as {@code LIMIT} clause. Passing null denotes no {@code LIMIT} clause.
 * @return the resulting SQL {@code SELECT} statement
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The code change includes refactoring to a new method computeWhere(selection), changing the StringBuilder to a String for the where clause, and the control flow around appending to the where clause is now encapsulated in the computeWhere method. Therefore, the changes are 3 (the if-else structure has been changed and encapsulated), 4 (string building has been replaced with a method call), and 5 (computeWhere seems to be a dependent API which has undergone changes).","Given the refactor and the method computeWhere(selection) being new or changed, it is possible that the resulting SQL query built might be different in the late version compared to the early version. Therefore, the resulting behavior of the method can be different due to potential changes in the computed where clause, leading to a different return value. Hence, the CI type is 1."
169,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUidTagState(int,String,long,long,int,int,int)>",28,29,"<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUidTagState(int,String,long,long,int,int,int)>","<android.app.usage.NetworkStatsManager: NetworkStats queryDetailsForUidTagState(int,String,long,long,int,int,int)>",0,"{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    NetworkStats result;
    try {
        result = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
        result.startHistoryEnumeration(uid, tag, state);
    } catch (RemoteException e) {
        Log.e(TAG, ""Error while querying stats for uid="" + uid + "" tag="" + tag + "" state="" + state, e);
        return null;
    }
    return result;
}","{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    return queryDetailsForUidTagState(template, startTime, endTime, uid, tag, state);
}",1,"/**
 * Query network usage statistics details for a given uid, tag, and state. Only usable for uids
 * belonging to calling user. Result is not aggregated over time. This means buckets' start and
 * end timestamps are going to be between 'startTime' and 'endTime' parameters. The uid is going
 * to be the same as the 'uid' parameter, the tag the same as the 'tag' parameter, and the state
 * the same as the 'state' parameter.
 * defaultNetwork is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered is going to be {@link NetworkStats.Bucket#METERED_ALL}, and
 * roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for no tags.
 * @param state state of interest. Use {@link NetworkStats.Bucket#STATE_ALL} to aggregate
 * traffic from all states.
 * @return Statistics object or null if an error happened during statistics collection.
 * @throws SecurityException if permissions are insufficient to read network statistics.
 */
","/**
 * Query network usage statistics details for a given uid, tag, and state. Only usable for uids
 * belonging to calling user. Result is not aggregated over time. This means buckets' start and
 * end timestamps are going to be between 'startTime' and 'endTime' parameters. The uid is going
 * to be the same as the 'uid' parameter, the tag the same as the 'tag' parameter, and the state
 * the same as the 'state' parameter.
 * defaultNetwork is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered is going to be {@link NetworkStats.Bucket#METERED_ALL}, and
 * roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for no tags.
 * @param state state of interest. Use {@link NetworkStats.Bucket#STATE_ALL} to aggregate
 * traffic from all states.
 * @return Statistics object or null if an error happened during statistics collection.
 * @throws SecurityException if permissions are insufficient to read network statistics.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"There's a notable change in the implementation from manually creating a `NetworkStats` object and handling `RemoteException` to directly returning the result of `queryDetailsForUidTagState` with the provided arguments. Additionally, the reliance on the internal `queryDetailsForUidTagState` method indicates a change in the dependent API, so the code change type is 1,5.","Since the method in the late version delegates the task to another method and does not handle `RemoteException` with a default return value (like 'return null' in the early version), it can potentially throw an exception instead of returning a null value. This change in how exceptions are handled represents a potential Compatibility Issue caused by different return values or types, thereby assigning the CI type as 1."
170,<android.app.Activity: void finishActivity(int)>,28,29,<android.app.Activity: void finishActivity(int)>,<android.app.Activity: void finishActivity(int)>,0,"{
    if (mParent == null) {
        try {
            ActivityManager.getService().finishSubActivity(mToken, mEmbeddedID, requestCode);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishActivityFromChild(this, requestCode);
    }
}","{
    if (mParent == null) {
        try {
            ActivityTaskManager.getService().finishSubActivity(mToken, mEmbeddedID, requestCode);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishActivityFromChild(this, requestCode);
    }
}",1,"/**
 * Force finish another activity that you had previously started with
 * {@link #startActivityForResult}.
 *
 * @param requestCode The request code of the activity that you had
 * given to startActivityForResult().  If there are multiple
 * activities started with this request code, they
 * will all be finished.
 */
","/**
 * Force finish another activity that you had previously started with
 * {@link #startActivityForResult}.
 *
 * @param requestCode The request code of the activity that you had
 * given to startActivityForResult().  If there are multiple
 * activities started with this request code, they
 * will all be finished.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API that is being called has changed from ActivityManager.getService() to ActivityTaskManager.getService(), so the code change is related to a dependent API, which is type 5.","Since the body of the method is fully encapsulated within a try-catch block for RemoteException and the catch block is empty without any changes in behavior, there is no potential Compatibility Issue in terms of different return values or exception handling, so the CI type is 0."
171,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,28,29,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,0,"{
    try {
        Preconditions.checkNotNull(clip);
        clip.prepareToLeaveProcess(true);
        mService.setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        Preconditions.checkNotNull(clip);
        clip.prepareToLeaveProcess(true);
        mService.setPrimaryClip(clip, mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 * @see #getPrimaryClip()
 * @see #clearPrimaryClip()
 */
","/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 * @see #getPrimaryClip()
 * @see #clearPrimaryClip()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The call to mService.setPrimaryClip() includes an additional parameter in the late implementation. This indicates a change in the dependent API, so the code change type is 5.","Since the method's signature has not changed and the exception handling remains the same, there is no change in the API's outward behavior in terms of exceptions being thrown or the values being returned by the API. Thus, there are no CIs in this regard, and the CI type is 0."
172,<android.view.View: void setClipBounds(Rect)>,28,29,<android.view.View: void setClipBounds(Rect)>,<android.view.View: void setClipBounds(Rect)>,0,"{
    if (clipBounds == mClipBounds || (clipBounds != null && clipBounds.equals(mClipBounds))) {
        return;
    }
    if (clipBounds != null) {
        if (mClipBounds == null) {
            mClipBounds = new Rect(clipBounds);
        } else {
            mClipBounds.set(clipBounds);
        }
    } else {
        mClipBounds = null;
    }
    mRenderNode.setClipBounds(mClipBounds);
    invalidateViewProperty(false, false);
}","{
    if (clipBounds == mClipBounds || (clipBounds != null && clipBounds.equals(mClipBounds))) {
        return;
    }
    if (clipBounds != null) {
        if (mClipBounds == null) {
            mClipBounds = new Rect(clipBounds);
        } else {
            mClipBounds.set(clipBounds);
        }
    } else {
        mClipBounds = null;
    }
    mRenderNode.setClipRect(mClipBounds);
    invalidateViewProperty(false, false);
}",1,"/**
 * Sets a rectangular area on this view to which the view will be clipped
 * when it is drawn. Setting the value to null will remove the clip bounds
 * and the view will draw normally, using its full bounds.
 *
 * @param clipBounds The rectangular area, in the local coordinates of
 * this view, to which future drawing operations will be clipped.
 */
","/**
 * Sets a rectangular area on this view to which the view will be clipped
 * when it is drawn. Setting the value to null will remove the clip bounds
 * and the view will draw normally, using its full bounds.
 *
 * @param clipBounds The rectangular area, in the local coordinates of
 * this view, to which future drawing operations will be clipped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method invoked on `mRenderNode` has changed from `setClipBounds(Rect)` to `setClipRect(Rect)`. This is a change in a method call of a dependent object, so the change type is 4,5.","Although the name of the method on `mRenderNode` has changed, since the API itself is a void method, it does not return any value that could be affected by this change, therefore there's no direct effect on the existing contracts of the `setClipBounds(Rect)` API. It might be considered an internal change unless `setClipRect(Rect)` has a different behavior compared to `setClipBounds(Rect)`, which is not apparent from the provided information. Thus, based on the available information, there is no compatibility issue (type 0)."
173,<android.net.ConnectivityManager.CallbackHandler: void handleMessage(Message)>,28,29,<android.net.ConnectivityManager.CallbackHandler: void handleMessage(Message)>,<android.net.ConnectivityManager.CallbackHandler: void handleMessage(Message)>,0,"{
    if (message.what == EXPIRE_LEGACY_REQUEST) {
        expireRequest((NetworkCapabilities) message.obj, message.arg1);
        return;
    }
    final NetworkRequest request = getObject(message, NetworkRequest.class);
    final Network network = getObject(message, Network.class);
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(request);
    }
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + "" for network "" + network);
    }
    if (callback == null) {
        Log.w(TAG, ""callback not found for "" + getCallbackName(message.what) + "" message"");
        return;
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                callback.onPreCheck(network);
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onAvailable(network, cap, lp);
                break;
            }
        case CALLBACK_LOSING:
            {
                callback.onLosing(network, message.arg1);
                break;
            }
        case CALLBACK_LOST:
            {
                callback.onLost(network);
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                callback.onUnavailable();
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                callback.onCapabilitiesChanged(network, cap);
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onLinkPropertiesChanged(network, lp);
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                callback.onNetworkSuspended(network);
                break;
            }
        case CALLBACK_RESUMED:
            {
                callback.onNetworkResumed(network);
                break;
            }
    }
}","{
    if (message.what == EXPIRE_LEGACY_REQUEST) {
        expireRequest((NetworkCapabilities) message.obj, message.arg1);
        return;
    }
    final NetworkRequest request = getObject(message, NetworkRequest.class);
    final Network network = getObject(message, Network.class);
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(request);
        if (callback == null) {
            Log.w(TAG, ""callback not found for "" + getCallbackName(message.what) + "" message"");
            return;
        }
        if (message.what == CALLBACK_UNAVAIL) {
            sCallbacks.remove(request);
            callback.networkRequest = ALREADY_UNREGISTERED;
        }
    }
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + "" for network "" + network);
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                callback.onPreCheck(network);
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onAvailable(network, cap, lp, message.arg1 != 0);
                break;
            }
        case CALLBACK_LOSING:
            {
                callback.onLosing(network, message.arg1);
                break;
            }
        case CALLBACK_LOST:
            {
                callback.onLost(network);
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                callback.onUnavailable();
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                callback.onCapabilitiesChanged(network, cap);
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onLinkPropertiesChanged(network, lp);
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                callback.onNetworkSuspended(network);
                break;
            }
        case CALLBACK_RESUMED:
            {
                callback.onNetworkResumed(network);
                break;
            }
        case CALLBACK_BLK_CHANGED:
            {
                boolean blocked = message.arg1 != 0;
                callback.onBlockedStatusChanged(network, blocked);
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2",The code changes include:,- The introduction of a new case CALLBACK_BLK_CHANGED for the switch statement.
175,<android.util.ArrayMap: String toString()>,28,29,<android.util.ArrayMap: String toString()>,<android.util.ArrayMap: String toString()>,0,"{
    if (isEmpty()) {
        return ""{}"";
    }
    StringBuilder buffer = new StringBuilder(mSize * 28);
    buffer.append('{');
    for (int i = 0; i < mSize; i++) {
        if (i > 0) {
            buffer.append("", "");
        }
        Object key = keyAt(i);
        if (key != this) {
            buffer.append(key);
        } else {
            buffer.append(""(this Map)"");
        }
        buffer.append('=');
        Object value = valueAt(i);
        if (value != this) {
            buffer.append(value);
        } else {
            buffer.append(""(this Map)"");
        }
    }
    buffer.append('}');
    return buffer.toString();
}","{
    if (isEmpty()) {
        return ""{}"";
    }
    StringBuilder buffer = new StringBuilder(mSize * 28);
    buffer.append('{');
    for (int i = 0; i < mSize; i++) {
        if (i > 0) {
            buffer.append("", "");
        }
        Object key = keyAt(i);
        if (key != this) {
            buffer.append(key);
        } else {
            buffer.append(""(this Map)"");
        }
        buffer.append('=');
        Object value = valueAt(i);
        if (value != this) {
            buffer.append(ArrayUtils.deepToString(value));
        } else {
            buffer.append(""(this Map)"");
        }
    }
    buffer.append('}');
    return buffer.toString();
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation composes a string by iterating over its mappings. If
 * this map contains itself as a key or a value, the string ""(this Map)""
 * will appear in its place.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method ArrayUtils.deepToString(value) is used in the late implementation where previously just value was used. This implies a different string representation of 'value' could be produced, especially when 'value' is an array or a collection. Therefore, the code change is classified as 4,5.","The change in calling ArrayUtils.deepToString(value) could potentially return a different String representation of 'value' when 'value' is an array or collection. Consequently, the behaviour of the toString() method has been altered, leading to a potential Compatibility Issue of type 1."
176,<android.content.ContentValues: Byte getAsByte(String)>,28,29,<android.content.ContentValues: Byte getAsByte(String)>,<android.content.ContentValues: Byte getAsByte(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).byteValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Byte.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Byte value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Byte: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return value != null ? ((Number) value).byteValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Byte.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Byte value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Byte: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Byte.
 *
 * @param key the value to get
 * @return the Byte value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Byte.
 *
 * @param key the value to get
 * @return the Byte value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the name of the internal map from mValues to mMap, which is merely an internal variable rename and does not affect the method's behavior, constituting an ""Other statement changed"".",There is no Compatibility Issue as the method's external behavior and return type remain consistent across both versions. The renaming of an internal field does not cause a change in the returned values or the exceptions thrown.
177,<android.widget.Editor.SelectionModifierCursorController: void show()>,28,29,<android.widget.Editor.SelectionModifierCursorController: void show()>,<android.widget.Editor.SelectionModifierCursorController: void show()>,0,"{
    if (mTextView.isInBatchEditMode()) {
        return;
    }
    initDrawables();
    initHandles();
}","{
    if (mTextView.isInBatchEditMode()) {
        return;
    }
    loadHandleDrawables(false);
    initHandles();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the if-statement block changed from initDrawables() to loadHandleDrawables(false), affecting the way drawables are loaded. Also, a parameter is added to this method (false), so the method signature it depends on has changed, resulting in change types 4 and 5.","This change does not affect the execution flow or the return value of the 'show' method or its exception handling; hence it would not cause a compatibility issue, so the CI type is 0."
178,<android.hardware.camera2.CameraCharacteristics: List<Key<?>> getKeys()>,28,29,<android.hardware.camera2.CameraCharacteristics: List<Key<?>> getKeys()>,<android.hardware.camera2.CameraCharacteristics: List<Key<?>> getKeys()>,0,"{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError(""android.request.availableCharacteristicsKeys must be non-null"" + "" in the characteristics"");
    }
    mKeys = Collections.unmodifiableList(getKeys(getClass(), getKeyClass(), this, filterTags));
    return mKeys;
}","{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError(""android.request.availableCharacteristicsKeys must be non-null"" + "" in the characteristics"");
    }
    mKeys = Collections.unmodifiableList(getKeys(getClass(), getKeyClass(), this, filterTags, true));
    return mKeys;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@NonNull, @Override]","[@NonNull, @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method `getKeys` has been changed to include an additional boolean parameter which can alter the behavior of the dependent API, so the code change type is 1,5.","The added parameter to the `getKeys` method suggests a potential difference in how the keys are retrieved or filtered, leading to a different list being returned. This constitutes a CI of type 1 due to the potential different return values."
181,"<android.content.ContentValues: Entry<String, Object>> valueSet()>",28,29,"<android.content.ContentValues: Entry<String, Object>> valueSet()>","<android.content.ContentValues: Entry<String, Object>> valueSet()>",0,"{
    return mValues.entrySet();
}","{
    return mMap.entrySet();
}",1,"/**
 * Returns a set of all of the keys and values
 *
 * @return a set of all of the keys and values
 */
","/**
 * Returns a set of all of the keys and values
 *
 * @return a set of all of the keys and values
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement change from returning mValues.entrySet() to returning mMap.entrySet() which indicates the variable holding the data has been changed, so the code change type is 4,5.","The return value is affected due to the change in the internal variable from which the entry set is obtained. Consequently, API users will receive a different entry set if the underlying map is different from the original values, so the CI type is 1."
182,<android.service.notification.ConditionProviderService: void requestUnbind()>,28,29,<android.service.notification.ConditionProviderService: void requestUnbind()>,<android.service.notification.ConditionProviderService: void requestUnbind()>,0,"{
    INotificationManager noMan = getNotificationInterface();
    try {
        noMan.requestUnbindProvider(mProvider);
        // Disable future messages.
        mProvider = null;
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}","{
    INotificationManager noMan = getNotificationInterface();
    try {
        noMan.requestUnbindProvider(mProvider);
        // Disable future messages.
        mIsConnected = false;
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Request that the provider service be unbound.
 *
 * <p>This will no longer receive subscription updates and will not be able to update the
 * state of conditions until {@link #requestRebind(ComponentName)} is called.
 * The service will likely be killed by the system after this call.
 *
 * <p>The service should wait for the {@link #onConnected()} event before performing this
 * operation.
 */
","/**
 * Request that the provider service be unbound.
 *
 * <p>This will no longer receive subscription updates and will not be able to update the
 * state of conditions until {@link #requestRebind(ComponentName)} is called.
 * The service will likely be killed by the system after this call.
 *
 * <p>The service should wait for the {@link #onConnected()} event before performing this
 * operation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The line `mProvider = null;` has been replaced with `mIsConnected = false;`, which indicates an assignment to a different variable, so the code change is classified as 4.",There is no Compatibility Issue since both the early and late versions are handling the exception in the same way and there is no change in the return type or exception thrown. The assignment to a different variable does not affect the API's behaviour from the caller's perspective.
183,<android.content.ContentValues: Integer getAsInteger(String)>,28,29,<android.content.ContentValues: Integer getAsInteger(String)>,<android.content.ContentValues: Integer getAsInteger(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).intValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Integer.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Integer value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Integer: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return value != null ? ((Number) value).intValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Integer.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Integer value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Integer: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to an Integer.
 *
 * @param key the value to get
 * @return the Integer value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to an Integer.
 *
 * @param key the value to get
 * @return the Integer value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The change from mValues.get(key) to mMap.get(key) does not alter the method's behavior because it only reflects a change in the internal variable name. The actual logic of the method, including the manner in which it accesses map elements, type casts, and handles exceptions, remains unchanged.",There is no compatibility issue as the behavior of the method has not been changed; the API still performs the same operations and yields the same results given the same inputs.
184,<android.os.StrictMode.AndroidBlockGuardPolicy: void onReadFromDisk()>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void onReadFromDisk()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onReadFromDisk()>,0,"{
    if ((mPolicyMask & DETECT_DISK_READ) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new DiskReadViolation());
}","{
    if ((mThreadPolicyMask & DETECT_THREAD_DISK_READ) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new DiskReadViolation());
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The condition in the 'if' statement has changed from checking mPolicyMask with DETECT_DISK_READ to checking mThreadPolicyMask with DETECT_THREAD_DISK_READ, and thus the control dependency has changed. The variable used in the condition (mPolicyMask to mThreadPolicyMask) and the constant (DETECT_DISK_READ to DETECT_THREAD_DISK_READ) which it is being compared to are also both changed, which means the implementation relies on a changed dependent API, so the code change types are 3 and 5.","The updated condition could lead to the method returning early or not depending on the new value of the new mask (mThreadPolicyMask & DETECT_THREAD_DISK_READ). Given that the control expression to check the policy mask has changed, the method may not execute the startHandlingViolationException() call where it previously would have or vice versa. This indicates a potential Compatibility Issue due to the fact that different behavior (different violations being reported) can be expected from the policy change, and so the CI type is 1."
186,"<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>",28,29,"<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, queryArgs);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        if (mWrapped != null) {
            return mWrapped.query(uri, projection, queryArgs, cancellationSignal);
        }
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, queryArgs);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}",1,"/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with support for cancellation.
 *
 * <p>For best performance, the caller should follow these guidelines:
 *
 * <li>Provide an explicit projection, to prevent reading data from storage
 * that aren't going to be used.
 *
 * Provider must identify which QUERY_ARG_SORT* arguments were honored during
 * the preparation of the result set by including the respective argument keys
 * in the {@link Cursor} extras {@link Bundle}. See {@link #EXTRA_HONORED_ARGS}
 * for details.
 *
 * @see #QUERY_ARG_SORT_COLUMNS, #QUERY_ARG_SORT_DIRECTION, #QUERY_ARG_SORT_COLLATION.
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param queryArgs A Bundle containing any arguments to the query.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with support for cancellation.
 *
 * <p>For best performance, the caller should follow these guidelines:
 *
 * <li>Provide an explicit projection, to prevent reading data from storage
 * that aren't going to be used.
 *
 * Provider must identify which QUERY_ARG_SORT* arguments were honored during
 * the preparation of the result set by including the respective argument keys
 * in the {@link Cursor} extras {@link Bundle}. See {@link #EXTRA_HONORED_ARGS}
 * for details.
 *
 * @see #QUERY_ARG_SORT_COLUMNS
 * @see #QUERY_ARG_SORT_DIRECTION
 * @see #QUERY_ARG_SORT_COLLATION
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param queryArgs A Bundle containing any arguments to the query.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry. May return
 * <code>null</code> if the underlying content provider returns <code>null</code>,
 * or if it crashes.
 * @see Cursor
 */
",-1,[@Nullable],"[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,,,,
187,<android.view.SurfaceControl.Transaction: Transaction merge(Transaction)>,28,29,<android.view.SurfaceControl.Transaction: Transaction merge(Transaction)>,<android.view.SurfaceControl.Transaction: Transaction merge(Transaction)>,0,"{
    mResizedSurfaces.putAll(other.mResizedSurfaces);
    other.mResizedSurfaces.clear();
    nativeMergeTransaction(mNativeObject, other.mNativeObject);
    return this;
}","{
    if (this == other) {
        return this;
    }
    mResizedSurfaces.putAll(other.mResizedSurfaces);
    other.mResizedSurfaces.clear();
    nativeMergeTransaction(mNativeObject, other.mNativeObject);
    return this;
}",1,"/**
 * Merge the other transaction into this transaction, clearing the
 * other transaction as if it had been applied.
 */
","/**
 * Merge the other transaction into this transaction, clearing the
 * other transaction as if it had been applied.
 *
 * @param other The transaction to merge in to this one.
 * @return This transaction.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,3,0,"A new condition ('if' statement) has been added to check if 'this' and 'other' are the same object, which introduces a control dependency change, so the code change type is 3.","The new 'if' statement causes the method to immediately return 'this' when 'this' and 'other' are the same object, which avoids performing redundant operations. However, it does not cause a Compatibility Issue since the resultant behavior and the returned object ('this') do not change compared to the earlier version when 'this' != 'other'. Thus, the CI type is 0."
189,<android.app.ActivityThread.H: void handleMessage(Message)>,28,29,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            mUpdatingSystemConfig = true;
            try {
                handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            } finally {
                mUpdatingSystemConfig = false;
            }
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
190,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,28,29,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            return ic;
        }
    }
    return null;
}","{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        outAttrs.targetInputMethodUser = mTextOperationUser;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            return ic;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
192,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,0,"{
    if (LOG_V)
        Log.d(TAG, ""onThreadPolicyViolation; policy="" + info.mPolicy);
    if (info.penaltyEnabled(PENALTY_GATHER)) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.getStackTrace().equals(previous.getStackTrace())) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if (info.penaltyEnabled(PENALTY_LOG) && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        sLogger.log(info);
    }
    final Violation violation = info.mViolation;
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if (info.penaltyEnabled(PENALTY_DIALOG) && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if (info.penaltyEnabled(PENALTY_DROPBOX) && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        violationMaskSubset |= info.getViolationBit();
        final boolean justDropBox = (info.mPolicy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
        } else {
            handleApplicationStrictModeViolation(violationMaskSubset, info);
        }
    }
    if ((info.getPolicyMask() & PENALTY_DEATH) != 0) {
        throw new RuntimeException(""StrictMode ThreadPolicy violation"", violation);
    }
    // penaltyDeath will cause penaltyCallback to no-op since we cannot guarantee the
    // executor finishes before crashing.
    final OnThreadViolationListener listener = sThreadViolationListener.get();
    final Executor executor = sThreadViolationExecutor.get();
    if (listener != null && executor != null) {
        try {
            executor.execute(() -> {
                // Lift violated policy to prevent infinite recursion.
                ThreadPolicy oldPolicy = allowThreadViolations();
                try {
                    listener.onThreadViolation(violation);
                } finally {
                    setThreadPolicy(oldPolicy);
                }
            });
        } catch (RejectedExecutionException e) {
            Log.e(TAG, ""ThreadPolicy penaltyCallback failed"", e);
        }
    }
}","{
    if (LOG_V)
        Log.d(TAG, ""onThreadPolicyViolation; penalty="" + info.mPenaltyMask);
    if (info.penaltyEnabled(PENALTY_GATHER)) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.getStackTrace().equals(previous.getStackTrace())) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if (info.penaltyEnabled(PENALTY_LOG) && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        sLogger.log(info);
    }
    final Violation violation = info.mViolation;
    // Penalties that ActivityManager should execute on our behalf.
    int penaltyMask = 0;
    if (info.penaltyEnabled(PENALTY_DIALOG) && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        penaltyMask |= PENALTY_DIALOG;
    }
    if (info.penaltyEnabled(PENALTY_DROPBOX) && lastViolationTime == 0) {
        penaltyMask |= PENALTY_DROPBOX;
    }
    if (penaltyMask != 0) {
        final boolean justDropBox = (info.mPenaltyMask == PENALTY_DROPBOX);
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(penaltyMask, info);
        } else {
            handleApplicationStrictModeViolation(penaltyMask, info);
        }
    }
    if (info.penaltyEnabled(PENALTY_DEATH)) {
        throw new RuntimeException(""StrictMode ThreadPolicy violation"", violation);
    }
    // penaltyDeath will cause penaltyCallback to no-op since we cannot guarantee the
    // executor finishes before crashing.
    final OnThreadViolationListener listener = sThreadViolationListener.get();
    final Executor executor = sThreadViolationExecutor.get();
    if (listener != null && executor != null) {
        try {
            executor.execute(() -> {
                // Lift violated policy to prevent infinite recursion.
                ThreadPolicy oldPolicy = StrictMode.allowThreadViolations();
                try {
                    listener.onThreadViolation(violation);
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            });
        } catch (RejectedExecutionException e) {
            Log.e(TAG, ""ThreadPolicy penaltyCallback failed"", e);
        }
    }
}",1,"// hence the policy being passed around.
","// hence the policy being passed around.
",-1,,,-1,-1,-1,-1,-1,-1,,,,
194,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getTraversalAfter()>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getTraversalAfter()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getTraversalAfter()>,0,"{
    enforceSealed();
    return getNodeForAccessibilityId(mTraversalAfter);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mTraversalAfter);
}",1,"/**
 * Gets the node after which this one is visited in accessibility traversal.
 * A screen-reader must visit the content of the other node before the content
 * of this one.
 *
 * @return The succeeding node if such or <code>null</code>.
 *
 * @see #setTraversalAfter(android.view.View)
 * @see #setTraversalAfter(android.view.View, int)
 */
","/**
 * Gets the node after which this one is visited in accessibility traversal.
 * A screen-reader must visit the content of the other node before the content
 * of this one.
 *
 * @return The succeeding node if such or <code>null</code>.
 *
 * @see #setTraversalAfter(android.view.View)
 * @see #setTraversalAfter(android.view.View, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getNodeForAccessibilityId has changed by taking additional parameters in the late implementation (mConnectionId, mWindowId), so the code change type is 5.","Despite the change in the dependent method's parameters, the early and late implementations of getTraversalAfter() both return the resultant AccessibilityNodeInfo object from getNodeForAccessibilityId method without any other changes that affect the behavior from the perspective of getTraversalAfter(). This implies that the returned type and the value are expected to remain consistent assuming the getNodeForAccessibilityId is correctly handling the additional parameters internally. Therefore, there is no Compatibility Issue; the CI type is 0."
197,"<android.bluetooth.BluetoothHidDevice: boolean sendReport(BluetoothDevice,int,byte[])>",28,29,"<android.bluetooth.BluetoothHidDevice: boolean sendReport(BluetoothDevice,int,byte[])>","<android.bluetooth.BluetoothHidDevice: boolean sendReport(BluetoothDevice,int,byte[])>",0,"{
    boolean result = false;
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            result = service.sendReport(device, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.sendReport(device, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Sends report to remote host using interrupt channel.
 *
 * @param id Report Id, as defined in descriptor. Can be 0 in case Report Id are not defined in
 * descriptor.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends report to remote host using interrupt channel.
 *
 * @param id Report Id, as defined in descriptor. Can be 0 in case Report Id are not defined in
 * descriptor.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement for acquiring the service instance has been updated from directly accessing the member variable `mService` to calling `getService()`. As both are intended to return an instance of `IBluetoothHidDevice`, this is classified as an 'Other statement changed' (4).","There is no Compatibility Issue. The change doesn't affect the behavior of `sendReport()` method; it simply modifies how the service instance is retrieved. Since the contract of `sendReport()` remains the same, and it's not clear that `getService()` method's behavior has changed between the versions, we assume it will either return a valid service or null as the previous implementation. Thus, no new return types or exceptions are introduced."
199,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,28,29,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,0,"{
    return ((locale != null && !locale.equals(Locale.ROOT) && ULocale.forLocale(locale).isRightToLeft()) || // If forcing into RTL layout mode, return RTL as default
    SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false)) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}","{
    return ((locale != null && !locale.equals(Locale.ROOT) && ULocale.forLocale(locale).isRightToLeft()) || // If forcing into RTL layout mode, return RTL as default
    DisplayProperties.debug_force_rtl().orElse(false)) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
","/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API SystemProperties.getBoolean() is replaced by DisplayProperties.debug_force_rtl().orElse(false), so code change type is 4,5.","The change from SystemProperties.getBoolean() to DisplayProperties.debug_force_rtl().orElse(false) could lead to a different return value as it relies on a different underlying system property or mechanism to determine the layout direction. Therefore, this represents a potential Compatibility Issue due to potentially different return values, making CI type 1."
200,<android.app.NotificationManager: NotificationChannel getNotificationChannel(String)>,28,29,<android.app.NotificationManager: NotificationChannel getNotificationChannel(String)>,<android.app.NotificationManager: NotificationChannel getNotificationChannel(String)>,0,"{
    INotificationManager service = getService();
    try {
        return service.getNotificationChannel(mContext.getPackageName(), channelId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INotificationManager service = getService();
    try {
        return service.getNotificationChannel(mContext.getOpPackageName(), mContext.getUserId(), mContext.getPackageName(), channelId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the notification channel settings for a given channel id.
 *
 * The channel must belong to your package, or it will not be returned.
 */
","/**
 * Returns the notification channel settings for a given channel id.
 *
 * <p>The channel must belong to your package, or to a package you are an approved notification
 * delegate for (see {@link #canNotifyAsPackage(String)}), or it will not be returned. To query
 * a channel as a notification delegate, call this method from a context created for that
 * package (see {@link Context#createPackageContext(String, int)}).</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `service.getNotificationChannel` arguments have changed to include additional parameters `mContext.getOpPackageName(), mContext.getUserId()`, indicating the dependent API `getNotificationChannel` changed, so the code change type is 5.","There is no Compatibility Issue, as the modification is related to the internal details of how the `service.getNotificationChannel` method is called. There is no change in the behavior regarding return values or exception handling that would affect the clients using the `getNotificationChannel(String channelId)` API; thus the CI type is 0."
201,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",28,29,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mPackageName, url, args, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.refresh(url, args, cancellationSignal);
    } catch (RemoteException e) {
        return false;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mPackageName, url, args, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * This allows clients to request an explicit refresh of content identified by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong indication (such as a user
 * initiated pull to refresh gesture) that the content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param args Additional options from the client. The definitions of these are specific to the
 * content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
 * none. For example, if you called refresh on a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether the client has
 * canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
","/**
 * This allows clients to request an explicit refresh of content identified by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong indication (such as a user
 * initiated pull to refresh gesture) that the content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param args Additional options from the client. The definitions of these are specific to the
 * content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
 * none. For example, if you called refresh on a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether the client has
 * canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version includes a new try-catch block that attempts to delegate the refresh operation to a wrapped ContentResolver instance (if available) using `mWrapped.refresh(url, args, cancellationSignal)`. Additionally, there's a new control dependency introduced because of this try-catch block. Therefore, the code change type is 3 for the control dependency change and 4 for the other statement changed.","The new try-catch block checks if `mWrapped` is not null and then attempts to call `refresh()` on it. If successful, it returns whatever `mWrapped.refresh()` returns."
202,<android.os.StrictMode.AndroidBlockGuardPolicy: String toString()>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: String toString()>,<android.os.StrictMode.AndroidBlockGuardPolicy: String toString()>,0,"{
    return ""AndroidBlockGuardPolicy; mPolicyMask="" + mPolicyMask;
}","{
    return ""AndroidBlockGuardPolicy; mPolicyMask="" + mThreadPolicyMask;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The variable being appended to the return string has changed from mPolicyMask to mThreadPolicyMask, so the code change type is 4.","As the return statement now includes a different variable, the output of the toString() method could potentially be different, which means the CI type is 1."
203,<android.view.KeyEvent: String toString()>,28,29,<android.view.KeyEvent: String toString()>,<android.view.KeyEvent: String toString()>,0,"{
    StringBuilder msg = new StringBuilder();
    msg.append(""KeyEvent { action="").append(actionToString(mAction));
    msg.append("", keyCode="").append(keyCodeToString(mKeyCode));
    msg.append("", scanCode="").append(mScanCode);
    if (mCharacters != null) {
        msg.append("", characters=\"""").append(mCharacters).append(""\"""");
    }
    msg.append("", metaState="").append(metaStateToString(mMetaState));
    msg.append("", flags=0x"").append(Integer.toHexString(mFlags));
    msg.append("", repeatCount="").append(mRepeatCount);
    msg.append("", eventTime="").append(mEventTime);
    msg.append("", downTime="").append(mDownTime);
    msg.append("", deviceId="").append(mDeviceId);
    msg.append("", source=0x"").append(Integer.toHexString(mSource));
    msg.append("" }"");
    return msg.toString();
}","{
    StringBuilder msg = new StringBuilder();
    msg.append(""KeyEvent { action="").append(actionToString(mAction));
    msg.append("", keyCode="").append(keyCodeToString(mKeyCode));
    msg.append("", scanCode="").append(mScanCode);
    if (mCharacters != null) {
        msg.append("", characters=\"""").append(mCharacters).append(""\"""");
    }
    msg.append("", metaState="").append(metaStateToString(mMetaState));
    msg.append("", flags=0x"").append(Integer.toHexString(mFlags));
    msg.append("", repeatCount="").append(mRepeatCount);
    msg.append("", eventTime="").append(mEventTime);
    msg.append("", downTime="").append(mDownTime);
    msg.append("", deviceId="").append(mDeviceId);
    msg.append("", source=0x"").append(Integer.toHexString(mSource));
    msg.append("", displayId="").append(mDisplayId);
    msg.append("" }"");
    return msg.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional piece of information, ""displayId"", is appended to the output of the `toString()` method, which means a new statement has been added to the method. The code change types are 1,4 because a new information is incorporated into the return value and there's a change in the body of the method that is not a control structure or an exception handling statement.","The addition of the ""displayId"" information to the output string represents a change in the return value, leading to a different return value between the two versions. The CI type is 1, due to the potential different return values."
204,<android.inputmethodservice.InputMethodService: boolean switchToPreviousInputMethod()>,28,29,<android.inputmethodservice.InputMethodService: boolean switchToPreviousInputMethod()>,<android.inputmethodservice.InputMethodService: boolean switchToPreviousInputMethod()>,0,"{
    return mImm.switchToPreviousInputMethodInternal(mToken);
}","{
    return mPrivOps.switchToPreviousInputMethod();
}",1,"/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
","/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method used within the return statement has changed from mImm.switchToPreviousInputMethodInternal(mToken) to mPrivOps.switchToPreviousInputMethod(), which indicates that a dependent API change (5) has occurred.","Since the invoked method within the return statement has changed, there is a potential that different behavior or different return value may occur due to the change. Therefore, there is a Compatibility Issue caused by potential different return values or types, which falls under type 1."
205,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitCustomSlowCalls()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitCustomSlowCalls()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitCustomSlowCalls()>,0,"{
    return disable(DETECT_CUSTOM);
}","{
    return disable(DETECT_THREAD_CUSTOM);
}",1,"/**
 * Disable detection of slow calls.
 */
","/**
 * Disable detection of slow calls.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed where the parameter to the disable() method is changed from DETECT_CUSTOM to DETECT_THREAD_CUSTOM, indicating that the dependency on another API has been altered. This accounts for a change in 'disable' method dependency (5). Additionally, the implementation detail changed indicating there's a 'Return statement changed' (1).","Since the return statement's behavior is altered due to the new parameter passed to the disable() method, this could cause the method to return a different result than before and hence it is considered a potential 'Compatibility Issue caused by potential different return values or types' (1)."
206,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,28,29,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(String)>,0,"{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}","{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, name, true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider if it determines that there is no other reason for
 * keeping it active.
 * @param name specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * with the authority of name or null if there isn't one.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is the addition of the `name` parameter in the constructor of `ContentProviderClient`. This qualifies as 'Other statement changed' since it is neither a control dependency change, return statement change, nor an exception handling statement change. It's also a 'Dependent API changed' since the constructor of `ContentProviderClient` seems to have changed between versions. The change type is 4,5.","There's no Compatibility Issue in this case; although the constructor for `ContentProviderClient` now includes an additional parameter (`name`), the `return` statement essentially returns the same type of object and the method's behavior as well as its return type in the signature remain unchanged. The method's contract and the return type are consistent with the previous version, fulfilling the nullability expectations, as indicated by the `@Nullable` annotation in both versions. The type is 0."
207,"<android.bluetooth.BluetoothHealth: boolean disconnectChannel(BluetoothDevice,BluetoothHealthAppConfiguration,int)>",28,29,"<android.bluetooth.BluetoothHealth: boolean disconnectChannel(BluetoothDevice,BluetoothHealthAppConfiguration,int)>","<android.bluetooth.BluetoothHealth: boolean disconnectChannel(BluetoothDevice,BluetoothHealthAppConfiguration,int)>",0,"{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.disconnectChannel(device, config, channelId);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}","{
    Log.e(TAG, ""disconnectChannel(): BluetoothHealth is deprecated"");
    return false;
}",1,"/**
 * Disconnect a connected health channel.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using {@link
 * #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @param channelId The channel id associated with the channel
 * @return If true, the callback associated with the application config will be called.
 */
","/**
 * Disconnect a connected health channel.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using {@link
 * #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @param channelId The channel id associated with the channel
 * @return If true, the callback associated with the application config will be called.
 *
 * @deprecated Health Device Profile (HDP) and MCAP protocol are no longer used. New
 * apps should use Bluetooth Low Energy based solutions such as {@link BluetoothGatt},
 * {@link BluetoothAdapter#listenUsingL2capChannel()(int)}, or
 * {@link BluetoothDevice#createL2capChannel(int)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,1,1,"The entire method body has been replaced by a simple log message followed by returning false. Therefore, the change type is 1 as the return statement changed.","The change directly impacts the behavior of the API by always logging a ""deprecated"" message and returning false, regardless of logic that was previously in place. This could lead to a different return type/value, giving the CI type of 1."
208,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,28,29,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,0,"{
    final long now = mClockFunction.get();
    if (now - mLastColorInvalidation < NOTIFY_COLORS_RATE_LIMIT_MS) {
        Log.w(TAG, ""This call has been deferred. You should only call "" + ""notifyColorsChanged() once every "" + (NOTIFY_COLORS_RATE_LIMIT_MS / 1000f) + "" seconds."");
        if (!mHandler.hasCallbacks(mNotifyColorsChanged)) {
            mHandler.postDelayed(mNotifyColorsChanged, NOTIFY_COLORS_RATE_LIMIT_MS);
        }
        return;
    }
    mLastColorInvalidation = now;
    mHandler.removeCallbacks(mNotifyColorsChanged);
    try {
        final WallpaperColors newColors = onComputeColors();
        if (mConnection != null) {
            mConnection.onWallpaperColorsChanged(newColors);
        } else {
            Log.w(TAG, ""Can't notify system because wallpaper connection "" + ""was not established."");
        }
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't notify system because wallpaper connection was lost."", e);
    }
}","{
    final long now = mClockFunction.get();
    if (now - mLastColorInvalidation < NOTIFY_COLORS_RATE_LIMIT_MS) {
        Log.w(TAG, ""This call has been deferred. You should only call "" + ""notifyColorsChanged() once every "" + (NOTIFY_COLORS_RATE_LIMIT_MS / 1000f) + "" seconds."");
        if (!mHandler.hasCallbacks(mNotifyColorsChanged)) {
            mHandler.postDelayed(mNotifyColorsChanged, NOTIFY_COLORS_RATE_LIMIT_MS);
        }
        return;
    }
    mLastColorInvalidation = now;
    mHandler.removeCallbacks(mNotifyColorsChanged);
    try {
        final WallpaperColors newColors = onComputeColors();
        if (mConnection != null) {
            mConnection.onWallpaperColorsChanged(newColors, mDisplay.getDisplayId());
        } else {
            Log.w(TAG, ""Can't notify system because wallpaper connection "" + ""was not established."");
        }
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't notify system because wallpaper connection was lost."", e);
    }
}",1,"/**
 * Notifies the engine that wallpaper colors changed significantly.
 * This will trigger a {@link #onComputeColors()} call.
 */
","/**
 * Notifies the engine that wallpaper colors changed significantly.
 * This will trigger a {@link #onComputeColors()} call.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method mConnection.onWallpaperColorsChanged() now takes a second parameter, mDisplay.getDisplayId(). This indicates the signature of the method called in the implementation has changed, which categorizes as a change type 5. Additionally, this is a change not related to return, exception handling, or control dependency which makes it type 4 as well.","Considering the method now additionally passes the display identifier, this can result in different behavior of the notifyColorsChanged method, potentially affecting the outcome of the API. The method could now consider the display ID when reporting the wallpaper colors, which would not have occurred in the previous version. Therefore, the Compatibility Issue type is 1."
209,<android.view.textservice.SpellCheckerSession: void close()>,28,29,<android.view.textservice.SpellCheckerSession: void close()>,<android.view.textservice.SpellCheckerSession: void close()>,0,"{
    mGuard.close();
    try {
        mSpellCheckerSessionListenerImpl.close();
        mTextServicesManager.finishSpellCheckerService(mSpellCheckerSessionListenerImpl);
    } catch (RemoteException e) {
    // do nothing
    }
}","{
    mGuard.close();
    mSpellCheckerSessionListenerImpl.close();
    mTextServicesManager.finishSpellCheckerService(mSpellCheckerSessionListenerImpl);
}",1,"/**
 * Finish this session and allow TextServicesManagerService to disconnect the bound spell
 * checker.
 */
","/**
 * Finish this session and allow TextServicesManagerService to disconnect the bound spell
 * checker.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The try-catch block for RemoteException has been removed, so the code change type is 2.","With the removal of the try-catch block, if a RemoteException occurs, it will no longer be caught and suppressed. This means the late version of the API could throw an unchecked exception that was previously handled, thus the CI type is 2."
211,<android.net.ConnectivityManager: void releaseNetworkRequest(PendingIntent)>,28,29,<android.net.ConnectivityManager: void releaseNetworkRequest(PendingIntent)>,<android.net.ConnectivityManager: void releaseNetworkRequest(PendingIntent)>,0,"{
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Removes a request made via {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)}
 * <p>
 * This method has the same behavior as
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)} with respect to
 * releasing network resources and disconnecting.
 *
 * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the
 * PendingIntent passed to
 * {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)} with the
 * corresponding NetworkRequest you'd like to remove. Cannot be null.
 */
","/**
 * Removes a request made via {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)}
 * <p>
 * This method has the same behavior as
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)} with respect to
 * releasing network resources and disconnecting.
 *
 * @param operation A PendingIntent equal (as defined by {@link Intent#filterEquals}) to the
 * PendingIntent passed to
 * {@link #requestNetwork(NetworkRequest, android.app.PendingIntent)} with the
 * corresponding NetworkRequest you'd like to remove. Cannot be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,A new method call to printStackTrace() was added to the beginning of the method body. This change type is 4 (Other statement changed).,"The newly added printStackTrace() call is for debugging purposes and does not affect the method's behavior, return value, or exception handling. There is no Compatibility Issue since it has no impact on the method's execution flow regarding the returning value or exceptions."
212,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,28,29,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,0,"{
    if (mEnteringNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, activity.getWindow(), activity.mEnterTransitionListener, mEnteringNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                OneShotPreDrawListener.add(decor, () -> {
                    if (mReturnExitCoordinator != null) {
                        mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}","{
    ArrayList<String> pendingExitNames = getPendingExitNames();
    if (pendingExitNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, activity.getWindow(), activity.mEnterTransitionListener, pendingExitNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                OneShotPreDrawListener.add(decor, () -> {
                    if (mReturnExitCoordinator != null) {
                        mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The control dependency change is in the first 'if' statement where 'mEnteringNames' is replaced with 'pendingExitNames' which is retrieved from 'getPendingExitNames()' method. Additionally, 'mEnteringNames' parameter in the 'ExitTransitionCoordinator' constructor is replaced with 'pendingExitNames'. There is no direct change to return or exception statements, so the code change type is 3 for control dependency and 5 for the dependent API change (change in the parameter list due to the introduction of the new 'pendingExitNames').","The Condition 'mEnteringNames == null' is merely renamed to 'pendingExitNames == null' where 'pendingExitNames' is a local variable assigned from getPendingExitNames(). Although it introduces a dependency on a new method, if the content of 'pendingExitNames' is conceptually similar to 'mEnteringNames', then these changes should not affect the behavior of the method. The CI is assumed not to occur because the logical flow remains the same, just with a different source of names used in the comparison and passed to the constructor. Hence, no CI is detected."
213,<android.widget.ProgressBar: Mode getSecondaryProgressTintMode()>,28,29,<android.widget.ProgressBar: Mode getSecondaryProgressTintMode()>,<android.widget.ProgressBar: Mode getSecondaryProgressTintMode()>,0,"{
    return mProgressTintInfo != null ? mProgressTintInfo.mSecondaryProgressTintMode : null;
}","{
    BlendMode mode = getSecondaryProgressTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the secondary
 * progress drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the secondary
 * progress drawable
 * @attr ref android.R.styleable#ProgressBar_secondaryProgressTintMode
 * @see #setSecondaryProgressTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the secondary
 * progress drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the secondary
 * progress drawable
 * @attr ref android.R.styleable#ProgressBar_secondaryProgressTintMode
 * @see #setSecondaryProgressTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed with the introduction of a new intermediary method getSecondaryProgressTintBlendMode() and utilization of a method BlendMode.blendModeToPorterDuffMode(mode) to obtain the result. This signifies that both the return statement and dependent APIs have undergone changes, thus the code change types are 1,5.","Since the implementation of how the mode is obtained and converted has changed, this can potentially lead to a difference in the value returned by the method. Therefore, there is a Compatibility Issue caused by potential different return values, and the CI type is 1."
214,"<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,String,String,String)>",28,29,"<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,String,String,String)>","<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,String,String,String)>",0,"{
    // Check if file exists with a FileInputStream
    FileInputStream stream = new FileInputStream(imagePath);
    try {
        Bitmap bm = BitmapFactory.decodeFile(imagePath);
        String ret = insertImage(cr, bm, name, description);
        bm.recycle();
        return ret;
    } finally {
        try {
            stream.close();
        } catch (IOException e) {
        }
    }
}","{
    final File file = new File(imagePath);
    final String mimeType = MediaFile.getMimeTypeForFile(imagePath);
    if (TextUtils.isEmpty(name))
        name = ""Image"";
    final PendingParams params = new PendingParams(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, name, mimeType);
    final Context context = AppGlobals.getInitialApplication();
    final Uri pendingUri = createPending(context, params);
    try (PendingSession session = openPending(context, pendingUri)) {
        try (InputStream in = new FileInputStream(file);
            OutputStream out = session.openOutputStream()) {
            FileUtils.copy(in, out);
        }
        return session.publish().toString();
    } catch (Exception e) {
        Log.w(TAG, ""Failed to insert image"", e);
        context.getContentResolver().delete(pendingUri, null, null);
        return null;
    }
}",1,"/**
 * Insert an image and create a thumbnail for it.
 *
 * @param cr The content resolver to use
 * @param imagePath The path to the image to insert
 * @param name The name of the image
 * @param description The description of the image
 * @return The URL to the newly created image
 * @throws FileNotFoundException
 */
","/**
 * Insert an image and create a thumbnail for it.
 *
 * @param cr The content resolver to use
 * @param imagePath The path to the image to insert
 * @param name The name of the image
 * @param description The description of the image
 * @return The URL to the newly created image
 * @deprecated inserting of images should be performed using
 * {@link MediaColumns#IS_PENDING}, which offers richer
 * control over lifecycle.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The late implementation replaces the entire body of code, including how the image is inserted and how streams are managed. There are new variables and objects introduced, and the exception handling has changed. The code change type involves return statement changed (1), exception handling statement changed (2), other statements changed (4), and dependent API changed (5), since `MediaFile.getMimeTypeForFile(imagePath)`, `createPending(context, params)`, and `openPending(context, pendingUri)` indicate a change in the dependent APIs. Additionally, control flow has changed due to the introduction of try-with-resources, which manages `InputStream` and `OutputStream`.","Because the whole implementation has changed, it's very likely that the behavior can change in numerous ways, including the conditions under which exceptions are thrown and the value that is returned. There may be scenarios where the early version would succeed but the late version could fail (and vice versa). Additionally, the early version always recycles the `Bitmap` and may return a non-null string, while the late version may return null in the case of exceptions. Hence, there's a potential Compatibility Issue caused by both different return values (1) and different exception handlings (2). Additionally, the removal of the `recycle()` method call does not directly cause a compatibility issue because it does not affect the return value or the exceptions thrown; it affects the memory management, which is not part of the compatibility issue as per our definitions. The fact that the method is also marked as deprecated in the late version points out that users are discouraged from using it, which can imply future compatibility concerns but is not a direct cause of the compatibility issue in terms of behavior changes between these two versions."
215,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,28,29,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, message.arg2 != 0);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors());
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.mOutsets.set((Rect) message.obj);
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors(), mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
216,<android.view.autofill.AutofillManager: String getDefaultFieldClassificationAlgorithm()>,28,29,<android.view.autofill.AutofillManager: String getDefaultFieldClassificationAlgorithm()>,<android.view.autofill.AutofillManager: String getDefaultFieldClassificationAlgorithm()>,0,"{
    try {
        return mService.getDefaultFieldClassificationAlgorithm();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getDefaultFieldClassificationAlgorithm(receiver);
        return receiver.getStringResult();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}",1,"/**
 * Gets the name of the default algorithm used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>The default algorithm is used when the algorithm on {@link UserData} is invalid or not
 * set.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
","/**
 * Gets the name of the default algorithm used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>The default algorithm is used when the algorithm on {@link UserData} is invalid or not
 * set.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The way the default field classification algorithm is retrieved has changed. The early version directly calls mService.getDefaultFieldClassificationAlgorithm(), while the late version uses a SyncResultReceiver to get the result. A new statement to create SyncResultReceiver is introduced, and the method call has changed from a direct method call to one that involves a receiver with a timeout. Therefore, the code change type involves 4 (Other statement changed) due to the introduction of new variable instantiation and change in method usage. Furthermore, the dependent API has changed; the late version invokes a different overload of getDefaultFieldClassificationAlgorithm(receiver) instead of the no-arg method, which contributes to change type 5 (Dependent API changed).","The change in how the result is obtained may lead to a different return value. This is particularly because the response is now conditional on the timeout via SyncResultReceiver, which could potentially introduce a timing-related issue that was not present before. In case of a timeout or interruption, it could behave differently, hence, CI type is 1 (Compatibility Issue caused by potential different return values or types)."
217,<android.app.AutomaticZenRule: String toString()>,28,29,<android.app.AutomaticZenRule: String toString()>,<android.app.AutomaticZenRule: String toString()>,0,"{
    return new StringBuilder(AutomaticZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",name="").append(name).append("",interruptionFilter="").append(interruptionFilter).append("",conditionId="").append(conditionId).append("",owner="").append(owner).append("",creationTime="").append(creationTime).append(']').toString();
}","{
    return new StringBuilder(AutomaticZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",name="").append(name).append("",interruptionFilter="").append(interruptionFilter).append("",conditionId="").append(conditionId).append("",owner="").append(owner).append("",configActivity="").append(configurationActivity).append("",creationTime="").append(creationTime).append("",mZenPolicy="").append(mZenPolicy).append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the API has additional StringBuilder append operations for ""configActivity"" and ""mZenPolicy"". This is a change in other statements, as well as a change in the return statement because it alters the content of the string being returned. The code change type is 1,4.",The addition of new fields to the string representation of the object will cause the API to return a different value. This qualifies as a potential Compatibility Issue of type 1 due to different return values.
218,<android.widget.Switch: Mode getThumbTintMode()>,28,29,<android.widget.Switch: Mode getThumbTintMode()>,<android.widget.Switch: Mode getThumbTintMode()>,0,"{
    return mThumbTintMode;
}","{
    BlendMode mode = getThumbTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
","/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The late version of the method invokes a new dependent API `getThumbTintBlendMode()` and converts its result with `BlendMode.blendModeToPorterDuffMode(mode)` instead of directly returning a member variable `mThumbTintMode`. This is a change both in return statement and dependent API, so the code change type is 1,5.","The method potentially returns a different value, as it now involves a conversion from a BlendMode to a PorterDuff mode, which could return a different result than what was previously stored in `mThumbTintMode`. Therefore, this constitutes a CI caused by potential different return values or types, so the CI type is 1."
219,<android.app.Activity: void setImmersive(boolean)>,28,29,<android.app.Activity: void setImmersive(boolean)>,<android.app.Activity: void setImmersive(boolean)>,0,"{
    try {
        ActivityManager.getService().setImmersive(mToken, i);
    } catch (RemoteException e) {
    // pass
    }
}","{
    try {
        ActivityTaskManager.getService().setImmersive(mToken, i);
    } catch (RemoteException e) {
    // pass
    }
}",1,"/**
 * Adjust the current immersive mode setting.
 *
 * Note that changing this value will have no effect on the activity's
 * {@link android.content.pm.ActivityInfo} structure; that is, if
 * <code>android:immersive</code> is set to <code>true</code>
 * in the application's manifest entry for this activity, the {@link
 * android.content.pm.ActivityInfo#flags ActivityInfo.flags} member will
 * always have its {@link android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 * FLAG_IMMERSIVE} bit set.
 *
 * @see #isImmersive()
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
","/**
 * Adjust the current immersive mode setting.
 *
 * Note that changing this value will have no effect on the activity's
 * {@link android.content.pm.ActivityInfo} structure; that is, if
 * <code>android:immersive</code> is set to <code>true</code>
 * in the application's manifest entry for this activity, the {@link
 * android.content.pm.ActivityInfo#flags ActivityInfo.flags} member will
 * always have its {@link android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 * FLAG_IMMERSIVE} bit set.
 *
 * @see #isImmersive()
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the try block was changed from ActivityManager.getService().setImmersive(mToken, i) to ActivityTaskManager.getService().setImmersive(mToken, i), which indicates that there is a change in the dependent API. However, this is not a return or exception handling statement change. Therefore, the correct classifications are 4 for other statement changed and 5 for dependent API changed.","There is no compatibility issue since the method's behavior in terms of returning a value or throwing an exception has not been altered. Although a dependent API has changed, it does not necessarily result in a different returned value or a newly thrown exception because the calling pattern is the same and the method signature remains unchanged. Hence, there is no compatibility issue."
220,<android.app.VoiceInteractor: boolean[] supportsCommands(String[])>,28,29,<android.app.VoiceInteractor: boolean[] supportsCommands(String[])>,<android.app.VoiceInteractor: boolean[] supportsCommands(String[])>,0,"{
    try {
        boolean[] res = mInteractor.supportsCommands(mContext.getOpPackageName(), commands);
        if (DEBUG)
            Log.d(TAG, ""supportsCommands: cmds="" + commands + "" res="" + res);
        return res;
    } catch (RemoteException e) {
        throw new RuntimeException(""Voice interactor has died"", e);
    }
}","{
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return new boolean[commands.length];
    }
    try {
        boolean[] res = mInteractor.supportsCommands(mContext.getOpPackageName(), commands);
        if (DEBUG)
            Log.d(TAG, ""supportsCommands: cmds="" + commands + "" res="" + res);
        return res;
    } catch (RemoteException e) {
        throw new RuntimeException(""Voice interactor has died"", e);
    }
}",1,"/**
 * Queries the supported commands available from the VoiceInteractionService.
 * The command is a string that describes the generic operation to be performed.
 * An example might be ""org.example.commands.PICK_DATE"" to ask the user to pick
 * a date.  (Note: This is not an actual working example.)
 *
 * @param commands The array of commands to query for support.
 * @return Array of booleans indicating whether each command is supported or not.
 */
","/**
 * Queries the supported commands available from the VoiceInteractionService.
 * The command is a string that describes the generic operation to be performed.
 * An example might be ""org.example.commands.PICK_DATE"" to ask the user to pick
 * a date.  (Note: This is not an actual working example.)
 *
 * @param commands The array of commands to query for support.
 * @return Array of booleans indicating whether each command is supported or not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The code change involves the introduction of an 'if' control structure which returns a new value, a boolean array initialized with default values. This change is a new control dependency change (3) and a return statement change (1).","The new if condition at the beginning of the method checks if the voice interactor is destroyed and in such a case, it returns a new boolean array filled with default values instead of the actual results. This introduces a possibility of returning different values based on the new check, leading to a CI of type 1."
221,"<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>",28,29,"<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>","<android.app.SharedElementCallback: View onCreateSnapshotView(Context,Parcelable)>",0,"{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            bitmap = Bitmap.createHardwareBitmap(buffer);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}","{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            ColorSpace colorSpace = null;
            int colorSpaceId = bundle.getInt(BUNDLE_SNAPSHOT_COLOR_SPACE, 0);
            if (colorSpaceId >= 0 && colorSpaceId < ColorSpace.Named.values().length) {
                colorSpace = ColorSpace.get(ColorSpace.Named.values()[colorSpaceId]);
            }
            bitmap = Bitmap.wrapHardwareBuffer(HardwareBuffer.createFromGraphicBuffer(buffer), colorSpace);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}",1,"/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
","/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There are changes in the method implementation, specifically within the condition `if (bitmap == null)`. Code has been added to handle the retrieval of a ColorSpace ID from the Bundle and to create a Bitmap using Bitmap.wrapHardwareBuffer, with the addition of this retrieved ColorSpace. These changes include various control dependency changes (added `if` conditional to check the ColorSpace ID), other statement changes (assignments and method calls), and dependent API changed (use of Bitmap.wrapHardwareBuffer and ColorSpace.get are the newly introduced dependent APIs). This combination makes the change types 1,3,4,5.","The inclusion of the new conditional checks and creation of the Bitmap with a potentially different ColorSpace could result in a different Bitmap being set on the ImageView, and consequently a different View being returned. This constitutes a different return value, making the CI type 1."
222,<android.net.NetworkCapabilities: boolean equals(Object)>,28,29,<android.net.NetworkCapabilities: boolean equals(Object)>,<android.net.NetworkCapabilities: boolean equals(Object)>,0,"{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsUids(that) && equalsSSID(that));
}","{
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsTransportInfo(that) && equalsUids(that) && equalsSSID(that));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent method used within the equals method has changed from equalsSpecifier(that) to equalsTransportInfo(that), so there is a change in Other statement and Dependent API, which is a change type of 4,5.","As the implementation now relies on a different dependent method (equalsTransportInfo instead of equalsSpecifier), this could potentially lead to the method returning a different result when comparing NetworkCapabilities objects. Therefore, the CI type is 1."
223,<android.animation.AnimatorSet: void setCurrentPlayTime(long)>,28,29,<android.animation.AnimatorSet: void setCurrentPlayTime(long)>,<android.animation.AnimatorSet: void setCurrentPlayTime(long)>,0,"{
    if (mReversing && getTotalDuration() == DURATION_INFINITE) {
        // Should never get here
        throw new UnsupportedOperationException(""Error: Cannot seek in reverse in an infinite"" + "" AnimatorSet"");
    }
    if ((getTotalDuration() != DURATION_INFINITE && playTime > getTotalDuration() - mStartDelay) || playTime < 0) {
        throw new UnsupportedOperationException(""Error: Play time should always be in between"" + ""0 and duration."");
    }
    initAnimation();
    if (!isStarted()) {
        if (mReversing) {
            throw new UnsupportedOperationException(""Error: Something went wrong. mReversing"" + "" should not be set when AnimatorSet is not started."");
        }
        if (!mSeekState.isActive()) {
            findLatestEventIdForTime(0);
            // Set all the values to start values.
            initChildren();
            skipToStartValue(mReversing);
            mSeekState.setPlayTime(0, mReversing);
        }
        animateBasedOnPlayTime(playTime, 0, mReversing);
        mSeekState.setPlayTime(playTime, mReversing);
    } else {
        // If the animation is running, just set the seek time and wait until the next frame
        // (i.e. doAnimationFrame(...)) to advance the animation.
        mSeekState.setPlayTime(playTime, mReversing);
    }
}","{
    if (mReversing && getTotalDuration() == DURATION_INFINITE) {
        // Should never get here
        throw new UnsupportedOperationException(""Error: Cannot seek in reverse in an infinite"" + "" AnimatorSet"");
    }
    if ((getTotalDuration() != DURATION_INFINITE && playTime > getTotalDuration() - mStartDelay) || playTime < 0) {
        throw new UnsupportedOperationException(""Error: Play time should always be in between"" + ""0 and duration."");
    }
    initAnimation();
    if (!isStarted() || isPaused()) {
        if (mReversing) {
            throw new UnsupportedOperationException(""Error: Something went wrong. mReversing"" + "" should not be set when AnimatorSet is not started."");
        }
        if (!mSeekState.isActive()) {
            findLatestEventIdForTime(0);
            // Set all the values to start values.
            initChildren();
            mSeekState.setPlayTime(0, mReversing);
        }
        animateBasedOnPlayTime(playTime, 0, mReversing);
        mSeekState.setPlayTime(playTime, mReversing);
    } else {
        // If the animation is running, just set the seek time and wait until the next frame
        // (i.e. doAnimationFrame(...)) to advance the animation.
        mSeekState.setPlayTime(playTime, mReversing);
    }
}",1,"/**
 * Sets the position of the animation to the specified point in time. This time should
 * be between 0 and the total duration of the animation, including any repetition. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this time; it will simply set the time to this value and perform any appropriate
 * actions based on that time. If the animation is already running, then setCurrentPlayTime()
 * will set the current playing time to this value and continue playing from that point.
 *
 * @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
 * Unless the animation is reversing, the playtime is considered the time since
 * the end of the start delay of the AnimatorSet in a forward playing direction.
 */
","/**
 * Sets the position of the animation to the specified point in time. This time should
 * be between 0 and the total duration of the animation, including any repetition. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this time; it will simply set the time to this value and perform any appropriate
 * actions based on that time. If the animation is already running, then setCurrentPlayTime()
 * will set the current playing time to this value and continue playing from that point.
 *
 * @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
 * Unless the animation is reversing, the playtime is considered the time since
 * the end of the start delay of the AnimatorSet in a forward playing direction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition in the 'if' statement is updated to also check if the AnimatorSet is paused by adding ""|| isPaused()"" to the condition. This is a control dependency change.","The addition of the ""|| isPaused()"" condition can change the behavior of the API as it could now potentially return at different states (paused or not paused) compared to the early version. This constitutes a change in the return statement (even though not explicitly a return keyword change) since it affects the animation's play state, hence the CI type is 1."
224,<android.widget.Editor.SuggestionsPopupWindow: void initContentView()>,28,29,<android.widget.Editor.SuggestionsPopupWindow: void initContentView()>,<android.widget.Editor.SuggestionsPopupWindow: void initContentView()>,0,"{
    final LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mContentView = (ViewGroup) inflater.inflate(mTextView.mTextEditSuggestionContainerLayout, null);
    mContainerView = (LinearLayout) mContentView.findViewById(com.android.internal.R.id.suggestionWindowContainer);
    ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) mContainerView.getLayoutParams();
    mContainerMarginWidth = lp.leftMargin + lp.rightMargin;
    mContainerMarginTop = lp.topMargin;
    mClippingLimitLeft = lp.leftMargin;
    mClippingLimitRight = lp.rightMargin;
    mSuggestionListView = (ListView) mContentView.findViewById(com.android.internal.R.id.suggestionContainer);
    mSuggestionsAdapter = new SuggestionAdapter();
    mSuggestionListView.setAdapter(mSuggestionsAdapter);
    mSuggestionListView.setOnItemClickListener(this);
    // Inflate the suggestion items once and for all.
    mSuggestionInfos = new SuggestionInfo[MAX_NUMBER_SUGGESTIONS];
    for (int i = 0; i < mSuggestionInfos.length; i++) {
        mSuggestionInfos[i] = new SuggestionInfo();
    }
    mAddToDictionaryButton = (TextView) mContentView.findViewById(com.android.internal.R.id.addToDictionaryButton);
    mAddToDictionaryButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            final SuggestionSpan misspelledSpan = findEquivalentSuggestionSpan(mMisspelledSpanInfo);
            if (misspelledSpan == null) {
                // Span has been removed.
                return;
            }
            final Editable editable = (Editable) mTextView.getText();
            final int spanStart = editable.getSpanStart(misspelledSpan);
            final int spanEnd = editable.getSpanEnd(misspelledSpan);
            if (spanStart < 0 || spanEnd <= spanStart) {
                return;
            }
            final String originalText = TextUtils.substring(editable, spanStart, spanEnd);
            final Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
            intent.putExtra(USER_DICTIONARY_EXTRA_WORD, originalText);
            intent.putExtra(USER_DICTIONARY_EXTRA_LOCALE, mTextView.getTextServicesLocale().toString());
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            mTextView.getContext().startActivity(intent);
            // There is no way to know if the word was indeed added. Re-check.
            // TODO The ExtractEditText should remove the span in the original text instead
            editable.removeSpan(mMisspelledSpanInfo.mSuggestionSpan);
            Selection.setSelection(editable, spanEnd);
            updateSpellCheckSpans(spanStart, spanEnd, false);
            hideWithCleanUp();
        }
    });
    mDeleteButton = (TextView) mContentView.findViewById(com.android.internal.R.id.deleteButton);
    mDeleteButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            final Editable editable = (Editable) mTextView.getText();
            final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
            int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
            if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
                // text
                if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                    spanUnionEnd = spanUnionEnd + 1;
                }
                mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
            }
            hideWithCleanUp();
        }
    });
}","{
    final LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mContentView = (ViewGroup) inflater.inflate(mTextView.mTextEditSuggestionContainerLayout, null);
    mContainerView = (LinearLayout) mContentView.findViewById(com.android.internal.R.id.suggestionWindowContainer);
    ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) mContainerView.getLayoutParams();
    mContainerMarginWidth = lp.leftMargin + lp.rightMargin;
    mContainerMarginTop = lp.topMargin;
    mClippingLimitLeft = lp.leftMargin;
    mClippingLimitRight = lp.rightMargin;
    mSuggestionListView = (ListView) mContentView.findViewById(com.android.internal.R.id.suggestionContainer);
    mSuggestionsAdapter = new SuggestionAdapter();
    mSuggestionListView.setAdapter(mSuggestionsAdapter);
    mSuggestionListView.setOnItemClickListener(this);
    // Inflate the suggestion items once and for all.
    mSuggestionInfos = new SuggestionInfo[MAX_NUMBER_SUGGESTIONS];
    for (int i = 0; i < mSuggestionInfos.length; i++) {
        mSuggestionInfos[i] = new SuggestionInfo();
    }
    mAddToDictionaryButton = (TextView) mContentView.findViewById(com.android.internal.R.id.addToDictionaryButton);
    mAddToDictionaryButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            final SuggestionSpan misspelledSpan = findEquivalentSuggestionSpan(mMisspelledSpanInfo);
            if (misspelledSpan == null) {
                // Span has been removed.
                return;
            }
            final Editable editable = (Editable) mTextView.getText();
            final int spanStart = editable.getSpanStart(misspelledSpan);
            final int spanEnd = editable.getSpanEnd(misspelledSpan);
            if (spanStart < 0 || spanEnd <= spanStart) {
                return;
            }
            final String originalText = TextUtils.substring(editable, spanStart, spanEnd);
            final Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
            intent.putExtra(USER_DICTIONARY_EXTRA_WORD, originalText);
            intent.putExtra(USER_DICTIONARY_EXTRA_LOCALE, mTextView.getTextServicesLocale().toString());
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            mTextView.startActivityAsTextOperationUserIfNecessary(intent);
            // There is no way to know if the word was indeed added. Re-check.
            // TODO The ExtractEditText should remove the span in the original text instead
            editable.removeSpan(mMisspelledSpanInfo.mSuggestionSpan);
            Selection.setSelection(editable, spanEnd);
            updateSpellCheckSpans(spanStart, spanEnd, false);
            hideWithCleanUp();
        }
    });
    mDeleteButton = (TextView) mContentView.findViewById(com.android.internal.R.id.deleteButton);
    mDeleteButton.setOnClickListener(new View.OnClickListener() {

        public void onClick(View v) {
            final Editable editable = (Editable) mTextView.getText();
            final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
            int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
            if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
                // text
                if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                    spanUnionEnd = spanUnionEnd + 1;
                }
                mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
            }
            hideWithCleanUp();
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
225,<android.provider.MediaStore.Images.Media: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Images.Media: Uri getContentUri(String)>,<android.provider.MediaStore.Images.Media: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/images/media"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""images"").appendPath(""media"").build();
}",1,"/**
 * Get the content:// style URI for the image media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the image media table on the given volume
 */
","/**
 * Get the content:// style URI for the image media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the image media table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The content of the return statement is changed but the logic to construct the Uri remains the same. The return type is not altered, but the method used to construct the Uri is different, which includes using method chaining (`buildUpon().appendPath().appendPath().appendPath().build()`) instead of string concatenation. This qualifies as Other statement changed (4).","Although the logic for constructing the Uri in the early version has been refactored in the late version, the result should theoretically be the same Uri object representing the same underlying contents. However, since the way the Uri is generated has changed, and these changes might depend on specific implementations of `Uri.parse()` and `AUTHORITY_URI.buildUpon()`, there is a potential compatibility issue where the API could return a different value (for instance, if `Uri.parse()` and `AUTHORITY_URI.buildUpon()` handle edge cases differently or if there's a difference in the encoding), thus the CI type is 1."
226,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,28,29,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,<android.service.notification.ZenModeConfig.ZenRule: boolean equals(Object)>,0,"{
    if (!(o instanceof ZenRule))
        return false;
    if (o == this)
        return true;
    final ZenRule other = (ZenRule) o;
    return other.enabled == enabled && other.snoozing == snoozing && Objects.equals(other.name, name) && other.zenMode == zenMode && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.condition, condition) && Objects.equals(other.component, component) && Objects.equals(other.id, id) && other.creationTime == creationTime && Objects.equals(other.enabler, enabler);
}","{
    if (!(o instanceof ZenRule))
        return false;
    if (o == this)
        return true;
    final ZenRule other = (ZenRule) o;
    return other.enabled == enabled && other.snoozing == snoozing && Objects.equals(other.name, name) && other.zenMode == zenMode && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.condition, condition) && Objects.equals(other.component, component) && Objects.equals(other.configurationActivity, configurationActivity) && Objects.equals(other.id, id) && Objects.equals(other.enabler, enabler) && Objects.equals(other.zenPolicy, zenPolicy) && Objects.equals(other.pkg, pkg) && other.modified == modified;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation of the equals method has added more comparison checks for `other.configurationActivity`, `other.zenPolicy`, `other.pkg`, and `other.modified`. This constitutes an 'Other statement changed' scenario.",There is no Compatibility Issue since the changes only refine the conditions for equality and do not alter the method's behavior in a way that could cause previously working comparisons to fail. Existing valid comparisons remain valid; additional properties are just taken into account for the comparison.
227,<android.os.ParcelFileDescriptor: int parseMode(String)>,28,29,<android.os.ParcelFileDescriptor: int parseMode(String)>,<android.os.ParcelFileDescriptor: int parseMode(String)>,0,"{
    final int modeBits;
    if (""r"".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
    } else if (""w"".equals(mode) || ""wt"".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE;
    } else if (""wa"".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_APPEND;
    } else if (""rw"".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_READ_WRITE | ParcelFileDescriptor.MODE_CREATE;
    } else if (""rwt"".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_READ_WRITE | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE;
    } else {
        throw new IllegalArgumentException(""Bad mode '"" + mode + ""'"");
    }
    return modeBits;
}","{
    return FileUtils.translateModePosixToPfd(FileUtils.translateModeStringToPosix(mode));
}",1,"/**
 * Converts a string representing a file mode, such as ""rw"", into a bitmask suitable for use
 * with {@link #open}.
 * <p>
 * @param mode The string representation of the file mode. Can be ""r"", ""w"", ""wt"", ""wa"", ""rw""
 * or ""rwt"".
 * @return A bitmask representing the given file mode.
 * @throws IllegalArgumentException if the given string does not match a known file mode.
 */
","/**
 * Converts a string representing a file mode, such as ""rw"", into a bitmask suitable for use
 * with {@link #open}.
 * <p>
 * @param mode The string representation of the file mode. Can be ""r"", ""w"", ""wt"", ""wa"", ""rw""
 * or ""rwt"".
 * @return A bitmask representing the given file mode.
 * @throws IllegalArgumentException if the given string does not match a known file mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation has been replaced with a call to FileUtils.translateModePosixToPfd(FileUtils.translateModeStringToPosix(mode)); the control logic has been completely removed from the API implementation itself, and there's a reliance on a new/modified dependent API (FileUtils.translateModeStringToPosix and FileUtils.translateModePosixToPfd), so the code change type is 1,4,5.","Given that the implementation relied on a control structure to parse and return the mode but now relies on a dependent API to provide the same functionality, there's potential for the return value (the parsed mode bits) to be different if the behavior of the dependent API is not an exact match for the previous implementation. Therefore, the CI type is 1."
228,<android.widget.TextView.TextAppearanceAttributes: String toString()>,28,29,<android.widget.TextView.TextAppearanceAttributes: String toString()>,<android.widget.TextView.TextAppearanceAttributes: String toString()>,0,"{
    return ""TextAppearanceAttributes {\n"" + ""    mTextColorHighlight:"" + mTextColorHighlight + ""\n"" + ""    mTextColor:"" + mTextColor + ""\n"" + ""    mTextColorHint:"" + mTextColorHint + ""\n"" + ""    mTextColorLink:"" + mTextColorLink + ""\n"" + ""    mTextSize:"" + mTextSize + ""\n"" + ""    mFontFamily:"" + mFontFamily + ""\n"" + ""    mFontTypeface:"" + mFontTypeface + ""\n"" + ""    mFontFamilyExplicit:"" + mFontFamilyExplicit + ""\n"" + ""    mTypefaceIndex:"" + mTypefaceIndex + ""\n"" + ""    mStyleIndex:"" + mStyleIndex + ""\n"" + ""    mFontWeight:"" + mFontWeight + ""\n"" + ""    mAllCaps:"" + mAllCaps + ""\n"" + ""    mShadowColor:"" + mShadowColor + ""\n"" + ""    mShadowDx:"" + mShadowDx + ""\n"" + ""    mShadowDy:"" + mShadowDy + ""\n"" + ""    mShadowRadius:"" + mShadowRadius + ""\n"" + ""    mHasElegant:"" + mHasElegant + ""\n"" + ""    mElegant:"" + mElegant + ""\n"" + ""    mHasFallbackLineSpacing:"" + mHasFallbackLineSpacing + ""\n"" + ""    mFallbackLineSpacing:"" + mFallbackLineSpacing + ""\n"" + ""    mHasLetterSpacing:"" + mHasLetterSpacing + ""\n"" + ""    mLetterSpacing:"" + mLetterSpacing + ""\n"" + ""    mFontFeatureSettings:"" + mFontFeatureSettings + ""\n"" + ""}"";
}","{
    return ""TextAppearanceAttributes {\n"" + ""    mTextColorHighlight:"" + mTextColorHighlight + ""\n"" + ""    mTextColor:"" + mTextColor + ""\n"" + ""    mTextColorHint:"" + mTextColorHint + ""\n"" + ""    mTextColorLink:"" + mTextColorLink + ""\n"" + ""    mTextSize:"" + mTextSize + ""\n"" + ""    mTextLocales:"" + mTextLocales + ""\n"" + ""    mFontFamily:"" + mFontFamily + ""\n"" + ""    mFontTypeface:"" + mFontTypeface + ""\n"" + ""    mFontFamilyExplicit:"" + mFontFamilyExplicit + ""\n"" + ""    mTypefaceIndex:"" + mTypefaceIndex + ""\n"" + ""    mTextStyle:"" + mTextStyle + ""\n"" + ""    mFontWeight:"" + mFontWeight + ""\n"" + ""    mAllCaps:"" + mAllCaps + ""\n"" + ""    mShadowColor:"" + mShadowColor + ""\n"" + ""    mShadowDx:"" + mShadowDx + ""\n"" + ""    mShadowDy:"" + mShadowDy + ""\n"" + ""    mShadowRadius:"" + mShadowRadius + ""\n"" + ""    mHasElegant:"" + mHasElegant + ""\n"" + ""    mElegant:"" + mElegant + ""\n"" + ""    mHasFallbackLineSpacing:"" + mHasFallbackLineSpacing + ""\n"" + ""    mFallbackLineSpacing:"" + mFallbackLineSpacing + ""\n"" + ""    mHasLetterSpacing:"" + mHasLetterSpacing + ""\n"" + ""    mLetterSpacing:"" + mLetterSpacing + ""\n"" + ""    mFontFeatureSettings:"" + mFontFeatureSettings + ""\n"" + ""    mFontVariationSettings:"" + mFontVariationSettings + ""\n"" + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified in the late implementation to include `mTextLocales`, and a new key-value, `mFontVariationSettings`, is appended. Additionally, the `mStyleIndex` field is replaced by `mTextStyle` in the return value. Since the content of the string returned by the method is altered, the code change type is 1 (return statement changed) and 4 (other statement changed).","Considering the return statement's content has changed with the addition of new information and renaming of field, the method now potentially returns a different value. Therefore, a Compatibility Issue could arise due to the potential difference in return values, which is the CI type 1."
230,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectResourceMismatches()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectResourceMismatches()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectResourceMismatches()>,0,"{
    return enable(DETECT_RESOURCE_MISMATCH);
}","{
    return enable(DETECT_THREAD_RESOURCE_MISMATCH);
}",1,"/**
 * Enables detection of mismatches between defined resource types and getter calls.
 *
 * <p>This helps detect accidental type mismatches and potentially expensive type
 * conversions when obtaining typed resources.
 *
 * <p>For example, a strict mode violation would be thrown when calling {@link
 * android.content.res.TypedArray#getInt(int, int)} on an index that contains a
 * String-type resource. If the string value can be parsed as an integer, this method
 * call will return a value without crashing; however, the developer should format the
 * resource as an integer to avoid unnecessary type conversion.
 */
","/**
 * Enables detection of mismatches between defined resource types and getter calls.
 *
 * <p>This helps detect accidental type mismatches and potentially expensive type
 * conversions when obtaining typed resources.
 *
 * <p>For example, a strict mode violation would be thrown when calling {@link
 * android.content.res.TypedArray#getInt(int, int)} on an index that contains a
 * String-type resource. If the string value can be parsed as an integer, this method
 * call will return a value without crashing; however, the developer should format the
 * resource as an integer to avoid unnecessary type conversion.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed because the parameter of the `enable` method has changed from DETECT_RESOURCE_MISMATCH to DETECT_THREAD_RESOURCE_MISMATCH. Since this parameter is related to the configuration of the StrictMode policy, the method invoked inside the `enable` method has changed, which means a dependent API has changed as well. Therefore, the code change types are 1 (Return statement changed) and 5 (Dependent API changed).","The change in the return statement indicates that the `enable` method is now being called with a different argument, which could potentially enable a different StrictMode policy, resulting in a different behavior. Thus, the potential Compatibility Issue arises from the potential different return value, and the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
231,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,String,boolean,int)>",28,29,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,String,boolean,int)>","<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,String,boolean,int)>",0,"{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        if (tag != null) {
            arg.putString(CALL_METHOD_TAG_KEY, tag);
        }
        if (makeDefault) {
            arg.putBoolean(CALL_METHOD_MAKE_DEFAULT_KEY, true);
        }
        IContentProvider cp = mProviderHolder.getProvider(cr);
        cp.call(cr.getPackageName(), mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}","{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        if (tag != null) {
            arg.putString(CALL_METHOD_TAG_KEY, tag);
        }
        if (makeDefault) {
            arg.putBoolean(CALL_METHOD_MAKE_DEFAULT_KEY, true);
        }
        IContentProvider cp = mProviderHolder.getProvider(cr);
        cp.call(cr.getPackageName(), mProviderHolder.mUri.getAuthority(), mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is within the `cp.call` method where `mProviderHolder.mUri.getAuthority()` replaced `mUri`. This is a call to a different method or property within the same library with no change in control flow, return type, or exception handling, so the code change type is 4.","There is no Compatibility Issue due to this change, as the implementation change does not affect the public API behavior in terms of its return value or the exceptions it throws; it merely changes a parameter passed to an internal call. The two versions perform the same functionality and provide the same guarantees to the end-user."
232,<android.webkit.WebViewLibraryLoader.RelroFileCreator: void main(String[])>,28,29,<android.webkit.WebViewLibraryLoader.RelroFileCreator: void main(String[])>,<android.webkit.WebViewLibraryLoader.RelroFileCreator: void main(String[])>,0,"{
    boolean result = false;
    boolean is64Bit = VMRuntime.getRuntime().is64Bit();
    try {
        if (args.length != 1 || args[0] == null) {
            Log.e(LOGTAG, ""Invalid RelroFileCreator args: "" + Arrays.toString(args));
            return;
        }
        Log.v(LOGTAG, ""RelroFileCreator (64bit = "" + is64Bit + ""), lib: "" + args[0]);
        if (!sAddressSpaceReserved) {
            Log.e(LOGTAG, ""can't create relro file; address space not reserved"");
            return;
        }
        result = nativeCreateRelroFile(args[0], /* path */
        is64Bit ? CHROMIUM_WEBVIEW_NATIVE_RELRO_64 : CHROMIUM_WEBVIEW_NATIVE_RELRO_32);
        if (result && DEBUG)
            Log.v(LOGTAG, ""created relro file"");
    } finally {
        // We must do our best to always notify the update service, even if something fails.
        try {
            WebViewFactory.getUpdateServiceUnchecked().notifyRelroCreationCompleted();
        } catch (RemoteException e) {
            Log.e(LOGTAG, ""error notifying update service"", e);
        }
        if (!result)
            Log.e(LOGTAG, ""failed to create relro file"");
        // Must explicitly exit or else this process will just sit around after we return.
        System.exit(0);
    }
}","{
    boolean result = false;
    boolean is64Bit = VMRuntime.getRuntime().is64Bit();
    try {
        if (args.length != 2 || args[0] == null || args[1] == null) {
            Log.e(LOGTAG, ""Invalid RelroFileCreator args: "" + Arrays.toString(args));
            return;
        }
        String packageName = args[0];
        String libraryFileName = args[1];
        Log.v(LOGTAG, ""RelroFileCreator (64bit = "" + is64Bit + ""), package: "" + packageName + "" library: "" + libraryFileName);
        if (!sAddressSpaceReserved) {
            Log.e(LOGTAG, ""can't create relro file; address space not reserved"");
            return;
        }
        LoadedApk apk = ActivityThread.currentActivityThread().getPackageInfo(packageName, null, Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
        result = nativeCreateRelroFile(libraryFileName, is64Bit ? CHROMIUM_WEBVIEW_NATIVE_RELRO_64 : CHROMIUM_WEBVIEW_NATIVE_RELRO_32, apk.getClassLoader());
        if (result && DEBUG)
            Log.v(LOGTAG, ""created relro file"");
    } finally {
        // We must do our best to always notify the update service, even if something fails.
        try {
            WebViewFactory.getUpdateServiceUnchecked().notifyRelroCreationCompleted();
        } catch (RemoteException e) {
            Log.e(LOGTAG, ""error notifying update service"", e);
        }
        if (!result)
            Log.e(LOGTAG, ""failed to create relro file"");
        // Must explicitly exit or else this process will just sit around after we return.
        System.exit(0);
    }
}",1,"// Called in an unprivileged child process to create the relro file.
","// Called in an unprivileged child process to create the relro file.
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method's condition check for the arguments has changed from requiring a single non-null argument to requiring two non-null arguments. This is a control dependency change (3). New local variables `packageName` and `libraryFileName` have been introduced replacing the direct usage of `args[0]`, and an additional call `ActivityThread.currentActivityThread().getPackageInfo()` is made, which affects the execution flow and the method call `nativeCreateRelroFile()` now takes an additional argument `apk.getClassLoader()`. These constitute other statement changes (4). The addition of a new parameter to `nativeCreateRelroFile()` indicates a dependent API change (5), and the return statement has been affected as a different number of parameters are being passed to `nativeCreateRelroFile()`, which is a return statement change (1).","There is a potential Compatibility Issue caused by different return values (1) because the verification of input arguments has been modified, which can cause the method to return early with different conditions in the new version. Any existing user of this API expecting only one argument before the update would face an incompatibility issue after the update since it now requires two arguments. Moreover, the method `nativeCreateRelroFile()` is invoked with a different set of parameters, potentially altering its return value or behavior."
233,"<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>",28,29,"<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>","<android.hardware.camera2.legacy.SurfaceTextureRenderer: void configureSurfaces(Collection<Pair<Surface, Size>>)>",0,"{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, ""No output surfaces configured for GL drawing."");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
                // LegacyCameraDevice is the producer of surfaces if it's not handled by EGL,
                // so LegacyCameraDevice needs to connect to the surfaces.
                LegacyCameraDevice.connectSurface(s);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, ""Surface abandoned, skipping configuration... "", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}","{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, ""No output surfaces configured for GL drawing."");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
                // LegacyCameraDevice is the producer of surfaces if it's not handled by EGL,
                // so LegacyCameraDevice needs to connect to the surfaces.
                LegacyCameraDevice.connectSurface(s);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, ""Surface abandoned, skipping configuration... "", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    try {
        makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, skipping configuration... "", e);
    }
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}",1,"/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */
","/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"Exception handling for makeCurrent() method call has been introduced with a try-catch block catching LegacyExceptionUtils.BufferQueueAbandonededException. Also, a new control dependency has been introduced around the makeCurrent() call, and the order of the initialization of mSurfaceTexture is slightly different due to the try-catch block being introduced, resulting in 2,3,4.","The introduction of a new exception handling mechanism can lead to different behavior if the exception is thrown. This change could potentially result in the method not throwing an exception where it previously would have continued execution after an error was logged, which is indicated in type 2 for CI."
235,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,28,29,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,<android.transition.TransitionManager.MultiListener: boolean onPreDraw()>,0,"{
    removeListeners();
    // Don't start the transition if it's no longer pending.
    if (!sPendingTransitions.remove(mSceneRoot)) {
        return true;
    }
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(mSceneRoot);
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}","{
    removeListeners();
    // Don't start the transition if it's no longer pending.
    if (!sPendingTransitions.remove(mSceneRoot)) {
        return true;
    }
    // Add to running list, handle end to remove it
    final ArrayMap<ViewGroup, ArrayList<Transition>> runningTransitions = getRunningTransitions();
    ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
    ArrayList<Transition> previousRunningTransitions = null;
    if (currentTransitions == null) {
        currentTransitions = new ArrayList<Transition>();
        runningTransitions.put(mSceneRoot, currentTransitions);
    } else if (currentTransitions.size() > 0) {
        previousRunningTransitions = new ArrayList<Transition>(currentTransitions);
    }
    currentTransitions.add(mTransition);
    mTransition.addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            ArrayList<Transition> currentTransitions = runningTransitions.get(mSceneRoot);
            currentTransitions.remove(transition);
            transition.removeListener(this);
        }
    });
    mTransition.captureValues(mSceneRoot, false);
    if (previousRunningTransitions != null) {
        for (Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(mSceneRoot);
        }
    }
    mTransition.playTransition(mSceneRoot);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is the introduction of the line 'transition.removeListener(this);' within the 'onTransitionEnd' method of the 'TransitionListenerAdapter' anonymous class. This is not a change in any return statements, exception handling statements, or control dependencies at the level of the 'onPreDraw' method itself. It's an internal modification to a listener of the 'mTransition' object, so the code change type is 4.","The inserted 'removeListener' statement does not affect the method's return value or exception throwing behavior; it changes the state of the 'transition' object being listened to. Therefore, it does not constitute a Compatibility Issue as defined by the provided definitions and instructions, hence the CI type is 0."
236,<android.widget.ProgressBar: Mode getIndeterminateTintMode()>,28,29,<android.widget.ProgressBar: Mode getIndeterminateTintMode()>,<android.widget.ProgressBar: Mode getIndeterminateTintMode()>,0,"{
    return mProgressTintInfo != null ? mProgressTintInfo.mIndeterminateTintMode : null;
}","{
    BlendMode mode = getIndeterminateTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the indeterminate
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the indeterminate
 * drawable
 * @attr ref android.R.styleable#ProgressBar_indeterminateTintMode
 * @see #setIndeterminateTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the indeterminate
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the indeterminate
 * drawable
 * @attr ref android.R.styleable#ProgressBar_indeterminateTintMode
 * @see #setIndeterminateTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed to use a new method getIndeterminateTintBlendMode() and a conversion function BlendMode.blendModeToPorterDuffMode(mode), which means the way of obtaining the return value is different, so the code change type is 1,5.","Since the method to calculate the returned value has changed and a conversion is added, it indicates that there is a potential for the method to return a different value even if the input remained the same. Thus, the CI type is 1."
242,<android.bluetooth.BluetoothHidDevice: boolean unregisterApp()>,28,29,<android.bluetooth.BluetoothHidDevice: boolean unregisterApp()>,<android.bluetooth.BluetoothHidDevice: boolean unregisterApp()>,0,"{
    boolean result = false;
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            result = service.unregisterApp();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.unregisterApp();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Unregisters application. Active connection will be disconnected and no new connections will
 * be allowed until registered again using {@link #registerApp
 * (BluetoothHidDeviceAppQosSettings, BluetoothHidDeviceAppQosSettings,
 * BluetoothHidDeviceAppQosSettings, Executor, Callback)}. The registration status should be
 * tracked by the application by handling callback from Callback#onAppStatusChanged. The app
 * registration status is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Unregisters application. Active connection will be disconnected and no new connections will
 * be allowed until registered again using {@link #registerApp
 * (BluetoothHidDeviceAppQosSettings, BluetoothHidDeviceAppQosSettings,
 * BluetoothHidDeviceAppQosSettings, Executor, Callback)}. The registration status should be
 * tracked by the application by handling callback from Callback#onAppStatusChanged. The app
 * registration status is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the call to getService() in place of accessing mService directly. It is categorized as 4 because it's not a return statement, exception handling change, or control dependency change. It's an implementation detail change of how the service instance is obtained.","There is no compatibility issue detected because the changes do not affect the overall behavior and output of the method. The method still returns a boolean result, and exception handling remains intact. The change is strictly in the internals of how the service is retrieved and should be transparent to an API user as long as the getService() method maintains the same contract as the direct mService access."
244,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,28,29,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,0,"{
    hideStatusIconInternal(imeToken);
}","{
    InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIcon(null, 0);
}",1,"/**
 * @deprecated Use {@link InputMethodService#hideStatusIcon()} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
","/**
 * @deprecated Use {@link InputMethodService#hideStatusIcon()} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The internal implementation of the method has changed from calling `hideStatusIconInternal` to using `InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIcon(null, 0)`. However, both calls are internal and the external behavior should remain the same (both are meant to hide the status icon), so the change is categorized as 5 (Dependent API changed).","Even though the internal implementation has changed, there is no direct indication that these changes will lead to a different behavior seen by the caller. Therefore, there is no evidence of a Compatibility Issue unless the new internal method `updateStatusIcon(null, 0)` by itself introduces a behavioral change when compared to `hideStatusIconInternal`. Based on the information provided, which does not include details on the behavior of these methods, there is no Compatibility Issue detected. However, it is worth noting that without the complete context or being able to assess the actual effects of `updateStatusIcon`, this analysis could miss potential compatibility issues, and an assumption is made that the two methods are functionally equivalent in their task to hide the status icon."
245,<android.service.carrier.CarrierIdentifier: String toString()>,28,29,<android.service.carrier.CarrierIdentifier: String toString()>,<android.service.carrier.CarrierIdentifier: String toString()>,0,"{
    return ""CarrierIdentifier{"" + ""mcc="" + mMcc + "",mnc="" + mMnc + "",spn="" + mSpn + "",imsi="" + mImsi + "",gid1="" + mGid1 + "",gid2="" + mGid2 + ""}"";
}","{
    return ""CarrierIdentifier{"" + ""mcc="" + mMcc + "",mnc="" + mMnc + "",spn="" + mSpn + "",imsi="" + Rlog.pii(false, mImsi) + "",gid1="" + mGid1 + "",gid2="" + mGid2 + "",carrierid="" + mCarrierId + "",specificCarrierId="" + mSpecificCarrierId + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement was modified by altering the concatenated string; an additional method call (Rlog.pii) was introduced for mImsi to potentially obfuscate it, and new fields (mCarrierId and mSpecificCarrierId) were appended to the output. These changes affect the return value of the method, so the code change types are 1 (Return statement changed) and 4 (Other statement changed).","The modification to the return statement can lead to the API potentially returning a different value due to the inclusion of the obfuscated mImsi and the new fields, resulting in a CI type of 1."
246,<android.content.ClipboardManager: boolean hasText()>,28,29,<android.content.ClipboardManager: boolean hasText()>,<android.content.ClipboardManager: boolean hasText()>,0,"{
    try {
        return mService.hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.hasClipboardText(mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
","/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mService.hasClipboardText` has changed as it now takes an additional parameter `mContext.getUserId()`. Hence, the code change type is 5. ","Since the try block is designed to handle `RemoteException` by rethrowing it, and there is no change to this mechanism, there should be no Compatibility Issue caused by different exception handling. In addition, as long as both calls to `hasClipboardText()` return a boolean value representing if there's text on the clipboard or not, the potential for a changed return value still depends on the contract of `hasClipboardText()` which should handle the added user ID appropriately. Considering usual practices, adding user context to such API calls should be backwards-compatible assuming the service is expected to be user-aware. Thus, there is no strong indication of a Compatibility Issue caused by different return values or types, and the CI type is 0."
247,<android.view.WindowInsets: int getSystemWindowInsetBottom()>,28,29,<android.view.WindowInsets: int getSystemWindowInsetBottom()>,<android.view.WindowInsets: int getSystemWindowInsetBottom()>,0,"{
    return mSystemWindowInsets.bottom;
}","{
    return getSystemWindowInsets().bottom;
}",1,"/**
 * Returns the bottom system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The bottom system window inset
 */
","/**
 * Returns the bottom system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The bottom system window inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from directly accessing the `mSystemWindowInsets.bottom` property to calling `getSystemWindowInsets().bottom`. This implies that `getSystemWindowInsets()` is a dependent API that has changed, so the code change type is 5.","There's no Compatibility Issue here as long as `getSystemWindowInsets()` still returns a `WindowInsets` object with the same `bottom` value that was previously returned by direct access to `mSystemWindowInsets.bottom`. The behavior of `getSystemWindowInsetBottom()` would remain unchanged, hence no CI. However, it's important to note that if the behavior or the definition of `getSystemWindowInsets()` had been modified in a way that changes the returned `bottom` value, that would not be detected here without additional context about the `getSystemWindowInsets()` method. In the absence of such context, we assume no CI."
248,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",28,29,"<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void takePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        UriGrantsManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method that is called within the try block is changed from ActivityManager.getService() to UriGrantsManager.getService(). There is no change in the control flow, return statement, or exception handling, so the code change type is 5.","The only change is in the service being called from ActivityManager to UriGrantsManager. Since the control flow, return statements, and exception handling have not changed and the signature of the takePersistableUriPermission method on the UriGrantsManager service is expected to match the one previously on ActivityManager, there should be no compatibility issue. Therefore, the CI is 0."
249,<android.net.LinkProperties: boolean equals(Object)>,28,29,<android.net.LinkProperties: boolean equals(Object)>,<android.net.LinkProperties: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (!(obj instanceof LinkProperties))
        return false;
    LinkProperties target = (LinkProperties) obj;
    /**
     * This method does not check that stacked interfaces are equal, because
     * stacked interfaces are not so much a property of the link as a
     * description of connections between links.
     */
    return isIdenticalInterfaceName(target) && isIdenticalAddresses(target) && isIdenticalDnses(target) && isIdenticalPrivateDns(target) && isIdenticalValidatedPrivateDnses(target) && isIdenticalRoutes(target) && isIdenticalHttpProxy(target) && isIdenticalStackedLinks(target) && isIdenticalMtu(target) && isIdenticalTcpBufferSizes(target);
}","{
    if (this == obj)
        return true;
    if (!(obj instanceof LinkProperties))
        return false;
    LinkProperties target = (LinkProperties) obj;
    /*
         * This method does not check that stacked interfaces are equal, because
         * stacked interfaces are not so much a property of the link as a
         * description of connections between links.
         */
    return isIdenticalInterfaceName(target) && isIdenticalAddresses(target) && isIdenticalDnses(target) && isIdenticalPrivateDns(target) && isIdenticalValidatedPrivateDnses(target) && isIdenticalPcscfs(target) && isIdenticalRoutes(target) && isIdenticalHttpProxy(target) && isIdenticalStackedLinks(target) && isIdenticalMtu(target) && isIdenticalTcpBufferSizes(target) && isIdenticalNat64Prefix(target);
}",1,,"/**
 * Compares this {@code LinkProperties} instance against the target
 * LinkProperties in {@code obj}. Two LinkPropertieses are equal if
 * all their fields are equal in values.
 *
 * For collection fields, such as mDnses, containsAll() is used to check
 * if two collections contains the same elements, independent of order.
 * There are two thoughts regarding containsAll()
 * 1. Duplicated elements. eg, (A, B, B) and (A, A, B) are equal.
 * 2. Worst case performance is O(n^2).
 *
 * @param obj the object to be tested for equality.
 * @return {@code true} if both objects are equal, {@code false} otherwise.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An additional method call isIdenticalNat64Prefix(target) is added to the boolean logic, and isIdenticalPcscfs(target) method replaces isIdenticalValidatedPrivateDnses(target) method in the boolean logic, so the change type is 1,4.","The addition of a new condition and replacement of an existing method in the logical return statement can potentially lead to a different outcome of the equals method, which means a Compatibility Issue of type 1 could arise due to potentially different return values."
251,"<android.net.ConnectivityManager: void reportNetworkConnectivity(Network,boolean)>",28,29,"<android.net.ConnectivityManager: void reportNetworkConnectivity(Network,boolean)>","<android.net.ConnectivityManager: void reportNetworkConnectivity(Network,boolean)>",0,"{
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    printStackTrace();
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Report to the framework whether a network has working connectivity.
 * This provides a hint to the system that a particular network is providing
 * working connectivity or not.  In response the framework may re-evaluate
 * the network's connectivity and might take further action thereafter.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @param hasConnectivity {@code true} if the application was able to successfully access the
 * Internet using {@code network} or {@code false} if not.
 */
","/**
 * Report to the framework whether a network has working connectivity.
 * This provides a hint to the system that a particular network is providing
 * working connectivity or not.  In response the framework may re-evaluate
 * the network's connectivity and might take further action thereafter.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @param hasConnectivity {@code true} if the application was able to successfully access the
 * Internet using {@code network} or {@code false} if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call `printStackTrace();` has been introduced at the beginning of the method body, which does not affect the logic or the return value of the method as the method's return type is void and does not involve any exception handling or return statements changes. Thus the change type is 4.","Since the new method call only adds additional logging (assuming that's the purpose of the `printStackTrace()` method, which seems likely as it does not alter the application flow) and does not change the behavior of the method itself concerning its output or exceptions, no compatibility issue arises from this change, and the CI type here is 0."
252,<android.app.Activity: int getRequestedOrientation()>,28,29,<android.app.Activity: int getRequestedOrientation()>,<android.app.Activity: int getRequestedOrientation()>,0,"{
    if (mParent == null) {
        try {
            return ActivityManager.getService().getRequestedOrientation(mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        return mParent.getRequestedOrientation();
    }
    return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","{
    if (mParent == null) {
        try {
            return ActivityTaskManager.getService().getRequestedOrientation(mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        return mParent.getRequestedOrientation();
    }
    return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}",1,"/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",-1,[@ActivityInfo.ScreenOrientation],[@ActivityInfo.ScreenOrientation],-1,-1,-1,-1,-1,-1,5,0,The dependent API used by this method has changed from ActivityManager.getService().getRequestedOrientation(mToken) to ActivityTaskManager.getService().getRequestedOrientation(mToken). This is classified as dependent API changed (code change type 5).,"There is no compatibility issue since the method signature, return type, exception handling, and control flows remain the same. The API mentioned in the implementation still fulfills the contract of the original method, implying that the behavior seen by the callers will not change even though the internal dependency has been updated (CI type 0)."
253,"<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>",28,29,"<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>","<android.view.inputmethod.InputMethodManager: boolean switchToNextInputMethod(IBinder,boolean)>",0,"{
    return switchToNextInputMethodInternal(imeToken, onlyCurrentIme);
}","{
    return InputMethodPrivilegedOperationsRegistry.get(imeToken).switchToNextInputMethod(onlyCurrentIme);
}",1,"/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToNextInputMethod(boolean)} instead. This
 * method was intended for IME developers who should be accessing APIs through the service.
 * APIs in this class are intended for app developers interacting with the IME.
 */
","/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToNextInputMethod(boolean)} instead. This
 * method was intended for IME developers who should be accessing APIs through the service.
 * APIs in this class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed to call `switchToNextInputMethod` on an instance retrieved from `InputMethodPrivilegedOperationsRegistry.get(imeToken)` instead of calling a method `switchToNextInputMethodInternal` directly. There's no change in the signature of the current API or in its return type, hence the type of this change is 5, which indicates the change of a Dependent API.","Given the information provided, there's no explicit change in behavior described for the dependent API being used, and the signature, return type, and exception handling capability of `switchToNextInputMethod` remain the same as the indirectly invoked `switchToNextInputMethodInternal`. We assume that the implementation details of the `InputMethodPrivilegedOperationsRegistry` contract to provide similar behavior to the previous implementation. Hence there doesn't seem to be a Compatibility Issue introduced by this change; the type is 0."
254,<android.net.NetworkCapabilities: int hashCode()>,28,29,<android.net.NetworkCapabilities: int hashCode()>,<android.net.NetworkCapabilities: int hashCode()>,0,"{
    return (int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mUnwantedNetworkCapabilities & 0xFFFFFFFF) * 5) + ((int) (mUnwantedNetworkCapabilities >> 32) * 7) + ((int) (mTransportTypes & 0xFFFFFFFF) * 11) + ((int) (mTransportTypes >> 32) * 13) + (mLinkUpBandwidthKbps * 17) + (mLinkDownBandwidthKbps * 19) + Objects.hashCode(mNetworkSpecifier) * 23 + (mSignalStrength * 29) + Objects.hashCode(mUids) * 31 + Objects.hashCode(mSSID) * 37;
}","{
    return (int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mUnwantedNetworkCapabilities & 0xFFFFFFFF) * 5) + ((int) (mUnwantedNetworkCapabilities >> 32) * 7) + ((int) (mTransportTypes & 0xFFFFFFFF) * 11) + ((int) (mTransportTypes >> 32) * 13) + (mLinkUpBandwidthKbps * 17) + (mLinkDownBandwidthKbps * 19) + Objects.hashCode(mNetworkSpecifier) * 23 + (mSignalStrength * 29) + Objects.hashCode(mUids) * 31 + Objects.hashCode(mSSID) * 37 + Objects.hashCode(mTransportInfo) * 41;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The hashCode calculation includes a new term Objects.hashCode(mTransportInfo) * 41, adding to the overall result of the hash function. This is an append operation, so the change type is 4.","While the hashCode method now includes an additional term, introducing this change does not result in a Compatibility Issue because hashCode is expected to produce different values when the object state changes. The method still calculates and returns an int value representing the hash code as required by its contract, and the nature of hash codes in Java allows for different implementations and results across different versions. Therefore, there is no Compatibility Issue."
255,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",28,29,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>","<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",0,"{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = mService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, mService, listener);
    try {
        mService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return session;
}","{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = mService.getCurrentSpellChecker(mUserId, null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, this, listener);
    try {
        mService.getSpellCheckerService(mUserId, sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return session;
}",1,"/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
","/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API `mService.getCurrentSpellChecker()` parameters were changed, now including `mUserId`. Additionally, there is a minor change in the instantiation of the `SpellCheckerSession` object, which now uses `this` instead of `mService`. These reflect changes in the 'Other statement' and 'Dependent API' categories which are change types 4 and 5.","There doesn't seem to be a Compatibility Issue due to the changes. The addition of the `mUserId` parameter is handled internally and assuming `mUserId` is correctly set in the context of the method's use, this should not affect the method's behavior from an API consumer standpoint. Also, changing the parameter from `mService` to `this` in the `SpellCheckerSession` constructor doesn't inherently change the behavior if the context of `this` maintains the same contract as `mService`, which can be inferred because there are no changes in how `mService` is utilized elsewhere in the method. Therefore, the prediction for CI is 0."
256,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",28,29,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>","<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",0,"{
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""SELECTION CHANGE: "" + mCurMethod);
                final int oldSelStart = mCursorSelStart;
                final int oldSelEnd = mCursorSelEnd;
                // Update internal values before sending updateSelection to the IME, because
                // if it changes the text within its onUpdateSelection handler in a way that
                // does not move the cursor we don't want to call it again with the same values.
                mCursorSelStart = selStart;
                mCursorSelEnd = selEnd;
                mCursorCandStart = candidatesStart;
                mCursorCandEnd = candidatesEnd;
                mCurMethod.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateSelection(view, selStart, selEnd, candidatesStart, candidatesEnd);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""SELECTION CHANGE: "" + mCurMethod);
                final int oldSelStart = mCursorSelStart;
                final int oldSelEnd = mCursorSelEnd;
                // Update internal values before sending updateSelection to the IME, because
                // if it changes the text within its onUpdateSelection handler in a way that
                // does not move the cursor we don't want to call it again with the same values.
                mCursorSelStart = selStart;
                mCursorSelEnd = selEnd;
                mCursorCandStart = candidatesStart;
                mCursorCandEnd = candidatesEnd;
                mCurMethod.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}",1,"/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
","/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"A new control dependency and other statement changes have been introduced in the form of checking whether there's a context mismatch and using a fallback input method manager if necessary. Moreover, a new dependent API call to getFallbackInputMethodManagerIfNecessary(view) has been added at the start of the method. The early implementation does not have this logic. Thus, the code change types are 3,4,5.","The additional control dependency alters the flow but does not introduce a new return variable or type, nor does it change the exception handling; the control flow simply diverts to a fallback mechanism when needed, and then the method exits. Thus, no compatibility issue arises due to this change because when the condition is met, the same method is called on the fallbackImm object instead of the current object, and when it's not, the method's execution proceeds just as it did in the early version."
257,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitDiskWrites()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitDiskWrites()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitDiskWrites()>,0,"{
    return disable(DETECT_DISK_WRITE);
}","{
    return disable(DETECT_THREAD_DISK_WRITE);
}",1,"/**
 * Disable detection of disk writes.
 */
","/**
 * Disable detection of disk writes.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from disable(DETECT_DISK_WRITE) to disable(DETECT_THREAD_DISK_WRITE) and the passed parameter to the disable method has changed, indicating that a different variation of detection disabled, so the code change type is 1,5.","The change in the return statement can potentially cause the API to return a different value which could affect the behavior of the resulting ThreadPolicy. Consequently, the CI type is 1."
259,"<android.app.admin.DevicePolicyManager: AttestedKeyPair generateKeyPair(ComponentName,String,KeyGenParameterSpec,int)>",28,29,"<android.app.admin.DevicePolicyManager: AttestedKeyPair generateKeyPair(ComponentName,String,KeyGenParameterSpec,int)>","<android.app.admin.DevicePolicyManager: AttestedKeyPair generateKeyPair(ComponentName,String,KeyGenParameterSpec,int)>",0,"{
    throwIfParentInstance(""generateKeyPair"");
    try {
        final ParcelableKeyGenParameterSpec parcelableSpec = new ParcelableKeyGenParameterSpec(keySpec);
        KeymasterCertificateChain attestationChain = new KeymasterCertificateChain();
        // Translate ID attestation flags to values used by AttestationUtils
        final boolean success = mService.generateKeyPair(admin, mContext.getPackageName(), algorithm, parcelableSpec, idAttestationFlags, attestationChain);
        if (!success) {
            Log.e(TAG, ""Error generating key via DevicePolicyManagerService."");
            return null;
        }
        final String alias = keySpec.getKeystoreAlias();
        final KeyPair keyPair = KeyChain.getKeyPair(mContext, alias);
        Certificate[] outputChain = null;
        try {
            if (AttestationUtils.isChainValid(attestationChain)) {
                outputChain = AttestationUtils.parseCertificateChain(attestationChain);
            }
        } catch (KeyAttestationException e) {
            Log.e(TAG, ""Error parsing attestation chain for alias "" + alias, e);
            mService.removeKeyPair(admin, mContext.getPackageName(), alias);
            return null;
        }
        return new AttestedKeyPair(keyPair, outputChain);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (KeyChainException e) {
        Log.w(TAG, ""Failed to generate key"", e);
    } catch (InterruptedException e) {
        Log.w(TAG, ""Interrupted while generating key"", e);
        Thread.currentThread().interrupt();
    }
    return null;
}","{
    throwIfParentInstance(""generateKeyPair"");
    try {
        final ParcelableKeyGenParameterSpec parcelableSpec = new ParcelableKeyGenParameterSpec(keySpec);
        KeymasterCertificateChain attestationChain = new KeymasterCertificateChain();
        // Translate ID attestation flags to values used by AttestationUtils
        final boolean success = mService.generateKeyPair(admin, mContext.getPackageName(), algorithm, parcelableSpec, idAttestationFlags, attestationChain);
        if (!success) {
            Log.e(TAG, ""Error generating key via DevicePolicyManagerService."");
            return null;
        }
        final String alias = keySpec.getKeystoreAlias();
        final KeyPair keyPair = KeyChain.getKeyPair(mContext, alias);
        Certificate[] outputChain = null;
        try {
            if (AttestationUtils.isChainValid(attestationChain)) {
                outputChain = AttestationUtils.parseCertificateChain(attestationChain);
            }
        } catch (KeyAttestationException e) {
            Log.e(TAG, ""Error parsing attestation chain for alias "" + alias, e);
            mService.removeKeyPair(admin, mContext.getPackageName(), alias);
            return null;
        }
        return new AttestedKeyPair(keyPair, outputChain);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (KeyChainException e) {
        Log.w(TAG, ""Failed to generate key"", e);
    } catch (InterruptedException e) {
        Log.w(TAG, ""Interrupted while generating key"", e);
        Thread.currentThread().interrupt();
    } catch (ServiceSpecificException e) {
        Log.w(TAG, String.format(""Key Generation failure: %d"", e.errorCode));
        switch(e.errorCode) {
            case KEY_GEN_STRONGBOX_UNAVAILABLE:
                throw new StrongBoxUnavailableException(""No StrongBox for key generation."");
            default:
                throw new RuntimeException(String.format(""Unknown error while generating key: %d"", e.errorCode));
        }
    }
    return null;
}",1,"/**
 * Called by a device or profile owner, or delegated certificate installer, to generate a
 * new private/public key pair. If the device supports key generation via secure hardware,
 * this method is useful for creating a key in KeyChain that never left the secure hardware.
 *
 * Access to the key is controlled the same way as in {@link #installKeyPair}.
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param algorithm The key generation algorithm, see {@link java.security.KeyPairGenerator}.
 * @param keySpec Specification of the key to generate, see
 * {@link java.security.KeyPairGenerator}.
 * @param idAttestationFlags A bitmask of all the identifiers that should be included in the
 * attestation record ({@code ID_TYPE_BASE_INFO}, {@code ID_TYPE_SERIAL},
 * {@code ID_TYPE_IMEI} and {@code ID_TYPE_MEID}), or {@code 0} if no device
 * identification is required in the attestation record.
 * Device owner, profile owner and their delegated certificate installer can use
 * {@link #ID_TYPE_BASE_INFO} to request inclusion of the general device information
 * including manufacturer, model, brand, device and product in the attestation record.
 * Only device owner and their delegated certificate installer can use
 * {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID} to request
 * unique device identifiers to be attested.
 * <p>
 * If any of {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID}
 * is set, it is implicitly assumed that {@link #ID_TYPE_BASE_INFO} is also set.
 * <p>
 * If any flag is specified, then an attestation challenge must be included in the
 * {@code keySpec}.
 * @return A non-null {@code AttestedKeyPair} if the key generation succeeded, null otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner. If Device ID attestation is requested (using {@link #ID_TYPE_SERIAL},
 * {@link #ID_TYPE_IMEI} or {@link #ID_TYPE_MEID}), the caller must be the Device Owner
 * or the Certificate Installer delegate.
 * @throws IllegalArgumentException if the alias in {@code keySpec} is empty, if the
 * algorithm specification in {@code keySpec} is not {@code RSAKeyGenParameterSpec}
 * or {@code ECGenParameterSpec}, or if Device ID attestation was requested but the
 * {@code keySpec} does not contain an attestation challenge.
 * @throws UnsupportedOperationException if Device ID attestation was requested but the
 * underlying hardware does not support it.
 * @see KeyGenParameterSpec.Builder#setAttestationChallenge(byte[])
 */
","/**
 * Called by a device or profile owner, or delegated certificate installer, to generate a
 * new private/public key pair. If the device supports key generation via secure hardware,
 * this method is useful for creating a key in KeyChain that never left the secure hardware.
 * Access to the key is controlled the same way as in {@link #installKeyPair}.
 *
 * <p>Because this method might take several seconds to complete, it should only be called from
 * a worker thread. This method returns {@code null} when called from the main thread.
 *
 * <p>Note: If the provided {@code alias} is of an existing alias, all former grants that apps
 * have been given to access the key and certificates associated with this alias will be
 * revoked.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if calling from a delegated certificate installer.
 * @param algorithm The key generation algorithm, see {@link java.security.KeyPairGenerator}.
 * @param keySpec Specification of the key to generate, see
 * {@link java.security.KeyPairGenerator}.
 * @param idAttestationFlags A bitmask of all the identifiers that should be included in the
 * attestation record ({@code ID_TYPE_BASE_INFO}, {@code ID_TYPE_SERIAL},
 * {@code ID_TYPE_IMEI} and {@code ID_TYPE_MEID}), or {@code 0} if no device
 * identification is required in the attestation record.
 * Device owner, profile owner and their delegated certificate installer can use
 * {@link #ID_TYPE_BASE_INFO} to request inclusion of the general device information
 * including manufacturer, model, brand, device and product in the attestation record.
 * Only device owner and their delegated certificate installer can use
 * {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID} to request
 * unique device identifiers to be attested.
 * <p>
 * If any of {@link #ID_TYPE_SERIAL}, {@link #ID_TYPE_IMEI} and {@link #ID_TYPE_MEID}
 * is set, it is implicitly assumed that {@link #ID_TYPE_BASE_INFO} is also set.
 * <p>
 * If any flag is specified, then an attestation challenge must be included in the
 * {@code keySpec}.
 * @return A non-null {@code AttestedKeyPair} if the key generation succeeded, null otherwise.
 * @throws SecurityException if {@code admin} is not {@code null} and not a device or profile
 * owner. If Device ID attestation is requested (using {@link #ID_TYPE_SERIAL},
 * {@link #ID_TYPE_IMEI} or {@link #ID_TYPE_MEID}), the caller must be the Device Owner
 * or the Certificate Installer delegate.
 * @throws IllegalArgumentException if the alias in {@code keySpec} is empty, if the
 * algorithm specification in {@code keySpec} is not {@code RSAKeyGenParameterSpec}
 * or {@code ECGenParameterSpec}, or if Device ID attestation was requested but the
 * {@code keySpec} does not contain an attestation challenge.
 * @throws UnsupportedOperationException if Device ID attestation was requested but the
 * underlying hardware does not support it.
 * @throws StrongBoxUnavailableException if the use of StrongBox for key generation was
 * specified in {@code keySpec} but the device does not have one.
 * @see KeyGenParameterSpec.Builder#setAttestationChallenge(byte[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The code has introduced a new catch block for ServiceSpecificException within the try-catch statement, which qualifies as an exception handling statement changed (2). Additionally, within the new catch block, there's a control dependency (switch statement) based on `e.errorCode`, and a throw statement with new exceptions that didn't exist in the early version, which is another form of an exception handling statement changed. There are no other statement changes (4) beyond this addition, hence only 2,4 is applicable.","The introduction of new exception handling for `ServiceSpecificException` which throws new types of exceptions like `StrongBoxUnavailableException` and `RuntimeException` based on the error code could lead to a change in the exceptions thrown by the method when compared to the early version, thus the CI type is 2."
260,<android.util.StatsLog: boolean logEvent(int)>,28,29,<android.util.StatsLog: boolean logEvent(int)>,<android.util.StatsLog: boolean logEvent(int)>,0,"{
    synchronized (StatsLog.class) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG)
                    Slog.d(TAG, ""Failed to find statsd when logging event"");
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__UNSPECIFIED);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG)
                Slog.d(TAG, ""Failed to connect to statsd when logging event"");
            return false;
        }
    }
}","{
    synchronized (sLogLock) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG) {
                    Slog.d(TAG, ""Failed to find statsd when logging event"");
                }
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__UNSPECIFIED);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG) {
                Slog.d(TAG, ""Failed to connect to statsd when logging event"");
            }
            return false;
        }
    }
}",1,"/**
 * Logs an event that does not represent a start or stop boundary.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */
","/**
 * Logs an event that does not represent a start or stop boundary.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the use of braces around the debug logging statements (if (DEBUG) { ... }). There is no change to the logic or behavior of the code, so the code change type is 4.","There is no change to the method's behavior as far as return values or exceptions are concerned. Therefore, the change does not lead to a Compatibility Issue."
261,<android.view.View: void onRestoreInstanceState(Parcelable)>,28,29,<android.view.View: void onRestoreInstanceState(Parcelable)>,<android.view.View: void onRestoreInstanceState(Parcelable)>,0,"{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            // It can happen that views have the same view id and the restoration path will not
            // be able to distinguish between them. The autofill id needs to be unique though.
            // Hence prevent the same autofill view id from being restored multiple times.
            ((BaseSavedState) state).mSavedData &= ~BaseSavedState.AUTOFILL_ID;
            if ((mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) != 0) {
                // Ignore when view already set it through setAutofillId();
                if (android.view.autofill.Helper.sDebug) {
                    Log.d(VIEW_LOG_TAG, ""onRestoreInstanceState(): not setting autofillId to "" + baseState.mAutofillViewId + "" because view explicitly set it to "" + mAutofillId);
                }
            } else {
                mAutofillViewId = baseState.mAutofillViewId;
                // will be set on demand by getAutofillId()
                mAutofillId = null;
            }
        }
    }
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != null && !(state instanceof AbsSavedState)) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
    if (state != null && state instanceof BaseSavedState) {
        BaseSavedState baseState = (BaseSavedState) state;
        if ((baseState.mSavedData & BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED) != 0) {
            mStartActivityRequestWho = baseState.mStartActivityRequestWhoSaved;
        }
        if ((baseState.mSavedData & BaseSavedState.IS_AUTOFILLED) != 0) {
            setAutofilled(baseState.mIsAutofilled);
        }
        if ((baseState.mSavedData & BaseSavedState.AUTOFILL_ID) != 0) {
            // It can happen that views have the same view id and the restoration path will not
            // be able to distinguish between them. The autofill id needs to be unique though.
            // Hence prevent the same autofill view id from being restored multiple times.
            ((BaseSavedState) state).mSavedData &= ~BaseSavedState.AUTOFILL_ID;
            if ((mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) != 0) {
                // Ignore when view already set it through setAutofillId();
                if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.DEBUG)) {
                    Log.d(AUTOFILL_LOG_TAG, ""onRestoreInstanceState(): not setting autofillId "" + ""to "" + baseState.mAutofillViewId + "" because view explicitly set"" + "" it to "" + mAutofillId);
                }
            } else {
                mAutofillViewId = baseState.mAutofillViewId;
                // will be set on demand by getAutofillId()
                mAutofillId = null;
            }
        }
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,4,0,"The change was in the logging method implementation from android.view.autofill.Helper.sDebug to Log.isLoggable(AUTOFILL_LOG_TAG, Log.DEBUG). This is an internal change that wouldn't affect the behaviour of the method in regards to its interaction with external code, so the code change type is 4.","As there are no changes in the return statements, exception handling or any other behaviour-affecting code, there is no Compatibility Issue with this change."
262,<android.hardware.radio.Utils: Set<Integer> createIntSet(Parcel)>,28,29,<android.hardware.radio.Utils: Set<Integer> createIntSet(Parcel)>,<android.hardware.radio.Utils: Set<Integer> createIntSet(Parcel)>,0,"{
    return createSet(in, new Parcelable.Creator<Integer>() {

        public Integer createFromParcel(Parcel in) {
            return in.readInt();
        }

        public Integer[] newArray(int size) {
            return new Integer[size];
        }
    });
}","{
    int size = in.readInt();
    Set<Integer> set = new HashSet<>(size);
    while (size-- > 0) {
        set.add(in.readInt());
    }
    return set;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method no longer uses createSet with a Parcelable.Creator, instead it constructs the HashSet directly inside the method, and also introduces new local variables such as 'size' and 'set', so the code change type is 1,4.","The late version of the implementation constructs the set differently and could potentially return a different set depending on the data read from the Parcel, even though the ultimate type is the same, a Set of Integers. Therefore, the CI type is 1 due to potential different return values."
263,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,28,29,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm);
    } else {
        return loadUnsafeLabel(pm);
    }
}","{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}",1,"/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method loadSafeLabel in the early version does not take any parameters, but in the late version, it takes three parameters: pm, DEFAULT_MAX_LABEL_SIZE_PX, and a combination of flags. This is a change in the parameter list of a dependent API which is a change type of 5. Moreover, there is a control dependency change (type 3) and return statement change (type 1) as new parameters are added to the method call only within the conditional branch.","The change to the dependent API loadSafeLabel to include new parameters could result in a different return value when the condition is true. Hence, a Compatibility Issue could arise due to potential different return values, hence the CI type is 1."
264,"<android.hardware.radio.Utils: Map<String, String> readStringMap(Parcel)>",28,29,"<android.hardware.radio.Utils: Map<String, String> readStringMap(Parcel)>","<android.hardware.radio.Utils: Map<String, String> readStringMap(Parcel)>",0,"{
    int size = in.readInt();
    Map<String, String> map = new HashMap<>();
    while (size-- > 0) {
        String key = in.readString();
        String value = in.readString();
        map.put(key, value);
    }
    return map;
}","{
    int size = in.readInt();
    Map<String, String> map = new HashMap<>(size);
    while (size-- > 0) {
        String key = in.readString();
        String value = in.readString();
        map.put(key, value);
    }
    return map;
}",1,,,-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change in the late version implementation compared to the early version, is the addition of the initial capacity to the HashMap constructor. This change does not affect the return value or the exception handling of the method, but merely optimizes the internal handling of the HashMap. Therefore, the change type is 4 (Other statement changed).","This change to the HashMap construction does not lead to differences in returned values or thrown exceptions, and therefore there is no Compatibility Issue. The API behaves the same way from the perspective of the user, merely with a potential improvement in performance due to informed initial capacity allocation."
265,<android.bluetooth.le.ScanRecord: String toString()>,28,29,<android.bluetooth.le.ScanRecord: String toString()>,<android.bluetooth.le.ScanRecord: String toString()>,0,"{
    return ""ScanRecord [mAdvertiseFlags="" + mAdvertiseFlags + "", mServiceUuids="" + mServiceUuids + "", mManufacturerSpecificData="" + BluetoothLeUtils.toString(mManufacturerSpecificData) + "", mServiceData="" + BluetoothLeUtils.toString(mServiceData) + "", mTxPowerLevel="" + mTxPowerLevel + "", mDeviceName="" + mDeviceName + ""]"";
}","{
    return ""ScanRecord [mAdvertiseFlags="" + mAdvertiseFlags + "", mServiceUuids="" + mServiceUuids + "", mServiceSolicitationUuids="" + mServiceSolicitationUuids + "", mManufacturerSpecificData="" + BluetoothLeUtils.toString(mManufacturerSpecificData) + "", mServiceData="" + BluetoothLeUtils.toString(mServiceData) + "", mTxPowerLevel="" + mTxPowerLevel + "", mDeviceName="" + mDeviceName + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method implementation changed by adding a variable (mServiceSolicitationUuids) to the returned string. The code change type is 4, since it involves a change in a statement that is neither a return, exception handling, control dependency, nor a dependent API change.","Despite changes in the implementation, the modification does not introduce any new behaviors that affect what values are returned by the method or the exceptions it might throw. It is simply adding more information to a string, which does not cause a compatibility issue with the expected return type or exception handling of the method. Therefore, there is no compatibility issue."
269,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,28,29,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,<android.hardware.camera2.CameraMetadata: List<TKey> getKeys()>,0,"{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null));
}","{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null, /*includeSynthetic*/
    true));
}",1,"/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
","/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */
",-1,"[@SuppressWarnings(""unchecked""), @NonNull]","[@SuppressWarnings(""unchecked""), @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",1,"The change is that a boolean parameter ""true"" for ""includeSynthetic"" has been added to the getKeys method call. This indicates an addition of a parameter to a method call, so the code change types are 4 (other statement changed) and 5 (dependent API changed).","The addition of the new parameter ""true"" for ""includeSynthetic"" could potentially alter the list of keys returned by getKeys, as it could include synthetic keys that weren't included before. This means the returned list from the method can be different, so there is a compatibility issue of type 1 (CI caused by potential different return values or types)."
270,<android.view.View: WindowInsets onApplyWindowInsets(WindowInsets)>,28,29,<android.view.View: WindowInsets onApplyWindowInsets(WindowInsets)>,<android.view.View: WindowInsets onApplyWindowInsets(WindowInsets)>,0,"{
    if ((mPrivateFlags3 & PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) {
        // and has logic to perform.
        if (fitSystemWindows(insets.getSystemWindowInsets())) {
            return insets.consumeSystemWindowInsets();
        }
    } else {
        // We were called from within a direct call to fitSystemWindows.
        if (fitSystemWindowsInt(insets.getSystemWindowInsets())) {
            return insets.consumeSystemWindowInsets();
        }
    }
    return insets;
}","{
    if ((mPrivateFlags3 & PFLAG3_FITTING_SYSTEM_WINDOWS) == 0) {
        // and has logic to perform.
        if (fitSystemWindows(insets.getSystemWindowInsetsAsRect())) {
            return insets.consumeSystemWindowInsets();
        }
    } else {
        // We were called from within a direct call to fitSystemWindows.
        if (fitSystemWindowsInt(insets.getSystemWindowInsetsAsRect())) {
            return insets.consumeSystemWindowInsets();
        }
    }
    return insets;
}",1,"/**
 * Called when the view should apply {@link WindowInsets} according to its internal policy.
 *
 * <p>This method should be overridden by views that wish to apply a policy different from or
 * in addition to the default behavior. Clients that wish to force a view subtree
 * to apply insets should call {@link #dispatchApplyWindowInsets(WindowInsets)}.</p>
 *
 * <p>Clients may supply an {@link OnApplyWindowInsetsListener} to a view. If one is set
 * it will be called during dispatch instead of this method. The listener may optionally
 * call this method from its own implementation if it wishes to apply the view's default
 * insets policy in addition to its own.</p>
 *
 * <p>Implementations of this method should either return the insets parameter unchanged
 * or a new {@link WindowInsets} cloned from the supplied insets with any insets consumed
 * that this view applied itself. This allows new inset types added in future platform
 * versions to pass through existing implementations unchanged without being erroneously
 * consumed.</p>
 *
 * <p>By default if a view's {@link #setFitsSystemWindows(boolean) fitsSystemWindows}
 * property is set then the view will consume the system window insets and apply them
 * as padding for the view.</p>
 *
 * @param insets Insets to apply
 * @return The supplied insets with any applied insets consumed
 */
","/**
 * Called when the view should apply {@link WindowInsets} according to its internal policy.
 *
 * <p>This method should be overridden by views that wish to apply a policy different from or
 * in addition to the default behavior. Clients that wish to force a view subtree
 * to apply insets should call {@link #dispatchApplyWindowInsets(WindowInsets)}.</p>
 *
 * <p>Clients may supply an {@link OnApplyWindowInsetsListener} to a view. If one is set
 * it will be called during dispatch instead of this method. The listener may optionally
 * call this method from its own implementation if it wishes to apply the view's default
 * insets policy in addition to its own.</p>
 *
 * <p>Implementations of this method should either return the insets parameter unchanged
 * or a new {@link WindowInsets} cloned from the supplied insets with any insets consumed
 * that this view applied itself. This allows new inset types added in future platform
 * versions to pass through existing implementations unchanged without being erroneously
 * consumed.</p>
 *
 * <p>By default if a view's {@link #setFitsSystemWindows(boolean) fitsSystemWindows}
 * property is set then the view will consume the system window insets and apply them
 * as padding for the view.</p>
 *
 * @param insets Insets to apply
 * @return The supplied insets with any applied insets consumed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the method the 'insets' object is calling: getSystemWindowInsets() has been changed to getSystemWindowInsetsAsRect(). This indicates a dependency on the WindowInsets class's API, so the code change type is 4,5.","There is no Compatibility Issue since the behavior of the 'onApplyWindowInsets' method in terms of what it returns or throws has not been altered. The calling of a different method (getSystemWindowInsetsAsRect instead of getSystemWindowInsets) does not necessarily mean the behavior seen by the API user changes, assuming the internals of WindowInsets ensures equivalent behavior for the two methods in the context they are used."
271,"<android.app.VoiceInteractor: boolean submitRequest(Request,String)>",28,29,"<android.app.VoiceInteractor: boolean submitRequest(Request,String)>","<android.app.VoiceInteractor: boolean submitRequest(Request,String)>",0,"{
    try {
        if (request.mRequestInterface != null) {
            throw new IllegalStateException(""Given "" + request + "" is already active"");
        }
        IVoiceInteractorRequest ireq = request.submit(mInteractor, mContext.getOpPackageName(), mCallback);
        request.mRequestInterface = ireq;
        request.mContext = mContext;
        request.mActivity = mActivity;
        request.mName = name;
        synchronized (mActiveRequests) {
            mActiveRequests.put(ireq.asBinder(), request);
        }
        return true;
    } catch (RemoteException e) {
        Log.w(TAG, ""Remove voice interactor service died"", e);
        return false;
    }
}","{
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return false;
    }
    try {
        if (request.mRequestInterface != null) {
            throw new IllegalStateException(""Given "" + request + "" is already active"");
        }
        IVoiceInteractorRequest ireq = request.submit(mInteractor, mContext.getOpPackageName(), mCallback);
        request.mRequestInterface = ireq;
        request.mContext = mContext;
        request.mActivity = mActivity;
        request.mName = name;
        synchronized (mActiveRequests) {
            mActiveRequests.put(ireq.asBinder(), request);
        }
        return true;
    } catch (RemoteException e) {
        Log.w(TAG, ""Remove voice interactor service died"", e);
        return false;
    }
}",1,"/**
 * Submit a new {@link Request} to the voice interaction service.  The request must be
 * one of the available subclasses -- {@link ConfirmationRequest}, {@link PickOptionRequest},
 * {@link CompleteVoiceRequest}, {@link AbortVoiceRequest}, or {@link CommandRequest}.
 *
 * @param request The desired request to submit.
 * @param name An optional name for this request, or null. This can be used later with
 * {@link #getActiveRequests} and {@link #getActiveRequest} to find the request.
 *
 * @return Returns true of the request was successfully submitted, else false.
 */
","/**
 * Submit a new {@link Request} to the voice interaction service.  The request must be
 * one of the available subclasses -- {@link ConfirmationRequest}, {@link PickOptionRequest},
 * {@link CompleteVoiceRequest}, {@link AbortVoiceRequest}, or {@link CommandRequest}.
 *
 * @param request The desired request to submit.
 * @param name An optional name for this request, or null. This can be used later with
 * {@link #getActiveRequests} and {@link #getActiveRequest} to find the request.
 *
 * @return Returns true of the request was successfully submitted, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is an addition of a new control dependency statement (if (isDestroyed()) { ... }) and an associated return statement (return false;) in the beginning of the method, which is not present in the early implementation. Hence, the change type is a combination of control dependency change (3) and other statement changed (4).","The introduction of the new 'if' check that returns false if the interactor is destroyed will cause a change in the method's behavior. Since this check could prevent the rest of the method from executing and influence the method's return value, there is a Compatibility Issue caused by potential different return values or types, so the CI type is 1."
274,<android.view.textclassifier.TextClassificationSession.SelectionEventHelper: boolean sanitizeEvent(SelectionEvent)>,28,29,<android.view.textclassifier.TextClassificationSession.SelectionEventHelper: boolean sanitizeEvent(SelectionEvent)>,<android.view.textclassifier.TextClassificationSession.SelectionEventHelper: boolean sanitizeEvent(SelectionEvent)>,0,"{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        if (DEBUG_LOG_ENABLED) {
            Log.d(LOG_TAG, ""Selection session not yet started. Ignoring event"");
        }
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
            mSmartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}","{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        Log.d(LOG_TAG, ""Selection session not yet started. Ignoring event"");
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            mSmartEvent = event;
            break;
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}",1,"/**
 * Updates the necessary fields in the event for the current session.
 *
 * @return true if the event should be reported. false if the event should be ignored
 */
","/**
 * Updates the necessary fields in the event for the current session.
 *
 * @return true if the event should be reported. false if the event should be ignored
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,There are multiple code changes here. The debug log statement for ignoring the event no longer checks for `DEBUG_LOG_ENABLED`. This The `case SelectionEvent.EVENT_SMART_SELECTION_MULTI:` has been modified to no longer have the special handling separate from `case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:` which previously was not there; these cases are now combined in the late version. These changes fall under Control dependency change (3) due to changes in the condition checking for debugging and changes in the switch-case logic as well as Other statement changed (4) due to modified and removed log statements.,"Despite the changes, including the control dependency and the debug log statement, there's no indication that the changes will affect the method's return value or the exceptions it may throw. The method's main logic flow remains unaffected, making the resultant behavior the same (assuming proper use where DEBUG_LOG_ENABLED will not alter significant execution flow outside of logging). Therefore, there is no Compatibility Issue arising from these changes."
278,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",28,29,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>","<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",0,"{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = InputMethodManager.peekInstance();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            mTextView.populateCharacterBounds(builder, composingTextStart, composingTextEnd, viewportToContentHorizontalOffset, viewportToContentVerticalOffset);
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottomWithoutSpacing(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}","{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = getInputMethodManager();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            mTextView.populateCharacterBounds(builder, composingTextStart, composingTextEnd, viewportToContentHorizontalOffset, viewportToContentVerticalOffset);
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottomWithoutSpacing(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
280,<android.app.DownloadManager: Cursor query(Query)>,28,29,<android.app.DownloadManager: Cursor query(Query)>,<android.app.DownloadManager: Cursor query(Query)>,0,"{
    Cursor underlyingCursor = query.runQuery(mResolver, UNDERLYING_COLUMNS, mBaseUri);
    if (underlyingCursor == null) {
        return null;
    }
    return new CursorTranslator(underlyingCursor, mBaseUri, mAccessFilename);
}","{
    return query(query, UNDERLYING_COLUMNS);
}",1,"/**
 * Query the download manager about downloads that have been requested.
 * @param query parameters specifying filters for this query
 * @return a Cursor over the result set of downloads, with columns consisting of all the
 * COLUMN_* constants.
 */
","/**
 * Query the download manager about downloads that have been requested.
 * @param query parameters specifying filters for this query
 * @return a Cursor over the result set of downloads, with columns consisting of all the
 * COLUMN_* constants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version implementation uses a local Cursor object to run the query and then creates a new CursorTranslator if the result is not null. The late version simply returns the result of a different query method directly without additional checks or CursorTranslator construction, indicating a change in dependent API as well as the return statement, so the code change type is 1,5.","Since the late version of the API does not perform a null check on the Cursor object and does not wrap it with a CursorTranslator, it is possible that it returns a different type of Cursor or null values differently than the early version. Therefore, the potential change in return values or types leads us to classify the CI type as 1."
281,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,28,29,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getWidthHint();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getWidthHint(mContext.getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
","/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change here is in the dependent API sGlobals.mService.getWidthHint(), which now takes an additional parameter mContext.getDisplayId(). This means there's a change in the dependent API being called, so the code change type is 5.","The change in method parameters for a dependent API call is not considered to directly cause a compatibility issue as long as the invoked method's contract is not altered, which means that the changes to this API's behavior solely depends on the changes within getWidthHint() method. Since no information about the internal changes to getWidthHint() is provided, assuming it adheres to its contract and does not lead to a compatibility issue is reasonable. Therefore, the CI type is 0."
282,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,28,29,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,<android.service.notification.ZenModeConfig.ZenRule: int hashCode()>,0,"{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, id, creationTime, enabler);
}","{
    return Objects.hash(enabled, snoozing, name, zenMode, conditionId, condition, component, configurationActivity, pkg, id, enabler, zenPolicy, modified);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() implementation has changed with new fields added to the hash, which are configurationActivity, pkg, zenPolicy, and modified, indicating a change in the method's internal logic. This is code change type 1. Additionally, the change involves modification within a return statement of a method, which is code change type 4.","The hash value returned by the method will differ if any of the newly added fields (configurationActivity, pkg, zenPolicy, modified) differ between objects that would otherwise be equal based on the old implementation. Therefore, objects that were considered equal in the earlier version might not be considered equal in the later version, which is a CI type 1."
283,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,28,29,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,<android.service.notification.NotificationListenerService.MyHandler: void handleMessage(Message)>,0,"{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                int reason = (int) args.arg3;
                NotificationStats stats = (NotificationStats) args.arg4;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap, stats, reason);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannel channel = (NotificationChannel) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelModified(pkgName, user, channel, modificationType);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannelGroup group = (NotificationChannelGroup) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelGroupModified(pkgName, user, group, modificationType);
            }
            break;
    }
}","{
    if (!isConnected) {
        return;
    }
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_POSTED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                args.recycle();
                onNotificationPosted(sbn, rankingMap);
            }
            break;
        case MSG_ON_NOTIFICATION_REMOVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                RankingMap rankingMap = (RankingMap) args.arg2;
                int reason = (int) args.arg3;
                NotificationStats stats = (NotificationStats) args.arg4;
                args.recycle();
                onNotificationRemoved(sbn, rankingMap, stats, reason);
            }
            break;
        case MSG_ON_LISTENER_CONNECTED:
            {
                onListenerConnected();
            }
            break;
        case MSG_ON_NOTIFICATION_RANKING_UPDATE:
            {
                RankingMap rankingMap = (RankingMap) msg.obj;
                onNotificationRankingUpdate(rankingMap);
            }
            break;
        case MSG_ON_LISTENER_HINTS_CHANGED:
            {
                final int hints = msg.arg1;
                onListenerHintsChanged(hints);
            }
            break;
        case MSG_ON_INTERRUPTION_FILTER_CHANGED:
            {
                final int interruptionFilter = msg.arg1;
                onInterruptionFilterChanged(interruptionFilter);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannel channel = (NotificationChannel) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelModified(pkgName, user, channel, modificationType);
            }
            break;
        case MSG_ON_NOTIFICATION_CHANNEL_GROUP_MODIFIED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String pkgName = (String) args.arg1;
                UserHandle user = (UserHandle) args.arg2;
                NotificationChannelGroup group = (NotificationChannelGroup) args.arg3;
                int modificationType = (int) args.arg4;
                onNotificationChannelGroupModified(pkgName, user, group, modificationType);
            }
            break;
        case MSG_ON_STATUS_BAR_ICON_BEHAVIOR_CHANGED:
            {
                onSilentStatusBarIconsVisibilityChanged((Boolean) msg.obj);
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
284,"<android.provider.MediaStore.Audio.Genres: Uri getContentUriForAudioId(String,int)>",28,29,"<android.provider.MediaStore.Audio.Genres: Uri getContentUriForAudioId(String,int)>","<android.provider.MediaStore.Audio.Genres: Uri getContentUriForAudioId(String,int)>",0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/media/"" + audioId + ""/genres"");
}","{
    return ContentUris.withAppendedId(Audio.Media.getContentUri(volumeName), audioId).buildUpon().appendPath(""genres"").build();
}",1,"/**
 * Get the content:// style URI for querying the genres of an audio file.
 *
 * @param volumeName the name of the volume to get the URI for
 * @param audioId the ID of the audio file for which to retrieve the genres
 * @return the URI to for querying the genres for the audio file
 * with the given the volume and audioID
 */
","/**
 * Get the content:// style URI for querying the genres of an audio file.
 *
 * @param volumeName the name of the volume to get the URI for
 * @param audioId the ID of the audio file for which to retrieve the genres
 * @return the URI to for querying the genres for the audio file
 * with the given the volume and audioID
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method of constructing the return `Uri` object has changed, involving the use of `ContentUris.withAppendedId(Audio.Media.getContentUri(volumeName), audioId)` and chaining methods to construct the `Uri`. Instead of directly parsing a string, it now uses a different method `Audio.Media.getContentUri` and additional method calls to construct the `Uri`. This change is classified under Return statement changed (1) and Dependent API changed (5) because `Audio.Media.getContentUri` is another API involved in building the resulting `Uri`.","The potential Compatibility Issue is caused by different return values (1). The construction process of the `Uri` has been altered, which could potentially result in different `Uri` values being returned. This change in the process may affect the structure and content of the `Uri`, thereby causing different results when the method is called."
285,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,28,29,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,0,"{
    if (mError == null) {
        try {
            if (mActions != null) {
                OnClickHandler handler = mHandler == null ? DEFAULT_ON_CLICK_HANDLER : mHandler;
                for (Action a : mActions) {
                    a.apply(viewTree.mRoot, mParent, handler);
                }
            }
        } catch (Exception e) {
            mError = e;
        }
    }
    if (mListener != null) {
        if (mError != null) {
            mListener.onError(mError);
        } else {
            mListener.onViewApplied(viewTree.mRoot);
        }
    } else if (mError != null) {
        if (mError instanceof ActionException) {
            throw (ActionException) mError;
        } else {
            throw new ActionException(mError);
        }
    }
}","{
    if (mError == null) {
        if (mListener != null) {
            mListener.onViewInflated(viewTree.mRoot);
        }
        try {
            if (mActions != null) {
                OnClickHandler handler = mHandler == null ? DEFAULT_ON_CLICK_HANDLER : mHandler;
                for (Action a : mActions) {
                    a.apply(viewTree.mRoot, mParent, handler);
                }
            }
        } catch (Exception e) {
            mError = e;
        }
    }
    if (mListener != null) {
        if (mError != null) {
            mListener.onError(mError);
        } else {
            mListener.onViewApplied(viewTree.mRoot);
        }
    } else if (mError != null) {
        if (mError instanceof ActionException) {
            throw (ActionException) mError;
        } else {
            throw new ActionException(mError);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a change in the placement of the if statement which calls mListener.onViewInflated(viewTree.mRoot); the rest of the code remains the same. The change is not related to return or exception handling statements, nor does it change the control dependency. It is a change in the ordering of statements, so it is classified as 4.","No Compatibility Issue arises from this change, as the execution flow and the behavior of the code have not been altered in a way that would lead to different return values or exception handling. mListener.onViewInflated(viewTree.mRoot) is called at a different point in the method, but ultimately it is still within the same conditional block (if mError == null), so there should be no functional difference in the code behavior. Thus, the CI type is 0."
287,<android.app.NotificationManager: List<NotificationChannelGroup> getNotificationChannelGroups()>,28,29,<android.app.NotificationManager: List<NotificationChannelGroup> getNotificationChannelGroups()>,<android.app.NotificationManager: List<NotificationChannelGroup> getNotificationChannelGroups()>,0,"{
    INotificationManager service = getService();
    try {
        return service.getNotificationChannelGroups(mContext.getPackageName()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INotificationManager service = getService();
    try {
        final ParceledListSlice<NotificationChannelGroup> parceledList = service.getNotificationChannelGroups(mContext.getPackageName());
        if (parceledList != null) {
            return parceledList.getList();
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return new ArrayList<>();
}",1,"/**
 * Returns all notification channel groups belonging to the calling app.
 */
","/**
 * Returns all notification channel groups belonging to the calling app.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method now introduces a new if condition to check for null before returning the list. A return statement in case of a null is added, which returns a new empty ArrayList. The control dependency and other statement have changed, so the code change type is 1,3,4.","The new if condition and a return statement for a null case can lead to a different return value in cases where parceledList is null; the old code would have thrown a NullPointerException, whereas the new code returns an empty list. Therefore, the CI type is 1."
289,"<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>",28,29,"<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>","<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>",0,"{
    try {
        if (ActivityManager.getService().setVrMode(mToken, enabled, requestedComponent) != 0) {
            throw new PackageManager.NameNotFoundException(requestedComponent.flattenToString());
        }
    } catch (RemoteException e) {
    // pass
    }
}","{
    try {
        if (ActivityTaskManager.getService().setVrMode(mToken, enabled, requestedComponent) != 0) {
            throw new PackageManager.NameNotFoundException(requestedComponent.flattenToString());
        }
    } catch (RemoteException e) {
    // pass
    }
}",1,"/**
 * Enable or disable virtual reality (VR) mode for this Activity.
 *
 * <p>VR mode is a hint to Android system to switch to a mode optimized for VR applications
 * while this Activity has user focus.</p>
 *
 * <p>It is recommended that applications additionally declare
 * {@link android.R.attr#enableVrMode} in their manifest to allow for smooth activity
 * transitions when switching between VR activities.</p>
 *
 * <p>If the requested {@link android.service.vr.VrListenerService} component is not available,
 * VR mode will not be started.  Developers can handle this case as follows:</p>
 *
 * <pre>
 * String servicePackage = ""com.whatever.app"";
 * String serviceClass = ""com.whatever.app.MyVrListenerService"";
 *
 * // Name of the component of the VrListenerService to start.
 * ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
 *
 * try {
 * setVrModeEnabled(true, myComponentName);
 * } catch (PackageManager.NameNotFoundException e) {
 * List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
 * boolean isInstalled = false;
 * for (ApplicationInfo app : installed) {
 * if (app.packageName.equals(servicePackage)) {
 * isInstalled = true;
 * break;
 * }
 * }
 * if (isInstalled) {
 * // Package is installed, but not enabled in Settings.  Let user enable it.
 * startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
 * } else {
 * // Package is not installed.  Send an intent to download this.
 * sentIntentToLaunchAppStore(servicePackage);
 * }
 * }
 * </pre>
 *
 * @param enabled {@code true} to enable this mode.
 * @param requestedComponent the name of the component to use as a
 * {@link android.service.vr.VrListenerService} while VR mode is enabled.
 *
 * @throws android.content.pm.PackageManager.NameNotFoundException if the given component
 * to run as a {@link android.service.vr.VrListenerService} is not installed, or has
 * not been enabled in user settings.
 *
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE_HIGH_PERFORMANCE
 * @see android.service.vr.VrListenerService
 * @see android.provider.Settings#ACTION_VR_LISTENER_SETTINGS
 * @see android.R.attr#enableVrMode
 */
","/**
 * Enable or disable virtual reality (VR) mode for this Activity.
 *
 * <p>VR mode is a hint to Android system to switch to a mode optimized for VR applications
 * while this Activity has user focus.</p>
 *
 * <p>It is recommended that applications additionally declare
 * {@link android.R.attr#enableVrMode} in their manifest to allow for smooth activity
 * transitions when switching between VR activities.</p>
 *
 * <p>If the requested {@link android.service.vr.VrListenerService} component is not available,
 * VR mode will not be started.  Developers can handle this case as follows:</p>
 *
 * <pre>
 * String servicePackage = ""com.whatever.app"";
 * String serviceClass = ""com.whatever.app.MyVrListenerService"";
 *
 * // Name of the component of the VrListenerService to start.
 * ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
 *
 * try {
 * setVrModeEnabled(true, myComponentName);
 * } catch (PackageManager.NameNotFoundException e) {
 * List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
 * boolean isInstalled = false;
 * for (ApplicationInfo app : installed) {
 * if (app.packageName.equals(servicePackage)) {
 * isInstalled = true;
 * break;
 * }
 * }
 * if (isInstalled) {
 * // Package is installed, but not enabled in Settings.  Let user enable it.
 * startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
 * } else {
 * // Package is not installed.  Send an intent to download this.
 * sentIntentToLaunchAppStore(servicePackage);
 * }
 * }
 * </pre>
 *
 * @param enabled {@code true} to enable this mode.
 * @param requestedComponent the name of the component to use as a
 * {@link android.service.vr.VrListenerService} while VR mode is enabled.
 *
 * @throws android.content.pm.PackageManager.NameNotFoundException if the given component
 * to run as a {@link android.service.vr.VrListenerService} is not installed, or has
 * not been enabled in user settings.
 *
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE_HIGH_PERFORMANCE
 * @see android.service.vr.VrListenerService
 * @see android.provider.Settings#ACTION_VR_LISTENER_SETTINGS
 * @see android.R.attr#enableVrMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block has changed from ActivityManager.getService().setVrMode() to ActivityTaskManager.getService().setVrMode(). Since this is an invocation to a different service, the code change type is 5 for Dependent API changed.","The service method that is called within the API has changed, but since both the original and the new service methods are expected to behave the same way (presumably ActivityTaskManager has replaced ActivityManager for this functionality in the new version), the fundamental behavior of setVrModeEnabled(boolean, ComponentName) is not altered. Therefore, no Compatibility Issue is expected to arise, so the CI type is 0."
290,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,28,29,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,<android.view.inputmethod.InputMethodManager: InputMethodSubtype getLastInputMethodSubtype()>,0,"{
    synchronized (mH) {
        try {
            return mService.getLastInputMethodSubtype();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    try {
        return mService.getLastInputMethodSubtype();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The 'synchronized' block has been removed from the method, so there is a control dependency change (type 3).","The removal of the 'synchronized' block does not result in a compatibility issue related to different return values or exception handling, as it only affects concurrent execution without changing the functional behavior of the method. Thus, the CI type is 0."
291,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",28,29,"<android.content.ContentResolver: Uri insert(Uri,ContentValues)>","<android.content.ContentResolver: Uri insert(Uri,ContentValues)>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.insert(url, values);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */
","/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row. May return <code>null</code> if the underlying
 * content provider returns <code>null</code>, or if it crashes.
 */
",-1,[@Nullable],"[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"3,5",0,"The code changes include a different flow of logic in dealing with `mWrapped` and the related `try-catch` block, and the calling of `acquireProvider(url)` and subsequent code are conditioned by `if (mWrapped != null)`. The change in the code flow points to a control dependency change (3). The try-catch blocks have been reordered and the conditions under which certain methods are called have changed, which means there is also a change in the dependent API (5), as the early version did not reference `mWrapped` and the late version does.","Although there are control flow changes and usage of a new field `mWrapped` in the late version, both versions ultimately return a `Uri` object or `null` and handle `RemoteException` the same wayby returning `null`. The new flow doesn't modify the types of outcomes (i.e., types of returned values or thrown exceptions) compared with the old version, thus no compatibility issues are detected. The method's return type and exception handling have not been altered in a way that would lead to different behavior perceived by the calling code. The addition of an override of a method doesn't affect compatibility either. Therefore, the CI type is 0."
293,<android.app.NotificationChannel: int hashCode()>,28,29,<android.app.NotificationChannel: int hashCode()>,<android.app.NotificationChannel: int hashCode()>,0,"{
    int result = getId() != null ? getId().hashCode() : 0;
    result = 31 * result + (getName() != null ? getName().hashCode() : 0);
    result = 31 * result + (getDescription() != null ? getDescription().hashCode() : 0);
    result = 31 * result + getImportance();
    result = 31 * result + (mBypassDnd ? 1 : 0);
    result = 31 * result + getLockscreenVisibility();
    result = 31 * result + (getSound() != null ? getSound().hashCode() : 0);
    result = 31 * result + (mLights ? 1 : 0);
    result = 31 * result + getLightColor();
    result = 31 * result + Arrays.hashCode(mVibration);
    result = 31 * result + getUserLockedFields();
    result = 31 * result + (mVibrationEnabled ? 1 : 0);
    result = 31 * result + (mShowBadge ? 1 : 0);
    result = 31 * result + (isDeleted() ? 1 : 0);
    result = 31 * result + (getGroup() != null ? getGroup().hashCode() : 0);
    result = 31 * result + (getAudioAttributes() != null ? getAudioAttributes().hashCode() : 0);
    result = 31 * result + (isBlockableSystem() ? 1 : 0);
    return result;
}","{
    int result = Objects.hash(getId(), getName(), mDesc, getImportance(), mBypassDnd, getLockscreenVisibility(), getSound(), mLights, getLightColor(), getUserLockedFields(), isFgServiceShown(), mVibrationEnabled, mShowBadge, isDeleted(), getGroup(), getAudioAttributes(), isBlockableSystem(), mAllowBubbles, mImportanceLockedByOEM, mImportanceLockedDefaultApp);
    result = 31 * result + Arrays.hashCode(mVibration);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() method implementation is modified, the body of the method is updated where the previous chained addition and multiplication operations to accumulate the hash were replaced by a single call to Objects.hash with multiple parameters followed by one addition with Arrays.hashCode(mVibration). This indicates a modification in the hash calculation logic, which qualifies as change type 1 (Return statement changed) and 4 (Other statement).","Since hashCode() method is expected to return a value derived from the object's state, any change to the method's return statement will affect the hash value generated for an instance of the NotificationChannel. Because the way the hash code is computed has been significantly altered, this API may return different hash values for the same NotificationChannel object before and after the change. Hence, CI type 1 (Compatibility Issue caused by potential different return values or types) is present."
294,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,28,29,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,<android.hardware.camera2.legacy.SurfaceTextureRenderer: void drawIntoSurfaces(CaptureCollector)>,0,"{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            try {
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                // Should never hit this.
                throw new IllegalStateException(""Surface abandoned, skipping drawFrame..."", e);
            }
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}","{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError(""before updateTexImage"");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, ""Dropping preview frame."");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            try {
                makeCurrent(holder.eglSurface);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                // Should never hit this.
                throw new IllegalStateException(""Surface abandoned, skipping drawFrame..."", e);
            }
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError(""glReadPixels"");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, ""Surface abandoned, dropping frame. "", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}",1,"/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
","/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
296,<android.view.WindowInsets: int getSystemWindowInsetTop()>,28,29,<android.view.WindowInsets: int getSystemWindowInsetTop()>,<android.view.WindowInsets: int getSystemWindowInsetTop()>,0,"{
    return mSystemWindowInsets.top;
}","{
    return getSystemWindowInsets().top;
}",1,"/**
 * Returns the top system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The top system window inset
 */
","/**
 * Returns the top system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The top system window inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The implementation now includes a call to getSystemWindowInsets() instead of directly accessing mSystemWindowInsets, which indicates the addition of a method call for getting the value, so the code change types are 3 (because of the change in accessing the value) and 5 (as there's a dependency on a different, possibly modified API getSystemWindowInsets()).","The change has introduced a potential Compatibility Issue due to the dependence on a potentially altered API (getSystemWindowInsets()) which could lead to a different return value, thus causing a CI of type 1."
297,<android.view.View: boolean isImportantForAutofill()>,28,29,<android.view.View: boolean isImportantForAutofill()>,<android.view.View: boolean isImportantForAutofill()>,0,"{
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        final int parentImportance = ((View) parent).getImportantForAutofill();
        if (parentImportance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || parentImportance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS) {
            return false;
        }
        parent = parent.getParent();
    }
    final int importance = getImportantForAutofill();
    // First, check the explicit states.
    if (importance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_YES) {
        return true;
    }
    if (importance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_NO) {
        return false;
    }
    // Then use some heuristics to handle AUTO.
    // Always include views that have an explicit resource id.
    final int id = mID;
    if (id != NO_ID && !isViewIdGenerated(id)) {
        final Resources res = getResources();
        String entry = null;
        String pkg = null;
        try {
            entry = res.getResourceEntryName(id);
            pkg = res.getResourcePackageName(id);
        } catch (Resources.NotFoundException e) {
        // ignore
        }
        if (entry != null && pkg != null && pkg.equals(mContext.getPackageName())) {
            return true;
        }
    }
    // If the app developer explicitly set hints for it, it's important.
    if (getAutofillHints() != null) {
        return true;
    }
    // Otherwise, assume it's not important...
    return false;
}","{
    // Check parent mode to ensure we're not hidden.
    ViewParent parent = mParent;
    while (parent instanceof View) {
        final int parentImportance = ((View) parent).getImportantForAutofill();
        if (parentImportance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || parentImportance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS) {
            if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)) {
                Log.v(AUTOFILL_LOG_TAG, ""View ("" + this + "") is not important for autofill "" + ""because parent "" + parent + ""'s importance is "" + parentImportance);
            }
            return false;
        }
        parent = parent.getParent();
    }
    final int importance = getImportantForAutofill();
    // First, check the explicit states.
    if (importance == IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_YES) {
        return true;
    }
    if (importance == IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS || importance == IMPORTANT_FOR_AUTOFILL_NO) {
        if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)) {
            Log.v(AUTOFILL_LOG_TAG, ""View ("" + this + "") is not important for autofill "" + ""because its importance is "" + importance);
        }
        return false;
    }
    // Then use some heuristics to handle AUTO.
    if (importance != IMPORTANT_FOR_AUTOFILL_AUTO) {
        Log.w(AUTOFILL_LOG_TAG, ""invalid autofill importance ("" + importance + "" on view "" + this);
        return false;
    }
    // Always include views that have an explicit resource id.
    final int id = mID;
    if (id != NO_ID && !isViewIdGenerated(id)) {
        final Resources res = getResources();
        String entry = null;
        String pkg = null;
        try {
            entry = res.getResourceEntryName(id);
            pkg = res.getResourcePackageName(id);
        } catch (Resources.NotFoundException e) {
        // ignore
        }
        if (entry != null && pkg != null && pkg.equals(mContext.getPackageName())) {
            return true;
        }
    }
    // If the app developer explicitly set hints for it, it's important.
    if (getAutofillHints() != null) {
        return true;
    }
    // Otherwise, assume it's not important...
    return false;
}",1,"/**
 * Hints the Android System whether the {@link android.app.assist.AssistStructure.ViewNode}
 * associated with this view is considered important for autofill purposes.
 *
 * <p>Generally speaking, a view is important for autofill if:
 * <ol>
 * <li>The view can be autofilled by an {@link android.service.autofill.AutofillService}.
 * <li>The view contents can help an {@link android.service.autofill.AutofillService}
 * determine how other views can be autofilled.
 * <ol>
 *
 * <p>For example, view containers should typically return {@code false} for performance reasons
 * (since the important info is provided by their children), but if its properties have relevant
 * information (for example, a resource id called {@code credentials}, it should return
 * {@code true}. On the other hand, views representing labels or editable fields should
 * typically return {@code true}, but in some cases they could return {@code false}
 * (for example, if they're part of a ""Captcha"" mechanism).
 *
 * <p>The value returned by this method depends on the value returned by
 * {@link #getImportantForAutofill()}:
 *
 * <ol>
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_YES} or
 * {@link #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS}, then it returns {@code true}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_NO} or
 * {@link #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS}, then it returns {@code false}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_AUTO}, then it uses some simple heuristics
 * that can return {@code true} in some cases (like a container with a resource id),
 * but {@code false} in most.
 * <li>otherwise, it returns {@code false}.
 * </ol>
 *
 * <p>When a view is considered important for autofill:
 * <ul>
 * <li>The view might automatically trigger an autofill request when focused on.
 * <li>The contents of the view are included in the {@link ViewStructure} used in an autofill
 * request.
 * </ul>
 *
 * <p>On the other hand, when a view is considered not important for autofill:
 * <ul>
 * <li>The view never automatically triggers autofill requests, but it can trigger a manual
 * request through {@link AutofillManager#requestAutofill(View)}.
 * <li>The contents of the view are not included in the {@link ViewStructure} used in an
 * autofill request, unless the request has the
 * {@link #AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS} flag.
 * </ul>
 *
 * @return whether the view is considered important for autofill.
 *
 * @see #setImportantForAutofill(int)
 * @see #IMPORTANT_FOR_AUTOFILL_AUTO
 * @see #IMPORTANT_FOR_AUTOFILL_YES
 * @see #IMPORTANT_FOR_AUTOFILL_NO
 * @see #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
 * @see #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
 * @see AutofillManager#requestAutofill(View)
 */
","/**
 * Hints the Android System whether the {@link android.app.assist.AssistStructure.ViewNode}
 * associated with this view is considered important for autofill purposes.
 *
 * <p>Generally speaking, a view is important for autofill if:
 * <ol>
 * <li>The view can be autofilled by an {@link android.service.autofill.AutofillService}.
 * <li>The view contents can help an {@link android.service.autofill.AutofillService}
 * determine how other views can be autofilled.
 * <ol>
 *
 * <p>For example, view containers should typically return {@code false} for performance reasons
 * (since the important info is provided by their children), but if its properties have relevant
 * information (for example, a resource id called {@code credentials}, it should return
 * {@code true}. On the other hand, views representing labels or editable fields should
 * typically return {@code true}, but in some cases they could return {@code false}
 * (for example, if they're part of a ""Captcha"" mechanism).
 *
 * <p>The value returned by this method depends on the value returned by
 * {@link #getImportantForAutofill()}:
 *
 * <ol>
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_YES} or
 * {@link #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS}, then it returns {@code true}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_NO} or
 * {@link #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS}, then it returns {@code false}
 * <li>if it returns {@link #IMPORTANT_FOR_AUTOFILL_AUTO}, then it uses some simple heuristics
 * that can return {@code true} in some cases (like a container with a resource id),
 * but {@code false} in most.
 * <li>otherwise, it returns {@code false}.
 * </ol>
 *
 * <p>When a view is considered important for autofill:
 * <ul>
 * <li>The view might automatically trigger an autofill request when focused on.
 * <li>The contents of the view are included in the {@link ViewStructure} used in an autofill
 * request.
 * </ul>
 *
 * <p>On the other hand, when a view is considered not important for autofill:
 * <ul>
 * <li>The view never automatically triggers autofill requests, but it can trigger a manual
 * request through {@link AutofillManager#requestAutofill(View)}.
 * <li>The contents of the view are not included in the {@link ViewStructure} used in an
 * autofill request, unless the request has the
 * {@link #AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS} flag.
 * </ul>
 *
 * @return whether the view is considered important for autofill.
 *
 * @see #setImportantForAutofill(int)
 * @see #IMPORTANT_FOR_AUTOFILL_AUTO
 * @see #IMPORTANT_FOR_AUTOFILL_YES
 * @see #IMPORTANT_FOR_AUTOFILL_NO
 * @see #IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS
 * @see #IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS
 * @see AutofillManager#requestAutofill(View)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes between the versions are the addition of logging statements (Log.v and Log.w) to provide verbose logs. These statements do not alter the return values or modify the control flow, hence the code change type is 4.","The added Log statements are not changing the API's behavior or the returning values; they are only providing extra logging capabilities. Therefore, they do not cause a compatibility issue. The CI type is 0."
298,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,28,29,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,0,"{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery(getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],-1,-1,-1,-1,-1,-1,5,0,"The method `startDiscovery()` is changed to `startDiscovery(getOpPackageName())` in the late version, indicating a change in the dependent API (the method that is being called is now different due to an additional parameter), so the code change type is 5.","There is no compatibility issue caused by this change because the method signature remains the same and the behavior change entirely depends on the new parameter passed to the dependent API. Assuming the `getOpPackageName()` obtains a package name necessary for the new version without impacting existing functionality, there shouldn't be any difference in the behavior observed by the clients of this API, hence no compatibility issues arise."
299,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolationWithTimingAttempt(ViolationInfo)>,0,"{
    Looper looper = Looper.myLooper();
    // go into this immediate mode?
    if (looper == null || (info.mPolicy & THREAD_PENALTY_MASK) == PENALTY_DEATH) {
        // unknown (redundant, already set)
        info.durationMillis = -1;
        onThreadPolicyViolation(info);
        return;
    }
    final ArrayList<ViolationInfo> records = violationsBeingTimed.get();
    if (records.size() >= MAX_OFFENSES_PER_LOOP) {
        // Not worth measuring.  Too many offenses in one loop.
        return;
    }
    records.add(info);
    if (records.size() > 1) {
        // at the end of this Looper's loop.
        return;
    }
    final IWindowManager windowManager = info.penaltyEnabled(PENALTY_FLASH) ? sWindowManager.get() : null;
    if (windowManager != null) {
        try {
            windowManager.showStrictModeViolation(true);
        } catch (RemoteException unused) {
        }
    }
    // We post a runnable to a Handler (== delay 0 ms) for
    // measuring the end time of a violation instead of using
    // an IdleHandler (as was previously used) because an
    // IdleHandler may not run for quite a long period of time
    // if an ongoing animation is happening and continually
    // posting ASAP (0 ms) animation steps.  Animations are
    // throttled back to 60fps via SurfaceFlinger/View
    // invalidates, _not_ by posting frame updates every 16
    // milliseconds.
    THREAD_HANDLER.get().postAtFrontOfQueue(() -> {
        long loopFinishTime = SystemClock.uptimeMillis();
        // to keep the red border on.
        if (windowManager != null) {
            try {
                windowManager.showStrictModeViolation(false);
            } catch (RemoteException unused) {
            }
        }
        for (int n = 0; n < records.size(); ++n) {
            ViolationInfo v = records.get(n);
            v.violationNumThisLoop = n + 1;
            v.durationMillis = (int) (loopFinishTime - v.violationUptimeMillis);
            onThreadPolicyViolation(v);
        }
        records.clear();
    });
}","{
    Looper looper = Looper.myLooper();
    // go into this immediate mode?
    if (looper == null || (info.mPenaltyMask == PENALTY_DEATH)) {
        // unknown (redundant, already set)
        info.durationMillis = -1;
        onThreadPolicyViolation(info);
        return;
    }
    final ArrayList<ViolationInfo> records = violationsBeingTimed.get();
    if (records.size() >= MAX_OFFENSES_PER_LOOP) {
        // Not worth measuring.  Too many offenses in one loop.
        return;
    }
    records.add(info);
    if (records.size() > 1) {
        // at the end of this Looper's loop.
        return;
    }
    final IWindowManager windowManager = info.penaltyEnabled(PENALTY_FLASH) ? sWindowManager.get() : null;
    if (windowManager != null) {
        try {
            windowManager.showStrictModeViolation(true);
        } catch (RemoteException unused) {
        }
    }
    // We post a runnable to a Handler (== delay 0 ms) for
    // measuring the end time of a violation instead of using
    // an IdleHandler (as was previously used) because an
    // IdleHandler may not run for quite a long period of time
    // if an ongoing animation is happening and continually
    // posting ASAP (0 ms) animation steps.  Animations are
    // throttled back to 60fps via SurfaceFlinger/View
    // invalidates, _not_ by posting frame updates every 16
    // milliseconds.
    THREAD_HANDLER.get().postAtFrontOfQueue(() -> {
        long loopFinishTime = SystemClock.uptimeMillis();
        // to keep the red border on.
        if (windowManager != null) {
            try {
                windowManager.showStrictModeViolation(false);
            } catch (RemoteException unused) {
            }
        }
        for (int n = 0; n < records.size(); ++n) {
            ViolationInfo v = records.get(n);
            v.violationNumThisLoop = n + 1;
            v.durationMillis = (int) (loopFinishTime - v.violationUptimeMillis);
            onThreadPolicyViolation(v);
        }
        records.clear();
    });
}",1,"// the next epoll_wait)
","// the next epoll_wait)
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change is in a control dependency: the way the penalty mask is checked has been changed from checking bits (`info.mPolicy & THREAD_PENALTY_MASK`) to direct equality comparison (`info.mPenaltyMask == PENALTY_DEATH`). This is a control dependency change, which falls under type 3.","There is no Compatibility Issue introduced by this change. Despite the change in the control dependency, the actual behaviour of the method (throwing exceptions, different return types/values) has not changed as the same conditional actions are performed. The check is for a specific condition that determines if the method should immediately handle the violation (which occurred in both versions of the method), so this change should not affect the method's external behaviour as far as returned results or thrown exceptions. Thus, the CI type is 0."
300,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",28,29,"<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>","<android.transition.Visibility: Animator onDisappear(ViewGroup,TransitionValues,int,TransitionValues,int)>",0,"{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else if (mCanRemoveViews) {
                overlayView = startView;
            } else {
                overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, (View) startView.getParent());
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                    transition.removeListener(this);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}","{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    if (startValues == null) {
        // startValues(and startView) will never be null for disappear transition.
        return null;
    }
    final View startView = startValues.view;
    final View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    boolean reusingOverlayView = false;
    View savedOverlayView = (View) startView.getTag(R.id.transition_overlay_view_tag);
    if (savedOverlayView != null) {
        // we've already created overlay for the start view.
        // it means that we are applying two visibility
        // transitions for the same view
        overlayView = savedOverlayView;
        reusingOverlayView = true;
    } else {
        boolean needOverlayForStartView = false;
        if (endView == null || endView.getParent() == null) {
            if (endView != null) {
                // endView was removed from its parent - add it to the overlay
                overlayView = endView;
            } else {
                needOverlayForStartView = true;
            }
        } else {
            // visibility change
            if (endVisibility == View.INVISIBLE) {
                viewToKeep = endView;
            } else {
                // Becoming GONE
                if (startView == endView) {
                    viewToKeep = endView;
                } else {
                    needOverlayForStartView = true;
                }
            }
        }
        if (needOverlayForStartView) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else {
                    int id = startParent.getId();
                    if (startParent.getParent() == null && id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    } else {
                    // TODO: Handle this case as well
                    }
                }
            }
        }
    }
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        final ViewGroupOverlay overlay;
        if (!reusingOverlayView) {
            overlay = sceneRoot.getOverlay();
            int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
            int screenX = screenLoc[0];
            int screenY = screenLoc[1];
            int[] loc = new int[2];
            sceneRoot.getLocationOnScreen(loc);
            overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
            overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
            overlay.add(overlayView);
        } else {
            overlay = null;
        }
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (!reusingOverlayView) {
            if (animator == null) {
                overlay.remove(overlayView);
            } else {
                startView.setTagInternal(R.id.transition_overlay_view_tag, overlayView);
                final View finalOverlayView = overlayView;
                addListener(new TransitionListenerAdapter() {

                    @Override
                    public void onTransitionPause(Transition transition) {
                        overlay.remove(finalOverlayView);
                    }

                    @Override
                    public void onTransitionResume(Transition transition) {
                        if (finalOverlayView.getParent() == null) {
                            overlay.add(finalOverlayView);
                        } else {
                            cancel();
                        }
                    }

                    @Override
                    public void onTransitionEnd(Transition transition) {
                        startView.setTagInternal(R.id.transition_overlay_view_tag, null);
                        overlay.remove(finalOverlayView);
                        transition.removeListener(this);
                    }
                });
            }
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = viewToKeep.getVisibility();
        viewToKeep.setTransitionVisibility(View.VISIBLE);
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, endVisibility, mSuppressLayout);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}",1,"/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
","/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
301,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",28,29,"<android.view.View: boolean onKeyDown(int,KeyEvent)>","<android.view.View: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if (event.getRepeatCount() == 0) {
            // Long clickable items don't necessarily have to be clickable.
            final boolean clickable = (mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE;
            if (clickable || (mViewFlags & TOOLTIP) == TOOLTIP) {
                // For the purposes of menu anchoring and drawable hotspots,
                // key events are considered to be at the center of the view.
                final float x = getWidth() / 2f;
                final float y = getHeight() / 2f;
                if (clickable) {
                    setPressed(true, x, y);
                }
                checkForLongClick(0, x, y);
                return true;
            }
        }
    }
    return false;
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if (event.getRepeatCount() == 0) {
            // Long clickable items don't necessarily have to be clickable.
            final boolean clickable = (mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE;
            if (clickable || (mViewFlags & TOOLTIP) == TOOLTIP) {
                // For the purposes of menu anchoring and drawable hotspots,
                // key events are considered to be at the center of the view.
                final float x = getWidth() / 2f;
                final float y = getHeight() / 2f;
                if (clickable) {
                    setPressed(true, x, y);
                }
                checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, // This is not a touch gesture -- do not classify it as one.
                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__UNKNOWN_CLASSIFICATION);
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between these two implementations is the additional parameters passed to the checkForLongClick method, which does not affect the return value or exception handling of the method, so the code change type is 4.","Since the change does not affect the control flow of the method nor does it introduce any new return statements or exception handling, the behavior of the API remains unchanged when it comes to its interactions with external code. Therefore, there's no compatibility issue, and the CI type is 0."
302,"<android.app.Activity: void performResume(boolean,String)>",28,29,"<android.app.Activity: void performResume(boolean,String)>","<android.app.Activity: void performResume(boolean,String)>",0,"{
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    if (mAutoFillResetNeeded) {
        // When Activity is destroyed in paused state, and relaunch activity, there will be
        // extra onResume and onPause event,  ignore the first onResume and onPause.
        // see ActivityThread.handleRelaunchActivity()
        mAutoFillIgnoreFirstResumePause = followedByPause;
        if (mAutoFillIgnoreFirstResumePause && DEBUG_LIFECYCLE) {
            Slog.v(TAG, ""autofill will ignore first pause when relaunching "" + this);
        }
    }
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    writeEventLog(LOG_AM_ON_RESUME_CALLED, reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
}","{
    dispatchActivityPreResumed();
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    if (mAutoFillResetNeeded) {
        // When Activity is destroyed in paused state, and relaunch activity, there will be
        // extra onResume and onPause event,  ignore the first onResume and onPause.
        // see ActivityThread.handleRelaunchActivity()
        mAutoFillIgnoreFirstResumePause = followedByPause;
        if (mAutoFillIgnoreFirstResumePause && DEBUG_LIFECYCLE) {
            Slog.v(TAG, ""autofill will ignore first pause when relaunching "" + this);
        }
    }
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    writeEventLog(LOG_AM_ON_RESUME_CALLED, reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
    dispatchActivityPostResumed();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version of the implementation, there are additional method calls at the beginning and the end of the method (`dispatchActivityPreResumed()` and `dispatchActivityPostResumed()`). These are considered to be ""Other statement changed"" since they do not alter return statement, exception handling statement, or control dependency. It's an addition of new behavior that does not directly impact the return type/value or the exceptions thrown.  ",No Compatibility Issue detected because neither the return value nor the exception handling behavior of the API has been modified. The additional method calls added are part of the internal flow and do not directly change the API's contract with the caller.
303,<android.util.StatsLog: boolean logStart(int)>,28,29,<android.util.StatsLog: boolean logStart(int)>,<android.util.StatsLog: boolean logStart(int)>,0,"{
    synchronized (StatsLog.class) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG)
                    Slog.d(TAG, ""Failed to find statsd when logging start"");
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__START);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG)
                Slog.d(TAG, ""Failed to connect to statsd when logging start"");
            return false;
        }
    }
}","{
    synchronized (sLogLock) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG) {
                    Slog.d(TAG, ""Failed to find statsd when logging start"");
                }
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__START);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG) {
                Slog.d(TAG, ""Failed to connect to statsd when logging start"");
            }
            return false;
        }
    }
}",1,"/**
 * Logs a start event.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */
","/**
 * Logs a start event.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the synchronization object used in the 'synchronized' block, which has changed from 'StatsLog.class' to 'sLogLock'. This is an example of an Other statement changed, which is type 4.","There is no Compatibility Issue because the change in the synchronization object doesn't affect the external behavior of the API method. The method's functionality, return value, and exception handling remain unchanged."
306,"<android.app.backup.BackupAgent.BackupServiceBinder: void doMeasureFullBackup(long,int,IBackupManager,int)>",28,29,"<android.app.backup.BackupAgent.BackupServiceBinder: void doMeasureFullBackup(long,int,IBackupManager,int)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doMeasureFullBackup(long,int,IBackupManager,int)>",0,"{
    // Ensure that we're running with the app's normal permission level
    final long ident = Binder.clearCallingIdentity();
    FullBackupDataOutput measureOutput = new FullBackupDataOutput(quotaBytes, transportFlags);
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(measureOutput);
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, measureOutput.getSize());
        } catch (RemoteException e) {
        // timeout, so we're safe
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    final long ident = Binder.clearCallingIdentity();
    FullBackupDataOutput measureOutput = new FullBackupDataOutput(quotaBytes, transportFlags);
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(measureOutput);
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, measureOutput.getSize());
        } catch (RemoteException e) {
        // timeout, so we're safe
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changed since the method opComplete(token, measureOutput.getSize()) was replaced with opCompleteForUser(getBackupUserId(), token, measureOutput.getSize()). Although there's a modification in the method called on the callbackBinder object, this change is related to the dependent APIs rather than the return statement or exception handing, which is why the code change type includes 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue arising from the change because neither the return value nor the exception handling of the doMeasureFullBackup method was altered in the context of how this API is used. The API doesn't return a value directly (it's a void method), and the exception behavior hasn't changed between versions. Therefore, the CI type is 0 (No Compatibility Issue)."
307,"<android.provider.BlockedNumberContract: boolean isBlocked(Context,String)>",28,29,"<android.provider.BlockedNumberContract: boolean isBlocked(Context,String)>","<android.provider.BlockedNumberContract: boolean isBlocked(Context,String)>",0,"{
    try {
        final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_IS_BLOCKED, phoneNumber, null);
        return res != null && res.getBoolean(RES_NUMBER_IS_BLOCKED, false);
    } catch (NullPointerException | IllegalArgumentException ex) {
        // The content resolver can throw an NPE or IAE; we don't want to crash Telecom if
        // either of these happen.
        Log.w(null, ""isBlocked: provider not ready."");
        return false;
    }
}","{
    try {
        final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_IS_BLOCKED, phoneNumber, null);
        boolean isBlocked = res != null && res.getBoolean(RES_NUMBER_IS_BLOCKED, false);
        Log.d(LOG_TAG, ""isBlocked: phoneNumber=%s, isBlocked=%b"", Log.piiHandle(phoneNumber), isBlocked);
        return isBlocked;
    } catch (NullPointerException | IllegalArgumentException ex) {
        // The content resolver can throw an NPE or IAE; we don't want to crash Telecom if
        // either of these happen.
        Log.w(null, ""isBlocked: provider not ready."");
        return false;
    }
}",1,"/**
 * Returns whether a given number is in the blocked list.
 *
 * <p> This matches the {@code phoneNumber} against the
 * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column, and the E164 representation of the
 * {@code phoneNumber} with the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
 *
 * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
 * context {@code context}, this method will throw a {@link SecurityException}.
 *
 * @return {@code true} if the {@code phoneNumber} is blocked.
 */
","/**
 * Returns whether a given number is in the blocked list.
 *
 * <p> This matches the {@code phoneNumber} against the
 * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column, and the E164 representation of the
 * {@code phoneNumber} with the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
 *
 * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
 * context {@code context}, this method will throw a {@link SecurityException}.
 *
 * @return {@code true} if the {@code phoneNumber} is blocked.
 */
",-1,[@WorkerThread],[@WorkerThread],-1,-1,-1,-1,-1,-1,4,0,"The addition of a logging statement `Log.d()` does not affect the execution flow or the return value of the function, so the change type is 4.",There is no Compatibility Issue since the added logging statement does not alter the behaviour of the method with respect to its return value or exception handling. The change is solely for logging purposes and has no impact on the API's functionality.
308,<android.app.Activity: void startLockTask()>,28,29,<android.app.Activity: void startLockTask()>,<android.app.Activity: void startLockTask()>,0,"{
    try {
        ActivityManager.getService().startLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityTaskManager.getService().startLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Request to put this activity in a mode where the user is locked to a restricted set of
 * applications.
 *
 * <p>If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns {@code true}
 * for this component, the current task will be launched directly into LockTask mode. Only apps
 * whitelisted by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])} can
 * be launched while LockTask mode is active. The user will not be able to leave this mode
 * until this activity calls {@link #stopLockTask()}. Calling this method while the device is
 * already in LockTask mode has no effect.
 *
 * <p>Otherwise, the current task will be launched into screen pinning mode. In this case, the
 * system will prompt the user with a dialog requesting permission to use this mode.
 * The user can exit at any time through instructions shown on the request dialog. Calling
 * {@link #stopLockTask()} will also terminate this mode.
 *
 * <p><strong>Note:</strong> this method can only be called when the activity is foreground.
 * That is, between {@link #onResume()} and {@link #onPause()}.
 *
 * @see #stopLockTask()
 * @see android.R.attr#lockTaskMode
 */
","/**
 * Request to put this activity in a mode where the user is locked to a restricted set of
 * applications.
 *
 * <p>If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns {@code true}
 * for this component, the current task will be launched directly into LockTask mode. Only apps
 * whitelisted by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])} can
 * be launched while LockTask mode is active. The user will not be able to leave this mode
 * until this activity calls {@link #stopLockTask()}. Calling this method while the device is
 * already in LockTask mode has no effect.
 *
 * <p>Otherwise, the current task will be launched into screen pinning mode. In this case, the
 * system will prompt the user with a dialog requesting permission to use this mode.
 * The user can exit at any time through instructions shown on the request dialog. Calling
 * {@link #stopLockTask()} will also terminate this mode.
 *
 * <p><strong>Note:</strong> this method can only be called when the activity is foreground.
 * That is, between {@link #onResume()} and {@link #onPause()}.
 *
 * @see #stopLockTask()
 * @see android.R.attr#lockTaskMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changes from calling ActivityManager.getService() to ActivityTaskManager.getService(). There is no change in exception handling or return statements, so the change type is 5.","Despite the dependent API changing, the exception handling and return behavior of the method remain the same. Since the method signature or logic inside the try block does not change the outcome or behavior of the API, there is no compatibility issue, so the CI type is 0."
309,<android.view.AccessibilityIterators.CharacterTextSegmentIterator: void onConfigurationChanged(Configuration)>,28,29,<android.view.AccessibilityIterators.CharacterTextSegmentIterator: void onConfigurationChanged(Configuration)>,<android.view.AccessibilityIterators.CharacterTextSegmentIterator: void onConfigurationChanged(Configuration)>,0,"{
    final Locale locale = globalConfig.getLocales().get(0);
    if (!mLocale.equals(locale)) {
        mLocale = locale;
        onLocaleChanged(locale);
    }
}","{
    final Locale locale = globalConfig.getLocales().get(0);
    if (locale == null) {
        return;
    }
    if (!mLocale.equals(locale)) {
        mLocale = locale;
        onLocaleChanged(locale);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The condition `if (locale == null)` has been added causing an early return, and that's a change in the control flow (type 3). Additionally, a 'return' statement was introduced (type 1).","The added return statement for the null 'locale' means that in a situation where 'locale' is null, the late version may exit the method early without calling 'onLocaleChanged(locale)', while the early version proceeds with potentially using a null locale, which is a behavioural change. Therefore, there is a Compatibility Issue caused by potential different return values or types (type 1)."
311,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,28,29,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByText(mConnectionId, mWindowId, mSourceNodeId, text);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByText(mConnectionId, mWindowId, mSourceNodeId, text);
}",1,"/**
 * Finds {@link AccessibilityNodeInfo}s by text. The match is case
 * insensitive containment. The search is relative to this info i.e.
 * this info is the root of the traversed tree.
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param text The searched text.
 * @return A list of node info.
 */
","/**
 * Finds {@link AccessibilityNodeInfo}s by text. The match is case
 * insensitive containment. The search is relative to this info i.e.
 * this info is the root of the traversed tree.
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param text The searched text.
 * @return A list of node info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The condition in the 'if' statement has changed, which affects when the method can perform the request over the connection because the method signature for canPerformRequestOverConnection() has changed (additional parameters are provided in the late version). Also, the invocation of the dependent API `canPerformRequestOverConnection` has changed, so the code change type is 3,5.","Since the method will return the same value (Collections.emptyList()) when the updated condition is met, and there is no change in the other parts of the code that would affect the return value or exception handling, there doesn't appear to be a CI caused by different return values or exception handling. Thus, the CI type is 0."
314,<android.content.ContentValues: Float getAsFloat(String)>,28,29,<android.content.ContentValues: Float getAsFloat(String)>,<android.content.ContentValues: Float getAsFloat(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).floatValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Float.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Float value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Float: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return value != null ? ((Number) value).floatValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Float.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Float value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Float: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Float.
 *
 * @param key the value to get
 * @return the Float value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Float.
 *
 * @param key the value to get
 * @return the Float value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change is from `mValues.get(key)` to `mMap.get(key)`, which is a change to the map object that is used to store the values. But the rest of the implementation logic remains the same. This is a dependent API change; hence the code change type is 4,5.","There is no Compatibility Issue as the change made does not affect the method's behavior. The method still attempts to retrieve the same key from essentially a map that holds the content values, casts it to a `Number`, and returns the `float` value or handles the impossibility of such casting in the same way. The map object change does not inherently affect the retrieval and casting logic; thus it does not lead to different return values or exception handling."
315,"<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>",28,29,"<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>","<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>",0,"{
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""APP PRIVATE COMMAND "" + action + "": "" + data);
            mCurMethod.appPrivateCommand(action, data);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.sendAppPrivateCommand(view, action, data);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""APP PRIVATE COMMAND "" + action + "": "" + data);
            mCurMethod.appPrivateCommand(action, data);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,"/**
 * Call {@link InputMethodSession#appPrivateCommand(String, Bundle)
 * InputMethodSession.appPrivateCommand()} on the current Input Method.
 * @param view Optional View that is sending the command, or null if
 * you want to send the command regardless of the view that is attached
 * to the input method.
 * @param action Name of the command to be performed.  This <em>must</em>
 * be a scoped name, i.e. prefixed with a package name you own, so that
 * different developers will not create conflicting commands.
 * @param data Any data to include with the command.
 */
","/**
 * Call {@link InputMethodSession#appPrivateCommand(String, Bundle)
 * InputMethodSession.appPrivateCommand()} on the current Input Method.
 * @param view Optional View that is sending the command, or null if
 * you want to send the command regardless of the view that is attached
 * to the input method.
 * @param action Name of the command to be performed.  This <em>must</em>
 * be a scoped name, i.e. prefixed with a package name you own, so that
 * different developers will not create conflicting commands.
 * @param data Any data to include with the command.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late implementation introduced a new code block before the existing code that conditionally redirects the command to a fallback input method manager and returns early. This is a control dependency change (specifically an additional 'if' condition) and also an 'other statement' change since there are new method calls and a conditional check added. The changes do not belong to the categories that define return statement, exception handling, or dependent API changes.","The new code performs a conditional action that does not inherently alter the behavior of the existing method implementation, as it only redirects to a fallback mechanism which is intended to handle the same command and is in line with the original method's purpose. Any existing behavior, such as the handling of input connections and invocation of mCurMethod is still encapsulated within the same control structure (synchronized block) and conditionals as before. So, there is no compatibility issue caused by potentially different return values or types, or by potentially different exception handlings."
317,<android.app.ActivityThread.CreateBackupAgentData: String toString()>,28,29,<android.app.ActivityThread.CreateBackupAgentData: String toString()>,<android.app.ActivityThread.CreateBackupAgentData: String toString()>,0,"{
    return ""CreateBackupAgentData{appInfo="" + appInfo + "" backupAgent="" + appInfo.backupAgentName + "" mode="" + backupMode + ""}"";
}","{
    return ""CreateBackupAgentData{appInfo="" + appInfo + "" backupAgent="" + appInfo.backupAgentName + "" mode="" + backupMode + "" userId="" + userId + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been modified with the addition of the string `"" userId="" + userId` in the late version. So the return statement has changed, making the code change type 1.","The addition of the `"" userId="" + userId` to the return string changes the output of the `toString()` method. Therefore, the late version API could potentially return a different string value than the early version, which means the CI type is 1."
318,<android.os.StrictMode.AndroidBlockGuardPolicy: void onResourceMismatch(Object)>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void onResourceMismatch(Object)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onResourceMismatch(Object)>,0,"{
    if ((mPolicyMask & DETECT_RESOURCE_MISMATCH) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new ResourceMismatchViolation(tag));
}","{
    if ((mThreadPolicyMask & DETECT_THREAD_RESOURCE_MISMATCH) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new ResourceMismatchViolation(tag));
}",1,"// Not part of BlockGuard.Policy; just part of StrictMode:
","// Not part of BlockGuard.Policy; just part of StrictMode:
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The member variable used in the condition statement is changed from `mPolicyMask` to `mThreadPolicyMask`, and a new constant `DETECT_THREAD_RESOURCE_MISMATCH` replaces `DETECT_RESOURCE_MISMATCH`. However, there are no changes in the control flow or logic because these are simply renaming of member variables and constants, which suggests they are fundamentally representing the same checks. This categorizes as control dependency change (3) and other statement change (4) because of the renaming, but the behavior is preserved.","There is no Compatibility Issue as the logic and control flow of the method are unaffected by these changes. The method will still return early based on the thread policy's configuration and handle the violation exception in the same manner as before, just using updated internal naming conventions."
322,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",28,29,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>","<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",0,"{
    try {
        getService().moveTaskToFront(taskId, flags, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        ActivityThread thread = ActivityThread.currentActivityThread();
        IApplicationThread appThread = thread.getApplicationThread();
        String packageName = mContext.getPackageName();
        getTaskService().moveTaskToFront(appThread, packageName, taskId, flags, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
","/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
",-1,[@RequiresPermission(android.Manifest.permission.REORDER_TASKS)],[@RequiresPermission(android.Manifest.permission.REORDER_TASKS)],-1,-1,-1,-1,-1,-1,"4,5",0,"The method getService().moveTaskToFront(...) has been replaced with getTaskService().moveTaskToFront(...), and additional parameters are passed to it. Also, new intermediate API calls to get the ActivityThread and IApplicationThread and package name are introduced. This accounts for 'Other statement changed' and 'Dependent API changed', so the code change type is 4,5.","Despite the change in the implementation, there is no reason to assume the new implementation would cause a different return value or type; the method is still void. The exception handling remains unchanged and will throw the same exception as before. Therefore, there is no Compatibility Issue, and the CI type is 0."
323,<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,28,29,<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,0,"{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        final int oldFlags = mConfigurationLocked.openFlags;
        final boolean walDisabled = (oldFlags & ENABLE_WRITE_AHEAD_LOGGING) == 0;
        final boolean compatibilityWalDisabled = (oldFlags & DISABLE_COMPATIBILITY_WAL) != 0;
        if (walDisabled && compatibilityWalDisabled) {
            return;
        }
        mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
        // If an app explicitly disables WAL, compatibility mode should be disabled too
        mConfigurationLocked.openFlags |= DISABLE_COMPATIBILITY_WAL;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags = oldFlags;
            throw ex;
        }
    }
}","{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        final int oldFlags = mConfigurationLocked.openFlags;
        final boolean walEnabled = (oldFlags & ENABLE_WRITE_AHEAD_LOGGING) != 0;
        final boolean compatibilityWalEnabled = (oldFlags & ENABLE_LEGACY_COMPATIBILITY_WAL) != 0;
        // WAL was never enabled for this database, so there's nothing left to do.
        if (!walEnabled && !compatibilityWalEnabled) {
            return;
        }
        // If an app explicitly disables WAL, it takes priority over any directive
        // to use the legacy ""compatibility WAL"" mode.
        mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
        mConfigurationLocked.openFlags &= ~ENABLE_LEGACY_COMPATIBILITY_WAL;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags = oldFlags;
            throw ex;
        }
    }
}",1,"/**
 * This method disables the features enabled by {@link #enableWriteAheadLogging()}.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #enableWriteAheadLogging
 */
","/**
 * This method disables the features enabled by {@link #enableWriteAheadLogging()}.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #enableWriteAheadLogging
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The change involves the conditions that determine whether the method returns early, the change of the flags being modified in the configuration, and the name of the flags (from DISABLE_COMPATIBILITY_WAL to ENABLE_LEGACY_COMPATIBILITY_WAL and walDisabled/walEnabled variable names). Additionally, the dependent API enable/disable flag constants might have been changed. Therefore, the code change type is 1,3,5.","Considering the behavior was originally dependent on whether WAL was previously disabled, and now it depends on whether WAL was enabled, the method's behavior will differ based on these conditions. The change in the flags and the check can lead to different return values and conditions under which the method performs its operations. A different logic in setting the open flags of the configuration will result in different database states after the execution of this method. Hence, the CI type is 1."
324,<android.widget.ListPopupWindow: void show()>,28,29,<android.widget.ListPopupWindow: void show()>,<android.widget.ListPopupWindow: void show()>,0,"{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
        mPopup.getContentView().restoreDefaultFocus();
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        mPopup.getContentView().restoreDefaultFocus();
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}","{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
        mPopup.getContentView().restoreDefaultFocus();
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setIsClippedToScreen(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        mPopup.getContentView().restoreDefaultFocus();
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}",1,"/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */
","/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
325,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",28,29,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>","<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",0,"{
    return isLocationProviderEnabledForUser(cr, provider, cr.getUserId());
}","{
    String allowedProviders = Settings.Secure.getStringForUser(cr, LOCATION_PROVIDERS_ALLOWED, cr.getUserId());
    return TextUtils.delimitedStringContains(allowedProviders, ',', provider);
}",1,"/**
 * Helper method for determining if a location provider is enabled.
 *
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 *
 * @deprecated use {@link LocationManager#isProviderEnabled(String)}
 */
","/**
 * Helper method for determining if a location provider is enabled.
 *
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 *
 * @deprecated use {@link LocationManager#isProviderEnabled(String)}
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has completely changed from calling ""isLocationProviderEnabledForUser(cr, provider, cr.getUserId())"" to using Settings.Secure.getStringForUser and TextUtils to determine if the provider is enabled. So the code change types include 1 (return statement changed) and 5 (dependent API changed).","Since the method now relies on a different approach to determine if the location provider is enabled, the return value might differ, and hence there is a potential compatibility issue with type 1 (Compatibility Issue caused by potential different return values)."
326,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,28,29,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,0,"{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        case DO_NOTIFY_IME_HIDDEN:
            {
                mInputMethodSession.notifyImeHidden();
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",2,"There is a removal of DO_FINISH_INPUT case which implies a change in behavior of the switch statement, and therefore, other statements under the control of the switch case 'DO_FINISH_INPUT' have been removed too. This is classified as other statement changed (4). Additionally, there's an addition of DO_NOTIFY_IME_HIDDEN case, which is a new return statement introduced. This is classified as return statement changed (1).","The deletion of the DO_FINISH_INPUT case and its associated mInputMethodSession.finishInput(); method call suggests that under some conditions where this case would have been executed, the method will no longer perform the 'finishInput' action on the mInputMethodSession which could lead to different behavior. These changes are not strictly return type/value changes but could lead to a change in behavior which may cause an issue with compatibility. The addition of DO_NOTIFY_IME_HIDDEN case potentially throws a different exception (unhandled method execution) if the 'notifyImeHidden' method is not implemented in some subclasses, which could lead to different behavior as well. Therefore, the CI type is due to potential different exception handlings (2)."
330,<android.bluetooth.le.ScanRecord: byte[] getManufacturerSpecificData(int)>,28,29,<android.bluetooth.le.ScanRecord: byte[] getManufacturerSpecificData(int)>,<android.bluetooth.le.ScanRecord: byte[] getManufacturerSpecificData(int)>,0,"{
    return mManufacturerSpecificData.get(manufacturerId);
}","{
    if (mManufacturerSpecificData == null) {
        return null;
    }
    return mManufacturerSpecificData.get(manufacturerId);
}",1,"/**
 * Returns the manufacturer specific data associated with the manufacturer id. Returns
 * {@code null} if the {@code manufacturerId} is not found.
 */
","/**
 * Returns the manufacturer specific data associated with the manufacturer id. Returns
 * {@code null} if the {@code manufacturerId} is not found.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,3,0,"A control dependency has been added in the form of an 'if' statement that checks if 'mManufacturerSpecificData' is null, which then returns null if true, so the change type is 3.","Although there is a change in the control flow, it will not result in a compatibility issue. In the early version, if 'mManufacturerSpecificData' were null, a NullPointerException would be thrown when trying to call 'get' on it. The late version handles this case explicitly and will return null instead of throwing an exception. This makes the late version more robust, but since it's handling an error case that previously wasn't managed, it would not change the behavior of correctly functioning code. Therefore, there is no compatibility issue caused by potentially different return values or types, CI type is 0."
331,"<android.provider.BlockedNumberContract: int unblock(Context,String)>",28,29,"<android.provider.BlockedNumberContract: int unblock(Context,String)>","<android.provider.BlockedNumberContract: int unblock(Context,String)>",0,"{
    final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_UNBLOCK, phoneNumber, null);
    return res.getInt(RES_NUM_ROWS_DELETED, 0);
}","{
    Log.d(LOG_TAG, ""unblock: phoneNumber=%s"", Log.piiHandle(phoneNumber));
    final Bundle res = context.getContentResolver().call(AUTHORITY_URI, METHOD_UNBLOCK, phoneNumber, null);
    return res.getInt(RES_NUM_ROWS_DELETED, 0);
}",1,"/**
 * Unblocks the {@code phoneNumber} if it is blocked.
 *
 * <p> This deletes all rows where the {@code phoneNumber} matches the
 * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column or the E164 representation of the
 * {@code phoneNumber} matches the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
 *
 * <p>To delete rows based on exact match with specific columns such as
 * {@link BlockedNumbers#COLUMN_ID} use
 * {@link android.content.ContentProvider#delete(Uri, String, String[])} with
 * {@link BlockedNumbers#CONTENT_URI} URI.
 *
 * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
 * context {@code context}, this method will throw a {@link SecurityException}.
 *
 * @return the number of rows deleted in the blocked number provider as a result of unblock.
 */
","/**
 * Unblocks the {@code phoneNumber} if it is blocked.
 *
 * <p> This deletes all rows where the {@code phoneNumber} matches the
 * {@link BlockedNumbers#COLUMN_ORIGINAL_NUMBER} column or the E164 representation of the
 * {@code phoneNumber} matches the {@link BlockedNumbers#COLUMN_E164_NUMBER} column.
 *
 * <p>To delete rows based on exact match with specific columns such as
 * {@link BlockedNumbers#COLUMN_ID} use
 * {@link android.content.ContentProvider#delete(Uri, String, String[])} with
 * {@link BlockedNumbers#CONTENT_URI} URI.
 *
 * <p> Note that if the {@link #canCurrentUserBlockNumbers} is {@code false} for the user
 * context {@code context}, this method will throw a {@link SecurityException}.
 *
 * @return the number of rows deleted in the blocked number provider as a result of unblock.
 */
",-1,[@WorkerThread],[@WorkerThread],-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of a log statement, which does not affect the method's behavior. Thus, the code change type is 4.","The addition of a logging statement does not affect the method's return value or its exception handling behavior. Therefore, there is no Compatibility Issue, and the CI type is 0."
332,<android.provider.MediaStore.Audio.Artists: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Audio.Artists: Uri getContentUri(String)>,<android.provider.MediaStore.Audio.Artists: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/artists"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""audio"").appendPath(""artists"").build();
}",1,"/**
 * Get the content:// style URI for the artists table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio artists table on the given volume
 */
","/**
 * Get the content:// style URI for the artists table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio artists table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The way of constructing the Uri has changed from direct parsing of a string to using a builder pattern with the AUTHORITY_URI variable, which involves a changed dependent API, so the change type is 1,5. ","This change in constructing the Uri can result in returned Uri having a potentially different value if the underlying implementation of buildUpon() or any related Uri building methods changed. This is a Compatibility Issue caused by potential different return values, thus the CI type is 1."
334,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getInputMethodList()>,28,29,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getInputMethodList()>,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getInputMethodList()>,0,"{
    try {
        return mService.getInputMethodList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        // instead.
        return mService.getInputMethodList(UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,"/**
 * Returns the list of installed input methods.
 *
 * <p>On multi user environment, this API returns a result for the calling process user.</p>
 *
 * @return {@link List} of {@link InputMethodInfo}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getInputMethodList() now takes an additional parameter in the late version. This parameter is not a change in return type or exception handling but in the signature of the dependent API, so the code change type is 5.","There is no compatibility issue as the additional parameter passed is generated internally within the method, and there's no change in the method signature, return type, or the exception handling in the calling code. The modification is an internal change within the API implementation that doesn't affect the callers of this method. The early and late versions of the API method `getInputMethodList()` still return the same type (`List<InputMethodInfo>`), and the exception handling hasn't been changed."
335,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,28,29,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,0,"{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",condition="").append(condition).append("",component="").append(component).append("",id="").append(id).append("",creationTime="").append(creationTime).append("",enabler="").append(enabler).append(']').toString();
}","{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""id="").append(id).append("",enabled="").append(String.valueOf(enabled).toUpperCase()).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",condition="").append(condition).append("",pkg="").append(pkg).append("",component="").append(component).append("",configActivity="").append(configurationActivity).append("",creationTime="").append(creationTime).append("",enabler="").append(enabler).append("",zenPolicy="").append(zenPolicy).append("",modified="").append(modified).append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the toString() method has been modified, including the order of the fields appended to the StringBuilder, the value of enabled transformed to uppercase, and the addition of new fields such as pkg, configActivity, zenPolicy, and modified. Therefore, the code changes involve changes in other statements (appending different strings to the StringBuilder) and return statement (as the resulting string returned will be different), so the change type is 1,4.","These modifications to the toString() method will change the output of the string representation of the ZenRule object. Since toString() is expected to return a string that accurately represents the current state of an object, any change in the implementation will result in a different string being returned. The change in the representation format and additional information in the late version qualifies as a change type 1, which is a Compatibility Issue caused by potentially different return values."
337,"<android.view.ViewGroup: int getChildDrawingOrder(int,int)>",28,29,"<android.view.ViewGroup: int getChildDrawingOrder(int,int)>","<android.view.ViewGroup: int getChildDrawingOrder(int,int)>",0,"{
    return i;
}","{
    return drawingPosition;
}",1,"/**
 * Returns the index of the child to draw for this iteration. Override this
 * if you want to change the drawing order of children. By default, it
 * returns i.
 * <p>
 * NOTE: In order for this method to be called, you must enable child ordering
 * first by calling {@link #setChildrenDrawingOrderEnabled(boolean)}.
 *
 * @param i The current iteration.
 * @return The index of the child to draw this iteration.
 *
 * @see #setChildrenDrawingOrderEnabled(boolean)
 * @see #isChildrenDrawingOrderEnabled()
 */
","/**
 * Converts drawing order position to container position. Override this
 * if you want to change the drawing order of children. By default, it
 * returns drawingPosition.
 * <p>
 * NOTE: In order for this method to be called, you must enable child ordering
 * first by calling {@link #setChildrenDrawingOrderEnabled(boolean)}.
 *
 * @param drawingPosition the drawing order position.
 * @return the container position of a child for this drawing order position.
 *
 * @see #setChildrenDrawingOrderEnabled(boolean)
 * @see #isChildrenDrawingOrderEnabled()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The variable returned has changed from 'i' in the early version to 'drawingPosition' in the late version. This is neither a return statement change in terms of introducing or deleting return statements, nor an exception handling, control dependency, or dependent API change. Thus, the code change type is 4. However, it reflects a change in the logic that is supposed to be encapsulated within the method based on variable renaming, and it is assumed that 'drawingPosition' correctly refers to the second parameter 'i'.","Considering that only the name of the variable returned has changed but not the core logic (assuming 'drawingPosition' correctly refers to the second parameter 'i'), technically no Compatibility Issue should arise due to this change. Thus, no potential different return values or types are expected  if 'drawingPosition' is indeed just a renamed representation of 'i'. However, without explicit information that 'drawingPosition' is indeed equivalent to 'i', there's a possibility of a Compatibility Issue, and therefore the safe classification would be 1 for potential Compatibility Issue caused by potentially different return values."
338,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,28,29,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,0,"{
    if (VDBG)
        log(""getConnectedDevices()"");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getConnectedDevices();
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    } finally {
        mServiceLock.readLock().unlock();
    }
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getConnectedDevices();
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changed from acquiring the service lock and using the 'mService' directly to using a local 'service' variable retrieved via 'getService()'. There's also a change in how the service instance is obtained, but the behavior of the code appears to be consistent with the previous version. The dependent API ('getService()') has potentially changed since it is not part of the previous implementation. Thus, the change type is 4,5.","There does not seem to be a Compatibility Issue because the method's core behavior - checking if 'service' is not null, if the adapter is enabled, and making the same calls - has not changed. The return paths, both for normal operation and exception handling, are the same. Therefore, the API should not return a different value or throw a different exception based on these changes."
339,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>",28,29,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>","<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>",0,"{
    if (handlePreAuthenticationErrors(callback, executor)) {
        return;
    }
    mFingerprintManager.authenticate(cancel, mBundle, executor, mDialogReceiver, callback);
}","{
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    authenticateInternal(null, /* crypto */
    cancel, executor, callback, mContext.getUserId(), null);
}",1,"/**
 * This call warms up the fingerprint hardware, displays a system-provided dialog, and starts
 * scanning for a fingerprint. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)} is called, or when
 * the user dismisses the system-provided dialog.  This operation can be canceled by using the
 * provided cancel object. The application will receive authentication errors through {@link
 * AuthenticationCallback}, and button events through the corresponding callback set in {@link
 * Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.  It is
 * safe to reuse the {@link BiometricPrompt} object, and calling {@link
 * BiometricPrompt#authenticate(CancellationSignal, Executor, AuthenticationCallback)} while
 * an existing authentication attempt is occurring will stop the previous client and start a new
 * authentication. The interrupted client will receive a cancelled notification through {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)}.
 *
 * @throws IllegalArgumentException If any of the arguments are null
 *
 * @param cancel An object that can be used to cancel authentication
 * @param executor An executor to handle callback events
 * @param callback An object to receive authentication events
 */
","/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)} is called, or when
 * the user dismisses the system-provided dialog.  This operation can be canceled by using the
 * provided cancel object. The application will receive authentication errors through {@link
 * AuthenticationCallback}, and button events through the corresponding callback set in {@link
 * Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.  It is
 * safe to reuse the {@link BiometricPrompt} object, and calling {@link
 * BiometricPrompt#authenticate(CancellationSignal, Executor, AuthenticationCallback)} while
 * an existing authentication attempt is occurring will stop the previous client and start a new
 * authentication. The interrupted client will receive a cancelled notification through {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)}.
 *
 * Note: Applications generally should not cancel and start authentication in quick succession.
 * For example, to properly handle authentication across configuration changes, it's recommended
 * to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so, the
 * application will not need to cancel/restart authentication during the configuration change.
 *
 * @throws IllegalArgumentException If any of the arguments are null
 *
 * @param cancel An object that can be used to cancel authentication
 * @param executor An executor to handle callback events
 * @param callback An object to receive authentication events
 */
",-1,[@RequiresPermission(USE_BIOMETRIC)],[@RequiresPermission(USE_BIOMETRIC)],-1,-1,-1,-1,-1,-1,"2,4,5","1,2","The implementation change includes the deletion of a call to ""handlePreAuthenticationErrors"" and the addition of direct ""throw"" statements for input arguments checking, as well as a call to ""authenticateInternal"" instead of ""mFingerprintManager.authenticate"". Thus, the code change type is 2 for exception handling statement changes, 4 for other statement changes such as the direct throws for null checks, and 5 for the internal method call changes.","CI type 1 arises due to the deletion of pre-existing early version's control flow which returned early from the method without making further calls, potentially leading to a different return behavior (i.e., an early termination of the execution). Additionally, CI type 2 is due to the introduction of direct argument null checks with new ""throw"" statements for ""IllegalArgumentException"", which could result in different exceptions being thrown compared to the early version."
341,<android.text.Layout: float getLineLeft(int)>,28,29,<android.text.Layout: float getLineLeft(int)>,<android.text.Layout: float getLineLeft(int)>,0,"{
    int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    if (align == Alignment.ALIGN_LEFT) {
        return 0;
    } else if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return getParagraphRight(line) - getLineMax(line);
        else
            return 0;
    } else if (align == Alignment.ALIGN_RIGHT) {
        return mWidth - getLineMax(line);
    } else if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return 0;
        else
            return mWidth - getLineMax(line);
    } else {
        /* align == Alignment.ALIGN_CENTER */
        int left = getParagraphLeft(line);
        int right = getParagraphRight(line);
        int max = ((int) getLineMax(line)) & ~1;
        return left + ((right - left) - max) / 2;
    }
}","{
    final int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    // To keep consistency, we convert a null alignment to ALIGN_CENTER.
    if (align == null) {
        align = Alignment.ALIGN_CENTER;
    }
    // First convert combinations of alignment and direction settings to
    // three basic cases: ALIGN_LEFT, ALIGN_RIGHT and ALIGN_CENTER.
    // For unexpected cases, it will fallback to ALIGN_LEFT.
    final Alignment resultAlign;
    switch(align) {
        case ALIGN_NORMAL:
            resultAlign = dir == DIR_RIGHT_TO_LEFT ? Alignment.ALIGN_RIGHT : Alignment.ALIGN_LEFT;
            break;
        case ALIGN_OPPOSITE:
            resultAlign = dir == DIR_RIGHT_TO_LEFT ? Alignment.ALIGN_LEFT : Alignment.ALIGN_RIGHT;
            break;
        case ALIGN_CENTER:
            resultAlign = Alignment.ALIGN_CENTER;
            break;
        case ALIGN_RIGHT:
            resultAlign = Alignment.ALIGN_RIGHT;
            break;
        default:
            /* align == Alignment.ALIGN_LEFT */
            resultAlign = Alignment.ALIGN_LEFT;
    }
    // plus the leading margin.
    switch(resultAlign) {
        case ALIGN_CENTER:
            final int left = getParagraphLeft(line);
            final float max = getLineMax(line);
            // please change here too.
            return (float) Math.floor(left + (mWidth - max) / 2);
        case ALIGN_RIGHT:
            return mWidth - getLineMax(line);
        default:
            /* resultAlign == Alignment.ALIGN_LEFT */
            return 0;
    }
}",1,"/**
 * Get the leftmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
","/**
 * Get the leftmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The late implementation has a remodeled the control flow logic and introduces a null check, reassigns the value of 'align', and refactors the 'if' conditions into a 'switch' statement that affects how 'resultAlign' is determined. Additionally, the method in which `getLineMax(line)` is used has been altered (wrapped with Math.floor in ALIGN_CENTER case), and there are changes in the statements within ALIGN_CENTER case's 'switch' body, so the code change includes 1, 3, 4, and 5.","As the late version introduces different logic for determining 'resultAlign' and changes the calculation of the return value in the ALIGN_CENTER case by using `Math.floor()`, the API may potentially return different values. Therefore, the CI type is 1."
342,<android.app.ActivityManager: AppTask> getAppTasks()>,28,29,<android.app.ActivityManager: AppTask> getAppTasks()>,<android.app.ActivityManager: AppTask> getAppTasks()>,0,"{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IBinder> appTasks;
    try {
        appTasks = getService().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i))));
    }
    return tasks;
}","{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IBinder> appTasks;
    try {
        appTasks = getTaskService().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i))));
    }
    return tasks;
}",1,"/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
","/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change involves changing the method call from getService().getAppTasks() to getTaskService().getAppTasks(). There is no indication that there are changes in the return type, logic of control flow, or the exception thrown, hence no change of 1, 2, 3, or 4 types. The change is 5 because a dependent API, the method to obtain the service, has been modified.","No Compatibility Issue is detected because the change does not affect the return value or the exception management of the method. The method still throws the same exception in case of a RemoteException and appTasks processing remains the same. Hence, despite the calling method to the service is altered, its return type and the subsequent operations on the list appTasks haven't changed. Therefore, no CI as per the provided definitions."
343,<android.app.ActivityOptions: Bundle toBundle()>,28,29,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    b.putInt(KEY_SPLIT_SCREEN_CREATE_MODE, mSplitScreenCreateMode);
    b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mSplitScreenCreateMode != SPLIT_SCREEN_CREATE_MODE_TOP_OR_LEFT) {
        b.putInt(KEY_SPLIT_SCREEN_CREATE_MODE, mSplitScreenCreateMode);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
345,<android.view.View: boolean onTouchEvent(MotionEvent)>,28,29,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(0, x, y);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                if (ambiguousGesture && hasPendingLongPressCallback()) {
                    final float ambiguousMultiplier = ViewConfiguration.getAmbiguousGestureMultiplier();
                    if (!pointInView(x, y, touchSlop)) {
                        // The default action here is to cancel long press. But instead, we
                        // just extend the timeout here, in case the classification
                        // stays ambiguous.
                        removeLongPressCallback();
                        long delay = (long) (ViewConfiguration.getLongPressTimeout() * ambiguousMultiplier);
                        // Subtract the time already spent
                        delay -= event.getEventTime() - event.getDownTime();
                        checkForLongClick(delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    }
                    touchSlop *= ambiguousMultiplier;
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, touchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                if (deepPress && hasPendingLongPressCallback()) {
                    // process the long click action immediately
                    removeLongPressCallback();
                    checkForLongClick(0, /* send immediately */
                    x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
346,<android.app.Notification: String toString()>,28,29,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(channel="");
    sb.append(getChannelId());
    sb.append("" pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    if (this.tickerText != null) {
        sb.append("" tick"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(channel="");
    sb.append(getChannelId());
    sb.append("" pri="");
    sb.append(priority);
    sb.append("" contentView="");
    if (contentView != null) {
        sb.append(contentView.getPackage());
        sb.append(""/0x"");
        sb.append(Integer.toHexString(contentView.getLayoutId()));
    } else {
        sb.append(""null"");
    }
    sb.append("" vibrate="");
    if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else {
        sb.append(""null"");
    }
    sb.append("" sound="");
    if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else if (this.sound != null) {
        sb.append(this.sound.toString());
    } else {
        sb.append(""null"");
    }
    if (this.tickerText != null) {
        sb.append("" tick"");
    }
    sb.append("" defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("" flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append(String.format("" color=0x%08x"", this.color));
    if (this.category != null) {
        sb.append("" category="");
        sb.append(this.category);
    }
    if (this.mGroupKey != null) {
        sb.append("" groupKey="");
        sb.append(this.mGroupKey);
    }
    if (this.mSortKey != null) {
        sb.append("" sortKey="");
        sb.append(this.mSortKey);
    }
    if (actions != null) {
        sb.append("" actions="");
        sb.append(actions.length);
    }
    sb.append("" vis="");
    sb.append(visibilityToString(this.visibility));
    if (this.publicVersion != null) {
        sb.append("" publicVersion="");
        sb.append(publicVersion.toString());
    }
    if (this.mLocusId != null) {
        sb.append("" locusId="");
        // LocusId.toString() is PII safe.
        sb.append(this.mLocusId);
    }
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,Only the `StringBuilder` manipulation has changed by adding information regarding `this.mLocusId` if it's not null. So the change type is 4.,"Although an extra piece of information (`mLocusId`) has been added to the `StringBuilder`, this is simply an additional attribute for the `toString()` representation and does not affect the behavior of this API. There is no change in the return type or the handling of exceptions, meaning no Compatibility Issue arises."
347,<android.app.admin.DevicePolicyManager: boolean isNetworkLoggingEnabled(ComponentName)>,28,29,<android.app.admin.DevicePolicyManager: boolean isNetworkLoggingEnabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isNetworkLoggingEnabled(ComponentName)>,0,"{
    throwIfParentInstance(""isNetworkLoggingEnabled"");
    try {
        return mService.isNetworkLoggingEnabled(admin);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""isNetworkLoggingEnabled"");
    try {
        return mService.isNetworkLoggingEnabled(admin, mContext.getPackageName());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Return whether network logging is enabled by a device owner.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Can only
 * be {@code null} if the caller has MANAGE_USERS permission.
 * @return {@code true} if network logging is enabled by device owner, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner and caller has
 * no MANAGE_USERS permission
 */
","/**
 * Return whether network logging is enabled by a device owner.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Can only
 * be {@code null} if the caller is a delegated app with {@link #DELEGATION_NETWORK_LOGGING}
 * or has MANAGE_USERS permission.
 * @return {@code true} if network logging is enabled by device owner, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner and caller has
 * no MANAGE_USERS permission
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mService.isNetworkLoggingEnabled` now takes an additional parameter `mContext.getPackageName()`. Therefore, the code change type is 5.","Since the method is still ultimately returning the result of `mService.isNetworkLoggingEnabled`, and the `RemoteException` is handled in the same way, the fact that an additional parameter is passed doesn't necessarily indicate a compatibility issue by itself. The change does not by itself indicate that the API will return a different value or throw a different exception. Therefore, there is no compatibility issue, and the CI type is 0."
348,<android.bluetooth.BluetoothA2dp: void close()>,28,29,<android.bluetooth.BluetoothA2dp: void close()>,<android.bluetooth.BluetoothA2dp: void close()>,0,"{
    mServiceListener = null;
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    try {
        mServiceLock.writeLock().lock();
        if (mService != null) {
            mService = null;
            mContext.unbindService(mConnection);
        }
    } catch (Exception re) {
        Log.e(TAG, """", re);
    } finally {
        mServiceLock.writeLock().unlock();
    }
}","{
    mProfileConnector.disconnect();
}",1,"/*package*/
",,-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the method has been completely replaced with a call to `mProfileConnector.disconnect()`. There are no return or exception handling statements in either version, so the change type is 4,5.","There is no indication of a compatibility issue caused by different return values or types, nor by different exception handlings, given that the method's signature indicates a void return type and there are no exception statements in the late implementation. The inner workings of `mProfileConnector.disconnect()` are abstracted away from the API's user, so assuming that the functionality provided by `mProfileConnector.disconnect()` remains the same, there will be no compatibility issue for the API caller."
349,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,28,29,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,0,"{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        ActivityManagerNative.getDefault().setPictureInPictureParams(mToken, params);
    } catch (RemoteException e) {
    }
}","{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        ActivityTaskManager.getService().setPictureInPictureParams(mToken, params);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Updates the properties of the picture-in-picture activity, or sets it to be used later when
 * {@link #enterPictureInPictureMode()} is called.
 *
 * @param params the new parameters for the picture-in-picture.
 */
","/**
 * Updates the properties of the picture-in-picture activity, or sets it to be used later when
 * {@link #enterPictureInPictureMode()} is called.
 *
 * @param params the new parameters for the picture-in-picture.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the try block has changed from `ActivityManagerNative.getDefault().setPictureInPictureParams(mToken, params)` to `ActivityTaskManager.getService().setPictureInPictureParams(mToken, params)`. Therefore, the dependent API has changed, and the code change type is 5.","However, as this change does not affect the method's return type, return values, or the exceptions it may throw (the structure of the try-catch block remains unchanged), there is no potential Compatibility Issue, so the CI type is 0."
350,"<android.os.Parcel: void writeByteArray(byte[],int,int)>",28,29,"<android.os.Parcel: void writeByteArray(byte[],int,int)>","<android.os.Parcel: void writeByteArray(byte[],int,int)>",0,"{
    if (b == null) {
        writeInt(-1);
        return;
    }
    Arrays.checkOffsetAndCount(b.length, offset, len);
    nativeWriteByteArray(mNativePtr, b, offset, len);
}","{
    if (b == null) {
        writeInt(-1);
        return;
    }
    ArrayUtils.throwsIfOutOfBounds(b.length, offset, len);
    nativeWriteByteArray(mNativePtr, b, offset, len);
}",1,"/**
 * Write a byte array into the parcel at the current {@link #dataPosition},
 * growing {@link #dataCapacity} if needed.
 * @param b Bytes to place into the parcel.
 * @param offset Index of first byte to be written.
 * @param len Number of bytes to write.
 */
","/**
 * Write a byte array into the parcel at the current {@link #dataPosition},
 * growing {@link #dataCapacity} if needed.
 * @param b Bytes to place into the parcel.
 * @param offset Index of first byte to be written.
 * @param len Number of bytes to write.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The difference is in the method used for bounds checking - it changed from Arrays.checkOffsetAndCount to ArrayUtils.throwsIfOutOfBounds - and this qualifies as a change in the 'Other statement changed' category. Additionally, this change is also a 'Dependent API changed' since a different method from another API is now being relied upon for that check.","However, this change should not introduce a Compatibility Issue because both methods are supposed to perform the same action: they check if the specified sub-range of the array is valid. Assuming the new implementation is correct and has the same behavior (throws an IndexOutOfBoundsException if the sub-range is not correct), there should be no difference in the outcome when using this method. Therefore, there is no compatibility issue."
351,<android.app.Activity: boolean isVoiceInteractionRoot()>,28,29,<android.app.Activity: boolean isVoiceInteractionRoot()>,<android.app.Activity: boolean isVoiceInteractionRoot()>,0,"{
    try {
        return mVoiceInteractor != null && ActivityManager.getService().isRootVoiceInteraction(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return mVoiceInteractor != null && ActivityTaskManager.getService().isRootVoiceInteraction(mToken);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Like {@link #isVoiceInteraction}, but only returns true if this is also the root
 * of a voice interaction.  That is, returns true if this activity was directly
 * started by the voice interaction service as the initiation of a voice interaction.
 * Otherwise, for example if it was started by another activity while under voice
 * interaction, returns false.
 */
","/**
 * Like {@link #isVoiceInteraction}, but only returns true if this is also the root
 * of a voice interaction.  That is, returns true if this activity was directly
 * started by the voice interaction service as the initiation of a voice interaction.
 * Otherwise, for example if it was started by another activity while under voice
 * interaction, returns false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed; the method getService() is changed from ActivityManager.getService() to ActivityTaskManager.getService(). Therefore, the change type is 5.","Since the method signature, exception handling, and return statements are unchanged and only the service class name has changed from `ActivityManager` to `ActivityTaskManager`, this change in the dependent API does not necessarily lead to a different return value or different exception handling as long as the semantics of `getService()` in both `ActivityManager` and `ActivityTaskManager` remain the same. Thus, there is no Compatibility Issue, the CI type is 0."
352,"<android.bluetooth.BluetoothHealth: boolean registerSinkAppConfiguration(String,int,BluetoothHealthCallback)>",28,29,"<android.bluetooth.BluetoothHealth: boolean registerSinkAppConfiguration(String,int,BluetoothHealthCallback)>","<android.bluetooth.BluetoothHealth: boolean registerSinkAppConfiguration(String,int,BluetoothHealthCallback)>",0,"{
    if (!isEnabled() || name == null)
        return false;
    if (VDBG)
        log(""registerSinkApplication("" + name + "":"" + dataType + "")"");
    return registerAppConfiguration(name, dataType, SINK_ROLE, CHANNEL_TYPE_ANY, callback);
}","{
    Log.e(TAG, ""registerSinkAppConfiguration(): BluetoothHealth is deprecated"");
    return false;
}",1,"/**
 * Register an application configuration that acts as a Health SINK.
 * This is the configuration that will be used to communicate with health devices
 * which will act as the {@link #SOURCE_ROLE}. This is an asynchronous call and so
 * the callback is used to notify success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param name The friendly name associated with the application or configuration.
 * @param dataType The dataType of the Source role of Health Profile to which the sink wants to
 * connect to.
 * @param callback A callback to indicate success or failure of the registration and all
 * operations done on this application configuration.
 * @return If true, callback will be called.
 */
","/**
 * Register an application configuration that acts as a Health SINK.
 * This is the configuration that will be used to communicate with health devices
 * which will act as the {@link #SOURCE_ROLE}. This is an asynchronous call and so
 * the callback is used to notify success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param name The friendly name associated with the application or configuration.
 * @param dataType The dataType of the Source role of Health Profile to which the sink wants to
 * connect to.
 * @param callback A callback to indicate success or failure of the registration and all
 * operations done on this application configuration.
 * @return If true, callback will be called.
 *
 * @deprecated Health Device Profile (HDP) and MCAP protocol are no longer used. New
 * apps should use Bluetooth Low Energy based solutions such as {@link BluetoothGatt},
 * {@link BluetoothAdapter#listenUsingL2capChannel()(int)}, or
 * {@link BluetoothDevice#createL2capChannel(int)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early version implementation includes a check if Bluetooth is enabled, null check for name, a logging statement, and a call to registerAppConfiguration(). However, the late version has a log statement that indicates the method is deprecated and returns false directly without performing any of the previous checks. The logging behavior has changed significantly, as well as the method's logic for processing, which includes a direct return of 'false' instead of potentially 'true', the removal of previously executed checks and method call. Therefore, the code change types are 1, 4, and 5.","Given that the late version implementation only logs a deprecation message and always returns false, regardless of the input, it implies that any previous behavior where the method could have returned true is no longer possible. Thus, the implementation change results in a CI due to the potential return of a different value (always false), classifying it as CI type 1."
353,<android.net.LinkProperties: int hashCode()>,28,29,<android.net.LinkProperties: int hashCode()>,<android.net.LinkProperties: int hashCode()>,0,"{
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + mValidatedPrivateDnses.size() * 61 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode()) + (mUsePrivateDns ? 57 : 0) + ((null == mPrivateDnsServerName) ? 0 : mPrivateDnsServerName.hashCode());
}","{
    return ((null == mIfaceName) ? 0 : mIfaceName.hashCode() + mLinkAddresses.size() * 31 + mDnses.size() * 37 + mValidatedPrivateDnses.size() * 61 + ((null == mDomains) ? 0 : mDomains.hashCode()) + mRoutes.size() * 41 + ((null == mHttpProxy) ? 0 : mHttpProxy.hashCode()) + mStackedLinks.hashCode() * 47) + mMtu * 51 + ((null == mTcpBufferSizes) ? 0 : mTcpBufferSizes.hashCode()) + (mUsePrivateDns ? 57 : 0) + mPcscfs.size() * 67 + ((null == mPrivateDnsServerName) ? 0 : mPrivateDnsServerName.hashCode()) + Objects.hash(mNat64Prefix);
}",1,,"/**
 * Generate hashcode based on significant fields
 *
 * Equal objects must produce the same hash code, while unequal objects
 * may have the same hash codes.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The hashCode computation has been extended with new elements (`mPcscfs.size() * 67` and `Objects.hash(mNat64Prefix)`), therefore the change type is 4 since other statement has changed.","The implementation changes do not affect the compatibility as the hashCode method is used to get an integer representation of the object state for hashing purposes (like putting it into hash-based collections). So, even though the returned value will differ between the two versions if the new fields are non-null or non-zero, this does not represent a behavior change in the context of the method's intended functionality. Thus, there is no compatibility issue."
354,<android.service.notification.NotificationListenerService.RankingMap: String[] getOrderedKeys()>,28,29,<android.service.notification.NotificationListenerService.RankingMap: String[] getOrderedKeys()>,<android.service.notification.NotificationListenerService.RankingMap: String[] getOrderedKeys()>,0,"{
    return mRankingUpdate.getOrderedKeys();
}","{
    return mOrderedKeys.toArray(new String[0]);
}",1,"/**
 * Request the list of notification keys in their current ranking
 * order.
 *
 * @return An array of active notification keys, in their ranking order.
 */
","/**
 * Request the list of notification keys in their current ranking
 * order.
 *
 * @return An array of active notification keys, in their ranking order.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method used to get the ordered keys has changed from mRankingUpdate.getOrderedKeys() to mOrderedKeys.toArray(new String[0]), along with the method through which the array is created, so the changes include the return statement, other statements, and a dependent API (change type is 1,4,5).","The change in how the array of keys is retrieved and constructed could potentially lead to the API returning a different set of values since the data source and the conversion method have changed. Hence, this would result in a Compatibility Issue caused by potential different return values (type 1)."
355,"<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>",28,29,"<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>","<android.view.View: WindowInsets computeSystemWindowInsets(WindowInsets,Rect)>",0,"{
    if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || ((mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0 && !mAttachInfo.mOverscanRequested)) {
        outLocalInsets.set(in.getSystemWindowInsets());
        return in.consumeSystemWindowInsets().inset(outLocalInsets);
    } else {
        // The application wants to take care of fitting system window for
        // the content...  however we still need to take care of any overscan here.
        final Rect overscan = mAttachInfo.mOverscanInsets;
        outLocalInsets.set(overscan);
        return in.inset(outLocalInsets);
    }
}","{
    if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || ((mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0 && !mAttachInfo.mOverscanRequested)) {
        outLocalInsets.set(in.getSystemWindowInsetsAsRect());
        return in.consumeSystemWindowInsets().inset(outLocalInsets);
    } else {
        // The application wants to take care of fitting system window for
        // the content...  however we still need to take care of any overscan here.
        final Rect overscan = mAttachInfo.mOverscanInsets;
        outLocalInsets.set(overscan);
        return in.inset(outLocalInsets);
    }
}",1,"/**
 * Compute insets that should be consumed by this view and the ones that should propagate
 * to those under it.
 *
 * @param in Insets currently being processed by this View, likely received as a parameter
 * to {@link #onApplyWindowInsets(WindowInsets)}.
 * @param outLocalInsets A Rect that will receive the insets that should be consumed
 * by this view
 * @return Insets that should be passed along to views under this one
 */
","/**
 * Compute insets that should be consumed by this view and the ones that should propagate
 * to those under it.
 *
 * @param in Insets currently being processed by this View, likely received as a parameter
 * to {@link #onApplyWindowInsets(WindowInsets)}.
 * @param outLocalInsets A Rect that will receive the insets that should be consumed
 * by this view
 * @return Insets that should be passed along to views under this one
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method getSystemWindowInsets() in the return statement of the if block is replaced with getSystemWindowInsetsAsRect(). This is a change to another method being called, which is a Dependent API change. Also, while this specific change does not alter the control flow or exception handling, it might result in a different return type or value because the method name and behavior may have changed. Hence, this change also falls into the Other statement changed category.","The change to a different method being called (getSystemWindowInsetsAsRect() instead of getSystemWindowInsets()) could potentially return a different value or type, especially as the exact behavior of the new method is not specified here. Thus, this creates a potential Compatibility Issue due to different return values or types, which is CI type 1."
356,<android.preference.ListPreference: void onPrepareDialogBuilder(Builder)>,28,29,<android.preference.ListPreference: void onPrepareDialogBuilder(Builder)>,<android.preference.ListPreference: void onPrepareDialogBuilder(Builder)>,0,"{
    super.onPrepareDialogBuilder(builder);
    if (mEntries == null || mEntryValues == null) {
        throw new IllegalStateException(""ListPreference requires an entries array and an entryValues array."");
    }
    mClickedDialogEntryIndex = getValueIndex();
    builder.setSingleChoiceItems(mEntries, mClickedDialogEntryIndex, new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            mClickedDialogEntryIndex = which;
            /*
                         * Clicking on an item simulates the positive button
                         * click, and dismisses the dialog.
                         */
            ListPreference.this.onClick(dialog, DialogInterface.BUTTON_POSITIVE);
            dialog.dismiss();
        }
    });
    /*
         * The typical interaction for list-based dialogs is to have
         * click-on-an-item dismiss the dialog instead of the user having to
         * press 'Ok'.
         */
    builder.setPositiveButton(null, null);
}","{
    super.onPrepareDialogBuilder(builder);
    if (mEntries == null || mEntryValues == null) {
        throw new IllegalStateException(""ListPreference requires an entries array and an entryValues array."");
    }
    mClickedDialogEntryIndex = getValueIndex();
    builder.setSingleChoiceItems(mEntries, mClickedDialogEntryIndex, new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            mClickedDialogEntryIndex = which;
            /*
                         * Clicking on an item simulates the positive button
                         * click, and dismisses the dialog.
                         */
            ListPreference.this.onClick(dialog, DialogInterface.BUTTON_POSITIVE);
            postDismiss();
        }
    });
    /*
         * The typical interaction for list-based dialogs is to have
         * click-on-an-item dismiss the dialog instead of the user having to
         * press 'Ok'.
         */
    builder.setPositiveButton(null, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method implementation change is inside the DialogInterface.OnClickListener(), specifically changing from `dialog.dismiss()` to `postDismiss()`. This is an internal implementation detail of the dialog interaction and does not change the control flow or the API's external behavior related to the return type or exceptions thrown.","There is no Compatibility Issue here because the modification from `dialog.dismiss()` to `postDismiss()` doesn't affect the return value nor does it introduce a new exception scenario. Both are internal calls to dismiss the dialog, and likely `postDismiss()` is just a wrapper around `dialog.dismiss()` with some additional internal handling. The public API behavior, in terms of the API contract, remains unchanged."
357,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,28,29,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,0,"{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}","{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            setValue(values.mNameConstant, value);
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    mView.invalidateViewProperty(false, false);
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}",1,"/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
","/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,The following changes were made in the code:,
358,<android.service.autofill.SaveInfo.Builder: SaveInfo build()>,28,29,<android.service.autofill.SaveInfo.Builder: SaveInfo build()>,<android.service.autofill.SaveInfo.Builder: SaveInfo build()>,0,"{
    throwIfDestroyed();
    Preconditions.checkState(!ArrayUtils.isEmpty(mRequiredIds) || !ArrayUtils.isEmpty(mOptionalIds), ""must have at least one required or optional id"");
    mDestroyed = true;
    return new SaveInfo(this);
}","{
    throwIfDestroyed();
    Preconditions.checkState(!ArrayUtils.isEmpty(mRequiredIds) || !ArrayUtils.isEmpty(mOptionalIds) || (mFlags & FLAG_DELAY_SAVE) != 0, ""must have at least one required or optional id or FLAG_DELAYED_SAVE"");
    mDestroyed = true;
    return new SaveInfo(this);
}",1,"/**
 * Builds a new {@link SaveInfo} instance.
 *
 * @throws IllegalStateException if no
 * {@link #SaveInfo.Builder(int, AutofillId[]) required ids}
 * or {@link #setOptionalIds(AutofillId[]) optional ids} were set
 */
","/**
 * Builds a new {@link SaveInfo} instance.
 *
 * @throws IllegalStateException if no
 * {@link #SaveInfo.Builder(int, AutofillId[]) required ids},
 * or {@link #setOptionalIds(AutofillId[]) optional ids}, or {@link #FLAG_DELAY_SAVE}
 * were set
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The Preconditions.checkState condition has been changed to include an additional condition (mFlags & FLAG_DELAY_SAVE) != 0, so the change type is 3.","The change in the condition of throwIfDestroyed() doesn't result in a different exception being thrown or a different return value because it's merely enlarging the condition which allows the method to proceed without throwing an IllegalStateException. If the conditions specified in both versions are not met, the same exception with the same message will be thrown. Therefore, there is no Compatibility Issue."
359,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,28,29,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,0,"{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: mServedView="" + dumpViewInfo(mServedView));
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}","{
    mNextServedView = null;
    mActivityViewToScreenMatrix = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: mServedView="" + dumpViewInfo(mServedView));
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}",1,"/**
 * Disconnect any existing input connection, clearing the served view.
 */
","/**
 * Disconnect any existing input connection, clearing the served view.
 */
",-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"The conditional block checking 'mCurrentTextBoxAttribute != null' and its associated try-catch for 'mService.finishInput(mClient)' has been removed, and a new statement 'mActivityViewToScreenMatrix = null;' has been added that does not affect control flow or exceptions. This means that the code change type is 4.","Since no control flow or exception handling has been changed that could affect the method's behavior, there is no Compatibility Issue. The changes are internal state modifications without impact on the method's return type, exceptions thrown, or observable side effects from an API consumer point of view. Therefore, the CI type is 0."
361,<android.hardware.camera2.impl.CameraDeviceImpl.FrameNumberTracker: long getCompletedFrameNumber()>,28,29,<android.hardware.camera2.impl.CameraDeviceImpl.FrameNumberTracker: long getCompletedFrameNumber()>,<android.hardware.camera2.impl.CameraDeviceImpl.FrameNumberTracker: long getCompletedFrameNumber()>,0,"{
    return mCompletedFrameNumber;
}","{
    return mCompletedFrameNumber[CaptureRequest.REQUEST_TYPE_REGULAR];
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement accesses a different element by using an index (CaptureRequest.REQUEST_TYPE_REGULAR) on what seems to be now an array rather than a single variable. This change impacts how the value is retrieved, and a dependent API (CaptureRequest.REQUEST_TYPE_REGULAR) is now being used to index the mCompletedFrameNumber array. Thus, the code change type is 1,5.","Because of the changed indexing into the mCompletedFrameNumber, which is now seemingly an array rather than a single long value, the API will return a different value or type based on the index provided by CaptureRequest.REQUEST_TYPE_REGULAR. This represents a Compatibility Issue due to potential different return values or types; therefore, the CI type is 1."
362,<android.view.WindowInsets: int getStableInsetRight()>,28,29,<android.view.WindowInsets: int getStableInsetRight()>,<android.view.WindowInsets: int getStableInsetRight()>,0,"{
    return mStableInsets.right;
}","{
    return getStableInsets().right;
}",1,"/**
 * Returns the right stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The right stable inset
 */
","/**
 * Returns the right stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The right stable inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There's a change in how the stable insets are accessed; in the early version directly from a field `mStableInsets.right`, and in the late version through a method call `getStableInsets().right`. However, this method call should still return the same value as accessed from the directly field assuming `getStableInsets()` returns the `mStableInsets` object without modification. Therefore, the code change type is 5.","No Compatibility Issue should arise from this change as the return value is expected to remain the same; thus, the CI type is 0."
363,"<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>",28,29,"<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>","<android.app.assist.AssistStructure.ViewNode: int writeSelfToParcel(Parcel,PooledStringWriter,boolean,float[])>",0,"{
    // Guard used to skip non-sanitized data when writing for autofill.
    boolean writeSensitive = true;
    int flags = mFlags & ~FLAGS_ALL_CONTROL;
    if (mId != View.NO_ID) {
        flags |= FLAGS_HAS_ID;
    }
    if (mAutofillId != null) {
        flags |= FLAGS_HAS_AUTOFILL_DATA;
    }
    if ((mX & ~0x7fff) != 0 || (mY & ~0x7fff) != 0 || (mWidth & ~0x7fff) != 0 | (mHeight & ~0x7fff) != 0) {
        flags |= FLAGS_HAS_LARGE_COORDS;
    }
    if (mScrollX != 0 || mScrollY != 0) {
        flags |= FLAGS_HAS_SCROLL;
    }
    if (mMatrix != null) {
        flags |= FLAGS_HAS_MATRIX;
    }
    if (mElevation != 0) {
        flags |= FLAGS_HAS_ELEVATION;
    }
    if (mAlpha != 1.0f) {
        flags |= FLAGS_HAS_ALPHA;
    }
    if (mContentDescription != null) {
        flags |= FLAGS_HAS_CONTENT_DESCRIPTION;
    }
    if (mText != null) {
        flags |= FLAGS_HAS_TEXT;
        if (!mText.isSimple()) {
            flags |= FLAGS_HAS_COMPLEX_TEXT;
        }
    }
    if (mInputType != 0) {
        flags |= FLAGS_HAS_INPUT_TYPE;
    }
    if (mWebScheme != null || mWebDomain != null) {
        flags |= FLAGS_HAS_URL;
    }
    if (mLocaleList != null) {
        flags |= FLAGS_HAS_LOCALE_LIST;
    }
    if (mExtras != null) {
        flags |= FLAGS_HAS_EXTRAS;
    }
    if (mChildren != null) {
        flags |= FLAGS_HAS_CHILDREN;
    }
    pwriter.writeString(mClassName);
    int writtenFlags = flags;
    if ((flags & FLAGS_HAS_AUTOFILL_DATA) != 0 && (mSanitized || !sanitizeOnWrite)) {
        // Remove 'checked' from sanitized autofill request.
        writtenFlags = flags & ~FLAGS_CHECKED;
    }
    if (mAutofillOverlay != null) {
        if (mAutofillOverlay.focused) {
            writtenFlags |= ViewNode.FLAGS_FOCUSED;
        } else {
            writtenFlags &= ~ViewNode.FLAGS_FOCUSED;
        }
    }
    out.writeInt(writtenFlags);
    if ((flags & FLAGS_HAS_ID) != 0) {
        out.writeInt(mId);
        if (mId != View.NO_ID) {
            pwriter.writeString(mIdEntry);
            if (mIdEntry != null) {
                pwriter.writeString(mIdType);
                pwriter.writeString(mIdPackage);
            }
        }
    }
    if ((flags & FLAGS_HAS_AUTOFILL_DATA) != 0) {
        writeSensitive = mSanitized || !sanitizeOnWrite;
        out.writeInt(mSanitized ? 1 : 0);
        out.writeParcelable(mAutofillId, 0);
        out.writeInt(mAutofillType);
        out.writeStringArray(mAutofillHints);
        final AutofillValue sanitizedValue;
        if (writeSensitive) {
            sanitizedValue = mAutofillValue;
        } else if (mAutofillOverlay != null && mAutofillOverlay.value != null) {
            sanitizedValue = mAutofillOverlay.value;
        } else {
            sanitizedValue = null;
        }
        out.writeParcelable(sanitizedValue, 0);
        out.writeCharSequenceArray(mAutofillOptions);
        if (mHtmlInfo instanceof Parcelable) {
            out.writeParcelable((Parcelable) mHtmlInfo, 0);
        } else {
            out.writeParcelable(null, 0);
        }
        out.writeInt(mMinEms);
        out.writeInt(mMaxEms);
        out.writeInt(mMaxLength);
        pwriter.writeString(mTextIdEntry);
        out.writeInt(mImportantForAutofill);
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        out.writeInt(mX);
        out.writeInt(mY);
        out.writeInt(mWidth);
        out.writeInt(mHeight);
    } else {
        out.writeInt((mY << 16) | mX);
        out.writeInt((mHeight << 16) | mWidth);
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        out.writeInt(mScrollX);
        out.writeInt(mScrollY);
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix.getValues(tmpMatrix);
        out.writeFloatArray(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        out.writeFloat(mElevation);
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        out.writeFloat(mAlpha);
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        TextUtils.writeToParcel(mContentDescription, out, 0);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText.writeToParcel(out, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0, writeSensitive);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        out.writeInt(mInputType);
    }
    if ((flags & FLAGS_HAS_URL) != 0) {
        out.writeString(mWebScheme);
        out.writeString(mWebDomain);
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        out.writeParcelable(mLocaleList, 0);
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        out.writeBundle(mExtras);
    }
    return flags;
}","{
    // Guard used to skip non-sanitized data when writing for autofill.
    boolean writeSensitive = true;
    int flags = mFlags & ~FLAGS_ALL_CONTROL;
    int autofillFlags = 0;
    if (mId != View.NO_ID) {
        flags |= FLAGS_HAS_ID;
    }
    if ((mX & ~0x7fff) != 0 || (mY & ~0x7fff) != 0 || (mWidth & ~0x7fff) != 0 | (mHeight & ~0x7fff) != 0) {
        flags |= FLAGS_HAS_LARGE_COORDS;
    }
    if (mScrollX != 0 || mScrollY != 0) {
        flags |= FLAGS_HAS_SCROLL;
    }
    if (mMatrix != null) {
        flags |= FLAGS_HAS_MATRIX;
    }
    if (mElevation != 0) {
        flags |= FLAGS_HAS_ELEVATION;
    }
    if (mAlpha != 1.0f) {
        flags |= FLAGS_HAS_ALPHA;
    }
    if (mContentDescription != null) {
        flags |= FLAGS_HAS_CONTENT_DESCRIPTION;
    }
    if (mText != null) {
        flags |= FLAGS_HAS_TEXT;
        if (!mText.isSimple()) {
            flags |= FLAGS_HAS_COMPLEX_TEXT;
        }
    }
    if (mInputType != 0) {
        flags |= FLAGS_HAS_INPUT_TYPE;
    }
    if (mWebScheme != null || mWebDomain != null) {
        flags |= FLAGS_HAS_URL;
    }
    if (mLocaleList != null) {
        flags |= FLAGS_HAS_LOCALE_LIST;
    }
    if (mExtras != null) {
        flags |= FLAGS_HAS_EXTRAS;
    }
    if (mChildren != null) {
        flags |= FLAGS_HAS_CHILDREN;
    }
    if (mAutofillId != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID;
        if (mAutofillId.isVirtualInt()) {
            autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID;
        }
        if (mAutofillId.hasSession()) {
            autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID;
        }
    }
    if (mAutofillValue != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE;
    }
    if (mAutofillType != View.AUTOFILL_TYPE_NONE) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE;
    }
    if (mAutofillHints != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS;
    }
    if (mAutofillOptions != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS;
    }
    if (mHtmlInfo instanceof Parcelable) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_HTML_INFO;
    }
    if (mMinEms > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS;
    }
    if (mMaxEms > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS;
    }
    if (mMaxLength > -1) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH;
    }
    if (mTextIdEntry != null) {
        autofillFlags |= AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY;
    }
    pwriter.writeString(mClassName);
    int writtenFlags = flags;
    if (autofillFlags != 0 && (mSanitized || !sanitizeOnWrite)) {
        // Remove 'checked' from sanitized autofill request.
        writtenFlags = flags & ~FLAGS_CHECKED;
    }
    if (mAutofillOverlay != null) {
        if (mAutofillOverlay.focused) {
            writtenFlags |= ViewNode.FLAGS_FOCUSED;
        } else {
            writtenFlags &= ~ViewNode.FLAGS_FOCUSED;
        }
    }
    out.writeInt(writtenFlags);
    out.writeInt(autofillFlags);
    if ((flags & FLAGS_HAS_ID) != 0) {
        out.writeInt(mId);
        if (mId != View.NO_ID) {
            pwriter.writeString(mIdEntry);
            if (mIdEntry != null) {
                pwriter.writeString(mIdType);
                pwriter.writeString(mIdPackage);
            }
        }
    }
    if (autofillFlags != 0) {
        out.writeInt(mSanitized ? 1 : 0);
        out.writeInt(mImportantForAutofill);
        writeSensitive = mSanitized || !sanitizeOnWrite;
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID) != 0) {
            out.writeInt(mAutofillId.getViewId());
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID) != 0) {
                out.writeInt(mAutofillId.getVirtualChildIntId());
            }
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID) != 0) {
                out.writeInt(mAutofillId.getSessionId());
            }
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE) != 0) {
            out.writeInt(mAutofillType);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS) != 0) {
            out.writeStringArray(mAutofillHints);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE) != 0) {
            final AutofillValue sanitizedValue;
            if (writeSensitive) {
                sanitizedValue = mAutofillValue;
            } else if (mAutofillOverlay != null && mAutofillOverlay.value != null) {
                sanitizedValue = mAutofillOverlay.value;
            } else {
                sanitizedValue = null;
            }
            out.writeParcelable(sanitizedValue, 0);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS) != 0) {
            out.writeCharSequenceArray(mAutofillOptions);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HTML_INFO) != 0) {
            out.writeParcelable((Parcelable) mHtmlInfo, 0);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS) != 0) {
            out.writeInt(mMinEms);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS) != 0) {
            out.writeInt(mMaxEms);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH) != 0) {
            out.writeInt(mMaxLength);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY) != 0) {
            pwriter.writeString(mTextIdEntry);
        }
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        out.writeInt(mX);
        out.writeInt(mY);
        out.writeInt(mWidth);
        out.writeInt(mHeight);
    } else {
        out.writeInt((mY << 16) | mX);
        out.writeInt((mHeight << 16) | mWidth);
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        out.writeInt(mScrollX);
        out.writeInt(mScrollY);
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix.getValues(tmpMatrix);
        out.writeFloatArray(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        out.writeFloat(mElevation);
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        out.writeFloat(mAlpha);
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        TextUtils.writeToParcel(mContentDescription, out, 0);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText.writeToParcel(out, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0, writeSensitive);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        out.writeInt(mInputType);
    }
    if ((flags & FLAGS_HAS_URL) != 0) {
        out.writeString(mWebScheme);
        out.writeString(mWebDomain);
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        out.writeParcelable(mLocaleList, 0);
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        out.writeBundle(mExtras);
    }
    return flags;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
364,"<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>",28,29,"<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>","<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>",0,"{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof HttpResponseCache) {
        HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
        // don't close and reopen if an equivalent cache is already installed
        AndroidShimResponseCache trueResponseCache = installedResponseCache.delegate;
        if (trueResponseCache.isEquivalent(directory, maxSize)) {
            return installedResponseCache;
        } else {
            // The HttpResponseCache that owns this object is about to be replaced.
            trueResponseCache.close();
        }
    }
    AndroidShimResponseCache trueResponseCache = AndroidShimResponseCache.create(directory, maxSize);
    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
    ResponseCache.setDefault(newResponseCache);
    return newResponseCache;
}","{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof HttpResponseCache) {
        HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
        CacheHolder cacheHolder = installedResponseCache.getCacheHolder();
        // don't close and reopen if an equivalent cache is already installed
        if (cacheHolder.isEquivalent(directory, maxSize)) {
            return installedResponseCache;
        } else {
            // The HttpResponseCache that owns this object is about to be replaced.
            installedResponseCache.close();
        }
    }
    CacheHolder cacheHolder = CacheHolder.create(directory, maxSize);
    AndroidResponseCacheAdapter androidResponseCacheAdapter = new AndroidResponseCacheAdapter(cacheHolder);
    HttpResponseCache responseCache = new HttpResponseCache(androidResponseCacheAdapter);
    ResponseCache.setDefault(responseCache);
    return responseCache;
}",1,"/**
 * Creates a new HTTP response cache and sets it as the system default cache.
 *
 * @param directory the directory to hold cache data.
 * @param maxSize the maximum size of the cache in bytes.
 * @return the newly-installed cache
 * @throws IOException if {@code directory} cannot be used for this cache.
 * Most applications should respond to this exception by logging a
 * warning.
 */
","/**
 * Creates a new HTTP response cache and sets it as the system default cache.
 *
 * @param directory the directory to hold cache data.
 * @param maxSize the maximum size of the cache in bytes.
 * @return the newly-installed cache
 * @throws IOException if {@code directory} cannot be used for this cache.
 * Most applications should respond to this exception by logging a
 * warning.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation has changed with the introduction of a new intermediate class 'CacheHolder' being used instead of 'AndroidShimResponseCache', and a different method 'getCacheHolder()' instead of accessing 'delegate' directly. Furthermore, 'AndroidResponseCacheAdapter' is used in place of 'AndroidShimResponseCache'. The core logic and control flow, however, remain consistent. Hence, the change type is 4,5.","Despite the introduction of new classes and intermediate variables, the logic to decide whether to return the existing cache or create a new one seems identical, and the same conditions for the cache equivalence check are present. Thus, assuming the behavior of these new classes is consistent with their old counterparts, there will be no Compatibility Issue, as the conditions under which a certain value is returned remain the same. There's no evidence from the given code that the changes affect the return type or the potential exceptions thrown."
366,<android.service.notification.ZenModeConfig.ZenRule: boolean isAutomaticActive()>,28,29,<android.service.notification.ZenModeConfig.ZenRule: boolean isAutomaticActive()>,<android.service.notification.ZenModeConfig.ZenRule: boolean isAutomaticActive()>,0,"{
    return enabled && !snoozing && component != null && isTrueOrUnknown();
}","{
    return enabled && !snoozing && pkg != null && isTrueOrUnknown();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The code change consists of a modification from checking 'component != null' to 'pkg != null', which is a change of a field being checked within the return expression, thus the change type is 4.","The change from 'component' to 'pkg' being checked for non-nullity is potentially a change in the logic of determining whether the rule is automatically active. If 'component' and 'pkg' do not always reference the same condition or their states are not equivalent, this could change the returned boolean value causing a Compatibility Issue of type 1."
369,<android.provider.MediaStore.Images.Thumbnails: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Images.Thumbnails: Uri getContentUri(String)>,<android.provider.MediaStore.Images.Thumbnails: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/images/thumbnails"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""images"").appendPath(""thumbnails"").build();
}",1,"/**
 * Get the content:// style URI for the image media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the image media table on the given volume
 */
","/**
 * Get the content:// style URI for the image media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the image media table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, and the mechanism for building the Uri has also changed. The method now uses a method chain (buildUpon().appendPath().appendPath().appendPath().build()) instead of Uri.parse(). Additionally, an implementation detail (CONTENT_AUTHORITY_SLASH) has been replaced with another one (AUTHORITY_URI), and therefore there is a change in how the dependent API is used. This indicates both types 1 and 5 have occurred.","Although both versions of the API ultimately aim to return a Uri object, the construction method is different, and thus the generated Uri may potentially be different, which is why CI type 1 is applicable."
371,<android.view.textclassifier.TextClassificationManager: void finalize()>,28,29,<android.view.textclassifier.TextClassificationManager: void finalize()>,<android.view.textclassifier.TextClassificationManager: void finalize()>,0,"{
    try {
        // Note that fields could be null if the constructor threw.
        if (mSettingsObserver != null) {
            getApplicationContext().getContentResolver().unregisterContentObserver(mSettingsObserver);
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        // Note that fields could be null if the constructor threw.
        if (mSettingsObserver != null) {
            getApplicationContext().getContentResolver().unregisterContentObserver(mSettingsObserver);
            if (ConfigParser.ENABLE_DEVICE_CONFIG) {
                DeviceConfig.removeOnPropertiesChangedListener(mSettingsObserver);
            }
        }
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The additional conditionally executed statement `DeviceConfig.removeOnPropertiesChangedListener(mSettingsObserver);` does not alter the return value or exception handling of the method because it is inside a `try` block and does not impact the `finally` block. Therefore, the code change is classified as 4 (Other statement changed).",There is no Compatibility Issue as the change does not affect the method's output or the exceptions it may throw. The additional statement simply cleans up an additional listener if a specific configuration is enabled and will not change the behavior of the API in terms of return values or exception throwing.
373,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,28,29,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an addition of a new parameter (null) to the constructor of ContextImpl, which is an Other statement change.","The addition of a new parameter as null does not inherently lead to a different behavior, since it does not change the method signature nor alters the logic within the method being called. Therefore, there's no Compatibility Issue based on the given definitions."
374,<android.service.notification.ZenModeConfig.Diff: String toString()>,28,29,<android.service.notification.ZenModeConfig.Diff: String toString()>,<android.service.notification.ZenModeConfig.Diff: String toString()>,0,"{
    final StringBuilder sb = new StringBuilder(""Diff["");
    final int N = lines.size();
    for (int i = 0; i < N; i++) {
        if (i > 0) {
            sb.append(',');
        }
        sb.append(lines.get(i));
    }
    return sb.append(']').toString();
}","{
    final StringBuilder sb = new StringBuilder(""Diff["");
    final int N = lines.size();
    for (int i = 0; i < N; i++) {
        if (i > 0) {
            sb.append("",\n"");
        }
        sb.append(lines.get(i));
    }
    return sb.append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change involves only a string literal in the append method of StringBuilder from ',' to "",\n"", which means the output format of the string will be different (adding a newline character after each comma). This is a minor change that affects the presentation but not the logic or the return type of the method. Therefore, the code change type is 4.","This change does not affect the API's behaviour in terms of logic, return value, or exception handling. It's merely a stylistic change in the output format, which typically should not cause compatibility issues as long as the API consumers do not rely on the exact format of the string (which they should not generally do for a 'toString' representation). Thus, there's no Compatibility Issue, and the CI type is 0."
375,"<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>",28,29,"<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>","<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    String[] splitDirs = packageInfo.getSplitResDirs();
    ClassLoader classLoader = packageInfo.getClassLoader();
    if (packageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, ""SplitDependencies"");
        try {
            classLoader = packageInfo.getSplitClassLoader(activityInfo.splitName);
            splitDirs = packageInfo.getSplitPaths(activityInfo.splitName);
        } catch (NameNotFoundException e) {
            // Nothing above us can handle a NameNotFoundException, better crash.
            throw new RuntimeException(e);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
        }
    }
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName, activityToken, null, 0, classLoader);
    // Clamp display ID to DEFAULT_DISPLAY if it is INVALID_DISPLAY.
    displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;
    final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
    final ResourcesManager resourcesManager = ResourcesManager.getInstance();
    // Create the base resources for which all configuration contexts for this Activity
    // will be rebased upon.
    context.setResources(resourcesManager.createBaseActivityResources(activityToken, packageInfo.getResDir(), splitDirs, packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo, classLoader));
    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId, context.getResources());
    return context;
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    String[] splitDirs = packageInfo.getSplitResDirs();
    ClassLoader classLoader = packageInfo.getClassLoader();
    if (packageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, ""SplitDependencies"");
        try {
            classLoader = packageInfo.getSplitClassLoader(activityInfo.splitName);
            splitDirs = packageInfo.getSplitPaths(activityInfo.splitName);
        } catch (NameNotFoundException e) {
            // Nothing above us can handle a NameNotFoundException, better crash.
            throw new RuntimeException(e);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
        }
    }
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName, activityToken, null, 0, classLoader, null);
    // Clamp display ID to DEFAULT_DISPLAY if it is INVALID_DISPLAY.
    displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;
    final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
    final ResourcesManager resourcesManager = ResourcesManager.getInstance();
    // Create the base resources for which all configuration contexts for this Activity
    // will be rebased upon.
    context.setResources(resourcesManager.createBaseActivityResources(activityToken, packageInfo.getResDir(), splitDirs, packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo, classLoader));
    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId, context.getResources());
    return context;
}",1,,,-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"The change from the early version to the late version is the addition of a new parameter 'null' to the constructor of ContextImpl. The rest of the method remains the same. Hence, there's an ""other statement changed, which is why the code change type is 4.","No Compatibility Issue should arise from this change because the added 'null' parameter does not affect the behavior of the method in a way that would lead to different return values or exception handling. It's an internal implementation detail that should be transparent to the user of the API, and assuming the eighth parameter of the ContextImpl constructor is indeed an optional parameter, this change should not cause any difference in behavior when the API method is called. Thus, the CI type is 0."
376,"<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>",28,29,"<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>","<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>",0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.updateExtractedText(token, text);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateExtractedText(view, token, text);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.updateExtractedText(token, text);
            } catch (RemoteException e) {
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"There is a new block of code that handles the case where a fallback InputMethodManager is needed, causing a new control flow (3), a new method call (4), and a new return statement (1) before the existing logic.","Although there is a new return statement added, it's only executed when 'fallbackImm' is not null and in which case 'fallbackImm.updateExtractedText(view, token, text)' is called instead of the rest of the method. This doesn't constitute a compatibility issue because it's an addition of a new code path that delegates the action to a fallback method which then performs the operation intended by the original method call. The behavior of the existing API method when 'fallbackImm' is null remains unchanged, ensuring backward compatibility for the existing clients of the method that are not dependent on the context of 'fallbackImm'. Hence, there is no compatibility issue."
378,"<android.animation.AnimatorSet: void animateBasedOnPlayTime(long,long,boolean)>",28,29,"<android.animation.AnimatorSet: void animateBasedOnPlayTime(long,long,boolean)>","<android.animation.AnimatorSet: void animateBasedOnPlayTime(long,long,boolean)>",0,"{
    if (currentPlayTime < 0 || lastPlayTime < 0) {
        throw new UnsupportedOperationException(""Error: Play time should never be negative."");
    }
    // Convert the play times to the forward direction.
    if (inReverse) {
        if (getTotalDuration() == DURATION_INFINITE) {
            throw new UnsupportedOperationException(""Cannot reverse AnimatorSet with infinite"" + "" duration"");
        }
        long duration = getTotalDuration() - mStartDelay;
        currentPlayTime = Math.min(currentPlayTime, duration);
        currentPlayTime = duration - currentPlayTime;
        lastPlayTime = duration - lastPlayTime;
        inReverse = false;
    }
    // Skip all values to start, and iterate mEvents to get animations to the right fraction.
    skipToStartValue(false);
    ArrayList<Node> unfinishedNodes = new ArrayList<>();
    // Assumes forward playing from here on.
    for (int i = 0; i < mEvents.size(); i++) {
        AnimationEvent event = mEvents.get(i);
        if (event.getTime() > currentPlayTime || event.getTime() == DURATION_INFINITE) {
            break;
        }
        // play time, add to the unfinished list.
        if (event.mEvent == AnimationEvent.ANIMATION_DELAY_ENDED) {
            if (event.mNode.mEndTime == DURATION_INFINITE || event.mNode.mEndTime > currentPlayTime) {
                unfinishedNodes.add(event.mNode);
            }
        }
        // they would in a normal run.
        if (event.mEvent == AnimationEvent.ANIMATION_END) {
            // Skip to the end of the animation.
            event.mNode.mAnimation.skipToEndValue(false);
        }
    }
    // Seek unfinished animation to the right time.
    for (int i = 0; i < unfinishedNodes.size(); i++) {
        Node node = unfinishedNodes.get(i);
        long playTime = getPlayTimeForNode(currentPlayTime, node, inReverse);
        if (!inReverse) {
            playTime -= node.mAnimation.getStartDelay();
        }
        node.mAnimation.animateBasedOnPlayTime(playTime, lastPlayTime, inReverse);
    }
}","{
    if (currentPlayTime < 0 || lastPlayTime < 0) {
        throw new UnsupportedOperationException(""Error: Play time should never be negative."");
    }
    // Convert the play times to the forward direction.
    if (inReverse) {
        if (getTotalDuration() == DURATION_INFINITE) {
            throw new UnsupportedOperationException(""Cannot reverse AnimatorSet with infinite"" + "" duration"");
        }
        long duration = getTotalDuration() - mStartDelay;
        currentPlayTime = Math.min(currentPlayTime, duration);
        currentPlayTime = duration - currentPlayTime;
        lastPlayTime = duration - lastPlayTime;
        inReverse = false;
    }
    ArrayList<Node> unfinishedNodes = new ArrayList<>();
    // Assumes forward playing from here on.
    for (int i = 0; i < mEvents.size(); i++) {
        AnimationEvent event = mEvents.get(i);
        if (event.getTime() > currentPlayTime || event.getTime() == DURATION_INFINITE) {
            break;
        }
        // play time, add to the unfinished list.
        if (event.mEvent == AnimationEvent.ANIMATION_DELAY_ENDED) {
            if (event.mNode.mEndTime == DURATION_INFINITE || event.mNode.mEndTime > currentPlayTime) {
                unfinishedNodes.add(event.mNode);
            }
        }
        // they would in a normal run.
        if (event.mEvent == AnimationEvent.ANIMATION_END) {
            // Skip to the end of the animation.
            event.mNode.mAnimation.skipToEndValue(false);
        }
    }
    // Seek unfinished animation to the right time.
    for (int i = 0; i < unfinishedNodes.size(); i++) {
        Node node = unfinishedNodes.get(i);
        long playTime = getPlayTimeForNode(currentPlayTime, node, inReverse);
        if (!inReverse) {
            playTime -= node.mAnimation.getStartDelay();
        }
        node.mAnimation.animateBasedOnPlayTime(playTime, lastPlayTime, inReverse);
    }
    // Seek not yet started animations.
    for (int i = 0; i < mEvents.size(); i++) {
        AnimationEvent event = mEvents.get(i);
        if (event.getTime() > currentPlayTime && event.mEvent == AnimationEvent.ANIMATION_DELAY_ENDED) {
            event.mNode.mAnimation.skipToEndValue(true);
        }
    }
}",1,"/**
 * Internal only.
 *
 * This method sets the animation values based on the play time. It also fast forward or
 * backward all the child animations progress accordingly.
 *
 * This method is also responsible for calling
 * {@link android.view.animation.Animation.AnimationListener#onAnimationRepeat(Animation)},
 * as needed, based on the last play time and current play time.
 */
","/**
 * Internal only.
 *
 * This method sets the animation values based on the play time. It also fast forward or
 * backward all the child animations progress accordingly.
 *
 * This method is also responsible for calling
 * {@link android.view.animation.Animation.AnimationListener#onAnimationRepeat(Animation)},
 * as needed, based on the last play time and current play time.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new block of code is added to the end of the method without altering the existing functionality, thus the change type is 4.","Since the added block only seeks not yet started animations and does not alter the control flow or exceptions for already handled cases, it does not create different return types, values or exception handlings for the situations already handled by the existing code. Hence, there is no compatibility issue."
379,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,0,"{
    switch(format) {
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            return HAL_PIXEL_FORMAT_BLOB;
        case ImageFormat.DEPTH16:
            return HAL_PIXEL_FORMAT_Y16;
        case ImageFormat.RAW_DEPTH:
            return HAL_PIXEL_FORMAT_RAW16;
        default:
            return format;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            return HAL_PIXEL_FORMAT_BLOB;
        case ImageFormat.DEPTH16:
            return HAL_PIXEL_FORMAT_Y16;
        case ImageFormat.RAW_DEPTH:
            return HAL_PIXEL_FORMAT_RAW16;
        default:
            return format;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16
 * </ul>
 * </p>
 *
 * <p>Passing in an internal format which has a different public format equivalent will fail.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.HEIC => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16
 * </ul>
 * </p>
 *
 * <p>Passing in an internal format which has a different public format equivalent will fail.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control structure, specifically the 'switch' case, has been altered with the addition of cases ImageFormat.DEPTH_JPEG and ImageFormat.HEIC that return the same value HAL_PIXEL_FORMAT_BLOB, so the code change type is 3.","The modification in the switch cases can result in a different return value for the new formats (ImageFormat.DEPTH_JPEG and ImageFormat.HEIC), thus the CI type is 1."
380,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>",28,29,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""Repeating request error received. Last frame number is "" + lastFrameNumber);
    }
    synchronized (mInterfaceLock) {
        // Camera is already closed or no repeating request is present.
        if (mRemoteDevice == null || mRepeatingRequestId == REQUEST_ID_NONE) {
            // Camera already closed
            return;
        }
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber);
        // Check if there is already a new repeating request
        if (mRepeatingRequestId == repeatingRequestId) {
            mRepeatingRequestId = REQUEST_ID_NONE;
        }
    }
}","{
    if (DEBUG) {
        Log.d(TAG, ""Repeating request error received. Last frame number is "" + lastFrameNumber);
    }
    synchronized (mInterfaceLock) {
        // Camera is already closed or no repeating request is present.
        if (mRemoteDevice == null || mRepeatingRequestId == REQUEST_ID_NONE) {
            // Camera already closed
            return;
        }
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
        // Check if there is already a new repeating request
        if (mRepeatingRequestId == repeatingRequestId) {
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `checkEarlyTriggerSequenceComplete` has been changed to add one more parameter `mRepeatingRequestTypes` in the late version and a new other statement has been added `mRepeatingRequestTypes = null;`. Therefore, the change is classified under the category 4 (Other statement changed) and 5 (Dependent API changed) due to the method signature change.","Although there is a change in the method `checkEarlyTriggerSequenceComplete` and new assignment `mRepeatingRequestTypes = null;`, this change does not affect the method's return type or value, and it does not introduce new exception handling. The function `onRepeatingRequestError` does not have a return statement in its main code path that is affected by these changes, nor do the changes involve exception handling. Therefore, there is no Compatibility Issue expected, corresponding to 0 (No Compatibility Issue)."
381,"<android.transition.ChangeImageTransform: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",28,29,"<android.transition.ChangeImageTransform: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>","<android.transition.ChangeImageTransform: Animator createAnimator(ViewGroup,TransitionValues,TransitionValues)>",0,"{
    if (startValues == null || endValues == null) {
        return null;
    }
    Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
    if (startBounds == null || endBounds == null) {
        return null;
    }
    Matrix startMatrix = (Matrix) startValues.values.get(PROPNAME_MATRIX);
    Matrix endMatrix = (Matrix) endValues.values.get(PROPNAME_MATRIX);
    boolean matricesEqual = (startMatrix == null && endMatrix == null) || (startMatrix != null && startMatrix.equals(endMatrix));
    if (startBounds.equals(endBounds) && matricesEqual) {
        return null;
    }
    ImageView imageView = (ImageView) endValues.view;
    Drawable drawable = imageView.getDrawable();
    int drawableWidth = drawable.getIntrinsicWidth();
    int drawableHeight = drawable.getIntrinsicHeight();
    ObjectAnimator animator;
    if (drawableWidth == 0 || drawableHeight == 0) {
        animator = createNullAnimator(imageView);
    } else {
        if (startMatrix == null) {
            startMatrix = Matrix.IDENTITY_MATRIX;
        }
        if (endMatrix == null) {
            endMatrix = Matrix.IDENTITY_MATRIX;
        }
        ANIMATED_TRANSFORM_PROPERTY.set(imageView, startMatrix);
        animator = createMatrixAnimator(imageView, startMatrix, endMatrix);
    }
    return animator;
}","{
    if (startValues == null || endValues == null) {
        return null;
    }
    Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
    Matrix startMatrix = (Matrix) startValues.values.get(PROPNAME_MATRIX);
    Matrix endMatrix = (Matrix) endValues.values.get(PROPNAME_MATRIX);
    if (startBounds == null || endBounds == null || startMatrix == null || endMatrix == null) {
        return null;
    }
    if (startBounds.equals(endBounds) && startMatrix.equals(endMatrix)) {
        return null;
    }
    ImageView imageView = (ImageView) endValues.view;
    Drawable drawable = imageView.getDrawable();
    int drawableWidth = drawable.getIntrinsicWidth();
    int drawableHeight = drawable.getIntrinsicHeight();
    ObjectAnimator animator;
    if (drawableWidth <= 0 || drawableHeight <= 0) {
        animator = createNullAnimator(imageView);
    } else {
        ANIMATED_TRANSFORM_PROPERTY.set(imageView, startMatrix);
        animator = createMatrixAnimator(imageView, startMatrix, endMatrix);
    }
    return animator;
}",1,"/**
 * Creates an Animator for ImageViews moving, changing dimensions, and/or changing
 * {@link android.widget.ImageView.ScaleType}.
 *
 * @param sceneRoot   The root of the transition hierarchy.
 * @param startValues The values for a specific target in the start scene.
 * @param endValues   The values for the target in the end scene.
 * @return An Animator to move an ImageView or null if the View is not an ImageView,
 * the Drawable changed, the View is not VISIBLE, or there was no change.
 */
","/**
 * Creates an Animator for ImageViews moving, changing dimensions, and/or changing
 * {@link android.widget.ImageView.ScaleType}.
 *
 * @param sceneRoot   The root of the transition hierarchy.
 * @param startValues The values for a specific target in the start scene.
 * @param endValues   The values for the target in the end scene.
 * @return An Animator to move an ImageView or null if the View is not an ImageView,
 * the Drawable changed, the View is not VISIBLE, or there was no change.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,The return statement conditions and the conditions within the 'if' block are changed. Specifically:,"These are control dependency changes, and as they change the conditions under which certain returns occur, they represent a type 1 change."
382,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,28,29,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityWindowInfo obtain(AccessibilityWindowInfo)>,0,"{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.mType = info.mType;
    infoClone.mLayer = info.mLayer;
    infoClone.mBooleanProperties = info.mBooleanProperties;
    infoClone.mId = info.mId;
    infoClone.mParentId = info.mParentId;
    infoClone.mBoundsInScreen.set(info.mBoundsInScreen);
    infoClone.mTitle = info.mTitle;
    infoClone.mAnchorId = info.mAnchorId;
    if (info.mChildIds != null && info.mChildIds.size() > 0) {
        if (infoClone.mChildIds == null) {
            infoClone.mChildIds = info.mChildIds.clone();
        } else {
            infoClone.mChildIds.addAll(info.mChildIds);
        }
    }
    infoClone.mConnectionId = info.mConnectionId;
    return infoClone;
}","{
    AccessibilityWindowInfo infoClone = obtain();
    infoClone.init(info);
    return infoClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * @param info The other info.
 * @return An instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",0,"The late implementation of the method is simplified by removing multiple assignment statements and encapsulating them inside the `init(info)` method. This suggests a change in the dependent API (obtain() calls init() instead of assigning fields individually) and also an ""Other statement changed"" because of the removal of the direct field assignment statements, qualifying it as types 4 and 5. However, it also changes the return statement, as now the way the object is initialized is different, making it of type 1 as well.","Although the late implementation of the method calls a new method to initialize 'infoClone', there is no evidence that this would lead to a different return value or to different exception handling since it can be assumed the method `init(info)` performs the equivalent operations to what was explicitly done in the early version, hence it should not be considered as a CI (0)."
383,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterY()>,28,29,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterY()>,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterY()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterY();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center Y"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterY(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center Y"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}",1,"/**
 * Returns the unscaled screen-relative Y coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative Y coordinate of the center of
 * the magnified region
 */
","/**
 * Returns the unscaled screen-relative Y coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative Y coordinate of the center of
 * the magnified region
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method connection.getMagnificationCenterY() is now called with an additional parameter mDisplayId, indicating a change in a dependent API, so the code change type is 5.","The addition of parameter mDisplayId to the call within try block does not necessarily imply a change in behavior since there is no return type or exception handling change in the calling method itself. Thus, there is no Compatibility Issue detected here; the change is internal to the dependent API."
384,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,28,29,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(@NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked() {
            AccessibilityService.this.onAccessibilityButtonClicked();
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(int displayId, @NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(displayId, region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked() {
            AccessibilityService.this.onAccessibilityButtonClicked();
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The onMagnificationChanged() method signature in the Callbacks class has changed, adding a new parameter (int displayId) that was not present in the previous version, which constitutes a change in a dependent API, and thus the change type is 4,5.","Even though the method's signature has changed by adding an extra parameter (int displayId), this does not directly imply a compatibility issue at the level of the onBind() method itself. The onBind() method still returns an IBinder object without any alteration to its return type or behavior, and the exceptions it could potentially throw have not been modified. As a result, there is no compatibility issue for onBind() when considering the changes made."
385,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",28,29,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>","<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return getDocumentThumbnail(client, documentUri, size, signal);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        }
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        return ContentResolver.loadThumbnail(content, documentUri, Point.convert(size), signal, ImageDecoder.ALLOCATOR_SOFTWARE);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        }
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
","/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The return statement is completely changed from calling `getDocumentThumbnail(client, documentUri, size, signal)` to `ContentResolver.loadThumbnail(content, documentUri, Point.convert(size), signal, ImageDecoder.ALLOCATOR_SOFTWARE)`. Additionally, the implementation to acquire a `ContentProviderClient` and release it within the try-finally block has been removed. The exception handling has also been streamlined by removing the `resolver` argument from the method `rethrowIfNecessary`. Finally, the implementation depends on a new method `ContentResolver.loadThumbnail`, thus there is a dependent API change as well. Therefore, the code change types are 1, 4, and 5.","This change introduces a new code path that returns a different value due to a new implementation of how the thumbnail is fetched. Additionally, the exception handling behavior has changed; while previously the code rethrew exceptions only if they were not `OperationCanceledException`, and used the resolver to potentially rethrow them, the new implementation no longer takes the resolver into account, so any exception caught by this block can potentially behave differently when rethrown. This means there could be a compatibility issue both in terms of potential different return values or types (CI type 1) and in terms of potential different exception handlings (CI type 2)."
386,<android.text.Layout: int getLineBaseline(int)>,28,29,<android.text.Layout: int getLineBaseline(int)>,<android.text.Layout: int getLineBaseline(int)>,0,"{
    // getLineTop(line+1) == getLineTop(line)
    return getLineTop(line + 1) - getLineDescent(line);
}","{
    // getLineTop(line+1) == getLineBottom(line)
    return getLineTop(line + 1) - getLineDescent(line);
}",1,"/**
 * Return the vertical position of the baseline of the specified line.
 */
","/**
 * Return the vertical position of the baseline of the specified line.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no actual code change; the change is only in the comment. The executable part of the implementation for getLineBaseline(int) remains the same in both versions.,"Since the executable code hasn't changed, there are no changes in the behavior of the API. Therefore, no compatibility issue arises."
389,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,28,29,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,<android.service.notification.ConditionProviderService.H: void handleMessage(Message)>,0,"{
    String name = null;
    if (!isBound()) {
        return;
    }
    try {
        switch(msg.what) {
            case ON_CONNECTED:
                name = ""onConnected"";
                onConnected();
                break;
            case ON_SUBSCRIBE:
                name = ""onSubscribe"";
                onSubscribe((Uri) msg.obj);
                break;
            case ON_UNSUBSCRIBE:
                name = ""onUnsubscribe"";
                onUnsubscribe((Uri) msg.obj);
                break;
        }
    } catch (Throwable t) {
        Log.w(TAG, ""Error running "" + name, t);
    }
}","{
    String name = null;
    if (!mIsConnected) {
        return;
    }
    try {
        switch(msg.what) {
            case ON_CONNECTED:
                name = ""onConnected"";
                onConnected();
                break;
            case ON_SUBSCRIBE:
                name = ""onSubscribe"";
                onSubscribe((Uri) msg.obj);
                break;
            case ON_UNSUBSCRIBE:
                name = ""onUnsubscribe"";
                onUnsubscribe((Uri) msg.obj);
                break;
        }
    } catch (Throwable t) {
        Log.w(TAG, ""Error running "" + name, t);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed from `if (!isBound())` to `if (!mIsConnected)`, so the code change type is 3.","There appears to be no Compatibility Issue, as the change is within a conditional check, changing the condition from the method `isBound()` to the variable `mIsConnected`. If the semantics of `isBound()` are correctly stored in `mIsConnected`, the behavior would remain the same, hence no difference in behavior is expected from this change alone. The modification seems to be an internal refactoring without altering the API's external behavior. Since both the early version and late version have a return statement at the same point, the return value or exception handling is not affected directly by this change unless the semantics of `isBound()` and `mIsConnected` differ."
390,<android.app.KeyguardManager.KeyguardLock: void reenableKeyguard()>,28,29,<android.app.KeyguardManager.KeyguardLock: void reenableKeyguard()>,<android.app.KeyguardManager.KeyguardLock: void reenableKeyguard()>,0,"{
    try {
        mWM.reenableKeyguard(mToken);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mWM.reenableKeyguard(mToken, mContext.getUserId());
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Reenable the keyguard.  The keyguard will reappear if the previous
 * call to {@link #disableKeyguard()} caused it to be hidden.
 *
 * A good place to call this is from {@link android.app.Activity#onPause()}
 *
 * Note: This call has no effect while any {@link android.app.admin.DevicePolicyManager}
 * is enabled that requires a password.
 *
 * @see #disableKeyguard()
 */
","/**
 * Reenable the keyguard.  The keyguard will reappear if the previous
 * call to {@link #disableKeyguard()} caused it to be hidden.
 *
 * A good place to call this is from {@link android.app.Activity#onPause()}
 *
 * Note: This call has no effect while any {@link android.app.admin.DevicePolicyManager}
 * is enabled that requires a password.
 *
 * @see #disableKeyguard()
 */
",-1,[@RequiresPermission(Manifest.permission.DISABLE_KEYGUARD)],[@RequiresPermission(Manifest.permission.DISABLE_KEYGUARD)],-1,-1,-1,-1,-1,-1,5,0,"There is a change in the dependent API call from mWM.reenableKeyguard(mToken) to mWM.reenableKeyguard(mToken, mContext.getUserId()), introducing an additional parameter to the method call. The code change type is 5.","There does not seem to be a Compatibility Issue in terms of return values or exception handling visible from the provided implementation, as the return type is void and the exception handling remains the same with no additional exceptions thrown. Therefore, the CI type is 0."
392,<android.view.WindowInsets: String toString()>,28,29,<android.view.WindowInsets: String toString()>,<android.view.WindowInsets: String toString()>,0,"{
    return ""WindowInsets{systemWindowInsets="" + mSystemWindowInsets + "" windowDecorInsets="" + mWindowDecorInsets + "" stableInsets="" + mStableInsets + (mDisplayCutout != null ? "" cutout="" + mDisplayCutout : """") + (isRound() ? "" round"" : """") + ""}"";
}","{
    return ""WindowInsets{systemWindowInsets="" + getSystemWindowInsets() + "" stableInsets="" + getStableInsets() + "" sysGestureInsets="" + getSystemGestureInsets() + (mDisplayCutout != null ? "" cutout="" + mDisplayCutout : """") + (isRound() ? "" round"" : """") + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed with different methods being called (getSystemWindowInsets(), getStableInsets(), and getSystemGestureInsets()), and a part of the string ("" windowDecorInsets="" + mWindowDecorInsets) is removed. Therefore, the code change type is 1,5.","The change of the return statement with different method calls and the removal of a substring in the representation indicates that the API will return a different string value. Hence, the CI type is 1."
393,<android.provider.MediaStore.Files: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Files: Uri getContentUri(String)>,<android.provider.MediaStore.Files: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/file"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""file"").build();
}",1,"/**
 * Get the content:// style URI for the files table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the files table on the given volume
 */
","/**
 * Get the content:// style URI for the files table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the files table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The method of constructing the Uri has been changed from using Uri.parse with string concatenation to using a Uri Builder. This is classified as an ""Other statement changed"" because it involves the change of the way the URI is built. Additionally, it's a ""Return statement changed"" because the same input `volumeName` could potentially result in different URIs being produced in different versions.","The change in how the URI is constructed (from string concatenation to using a Uri Builder) could lead to a different return value, especially if there is a change in how the Uri Builder interprets the appended paths compared to string concatenation. Therefore, there is potential for a Compatibility Issue due to a different return value (type 1)."
394,<android.service.autofill.UserData: String toString()>,28,29,<android.service.autofill.UserData: String toString()>,<android.service.autofill.UserData: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""UserData: [id="").append(mId).append("", algorithm="").append(mAlgorithm);
    // Cannot disclose category ids or values because they could contain PII
    builder.append("", categoryIds="");
    Helper.appendRedacted(builder, mCategoryIds);
    builder.append("", values="");
    Helper.appendRedacted(builder, mValues);
    return builder.append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""UserData: [id="").append(mId);
    // Cannot disclose category ids or values because they could contain PII
    builder.append("", categoryIds="");
    Helper.appendRedacted(builder, mCategoryIds);
    builder.append("", values="");
    Helper.appendRedacted(builder, mValues);
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The string ""algorithm="" and its associated value mAlgorithm have been removed from the StringBuilder in the late implementation. This change is an other statement change since it does not involve any return statement, exception handling, control dependency, or dependent API changes.","This change does not introduce a compatibility issue since the method's purpose is to return a string representation of the object for debugging or logging, and removing part of that representation does not affect the method's behavior as intended by its signature. The API's contract or external behavior from a functionality standpoint remains intact, and the change only modifies the internal details of the string being returned."
395,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,28,29,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,0,"{
    if (mMagnifierAnimator == null) {
        return;
    }
    final PointF showPosInView = new PointF();
    final boolean shouldShow = !tooLargeTextForMagnifier() && obtainMagnifierShowCoordinates(event, showPosInView);
    if (shouldShow) {
        // Make the cursor visible and stop blinking.
        mRenderCursorRegardlessTiming = true;
        mTextView.invalidateCursorPath();
        suspendBlink();
        mMagnifierAnimator.mMagnifier.setOnOperationCompleteCallback(mHandlesVisibilityCallback);
        mMagnifierAnimator.show(showPosInView.x, showPosInView.y);
    } else {
        dismissMagnifier();
    }
}","{
    if (mMagnifierAnimator == null) {
        return;
    }
    final PointF showPosInView = new PointF();
    final boolean shouldShow = checkForTransforms() && /*check not rotated and compute scale*/
    !tooLargeTextForMagnifier() && obtainMagnifierShowCoordinates(event, showPosInView);
    if (shouldShow) {
        // Make the cursor visible and stop blinking.
        mRenderCursorRegardlessTiming = true;
        mTextView.invalidateCursorPath();
        suspendBlink();
        mMagnifierAnimator.show(showPosInView.x, showPosInView.y);
        updateHandlesVisibility();
    } else {
        dismissMagnifier();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition in the if statement inside updateMagnifier has been modified by adding 'checkForTransforms() &&', and the statement 'mMagnifierAnimator.mMagnifier.setOnOperationCompleteCallback(mHandlesVisibilityCallback);' has been removed. Additionally, the call to 'mHandlesVisibilityCallback' has been replaced with 'updateHandlesVisibility()' outside of the condition. This is a control dependency change (3) because the behavior of the condition has altered, and an other statement change (4) with the removal and addition of method calls.","The changes to the condition for 'shouldShow' could lead to a difference in whether the magnifier is shown or not when invoking 'updateMagnifier'. The deletion of the 'mMagnifierAnimator.mMagnifier.setOnOperationCompleteCallback(...)' call also affects the API's behavior, as it changes how callbacks are handled. As 'updateHandlesVisibility()' could have different implementations compared to the previous callback mechanism, there is the potential for a different behavior which may result in a different return value (1)."
396,"<android.app.admin.DevicePolicyManager: void wipeData(int,CharSequence)>",28,29,"<android.app.admin.DevicePolicyManager: void wipeData(int,CharSequence)>","<android.app.admin.DevicePolicyManager: void wipeData(int,CharSequence)>",0,"{
    throwIfParentInstance(""wipeData"");
    Preconditions.checkNotNull(reason, ""CharSequence is null"");
    wipeDataInternal(flags, reason.toString());
}","{
    throwIfParentInstance(""wipeData"");
    Preconditions.checkNotNull(reason, ""reason string is null"");
    Preconditions.checkStringNotEmpty(reason, ""reason string is empty"");
    Preconditions.checkArgument((flags & WIPE_SILENTLY) == 0, ""WIPE_SILENTLY cannot be set"");
    wipeDataInternal(flags, reason.toString());
}",1,"/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected, the provided reason for wiping data can be shown to
 * user. Calling from the primary user will cause the device to reboot, erasing all device data
 * - including all the secondary users and their data - while booting up. In this case, we don't
 * show the reason to the user since the device would be factory reset.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE} and {@link #WIPE_RESET_PROTECTION_DATA}.
 * @param reason a string that contains the reason for wiping data, which can be
 * presented to the user.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 * @throws IllegalArgumentException if the input reason string is null or empty.
 */
","/**
 * Ask that all user data be wiped. If called as a secondary user, the user will be removed and
 * other users will remain unaffected, the provided reason for wiping data can be shown to
 * user. Calling from the primary user will cause the device to reboot, erasing all device data
 * - including all the secondary users and their data - while booting up. In this case, we don't
 * show the reason to the user since the device would be factory reset.
 * <p>
 * The calling device admin must have requested {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to
 * be able to call this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently supported flags are
 * {@link #WIPE_EXTERNAL_STORAGE}, {@link #WIPE_RESET_PROTECTION_DATA} and
 * {@link #WIPE_EUICC}.
 * @param reason a string that contains the reason for wiping data, which can be
 * presented to the user.
 * @throws SecurityException if the calling application does not own an active administrator
 * that uses {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}
 * @throws IllegalArgumentException if the input reason string is null or empty, or if
 * {@link #WIPE_SILENTLY} is set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"New precondition checks are added to the method (checkStringNotEmpty, checkArgument). This does not change the control flow or the return type/value of the method, but it introduces additional validation on the inputs. So the code change type is 4.","Since the method has no return statement and only new precondition check statements are added without changing the return type/value or the exceptions the method can throw, there is no Compatibility Issue, and the CI type is 0."
397,"<android.app.Activity: void performStop(boolean,String)>",28,29,"<android.app.Activity: void performStop(boolean,String)>","<android.app.Activity: void performStop(boolean,String)>",0,"{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    // Disallow entering picture-in-picture after the activity has been stopped
    mCanEnterPictureInPicture = false;
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        writeEventLog(LOG_AM_ON_STOP_CALLED, reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}","{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    // Disallow entering picture-in-picture after the activity has been stopped
    mCanEnterPictureInPicture = false;
    if (!mStopped) {
        dispatchActivityPreStopped();
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        writeEventLog(LOG_AM_ON_STOP_CALLED, reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
        dispatchActivityPostStopped();
    }
    mResumed = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of dispatchActivityPreStopped() and dispatchActivityPostStopped() method calls, which are changes not directly related to return statements, exception handling statements, or control dependencies. Thus, the change type is 4.","The addition of these method calls should not result in a different return value, nor should it change the exception handling. Dispatch methods typically indicate event notifications and are unlikely to impact the API contract. Therefore, there is no Compatibility Issue; the CI type is 0."
398,<android.app.ContextImpl: Context createDisplayContext(Display)>,28,29,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader);
    final int displayId = display.getDisplayId();
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    context.mDisplay = display;
    return context;
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader, null);
    final int displayId = display.getDisplayId();
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    context.mDisplay = display;
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The instantiation of the ContextImpl class has changed by adding a new `null` parameter at the end of the constructor arguments list. This represents a code change classified as type 4.,"The added `null` parameter does not affect the return type or the exception handling of the method. Therefore, it does not introduce potential Compatibility Issues, so the CI type is 0."
399,<android.service.autofill.SaveCallback: void onFailure(CharSequence)>,28,29,<android.service.autofill.SaveCallback: void onFailure(CharSequence)>,<android.service.autofill.SaveCallback: void onFailure(CharSequence)>,0,"{
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}","{
    Log.w(TAG, ""onFailure(): "" + message);
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}",1,"/**
 * Notifies the Android System that an
 * {@link AutofillService#onSaveRequest(SaveRequest, SaveCallback)} could not be handled
 * by the service.
 *
 * <p>This method should only be called when the service could not handle the request right away
 * and could not recover or retry it. If the service could retry or recover, it could keep
 * the {@link SaveRequest} and call {@link #onSuccess()} instead.
 *
 * <p><b>Note:</b> The Android System displays an UI with the supplied error message; if
 * you prefer to show your own message, call {@link #onSuccess()} or
 * {@link #onSuccess(IntentSender)} instead.
 *
 * @param message error message to be displayed to the user.
 */
","/**
 * Notifies the Android System that an
 * {@link AutofillService#onSaveRequest(SaveRequest, SaveCallback)} could not be handled
 * by the service.
 *
 * <p>This method is just used for logging purposes, the Android System won't call the service
 * again in case of failures&mdash;if you need to recover from the failure, just save the
 * {@link SaveRequest} and try again later.
 *
 * <p><b>Note: </b>for apps targeting {@link android.os.Build.VERSION_CODES#Q} or higher, this
 * method just logs the message on {@code logcat}; for apps targetting older SDKs, it also
 * displays the message to user using a {@link android.widget.Toast}.
 *
 * @param message error message. <b>Note: </b> this message should <b>not</b> contain PII
 * (Personally Identifiable Information, such as username or email address).
 *
 * @throws IllegalStateException if this method, {@link #onSuccess()},
 * or {@link #onSuccess(IntentSender)} was already called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The Log.w(TAG, ""onFailure(): "" + message); line has been added as an additional statement (not altering existing return or exception handling behavior), so the type of change is 4.","There is no compatibility issue as the newly added log statement does not affect the method's return value or how it handles exceptions. The method's behavior remains functionally consistent despite the additional logging; thus, the CI type is 0."
400,<android.service.carrier.CarrierIdentifier: boolean equals(Object)>,28,29,<android.service.carrier.CarrierIdentifier: boolean equals(Object)>,<android.service.carrier.CarrierIdentifier: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    CarrierIdentifier that = (CarrierIdentifier) obj;
    return Objects.equals(mMcc, that.mMcc) && Objects.equals(mMnc, that.mMnc) && Objects.equals(mSpn, that.mSpn) && Objects.equals(mImsi, that.mImsi) && Objects.equals(mGid1, that.mGid1) && Objects.equals(mGid2, that.mGid2);
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    CarrierIdentifier that = (CarrierIdentifier) obj;
    return Objects.equals(mMcc, that.mMcc) && Objects.equals(mMnc, that.mMnc) && Objects.equals(mSpn, that.mSpn) && Objects.equals(mImsi, that.mImsi) && Objects.equals(mGid1, that.mGid1) && Objects.equals(mGid2, that.mGid2) && Objects.equals(mCarrierId, that.mCarrierId) && Objects.equals(mSpecificCarrierId, that.mSpecificCarrierId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified to include additional comparisons with 'mCarrierId' and 'mSpecificCarrierId', so the code change type includes 1 and 4 (Other statement changed due to the addition of new equality checks).","The method now considers more fields in the equality check which means it is possible for the method to return 'false' when comparing the additional fields, where previously it would have returned 'true' if only the original fields matched. Thus, the potential return value of the method has changed, and the CI type is 1."
401,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromSocket(Socket)>,28,29,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromSocket(Socket)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromSocket(Socket)>,0,"{
    FileDescriptor fd = socket.getFileDescriptor$();
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}","{
    FileDescriptor fd = socket.getFileDescriptor$();
    try {
        return fd != null ? ParcelFileDescriptor.dup(fd) : null;
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}",1,"/**
 * Create a new ParcelFileDescriptor from the specified Socket.  The new
 * ParcelFileDescriptor holds a dup of the original FileDescriptor in
 * the Socket, so you must still close the Socket as well as the new
 * ParcelFileDescriptor.
 *
 * @param socket The Socket whose FileDescriptor is used to create
 * a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with the FileDescriptor of the
 * specified Socket.
 */
","/**
 * Create a new ParcelFileDescriptor from the specified Socket.  The new
 * ParcelFileDescriptor holds a dup of the original FileDescriptor in
 * the Socket, so you must still close the Socket as well as the new
 * ParcelFileDescriptor.
 * <p>
 * <strong>WARNING:</strong> Prior to API level 29, this function would not
 * actually dup the Socket's FileDescriptor, and would take a
 * reference to the its internal FileDescriptor instead. If the Socket
 * gets garbage collected before the ParcelFileDescriptor, this may
 * lead to the ParcelFileDescriptor being unexpectedly closed. To avoid
 * this, the following pattern can be used:
 * <pre>{@code
 * ParcelFileDescriptor pfd = ParcelFileDescriptor.fromSocket(socket).dup();
 * }</pre>
 *
 * @param socket The Socket whose FileDescriptor is used to create
 * a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with a duped copy of the
 * FileDescriptor of the specified Socket.
 *
 * @throws UncheckedIOException if {@link #dup(FileDescriptor)} throws IOException.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The implementation now includes exception handling where it did not before, resulting in a potential throw of a new unchecked exception (UncheckedIOException). Furthermore, a dependent API changed as the method calls ParcelFileDescriptor.dup(fd) instead of new ParcelFileDescriptor(fd), so the code change involves return statement, exception handling statement, and dependent API, which are types 1, 2, and 5.","The new version may throw an unchecked exception where the previous one did not, indicating a potential different exception handling, which is a CI (type 2). Additionally, the change from a constructor to the 'dup' method could potentially lead to different return values (due to the nature of the 'dup' method creating a duplicate file descriptor), which is another CI (type 1)."
402,<android.provider.MediaStore: Uri getMediaScannerUri()>,28,29,<android.provider.MediaStore: Uri getMediaScannerUri()>,<android.provider.MediaStore: Uri getMediaScannerUri()>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + ""none/media_scanner"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(""none"").appendPath(""media_scanner"").build();
}",1,"/**
 * Uri for querying the state of the media scanner.
 */
","/**
 * Uri for querying the state of the media scanner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method of creating the Uri is changed; however, the resulting Uri from both the early and late version points to the same logical resource. The change does not affect the return type or value but rather the implementation detail of how the Uri is constructed, so the code change type is 4.","There is no Compatibility Issue since the resulting Uri is logically equivalent despite the difference in construction method. The outcome for the API consumer is the same; therefore, there is no potential different behavior introduced by the change."
404,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,28,29,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,0,"{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return false;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        return ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken, params);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return false;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        return ActivityTaskManager.getService().enterPictureInPictureMode(mToken, params);
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system successfully put this activity into picture-in-picture mode or was
 * already in picture-in-picture mode (@see {@link #isInPictureInPictureMode()). If the device
 * does not support picture-in-picture, return false.
 */
","/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system successfully put this activity into picture-in-picture mode or was
 * already in picture-in-picture mode (see {@link #isInPictureInPictureMode()}). If the device
 * does not support picture-in-picture, return false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method call within the return statement has changed from ActivityManagerNative.getDefault().enterPictureInPictureMode to ActivityTaskManager.getService().enterPictureInPictureMode, which means the change type is 5 as the dependent API has been modified.","Since the dependent API call has changed, it's possible that the new API has a different implementation, which could potentially return different results; thus, there's a Compatibility Issue of type 1 caused by potentially different return values."
405,<android.bluetooth.BluetoothHidDevice: boolean connect(BluetoothDevice)>,28,29,<android.bluetooth.BluetoothHidDevice: boolean connect(BluetoothDevice)>,<android.bluetooth.BluetoothHidDevice: boolean connect(BluetoothDevice)>,0,"{
    boolean result = false;
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            result = service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Initiates connection to host which is currently paired with this device. If the application
 * is not registered, #connect(BluetoothDevice) will fail. The connection state should be
 * tracked by the application by handling callback from Callback#onConnectionStateChanged. The
 * connection state is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Initiates connection to host which is currently paired with this device. If the application
 * is not registered, #connect(BluetoothDevice) will fail. The connection state should be
 * tracked by the application by handling callback from Callback#onConnectionStateChanged. The
 * connection state is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is calling getService() instead of directly accessing mService, which is related to how the service object is obtained. This is a change to the dependent API, so the code change type is 5.","The change does not affect the behavior of the connect(BluetoothDevice) method in terms of the value it returns or the exceptions it throws, therefore, there is no Compatibility Issue."
406,"<android.provider.DocumentsProvider: Cursor query(Uri,String[],Bundle,CancellationSignal)>",28,29,"<android.provider.DocumentsProvider: Cursor query(Uri,String[],Bundle,CancellationSignal)>","<android.provider.DocumentsProvider: Cursor query(Uri,String[],Bundle,CancellationSignal)>",0,"{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    // TODO: Update ""ForManage"" variant to support query args.
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, getSortClause(queryArgs));
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, queryArgs);
                }
            default:
                throw new UnsupportedOperationException(""Unsupported Uri "" + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, ""Failed during query"", e);
        return null;
    }
}","{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection, queryArgs, cancellationSignal);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), projection, queryArgs);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    // TODO: Update ""ForManage"" variant to support query args.
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, getSortClause(queryArgs));
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, queryArgs);
                }
            default:
                throw new UnsupportedOperationException(""Unsupported Uri "" + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, ""Failed during query"", e);
        return null;
    }
}",1,"/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[])
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String, String[])
 */
","/**
 * Implementation is provided by the parent class. Cannot be overridden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[], Bundle, CancellationSignal)
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String[], Bundle)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method signature indicates the addition of `Bundle queryArgs` and `CancellationSignal cancellationSignal` parameters. However, these changes are not reflected in the actual implementation provided, which indicates either missing code or an omission in the manual transcription of the provided information.",
408,"<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>",28,29,"<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>","<android.view.textclassifier.TextClassification.Builder: Builder setEntityType(String,float)>",0,"{
    mEntityConfidence.put(type, confidenceScore);
    return this;
}","{
    setEntityType(type, confidenceScore, null);
    return this;
}",1,"/**
 * Sets an entity type for the classification result and assigns a confidence score.
 * If a confidence score had already been set for the specified entity type, this will
 * override that score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets an entity type for the classification result and assigns a confidence score.
 * If a confidence score had already been set for the specified entity type, this will
 * override that score.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the entity does not exist for the classified text.
 * Values greater than 1 are clamped to 1.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,The implementation of the method now calls another overloaded version of setEntityType with an additional parameter. This change is of type 5 (Dependent API changed).,"There is no Compatibility Issue in this case because the implementation still calls setEntityType but with a different signature that manages the confidence score without changing the external behavior seen by the caller. The builder pattern remains intact as 'this' is still returned, hence, no CI (0)."
409,<android.content.ContentValues: byte[] getAsByteArray(String)>,28,29,<android.content.ContentValues: byte[] getAsByteArray(String)>,<android.content.ContentValues: byte[] getAsByteArray(String)>,0,"{
    Object value = mValues.get(key);
    if (value instanceof byte[]) {
        return (byte[]) value;
    } else {
        return null;
    }
}","{
    Object value = mMap.get(key);
    if (value instanceof byte[]) {
        return (byte[]) value;
    } else {
        return null;
    }
}",1,"/**
 * Gets a value that is a byte array. Note that this method will not convert
 * any other types to byte arrays.
 *
 * @param key the value to get
 * @return the {@code byte[]} value, or {@code null} is the value is missing or not a
 * {@code byte[]}
 */
","/**
 * Gets a value that is a byte array. Note that this method will not convert
 * any other types to byte arrays.
 *
 * @param key the value to get
 * @return the {@code byte[]} value, or {@code null} is the value is missing or not a
 * {@code byte[]}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the implementation is the use of different member variables to retrieve the value (from 'mValues.get(key)' to 'mMap.get(key)'), which is a part of the Dependent API changed (Different member variable used to achieve the same functionality, no return or exception handling statement has been changed), the code change type is 4,5.","Despite the change in the internal member variable used to retrieve the value, the behavior of the method remains the same from the caller's perspective. The method still returns a byte[] if the key corresponds to a byte[] value, otherwise, it returns null. Therefore, there is no Compatibility Issue concerning return values or types, and exception handling remains unchanged as well, so the CI type is 0."
410,<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl)>,28,29,<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl)>,<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl)>,0,"{
    final LoadedApk packageInfo = systemContext.mPackageInfo;
    ContextImpl context = new ContextImpl(null, systemContext.mMainThread, packageInfo, null, null, null, 0, null);
    context.setResources(createResources(null, packageInfo, null, Display.DEFAULT_DISPLAY, null, packageInfo.getCompatibilityInfo()));
    return context;
}","{
    return createSystemUiContext(systemContext, Display.DEFAULT_DISPLAY);
}",1,"/**
 * System Context to be used for UI. This Context has resources that can be themed.
 * Make sure that the created system UI context shares the same LoadedApk as the system context.
 */
","/**
 * The overloaded method of {@link #createSystemUiContext(ContextImpl, int)}.
 * Uses {@Code Display.DEFAULT_DISPLAY} as the target display.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from constructing a new `ContextImpl` and setting resources to invoking a different method `createSystemUiContext(systemContext, Display.DEFAULT_DISPLAY)`. Also, this new method invocation implies a dependent API change since we're now relying on an external method. So, the code change type is 1, 5.","Since the implementation of the method has been completely replaced with a call to another method, the return value may differ between versions. The late version of the API may potentially return a different type or instance of `ContextImpl` due to different initialization logic in `createSystemUiContext`, so the CI type is 1."
411,<android.os.storage.StorageManager: UUID getUuidForPath(File)>,28,29,<android.os.storage.StorageManager: UUID getUuidForPath(File)>,<android.os.storage.StorageManager: UUID getUuidForPath(File)>,0,"{
    Preconditions.checkNotNull(path);
    final String pathString = path.getCanonicalPath();
    if (FileUtils.contains(Environment.getDataDirectory().getAbsolutePath(), pathString)) {
        return UUID_DEFAULT;
    }
    try {
        for (VolumeInfo vol : mStorageManager.getVolumes(0)) {
            if (vol.path != null && FileUtils.contains(vol.path, pathString) && vol.type != VolumeInfo.TYPE_PUBLIC) {
                // underlying volume
                try {
                    return convert(vol.fsUuid);
                } catch (IllegalArgumentException e) {
                    continue;
                }
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    throw new FileNotFoundException(""Failed to find a storage device for "" + path);
}","{
    Preconditions.checkNotNull(path);
    final String pathString = path.getCanonicalPath();
    if (FileUtils.contains(Environment.getDataDirectory().getAbsolutePath(), pathString)) {
        return UUID_DEFAULT;
    }
    try {
        for (VolumeInfo vol : mStorageManager.getVolumes(0)) {
            if (vol.path != null && FileUtils.contains(vol.path, pathString) && vol.type != VolumeInfo.TYPE_PUBLIC && vol.type != VolumeInfo.TYPE_STUB) {
                // underlying volume
                try {
                    return convert(vol.fsUuid);
                } catch (IllegalArgumentException e) {
                    continue;
                }
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    throw new FileNotFoundException(""Failed to find a storage device for "" + path);
}",1,"/**
 * Return a UUID identifying the storage volume that hosts the given
 * filesystem path.
 * <p>
 * If this path is hosted by the default internal storage of the device at
 * {@link Environment#getDataDirectory()}, the returned value will be
 * {@link #UUID_DEFAULT}.
 *
 * @throws IOException when the storage device hosting the given path isn't
 * present, or when it doesn't have a valid UUID.
 */
","/**
 * Return a UUID identifying the storage volume that hosts the given
 * filesystem path.
 * <p>
 * If this path is hosted by the default internal storage of the device at
 * {@link Environment#getDataDirectory()}, the returned value will be
 * {@link #UUID_DEFAULT}.
 *
 * @throws IOException when the storage device hosting the given path isn't
 * present, or when it doesn't have a valid UUID.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,3,0,"There has been a condition added to an 'if' statement inside a loop in the late version (vol.type != VolumeInfo.TYPE_STUB). This is the only change detected, so the code change type is 3 (Control dependency change).","Although a control dependency change is present, it does not necessarily lead to a CI because the added condition (vol.type != VolumeInfo.TYPE_STUB) merely excludes additional type of volume from consideration while fetching UUID. If a volume is of type TYPE_STUB, it would not have been considered acceptable in the previous implementation either, since this seems to be a refinement of the logic to exclude an additional case. It does not introduce a new behavior or affect the returned UUID for cases that would have previously been valid. Therefore, the change does not lead to a compatibility issue. The CI type is 0 (No Compatibility Issue)."
412,<android.widget.ProgressBar: Mode getProgressBackgroundTintMode()>,28,29,<android.widget.ProgressBar: Mode getProgressBackgroundTintMode()>,<android.widget.ProgressBar: Mode getProgressBackgroundTintMode()>,0,"{
    return mProgressTintInfo != null ? mProgressTintInfo.mProgressBackgroundTintMode : null;
}","{
    BlendMode mode = getProgressBackgroundTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * @return the blending mode used to apply the tint to the progress
 * background
 * @attr ref android.R.styleable#ProgressBar_progressBackgroundTintMode
 * @see #setProgressBackgroundTintMode(PorterDuff.Mode)
 */
","/**
 * @return the blending mode used to apply the tint to the progress
 * background
 * @attr ref android.R.styleable#ProgressBar_progressBackgroundTintMode
 * @see #setProgressBackgroundTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed to use a different API, `getProgressBackgroundTintBlendMode()`, and convert its result with `BlendMode.blendModeToPorterDuffMode(mode)` which represents a change in the method used to retrieve the progress background tint mode. Additionally, a method from a different (dependent) API is being used, so the code change types are 1,5.","The late version is using a different API to get the blend mode, and then converts it to a porter-duff mode, which could potentially lead to a different return value than the early version. Thus, the CI type is 1."
413,<android.service.autofill.UserData: String getFieldClassificationAlgorithm()>,28,29,<android.service.autofill.UserData: String getFieldClassificationAlgorithm()>,<android.service.autofill.UserData: String getFieldClassificationAlgorithm()>,0,"{
    return mAlgorithm;
}","{
    return mDefaultAlgorithm;
}",1,"/**
 * Gets the name of the algorithm that is used to calculate
 * {@link Match#getScore() match scores}.
 */
","/**
 * Gets the name of the default algorithm that is used to calculate
 * {@link Match#getScore()} match scores}.
 */
",-1,[@Nullable],"[@Nullable, @Override]",-1,-1,-1,-1,-1,-1,1,1,"The return statement changed from returning 'mAlgorithm' to returning 'mDefaultAlgorithm'. This is a change in the source of the returned value, which constitutes a change type of 1.","Since the method now returns a different member variable, the API could potentially return a different value, even though the return type remains the same. Hence, the CI type is 1."
414,<android.app.NotificationChannelGroup: int hashCode()>,28,29,<android.app.NotificationChannelGroup: int hashCode()>,<android.app.NotificationChannelGroup: int hashCode()>,0,"{
    int result = getId() != null ? getId().hashCode() : 0;
    result = 31 * result + (getName() != null ? getName().hashCode() : 0);
    result = 31 * result + (getDescription() != null ? getDescription().hashCode() : 0);
    result = 31 * result + (isBlocked() ? 1 : 0);
    result = 31 * result + (getChannels() != null ? getChannels().hashCode() : 0);
    return result;
}","{
    return Objects.hash(getId(), getName(), getDescription(), isBlocked(), getChannels(), mUserLockedFields);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",0,"The method for calculating the hash code has been changed from a manual calculation to using Objects.hash(). Additional field mUserLockedFields is also included in the hash calculation in the late implementation, and the dependent API Objects.hash() is used instead of the manual calculation. The hashCode() implementation is completely refactored, hence the code change types are 1,4,5.","There is no Compatibility Issue in hashCode() change because the method's contract is to return an int representing the objects hash, and that contract remains. As long as the method returns a consistent hash code for the same object before and after the change, which is the standard behavior for hashCode(), no CI is expected to arise. The specific value of the hash code isn't generally relied upon, just that it is consistent, so changing the way it is computed doesn't cause a compatibility issue."
416,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,String[],MatchFilter,TransformFilter)>",28,29,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,String[],MatchFilter,TransformFilter)>","<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,String[],MatchFilter,TransformFilter)>",0,"{
    final String[] schemesCopy;
    if (defaultScheme == null)
        defaultScheme = """";
    if (schemes == null || schemes.length < 1) {
        schemes = EmptyArray.STRING;
    }
    schemesCopy = new String[schemes.length + 1];
    schemesCopy[0] = defaultScheme.toLowerCase(Locale.ROOT);
    for (int index = 0; index < schemes.length; index++) {
        String scheme = schemes[index];
        schemesCopy[index + 1] = (scheme == null) ? """" : scheme.toLowerCase(Locale.ROOT);
    }
    boolean hasMatches = false;
    Matcher m = pattern.matcher(spannable);
    while (m.find()) {
        int start = m.start();
        int end = m.end();
        boolean allowed = true;
        if (matchFilter != null) {
            allowed = matchFilter.acceptMatch(spannable, start, end);
        }
        if (allowed) {
            String url = makeUrl(m.group(0), schemesCopy, m, transformFilter);
            applyLink(url, start, end, spannable);
            hasMatches = true;
        }
    }
    return hasMatches;
}","{
    return addLinks(spannable, pattern, defaultScheme, schemes, matchFilter, transformFilter, null);
}",1,"/**
 * Applies a regex to a Spannable turning the matches into links.
 *
 * @param spannable Spannable whose text is to be marked-up with links.
 * @param pattern Regex pattern to be used for finding links.
 * @param defaultScheme The default scheme to be prepended to links if the link does not
 * start with one of the <code>schemes</code> given.
 * @param schemes Array of schemes (eg <code>http://</code>) to check if the link found
 * contains a scheme. Passing a null or empty value means prepend defaultScheme
 * to all links.
 * @param matchFilter  The filter that is used to allow the client code additional control
 * over which pattern matches are to be converted into links.
 * @param transformFilter Filter to allow the client code to update the link found.
 *
 * @return True if at least one link is found and applied.
 */
","/**
 * Applies a regex to a Spannable turning the matches into links.
 *
 * @param spannable Spannable whose text is to be marked-up with links.
 * @param pattern Regex pattern to be used for finding links.
 * @param defaultScheme The default scheme to be prepended to links if the link does not
 * start with one of the <code>schemes</code> given.
 * @param schemes Array of schemes (eg <code>http://</code>) to check if the link found
 * contains a scheme. Passing a null or empty value means prepend defaultScheme
 * to all links.
 * @param matchFilter  The filter that is used to allow the client code additional control
 * over which pattern matches are to be converted into links.
 * @param transformFilter Filter to allow the client code to update the link found.
 *
 * @return True if at least one link is found and applied.
 *
 * @see #addLinks(Spannable, Pattern, String, String[], MatchFilter, TransformFilter, Function)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version of the method contains a complete implementation, while the late version is now calling another method, presumably an overloaded version of addLinks(). Since the whole body of the method has been replaced by a single call to another method, the return statement has changed, and it's dependent on the implementation of that newly called method. Therefore, the code change is classified as both 1 (Return statement changed) and 5 (Dependent API changed).","Since the late version of the method delegates its functionality to another method, there's potential for changes in behavior, especially if the new addLinks method that's being called behaves differently from the inlined logic that was present in the early version. Hence, there's a potential compatibility issue due to the possibility of different return values, categorized as 1."
418,"<android.content.pm.CrossProfileApps: void startMainActivity(ComponentName,UserHandle)>",28,29,"<android.content.pm.CrossProfileApps: void startMainActivity(ComponentName,UserHandle)>","<android.content.pm.CrossProfileApps: void startMainActivity(ComponentName,UserHandle)>",0,"{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, targetUser);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}","{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, targetUser.getIdentifier(), true);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts the specified main activity of the caller package in the specified profile.
 *
 * @param component The ComponentName of the activity to launch, it must be exported and has
 * action {@link android.content.Intent#ACTION_MAIN}, category
 * {@link android.content.Intent#CATEGORY_LAUNCHER}. Otherwise, SecurityException will
 * be thrown.
 * @param targetUser The UserHandle of the profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 */
","/**
 * Starts the specified main activity of the caller package in the specified profile.
 *
 * @param component The ComponentName of the activity to launch, it must be exported and has
 * action {@link android.content.Intent#ACTION_MAIN}, category
 * {@link android.content.Intent#CATEGORY_LAUNCHER}. Otherwise, SecurityException will
 * be thrown.
 * @param targetUser The UserHandle of the profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method `startActivityAsUser` from the class `mService` now includes an additional parameter (`targetUser.getIdentifier()` and `true`) in the late version. The difference in the method signature specifies the change type as 4,5.","While the method `startActivityAsUser` has an additional parameter in its invocation, it does not lead to a compatibility issue from the perspective of this API's callers since the method call is encapsulated within a try block, and any exceptions thrown would still result in a `RemoteException` being rethrown from the system server. As such, the method signature change in the dependent API does not affect the behavior of the `startMainActivity` API with respect to its callers, and therefore, it does not introduce a compatibility issue."
419,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,28,29,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.isEmpty()) {
            try {
                mService.addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.isEmpty()) {
            try {
                mService.addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName(), mContext.getUserId());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method mService.addPrimaryClipChangedListener() now includes an additional parameter, mContext.getUserId(), in its call. This shows that a dependent API has changed. Hence, the code change type is 5.","This code change does not directly lead to compatibility issues as the body of the method addPrimaryClipChangedListener(OnPrimaryClipChangedListener) remains the same in terms of its control flow and executed operations from an external perspective. The adding of an additional parameter to a method call within this method does not alter the behavior of the method itself with respect to its contract. There are no changes to return values, thrown exceptions, or control flow that affect the caller. Thus, no Compatibility Issue exists here."
420,<android.app.Activity: void onBackPressed()>,28,29,<android.app.Activity: void onBackPressed()>,<android.app.Activity: void onBackPressed()>,0,"{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (fragmentManager.isStateSaved() || !fragmentManager.popBackStackImmediate()) {
        finishAfterTransition();
    }
}","{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (!fragmentManager.isStateSaved() && fragmentManager.popBackStackImmediate()) {
        return;
    }
    if (!isTaskRoot()) {
        // If the activity is not the root of the task, allow finish to proceed normally.
        finishAfterTransition();
        return;
    }
    try {
        // Inform activity task manager that the activity received a back press
        // while at the root of the task. This call allows ActivityTaskManager
        // to intercept or defer finishing.
        ActivityTaskManager.getService().onBackPressedOnTaskRoot(mToken, new IRequestFinishCallback.Stub() {

            public void requestFinish() {
                mHandler.post(() -> finishAfterTransition());
            }
        });
    } catch (RemoteException e) {
        finishAfterTransition();
    }
}",1,"/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
","/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The control dependency inside the second 'if' condition has changed, and the finishAfterTransition() method call has been moved into a different control flow, which means a 'return' statement was added. Additionally, there is a new 'try-catch' block added with exception handling for RemoteException, which leads to invoking ActivityTaskManager.getService(). Hence, the change type includes 1 (due to the additional 'return'), 2 (introduced exception handling), 3 (control dependency changes due to the altered conditions and the new 'if' condition), and 4 (due to entirely new statements).","The altered control flow can result in different behaviors of the onBackPressed() method. Previously, finishAfterTransition() would be called if the fragment stack could not be popped or if the state was saved. In the late version, finishAfterTransition() can now be called conditionally depending on whether the activity is root of the task. In addition, a new remote call is introduced which could throw a RemoteException, resulting in the invocation of finishAfterTransition(). Both of these changes potentially lead to different return values or paths (1) and different exception handlings (2). The API now could potentially return without calling finishAfterTransition() depending on new conditions that were not present earlier and could throw an exception that was previously caught and logged (2)."
421,"<android.provider.FontsContract: Typeface buildTypeface(Context,CancellationSignal,FontInfo[])>",28,29,"<android.provider.FontsContract: Typeface buildTypeface(Context,CancellationSignal,FontInfo[])>","<android.provider.FontsContract: Typeface buildTypeface(Context,CancellationSignal,FontInfo[])>",0,"{
    if (context.isRestricted()) {
        // TODO: Should we allow if the peer process is system or myself?
        return null;
    }
    final Map<Uri, ByteBuffer> uriBuffer = prepareFontData(context, fonts, cancellationSignal);
    if (uriBuffer.isEmpty()) {
        return null;
    }
    return new Typeface.Builder(fonts, uriBuffer).build();
}","{
    if (context.isRestricted()) {
        // TODO: Should we allow if the peer process is system or myself?
        return null;
    }
    final Map<Uri, ByteBuffer> uriBuffer = prepareFontData(context, fonts, cancellationSignal);
    if (uriBuffer.isEmpty()) {
        return null;
    }
    FontFamily.Builder familyBuilder = null;
    for (FontInfo fontInfo : fonts) {
        final ByteBuffer buffer = uriBuffer.get(fontInfo.getUri());
        if (buffer == null) {
            continue;
        }
        try {
            final Font font = new Font.Builder(buffer).setWeight(fontInfo.getWeight()).setSlant(fontInfo.isItalic() ? FontStyle.FONT_SLANT_ITALIC : FontStyle.FONT_SLANT_UPRIGHT).setTtcIndex(fontInfo.getTtcIndex()).setFontVariationSettings(fontInfo.getAxes()).build();
            if (familyBuilder == null) {
                familyBuilder = new FontFamily.Builder(font);
            } else {
                familyBuilder.addFont(font);
            }
        } catch (IllegalArgumentException e) {
            // thrown by native code and returns null.
            return null;
        } catch (IOException e) {
            continue;
        }
    }
    if (familyBuilder == null) {
        return null;
    }
    final FontFamily family = familyBuilder.build();
    final FontStyle normal = new FontStyle(FontStyle.FONT_WEIGHT_NORMAL, FontStyle.FONT_SLANT_UPRIGHT);
    Font bestFont = family.getFont(0);
    int bestScore = normal.getMatchScore(bestFont.getStyle());
    for (int i = 1; i < family.getSize(); ++i) {
        final Font candidate = family.getFont(i);
        final int score = normal.getMatchScore(candidate.getStyle());
        if (score < bestScore) {
            bestFont = candidate;
            bestScore = score;
        }
    }
    return new Typeface.CustomFallbackBuilder(family).setStyle(bestFont.getStyle()).build();
}",1,"/**
 * Build a Typeface from an array of {@link FontInfo}
 *
 * Results that are marked as not ready will be skipped.
 *
 * @param context A {@link Context} that will be used to fetch the font contents.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none. If
 * the operation is canceled, then {@link
 * android.os.OperationCanceledException} will be thrown.
 * @param fonts An array of {@link FontInfo} to be used to create a Typeface.
 * @return A Typeface object. Returns null if typeface creation fails.
 */
","/**
 * Build a Typeface from an array of {@link FontInfo}
 *
 * Results that are marked as not ready will be skipped.
 *
 * @param context A {@link Context} that will be used to fetch the font contents.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none. If
 * the operation is canceled, then {@link
 * android.os.OperationCanceledException} will be thrown.
 * @param fonts An array of {@link FontInfo} to be used to create a Typeface.
 * @return A Typeface object. Returns null if typeface creation fails.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been changed since it is using a new method to build the Typeface object. Additionally, there are other statement changes with the addition of iteration over fonts array, conditionals, and building FontFamily and Font objects. Also, the `Typeface.Builder` constructor call has been replaced by a different mechanism to construct a Typeface, involving a `FontFamily.Builder` and `Typeface.CustomFallbackBuilder`. Moreover, the dependent API has been changed since the addition of new classes and methods like `Font.Builder`, `FontFamily.Builder`, and `Typeface.CustomFallbackBuilder`, which are likely to belong to the Android SDK but were not used in the early implementation. Hence, the change type is 1,4,5.","Due to the change in the process of building the Typeface object, the final output Typeface may be different compared to the previous version, thus leading to a potential Compatibility Issue due to the different return value. The late version may produce a different Typeface especially since it utilizes a custom fallback mechanism and considers the best matching font style based on certain conditions, which did not exist in the early version. Therefore, the CI type is 1."
423,<android.view.autofill.AutofillId: boolean equals(Object)>,28,29,<android.view.autofill.AutofillId: boolean equals(Object)>,<android.view.autofill.AutofillId: boolean equals(Object)>,0,"{
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    final AutofillId other = (AutofillId) obj;
    if (mViewId != other.mViewId)
        return false;
    if (mVirtualId != other.mVirtualId)
        return false;
    return true;
}","{
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    final AutofillId other = (AutofillId) obj;
    if (mViewId != other.mViewId)
        return false;
    if (mVirtualIntId != other.mVirtualIntId)
        return false;
    if (mVirtualLongId != other.mVirtualLongId)
        return false;
    if (mSessionId != other.mSessionId)
        return false;
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 4",1,"The late implementation has added new checks for fields mVirtualLongId and mSessionId which don't exist in the early version, altering the logic used to determine equality. There's a field name change from mVirtualId to mVirtualIntId, and new fields are involved in equality check. This results in change types 1 (for the new return paths introduced by the additional checks) and 4 (for the changes in the fields used in equality checks).","The modifications in the logic for equality comparison (additional checks for mSessionId and changes from mVirtualId to mVirtualIntId and adding mVirtualLongId) can cause the method to return different results for the same input (an instance of the object being compared). Since equality comparison can now consider additional fields that were not previously considered, there is a potential Compatibility Issue of type 1 due to different return values."
424,<android.view.autofill.AutofillId: int hashCode()>,28,29,<android.view.autofill.AutofillId: int hashCode()>,<android.view.autofill.AutofillId: int hashCode()>,0,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + mViewId;
    result = prime * result + mVirtualId;
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + mViewId;
    result = prime * result + mVirtualIntId;
    result = prime * result + (int) (mVirtualLongId ^ (mVirtualLongId >>> 32));
    result = prime * result + mSessionId;
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the hashCode() method has new calculations, including operations with mVirtualIntId, mVirtualLongId, and mSessionId, whereas the early version only considered mViewId and mVirtualId. This is an instance of class 1 (Return statement changed), and 4 (Other statement changed) because there are new arithmetic operations introduced in the late version.","The late version of the API adds variables mVirtualIntId, incorporates bits from mVirtualLongId, and includes mSessionId into the hash calculation, which inevitably leads to a different return value. Therefore, a Compatibility Issue could arise due to different return values (type 1)."
425,<android.printservice.recommendation.RecommendationService.MyHandler: void handleMessage(Message)>,28,29,<android.printservice.recommendation.RecommendationService.MyHandler: void handleMessage(Message)>,<android.printservice.recommendation.RecommendationService.MyHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_CONNECT:
            mCallbacks = (IRecommendationServiceCallbacks) msg.obj;
            onConnected();
            break;
        case MSG_DISCONNECT:
            onDisconnected();
            mCallbacks = null;
            break;
        case MSG_UPDATE:
            // transaction is actually processed.
            try {
                mCallbacks.onRecommendationsUpdated((List<RecommendationInfo>) msg.obj);
            } catch (RemoteException | NullPointerException e) {
                Log.e(LOG_TAG, ""Could not update recommended services"", e);
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_CONNECT:
            mCallbacks = (IRecommendationServiceCallbacks) msg.obj;
            onConnected();
            break;
        case MSG_DISCONNECT:
            onDisconnected();
            mCallbacks = null;
            break;
        case MSG_UPDATE:
            if (mCallbacks != null) {
                // change binder transaction is actually processed.
                try {
                    mCallbacks.onRecommendationsUpdated((List<RecommendationInfo>) msg.obj);
                } catch (RemoteException | NullPointerException e) {
                    Log.e(LOG_TAG, ""Could not update recommended services"", e);
                }
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The code change is the introduction of an 'if' statement checking whether mCallbacks is not null before attempting to use it, thus the code change type is 3.","Because the newly added 'if' condition ensures that the code inside the MSG_UPDATE case is only executed if mCallbacks is not null, it prevents NullPointerException that could happen in the early version. However, as the behavior of API in terms of the successful completion and return values have not changed (the block inside remains the same), there is no expected potential difference that will affect the behavior seen by the API consumer. Hence, there is no compatibility issue, so the CI type is 0."
427,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,28,29,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,<android.os.StrictMode: void setVmPolicy(VmPolicy)>,0,"{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicy.mask & VM_PENALTY_MASK) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
        int networkPolicy = NETWORK_POLICY_ACCEPT;
        if ((sVmPolicy.mask & DETECT_VM_CLEARTEXT_NETWORK) != 0) {
            if ((sVmPolicy.mask & PENALTY_DEATH) != 0 || (sVmPolicy.mask & PENALTY_DEATH_ON_CLEARTEXT_NETWORK) != 0) {
                networkPolicy = NETWORK_POLICY_REJECT;
            } else {
                networkPolicy = NETWORK_POLICY_LOG;
            }
        }
        final INetworkManagementService netd = INetworkManagementService.Stub.asInterface(ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
        if (netd != null) {
            try {
                netd.setUidCleartextNetworkPolicy(android.os.Process.myUid(), networkPolicy);
            } catch (RemoteException ignored) {
            }
        } else if (networkPolicy != NETWORK_POLICY_ACCEPT) {
            Log.w(TAG, ""Dropping requested network policy due to missing service!"");
        }
        if ((sVmPolicy.mask & DETECT_VM_NON_SDK_API_USAGE) != 0) {
            VMRuntime.setNonSdkApiUsageConsumer(sNonSdkApiUsageConsumer);
            VMRuntime.setDedupeHiddenApiWarnings(false);
        } else {
            VMRuntime.setNonSdkApiUsageConsumer(null);
            VMRuntime.setDedupeHiddenApiWarnings(true);
        }
    }
}","{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicy.mask & PENALTY_ALL) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
        int networkPolicy = NETWORK_POLICY_ACCEPT;
        if ((sVmPolicy.mask & DETECT_VM_CLEARTEXT_NETWORK) != 0) {
            if ((sVmPolicy.mask & PENALTY_DEATH) != 0 || (sVmPolicy.mask & PENALTY_DEATH_ON_CLEARTEXT_NETWORK) != 0) {
                networkPolicy = NETWORK_POLICY_REJECT;
            } else {
                networkPolicy = NETWORK_POLICY_LOG;
            }
        }
        final INetworkManagementService netd = INetworkManagementService.Stub.asInterface(ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
        if (netd != null) {
            try {
                netd.setUidCleartextNetworkPolicy(android.os.Process.myUid(), networkPolicy);
            } catch (RemoteException ignored) {
            }
        } else if (networkPolicy != NETWORK_POLICY_ACCEPT) {
            Log.w(TAG, ""Dropping requested network policy due to missing service!"");
        }
        if ((sVmPolicy.mask & DETECT_VM_NON_SDK_API_USAGE) != 0) {
            VMRuntime.setNonSdkApiUsageConsumer(sNonSdkApiUsageConsumer);
            VMRuntime.setDedupeHiddenApiWarnings(false);
        } else {
            VMRuntime.setNonSdkApiUsageConsumer(null);
            VMRuntime.setDedupeHiddenApiWarnings(true);
        }
        setBlockGuardVmPolicy(sVmPolicy.mask);
    }
}",1,"/**
 * Sets the policy for what actions in the VM process (on any thread) should be detected, as
 * well as the penalty if such actions occur.
 *
 * @param policy the policy to put into place
 */
","/**
 * Sets the policy for what actions in the VM process (on any thread) should be detected, as
 * well as the penalty if such actions occur.
 *
 * @param policy the policy to put into place
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change includes the addition of the statement setBlockGuardVmPolicy(sVmPolicy.mask); at the end of the synchronized block, which is not related to any return statement or exception handling statement, so the code change type is 4.","The added statement setBlockGuardVmPolicy(sVmPolicy.mask); does not change the way exceptions are handled or values are returned by the method since it's a void method, hence the added line does not cause any compatibility issue; therefore, the Compatibility Issue situation remains 0."
428,"<android.hardware.radio.Utils: Map<String, Integer> readStringIntMap(Parcel)>",28,29,"<android.hardware.radio.Utils: Map<String, Integer> readStringIntMap(Parcel)>","<android.hardware.radio.Utils: Map<String, Integer> readStringIntMap(Parcel)>",0,"{
    int size = in.readInt();
    Map<String, Integer> map = new HashMap<>();
    while (size-- > 0) {
        String key = in.readString();
        int value = in.readInt();
        map.put(key, value);
    }
    return map;
}","{
    int size = in.readInt();
    Map<String, Integer> map = new HashMap<>(size);
    while (size-- > 0) {
        String key = in.readString();
        int value = in.readInt();
        map.put(key, value);
    }
    return map;
}",1,,,-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change made in the late version of the code is the addition of `size` as an initial capacity to the `HashMap` constructor. This is an optimization to set the capacity of the map to the number of elements it will contain. This change does not affect the API's existing behavior; hence, the type of change is 4 (Other statement changed).","There is no Compatibility Issue here since the method's contract remains the same, and the return value and exception handling haven't changed. The optimization does not alter the functional behavior from an external perspective."
429,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo findFocus(int)>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo findFocus(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo findFocus(int)>,0,"{
    enforceSealed();
    enforceValidFocusType(focus);
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, mWindowId, mSourceNodeId, focus);
}","{
    enforceSealed();
    enforceValidFocusType(focus);
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, mWindowId, mSourceNodeId, focus);
}",1,"/**
 * Find the view that has the specified focus type. The search starts from
 * the view represented by this node info.
 *
 * @param focus The focus to find. One of {@link #FOCUS_INPUT} or
 * {@link #FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see #FOCUS_INPUT
 * @see #FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search starts from
 * the view represented by this node info.
 *
 * @param focus The focus to find. One of {@link #FOCUS_INPUT} or
 * {@link #FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see #FOCUS_INPUT
 * @see #FOCUS_ACCESSIBILITY
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the argument list for the method call canPerformRequestOverConnection(), where an extra argument mConnectionId has been added in the late version. Therefore, the code change type is 5.","The modification does not add new behavior or change the existing control flow; instead, it changes the parameters passed to another API method. There is no direct indication that this leads to a CI since the return value or exception handling for the method findFocus() has not changed. Thus, there is no Compatibility Issue; the CI type is 0."
430,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableCaptureResultKeys()>,28,29,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableCaptureResultKeys()>,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableCaptureResultKeys()>,0,"{
    if (mAvailableResultKeys == null) {
        Object crKey = CaptureResult.Key.class;
        Class<CaptureResult.Key<?>> crKeyTyped = (Class<CaptureResult.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS);
        if (filterTags == null) {
            throw new AssertionError(""android.request.availableResultKeys must be non-null "" + ""in the characteristics"");
        }
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class, crKeyTyped, filterTags);
    }
    return mAvailableResultKeys;
}","{
    if (mAvailableResultKeys == null) {
        Object crKey = CaptureResult.Key.class;
        Class<CaptureResult.Key<?>> crKeyTyped = (Class<CaptureResult.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS);
        if (filterTags == null) {
            throw new AssertionError(""android.request.availableResultKeys must be non-null "" + ""in the characteristics"");
        }
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class, crKeyTyped, filterTags, /*includeSynthetic*/
        true);
    }
    return mAvailableResultKeys;
}",1,"/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureResult}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureResults.
 */
","/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureResult}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureResults.
 */
",-1,"[@SuppressWarnings({ ""unchecked"" }), @NonNull]","[@SuppressWarnings({ ""unchecked"" }), @NonNull]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method getAvailableKeyList in the late version includes an additional boolean parameter (/*includeSynthetic*/ true) which is not present in the early version. This change in the method signature and the way the method is called represents both a different statement (type 4) and a Dependency API change (type 5). Furthermore, since the method may rely on the additional parameter to determine the output, the return statement is also impacted (type 1).","The introduction of the additional parameter in the method call to getAvailableKeyList means that the method could potentially return a different list of keys, which would be a change in the return value. Therefore, the change could potentially cause the API to return a different value, indicating a Compatibility Issue (type 1)."
431,<android.view.autofill.AutofillValue: AutofillValue forText(CharSequence)>,28,29,<android.view.autofill.AutofillValue: AutofillValue forText(CharSequence)>,<android.view.autofill.AutofillValue: AutofillValue forText(CharSequence)>,0,"{
    return value == null ? null : new AutofillValue(AUTOFILL_TYPE_TEXT, TextUtils.trimNoCopySpans(value));
}","{
    if (sVerbose && !Looper.getMainLooper().isCurrentThread()) {
        Log.v(TAG, ""forText() not called on main thread: "" + Thread.currentThread());
    }
    return value == null ? null : new AutofillValue(AUTOFILL_TYPE_TEXT, TextUtils.trimNoCopySpans(value));
}",1,"/**
 * Creates a new {@link AutofillValue} to autofill a {@link View} representing a text field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TEXT} for more info.
 */
","/**
 * Creates a new {@link AutofillValue} to autofill a {@link View} representing a text field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TEXT} for more info.
 *
 * <p><b>Note:</b> This method is not thread safe and can throw an exception if the
 * {@code value} is modified by a different thread before it returns.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The newer implementation adds a logging statement that is executed when the method is not called from the main thread, but it doesn't affect the method's return value or throw any new exceptions. So the code change type is 4.","Despite the added log statement, this change does not lead to any Compatibility Issue because it does not affect the API's behavior in terms of what it returns or what exceptions it might throw. The API's output remains the same regardless of where it is called from. Thus, there is no Compatibility Issue."
432,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",28,29,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",0,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    // Activity.attach expects a non-null Application Object.
    if (application == null) {
        application = new Application();
    }
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null);
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    // Activity.attach expects a non-null Application Object.
    if (application == null) {
        application = new Application();
    }
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null, /* activityConfigCallback */
    null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional comment added to mark a parameter as ""/* activityConfigCallback */"", but no actual code has changed, so the code change type is 4.","Since there are no changes to the actual code, only a comment was added, there is no Compatibility Issue; the API behavior remains the same."
433,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",28,29,"<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessage(NdefMessage,Activity,Activity)>",0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessage(activity, message, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessage(a, message, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessage(activity, message, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessage(a, message, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a static {@link NdefMessage} to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message is only made available for NDEF push when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessage(ndefMessage, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the NDEF message and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically generate an NDEF message,
 * then set a callback using {@link #setNdefPushMessageCallback} instead
 * of a static message.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Set a static {@link NdefMessage} to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message is only made available for NDEF push when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessage(ndefMessage, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the NDEF message and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically generate an NDEF message,
 * then set a callback using {@link #setNdefPushMessageCallback} instead
 * of a static message.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param message NDEF message to push over NFC, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated this feature is deprecated. File sharing can work using other technology like
 * Bluetooth.
 */
",-1,,[@java.lang.Deprecated],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","There's an added check for sHasBeamFeature with an associated return statement, an added control structure, and a change in the exception handling logic within the same control structure. Therefore, the change types are 2 (exception handling statement changed), 3 (control dependency changed), and 4 (other statement changed).","The addition of a control dependency for sHasBeamFeature that leads to an early return introduces a new code path which causes a CI of type 1 (potential different return values). Also, the re-thrown IllegalStateException only for new applications introduces a CI of type 2 (potential different exception handlings)."
434,"<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>",28,29,"<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>","<android.view.inputmethod.InputMethodManager: void showSoftInputFromInputMethod(IBinder,int)>",0,"{
    showSoftInputFromInputMethodInternal(token, flags);
}","{
    InputMethodPrivilegedOperationsRegistry.get(token).showMySoftInput(flags);
}",1,"/**
 * Show the input method's soft input area, so the user
 * sees the input method window and can interact with it.
 * This can only be called from the currently active input method,
 * as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} or
 * {@link #SHOW_FORCED} bit set.
 * @deprecated Use {@link InputMethodService#requestShowSelf(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
","/**
 * Show the input method's soft input area, so the user
 * sees the input method window and can interact with it.
 * This can only be called from the currently active input method,
 * as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} or
 * {@link #SHOW_FORCED} bit set.
 * @deprecated Use {@link InputMethodService#requestShowSelf(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,1,"The implementation of the method has changed from calling showSoftInputFromInputMethodInternal(token, flags) in the early version to InputMethodPrivilegedOperationsRegistry.get(token).showMySoftInput(flags) in the late version. This indicates that there is a change in the dependent API being used, thus the code change type is 5.","The change in the dependent API being invoked to initiate the soft input could potentially lead to different behaviors in the late version. Consequently, this constitutes a Compatibility Issue of type 1, caused by the potential for different return values or states. Even though the method's signature indicates a 'void' return type, the operational effect of the method could result in different outcomes due to the different internal API calls."
435,<android.view.DisplayCutout: int hashCode()>,28,29,<android.view.DisplayCutout: int hashCode()>,<android.view.DisplayCutout: int hashCode()>,0,"{
    int result = mSafeInsets.hashCode();
    result = result * 31 + mBounds.getBounds().hashCode();
    return result;
}","{
    return mSafeInsets.hashCode() * 48271 + mBounds.hashCode();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The algorithm to calculate the hashCode has been changed, therefore we have an Other statement changed type, which is 4.","Since the hashCode calculation method has been altered, this modification will likely result in the late version of the API returning a different integer compared to the earlier version for the same object. Thus, there is a Compatibility Issue caused by potential different return values, which is type 1."
436,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,28,29,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void removePrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        mPrimaryClipChangedListeners.remove(what);
        if (mPrimaryClipChangedListeners.isEmpty()) {
            try {
                mService.removePrimaryClipChangedListener(mPrimaryClipChangedServiceListener);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        mPrimaryClipChangedListeners.remove(what);
        if (mPrimaryClipChangedListeners.isEmpty()) {
            try {
                mService.removePrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName(), mContext.getUserId());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API mService.removePrimaryClipChangedListener(...) has added two new parameters, mContext.getOpPackageName() and mContext.getUserId(), so the code change type is 5.","The modification in the dependent API does not change the control flow nor alter the exception handling or return value of the removePrimaryClipChangedListener method itself. Hence, there is no Compatibility Issue caused by potential different return values or types, or by potential different exception handlings, so the CI type is 0."
437,<android.app.NotificationChannel: String toString()>,28,29,<android.app.NotificationChannel: String toString()>,<android.app.NotificationChannel: String toString()>,0,"{
    return ""NotificationChannel{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDesc) ? ""hasDescription "" : """") + "", mImportance="" + mImportance + "", mBypassDnd="" + mBypassDnd + "", mLockscreenVisibility="" + mLockscreenVisibility + "", mSound="" + mSound + "", mLights="" + mLights + "", mLightColor="" + mLightColor + "", mVibration="" + Arrays.toString(mVibration) + "", mUserLockedFields="" + Integer.toHexString(mUserLockedFields) + "", mFgServiceShown="" + mFgServiceShown + "", mVibrationEnabled="" + mVibrationEnabled + "", mShowBadge="" + mShowBadge + "", mDeleted="" + mDeleted + "", mGroup='"" + mGroup + '\'' + "", mAudioAttributes="" + mAudioAttributes + "", mBlockableSystem="" + mBlockableSystem + '}';
}","{
    return ""NotificationChannel{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDesc) ? ""hasDescription "" : """") + "", mImportance="" + mImportance + "", mBypassDnd="" + mBypassDnd + "", mLockscreenVisibility="" + mLockscreenVisibility + "", mSound="" + mSound + "", mLights="" + mLights + "", mLightColor="" + mLightColor + "", mVibration="" + Arrays.toString(mVibration) + "", mUserLockedFields="" + Integer.toHexString(mUserLockedFields) + "", mFgServiceShown="" + mFgServiceShown + "", mVibrationEnabled="" + mVibrationEnabled + "", mShowBadge="" + mShowBadge + "", mDeleted="" + mDeleted + "", mGroup='"" + mGroup + '\'' + "", mAudioAttributes="" + mAudioAttributes + "", mBlockableSystem="" + mBlockableSystem + "", mAllowBubbles="" + mAllowBubbles + "", mImportanceLockedByOEM="" + mImportanceLockedByOEM + "", mImportanceLockedDefaultApp="" + mImportanceLockedDefaultApp + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There are new fields appended to the toString() representation in the late implementation: mAllowBubbles, mImportanceLockedByOEM, and mImportanceLockedDefaultApp. The change type is 4 as it affects a non-control, non-exception handling, and non-return statement part of the code.","The addition of new fields in the toString() output may lead existing clients that parse or rely on the format of the output to function incorrectly if they are not expecting these new fields. Thus, the change could potentially return a different value, which means the CI type is 1."
438,"<android.os.FileBridge.FileBridgeOutputStream: void write(byte[],int,int)>",28,29,"<android.os.FileBridge.FileBridgeOutputStream: void write(byte[],int,int)>","<android.os.FileBridge.FileBridgeOutputStream: void write(byte[],int,int)>",0,"{
    Arrays.checkOffsetAndCount(buffer.length, byteOffset, byteCount);
    Memory.pokeInt(mTemp, 0, CMD_WRITE, ByteOrder.BIG_ENDIAN);
    Memory.pokeInt(mTemp, 4, byteCount, ByteOrder.BIG_ENDIAN);
    IoBridge.write(mClient, mTemp, 0, MSG_LENGTH);
    IoBridge.write(mClient, buffer, byteOffset, byteCount);
}","{
    ArrayUtils.throwsIfOutOfBounds(buffer.length, byteOffset, byteCount);
    Memory.pokeInt(mTemp, 0, CMD_WRITE, ByteOrder.BIG_ENDIAN);
    Memory.pokeInt(mTemp, 4, byteCount, ByteOrder.BIG_ENDIAN);
    IoBridge.write(mClient, mTemp, 0, MSG_LENGTH);
    IoBridge.write(mClient, buffer, byteOffset, byteCount);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method called to check the validity of the offset and count parameters has changed from Arrays.checkOffsetAndCount to ArrayUtils.throwsIfOutOfBounds, which is a different internal implementation for parameter checking. This potentially relates to a Dependent API changed (5). Additionally, this is not a return statement, exception handling, or control dependency change, thus falls into Other statement changed (4).","There is no Compatibility Issue in this case, since the semantic and the behavior of the API appear to be preserved despite the internal change of the method used for bounds checking. The purpose of both methods is to ensure the passed parameters are within the required bounds, and therefore, this does not affect the external behavior of the API."
439,<android.app.Notification.Style: RemoteViews getStandardView(int)>,28,29,<android.app.Notification.Style: RemoteViews getStandardView(int)>,<android.app.Notification.Style: RemoteViews getStandardView(int)>,0,"{
    return getStandardView(layoutId, null);
}","{
    StandardTemplateParams p = mBuilder.mParams.reset().fillTextsFrom(mBuilder);
    return getStandardView(layoutId, p, null);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method now includes new steps to create a `StandardTemplateParams` object and passes it to `getStandardView()`, compared to the early version where `null` was passed directly. Additionally, the method signature for `getStandardView()` that is being called has changed as it now takes an additional `StandardTemplateParams` parameter. So, the change is of type 1, 4, and 5.","The change in the parameters being passed to the `getStandardView()` method and the introduction of `StandardTemplateParams` object could lead to different return values, making it a compatibility issue of type 1."
440,<android.hardware.usb.UsbAccessory: boolean equals(Object)>,28,29,<android.hardware.usb.UsbAccessory: boolean equals(Object)>,<android.hardware.usb.UsbAccessory: boolean equals(Object)>,0,"{
    if (obj instanceof UsbAccessory) {
        UsbAccessory accessory = (UsbAccessory) obj;
        return (compare(mManufacturer, accessory.getManufacturer()) && compare(mModel, accessory.getModel()) && compare(mDescription, accessory.getDescription()) && compare(mVersion, accessory.getVersion()) && compare(mUri, accessory.getUri()) && compare(mSerial, accessory.getSerial()));
    }
    return false;
}","{
    if (obj instanceof UsbAccessory) {
        UsbAccessory accessory = (UsbAccessory) obj;
        return (compare(mManufacturer, accessory.getManufacturer()) && compare(mModel, accessory.getModel()) && compare(mDescription, accessory.getDescription()) && compare(mVersion, accessory.getVersion()) && compare(mUri, accessory.getUri()) && compare(getSerial(), accessory.getSerial()));
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The code change consists of using the getSerial() method in the late version instead of directly accessing the mSerial variable; this denotes a change in the dependent API, therefore, the change type is 5.","There is no Compatibility Issue, as both versions of the method ultimately perform the same operation in comparing the serial value, with the only difference being the accessor method used. The behavior of the equals method remains functionally unaltered, hence there is no potential for different return values or exception handlings. Therefore, the CI type is 0."
442,"<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>",28,29,"<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // If the view isn't an AdapterView, setting a PendingIntent template doesn't make sense
    if (target instanceof AdapterView<?>) {
        AdapterView<?> av = (AdapterView<?>) target;
        // The PendingIntent template is stored in the view's tag.
        OnItemClickListener listener = new OnItemClickListener() {

            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The view should be a frame layout
                if (view instanceof ViewGroup) {
                    ViewGroup vg = (ViewGroup) view;
                    // so we need to go one layer deeper here.
                    if (parent instanceof AdapterViewAnimator) {
                        vg = (ViewGroup) vg.getChildAt(0);
                    }
                    if (vg == null)
                        return;
                    Intent fillInIntent = null;
                    int childCount = vg.getChildCount();
                    for (int i = 0; i < childCount; i++) {
                        Object tag = vg.getChildAt(i).getTag(com.android.internal.R.id.fillInIntent);
                        if (tag instanceof Intent) {
                            fillInIntent = (Intent) tag;
                            break;
                        }
                    }
                    if (fillInIntent == null)
                        return;
                    final Rect rect = getSourceBounds(view);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(view, pendingIntentTemplate, fillInIntent);
                }
            }
        };
        av.setOnItemClickListener(listener);
        av.setTag(pendingIntentTemplate);
    } else {
        Log.e(LOG_TAG, ""Cannot setPendingIntentTemplate on a view which is not"" + ""an AdapterView (id: "" + viewId + "")"");
        return;
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // If the view isn't an AdapterView, setting a PendingIntent template doesn't make sense
    if (target instanceof AdapterView<?>) {
        AdapterView<?> av = (AdapterView<?>) target;
        // The PendingIntent template is stored in the view's tag.
        OnItemClickListener listener = new OnItemClickListener() {

            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The view should be a frame layout
                if (view instanceof ViewGroup) {
                    ViewGroup vg = (ViewGroup) view;
                    // so we need to go one layer deeper here.
                    if (parent instanceof AdapterViewAnimator) {
                        vg = (ViewGroup) vg.getChildAt(0);
                    }
                    if (vg == null)
                        return;
                    RemoteResponse response = null;
                    int childCount = vg.getChildCount();
                    for (int i = 0; i < childCount; i++) {
                        Object tag = vg.getChildAt(i).getTag(com.android.internal.R.id.fillInIntent);
                        if (tag instanceof RemoteResponse) {
                            response = (RemoteResponse) tag;
                            break;
                        }
                    }
                    if (response == null)
                        return;
                    response.handleViewClick(view, handler);
                }
            }
        };
        av.setOnItemClickListener(listener);
        av.setTag(pendingIntentTemplate);
    } else {
        Log.e(LOG_TAG, ""Cannot setPendingIntentTemplate on a view which is not"" + ""an AdapterView (id: "" + viewId + "")"");
        return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"Within the OnItemClick method, the type of object stored in the tag has changed from Intent to RemoteResponse and the way it is utilized has also changedpreviously it was creating a new Intent and calling onClickHandler, but now it directly calls handleViewClick on the new RemoteResponse object. The control dependency has not changed, but the implementation and related objects have, so the change types are 1 (return statement changed), 3 (Control dependency change), and 4 (Other statement changed).","Due to the changes in handling the click response, the behavior of this API method could potentially differ, particularly how the PendingIntent is handled and what actions are performed when an item is clicked. Therefore, there could be a compatibility issue due to potentially different return values or types, hence the CI type 1. There's no indication that exceptions are handled differently, so CI type 2 is not applicable."
444,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,28,29,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader);
    final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, overrideConfiguration, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    return context;
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, mFlags, mClassLoader, null);
    final int displayId = getDisplayId();
    context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId, overrideConfiguration, getDisplayAdjustments(displayId).getCompatibilityInfo()));
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,The changes include adding an additional parameter 'null' to the constructor of ContextImpl and replacing the logic for retrieving the displayId with the getDisplayId() method. This is considered an Other statement changed (4) and a Dependent API changed (5).,"No Compatibility Issue arises because of these changes; the method still behaves the same way from the caller's perspective, there is no change in its control dependencies, return statements, or exception handling that would affect its behavior."
445,<android.app.Activity: boolean releaseInstance()>,28,29,<android.app.Activity: boolean releaseInstance()>,<android.app.Activity: boolean releaseInstance()>,0,"{
    try {
        return ActivityManager.getService().releaseActivityInstance(mToken);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}","{
    try {
        return ActivityTaskManager.getService().releaseActivityInstance(mToken);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}",1,"/**
 * Ask that the local app instance of this activity be released to free up its memory.
 * This is asking for the activity to be destroyed, but does <b>not</b> finish the activity --
 * a new instance of the activity will later be re-created if needed due to the user
 * navigating back to it.
 *
 * @return Returns true if the activity was in a state that it has started the process
 * of destroying its current instance; returns false if for any reason this could not
 * be done: it is currently visible to the user, it is already being destroyed, it is
 * being finished, it hasn't yet saved its state, etc.
 */
","/**
 * Ask that the local app instance of this activity be released to free up its memory.
 * This is asking for the activity to be destroyed, but does <b>not</b> finish the activity --
 * a new instance of the activity will later be re-created if needed due to the user
 * navigating back to it.
 *
 * @return Returns true if the activity was in a state that it has started the process
 * of destroying its current instance; returns false if for any reason this could not
 * be done: it is currently visible to the user, it is already being destroyed, it is
 * being finished, it hasn't yet saved its state, etc.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API used within the try block has changed from ActivityManager.getService().releaseActivityInstance(mToken) to ActivityTaskManager.getService().releaseActivityInstance(mToken), so the code change is of type 5, which signifies a dependent API change.","Despite the update to the dependent API, there is no indication that the behavior of the API has changed since the same method name and arguments are used, and the exception handling has not changed. Therefore, there is no compatibility issue; thus, CI type is 0."
447,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,28,29,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mLayout.packageName = getPackageName();
    mDisplayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
    mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);
    mDisplayState = mDisplay.getState();
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mLayout.packageName = getPackageName();
    mIWallpaperEngine.mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mIWallpaperEngine.mDisplay;
    mDisplayContext = createDisplayContext(mDisplay);
    mDisplayState = mDisplay.getState();
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,The code change includes:,- Addition of new variable mDisplayContext with the assignment createDisplayContext(mDisplay).
448,"<android.provider.MediaStore.Files: Uri getContentUri(String,long)>",28,29,"<android.provider.MediaStore.Files: Uri getContentUri(String,long)>","<android.provider.MediaStore.Files: Uri getContentUri(String,long)>",0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/file/"" + rowId);
}","{
    return ContentUris.withAppendedId(getContentUri(volumeName), rowId);
}",1,"/**
 * Get the content:// style URI for a single row in the files table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @param rowId the file to get the URI for
 * @return the URI to the files table on the given volume
 */
","/**
 * Get the content:// style URI for a single row in the files table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @param rowId the file to get the URI for
 * @return the URI to the files table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of returning a Uri has changed from using Uri.parse() method to using ContentUris.withAppendedId() method along with getContentUri(volumeName). There is a change in the method used to append an ID to a Uri, and it involves a dependency on another API method getContentUri(String), therefore, the code change types are 1,5.","Since the way of constructing the Uri object changed between versions, this could potentially lead to different return values even though they are expected to represent the same Uri. Therefore, there is a possible Compatibility Issue due to a potential different return value, and the CI type is 1."
449,<android.app.Activity: int getTaskId()>,28,29,<android.app.Activity: int getTaskId()>,<android.app.Activity: int getTaskId()>,0,"{
    try {
        return ActivityManager.getService().getTaskForActivity(mToken, false);
    } catch (RemoteException e) {
        return -1;
    }
}","{
    try {
        return ActivityTaskManager.getService().getTaskForActivity(mToken, false);
    } catch (RemoteException e) {
        return -1;
    }
}",1,"/**
 * Return the identifier of the task this activity is in.  This identifier
 * will remain the same for the lifetime of the activity.
 *
 * @return Task identifier, an opaque integer.
 */
","/**
 * Return the identifier of the task this activity is in.  This identifier
 * will remain the same for the lifetime of the activity.
 *
 * @return Task identifier, an opaque integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change consists of a call to a different service, from ActivityManager.getService() to ActivityTaskManager.getService(), without altering the method being called or its parameters. Therefore, the code change type is 5 (Dependent API changed).","There are no direct changes in the return statements or exception handling that would lead to a Compatibility Issue. The dependent API getService() may have different implementations, but assuming they are functionally equivalent and intended to preserve behavior across versions, there is no indication of a Compatibility Issue. Thus, the CI type is 0 (No Compatibility Issue)."
451,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",28,29,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>","<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.showSoftInput(view, flags, resultReceiver);
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
","/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"A new mechanism (the fallback InputMethodManager) has been introduced before the original logic, and the dependent API getFallbackInputMethodManagerIfNecessary(view) is a new call which may alter behavior. The code change includes control dependency change, other statement change, and dependent API changed, which are types 3, 4, and 5 respectively.","Although there is a significant change in the logic, the final result of the method is not altered in a way that would constitute a compatibility issue, since if the fallback IMM is not necessary, the original logic is executed exactly as before. Therefore, the compatibility issue type is 0, meaning there is no compatibility issue."
452,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",28,29,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>","<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",0,"{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
        Log.i(TAG, prefix + ""  Resource id: "" + node.getTextIdEntry());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized() + "", importantFor="" + node.getImportantForAutofill());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}","{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
        Log.i(TAG, prefix + ""  Resource id: "" + node.getTextIdEntry());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""  Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized() + "", important="" + node.getImportantForAutofill());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
453,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,28,29,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,<android.widget.Editor.HandleView: boolean onTouchEvent(MotionEvent)>,0,"{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY, ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp(ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable();
            break;
    }
    return true;
}","{
    updateFloatingToolbarVisibility(ev);
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mLastParentXOnScreen = positionListener.getPositionXOnScreen();
                mLastParentYOnScreen = positionListener.getPositionYOnScreen();
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                mTouchToWindowOffsetX = xInWindow - mPositionX;
                mTouchToWindowOffsetY = yInWindow - mPositionY;
                mIsDragging = true;
                mPreviousLineTouched = UNSET_LINE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float xInWindow = ev.getRawX() - mLastParentXOnScreen + mLastParentX;
                final float yInWindow = ev.getRawY() - mLastParentYOnScreen + mLastParentY;
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = yInWindow - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = xInWindow - mTouchToWindowOffsetX + mHotspotX + getHorizontalOffset();
                final float newPosY = yInWindow - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY, ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp(ev.isFromSource(InputDevice.SOURCE_TOUCHSCREEN));
        // Fall through.
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            updateDrawable(false);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
454,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",28,29,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        unstableProvider = null;
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    try {
        if (mWrapped != null)
            return mWrapped.openTypedAssetFile(uri, mimeType, opts, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        unstableProvider = null;
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
455,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>",28,29,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>","<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>",0,"{
    if (handlePreAuthenticationErrors(callback, executor)) {
        return;
    }
    mFingerprintManager.authenticate(crypto, cancel, mBundle, executor, mDialogReceiver, callback);
}","{
    if (crypto == null) {
        throw new IllegalArgumentException(""Must supply a crypto object"");
    }
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    if (mBundle.getBoolean(KEY_ALLOW_DEVICE_CREDENTIAL)) {
        throw new IllegalArgumentException(""Device credential not supported with crypto"");
    }
    authenticateInternal(crypto, cancel, executor, callback, mContext.getUserId(), null);
}",1,"/**
 * This call warms up the fingerprint hardware, displays a system-provided dialog, and starts
 * scanning for a fingerprint. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)}, or when the user
 * dismisses the system-provided dialog, at which point the crypto object becomes invalid. This
 * operation can be canceled by using the provided cancel object. The application will receive
 * authentication errors through {@link AuthenticationCallback}, and button events through the
 * corresponding callback set in {@link Builder#setNegativeButton(CharSequence, Executor,
 * DialogInterface.OnClickListener)}. It is safe to reuse the {@link BiometricPrompt} object,
 * and calling {@link BiometricPrompt#authenticate( CancellationSignal, Executor,
 * AuthenticationCallback)} while an existing authentication attempt is occurring will stop the
 * previous client and start a new authentication. The interrupted client will receive a
 * cancelled notification through {@link AuthenticationCallback#onAuthenticationError(int,
 * CharSequence)}.
 *
 * @throws IllegalArgumentException If any of the arguments are null
 *
 * @param crypto Object associated with the call
 * @param cancel An object that can be used to cancel authentication
 * @param executor An executor to handle callback events
 * @param callback An object to receive authentication events
 */
","/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)}, or when the user
 * dismisses the system-provided dialog, at which point the crypto object becomes invalid. This
 * operation can be canceled by using the provided cancel object. The application will receive
 * authentication errors through {@link AuthenticationCallback}, and button events through the
 * corresponding callback set in {@link Builder#setNegativeButton(CharSequence, Executor,
 * DialogInterface.OnClickListener)}. It is safe to reuse the {@link BiometricPrompt} object,
 * and calling {@link BiometricPrompt#authenticate( CancellationSignal, Executor,
 * AuthenticationCallback)} while an existing authentication attempt is occurring will stop the
 * previous client and start a new authentication. The interrupted client will receive a
 * cancelled notification through {@link AuthenticationCallback#onAuthenticationError(int,
 * CharSequence)}.
 *
 * Note: Applications generally should not cancel and start authentication in quick succession.
 * For example, to properly handle authentication across configuration changes, it's recommended
 * to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so, the
 * application will not need to cancel/restart authentication during the configuration change.
 *
 * @throws IllegalArgumentException If any of the arguments are null
 *
 * @param crypto Object associated with the call
 * @param cancel An object that can be used to cancel authentication
 * @param executor An executor to handle callback events
 * @param callback An object to receive authentication events
 */
",-1,[@RequiresPermission(USE_BIOMETRIC)],[@RequiresPermission(USE_BIOMETRIC)],-1,-1,-1,-1,-1,-1,"2,3,4,5",2,"The late version introduces several new exception handling statements (throw new IllegalArgumentException(...)) and deletes the early version's call to handlePreAuthenticationErrors(), changing the set of exceptions that are thrown. It also replaces the mFingerprintManager.authenticate(...) with authenticateInternal(..., null), which is a change in the body of the method (other statement changed) and a change in the dependent APIs being called. Additionally, the control flow of the method has been altered with new conditional checks, representing a change in control dependency. The code change types are 2,3,4,5.","Because of the new checks that throw exceptions and the removal of the previous error handling code, the late version of the method can throw different exceptions compared to the previous version. For example, if the arguments are not provided correctly, the previous version would handle errors using handlePreAuthenticationErrors method, while the new version throws IllegalArgumentException directly. This could lead to a Compatibility Issue due to potential different exception handlings (CI type 2)."
456,<android.view.WindowInsets: int hashCode()>,28,29,<android.view.WindowInsets: int hashCode()>,<android.view.WindowInsets: int hashCode()>,0,"{
    return Objects.hash(mSystemWindowInsets, mWindowDecorInsets, mStableInsets, mIsRound, mDisplayCutout, mAlwaysConsumeNavBar, mSystemWindowInsetsConsumed, mWindowDecorInsetsConsumed, mStableInsetsConsumed, mDisplayCutoutConsumed);
}","{
    return Objects.hash(Arrays.hashCode(mTypeInsetsMap), Arrays.hashCode(mTypeMaxInsetsMap), Arrays.hashCode(mTypeVisibilityMap), mIsRound, mDisplayCutout, mAlwaysConsumeSystemBars, mSystemWindowInsetsConsumed, mStableInsetsConsumed, mDisplayCutoutConsumed);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The arguments of the `Objects.hash` call have changed, removing some elements and adding others (changed from individual insets members to arrays of type inset maps), so the code change type is 1.","Because the hashCode computation relies on different inputs, the hash code returned by the late version could potentially differ from the early version, so the CI type is 1."
457,<android.bluetooth.BluetoothHeadset: void close()>,28,29,<android.bluetooth.BluetoothHeadset: void close()>,<android.bluetooth.BluetoothHeadset: void close()>,0,"{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    mServiceListener = null;
    doUnbind();
}","{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (RemoteException re) {
            Log.e(TAG, """", re);
        }
    }
    mServiceListener = null;
    doUnbind();
}",1,"/*package*/
","/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothHeadset will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 */
",-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"The only change is the rename of the exception variable from 'e' to 're', which does not affect the behavior of the method. Additionally, an annotation `@UnsupportedAppUsage` has been added in the late version, but this annotation does not change the method's behavior either. Thus, the change type is 4.","Since the change is a simple rename of a local exception variable and does not affect the control flow or the method's contract, it will not cause any external behavior changes when this API is invoked. Therefore, there is no Compatibility Issue, hence the CI type is 0."
458,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,28,29,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,0,"{
    hasProgress = true;
    ambient = false;
    title = null;
    text = null;
    headerTextSecondary = null;
    maxRemoteInputHistory = Style.MAX_REMOTE_INPUT_HISTORY_LINES;
    return this;
}","{
    hasProgress = true;
    title = null;
    text = null;
    summaryText = null;
    headerTextSecondary = null;
    maxRemoteInputHistory = Style.MAX_REMOTE_INPUT_HISTORY_LINES;
    allowColorization = true;
    forceDefaultColor = false;
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statements to 'ambient', 'summaryText', 'allowColorization', and 'forceDefaultColor' have changed. New fields 'allowColorization' and 'forceDefaultColor' have been added, and there is no change to the return type or value. As such, the code change type is 4.","There is no Compatibility Issue, because although there are added and deleted assignment statements, none of these changes alter the return value or type, nor do they affect exception handling. The method still returns 'this', the current instance of StandardTemplateParams, so the API will behave consistently in terms of method signature and returned value type. Therefore, the CI type is 0."
460,<android.accessibilityservice.AccessibilityService.MagnificationController: boolean reset(boolean)>,28,29,<android.accessibilityservice.AccessibilityService.MagnificationController: boolean reset(boolean)>,<android.accessibilityservice.AccessibilityService.MagnificationController: boolean reset(boolean)>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.resetMagnification(animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to reset"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.resetMagnification(mDisplayId, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to reset"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Resets magnification scale and center to their default (e.g. no
 * magnification) values.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param animate {@code true} to animate from the current scale and
 * center or {@code false} to reset the scale and center
 * immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Resets magnification scale and center to their default (e.g. no
 * magnification) values.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param animate {@code true} to animate from the current scale and
 * center or {@code false} to reset the scale and center
 * immediately
 * @return {@code true} on success, {@code false} on failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There has been a change in the arguments passed to the method connection.resetMagnification(). In the early version, it takes 'animate' as a parameter, while in the late version, an additional parameter 'mDisplayId' is passed along with 'animate'. This indicates that the dependent API connection.resetMagnification() has changed. Therefore, the code change type is 5.","There is no Compatibility Issue here because the implementation has been updated correctly to reflect the change in the dependent API without altering the overall behavior of the method. It still returns the same boolean value, and the surrounding try-catch block has not changed, meaning the API will behave consistently across versions regarding both return values and exceptions. Thus, CI type is 0."
461,<android.view.TouchDelegate: boolean onTouchEvent(MotionEvent)>,28,29,<android.view.TouchDelegate: boolean onTouchEvent(MotionEvent)>,<android.view.TouchDelegate: boolean onTouchEvent(MotionEvent)>,0,"{
    int x = (int) event.getX();
    int y = (int) event.getY();
    boolean sendToDelegate = false;
    boolean hit = true;
    boolean handled = false;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDelegateTargeted = mBounds.contains(x, y);
            sendToDelegate = mDelegateTargeted;
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
        case MotionEvent.ACTION_POINTER_UP:
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_MOVE:
            sendToDelegate = mDelegateTargeted;
            if (sendToDelegate) {
                Rect slopBounds = mSlopBounds;
                if (!slopBounds.contains(x, y)) {
                    hit = false;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            sendToDelegate = mDelegateTargeted;
            mDelegateTargeted = false;
            break;
    }
    if (sendToDelegate) {
        final View delegateView = mDelegateView;
        if (hit) {
            // Offset event coordinates to be inside the target view
            event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
        } else {
            // Offset event coordinates to be outside the target view (in case it does
            // something like tracking pressed state)
            int slop = mSlop;
            event.setLocation(-(slop * 2), -(slop * 2));
        }
        handled = delegateView.dispatchTouchEvent(event);
    }
    return handled;
}","{
    int x = (int) event.getX();
    int y = (int) event.getY();
    boolean sendToDelegate = false;
    boolean hit = true;
    boolean handled = false;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDelegateTargeted = mBounds.contains(x, y);
            sendToDelegate = mDelegateTargeted;
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
        case MotionEvent.ACTION_POINTER_UP:
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_MOVE:
            sendToDelegate = mDelegateTargeted;
            if (sendToDelegate) {
                Rect slopBounds = mSlopBounds;
                if (!slopBounds.contains(x, y)) {
                    hit = false;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            sendToDelegate = mDelegateTargeted;
            mDelegateTargeted = false;
            break;
    }
    if (sendToDelegate) {
        if (hit) {
            // Offset event coordinates to be inside the target view
            event.setLocation(mDelegateView.getWidth() / 2, mDelegateView.getHeight() / 2);
        } else {
            // Offset event coordinates to be outside the target view (in case it does
            // something like tracking pressed state)
            int slop = mSlop;
            event.setLocation(-(slop * 2), -(slop * 2));
        }
        handled = mDelegateView.dispatchTouchEvent(event);
    }
    return handled;
}",1,"/**
 * Will forward touch events to the delegate view if the event is within the bounds
 * specified in the constructor.
 *
 * @param event The touch event to forward
 * @return True if the event was forwarded to the delegate, false otherwise.
 */
","/**
 * Forward touch events to the delegate view if the event is within the bounds
 * specified in the constructor.
 *
 * @param event The touch event to forward
 * @return True if the event was consumed by the delegate, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change made in the code is the elimination of the local variable declaration `final View delegateView = mDelegateView;` which is not used afterwards and instead, `mDelegateView` is used directly in the late version. This change falls under the category of Other statement changed as it doesn't involve a control, return, exception handling or dependent API change.","This change does not affect the behavior of the method, it does not lead to a different return value, and it does not introduce any new exception handling nor control flow changes. Therefore, there is no Compatibility Issue."
462,"<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>",28,29,"<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>","<android.app.ActivityManager: int addAppTask(Activity,Intent,TaskDescription,Bitmap)>",0,"{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return getService().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return getTaskService().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Add a new {@link AppTask} for the calling application.  This will create a new
 * recents entry that is added to the <b>end</b> of all existing recents.
 *
 * @param activity The activity that is adding the entry.   This is used to help determine
 * the context that the new recents entry will be in.
 * @param intent The Intent that describes the recents entry.  This is the same Intent that
 * you would have used to launch the activity for it.  In generally you will want to set
 * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and
 * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents
 * entry will exist without an activity, so it doesn't make sense to not retain it when
 * its activity disappears.  The given Intent here also must have an explicit ComponentName
 * set on it.
 * @param description Optional additional description information.
 * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
 * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be
 * recreated in your process, probably in a way you don't like, before the recents entry
 * is added.
 *
 * @return Returns the task id of the newly added app task, or -1 if the add failed.  The
 * most likely cause of failure is that there is no more room for more tasks for your app.
 */
","/**
 * Add a new {@link AppTask} for the calling application.  This will create a new
 * recents entry that is added to the <b>end</b> of all existing recents.
 *
 * @param activity The activity that is adding the entry.   This is used to help determine
 * the context that the new recents entry will be in.
 * @param intent The Intent that describes the recents entry.  This is the same Intent that
 * you would have used to launch the activity for it.  In generally you will want to set
 * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and
 * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents
 * entry will exist without an activity, so it doesn't make sense to not retain it when
 * its activity disappears.  The given Intent here also must have an explicit ComponentName
 * set on it.
 * @param description Optional additional description information.
 * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
 * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be
 * recreated in your process, probably in a way you don't like, before the recents entry
 * is added.
 *
 * @return Returns the task id of the newly added app task, or -1 if the add failed.  The
 * most likely cause of failure is that there is no more room for more tasks for your app.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `getService()` is changed to `getTaskService()` which indicates that a dependent API has changed, thus the code change type is 5.","The change is within an internal call to another method, and there's no change to the signature or expected behavior of the API itself from a caller perspective (assuming `getTaskService()` is intended to replace `getService()` and has the same expected behavior for this scenario). Therefore, there is no Compatibility Issue, and the CI type is 0."
463,<android.view.textclassifier.SystemTextClassifier.ResponseReceiver: T get()>,28,29,<android.view.textclassifier.SystemTextClassifier.ResponseReceiver: T get()>,<android.view.textclassifier.SystemTextClassifier.ResponseReceiver: T get()>,0,"{
    // NOTE that TextClassifier calls should preferably always be called on a worker thread.
    if (Looper.myLooper() != Looper.getMainLooper()) {
        mLatch.await(2, TimeUnit.SECONDS);
    }
    return mResponse;
}","{
    // NOTE that TextClassifier calls should preferably always be called on a worker thread.
    if (Looper.myLooper() != Looper.getMainLooper()) {
        try {
            boolean success = mLatch.await(2, TimeUnit.SECONDS);
            if (!success) {
                Log.w(LOG_TAG, ""Timeout in ResponseReceiver.get(): "" + mName);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            Log.e(LOG_TAG, ""Interrupted during ResponseReceiver.get(): "" + mName, e);
        }
    }
    return mResponse;
}",1,,,-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"2,3",0,"The control dependency has changed with the addition of a try-catch block within the existing if statement for logging purposes. Exception handling statement changed because the InterruptedException is now being caught and handled by logging the error and re-interrupting the current thread. Hence, the code change type is 2,3.","Although new exception handling has been introduced, there is no change in the exception being thrown to the callers of the method, and the method's return type and value have not been modified. The method still returns `mResponse` which is of the same type. Therefore, these changes do not introduce compatibility issues that would affect the method's behavior from the API users' perspective. The return value or the type of exception that can propagate to the caller is the same; hence, there is no Compatibility Issue, indicated by 0."
464,"<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>",28,29,"<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>","<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>",0,"{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        try {
            mCurMethod.updateCursorAnchorInfo(cursorAnchorInfo);
            mCursorAnchorInfo = cursorAnchorInfo;
            // Clear immediate bit (if any).
            mRequestUpdateCursorAnchorInfoMonitorMode &= ~InputConnection.CURSOR_UPDATE_IMMEDIATE;
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        try {
            if (mActivityViewToScreenMatrix != null) {
                mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(cursorAnchorInfo, mActivityViewToScreenMatrix));
            } else {
                mCurMethod.updateCursorAnchorInfo(cursorAnchorInfo);
            }
            mCursorAnchorInfo = cursorAnchorInfo;
            // Clear immediate bit (if any).
            mRequestUpdateCursorAnchorInfoMonitorMode &= ~InputConnection.CURSOR_UPDATE_IMMEDIATE;
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,"/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
","/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The code introduced a new logic to check for a fallback input method manager and calls `updateCursorAnchorInfo` from it if necessary. The internal logic for calling `mCurMethod.updateCursorAnchorInfo(cursorAnchorInfo);` has been modified to take into account an additional parent matrix if it exists, and there is a new dependent API call `CursorAnchorInfo.createForAdditionalParentMatrix`. Therefore, the change types include a control dependency change (3), an other statement changed (4), and a dependent API changed (5).","A compatibility issue could arise here as the late version of the API introduces a new logic that could lead to a different method being called (`fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);`) and also changes the behavior of the existing method call to `mCurMethod.updateCursorAnchorInfo` by potentially transforming the `cursorAnchorInfo` using an additional matrix. This can lead to the API having a different effect on the state of the system due to the differing input passed to `updateCursorAnchorInfo`. Therefore, the CI type is 1."
465,<android.util.ArraySet: E removeAt(int)>,28,29,<android.util.ArraySet: E removeAt(int)>,<android.util.ArraySet: E removeAt(int)>,0,"{
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        clear();
    } else {
        if (shouldShrink()) {
            // Shrunk enough to reduce size of arrays.
            final int n = getNewShrunkenSize();
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + mSize + "" to "" + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}",1,"/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
","/**
 * Remove the key/value mapping at the given index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
466,<android.content.ClipboardManager: ClipData getPrimaryClip()>,28,29,<android.content.ClipboardManager: ClipData getPrimaryClip()>,<android.content.ClipboardManager: ClipData getPrimaryClip()>,0,"{
    try {
        return mService.getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getPrimaryClip(mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the current primary clip on the clipboard.
 *
 * @see #setPrimaryClip(ClipData)
 */
","/**
 * Returns the current primary clip on the clipboard.
 *
 * <em>If the application is not the default IME or does not have input focus this return
 * {@code null}.</em>
 *
 * @see #setPrimaryClip(ClipData)
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The call to mService.getPrimaryClip() now includes an additional parameter, mContext.getUserId(), so the code change type is 5.","Even though there is an additional parameter in the late version API, it does not lead to a different return value or exception thrown since the primary behavior and exception handling have not been altered. Therefore, there is no Compatibility Issue, and the CI type is 0."
467,"<android.provider.DocumentsContract: Path findDocumentPath(ContentResolver,Uri)>",28,29,"<android.provider.DocumentsContract: Path findDocumentPath(ContentResolver,Uri)>","<android.provider.DocumentsContract: Path findDocumentPath(ContentResolver,Uri)>",0,"{
    checkArgument(isTreeUri(treeUri), treeUri + "" is not a tree uri."");
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(treeUri.getAuthority());
    try {
        return findDocumentPath(client, treeUri);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to find path"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, treeUri);
        final Bundle out = content.call(treeUri.getAuthority(), METHOD_FIND_DOCUMENT_PATH, null, in);
        return out.getParcelable(DocumentsContract.EXTRA_RESULT);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to find path"", e);
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Finds the canonical path from the top of the document tree.
 *
 * The {@link Path#getPath()} of the return value contains the document ID
 * of all documents along the path from the top the document tree to the
 * requested document, both inclusive.
 *
 * The {@link Path#getRootId()} of the return value returns {@code null}.
 *
 * @param treeUri treeUri of the document which path is requested.
 * @return the path of the document, or {@code null} if failed.
 * @see DocumentsProvider#findDocumentPath(String, String)
 */
","/**
 * Finds the canonical path from the top of the document tree.
 *
 * The {@link Path#getPath()} of the return value contains the document ID
 * of all documents along the path from the top the document tree to the
 * requested document, both inclusive.
 *
 * The {@link Path#getRootId()} of the return value returns {@code null}.
 *
 * @param treeUri treeUri of the document which path is requested.
 * @return the path of the document, or {@code null} if failed.
 * @see DocumentsProvider#findDocumentPath(String, String)
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The entire implementation of the method has been rewritten. This involves changes to the control flow of the method, with different try-catch structures, the removal of an existing catch block and introduction of a new way of handling exceptions, the use of different APIs/methods such as acquiring a ContentProviderClient and the call to the content resolver, and different ways of dealing with method parameters and return values. In addition, the method's return type feature being changed to include the @Nullable annotation So, the change type is 1,2,3,4,5.","Since there have been significant changes to the implementation, it can be said with certainty that the API could return different values and handle exceptions differently. In particular:"
468,<android.database.AbstractCursor: boolean requery()>,28,29,<android.database.AbstractCursor: boolean requery()>,<android.database.AbstractCursor: boolean requery()>,0,"{
    if (mSelfObserver != null && mSelfObserverRegistered == false) {
        mContentResolver.registerContentObserver(mNotifyUri, true, mSelfObserver);
        mSelfObserverRegistered = true;
    }
    mDataSetObservable.notifyChanged();
    return true;
}","{
    if (mSelfObserver != null && mSelfObserverRegistered == false) {
        final int size = mNotifyUris.size();
        for (int i = 0; i < size; ++i) {
            final Uri notifyUri = mNotifyUris.get(i);
            mContentResolver.registerContentObserver(notifyUri, true, mSelfObserver);
        }
        mSelfObserverRegistered = true;
    }
    mDataSetObservable.notifyChanged();
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes a change in a control dependency (introduction of a for-loop that operates over mNotifyUris), and other statements (invocation of mNotifyUris.get(i) within the loop), which are categorized under 3 and 4.","There is no Compatibility Issue detected because the return value remains unchanged (always true), and there are no changes in exception handling. Additionally, the changes in control structures and other statements do not affect the external behavior of the API in a way that would lead to different results when the method is called, fitting the criteria for 0 (No Compatibility Issue)."
470,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setCenter(float,float,boolean)>",28,29,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setCenter(float,float,boolean)>","<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setCenter(float,float,boolean)>",0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(Float.NaN, centerX, centerY, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set center"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, Float.NaN, centerX, centerY, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set center"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Sets the center of the magnified viewport.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param centerX the unscaled screen-relative X coordinate on which to
 * center the viewport
 * @param centerY the unscaled screen-relative Y coordinate on which to
 * center the viewport
 * @param animate {@code true} to animate from the current viewport
 * center or {@code false} to set the center immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Sets the center of the magnified viewport.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param centerX the unscaled screen-relative X coordinate on which to
 * center the viewport
 * @param centerY the unscaled screen-relative Y coordinate on which to
 * center the viewport
 * @param animate {@code true} to animate from the current viewport
 * center or {@code false} to set the center immediately
 * @return {@code true} on success, {@code false} on failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method invocation within the try block changed by adding an additional parameter (mDisplayId) to the call to connection.setMagnificationScaleAndCenter. This indicates that the signature of the dependent API has changed, thus the change type is 5.","Despite the change in the method signature of the dependent API by adding a new parameter (mDisplayId), it does not introduce a compatibility issue in terms of different return values, types or exception handlings since the method's return type and exception handling remain unchanged. Therefore, there is no compatibility issue."
471,"<android.net.http.HttpResponseCache: CacheRequest put(URI,URLConnection)>",28,29,"<android.net.http.HttpResponseCache: CacheRequest put(URI,URLConnection)>","<android.net.http.HttpResponseCache: CacheRequest put(URI,URLConnection)>",0,"{
    return delegate.put(uri, urlConnection);
}","{
    return mDelegate.put(uri, urlConnection);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation change is about the renaming of the variable used to access the delegate from 'delegate' to 'mDelegate'. This is an internal change to the member variable name and does not alter the API's behavior, so the code change type is 4.","This renaming of a variable does not affect the behavior, return values, or exception handling of the API, so there is no compatibility issue. The renaming is purely an internal change and does not affect the API consumers. Hence, CI type is 0."
472,<android.view.WindowInsets: int getSystemWindowInsetRight()>,28,29,<android.view.WindowInsets: int getSystemWindowInsetRight()>,<android.view.WindowInsets: int getSystemWindowInsetRight()>,0,"{
    return mSystemWindowInsets.right;
}","{
    return getSystemWindowInsets().right;
}",1,"/**
 * Returns the right system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The right system window inset
 */
","/**
 * Returns the right system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The right system window inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late version of the method uses getSystemWindowInsets() instead of directly accessing mSystemWindowInsets, indicating that there is a dependency on a new or modified API, so the change type is 1,5.","Since the implementation has changed from direct field access to calling another API method to get the insets, the return value could potentially be different, constituting a Compatibility Issue of type 1."
474,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,28,29,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,0,"{
    try {
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor[] fds = Os.pipe2(ifAtLeastQ(O_CLOEXEC));
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */
","/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called within the try block changed from Os.pipe() to Os.pipe2(ifAtLeastQ(O_CLOEXEC)). This is a change in the dependent API, hence the change type is 4,5.","Although there is a change in the dependent API, the change does not appear to impact the behavior of the API itself with respect to the types of exceptions thrown or the values returned. The method still catches an `ErrnoException` and rethrows it as an `IOException`, and the returned array still solely depends on `FileDescriptor` values obtained from the operating system's pipe method. Unless the new method `Os.pipe2` changes the types or numbers of exceptions that can be thrown (which isn't indicated by the given information), there is no compatibility issue introduced by the change in the method call itself. Therefore, the CI type is 0."
476,"<android.util.jar.StrictJarManifestReader: void readEntries(Map<String, Attributes>,Chunk>)>",28,29,"<android.util.jar.StrictJarManifestReader: void readEntries(Map<String, Attributes>,Chunk>)>","<android.util.jar.StrictJarManifestReader: void readEntries(Map<String, Attributes>,Chunk>)>",0,"{
    int mark = pos;
    while (readHeader()) {
        if (!Attributes.Name.NAME.equals(name)) {
            throw new IOException(""Entry is not named"");
        }
        String entryNameValue = value;
        Attributes entry = entries.get(entryNameValue);
        if (entry == null) {
            entry = new Attributes(12);
        }
        while (readHeader()) {
            entry.put(name, value);
        }
        if (chunks != null) {
            if (chunks.get(entryNameValue) != null) {
                // updating the signature; for now a defensive error is thrown
                throw new IOException(""A jar verifier does not support more than one entry with the same name"");
            }
            chunks.put(entryNameValue, new StrictJarManifest.Chunk(mark, pos));
            mark = pos;
        }
        entries.put(entryNameValue, entry);
    }
}","{
    int mark = pos;
    while (readHeader()) {
        if (!StrictJarManifest.ATTRIBUTE_NAME_NAME.equals(name)) {
            throw new IOException(""Entry is not named"");
        }
        String entryNameValue = value;
        Attributes entry = entries.get(entryNameValue);
        if (entry == null) {
            entry = new Attributes(12);
        }
        while (readHeader()) {
            entry.put(name, value);
        }
        if (chunks != null) {
            if (chunks.get(entryNameValue) != null) {
                // updating the signature; for now a defensive error is thrown
                throw new IOException(""A jar verifier does not support more than one entry with the same name"");
            }
            chunks.put(entryNameValue, new StrictJarManifest.Chunk(mark, pos));
            mark = pos;
        }
        entries.put(entryNameValue, entry);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is to the attribute name from `Attributes.Name.NAME` to `StrictJarManifest.ATTRIBUTE_NAME_NAME`, which is a change in the dependent API. The literal value referenced by these constants is expected to remain the same, just the reference to the constant has changed. Therefore, the code change type is 5.","Since there is no change in the behavior of the method and the constants being compared should have the same value, it's reasonable to consider that there is no compatibility issue caused by this change. Hence, the CI type is 0."
477,<android.os.StrictMode.AndroidBlockGuardPolicy: void onWriteToDisk()>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void onWriteToDisk()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onWriteToDisk()>,0,"{
    if ((mPolicyMask & DETECT_DISK_WRITE) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new DiskWriteViolation());
}","{
    if ((mThreadPolicyMask & DETECT_THREAD_DISK_WRITE) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new DiskWriteViolation());
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the condition of the if statement, where 'mPolicyMask' has been changed to 'mThreadPolicyMask' and 'DETECT_DISK_WRITE' to 'DETECT_THREAD_DISK_WRITE'. This implies that the variable being checked and the constant it is being compared against have both changed. Additionally, there's a variable name change; however, the overall behavior of the method remains consistent with the previous implementation. There is no change to the structure of control flow, return values, or exception handling; therefore, the change is categorized under Other statement changed and Dependent API changed, types 4 and 5, respectively.","There are no new return statements, exception handling statements, or changes in control flow. The change in variable and constant name does not inherently indicate a change in the API's external behavior, as this might be due to a refactoring of internal constants or variable names for clarity or consistency. Hence, there does not appear to be a Compatibility Issue, and the prediction is 0."
479,"<android.content.pm.PackageInstaller: void registerSessionCallback(SessionCallback,Handler)>",28,29,"<android.content.pm.PackageInstaller: void registerSessionCallback(SessionCallback,Handler)>","<android.content.pm.PackageInstaller: void registerSessionCallback(SessionCallback,Handler)>",0,"{
    synchronized (mDelegates) {
        final SessionCallbackDelegate delegate = new SessionCallbackDelegate(callback, handler.getLooper());
        try {
            mInstaller.registerCallback(delegate, mUserId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        mDelegates.add(delegate);
    }
}","{
    synchronized (mDelegates) {
        final SessionCallbackDelegate delegate = new SessionCallbackDelegate(callback, new HandlerExecutor(handler));
        try {
            mInstaller.registerCallback(delegate, mUserId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        mDelegates.add(delegate);
    }
}",1,"/**
 * Register to watch for session lifecycle events. No special permissions
 * are required to watch for these events.
 *
 * @param handler to dispatch callback events through, otherwise uses
 * calling thread.
 */
","/**
 * Register to watch for session lifecycle events. No special permissions
 * are required to watch for these events.
 *
 * @param handler to dispatch callback events through, otherwise uses
 * calling thread.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's a change in how the `SessionCallbackDelegate` is constructed by wrapping the provided `handler` in a new `HandlerExecutor`, so the code change type is 4. Additionally, there's a change in the dependent API `new SessionCallbackDelegate(callback, new HandlerExecutor(handler))`, which makes the change type also 5.","The modification to the constructor of the `SessionCallbackDelegate` does not impact the behavior of `registerSessionCallback` with respect to its return type or exception handling, and it does not inherently lead to a CI, so the CI type is 0."
480,"<android.provider.DocumentsContract: Uri buildDocumentUri(String,String)>",28,29,"<android.provider.DocumentsContract: Uri buildDocumentUri(String,String)>","<android.provider.DocumentsContract: Uri buildDocumentUri(String,String)>",0,"{
    return new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(authority).appendPath(PATH_DOCUMENT).appendPath(documentId).build();
}","{
    return getBaseDocumentUriBuilder(authority).appendPath(documentId).build();
}",1,"/**
 * Build URI representing the target {@link Document#COLUMN_DOCUMENT_ID} in
 * a document provider. When queried, a provider will return a single row
 * with columns defined by {@link Document}.
 *
 * @see DocumentsProvider#queryDocument(String, String[])
 * @see #getDocumentId(Uri)
 */
","/**
 * Build URI representing the target {@link Document#COLUMN_DOCUMENT_ID} in
 * a document provider. When queried, a provider will return a single row
 * with columns defined by {@link Document}.
 *
 * @see DocumentsProvider#queryDocument(String, String[])
 * @see #getDocumentId(Uri)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method to construct the Uri has changed from directly building in the function to using a helper function getBaseDocumentUriBuilder(authority). This reflects a change in the how the Uri is created which is an Other Statement Changed (4). Also, there is a dependent API change (5) because it now relies on getBaseDocumentUriBuilder().","Despite the change in the implementation, the returned Uri should represent the same resource and therefore there is no change in the value or type of the returned variable assuming that getBaseDocumentUriBuilder(authority) correctly encapsulates the previous behavior. There is no compatibility issue (0) caused by this change."
481,<android.app.RemoteInput.Builder: RemoteInput build()>,28,29,<android.app.RemoteInput.Builder: RemoteInput build()>,<android.app.RemoteInput.Builder: RemoteInput build()>,0,"{
    return new RemoteInput(mResultKey, mLabel, mChoices, mFlags, mExtras, mAllowedDataTypes);
}","{
    return new RemoteInput(mResultKey, mLabel, mChoices, mFlags, mEditChoicesBeforeSending, mExtras, mAllowedDataTypes);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link RemoteInput}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link RemoteInput}
 * object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The constructor of RemoteInput called inside the build method has a new parameter added (mEditChoicesBeforeSending), which is a change in the statement that does not change control flow (type 4). Additionally, since the constructor's signature has changed, this also reflects a change in return statement (type 1).","The introduction of a new parameter in the RemoteInput constructor might cause different behavior (returning a RemoteInput object with potentially different state), so the CI type is 1."
482,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",28,29,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>","<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mUserId);
    dest.writeString(mId);
    dest.writeString(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString(mBitmapPath);
    dest.writeString(mIconResName);
    dest.writeString(mTitleResName);
    dest.writeString(mTextResName);
    dest.writeString(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
}","{
    dest.writeInt(mUserId);
    dest.writeString(mId);
    dest.writeString(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString(mBitmapPath);
    dest.writeString(mIconResName);
    dest.writeString(mTitleResName);
    dest.writeString(mTextResName);
    dest.writeString(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelableArray(mPersons, flags);
    dest.writeParcelable(mLocusId, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late version, new parcelable array 'mPersons' and a parcelable object 'mLocusId' have been written to the `Parcel`. These statements do not change control flow or exception handling, so the change type is 4.","Writing additional data to a `Parcel` does not alter the API behavior from the perspective of the calling code; the method still successfully writes to the parcel without returning a different value or throwing a new exception, so this would not constitute a Compatibility Issue. The additional data should be handled by corresponding `readFromParcel` logic that knows how to read the new fields without affecting older implementations. Therefore, the CI type is 0."
483,<android.view.KeyEvent: int keyCodeFromString(String)>,28,29,<android.view.KeyEvent: int keyCodeFromString(String)>,<android.view.KeyEvent: int keyCodeFromString(String)>,0,"{
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
        int keyCode = nativeKeyCodeFromString(symbolicName);
        if (keyCode > 0) {
            return keyCode;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return KEYCODE_UNKNOWN;
    }
}","{
    try {
        int keyCode = Integer.parseInt(symbolicName);
        if (keyCodeIsValid(keyCode)) {
            return keyCode;
        }
    } catch (NumberFormatException ex) {
    }
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
    }
    int keyCode = nativeKeyCodeFromString(symbolicName);
    if (keyCodeIsValid(keyCode)) {
        return keyCode;
    }
    return KEYCODE_UNKNOWN;
}",1,"/**
 * Gets a keycode by its symbolic name such as ""KEYCODE_A"" or an equivalent
 * numeric constant such as ""1001"".
 *
 * @param symbolicName The symbolic name of the keycode.
 * @return The keycode or {@link #KEYCODE_UNKNOWN} if not found.
 * @see #keycodeToString(int)
 */
","/**
 * Gets a keycode by its symbolic name such as ""KEYCODE_A"" or an equivalent
 * numeric constant such as ""29"". For symbolic names,
 * starting in {@link android.os.Build.VERSION_CODES#Q} the prefix ""KEYCODE_"" is optional.
 *
 * @param symbolicName The symbolic name of the keycode.
 * @return The keycode or {@link #KEYCODE_UNKNOWN} if not found.
 * @see #keyCodeToString(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control flow and structure of the method have changed. The parsing of the integer from the string has been moved to the top and wrapped in a try-catch block, the validation has been shifted down and replaced with a new validation method keyCodeIsValid(). Additionally, the organization of the string processing and nativeKeyCodeFromString call has been shifted. The code change type is 3 and 4 due to reordering of control flow and statements.","Since the control structure and method of processing the input string have changed, it is possible that the method may return different values for certain inputs versus the early version. Previously, it was immediately returning if the keyCode from nativeKeyCodeFromString was greater than 0, whereas now it checks the validity with keyCodeIsValid(). Also, the Integer.parseInt has moved outside the condition check for starting with LABEL_PREFIX, potentially affecting the returned value. The CI type is 1 due to potential changed return values."
484,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,28,29,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,0,"{
    if (VDBG)
        Log.d(TAG, ""executeReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""executeReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */
","/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the synchronization lock object, from mDeviceBusy to mDeviceBusyLock. The synchronization lock object change does not impact the method functionality or outcomes, so the code change type is 4.","The change in the synchronization lock object will not cause any change in the behavior of the method in terms of returning a different value or throwing different exceptions because it does not alter the logic or flow of the code. The synchronization itself ensures the same contract as before but with a different lock; hence no compatibility issue arises, and the CI type is 0."
485,"<android.service.autofill.CustomDescription: void writeToParcel(Parcel,int)>",28,29,"<android.service.autofill.CustomDescription: void writeToParcel(Parcel,int)>","<android.service.autofill.CustomDescription: void writeToParcel(Parcel,int)>",0,"{
    dest.writeParcelable(mPresentation, flags);
    if (mPresentation == null)
        return;
    if (mTransformations == null) {
        dest.writeIntArray(null);
    } else {
        final int size = mTransformations.size();
        final int[] ids = new int[size];
        final InternalTransformation[] values = new InternalTransformation[size];
        for (int i = 0; i < size; i++) {
            final Pair<Integer, InternalTransformation> pair = mTransformations.get(i);
            ids[i] = pair.first;
            values[i] = pair.second;
        }
        dest.writeIntArray(ids);
        dest.writeParcelableArray(values, flags);
    }
    if (mUpdates == null) {
        dest.writeParcelableArray(null, flags);
    } else {
        final int size = mUpdates.size();
        final InternalValidator[] conditions = new InternalValidator[size];
        final BatchUpdates[] updates = new BatchUpdates[size];
        for (int i = 0; i < size; i++) {
            final Pair<InternalValidator, BatchUpdates> pair = mUpdates.get(i);
            conditions[i] = pair.first;
            updates[i] = pair.second;
        }
        dest.writeParcelableArray(conditions, flags);
        dest.writeParcelableArray(updates, flags);
    }
}","{
    dest.writeParcelable(mPresentation, flags);
    if (mPresentation == null)
        return;
    if (mTransformations == null) {
        dest.writeIntArray(null);
    } else {
        final int size = mTransformations.size();
        final int[] ids = new int[size];
        final InternalTransformation[] values = new InternalTransformation[size];
        for (int i = 0; i < size; i++) {
            final Pair<Integer, InternalTransformation> pair = mTransformations.get(i);
            ids[i] = pair.first;
            values[i] = pair.second;
        }
        dest.writeIntArray(ids);
        dest.writeParcelableArray(values, flags);
    }
    if (mUpdates == null) {
        dest.writeParcelableArray(null, flags);
    } else {
        final int size = mUpdates.size();
        final InternalValidator[] conditions = new InternalValidator[size];
        final BatchUpdates[] updates = new BatchUpdates[size];
        for (int i = 0; i < size; i++) {
            final Pair<InternalValidator, BatchUpdates> pair = mUpdates.get(i);
            conditions[i] = pair.first;
            updates[i] = pair.second;
        }
        dest.writeParcelableArray(conditions, flags);
        dest.writeParcelableArray(updates, flags);
    }
    if (mActions == null) {
        dest.writeIntArray(null);
    } else {
        final int size = mActions.size();
        final int[] ids = new int[size];
        final InternalOnClickAction[] values = new InternalOnClickAction[size];
        for (int i = 0; i < size; i++) {
            ids[i] = mActions.keyAt(i);
            values[i] = mActions.valueAt(i);
        }
        dest.writeIntArray(ids);
        dest.writeParcelableArray(values, flags);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"In the late implementation, new code blocks have been added to handle the serialization of `mActions`. This change introduces additional statements for writing `mActions` to the `Parcel`, which is not present in the early version. Therefore, the code change type is 1,4 due to a new return statement introduced and other statements added.","The addition of writing `mActions` to the `Parcel` can cause a change in the behavior of the method because the parcel data written in the late version will be more than that of the early version. Thus, there is a change in the actual data content that is written to the parcel, and the CI type is 1 for a potential different return value. The method itself does not throw exceptions, so there's no CI related to exceptions."
486,<android.view.inputmethod.CursorAnchorInfo.Builder: CursorAnchorInfo build()>,28,29,<android.view.inputmethod.CursorAnchorInfo.Builder: CursorAnchorInfo build()>,<android.view.inputmethod.CursorAnchorInfo.Builder: CursorAnchorInfo build()>,0,"{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException(""Coordinate transformation matrix is "" + ""required when positional parameters are specified."");
        }
    }
    return new CursorAnchorInfo(this);
}","{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException(""Coordinate transformation matrix is "" + ""required when positional parameters are specified."");
        }
    }
    return CursorAnchorInfo.create(this);
}",1,"/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */
","/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method used for returning the CursorAnchorInfo instance has changed from `new CursorAnchorInfo(this)` to `CursorAnchorInfo.create(this)`. This is a change in the dependent API, leading to code change type 4,5, as the object creation pattern has changed and it's now using a static factory method.","The change from a constructor to a static factory method (`create`) could potentially return a different value, depending on the implementation of the `create` method. Therefore, the CI type is 1 due to the potential difference in the returned value of the method."
487,<android.app.Dialog: boolean isShowing()>,28,29,<android.app.Dialog: boolean isShowing()>,<android.app.Dialog: boolean isShowing()>,0,"{
    return mShowing;
}","{
    return mDecor == null ? false : mDecor.getVisibility() == View.VISIBLE;
}",1,"/**
 * @return Whether the dialog is currently showing.
 */
","/**
 * @return Whether the dialog is currently showing.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"In the late implementation, the method checks if `mDecor` is `null` and the visibility of `mDecor` instead of directly returning the `mShowing` field; this is a change in the return statement, so the code change type is 1.","The change in how the return value is computed can lead to the API returning a different value. For example, the condition `mDecor == null ? false : mDecor.getVisibility() == View.VISIBLE` can yield a different outcome compared to the direct return of `mShowing` from the early version, hence the CI type is 1."
489,"<android.view.inputmethod.InputMethodManager: void setAdditionalInputMethodSubtypes(String,InputMethodSubtype[])>",28,29,"<android.view.inputmethod.InputMethodManager: void setAdditionalInputMethodSubtypes(String,InputMethodSubtype[])>","<android.view.inputmethod.InputMethodManager: void setAdditionalInputMethodSubtypes(String,InputMethodSubtype[])>",0,"{
    synchronized (mH) {
        try {
            mService.setAdditionalInputMethodSubtypes(imiId, subtypes);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    try {
        mService.setAdditionalInputMethodSubtypes(imiId, subtypes);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Set additional input method subtypes. Only a process which shares the same uid with the IME
 * can add additional input method subtypes to the IME.
 * Please note that a subtype's status is stored in the system.
 * For example, enabled subtypes are remembered by the framework even after they are removed
 * by using this method. If you re-add the same subtypes again,
 * they will just get enabled. If you want to avoid such conflicts, for instance, you may
 * want to create a ""different"" new subtype even with the same locale and mode,
 * by changing its extra value. The different subtype won't get affected by the stored past
 * status. (You may want to take a look at {@link InputMethodSubtype#hashCode()} to refer
 * to the current implementation.)
 *
 * <p>NOTE: If the same subtype exists in both the manifest XML file and additional subtypes
 * specified by {@code subtypes}, those multiple instances are automatically merged into one
 * instance.</p>
 *
 * <p>CAVEAT: In API Level 23 and prior, the system may do nothing if an empty
 * {@link InputMethodSubtype} is specified in {@code subtypes}, which prevents you from removing
 * the last one entry of additional subtypes. If your IME statically defines one or more
 * subtypes in the manifest XML file, you may be able to work around this limitation by
 * specifying one of those statically defined subtypes in {@code subtypes}.</p>
 *
 * @param imiId Id of InputMethodInfo which additional input method subtypes will be added to.
 * @param subtypes subtypes will be added as additional subtypes of the current input method.
 */
","/**
 * Set additional input method subtypes. Only a process which shares the same uid with the IME
 * can add additional input method subtypes to the IME.
 * Please note that a subtype's status is stored in the system.
 * For example, enabled subtypes are remembered by the framework even after they are removed
 * by using this method. If you re-add the same subtypes again,
 * they will just get enabled. If you want to avoid such conflicts, for instance, you may
 * want to create a ""different"" new subtype even with the same locale and mode,
 * by changing its extra value. The different subtype won't get affected by the stored past
 * status. (You may want to take a look at {@link InputMethodSubtype#hashCode()} to refer
 * to the current implementation.)
 *
 * <p>NOTE: If the same subtype exists in both the manifest XML file and additional subtypes
 * specified by {@code subtypes}, those multiple instances are automatically merged into one
 * instance.</p>
 *
 * <p>CAVEAT: In API Level 23 and prior, the system may do nothing if an empty
 * {@link InputMethodSubtype} is specified in {@code subtypes}, which prevents you from removing
 * the last one entry of additional subtypes. If your IME statically defines one or more
 * subtypes in the manifest XML file, you may be able to work around this limitation by
 * specifying one of those statically defined subtypes in {@code subtypes}.</p>
 *
 * @param imiId Id of InputMethodInfo which additional input method subtypes will be added to.
 * @param subtypes subtypes will be added as additional subtypes of the current input method.
 * @deprecated For IMEs that have already implemented features like customizable/downloadable
 * keyboard layouts/languages, please start migration to other approaches. One idea
 * would be exposing only one unified {@link InputMethodSubtype} then implement
 * IME's own language switching mechanism within that unified subtype. The support
 * of ""Additional Subtype"" may be completely dropped in a future version of Android.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,The code change includes the removal of the synchronized block and the addition of a @Deprecated annotation. This change is a type 3 (control dependency changed) due to the modification in the synchronization approach and a type 4 (other statement changed) due to the annotation update.,"Despite the removal of the synchronized block potentially affecting thread safety, this change by itself does not result in different return values or exception handling which would lead to a compatibility issue; hence, there is no compatibility issue (0)."
490,<android.app.WallpaperManager: void setDisplayPadding(Rect)>,28,29,<android.app.WallpaperManager: void setDisplayPadding(Rect)>,<android.app.WallpaperManager: void setDisplayPadding(Rect)>,0,"{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDisplayPadding(padding, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDisplayPadding(padding, mContext.getOpPackageName(), mContext.getDisplayId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Specify extra padding that the wallpaper should have outside of the display.
 * That is, the given padding supplies additional pixels the wallpaper should extend
 * outside of the display itself.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param padding The number of pixels the wallpaper should extend beyond the display,
 * on its left, top, right, and bottom sides.
 */
","/**
 * Specify extra padding that the wallpaper should have outside of the display.
 * That is, the given padding supplies additional pixels the wallpaper should extend
 * outside of the display itself.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param padding The number of pixels the wallpaper should extend beyond the display,
 * on its left, top, right, and bottom sides.
 */
",-1,[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER_HINTS)],[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER_HINTS)],-1,-1,-1,-1,-1,-1,5,0,"The method signature for 'sGlobals.mService.setDisplayPadding()' has changed to include an additional parameter 'mContext.getDisplayId()'. However, this is a change to a dependent API call, so the code change type is 5.","There is no Compatibility Issue arising from this change as added parameters to methods only modify internal behavior and do not affect the behavior faced by the clients of the 'setDisplayPadding' method of 'WallpaperManager', assuming 'mContext.getDisplayId()' does not lead to an exception. There is no change in control flow or the way exceptions are handled, and the method's return type remains void. Therefore, the CI type is 0."
491,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,28,29,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId)
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}","{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId))
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}",1,"/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The code has been changed with the addition of a new condition in an if statement to check equality on an additional field mPhysicalCameraId using Objects.equals(). This change is an other statement changed, but since it's directly related to the return statement, it falls under return statement changed (1). It's not a change in control flow, exception handling, or a change in the signature of a dependent API, so those categories do not apply.","The added comparison of mPhysicalCameraId may cause the method to return a different boolean result when comparing two OutputConfiguration objects. Thus, it can potentially return a different value, hence the CI type is 1."
492,<android.content.pm.PackageParser.SigningDetails.Builder: SigningDetails build()>,28,29,<android.content.pm.PackageParser.SigningDetails.Builder: SigningDetails build()>,<android.content.pm.PackageParser.SigningDetails.Builder: SigningDetails build()>,0,"{
    checkInvariants();
    return new SigningDetails(mSignatures, mSignatureSchemeVersion, mPastSigningCertificates, mPastSigningCertificatesFlags);
}","{
    checkInvariants();
    return new SigningDetails(mSignatures, mSignatureSchemeVersion, mPastSigningCertificates);
}",1,"/**
 * build a {@code SigningDetails} object
 */
","/**
 * build a {@code SigningDetails} object
 */
",-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for `SigningDetails` in the return statement has changed, with `mPastSigningCertificatesFlags` removed from the arguments in the late version. A parameter was removed in the constructor call, which means the code change is of type 1,5.","The removal of the parameter `mPastSigningCertificatesFlags` from the constructor call means the build method potentially returns a `SigningDetails` object with different internal states, and hence the CI type is 1."
493,<android.app.Activity: void performStart(String)>,28,29,<android.app.Activity: void performStart(String)>,<android.app.Activity: void performStart(String)>,0,"{
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    writeEventLog(LOG_AM_ON_START_CALLED, reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    boolean isAppDebuggable = (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    // This property is set for all non-user builds except final release
    boolean isDlwarningEnabled = SystemProperties.getInt(""ro.bionic.ld.warning"", 0) == 1;
    if (isAppDebuggable || isDlwarningEnabled) {
        String dlwarning = getDlWarning();
        if (dlwarning != null) {
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = ""Detected problems with app native libraries\n"" + ""(please consult log for detail):\n"" + dlwarning;
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + ""\n"" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    // This property is set for all non-user builds except final release
    boolean isApiWarningEnabled = SystemProperties.getInt(""ro.art.hiddenapi.warning"", 0) == 1;
    if (isAppDebuggable || isApiWarningEnabled) {
        if (!mMainThread.mHiddenApiWarningShown && VMRuntime.getRuntime().hasUsedHiddenApi()) {
            // Only show the warning once per process.
            mMainThread.mHiddenApiWarningShown = true;
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = ""Detected problems with API compatibility\n"" + ""(visit g.co/dev/appcompat for more info)"";
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + ""\n"" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    mActivityTransitionState.enterReady(this);
}","{
    dispatchActivityPreStarted();
    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    writeEventLog(LOG_AM_ON_START_CALLED, reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    mFragments.reportLoaderStart();
    boolean isAppDebuggable = (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    // This property is set for all non-user builds except final release
    boolean isDlwarningEnabled = SystemProperties.getInt(""ro.bionic.ld.warning"", 0) == 1;
    if (isAppDebuggable || isDlwarningEnabled) {
        String dlwarning = getDlWarning();
        if (dlwarning != null) {
            String appName = getApplicationInfo().loadLabel(getPackageManager()).toString();
            String warning = ""Detected problems with app native libraries\n"" + ""(please consult log for detail):\n"" + dlwarning;
            if (isAppDebuggable) {
                new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok, null).setCancelable(false).show();
            } else {
                Toast.makeText(this, appName + ""\n"" + warning, Toast.LENGTH_LONG).show();
            }
        }
    }
    GraphicsEnvironment.getInstance().showAngleInUseDialogBox(this);
    mActivityTransitionState.enterReady(this);
    dispatchActivityPostStarted();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late implementation includes the addition of two method calls, 'dispatchActivityPreStarted()' at the beginning and 'dispatchActivityPostStarted()' at the end, which are not present in the early version. There is also an additional call to 'GraphicsEnvironment.getInstance().showAngleInUseDialogBox(this);'. These changes are modifications to the method body that are not return statements, exception handling statements, control dependency changes, or dependent API changes. Therefore, the code change type is 4.","No Compatibility Issue arises from these changes because all added statements do not alter the return value or exception handling of the `performStart` method. The method's behavior in terms of its observable effects (returns and exceptions) remains unchanged for the caller, assuming `dispatchActivityPreStarted()`, `dispatchActivityPostStarted()`, and `showAngleInUseDialogBox(this)` do not throw unchecked exceptions or return a value that affects the subsequent flow. Thus, CI type is 0."
494,<android.view.WindowInsets: boolean hasSystemWindowInsets()>,28,29,<android.view.WindowInsets: boolean hasSystemWindowInsets()>,<android.view.WindowInsets: boolean hasSystemWindowInsets()>,0,"{
    return mSystemWindowInsets.left != 0 || mSystemWindowInsets.top != 0 || mSystemWindowInsets.right != 0 || mSystemWindowInsets.bottom != 0;
}","{
    return !getSystemWindowInsets().equals(Insets.NONE);
}",1,"/**
 * Returns true if this WindowInsets has nonzero system window insets.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return true if any of the system window inset values are nonzero
 */
","/**
 * Returns true if this WindowInsets has nonzero system window insets.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return true if any of the system window inset values are nonzero
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method of determining if the WindowInsets has system window insets has been changed from checking individual insets' values directly to using the getSystemWindowInsets().equals(Insets.NONE), and this is a dependent API change since getSystemWindowInsets() is used instead of direct field access, so the change types are 1,5.","The logic is altered to rely on the equals method of an Insets object to determine if any system window insets are present. This could potentially lead to different return values in cases where the old direct field comparison with zero and the new equals check against a static Insets.NONE constant might differ due to how the equality is assessed. Therefore, the CI type is 1."
495,<android.app.NotificationChannelGroup: String toString()>,28,29,<android.app.NotificationChannelGroup: String toString()>,<android.app.NotificationChannelGroup: String toString()>,0,"{
    return ""NotificationChannelGroup{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDescription) ? ""hasDescription "" : """") + "", mBlocked="" + mBlocked + "", mChannels="" + mChannels + '}';
}","{
    return ""NotificationChannelGroup{"" + ""mId='"" + mId + '\'' + "", mName="" + mName + "", mDescription="" + (!TextUtils.isEmpty(mDescription) ? ""hasDescription "" : """") + "", mBlocked="" + mBlocked + "", mChannels="" + mChannels + "", mUserLockedFields="" + mUserLockedFields + '}';
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The string that the method returns is changed by appending a new field, 'mUserLockedFields', to the return value. The core functionality of the method is the same (it still returns a string representation of the object), so the change type is 4.","This code change does not cause a compatibility issue because the method is intended to return a string representation of the object, and the change does not affect how other code interacts with it. The change simply includes more information in the output string, which does not affect backward compatibility with code that calls this method. It's an enhancement rather than a change in behavior, so there is no compatibility issue."
496,<android.app.VoiceInteractor: Request[] getActiveRequests()>,28,29,<android.app.VoiceInteractor: Request[] getActiveRequests()>,<android.app.VoiceInteractor: Request[] getActiveRequests()>,0,"{
    synchronized (mActiveRequests) {
        final int N = mActiveRequests.size();
        if (N <= 0) {
            return NO_REQUESTS;
        }
        Request[] requests = new Request[N];
        for (int i = 0; i < N; i++) {
            requests[i] = mActiveRequests.valueAt(i);
        }
        return requests;
    }
}","{
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return null;
    }
    synchronized (mActiveRequests) {
        final int N = mActiveRequests.size();
        if (N <= 0) {
            return NO_REQUESTS;
        }
        Request[] requests = new Request[N];
        for (int i = 0; i < N; i++) {
            requests[i] = mActiveRequests.valueAt(i);
        }
        return requests;
    }
}",1,"/**
 * Return all currently active requests.
 */
","/**
 * Return all currently active requests.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,A new if-statement is introduced at the beginning of the method which checks if the VoiceInteractor is destroyed and returns null. This is a change in control dependency as well as a return statement change.,"The early version of the API does not have a check for whether the VoiceInteractor is destroyed and will never return null in that case, while the late version does. Due to the introduction of this new control statement and the corresponding return of null, the API can behave differently when the VoiceInteractor is destroyed. Therefore, the CI type is 1 because of the potential to return a different value."
497,<android.content.ContentValues: String getAsString(String)>,28,29,<android.content.ContentValues: String getAsString(String)>,<android.content.ContentValues: String getAsString(String)>,0,"{
    Object value = mValues.get(key);
    return value != null ? value.toString() : null;
}","{
    Object value = mMap.get(key);
    return value != null ? value.toString() : null;
}",1,"/**
 * Gets a value and converts it to a String.
 *
 * @param key the value to get
 * @return the String for the value
 */
","/**
 * Gets a value and converts it to a String.
 *
 * @param key the value to get
 * @return the String for the value
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code changes from using `mValues.get(key)` to `mMap.get(key)`. This is a change in the internal variable used to retrieve the value, categorized as 4 (Other statement changed). Additionally, because the method signature for 'get' should remain the same and it's an internal change, this is also categorized as 5 (Dependent API changed).","There's no Compatibility Issue since the method `getAsString` is still returning the same value in the same way as before (it's just retrieving the value from a differently named internal map). The behavior of the method has not changed from the caller's perspective; hence, no CI is detected."
498,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: RemoteViews getViewAt(int)>,28,29,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: RemoteViews getViewAt(int)>,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: RemoteViews getViewAt(int)>,0,"{
    RemoteViews rv = null;
    try {
        rv = mFactory.getViewAt(position);
        if (rv != null) {
            rv.setIsWidgetCollectionChild(true);
        }
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return rv;
}","{
    RemoteViews rv = null;
    try {
        rv = mFactory.getViewAt(position);
        if (rv != null) {
            rv.addFlags(RemoteViews.FLAG_WIDGET_IS_COLLECTION_CHILD);
        }
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return rv;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method used to flag the RemoteViews object has changed from setIsWidgetCollectionChild(true) to addFlags(RemoteViews.FLAG_WIDGET_IS_COLLECTION_CHILD), so the code change type is 4.","Despite the change in how the flag is set on the RemoteViews object, the behavior from the API consumer's perspective should remain the same as both methods aim to achieve the same end result (marking the RemoteViews as a child of a widget collection). No new return statements or exception handling changes were introduced. Therefore, no Compatibility Issue arises, and the CI type is 0."
499,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,28,29,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(InputMethodClient.START_INPUT_REASON_BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @InputMethodClient.UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodClient.getUnbindReason(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(InputMethodClient.START_INPUT_REASON_UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && canStartInput(mServedView)) {
                        if (checkFocusNoStartInput(mRestartOnNextWindowFocus)) {
                            final int reason = active ? InputMethodClient.START_INPUT_REASON_ACTIVATED_BY_IMMS : InputMethodClient.START_INPUT_REASON_DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_SET_USER_ACTION_NOTIFICATION_SEQUENCE_NUMBER:
            {
                synchronized (mH) {
                    mNextUserActionNotificationSequenceNumber = msg.arg1;
                }
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                    mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
                }
                startInputInner(StartInputReason.BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodDebug.unbindReasonToString(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // we would like to re-connect to the next input method.
                    if (mServedView != null && mServedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(StartInputReason.UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // handling this message.
                    if (mServedView != null && canStartInput(mServedView)) {
                        if (checkFocusNoStartInput(mRestartOnNextWindowFocus)) {
                            final int reason = active ? StartInputReason.ACTIVATED_BY_IMMS : StartInputReason.DEACTIVATED_BY_IMMS;
                            startInputInner(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
        case MSG_REPORT_PRE_RENDERED:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.onPreRendered((EditorInfo) msg.obj);
                    }
                }
                return;
            }
        case MSG_APPLY_IME_VISIBILITY:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.applyImeVisibility(msg.arg1 != 0);
                    }
                }
                return;
            }
        case MSG_UPDATE_ACTIVITY_VIEW_TO_SCREEN_MATRIX:
            {
                final float[] matrixValues = (float[]) msg.obj;
                final int bindSequence = msg.arg1;
                synchronized (mH) {
                    if (mBindSequence != bindSequence) {
                        return;
                    }
                    if (matrixValues == null) {
                        // That this app is unbound from the parent ActivityView. In this case,
                        // calling updateCursorAnchorInfo() isn't safe.  Only clear the matrix.
                        mActivityViewToScreenMatrix = null;
                        return;
                    }
                    final float[] currentValues = new float[9];
                    mActivityViewToScreenMatrix.getValues(currentValues);
                    if (Arrays.equals(currentValues, matrixValues)) {
                        return;
                    }
                    mActivityViewToScreenMatrix.setValues(matrixValues);
                    if (mCursorAnchorInfo == null || mCurMethod == null || mServedInputConnectionWrapper == null) {
                        return;
                    }
                    final boolean isMonitoring = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_MONITOR) != 0;
                    if (!isMonitoring) {
                        return;
                    }
                    // IMS#updateCursorAnchorInfo() again.
                    try {
                        mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(mCursorAnchorInfo, mActivityViewToScreenMatrix));
                    } catch (RemoteException e) {
                        Log.w(TAG, ""IME died: "" + mCurId, e);
                    }
                }
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
500,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,28,29,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,<android.content.ContentResolver: ContentProviderClient acquireContentProviderClient(Uri)>,0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, true);
    }
    return null;
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, uri.getAuthority(), true);
    }
    return null;
}",1,"/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider it it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
","/**
 * Returns a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri, starting the provider if necessary. Returns
 * null if there is no provider associated wih the uri. The caller must indicate that they are
 * done with the provider by calling {@link ContentProviderClient#release} which will allow
 * the system to release the provider if it determines that there is no other reason for
 * keeping it active.
 * @param uri specifies which provider should be acquired
 * @return a {@link ContentProviderClient} that is associated with the {@link ContentProvider}
 * that services the content at uri or null if there isn't one.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The constructor for `ContentProviderClient` now includes an additional parameter (`uri.getAuthority()`), which indicates a change in the dependent API (the constructor itself). Additionally, the change involves adding a new parameter to the method call, which is a type of Other statement changed. These constitute the changes in code: 1, 4, 5.","The change in how `ContentProviderClient` is constructed with an additional parameter could potentially lead to a difference in behavior of the returned `ContentProviderClient` object. This constitutes a Compatibility Issue because the object instantiated with the additional parameter might behave differently, resulting in a different return value. Hence, the CI type is 1."
501,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectDiskWrites()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectDiskWrites()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectDiskWrites()>,0,"{
    return enable(DETECT_DISK_WRITE);
}","{
    return enable(DETECT_THREAD_DISK_WRITE);
}",1,"/**
 * Enable detection of disk writes.
 */
","/**
 * Enable detection of disk writes.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The method that is being called within the return statement has been changed from enable(DETECT_DISK_WRITE) to enable(DETECT_THREAD_DISK_WRITE), indicating a change in the method being used, possibly affecting its behavior. Additionally, the parameter passed to the method has been altered, potentially leading to different outcomes and actions taken within the method. Therefore, the change type is 1,5.","The change to the method being called, as well as the parameter, implies that the return value of the method may differ between versions. Since the `enable` method is being called with different arguments, the state modified or value returned by `enable` could be different. This indicates that there's a potential for a Compatibility Issue due to a different return value, hence CI type 1."
503,"<android.provider.DocumentsContract: Uri renameDocument(ContentResolver,Uri,String)>",28,29,"<android.provider.DocumentsContract: Uri renameDocument(ContentResolver,Uri,String)>","<android.provider.DocumentsContract: Uri renameDocument(ContentResolver,Uri,String)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return renameDocument(client, documentUri, displayName);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to rename document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, documentUri);
        in.putString(Document.COLUMN_DISPLAY_NAME, displayName);
        final Bundle out = content.call(documentUri.getAuthority(), METHOD_RENAME_DOCUMENT, null, in);
        final Uri outUri = out.getParcelable(DocumentsContract.EXTRA_URI);
        return (outUri != null) ? outUri : documentUri;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to rename document"", e);
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Change the display name of an existing document.
 * <p>
 * If the underlying provider needs to create a new
 * {@link Document#COLUMN_DOCUMENT_ID} to represent the updated display
 * name, that new document is returned and the original document is no
 * longer valid. Otherwise, the original document is returned.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_RENAME}
 * @param displayName updated name for document
 * @return the existing or new document after the rename, or {@code null} if
 * failed.
 */
","/**
 * Change the display name of an existing document.
 * <p>
 * If the underlying provider needs to create a new
 * {@link Document#COLUMN_DOCUMENT_ID} to represent the updated display
 * name, that new document is returned and the original document is no
 * longer valid. Otherwise, the original document is returned.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_RENAME}
 * @param displayName updated name for document
 * @return the existing or new document after the rename, or {@code null} if
 * failed.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The implementation's structure has been significantly changed including altered method call for renaming document, exception handling, and new bundle handling. It shifts from acquireUnstableContentProviderClient to using the ContentResolver call method with Bundle parameters. There's also a new mechanism to determine the returned Uri. Moreover, the dependent API has changed, specifically `renameDocument(client, documentUri, displayName)` is replaced with call to the provider with METHOD_RENAME_DOCUMENT and Bundle as arguments. These are changes of types 1, 2, 4, and 5.","This change can cause a different value to be returned (either a new document Uri or the original one, instead of always trying to return the renamed document Uri or null) indicating a potential CI due to different return types/values. Moreover, the change in exception handling, now directly rethrowing the exception instead of just logging and returning null, could lead to potentially different exception handling, representing a CI as well. There can be both types 1 and 2 CIs."
504,"<android.provider.MediaStore.Audio.Playlists.Members: Uri getContentUri(String,long)>",28,29,"<android.provider.MediaStore.Audio.Playlists.Members: Uri getContentUri(String,long)>","<android.provider.MediaStore.Audio.Playlists.Members: Uri getContentUri(String,long)>",0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/playlists/"" + playlistId + ""/members"");
}","{
    return ContentUris.withAppendedId(Audio.Playlists.getContentUri(volumeName), playlistId).buildUpon().appendPath(""members"").build();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed from constructing the Uri directly by string concatenation to using ContentUris.withAppendedId() and other method calls to construct the Uri. This is a significant change to the return statement and dependent APIs are also involved in constructing the Uri, so the code change type is 1,5.","The change in the return statement and construction method of the Uri could lead to a different returned Uri value, so the CI type is 1."
505,"<android.content.Intent: int fillIn(Intent,int)>",28,29,"<android.content.Intent: int fillIn(Intent,int)>","<android.content.Intent: int fillIn(Intent,int)>",0,"{
    int changes = 0;
    boolean mayHaveCopiedUris = false;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
        mayHaveCopiedUris = true;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new ArraySet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    if (other.mClipData != null && (mClipData == null || (flags & FILL_IN_CLIP_DATA) != 0)) {
        mClipData = other.mClipData;
        changes |= FILL_IN_CLIP_DATA;
        mayHaveCopiedUris = true;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
            mayHaveCopiedUris = true;
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
            mayHaveCopiedUris = true;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    if (mayHaveCopiedUris && mContentUserHint == UserHandle.USER_CURRENT && other.mContentUserHint != UserHandle.USER_CURRENT) {
        mContentUserHint = other.mContentUserHint;
    }
    return changes;
}","{
    int changes = 0;
    boolean mayHaveCopiedUris = false;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
        mayHaveCopiedUris = true;
    }
    if (other.mIdentifier != null && (mIdentifier == null || (flags & FILL_IN_IDENTIFIER) != 0)) {
        mIdentifier = other.mIdentifier;
        changes |= FILL_IN_IDENTIFIER;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new ArraySet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    if (other.mClipData != null && (mClipData == null || (flags & FILL_IN_CLIP_DATA) != 0)) {
        mClipData = other.mClipData;
        changes |= FILL_IN_CLIP_DATA;
        mayHaveCopiedUris = true;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
            mayHaveCopiedUris = true;
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
            mayHaveCopiedUris = true;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(TAG, ""Failure filling in extras"", e);
        }
    }
    if (mayHaveCopiedUris && mContentUserHint == UserHandle.USER_CURRENT && other.mContentUserHint != UserHandle.USER_CURRENT) {
        mContentUserHint = other.mContentUserHint;
    }
    return changes;
}",1,"/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}.
 * <li> selector, as set by {@link #setSelector(Intent)}.
 * <li> clip data, as set by {@link #setClipData(ClipData)}.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
 * the restriction where the corresponding field will not be replaced if
 * it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
 * is explicitly specified.  The selector will only be copied if
 * {@link #FILL_IN_SELECTOR} is explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR} and {@link #FILL_IN_CLIP_DATA} indicating which fields were
 * changed.
 */
","/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> identifier, as set by {@link #setIdentifier}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}.
 * <li> selector, as set by {@link #setSelector(Intent)}.
 * <li> clip data, as set by {@link #setClipData(ClipData)}.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_IDENTIFIER}, {@link #FILL_IN_CATEGORIES},
 * {@link #FILL_IN_PACKAGE}, {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
 * the restriction where the corresponding field will not be replaced if
 * it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
 * is explicitly specified.  The selector will only be copied if
 * {@link #FILL_IN_SELECTOR} is explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR} and {@link #FILL_IN_CLIP_DATA} indicating which fields were
 * changed.
 */
",-1,[@FillInFlags],[@FillInFlags],-1,-1,-1,-1,-1,-1,,,,
507,<android.app.Notification.Action: Action clone()>,28,29,<android.app.Notification.Action: Action clone()>,<android.app.Notification.Action: Action clone()>,0,"{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, mExtras == null ? new Bundle() : new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies(), getSemanticAction());
}","{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, mExtras == null ? new Bundle() : new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies(), getSemanticAction(), isContextual());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of Action in the return statement includes an additional parameter isContextual() in the late version, which indicates a change in the return statement and also a change in a dependent API (the constructor), so the code change types are 1 and 5.","The additional parameter in the Action constructor can potentially change the behavior of the returned Action object, hence there is a Compatibility Issue caused by potential different return values or types, which is type 1."
508,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setScale(float,boolean)>",28,29,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setScale(float,boolean)>","<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setScale(float,boolean)>",0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(scale, Float.NaN, Float.NaN, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, scale, Float.NaN, Float.NaN, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Sets the magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param scale the magnification scale to set, must be >= 1 and <= 5
 * @param animate {@code true} to animate from the current scale or
 * {@code false} to set the scale immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Sets the magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param scale the magnification scale to set, must be >= 1 and <= 8
 * @param animate {@code true} to animate from the current scale or
 * {@code false} to set the scale immediately
 * @return {@code true} on success, {@code false} on failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method call connection.setMagnificationScaleAndCenter() now takes an additional parameter mDisplayId in the late version. This indicates that a dependent API has changed, which corresponds to change type 5.","There are no changes in the return statements or exception handling within the given method that would suggest a different behavior. The additional parameter in the dependent API does not directly imply that the behavior will change from the call within this method, as this method's signature or its control flow has not changed. Therefore, there is no compatibility issue as per the definitions given; hence, the CI type is 0."
509,<android.view.textclassifier.TextLinks.Builder: TextLinks build()>,28,29,<android.view.textclassifier.TextLinks.Builder: TextLinks build()>,<android.view.textclassifier.TextLinks.Builder: TextLinks build()>,0,"{
    return new TextLinks(mFullText, mLinks);
}","{
    return new TextLinks(mFullText, mLinks, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Constructs a TextLinks instance.
 *
 * @return the constructed TextLinks
 */
","/**
 * Constructs a TextLinks instance.
 *
 * @return the constructed TextLinks
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1, 4",1,"The constructor call for `TextLinks` in the return statement has been updated to include a new parameter, with a conditional expression that checks if `mExtras` is null. This constitutes a change in the 'Other statement' category as it's an additional expression as well as a change in the 'Return statement' since the constructor call being returned has changed, therefore, the change types are 1, 4.","The addition of a new parameter in the constructor call changes the data that is returned by the API. If `mExtras` is not null, then the extra data returned will differ between versions, which potentially leads to different return values. Thus, the CI type is 1."
510,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getEnabledInputMethodList()>,28,29,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getEnabledInputMethodList()>,<android.view.inputmethod.InputMethodManager: List<InputMethodInfo> getEnabledInputMethodList()>,0,"{
    try {
        return mService.getEnabledInputMethodList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        // instead.
        return mService.getEnabledInputMethodList(UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,"/**
 * Returns the list of enabled input methods.
 *
 * <p>On multi user environment, this API returns a result for the calling process user.</p>
 *
 * @return {@link List} of {@link InputMethodInfo}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The code change involves adding a parameter to the call to mService.getEnabledInputMethodList(), modifying it from mService.getEnabledInputMethodList() to mService.getEnabledInputMethodList(UserHandle.myUserId()). This parameter addition indicates a change to a dependent API, and thus the change type is 1,5.","Although a new parameter is passed to the getEnabledInputMethodList() method, typically adding information about the user ID, this change should not affect the functionality from the perspective of the caller assuming that the underlying system provides the correct list for the current user. Therefore, it is not expected to cause a Compatibility Issue as it should behave as expected for the callers, which means it does not necessarily lead to a different return type or value when called within the GUI session of the same user. Thus, the CI type is 0."
511,<android.inputmethodservice.InputMethodService: void setBackDisposition(int)>,28,29,<android.inputmethodservice.InputMethodService: void setBackDisposition(int)>,<android.inputmethodservice.InputMethodService: void setBackDisposition(int)>,0,"{
    if (disposition == mBackDisposition) {
        return;
    }
    if (disposition > BACK_DISPOSITION_MAX || disposition < BACK_DISPOSITION_MIN) {
        Log.e(TAG, ""Invalid back disposition value ("" + disposition + "") specified."");
        return;
    }
    mBackDisposition = disposition;
    mImm.setImeWindowStatus(mToken, mStartInputToken, mapToImeWindowStatus(isInputViewShown()), mBackDisposition);
}","{
    if (disposition == mBackDisposition) {
        return;
    }
    if (disposition > BACK_DISPOSITION_MAX || disposition < BACK_DISPOSITION_MIN) {
        Log.e(TAG, ""Invalid back disposition value ("" + disposition + "") specified."");
        return;
    }
    mBackDisposition = disposition;
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
}",1,"/**
 * Sets the disposition mode that indicates the expected affordance for the back button.
 *
 * <p>Keep in mind that specifying this flag does not change the the default behavior of
 * {@link #onKeyDown(int, KeyEvent)}.  It is IME developers' responsibility for making sure that
 * their custom implementation of {@link #onKeyDown(int, KeyEvent)} is consistent with the mode
 * specified to this API.</p>
 *
 * @see #getBackDisposition()
 * @param disposition disposition mode to be set
 */
","/**
 * Sets the disposition mode that indicates the expected affordance for the back button.
 *
 * <p>Keep in mind that specifying this flag does not change the the default behavior of
 * {@link #onKeyDown(int, KeyEvent)}.  It is IME developers' responsibility for making sure that
 * their custom implementation of {@link #onKeyDown(int, KeyEvent)} is consistent with the mode
 * specified to this API.</p>
 *
 * @see #getBackDisposition()
 * @param disposition disposition mode to be set
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change is in the way the status is set at the end of the method; the method call changed from mImm.setImeWindowStatus() in the early version to setImeWindowStatus() in the late version; the new implementation also drops parameters mToken and mStartInputToken and only passes the results of the mapToImeWindowStatus() method and mBackDisposition. This change affects a dependent API (method call), so the code change type is 4,5.","The change to a dependent API where the invocation of setting the IME window status no longer includes certain parameters (mToken, mStartInputToken) may cause the API to behave differently (e.g., different effects on the IME window status), hence there could be a compatibility issue of type 1 where the behavior of setting the back disposition is different and possibly affects the outcome of the method."
514,<android.bluetooth.BluetoothHealth: int getConnectionState(BluetoothDevice)>,28,29,<android.bluetooth.BluetoothHealth: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothHealth: int getConnectionState(BluetoothDevice)>,0,"{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getHealthDeviceConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return STATE_DISCONNECTED;
}","{
    Log.e(TAG, ""getConnectionState(): BluetoothHealth is deprecated"");
    return STATE_DISCONNECTED;
}",1,"/**
 * Get the current connection state of the profile.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter with the remote device. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param device Remote bluetooth device.
 * @return State of the profile connection. One of {@link #STATE_CONNECTED}, {@link
 * #STATE_CONNECTING}, {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING}
 */
","/**
 * Get the current connection state of the profile.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter with the remote device. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param device Remote bluetooth device.
 * @return State of the profile connection. One of {@link #STATE_CONNECTED}, {@link
 * #STATE_CONNECTING}, {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The complete logic in the early implementation checking conditions and potentially returning a value obtained from the service has been removed. The late version unconditionally logs an error message and returns STATE_DISCONNECTED, so the change type is 1.","Since the entire implementation has been changed to always return STATE_DISCONNECTED and no longer does the checks or service call as in the early version, it's guaranteed that the return values will differ between versions in cases where the checks would have previously succeeded. This is a direct cause of a different return value, so the CI type is 1."
515,<android.widget.AbsListView.PositionScroller: void run()>,28,29,<android.widget.AbsListView.PositionScroller: void run()>,<android.widget.AbsListView.PositionScroller: void run()>,0,"{
    final int listHeight = getHeight();
    final int firstPos = mFirstPosition;
    switch(mMode) {
        case MOVE_DOWN_POS:
            {
                final int lastViewIndex = getChildCount() - 1;
                final int lastPos = firstPos + lastViewIndex;
                if (lastViewIndex < 0) {
                    return;
                }
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = lastPos < mItemCount - 1 ? Math.max(mListPadding.bottom, mExtraScroll) : mListPadding.bottom;
                final int scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                smoothScrollBy(scrollBy, mScrollDuration, true, lastPos < mTargetPos);
                mLastSeenPos = lastPos;
                if (lastPos < mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_DOWN_BOUND:
            {
                final int nextViewIndex = 1;
                final int childCount = getChildCount();
                if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) {
                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    return;
                }
                final int nextPos = firstPos + nextViewIndex;
                if (nextPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View nextView = getChildAt(nextViewIndex);
                final int nextViewHeight = nextView.getHeight();
                final int nextViewTop = nextView.getTop();
                final int extraScroll = Math.max(mListPadding.bottom, mExtraScroll);
                if (nextPos < mBoundPos) {
                    smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration, true, true);
                    mLastSeenPos = nextPos;
                    postOnAnimation(this);
                } else {
                    if (nextViewTop > extraScroll) {
                        smoothScrollBy(nextViewTop - extraScroll, mScrollDuration, true, false);
                    } else {
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                break;
            }
        case MOVE_UP_POS:
            {
                if (firstPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View firstView = getChildAt(0);
                if (firstView == null) {
                    return;
                }
                final int firstViewTop = firstView.getTop();
                final int extraScroll = firstPos > 0 ? Math.max(mExtraScroll, mListPadding.top) : mListPadding.top;
                smoothScrollBy(firstViewTop - extraScroll, mScrollDuration, true, firstPos > mTargetPos);
                mLastSeenPos = firstPos;
                if (firstPos > mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_UP_BOUND:
            {
                final int lastViewIndex = getChildCount() - 2;
                if (lastViewIndex < 0) {
                    return;
                }
                final int lastPos = firstPos + lastViewIndex;
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = Math.max(mListPadding.top, mExtraScroll);
                mLastSeenPos = lastPos;
                if (lastPos > mBoundPos) {
                    smoothScrollBy(-(lastViewPixelsShowing - extraScroll), mScrollDuration, true, true);
                    postOnAnimation(this);
                } else {
                    final int bottom = listHeight - extraScroll;
                    final int lastViewBottom = lastViewTop + lastViewHeight;
                    if (bottom > lastViewBottom) {
                        smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration, true, false);
                    } else {
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                break;
            }
        case MOVE_OFFSET:
            {
                if (mLastSeenPos == firstPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                mLastSeenPos = firstPos;
                final int childCount = getChildCount();
                final int position = mTargetPos;
                final int lastPos = firstPos + childCount - 1;
                // Account for the visible ""portion"" of the first / last child when we estimate
                // how many screens we should travel to reach our target
                final View firstChild = getChildAt(0);
                final int firstChildHeight = firstChild.getHeight();
                final View lastChild = getChildAt(childCount - 1);
                final int lastChildHeight = lastChild.getHeight();
                final float firstPositionVisiblePart = (firstChildHeight == 0.0f) ? 1.0f : (float) (firstChildHeight + firstChild.getTop()) / firstChildHeight;
                final float lastPositionVisiblePart = (lastChildHeight == 0.0f) ? 1.0f : (float) (lastChildHeight + getHeight() - lastChild.getBottom()) / lastChildHeight;
                float viewTravelCount = 0;
                if (position < firstPos) {
                    viewTravelCount = firstPos - position + (1.0f - firstPositionVisiblePart) + 1;
                } else if (position > lastPos) {
                    viewTravelCount = position - lastPos + (1.0f - lastPositionVisiblePart);
                }
                // Estimate how many screens we should travel
                final float screenTravelCount = viewTravelCount / childCount;
                final float modifier = Math.min(Math.abs(screenTravelCount), 1.f);
                if (position < firstPos) {
                    final int distance = (int) (-getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true, true);
                    postOnAnimation(this);
                } else if (position > lastPos) {
                    final int distance = (int) (getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true, true);
                    postOnAnimation(this);
                } else {
                    // On-screen, just scroll.
                    final int targetTop = getChildAt(position - firstPos).getTop();
                    final int distance = targetTop - mOffsetFromTop;
                    final int duration = (int) (mScrollDuration * ((float) Math.abs(distance) / getHeight()));
                    smoothScrollBy(distance, duration, true, false);
                }
                break;
            }
        default:
            break;
    }
}","{
    final int listHeight = getHeight();
    final int firstPos = mFirstPosition;
    switch(mMode) {
        case MOVE_DOWN_POS:
            {
                final int lastViewIndex = getChildCount() - 1;
                final int lastPos = firstPos + lastViewIndex;
                if (lastViewIndex < 0) {
                    return;
                }
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = lastPos < mItemCount - 1 ? Math.max(mListPadding.bottom, mExtraScroll) : mListPadding.bottom;
                final int scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                smoothScrollBy(scrollBy, mScrollDuration, true, lastPos < mTargetPos);
                mLastSeenPos = lastPos;
                if (lastPos < mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_DOWN_BOUND:
            {
                final int nextViewIndex = 1;
                final int childCount = getChildCount();
                if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) {
                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    return;
                }
                final int nextPos = firstPos + nextViewIndex;
                if (nextPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View nextView = getChildAt(nextViewIndex);
                final int nextViewHeight = nextView.getHeight();
                final int nextViewTop = nextView.getTop();
                final int extraScroll = Math.max(mListPadding.bottom, mExtraScroll);
                if (nextPos < mBoundPos) {
                    smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration, true, true);
                    mLastSeenPos = nextPos;
                    postOnAnimation(this);
                } else {
                    if (nextViewTop > extraScroll) {
                        smoothScrollBy(nextViewTop - extraScroll, mScrollDuration, true, false);
                    } else {
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                break;
            }
        case MOVE_UP_POS:
            {
                if (firstPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View firstView = getChildAt(0);
                if (firstView == null) {
                    return;
                }
                final int firstViewTop = firstView.getTop();
                final int extraScroll = firstPos > 0 ? Math.max(mExtraScroll, mListPadding.top) : mListPadding.top;
                smoothScrollBy(firstViewTop - extraScroll, mScrollDuration, true, firstPos > mTargetPos);
                mLastSeenPos = firstPos;
                if (firstPos > mTargetPos) {
                    postOnAnimation(this);
                }
                break;
            }
        case MOVE_UP_BOUND:
            {
                final int lastViewIndex = getChildCount() - 2;
                if (lastViewIndex < 0) {
                    return;
                }
                final int lastPos = firstPos + lastViewIndex;
                if (lastPos == mLastSeenPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                final View lastView = getChildAt(lastViewIndex);
                final int lastViewHeight = lastView.getHeight();
                final int lastViewTop = lastView.getTop();
                final int lastViewPixelsShowing = listHeight - lastViewTop;
                final int extraScroll = Math.max(mListPadding.top, mExtraScroll);
                mLastSeenPos = lastPos;
                if (lastPos > mBoundPos) {
                    smoothScrollBy(-(lastViewPixelsShowing - extraScroll), mScrollDuration, true, true);
                    postOnAnimation(this);
                } else {
                    final int bottom = listHeight - extraScroll;
                    final int lastViewBottom = lastViewTop + lastViewHeight;
                    if (bottom > lastViewBottom) {
                        smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration, true, false);
                    } else {
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                break;
            }
        case MOVE_OFFSET:
            {
                if (mLastSeenPos == firstPos) {
                    // No new views, let things keep going.
                    postOnAnimation(this);
                    return;
                }
                mLastSeenPos = firstPos;
                final int childCount = getChildCount();
                if (childCount <= 0) {
                    return;
                }
                final int position = mTargetPos;
                final int lastPos = firstPos + childCount - 1;
                // Account for the visible ""portion"" of the first / last child when we estimate
                // how many screens we should travel to reach our target
                final View firstChild = getChildAt(0);
                final int firstChildHeight = firstChild.getHeight();
                final View lastChild = getChildAt(childCount - 1);
                final int lastChildHeight = lastChild.getHeight();
                final float firstPositionVisiblePart = (firstChildHeight == 0.0f) ? 1.0f : (float) (firstChildHeight + firstChild.getTop()) / firstChildHeight;
                final float lastPositionVisiblePart = (lastChildHeight == 0.0f) ? 1.0f : (float) (lastChildHeight + getHeight() - lastChild.getBottom()) / lastChildHeight;
                float viewTravelCount = 0;
                if (position < firstPos) {
                    viewTravelCount = firstPos - position + (1.0f - firstPositionVisiblePart) + 1;
                } else if (position > lastPos) {
                    viewTravelCount = position - lastPos + (1.0f - lastPositionVisiblePart);
                }
                // Estimate how many screens we should travel
                final float screenTravelCount = viewTravelCount / childCount;
                final float modifier = Math.min(Math.abs(screenTravelCount), 1.f);
                if (position < firstPos) {
                    final int distance = (int) (-getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true, true);
                    postOnAnimation(this);
                } else if (position > lastPos) {
                    final int distance = (int) (getHeight() * modifier);
                    final int duration = (int) (mScrollDuration * modifier);
                    smoothScrollBy(distance, duration, true, true);
                    postOnAnimation(this);
                } else {
                    // On-screen, just scroll.
                    final int targetTop = getChildAt(position - firstPos).getTop();
                    final int distance = targetTop - mOffsetFromTop;
                    final int duration = (int) (mScrollDuration * ((float) Math.abs(distance) / getHeight()));
                    smoothScrollBy(distance, duration, true, false);
                }
                break;
            }
        default:
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
516,<android.app.Activity: boolean isImmersive()>,28,29,<android.app.Activity: boolean isImmersive()>,<android.app.Activity: boolean isImmersive()>,0,"{
    try {
        return ActivityManager.getService().isImmersive(mToken);
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return ActivityTaskManager.getService().isImmersive(mToken);
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Bit indicating that this activity is ""immersive"" and should not be
 * interrupted by notifications if possible.
 *
 * This value is initially set by the manifest property
 * <code>android:immersive</code> but may be changed at runtime by
 * {@link #setImmersive}.
 *
 * @see #setImmersive(boolean)
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
","/**
 * Bit indicating that this activity is ""immersive"" and should not be
 * interrupted by notifications if possible.
 *
 * This value is initially set by the manifest property
 * <code>android:immersive</code> but may be changed at runtime by
 * {@link #setImmersive}.
 *
 * @see #setImmersive(boolean)
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The dependent API ActivityManager.getService().isImmersive(mToken) has been updated to ActivityTaskManager.getService().isImmersive(mToken) with just a change in the service class being used while the method signature remains the same. This is a change of type 5.,"No Compatibility Issue should arise from this change, as the method signature remains the same and it is expected that the new service class provides the same functionality with respect to the isImmersive() method. The handling of the RemoteException has not changed and the method still returns a boolean value. Therefore, CI is 0."
518,<android.hardware.camera2.params.StreamConfigurationMap: boolean equals(Object)>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: boolean equals(Object)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mDepthConfigurations, other.mDepthConfigurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}","{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mDepthConfigurations, other.mDepthConfigurations) && Arrays.equals(mDepthMinFrameDurations, other.mDepthMinFrameDurations) && Arrays.equals(mDepthStallDurations, other.mDepthStallDurations) && Arrays.equals(mDynamicDepthConfigurations, other.mDynamicDepthConfigurations) && Arrays.equals(mDynamicDepthMinFrameDurations, other.mDynamicDepthMinFrameDurations) && Arrays.equals(mDynamicDepthStallDurations, other.mDynamicDepthStallDurations) && Arrays.equals(mHeicConfigurations, other.mHeicConfigurations) && Arrays.equals(mHeicMinFrameDurations, other.mHeicMinFrameDurations) && Arrays.equals(mHeicStallDurations, other.mHeicStallDurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}",1,"/**
 * Check if this {@link StreamConfigurationMap} is equal to another
 * {@link StreamConfigurationMap}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link StreamConfigurationMap} is equal to another
 * {@link StreamConfigurationMap}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late version, additional arrays are being compared for equality, however, this does not affect the types of values returned nor the exceptions that may be thrown. Therefore, the code change type is 4.","The addition of more array comparisons in the equals method does not introduce a compatibility issue as it does not affect the return type, the value of returns in existing conditions, or introduce new exceptions. It simply extends the equality check to more fields, and the method still returns a boolean. Thus, there is no compatibility issue, and the CI type is 0."
519,<android.widget.TextView: boolean isInputMethodTarget()>,28,29,<android.widget.TextView: boolean isInputMethodTarget()>,<android.widget.TextView: boolean isInputMethodTarget()>,0,"{
    InputMethodManager imm = InputMethodManager.peekInstance();
    return imm != null && imm.isActive(this);
}","{
    InputMethodManager imm = getInputMethodManager();
    return imm != null && imm.isActive(this);
}",1,"/**
 * Returns whether this text view is a current input method target.  The
 * default implementation just checks with {@link InputMethodManager}.
 * @return True if the TextView is a current input method target; false otherwise.
 */
","/**
 * Returns whether this text view is a current input method target.  The
 * default implementation just checks with {@link InputMethodManager}.
 * @return True if the TextView is a current input method target; false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to obtain the instance of InputMethodManager has changed from InputMethodManager.peekInstance() to getInputMethodManager(), so the code change type is 5 (Dependent API changed).","Since there is no difference in the logic or control flow of the code apart from the change in the method used to obtain the InputMethodManager instance, and there are no changes in what the method returns or the exceptions it handles, there is no Compatibility Issue; although the method used to get the InputMethodManager instance has changed, it should still operate in the same way. Therefore, the CI type is 0 (No Compatibility Issue)."
520,<android.view.View: float getCameraDistance()>,28,29,<android.view.View: float getCameraDistance()>,<android.view.View: float getCameraDistance()>,0,"{
    final float dpi = mResources.getDisplayMetrics().densityDpi;
    return -(mRenderNode.getCameraDistance() * dpi);
}","{
    final float dpi = mResources.getDisplayMetrics().densityDpi;
    return mRenderNode.getCameraDistance() * dpi;
}",1,"/**
 * Gets the distance along the Z axis from the camera to this view.
 *
 * @see #setCameraDistance(float)
 *
 * @return The distance along the Z axis.
 */
","/**
 * Gets the distance along the Z axis from the camera to this view.
 *
 * @see #setCameraDistance(float)
 *
 * @return The distance along the Z axis.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement's sign has changed from negative to positive, so the type of code change is 1.","The modification in the return statement, from a negative to a positive value, means that the API will potentially return a different value. This constitutes a CI of type 1."
522,<android.bluetooth.le.ScanFilter: boolean equals(Object)>,28,29,<android.bluetooth.le.ScanFilter: boolean equals(Object)>,<android.bluetooth.le.ScanFilter: boolean equals(Object)>,0,"{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ScanFilter other = (ScanFilter) obj;
    return Objects.equals(mDeviceName, other.mDeviceName) && Objects.equals(mDeviceAddress, other.mDeviceAddress) && mManufacturerId == other.mManufacturerId && Objects.deepEquals(mManufacturerData, other.mManufacturerData) && Objects.deepEquals(mManufacturerDataMask, other.mManufacturerDataMask) && Objects.equals(mServiceDataUuid, other.mServiceDataUuid) && Objects.deepEquals(mServiceData, other.mServiceData) && Objects.deepEquals(mServiceDataMask, other.mServiceDataMask) && Objects.equals(mServiceUuid, other.mServiceUuid) && Objects.equals(mServiceUuidMask, other.mServiceUuidMask);
}","{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    ScanFilter other = (ScanFilter) obj;
    return Objects.equals(mDeviceName, other.mDeviceName) && Objects.equals(mDeviceAddress, other.mDeviceAddress) && mManufacturerId == other.mManufacturerId && Objects.deepEquals(mManufacturerData, other.mManufacturerData) && Objects.deepEquals(mManufacturerDataMask, other.mManufacturerDataMask) && Objects.equals(mServiceDataUuid, other.mServiceDataUuid) && Objects.deepEquals(mServiceData, other.mServiceData) && Objects.deepEquals(mServiceDataMask, other.mServiceDataMask) && Objects.equals(mServiceUuid, other.mServiceUuid) && Objects.equals(mServiceUuidMask, other.mServiceUuidMask) && Objects.equals(mServiceSolicitationUuid, other.mServiceSolicitationUuid) && Objects.equals(mServiceSolicitationUuidMask, other.mServiceSolicitationUuidMask);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation adds checks for `mServiceSolicitationUuid` and `mServiceSolicitationUuidMask`, which are missing in the early version, so the change involves additional return conditions (code change type 1,4).","The addition of new conditions in the equals comparison introduces a possibility for the method to return different results for objects that differ only in their `mServiceSolicitationUuid` and `mServiceSolicitationUuidMask` values. Therefore, it is a CI of type 1 caused by potential different return values."
523,"<android.app.Activity: boolean onPreparePanel(int,View,Menu)>",28,29,"<android.app.Activity: boolean onPreparePanel(int,View,Menu)>","<android.app.Activity: boolean onPreparePanel(int,View,Menu)>",0,"{
    if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
        boolean goforit = onPrepareOptionsMenu(menu);
        goforit |= mFragments.dispatchPrepareOptionsMenu(menu);
        return goforit;
    }
    return true;
}","{
    if (featureId == Window.FEATURE_OPTIONS_PANEL) {
        boolean goforit = onPrepareOptionsMenu(menu);
        goforit |= mFragments.dispatchPrepareOptionsMenu(menu);
        return goforit;
    }
    return true;
}",1,"/**
 * Default implementation of
 * {@link android.view.Window.Callback#onPreparePanel}
 * for activities.  This
 * calls through to the new {@link #onPrepareOptionsMenu} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
","/**
 * Default implementation of
 * {@link android.view.Window.Callback#onPreparePanel}
 * for activities.  This
 * calls through to the new {@link #onPrepareOptionsMenu} method for the
 * {@link android.view.Window#FEATURE_OPTIONS_PANEL}
 * panel, so that subclasses of
 * Activity don't need to deal with feature codes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition in the 'if' statement has changed by removing the 'menu != null' check but the rest of the code within the 'if' block and the final 'return true' statement remains the same, so the code change type is 3.","There is no CI because the logic of the method has not changed in a way that would affect the return value or the exceptions thrown by the method. If 'menu' is null, onPrepareOptionsMenu will be called as before, which should handle 'null' appropriately since it is possible for it to be called with 'null' in the original implementation. The change only bypasses an explicit null check, relying on internal null handling within the onPrepareOptionsMenu and dispatchPrepareOptionsMenu methods. If those methods are correctly handling 'null,' this should not introduce a change in behavior. Hence, there is no Compatibility Issue."
524,"<android.text.SpannableStringBuilder: int getTextRunCursor(int,int,int,int,int,Paint)>",28,29,"<android.text.SpannableStringBuilder: int getTextRunCursor(int,int,int,int,int,Paint)>","<android.text.SpannableStringBuilder: int getTextRunCursor(int,int,int,int,int,Paint)>",0,"{
    int ret;
    int contextLen = contextEnd - contextStart;
    if (contextEnd <= mGapStart) {
        ret = p.getTextRunCursor(mText, contextStart, contextLen, dir, offset, cursorOpt);
    } else if (contextStart >= mGapStart) {
        ret = p.getTextRunCursor(mText, contextStart + mGapLength, contextLen, dir, offset + mGapLength, cursorOpt) - mGapLength;
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        ret = p.getTextRunCursor(buf, 0, contextLen, dir, offset - contextStart, cursorOpt) + contextStart;
        TextUtils.recycle(buf);
    }
    return ret;
}","{
    return getTextRunCursor(contextStart, contextEnd, dir == 1, offset, cursorOpt, p);
}",1,"/**
 * Returns the next cursor position in the run.  This avoids placing the cursor between
 * surrogates, between characters that form conjuncts, between base characters and combining
 * marks, or within a reordering cluster.
 *
 * <p>The context is the shaping context for cursor movement, generally the bounds of the metric
 * span enclosing the cursor in the direction of movement.
 * <code>contextStart</code>, <code>contextEnd</code> and <code>offset</code> are relative to
 * the start of the string.</p>
 *
 * <p>If cursorOpt is CURSOR_AT and the offset is not a valid cursor position,
 * this returns -1.  Otherwise this will never return a value before contextStart or after
 * contextEnd.</p>
 *
 * @param contextStart the start index of the context
 * @param contextEnd the (non-inclusive) end index of the context
 * @param dir either DIRECTION_RTL or DIRECTION_LTR
 * @param offset the cursor position to move from
 * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,
 * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
 * CURSOR_AT_OR_BEFORE, or CURSOR_AT
 * @param p the Paint object that is requesting this information
 * @return the offset of the next position, or -1
 * @deprecated This is an internal method, refrain from using it in your code
 */
","/**
 * Returns the next cursor position in the run.  This avoids placing the cursor between
 * surrogates, between characters that form conjuncts, between base characters and combining
 * marks, or within a reordering cluster.
 *
 * <p>The context is the shaping context for cursor movement, generally the bounds of the metric
 * span enclosing the cursor in the direction of movement.
 * <code>contextStart</code>, <code>contextEnd</code> and <code>offset</code> are relative to
 * the start of the string.</p>
 *
 * <p>If cursorOpt is CURSOR_AT and the offset is not a valid cursor position,
 * this returns -1.  Otherwise this will never return a value before contextStart or after
 * contextEnd.</p>
 *
 * @param contextStart the start index of the context
 * @param contextEnd the (non-inclusive) end index of the context
 * @param dir 1 if the run is RTL, otherwise 0
 * @param offset the cursor position to move from
 * @param cursorOpt how to move the cursor, one of CURSOR_AFTER,
 * CURSOR_AT_OR_AFTER, CURSOR_BEFORE,
 * CURSOR_AT_OR_BEFORE, or CURSOR_AT
 * @param p the Paint object that is requesting this information
 * @return the offset of the next position, or -1
 * @deprecated This is an internal method, refrain from using it in your code
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The code change includes a replacement of the body of the method with a call to a different method, getTextRunCursor. This indicates a dependent API change, so the code change type is 1,5.","Since the implementation code has been changed to call a different method entirely, and the logic within the method is different, this leads to a potential change in the return value of the method. Therefore, the CI type is 1."
525,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,28,29,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,0,"{
    final WindowInsets result = new WindowInsets(this);
    result.mSystemWindowInsets = EMPTY_RECT;
    result.mSystemWindowInsetsConsumed = true;
    return result;
}","{
    return new WindowInsets(null, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this));
}",1,"/**
 * Returns a copy of this WindowInsets with the system window insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
","/**
 * Returns a copy of this WindowInsets with the system window insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The instantiation of WindowInsets in the return statement has changed and a direct modification was made on how the object is constructed, which indicates an 'Other statement changed' as the code construct is substantially different. Since these changes alter how the resulting object is initialized, the return type is also affected, thus 'Return statement changed' applies.","The changes in how the WindowInsets object is created and initialized can lead to the API returning a different object with potentially different internal states. The new instantiation pattern may result in different behaviors of the returned object, so a 'Compatibility Issue caused by potential different return values or types' is identified."
526,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,0,"{
    enforceSealed();
    return getNodeForAccessibilityId(mParentNodeId);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mParentNodeId);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method getNodeForAccessibilityId has an additional set of parameters in the late version (mConnectionId, mWindowId, mParentNodeId instead of just mParentNodeId), indicating a change in the dependent API, so the code change type is 5.","The dependent API has changed, which can potentially lead to a different return value because the method now considers additional parameters to retrieve the parent node, thus there's a compatibility issue of type 1."
527,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",28,29,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}","{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change from calling `callbackBinder.opComplete(token, 0)` to `callbackBinder.opCompleteForUser(getBackupUserId(), token, 0)`. This change indicates a dependent API change, and since it is a method call with a different method name and an additional parameter, the change type is 4,5.","This change should not lead to a Compatibility Issue since the change is within a try-catch block inside a finally block and it's related to the operation completion callback. The `opComplete` and `opCompleteForUser` methods are likely used to inform some other component that the operation is complete. The method signature change does not alter the behavior of the `doRestoreFile` method itself in terms of what it returns or the exceptions it throws as seen in the provided implementation. Therefore, no CI is expected from this change (pred_CI: 0)."
528,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,28,29,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,<android.content.ContentResolver: List<UriPermission> getOutgoingPersistedUriPermissions()>,0,"{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return UriGrantsManager.getService().getUriPermissions(mPackageName, false, /* incoming */
        true).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */
","/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"The method used to retrieve persisted URI permissions has been changed from ActivityManager.getService().getPersistedUriPermissions to UriGrantsManager.getService().getUriPermissions, and the parameters passed inside seem to have been adjusted accordingly. This indicates that a dependent API has changed, therefore, the code change type is 4,5.","Given that the implementation now relies on a different Service (`UriGrantsManager` instead of `ActivityManager`) and likely a different method for obtaining URI permissions, the return value could potentially differ due to this change in the underlying service and method being called. Consequently, the CI type is 1."
529,<android.os.PowerManager: int getLocationPowerSaveMode()>,28,29,<android.os.PowerManager: int getLocationPowerSaveMode()>,<android.os.PowerManager: int getLocationPowerSaveMode()>,0,"{
    final PowerSaveState powerSaveState = getPowerSaveState(ServiceType.GPS);
    if (!powerSaveState.globalBatterySaverEnabled) {
        return LOCATION_MODE_NO_CHANGE;
    }
    return powerSaveState.gpsMode;
}","{
    final PowerSaveState powerSaveState = getPowerSaveState(ServiceType.LOCATION);
    if (!powerSaveState.batterySaverEnabled) {
        return LOCATION_MODE_NO_CHANGE;
    }
    return powerSaveState.locationMode;
}",1,"/**
 * Returns how location features should behave when battery saver is on. When battery saver
 * is off, this will always return {@link #LOCATION_MODE_NO_CHANGE}.
 *
 * <p>This API is normally only useful for components that provide location features.
 *
 * @see #isPowerSaveMode()
 * @see #ACTION_POWER_SAVE_MODE_CHANGED
 */
","/**
 * Returns how location features should behave when battery saver is on. When battery saver
 * is off, this will always return {@link #LOCATION_MODE_NO_CHANGE}.
 *
 * <p>This API is normally only useful for components that provide location features.
 *
 * @see #isPowerSaveMode()
 * @see #ACTION_POWER_SAVE_MODE_CHANGED
 */
",-1,[@LocationPowerSaveMode],[@LocationPowerSaveMode],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement changed from `return powerSaveState.gpsMode;` to `return powerSaveState.locationMode;`, the control dependency changed as the condition is now checking a different field `(!powerSaveState.batterySaverEnabled)` instead of `(!powerSaveState.globalBatterySaverEnabled)`, and there is a change in the dependent API's parameter from `ServiceType.GPS` to `ServiceType.LOCATION`. The code change type is 1,3,5.","The changes in the return statement, condition check, and the dependent API parameter will make the API potentially return a different value. Hence, there is a compatibility issue caused by potential different return values or types, classified as type 1."
530,<android.view.ViewRootImpl.EarlyPostImeInputStage: int onProcess(QueuedInputEvent)>,28,29,<android.view.ViewRootImpl.EarlyPostImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.EarlyPostImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else {
        final int source = q.mEvent.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            return processPointerEvent(q);
        }
    }
    return FORWARD;
}","{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else if (q.mEvent instanceof MotionEvent) {
        return processMotionEvent(q);
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency has changed by replacing a condition that checks the event source for pointer events with an `instanceof MotionEvent` check. The return statement within the 'else' block is altered because the `processPointerEvent` method call has been replaced with `processMotionEvent`. This constitutes a change in both control dependency and return statement, so the code change type is 1,3.","The behavior of the method may change as a result of the modified control statement and the different method being called for processing motion events (`processMotionEvent` instead of `processPointerEvent`). This could lead to the API returning different values for motion events, and thus the CI type is 1."
531,"<android.app.Activity: void overridePendingTransition(int,int)>",28,29,"<android.app.Activity: void overridePendingTransition(int,int)>","<android.app.Activity: void overridePendingTransition(int,int)>",0,"{
    try {
        ActivityManager.getService().overridePendingTransition(mToken, getPackageName(), enterAnim, exitAnim);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityTaskManager.getService().overridePendingTransition(mToken, getPackageName(), enterAnim, exitAnim);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Call immediately after one of the flavors of {@link #startActivity(Intent)}
 * or {@link #finish} to specify an explicit transition animation to
 * perform next.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN} an alternative
 * to using this with starting activities is to supply the desired animation
 * information through a {@link ActivityOptions} bundle to
 * {@link #startActivity(Intent, Bundle)} or a related function.  This allows
 * you to specify a custom animation even when starting an activity from
 * outside the context of the current top activity.
 *
 * @param enterAnim A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitAnim A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 */
","/**
 * Call immediately after one of the flavors of {@link #startActivity(Intent)}
 * or {@link #finish} to specify an explicit transition animation to
 * perform next.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN} an alternative
 * to using this with starting activities is to supply the desired animation
 * information through a {@link ActivityOptions} bundle to
 * {@link #startActivity(Intent, Bundle)} or a related function.  This allows
 * you to specify a custom animation even when starting an activity from
 * outside the context of the current top activity.
 *
 * @param enterAnim A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitAnim A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API used within try block has changed from ActivityManager.getService() to ActivityTaskManager.getService(), so there's a change in the dependent API, making the change types 4 and 5.","However, there is no evident change in the behavior of the method since the try-catch block is intended to handle the same exception (RemoteException) and there are no changes in the return type or value or in exception handling. Therefore, no Compatibility Issue is detected, and the CI type is 0."
533,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getConnectedDevices()>,28,29,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothHealth: List<BluetoothDevice> getConnectedDevices()>,0,"{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedHealthDevices();
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    Log.e(TAG, ""getConnectedDevices(): BluetoothHealth is deprecated"");
    return new ArrayList<>();
}",1,"/**
 * Get connected devices for the health profile.
 *
 * <p> Return the set of devices which are in state {@link #STATE_CONNECTED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @return List of devices. The list will be empty on error.
 */
","/**
 * Get connected devices for the health profile.
 *
 * <p> Return the set of devices which are in state {@link #STATE_CONNECTED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @return List of devices. The list will be empty on error.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The early version of the implementation contains logic that checks for the service's availability and whether Bluetooth is enabled before attempting to retrieve connected devices, with exception handling for RemoteException. The late version has completely removed these checks and exception handling, simply logging a message and returning a new empty ArrayList. Therefore, the change type is 1.","This significant change in implementation from performing operations to retrieve connected devices to always returning an empty list will cause existing applications expecting a list of connected Bluetooth devices to receive an empty list instead, regardless of the actual state of connected devices. Thus, the change leads to a different return value, and the CI type is 1."
534,"<android.bluetooth.BluetoothHealth: boolean connectChannelToSource(BluetoothDevice,BluetoothHealthAppConfiguration)>",28,29,"<android.bluetooth.BluetoothHealth: boolean connectChannelToSource(BluetoothDevice,BluetoothHealthAppConfiguration)>","<android.bluetooth.BluetoothHealth: boolean connectChannelToSource(BluetoothDevice,BluetoothHealthAppConfiguration)>",0,"{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.connectChannelToSource(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}","{
    Log.e(TAG, ""connectChannelToSource(): BluetoothHealth is deprecated"");
    return false;
}",1,"/**
 * Connect to a health device which has the {@link #SOURCE_ROLE}.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using {@link
 * #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @return If true, the callback associated with the application config will be called.
 */
","/**
 * Connect to a health device which has the {@link #SOURCE_ROLE}.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using {@link
 * #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @return If true, the callback associated with the application config will be called.
 *
 * @deprecated Health Device Profile (HDP) and MCAP protocol are no longer used. New
 * apps should use Bluetooth Low Energy based solutions such as {@link BluetoothGatt},
 * {@link BluetoothAdapter#listenUsingL2capChannel()(int)}, or
 * {@link BluetoothDevice#createL2capChannel(int)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The entire implementation has been simplified and now always logs that BluetoothHealth is deprecated and returns false. The control flow and the dependent service API call have been removed, so the code change types are 1,4.","Given the radical change where it no longer attempts to connect and directly returns false, the behavior of the API has changed in a way that will potentially return different values to any calling code and may not work as expected, thus there is a compatibility issue caused by potential different return values, CI type 1."
535,<android.app.NotificationManager: List<NotificationChannel> getNotificationChannels()>,28,29,<android.app.NotificationManager: List<NotificationChannel> getNotificationChannels()>,<android.app.NotificationManager: List<NotificationChannel> getNotificationChannels()>,0,"{
    INotificationManager service = getService();
    try {
        return service.getNotificationChannels(mContext.getPackageName()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INotificationManager service = getService();
    try {
        return service.getNotificationChannels(mContext.getOpPackageName(), mContext.getPackageName(), mContext.getUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns all notification channels belonging to the calling package.
 */
","/**
 * Returns all notification channels belonging to the calling package.
 *
 * <p>Approved notification delegates (see {@link #canNotifyAsPackage(String)}) can query
 * notification channels belonging to packages they are the delegate for. To do so, call this
 * method from a context created for that package (see
 * {@link Context#createPackageContext(String, int)}).</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation now calls a different version of the `getNotificationChannels` method with additional parameters: `mContext.getOpPackageName()` and `mContext.getUserId()`. This indicates a change in the dependent API, so the code change type is 5.","As the change is in the parameters of a method call, but the behavior and the return type of the `getNotificationChannels` API do not seem to be altered (assuming the overloaded `getNotificationChannels` method invoked in the late version maintains the same contract as the one in the early version), there is no direct indication of a Compatibility Issue. Therefore, the CI type is 0."
536,<android.util.SparseArray: void removeAt(int)>,28,29,<android.util.SparseArray: void removeAt(int)>,<android.util.SparseArray: void removeAt(int)>,0,"{
    if (mValues[index] != DELETED) {
        mValues[index] = DELETED;
        mGarbage = true;
    }
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mValues[index] != DELETED) {
        mValues[index] = DELETED;
        mGarbage = true;
    }
}",1,"/**
 * Removes the mapping at the specified index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>,
 * the behavior is undefined.</p>
 */
","/**
 * Removes the mapping at the specified index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>,
 * the behavior is undefined for apps targeting {@link android.os.Build.VERSION_CODES#P} and
 * earlier, and an {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late version introduces a new conditional check that throws an ArrayIndexOutOfBoundsException, and an if control statement has been added, causing the change types to be 2,3.","The introduction of a new exception-throwing statement (ArrayIndexOutOfBoundsException) in certain conditions (index >= mSize) constitutes a potential change in the exceptions thrown by the method. Therefore, the CI type is 2."
538,<android.content.ContentProviderResult: String toString()>,28,29,<android.content.ContentProviderResult: String toString()>,<android.content.ContentProviderResult: String toString()>,0,"{
    if (uri != null) {
        return ""ContentProviderResult(uri="" + uri.toString() + "")"";
    }
    return ""ContentProviderResult(count="" + count + "")"";
}","{
    final StringBuilder sb = new StringBuilder(""ContentProviderResult("");
    if (uri != null) {
        sb.append(""uri="" + uri + "" "");
    }
    if (count != null) {
        sb.append(""count="" + count + "" "");
    }
    if (uri != null) {
        sb.append(""failure="" + failure + "" "");
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation changes the entire structure of the toString method by using StringBuilder and by adding an extra if condition for a new field 'failure'. It also changes the way 'uri' and 'count' are appended to the result, as well as modifying the output format slightly with appending spaces and removing the last space character. Therefore the change types are 1 and 4.","Even though the overall intent of the function remains the same, the logic modifications will lead to a different output String from the toString method, so there is a Compatibility Issue of type 1."
539,<android.hardware.camera2.impl.CameraDeviceImpl.FrameNumberTracker: long getCompletedReprocessFrameNumber()>,28,29,<android.hardware.camera2.impl.CameraDeviceImpl.FrameNumberTracker: long getCompletedReprocessFrameNumber()>,<android.hardware.camera2.impl.CameraDeviceImpl.FrameNumberTracker: long getCompletedReprocessFrameNumber()>,0,"{
    return mCompletedReprocessFrameNumber;
}","{
    return mCompletedFrameNumber[CaptureRequest.REQUEST_TYPE_REPROCESS];
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The internal implementation of `getCompletedReprocessFrameNumber()` has changed from directly returning `mCompletedReprocessFrameNumber` to now referencing an array `mCompletedFrameNumber[CaptureRequest.REQUEST_TYPE_REPROCESS]`. There's no change in control flow logic, no exception handling change, but there's a change in the data retrieval mechanism which implies a dependent API change and other changes, so the change type is 4,5.","The return value now comes from a different source (`mCompletedFrameNumber` array vs. a direct variable `mCompletedReprocessFrameNumber`), and this can potentially return a different value if the underlying array has different values than the former variable. Hence, the CI type is 1 due to the potential difference in return values."
540,<android.service.quicksettings.TileService.H: void handleMessage(Message)>,28,29,<android.service.quicksettings.TileService.H: void handleMessage(Message)>,<android.service.quicksettings.TileService.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_TILE_ADDED:
            TileService.this.onTileAdded();
            break;
        case MSG_TILE_REMOVED:
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            TileService.this.onTileRemoved();
            break;
        case MSG_STOP_LISTENING:
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            break;
        case MSG_START_LISTENING:
            if (!mListening) {
                mListening = true;
                TileService.this.onStartListening();
            }
            break;
        case MSG_TILE_CLICKED:
            mToken = (IBinder) msg.obj;
            TileService.this.onClick();
            break;
        case MSG_UNLOCK_COMPLETE:
            if (mUnlockRunnable != null) {
                mUnlockRunnable.run();
            }
            break;
        case MSG_START_SUCCESS:
            try {
                mService.onStartSuccessful(mTileToken);
            } catch (RemoteException e) {
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_TILE_ADDED:
            if (DEBUG)
                logMessage(""MSG_TILE_ADDED"");
            TileService.this.onTileAdded();
            break;
        case MSG_TILE_REMOVED:
            if (DEBUG)
                logMessage(""MSG_TILE_REMOVED"");
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            TileService.this.onTileRemoved();
            break;
        case MSG_STOP_LISTENING:
            if (DEBUG)
                logMessage(""MSG_STOP_LISTENING"");
            if (mListening) {
                mListening = false;
                TileService.this.onStopListening();
            }
            break;
        case MSG_START_LISTENING:
            if (DEBUG)
                logMessage(""MSG_START_LISTENING"");
            if (!mListening) {
                mListening = true;
                TileService.this.onStartListening();
            }
            break;
        case MSG_TILE_CLICKED:
            if (DEBUG)
                logMessage(""MSG_TILE_CLICKED"");
            mToken = (IBinder) msg.obj;
            TileService.this.onClick();
            break;
        case MSG_UNLOCK_COMPLETE:
            if (DEBUG)
                logMessage(""MSG_UNLOCK_COMPLETE"");
            if (mUnlockRunnable != null) {
                mUnlockRunnable.run();
            }
            break;
        case MSG_START_SUCCESS:
            if (DEBUG)
                logMessage(""MSG_START_SUCCESS"");
            try {
                mService.onStartSuccessful(mTileToken);
            } catch (RemoteException e) {
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Logging statements are added for each case of the `switch` statement, but these logs are conditionally executed based on a `DEBUG` flag and do not alter the flow of execution or the behavior of the method, so the code change type is 4.","The new logging statements are only executed if the `DEBUG` flag is set to `true` and they are not changing the method's functional behavior. Even though the logging statements have been added, they do not affect what the method returns or the exceptions it might throw. Therefore, there is no Compatibility Issue."
542,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>",28,29,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFinished();
    } catch (Exception e) {
        Log.d(TAG, ""onRestoreFinished ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw e;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFinished();
    } catch (Exception e) {
        Log.d(TAG, ""onRestoreFinished ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw e;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method invoked in the 'try' block inside the 'finally' block is changed from callbackBinder.opComplete(token, 0) to callbackBinder.opCompleteForUser(getBackupUserId(), token, 0), which means there is a change in how the operation completion is reported. This is a type of ""Other statement changed"" because it doesn't involve return, exception, or control structures, and it's a ""Dependent API changed"" because the method invoked (part of a dependent service API) has been modified in its signature or behavior.","There is no Compatibility Issue since this change does not affect the behavior of the API with respect to how it handles return values or exceptions at this level of abstraction. The method is void, meaning no return value could change, and the exception handling logic remains the same. The underlying system callback (the dependent API) is changed but this is abstracted away from the caller of doRestoreFinished()."
543,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,28,29,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mWindowId, mSourceNodeId, action, null);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mWindowId, mSourceNodeId, action, null);
}",1,"/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method signature of `canPerformRequestOverConnection` changed from `canPerformRequestOverConnection(mSourceNodeId)` to `canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)`. This indicates that the dependent API has changed, hence code change type is 4,5.","Despite the change in the dependent method signature, there is no change in the behavior of the `performAction` method with respect to what it returns or the exceptions it might throw. The method still returns `false` if the request cannot be performed over the connection and delegates the actual action performance to the `AccessibilityInteractionClient`. Therefore, there is no Compatibility Issue in this change, leading to pred_CI being 0."
544,<android.widget.AutoCompleteTextView: void doBeforeTextChanged()>,28,29,<android.widget.AutoCompleteTextView: void doBeforeTextChanged()>,<android.widget.AutoCompleteTextView: void doBeforeTextChanged()>,0,"{
    if (mBlockCompletion)
        return;
    // when text is changed, inserted or deleted, we attempt to show
    // the drop down
    mOpenBefore = isPopupShowing();
    if (DEBUG)
        Log.v(TAG, ""before text changed: open="" + mOpenBefore);
}","{
    mAutoCompleteTextWatcher.beforeTextChanged(null, 0, 0, 0);
}",1,,"/**
 * This function is deprecated. Please use {@link #refreshAutoCompleteResults} instead.
 * Note: Remove {@link #mAutoCompleteTextWatcher} after removing this function.
 */
",-1,,[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)],-1,-1,-1,-1,-1,-1,"1,4",1,"The method body has been completely replaced with a call to mAutoCompleteTextWatcher.beforeTextChanged(null, 0, 0, 0), which is a different implementation than the early version. This is neither a control structure change nor an exception handling change. Early version set some flags and logged a message based on debug state. Now, the implementation directly delegates to another method which we can't see the internals of, so it's categorized as change type 1 because it changes return behavior implicitly (as the method is void, it changes side effects), and 4 since it's an other statement changed.","This change could lead to different behavior at runtime because of the different execution path taken by the method's invocation. Since the method no longer manipulates member variables and instead delegates to a watcher, this could cause a change in the functionality of how the AutoCompleteTextView behaves before text is changed. It's labeled with CI type 1 because of potential different return values or side effects."
545,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,28,29,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,0,"{
    Preconditions.checkNotNull(operations, ""operations"");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    return applyBatch(mAuthority, operations);
}",1,"/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
","/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation handles exception and remote operations explicitly, while the late implementation directly returns the result of applyBatch(mAuthority, operations), showing the use of a different applyBatch method (presumably an overloaded one) that doesn't include exception handling in the API usage itself. Therefore, the code change type is 1,5 because a return statement was changed and a dependent API was changed.","Compatibility Issue is present due to the potential different return value. The early version might catch the DeadObjectException, execute the block of code under catch, and then throw it, which affects the return value. On the other hand, the late version doesnt seem to manage any exceptions, therefore potentially throwing a different exception to the caller. The new implementation could defer the exception handling to the newly referenced applyBatch variant, making the exception handling and flow different, leading to a CI of type 1."
546,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionModified(int,int,TextClassification,TextSelection)>",28,29,"<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionModified(int,int,TextClassification,TextSelection)>","<android.widget.SelectionActionModeHelper.SelectionMetricsLogger: void logSelectionModified(int,int,TextClassification,TextSelection)>",0,"{
    try {
        if (hasActiveClassificationSession()) {
            Preconditions.checkArgumentInRange(start, 0, mText.length(), ""start"");
            Preconditions.checkArgumentInRange(end, start, mText.length(), ""end"");
            int[] wordIndices = getWordDelta(start, end);
            if (selection != null) {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1], selection));
            } else if (classification != null) {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1], classification));
            } else {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1]));
            }
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.e(LOG_TAG, """" + e.getMessage(), e);
    }
}","{
    try {
        if (hasActiveClassificationSession()) {
            Preconditions.checkArgumentInRange(start, 0, mText.length(), ""start"");
            Preconditions.checkArgumentInRange(end, start, mText.length(), ""end"");
            int[] wordIndices = getWordDelta(start, end);
            if (selection != null) {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1], selection));
            } else if (classification != null) {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1], classification));
            } else {
                mClassificationSession.onSelectionEvent(SelectionEvent.createSelectionModifiedEvent(wordIndices[0], wordIndices[1]));
            }
            maybeGenerateTranslateViewEvent(classification);
        }
    } catch (Exception e) {
        // Avoid crashes due to logging.
        Log.e(LOG_TAG, """" + e.getMessage(), e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only addition to the late implementation is the call to the `maybeGenerateTranslateViewEvent` method which does not affect the return statement or exception handling. Therefore, the change is an 'Other statement changed' rather than a 'Control dependency change'. Since the behavior of logSelectionModified method is not predicated on the outcome of maybeGenerateTranslateViewEvent directly, there's no indication that this addition would result in any change to the return value or exception throwing behavior.","There is no indication that the change will cause the API to return a different variable or throw an exception differently, so there is no compatibility issue here."
547,<android.inputmethodservice.InputMethodService.InputMethodImpl: void attachToken(IBinder)>,28,29,<android.inputmethodservice.InputMethodService.InputMethodImpl: void attachToken(IBinder)>,<android.inputmethodservice.InputMethodService.InputMethodImpl: void attachToken(IBinder)>,0,"{
    if (mToken == null) {
        mToken = token;
        mWindow.setToken(token);
    }
}","{
    if (mToken != null) {
        throw new IllegalStateException(""attachToken() must be called at most once. token="" + token);
    }
    mToken = token;
    mWindow.setToken(token);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"2,3",2,"The early version does not throw an exception, while the late version introduces a new 'throw' statement when mToken is not null, and the condition in the 'if' statement has changed. Hence, the change type is 2,3.","The late version of the API can potentially throw a new IllegalStateException when mToken is not null, which is a different exception behavior from the early version that never threw an exception but quietly skipped the assignment. Therefore, the CI type is 2."
549,<com.android.server.backup.PermissionBackupHelper: byte[] getBackupPayload(String)>,28,29,<com.android.server.backup.PermissionBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.PermissionBackupHelper: byte[] getBackupPayload(String)>,0,"{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                return pm.getPermissionGrantBackup(UserHandle.USER_SYSTEM);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key);
    }
    return null;
}","{
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                return mPermissionManager.backupRuntimePermissions(mUser);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key);
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method getPermissionGrantBackup(UserHandle.USER_SYSTEM) from AppGlobals.getPackageManager() (the dependent API) has been replaced with mPermissionManager.backupRuntimePermissions(mUser). There are no changes in control structures or exception handling, so the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","Although there's a change in how permissions are being backed up, we don't see a potential Compatibility Issue because the method is expected to return the same type of data (a byte array of backed-up permissions) and handle exceptions in the same way. The change in implementation details does not inherently mean a different behavior in terms of API's output or exceptions as seen from a caller perspective, provided that the new mPermissionManager.backupRuntimePermissions(mUser) is functionally equivalent to pm.getPermissionGrantBackup(UserHandle.USER_SYSTEM)."
551,<android.view.View: void setAutofillId(AutofillId)>,28,29,<android.view.View: void setAutofillId(AutofillId)>,<android.view.View: void setAutofillId(AutofillId)>,0,"{
    // TODO(b/37566627): add unit / CTS test for all possible combinations below
    if (android.view.autofill.Helper.sVerbose) {
        Log.v(VIEW_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id);
    }
    if (isAttachedToWindow()) {
        throw new IllegalStateException(""Cannot set autofill id when view is attached"");
    }
    if (id != null && id.isVirtual()) {
        throw new IllegalStateException(""Cannot set autofill id assigned to virtual views"");
    }
    if (id == null && (mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) == 0) {
        // Ignore reset because it was never explicitly set before.
        return;
    }
    mAutofillId = id;
    if (id != null) {
        mAutofillViewId = id.getViewId();
        mPrivateFlags3 |= PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    } else {
        mAutofillViewId = NO_ID;
        mPrivateFlags3 &= ~PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    }
}","{
    // TODO(b/37566627): add unit / CTS test for all possible combinations below
    if (Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)) {
        Log.v(AUTOFILL_LOG_TAG, ""setAutofill(): from "" + mAutofillId + "" to "" + id);
    }
    if (isAttachedToWindow()) {
        throw new IllegalStateException(""Cannot set autofill id when view is attached"");
    }
    if (id != null && !id.isNonVirtual()) {
        throw new IllegalStateException(""Cannot set autofill id assigned to virtual views"");
    }
    if (id == null && (mPrivateFlags3 & PFLAG3_AUTOFILLID_EXPLICITLY_SET) == 0) {
        // Ignore reset because it was never explicitly set before.
        return;
    }
    mAutofillId = id;
    if (id != null) {
        mAutofillViewId = id.getViewId();
        mPrivateFlags3 |= PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    } else {
        mAutofillViewId = NO_ID;
        mPrivateFlags3 &= ~PFLAG3_AUTOFILLID_EXPLICITLY_SET;
    }
}",1,"/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
","/**
 * Sets the unique, logical identifier of this view in the activity, for autofill purposes.
 *
 * <p>The autofill id is created on demand, and this method should only be called when a view is
 * reused after {@link #dispatchProvideAutofillStructure(ViewStructure, int)} is called, as
 * that method creates a snapshot of the view that is passed along to the autofill service.
 *
 * <p>This method is typically used when view subtrees are recycled to represent different
 * content* &mdash;in this case, the autofill id can be saved before the view content is swapped
 * out, and restored later when it's swapped back in. For example:
 *
 * <pre>
 * EditText reusableView = ...;
 * ViewGroup parentView = ...;
 * AutofillManager afm = ...;
 *
 * // Swap out the view and change its contents
 * AutofillId oldId = reusableView.getAutofillId();
 * CharSequence oldText = reusableView.getText();
 * parentView.removeView(reusableView);
 * AutofillId newId = afm.getNextAutofillId();
 * reusableView.setText(""New I am"");
 * reusableView.setAutofillId(newId);
 * parentView.addView(reusableView);
 *
 * // Later, swap the old content back in
 * parentView.removeView(reusableView);
 * reusableView.setAutofillId(oldId);
 * reusableView.setText(oldText);
 * parentView.addView(reusableView);
 * </pre>
 *
 * @param id an autofill ID that is unique in the {@link android.app.Activity} hosting the view,
 * or {@code null} to reset it. Usually it's an id previously allocated to another view (and
 * obtained through {@link #getAutofillId()}), or a new value obtained through
 * {@link AutofillManager#getNextAutofillId()}.
 *
 * @throws IllegalStateException if the view is already {@link #isAttachedToWindow() attached to
 * a window}.
 *
 * @throws IllegalArgumentException if the id is an autofill id associated with a virtual view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The method of checking log verbosity has changed from `android.view.autofill.Helper.sVerbose` to `Log.isLoggable(AUTOFILL_LOG_TAG, Log.VERBOSE)`, and also the exception checking from `id.isVirtual()` to `!id.isNonVirtual()`, which is an exception handling statement changed and other change, so the code change types are 2 and 4.","The change in the exception throwing conditions (`id.isVirtual()` to `!id.isNonVirtual()`) could lead to a different behavior regarding which exceptions are thrown under certain conditions. Therefore, this can lead to a Compatibility Issue by changing the exception that might be thrown, type 2."
552,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",28,29,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodClient.getStartInputReason(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> startInputInner(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" mServedView="" + dumpViewInfo(mServedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res == null) {
                Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodClient.getStartInputReason(startInputReason) + "" editorInfo="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
                return false;
            }
            if (res.id != null) {
                setInputChannelLocked(res.channel);
                mBindSequence = res.sequence;
                mCurMethod = res.method;
                mCurId = res.id;
                mNextUserActionNotificationSequenceNumber = res.userActionNotificationSequenceNumber;
            } else if (res.channel != null && res.channel != mCurChannel) {
                res.channel.dispose();
            }
            switch(res.result) {
                case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                    mRestartOnNextWindowFocus = true;
                    break;
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodDebug.startInputReasonToString(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    if (windowGainingFocus == null) {
        windowGainingFocus = view.getWindowToken();
        if (windowGainingFocus == null) {
            Log.e(TAG, ""ABORT input: ServedView must be attached to a Window"");
            return false;
        }
        startInputFlags |= StartInputFlags.VIEW_HAS_FOCUS;
        if (view.onCheckIsTextEditor()) {
            startInputFlags |= StartInputFlags.IS_TEXT_EDITOR;
        }
        softInputMode = view.getViewRootImpl().mWindowAttributes.softInputMode;
        windowFlags = view.getViewRootImpl().mWindowAttributes.flags;
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> startInputInner(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" mServedView="" + dumpViewInfo(mServedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            startInputFlags |= StartInputFlags.INITIAL_CONNECTION;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        maybeCallServedViewChangedLocked(tba);
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, startInputFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res == null) {
                Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodDebug.startInputReasonToString(startInputReason) + "" editorInfo="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
                return false;
            }
            mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
            if (res.id != null) {
                setInputChannelLocked(res.channel);
                mBindSequence = res.sequence;
                mCurMethod = res.method;
                mCurId = res.id;
            } else if (res.channel != null && res.channel != mCurChannel) {
                res.channel.dispose();
            }
            switch(res.result) {
                case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                    mRestartOnNextWindowFocus = true;
                    break;
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
553,<android.os.ParcelFileDescriptor: int detachFd()>,28,29,<android.os.ParcelFileDescriptor: int detachFd()>,<android.os.ParcelFileDescriptor: int detachFd()>,0,"{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        final int fd = getFd();
        mFd.setInt$(-1);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}","{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        int fd = IoUtils.acquireRawFd(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}",1,"/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */
","/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The code change includes replacing 'final int fd = getFd(); mFd.setInt$(-1);' with 'int fd = IoUtils.acquireRawFd(mFd);' and removing 'mFd.setInt$(-1);', which indicates a change in how the file descriptor is detached and therefore a change in the control dependency and other statements, as well as relying on a potentially altered dependent API (IoUtils.acquireRawFd). Hence, the code change type is 3,4,5.","Since the file descriptor detachment mechanism has been altered by replacing getFd() with IoUtils.acquireRawFd(), this could cause the API to potentially return a different file descriptor, resulting in a CI of type 1."
556,<android.service.notification.ZenModeConfig.EventInfo: boolean equals(Object)>,28,29,<android.service.notification.ZenModeConfig.EventInfo: boolean equals(Object)>,<android.service.notification.ZenModeConfig.EventInfo: boolean equals(Object)>,0,"{
    if (!(o instanceof EventInfo))
        return false;
    final EventInfo other = (EventInfo) o;
    return userId == other.userId && Objects.equals(calendar, other.calendar) && reply == other.reply;
}","{
    if (!(o instanceof EventInfo))
        return false;
    final EventInfo other = (EventInfo) o;
    return userId == other.userId && Objects.equals(calName, other.calName) && reply == other.reply && Objects.equals(calendarId, other.calendarId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been changed as it includes checks for additional fields (calName, calendarId) in the comparison, and the field in the comparison has been changed from calendar to calName, so the code change types are 1,4.","The adjustments to the logic in the return statement could lead to different outcomes (true or false), depending on the instance's state being compared. Therefore, the CI type is 1."
557,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,28,29,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,0,"{
    try {
        mPfd.close();
    } finally {
        super.close();
    }
}","{
    try {
        super.close();
    } finally {
        mPfd.close();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The order of method calls within 'try' and 'finally' blocks has been swapped; 'mPfd.close()' and 'super.close()' invocations have changed places. This alteration is classified as 'Other statement changed' (code 4).,"There is no Compatibility Issue as the order of closing 'mPfd' and 'super' does not affect the external behavior of the 'close' method from the perspective of the API contract. Both are required to be called, and they are both called in either implementation, so there is no difference in terms of the API's functionality or the exceptions it might throw."
558,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",28,29,"<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>","<android.nfc.NfcAdapter: void setNdefPushMessageCallback(CreateNdefMessageCallback,Activity,Activity)>",0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(activity, callback, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessageCallback(a, callback, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setNdefPushMessageCallback(activity, callback, 0);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setNdefPushMessageCallback(a, callback, 0);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessageCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Set a callback that dynamically generates NDEF messages to send using Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the NDEF message callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>Only one NDEF message can be pushed by the currently resumed activity.
 * If both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback} are set, then
 * the callback will take priority.
 *
 * <p>If neither {@link #setNdefPushMessage} or
 * {@link #setNdefPushMessageCallback} have been called for your activity, then
 * the Android OS may choose to send a default NDEF message on your behalf,
 * such as a URI for your application.
 *
 * <p>If {@link #setNdefPushMessage} is called with a null NDEF message,
 * and/or {@link #setNdefPushMessageCallback} is called with a null callback,
 * then NDEF push will be completely disabled for the specified activity(s).
 * This also disables any default NDEF message the Android OS would have
 * otherwise sent on your behalf for those activity(s).
 *
 * <p>If you want to prevent the Android OS from sending default NDEF
 * messages completely (for all activities), you can include a
 * {@code <meta-data>} element inside the {@code <application>}
 * element of your AndroidManifest.xml file, like this:
 * <pre>
 * &lt;application ...>
 * &lt;meta-data android:name=""android.nfc.disable_beam_default""
 * android:value=""true"" />
 * &lt;/application></pre>
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setNdefPushMessageCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 * <p class=""note"">For sending large content such as pictures and songs,
 * consider using {@link #setBeamPushUris}, which switches to alternate transports
 * such as Bluetooth to achieve a fast transfer rate.
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated this feature is deprecated. File sharing can work using other technology like
 * Bluetooth.
 */
",-1,,[@java.lang.Deprecated],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The control flow has changed with the addition of a new conditional check `if (!sHasBeamFeature)` with a return statement, and another condition in the synchronized block. So, the change is classified as a control dependency change (3), and the addition of the return statement also qualifies it as a return statement changed (1). Additionally, a deprecation annotation has been added in the late version (4).","The introduction of a return statement inside the synchronized block could lead to the method returning earlier than it did in the earlier version, thus a different behavior in regards to the returned value is possible, which means there's a Compatibility Issue related to different return values (1). The new condition check does not affect exception handling, so it doesn't introduce a Compatibility Issue through different exceptions (2). However, due to the `UnsupportedOperationException` already existing in the early version, and now an additional early return possibility in the new version, the late version may not necessarily throw an exception where the early version would have, this could be seen as a potential Compatibility Issue in exception handling as well (2)."
559,<android.view.DisplayCutout: List<Rect> getBoundingRects()>,28,29,<android.view.DisplayCutout: List<Rect> getBoundingRects()>,<android.view.DisplayCutout: List<Rect> getBoundingRects()>,0,"{
    List<Rect> result = new ArrayList<>();
    Region bounds = Region.obtain();
    // top
    bounds.set(mBounds);
    bounds.op(0, 0, Integer.MAX_VALUE, getSafeInsetTop(), Region.Op.INTERSECT);
    if (!bounds.isEmpty()) {
        result.add(bounds.getBounds());
    }
    // left
    bounds.set(mBounds);
    bounds.op(0, 0, getSafeInsetLeft(), Integer.MAX_VALUE, Region.Op.INTERSECT);
    if (!bounds.isEmpty()) {
        result.add(bounds.getBounds());
    }
    // right & bottom
    bounds.set(mBounds);
    bounds.op(getSafeInsetLeft() + 1, getSafeInsetTop() + 1, Integer.MAX_VALUE, Integer.MAX_VALUE, Region.Op.INTERSECT);
    if (!bounds.isEmpty()) {
        result.add(bounds.getBounds());
    }
    bounds.recycle();
    return result;
}","{
    List<Rect> result = new ArrayList<>();
    for (Rect bound : getBoundingRectsAll()) {
        if (!bound.isEmpty()) {
            result.add(new Rect(bound));
        }
    }
    return result;
}",1,"/**
 * Returns a list of {@code Rect}s, each of which is the bounding rectangle for a non-functional
 * area on the display.
 *
 * There will be at most one non-functional area per short edge of the device, and none on
 * the long edges.
 *
 * @return a list of bounding {@code Rect}s, one for each display cutout area.
 */
","/**
 * Returns a list of {@code Rect}s, each of which is the bounding rectangle for a non-functional
 * area on the display.
 *
 * There will be at most one non-functional area per short edge of the device, and none on
 * the long edges.
 *
 * @return a list of bounding {@code Rect}s, one for each display cutout area. No empty Rect is
 * returned.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed to use getBoundingRectsAll() instead of calculating the bounding rectangles manually. Additionally, the return statement has changed because it is now based on a different method of collecting the bounding rectangles. Therefore, the code change types are 1 and 5.","Because the method of obtaining the bounding rectangles has changed, which inherently means that the late version of the API could return a different list of Rect objects, there is a potential for different return values. Therefore, the CI type is 1."
561,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",28,29,"<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>","<android.content.ContentResolver: int update(Uri,ContentValues,String,String[])>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        if (mWrapped != null)
            return mWrapped.update(uri, values, where, selectionArgs);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
","/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The code change includes a control dependency change with the addition of a try-catch block around a call to ""mWrapped.update"", which did not exist in the early version. Other changes include updates to exception handling resulting in different return values (-1 in the early version versus 0 in the late version for a RemoteException), and other statement changes such as the addition of a check for ""mWrapped"" and its associated return statement. Thus, the change type corresponds to 1,3,4.","There's a potential Compatibility Issue caused by both different return values or types and different exception handlings. A RemoteException now results in a return of 0 rather than -1. Additionally, there is a new execution path where ""mWrapped.update"" can be called and its value directly returned, which could be different from the original implementation's returned value. The CI types are therefore 1,2."
562,<android.widget.TextView: void setEnabled(boolean)>,28,29,<android.widget.TextView: void setEnabled(boolean)>,<android.widget.TextView: void setEnabled(boolean)>,0,"{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
    if (enabled) {
        // Make sure IME is updated with current editor info.
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null)
            imm.restartInput(this);
    }
    // Will change text color
    if (mEditor != null) {
        mEditor.invalidateTextDisplayList();
        mEditor.prepareCursorControllers();
        // start or stop the cursor blinking as appropriate
        mEditor.makeBlink();
    }
}","{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = getInputMethodManager();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
    if (enabled) {
        // Make sure IME is updated with current editor info.
        InputMethodManager imm = getInputMethodManager();
        if (imm != null)
            imm.restartInput(this);
    }
    // Will change text color
    if (mEditor != null) {
        mEditor.invalidateTextDisplayList();
        mEditor.prepareCursorControllers();
        // start or stop the cursor blinking as appropriate
        mEditor.makeBlink();
    }
}",1,,,-1,"[@android.view.RemotableViewMethod, @Override]","[@android.view.RemotableViewMethod, @Override]",-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from using a method 'InputMethodManager.peekInstance()' to another method 'getInputMethodManager()'. Although the method's name has changed, this is a call to acquire an instance of InputMethodManager. Since there's no information to suggest that the behavior or return type of 'getInputMethodManager()' has changed compared to 'InputMethodManager.peekInstance()', the change belongs only to the 'Other statement changed' category (4). It is also a 'Dependent API changed' (5) because the method used to acquire the InputMethodManager instance has changed.","Even with the change from 'InputMethodManager.peekInstance()' to 'getInputMethodManager()', if the returned 'InputMethodManager' object behaves the same way, it would not cause a Compatibility Issue. There is no change in the return statement or exception handling that could lead to different behavior. Therefore, the Compatibility Issue is classified as 0 (No Compatibility Issue)."
563,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",28,29,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    mImm.setImeWindowStatus(mToken, mStartInputToken, mapToImeWindowStatus(isInputViewShown()), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    final boolean wasVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        if (mIsPreRendered) {
            if (DEBUG) {
                Log.v(TAG, ""Making IME window visible"");
            }
            applyVisibilityInInsetsConsumer(true);
            onPreRenderedWindowVisibilityChanged(true);
        } else {
            showWindow(true);
        }
    }
    // If user uses hard keyboard, IME button should always be shown.
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The return type of this method is void, but the way that the method works internally and the state at which the ResultReceiver is notified have changed. Specifically:",- The 'mImm.setImeWindowStatus' call in the early version was changed to 'setImeWindowStatus' (with different parameters) in the late version.
564,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,28,29,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            long lastFrameNumber;
            try {
                lastFrameNumber = mRemoteDevice.cancelRequest(requestId);
            } catch (IllegalArgumentException e) {
                if (DEBUG) {
                    Log.v(TAG, ""Repeating request was already stopped for request "" + requestId);
                }
                // Repeating request was already stopped. Nothing more to do.
                return;
            }
            checkEarlyTriggerSequenceComplete(requestId, lastFrameNumber);
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            int[] requestTypes = mRepeatingRequestTypes;
            mRepeatingRequestTypes = null;
            long lastFrameNumber;
            try {
                lastFrameNumber = mRemoteDevice.cancelRequest(requestId);
            } catch (IllegalArgumentException e) {
                if (DEBUG) {
                    Log.v(TAG, ""Repeating request was already stopped for request "" + requestId);
                }
                // Repeating request was already stopped. Nothing more to do.
                return;
            }
            checkEarlyTriggerSequenceComplete(requestId, lastFrameNumber, requestTypes);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional line in the late implementation that initializes an array variable `int[] requestTypes` with `mRepeatingRequestTypes` and then sets `mRepeatingRequestTypes` to `null`. Also, the method 'checkEarlyTriggerSequenceComplete' in the late version adds an additional argument 'requestTypes'. Apart from these changes, the core logic of the method doesn't seem to be altered. Thus, the code change type is 4.","The changes in the late implementation version do not alter the control flow or the conditions that might lead to a different outcome. The method performs the same actions and would return the same results if the data dependencies were consistent. The additional variable and argument added do not constitute a change that would result in a different return value or different exception handling. The behavior remains ostensibly the same from the perspective of the API caller, provided that `checkEarlyTriggerSequenceComplete` handles the additional argument without changing its success or failure outcome as exposed to the caller. Hence, there is no compatibility issue, and the CI type is 0."
565,<android.transition.TransitionSet: TransitionSet setInterpolator(TimeInterpolator)>,28,29,<android.transition.TransitionSet: TransitionSet setInterpolator(TimeInterpolator)>,<android.transition.TransitionSet: TransitionSet setInterpolator(TimeInterpolator)>,0,"{
    return (TransitionSet) super.setInterpolator(interpolator);
}","{
    mChangeFlags |= FLAG_CHANGE_INTERPOLATOR;
    if (mTransitions != null) {
        int numTransitions = mTransitions.size();
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).setInterpolator(interpolator);
        }
    }
    return (TransitionSet) super.setInterpolator(interpolator);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version has additional lines that update a field and iterate over a list to set the interpolator; however, the actual return statement is unchanged. So, we have a change in other statements (setting a variable and iterating over a collection) as well as control dependency change due to the for loop being added. The code change types are 3 and 4.","Despite the changes, there is no compatibility issue in terms of differing return values or exceptions. The method returns the same 'TransitionSet' object after setting the interpolator, and there are no new exceptions being thrown or caught. Thus, no CI issue arises."
566,"<android.view.ViewGroup: void invalidateChild(View,Rect)>",28,29,"<android.view.ViewGroup: void invalidateChild(View,Rect)>","<android.view.ViewGroup: void invalidateChild(View,Rect)>",0,"{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null && attachInfo.mHardwareAccelerated) {
        // HW accelerated fast path
        onDescendantInvalidated(child, child);
        return;
    }
    ViewParent parent = this;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) != 0;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        final boolean isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
        // Mark the child as dirty, using the appropriate flag
        // Make sure we do not set both flags at the same time
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) {
                    opaqueFlag = PFLAG_DIRTY;
                }
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
                }
            }
        } while (parent != null);
    }
}","{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null && attachInfo.mHardwareAccelerated) {
        // HW accelerated fast path
        onDescendantInvalidated(child, child);
        return;
    }
    ViewParent parent = this;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) != 0;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom));
                }
            }
        } while (parent != null);
    }
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead to observe updates to
 * draw state in descendants.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * @deprecated Use {@link #onDescendantInvalidated(View, View)} instead to observe updates to
 * draw state in descendants.
 */
",-1,"[@Deprecated, @Override]","[@Deprecated, @Override]",-1,-1,-1,-1,-1,-1,,,,
567,"<android.content.UriMatcher: void addURI(String,String,int)>",28,29,"<android.content.UriMatcher: void addURI(String,String,int)>","<android.content.UriMatcher: void addURI(String,String,int)>",0,"{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split(""/"");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals(""#"")) {
                child.mWhich = NUMBER;
            } else if (token.equals(""*"")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}","{
    if (code < 0) {
        throw new IllegalArgumentException(""code "" + code + "" is invalid: it must be positive"");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split(""/"");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = createChild(token);
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}",1,"/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
","/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token ""*""
 * that matches any text, or the token ""#"" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change is the extraction of creating a new `UriMatcher` child into a new method `createChild(token)` instead of inline creation, which is a change in other statements (code change type 4). This also includes the dependent API change because the implementation now depends on the new `createChild` method (code change type 5).","There is no compatibility issue since the behavior and return value of the method did not change; the method now simply delegates part of its logic to another method. The method's signature did not change, nor did its logic for how it handles inputs or outputs."
568,<android.app.ActivityThread.Idler: boolean queueIdle()>,28,29,<android.app.ActivityThread.Idler: boolean queueIdle()>,<android.app.ActivityThread.Idler: boolean queueIdle()>,0,"{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManager.getService();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    ensureJitEnabled();
    return false;
}","{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityTaskManager am = ActivityTaskManager.getService();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    applyPendingProcessState();
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,The API implementation has changed in several ways: ,"- The surrounding control structure and other statements remain unchanged, thus the change type is 3,4,5."
570,"<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig create(Collection<String>,Collection<String>,Collection<String>)>",28,29,"<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig create(Collection<String>,Collection<String>,Collection<String>)>","<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig create(Collection<String>,Collection<String>,Collection<String>)>",0,"{
    return new EntityConfig(/* useHints */
    true, hints, includedEntityTypes, excludedEntityTypes);
}","{
    return new EntityConfig.Builder().setIncludedTypes(includedEntityTypes).setExcludedTypes(excludedEntityTypes).setHints(hints).includeTypesFromTextClassifier(true).build();
}",1,"/**
 * Creates an EntityConfig.
 *
 * @param hints Hints for the TextClassifier to determine what types of entities to find
 * @param includedEntityTypes Entity types, e.g. {@link #TYPE_EMAIL}, to explicitly include
 * @param excludedEntityTypes Entity types, e.g. {@link #TYPE_PHONE}, to explicitly exclude
 *
 * Note that if an entity has been excluded, the exclusion will take precedence.
 */
","/**
 * Creates an EntityConfig.
 *
 * @param hints Hints for the TextClassifier to determine what types of entities to find
 * @param includedEntityTypes Entity types, e.g. {@link #TYPE_EMAIL}, to explicitly include
 * @param excludedEntityTypes Entity types, e.g. {@link #TYPE_PHONE}, to explicitly exclude
 *
 * Note that if an entity has been excluded, the exclusion will take precedence.
 *
 * @deprecated Use {@link Builder} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The instantiation of `EntityConfig` changed from direct constructor call to using a `Builder` pattern with chained method calls. This is a change in the object creation process, not in behavior, assuming the Builder and constructor create equivalent `EntityConfig` objects. It's also a dependent API change because the old and new versions rely on different constructors/methods to create `EntityConfig` instances, so the code change type is 4,5.","There should be no compatibility issue if the new Builder pattern creates an instance that is functionally identical to the instance created by the direct constructor call. The change is in how the object is constructed, not in the object's behavior or contract, and thus it should not affect existing code that uses this method. Therefore, the CI type is 0."
571,"<android.provider.DocumentsContract: void ejectRoot(ContentResolver,Uri)>",28,29,"<android.provider.DocumentsContract: void ejectRoot(ContentResolver,Uri)>","<android.provider.DocumentsContract: void ejectRoot(ContentResolver,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(rootUri.getAuthority());
    try {
        ejectRoot(client, rootUri);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, rootUri);
        content.call(rootUri.getAuthority(), METHOD_EJECT_ROOT, null, in);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to eject"", e);
    }
}",1,"/**
 * Ejects the given root. It throws {@link IllegalStateException} when ejection failed.
 *
 * @param rootUri root with {@link Root#FLAG_SUPPORTS_EJECT} to be ejected
 */
","/**
 * Ejects the given root. It throws {@link IllegalStateException} when ejection failed.
 *
 * @param rootUri root with {@link Root#FLAG_SUPPORTS_EJECT} to be ejected
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",2,"The method body has significantly changed between versions. A new dependent API content.call() is introduced to replace ejectRoot(client, rootUri), changing the control flow and the mechanism of exception handling. Additionally, the exception type caught has broadened from RemoteException to Exception, and the handling logic went from rethrowing as a runtime exception to logging a warning. Hence, the changes include exception handling statement changed (2), other statement changed as per the mechanism of interaction (4), and dependent API changed (5).",The new version could potentially behave differently in terms of exception handling since it now logs a warning instead of rethrowing the exception as a runtime exception. This is a change in core behavior which could cause a Compatibility Issue due to the different exception handlings (2).
572,<android.content.pm.SharedLibraryInfo: String toString()>,28,29,<android.content.pm.SharedLibraryInfo: String toString()>,<android.content.pm.SharedLibraryInfo: String toString()>,0,"{
    return ""SharedLibraryInfo[name:"" + mName + "", type:"" + typeToString(mType) + "", version:"" + mVersion + (!getDependentPackages().isEmpty() ? "" has dependents"" : """");
}","{
    return ""SharedLibraryInfo{name:"" + mName + "", type:"" + typeToString(mType) + "", version:"" + mVersion + (!getDependentPackages().isEmpty() ? "" has dependents"" : """") + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation has been updated to correctly close the curly brace in the return string, so the code change type is 4.","This is simply a syntactical change to fix a string formatting issue in the toString method. There are no different behaviors in terms of returned values, exceptions, or control flows, so there is no compatibility issue."
573,<android.bluetooth.le.ScanRecord: byte[] getServiceData(ParcelUuid)>,28,29,<android.bluetooth.le.ScanRecord: byte[] getServiceData(ParcelUuid)>,<android.bluetooth.le.ScanRecord: byte[] getServiceData(ParcelUuid)>,0,"{
    if (serviceDataUuid == null) {
        return null;
    }
    return mServiceData.get(serviceDataUuid);
}","{
    if (serviceDataUuid == null || mServiceData == null) {
        return null;
    }
    return mServiceData.get(serviceDataUuid);
}",1,"/**
 * Returns the service data byte array associated with the {@code serviceUuid}. Returns
 * {@code null} if the {@code serviceDataUuid} is not found.
 */
","/**
 * Returns the service data byte array associated with the {@code serviceUuid}. Returns
 * {@code null} if the {@code serviceDataUuid} is not found.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed with an added null check for `mServiceData` object before the return statement, so the code change type is 3.","Despite the additional null check, the behavior of the method remains compatible. The method previously returned null if `serviceDataUuid` was null. Now it also returns null if `mServiceData` is null, which is consistent with the previous contract of the method (as returning `null` is already a behavior of the method if the data is not present). The additional check does not introduce a new behavior or change the nature of the return value when it is not null, and thus does not cause a Compatibility Issue. Hence, the CI type is 0."
574,<android.app.Activity: boolean isInMultiWindowMode()>,28,29,<android.app.Activity: boolean isInMultiWindowMode()>,<android.app.Activity: boolean isInMultiWindowMode()>,0,"{
    try {
        return ActivityManager.getService().isInMultiWindowMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return ActivityTaskManager.getService().isInMultiWindowMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Returns true if the activity is currently in multi-window mode.
 * @see android.R.attr#resizeableActivity
 *
 * @return True if the activity is in multi-window mode.
 */
","/**
 * Returns true if the activity is currently in multi-window mode.
 * @see android.R.attr#resizeableActivity
 *
 * @return True if the activity is in multi-window mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to check the multi-window mode has changed from `ActivityManager.getService().isInMultiWindowMode` to `ActivityTaskManager.getService().isInMultiWindowMode`, indicating a dependent API change, so the code change is of type 5.","Although there is a change in the dependent API from `ActivityManager` to `ActivityTaskManager`, the signature of the method `isInMultiWindowMode` remains the same, as does the logic of the method. Therefore, there is no compatibility issue as the return type and exception handling have not changed; thus the CI type is 0."
575,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,28,29,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,<android.view.textclassifier.TextClassification.Builder: TextClassification build()>,0,"{
    return new TextClassification(mText, mLegacyIcon, mLegacyLabel, mLegacyIntent, mLegacyOnClickListener, mActions, mEntityConfidence, mId);
}","{
    EntityConfidence entityConfidence = new EntityConfidence(mTypeScoreMap);
    return new TextClassification(mText, mLegacyIcon, mLegacyLabel, mLegacyIntent, mLegacyOnClickListener, mActions, entityConfidence, mId, buildExtras(entityConfidence));
}",1,"/**
 * Builds and returns a {@link TextClassification} object.
 */
","/**
 * Builds and returns a {@link TextClassification} object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late implementation introduces the object 'entityConfidence', then passed through a new method buildExtras() which likely returns an additional parameter for the constructor of TextClassification. This means the return statement is changed. A new constructor parameter 'buildExtras(entityConfidence)' is introduced, which also indicates a change in object initialization, and since 'EntityConfidence' is initialized in a different way, it classifies also as another statement changed (if we assume that 'mTypeScoreMap' was an existing field that was used differently in the early version), and that dependent APIs have potentially changed, so the change type is 1,4,5.","Since the constructor for TextClassification now includes an additional parameter which is the result of a new method call, it may result in different behavior from the API, potentially leading to a different return object. Hence, the API could return different values indicating a CI type of 1."
577,<android.net.IpPrefix: boolean contains(InetAddress)>,28,29,<android.net.IpPrefix: boolean contains(InetAddress)>,<android.net.IpPrefix: boolean contains(InetAddress)>,0,"{
    byte[] addrBytes = (address == null) ? null : address.getAddress();
    if (addrBytes == null || addrBytes.length != this.address.length) {
        return false;
    }
    NetworkUtils.maskRawAddress(addrBytes, prefixLength);
    return Arrays.equals(this.address, addrBytes);
}","{
    byte[] addrBytes = address.getAddress();
    if (addrBytes == null || addrBytes.length != this.address.length) {
        return false;
    }
    NetworkUtils.maskRawAddress(addrBytes, prefixLength);
    return Arrays.equals(this.address, addrBytes);
}",1,"/**
 * Determines whether the prefix contains the specified address.
 *
 * @param address An {@link InetAddress} to test.
 * @return {@code true} if the prefix covers the given address.
 */
","/**
 * Determines whether the prefix contains the specified address.
 *
 * @param address An {@link InetAddress} to test.
 * @return {@code true} if the prefix covers the given address. {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency changed by removing the null check on the 'address' parameter. Additionally, there's an other statement changed which is related to the assignment of 'addrBytes'. However, this change is actually removing a potential null pointer exception, which was previously being checked.","This change does not bring about a Compatibility Issue because it only eliminates the possibility of having a NullPointerException if 'address' was null. If null were passed to the method in the early version, it would return false. In the late version, it would throw a NullPointerException, thus an invocation that used to succeed in a controlled manner (returning false gracefully) might now lead to an unplanned exception. However, since passing null to this method is likely to be considered programmer error (since an InetAddress should never be null to check containment within an IpPrefix), this change might have been introduced to enforce correct usage of API rather than changing its intended behavior."
578,<android.app.ActivityThread.H: String codeToString(int)>,28,29,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PURGE_RESOURCES:
                return ""PURGE_RESOURCES"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
580,<android.accessibilityservice.AccessibilityService: MagnificationController getMagnificationController()>,28,29,<android.accessibilityservice.AccessibilityService: MagnificationController getMagnificationController()>,<android.accessibilityservice.AccessibilityService: MagnificationController getMagnificationController()>,0,"{
    synchronized (mLock) {
        if (mMagnificationController == null) {
            mMagnificationController = new MagnificationController(this, mLock);
        }
        return mMagnificationController;
    }
}","{
    return getMagnificationController(Display.DEFAULT_DISPLAY);
}",1,"/**
 * Returns the magnification controller, which may be used to query and
 * modify the state of display magnification.
 * <p>
 * <strong>Note:</strong> In order to control magnification, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canControlMagnification}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 *
 * @return the magnification controller
 */
","/**
 * Returns the magnification controller, which may be used to query and
 * modify the state of display magnification.
 * <p>
 * <strong>Note:</strong> In order to control magnification, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canControlMagnification}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 *
 * @return the magnification controller
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed to calling another method, getMagnificationController(int displayId), with a default display id parameter, so it's a dependent API change, making it change type 5.","There is no Compatibility Issue, since the late version of the API is a shorthand for the earlier version with a default parameter. The non-null contract is preserved, and the new method called inside should itself be responsible for returning a non-null MagnificationController for the default display, maintaining the behavior expected by callers of the earlier version."
581,"<android.provider.DocumentsContract: Uri createDocument(ContentResolver,Uri,String,String)>",28,29,"<android.provider.DocumentsContract: Uri createDocument(ContentResolver,Uri,String,String)>","<android.provider.DocumentsContract: Uri createDocument(ContentResolver,Uri,String,String)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(parentDocumentUri.getAuthority());
    try {
        return createDocument(client, parentDocumentUri, mimeType, displayName);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to create document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, parentDocumentUri);
        in.putString(Document.COLUMN_MIME_TYPE, mimeType);
        in.putString(Document.COLUMN_DISPLAY_NAME, displayName);
        final Bundle out = content.call(parentDocumentUri.getAuthority(), METHOD_CREATE_DOCUMENT, null, in);
        return out.getParcelable(DocumentsContract.EXTRA_URI);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to create document"", e);
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Create a new document with given MIME type and display name.
 *
 * @param parentDocumentUri directory with {@link Document#FLAG_DIR_SUPPORTS_CREATE}
 * @param mimeType MIME type of new document
 * @param displayName name of new document
 * @return newly created document, or {@code null} if failed
 */
","/**
 * Create a new document with given MIME type and display name.
 *
 * @param parentDocumentUri directory with {@link Document#FLAG_DIR_SUPPORTS_CREATE}
 * @param mimeType MIME type of new document
 * @param displayName name of new document
 * @return newly created document, or {@code null} if failed
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The implementation of the method has been changed significantly including the signature of the createDocument() method being called within the try block, the way the parameters are being passed to it, and the handling of the output. Additionally, there is removal of the ContentProviderClient along with how it is acquired and released. The statement 'ContentProviderClient.releaseQuietly(client);' is removed in the late version, which is not directly related to the API's return value or exception handling, so code change types are 1 (as there is a change in what `createDocument` returns), 4 (other statement change), and 5 (dependent API change).","There's a potential change in behavior due to the restructuring of how the function handles its creation logic which could potentially result in different return values; therefore, there's a CI of type 1. There are also changes to how exceptions are handled because the late version does not rethrow an exception using a method with a ContentResolver parameter, leading to potential different exceptions; therefore, there is a CI of type 2."
582,"<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>",28,29,"<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>","<android.view.inputmethod.InputMethodManager: Map<InputMethodInfo, List<InputMethodSubtype>> getShortcutInputMethodsAndSubtypes()>",0,"{
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // ""info"" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            if (info != null && !info.isEmpty()) {
                final int N = info.size();
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, ""IMI list already contains the same InputMethod."");
                            break;
                        }
                        subtypes = new ArrayList<>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        return ret;
    }
}","{
    final List<InputMethodInfo> enabledImes = getEnabledInputMethodList();
    // Ensure we check system IMEs first.
    enabledImes.sort(Comparator.comparingInt(imi -> imi.isSystem() ? 0 : 1));
    final int numEnabledImes = enabledImes.size();
    for (int imiIndex = 0; imiIndex < numEnabledImes; ++imiIndex) {
        final InputMethodInfo imi = enabledImes.get(imiIndex);
        final List<InputMethodSubtype> subtypes = getEnabledInputMethodSubtypeList(imi, true);
        final int subtypeCount = subtypes.size();
        for (int subtypeIndex = 0; subtypeIndex < subtypeCount; ++subtypeIndex) {
            final InputMethodSubtype subtype = imi.getSubtypeAt(subtypeIndex);
            if (SUBTYPE_MODE_VOICE.equals(subtype.getMode())) {
                return Collections.singletonMap(imi, Collections.singletonList(subtype));
            }
        }
    }
    return Collections.emptyMap();
}",1,"/**
 * Returns a map of all shortcut input method info and their subtypes.
 */
","/**
 * Returns a map of all shortcut input method info and their subtypes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The entire early implementation is wrapped in a synchronized block and uses a RemoteException catch block, whereas the late implementation lacks these and uses entirely different logic for processing and returning the map of input methods and subtypes, making use of getEnabledInputMethodList() and getEnabledInputMethodSubtypeList() instead of a service method call. There is a change in return statement, control dependency (the whole logic, including loops), other statements due to significant logic change, and dependent APIs due to the use of new methods like getEnabledInputMethodList() and getEnabledInputMethodSubtypeList(). Hence, the code changes include 1, 3, 4, and 5.","The method in early version collects IMEs and their subtypes differently and possibly returns a complete map of all shortcut input methods and their subtypes. In contrast, in the late version, it only returns a map containing one entry with voice subtype if available or an empty map otherwise, which significantly differs from the behavior in the early version. So the type of CI is 1 due to the potential different return types or values."
583,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,28,29,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mSplitName, mActivityToken, mUser, flags, mClassLoader, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation code has changed by adding a new parameter 'null' to the constructor of ContextImpl, which changes the number of parameters in a method call without altering any control structures, exception handling, or return statements. Thus the change type is 4 for Other statement changed and 5 for Dependent API changed.","This change does not lead to a Compatibility Issue since the added 'null' parameter does not affect the behavior or output of the method createDeviceProtectedStorageContext(). The method should behave as before, with the 'null' value merely becoming a part of the internal state of the newly created ContextImpl object. The API's contract or its returning value remains unchanged, so there is no Compatibility Issue here."
585,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",28,29,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mimeType, ""mimeType"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    return openTypedAssetFile(uri, mimeType, opts, signal);
}",1,"/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
","/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,5","1,2","The implementation has been changed entirely from the detailed internal logic to a single call to another method, openTypedAssetFile(uri, mimeType, opts, signal). There is a return statement change from a complex block of code to a single method call, which is a control dependency change, and it's calling another API, so the change types are 1,3,5.","There is a potential Compatibility Issue due to the different return values because the previous implementation directly manipulated signals and handled exceptions, which could lead to different outcomes compared to just delegating to another method. This also includes an Exception handling change since the new implementation no longer explicitly handles DeadObjectException or manages a CancellationSignal, which can lead to different exception handling behavior, so the CI types are 1,2."
586,"<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",28,29,"<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>","<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",0,"{
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}","{
    final Uri uri = ContentUris.withAppendedId(Video.Media.EXTERNAL_CONTENT_URI, videoId);
    return InternalThumbnails.getThumbnail(cr, uri, kind, options);
}",1,"/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image
 * associated with origId doesn't exist or memory is not enough.
 */
","/**
 * Return thumbnail representing a specific video item. If a
 * thumbnail doesn't exist, this method will block until it's
 * generated. Callers are responsible for their own in-memory
 * caching of returned values.
 *
 * @param videoId the video item to obtain a thumbnail for.
 * @param kind optimal thumbnail size desired.
 * @return decoded thumbnail, or {@code null} if problem was
 * encountered.
 * @deprecated Callers should migrate to using
 * {@link ContentResolver#loadThumbnail}, since it
 * offers richer control over requested thumbnail sizes
 * and cancellation behavior.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed by modifying how the thumbnail is retrieved. In the early version, the method directly calls `getThumbnail()` with a set of parameters, including `origId`. In the late version, it first constructs a `Uri` using the `videoId` and then calls a different `getThumbnail()` method that accepts the `Uri`. Given that the parameters passed to the `getThumbnail()` method have been altered, both the way the `Uri` is obtained and the `getThumbnail` method itself might have changed. This indicates changes in both return statements (since the value returned could be different due to changes in parameters) and dependent API (because the `getThumbnail` method called is different with different parameters). Therefore, the code change type is 1,5.","The change to how the thumbnail is obtained and which `getThumbnail` method is called could potentially lead to the API returning a different value, so the CI type is 1."
587,<android.app.assist.AssistStructure: ComponentName getActivityComponent()>,28,29,<android.app.assist.AssistStructure: ComponentName getActivityComponent()>,<android.app.assist.AssistStructure: ComponentName getActivityComponent()>,0,"{
    ensureData();
    return mActivityComponent;
}","{
    return mActivityComponent;
}",1,"/**
 * Return the activity this AssistStructure came from.
 */
","/**
 * Return the activity this AssistStructure came from.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call ensureData() has been removed, so the type of code change is 4 (Other statement changed).","The removal of ensureData() does not necessarily imply a Compatibility Issue. Without additional information on what ensureData() does, we cannot assume it modifies the state that would affect the return value. Since the returned value is still mActivityComponent in both versions, no CI related to different return values or exception handlings can be directly inferred. There is no CI."
589,<android.hardware.usb.UsbDevice: String toString()>,28,29,<android.hardware.usb.UsbDevice: String toString()>,<android.hardware.usb.UsbDevice: String toString()>,0,"{
    StringBuilder builder = new StringBuilder(""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mManufacturerName="" + mManufacturerName + "",mProductName="" + mProductName + "",mVersion="" + mVersion + "",mSerialNumber="" + mSerialNumber + "",mConfigurations=["");
    for (int i = 0; i < mConfigurations.length; i++) {
        builder.append(""\n"");
        builder.append(mConfigurations[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder(""UsbDevice[mName="" + mName + "",mVendorId="" + mVendorId + "",mProductId="" + mProductId + "",mClass="" + mClass + "",mSubclass="" + mSubclass + "",mProtocol="" + mProtocol + "",mManufacturerName="" + mManufacturerName + "",mProductName="" + mProductName + "",mVersion="" + mVersion + "",mSerialNumberReader="" + mSerialNumberReader + "",mConfigurations=["");
    for (int i = 0; i < mConfigurations.length; i++) {
        builder.append(""\n"");
        builder.append(mConfigurations[i].toString());
    }
    builder.append(""]"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is that 'mSerialNumber' has been replaced with 'mSerialNumberReader' in the builder's string concatenation, but the overall structure of the method and how it executes remain unchanged. This is a change in an other statement, so the code change type is 4.","This difference does not cause any compatibility issue since the method's behavior, in terms of how it processes and returns a string representation of the object, remains the same. The string still fulfills the same purpose and the method signature has not changed, so there is no compatibility issue."
590,"<android.widget.DayPickerPagerAdapter: Object instantiateItem(ViewGroup,int)>",28,29,"<android.widget.DayPickerPagerAdapter: Object instantiateItem(ViewGroup,int)>","<android.widget.DayPickerPagerAdapter: Object instantiateItem(ViewGroup,int)>",0,"{
    final View itemView = mInflater.inflate(mLayoutResId, container, false);
    final SimpleMonthView v = itemView.findViewById(mCalendarViewId);
    v.setOnDayClickListener(mOnDayClickListener);
    v.setMonthTextAppearance(mMonthTextAppearance);
    v.setDayOfWeekTextAppearance(mDayOfWeekTextAppearance);
    v.setDayTextAppearance(mDayTextAppearance);
    if (mDaySelectorColor != null) {
        v.setDaySelectorColor(mDaySelectorColor);
    }
    if (mDayHighlightColor != null) {
        v.setDayHighlightColor(mDayHighlightColor);
    }
    if (mCalendarTextColor != null) {
        v.setMonthTextColor(mCalendarTextColor);
        v.setDayOfWeekTextColor(mCalendarTextColor);
        v.setDayTextColor(mCalendarTextColor);
    }
    final int month = getMonthForPosition(position);
    final int year = getYearForPosition(position);
    final int selectedDay;
    if (mSelectedDay != null && mSelectedDay.get(Calendar.MONTH) == month) {
        selectedDay = mSelectedDay.get(Calendar.DAY_OF_MONTH);
    } else {
        selectedDay = -1;
    }
    final int enabledDayRangeStart;
    if (mMinDate.get(Calendar.MONTH) == month && mMinDate.get(Calendar.YEAR) == year) {
        enabledDayRangeStart = mMinDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeStart = 1;
    }
    final int enabledDayRangeEnd;
    if (mMaxDate.get(Calendar.MONTH) == month && mMaxDate.get(Calendar.YEAR) == year) {
        enabledDayRangeEnd = mMaxDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeEnd = 31;
    }
    v.setMonthParams(selectedDay, month, year, mFirstDayOfWeek, enabledDayRangeStart, enabledDayRangeEnd);
    final ViewHolder holder = new ViewHolder(position, itemView, v);
    mItems.put(position, holder);
    container.addView(itemView);
    return holder;
}","{
    final View itemView = mInflater.inflate(mLayoutResId, container, false);
    final SimpleMonthView v = itemView.findViewById(mCalendarViewId);
    v.setOnDayClickListener(mOnDayClickListener);
    v.setMonthTextAppearance(mMonthTextAppearance);
    v.setDayOfWeekTextAppearance(mDayOfWeekTextAppearance);
    v.setDayTextAppearance(mDayTextAppearance);
    if (mDaySelectorColor != null) {
        v.setDaySelectorColor(mDaySelectorColor);
    }
    if (mDayHighlightColor != null) {
        v.setDayHighlightColor(mDayHighlightColor);
    }
    if (mCalendarTextColor != null) {
        v.setMonthTextColor(mCalendarTextColor);
        v.setDayOfWeekTextColor(mCalendarTextColor);
        v.setDayTextColor(mCalendarTextColor);
    }
    final int month = getMonthForPosition(position);
    final int year = getYearForPosition(position);
    final int selectedDay;
    if (mSelectedDay != null && mSelectedDay.get(Calendar.MONTH) == month && mSelectedDay.get(Calendar.YEAR) == year) {
        selectedDay = mSelectedDay.get(Calendar.DAY_OF_MONTH);
    } else {
        selectedDay = -1;
    }
    final int enabledDayRangeStart;
    if (mMinDate.get(Calendar.MONTH) == month && mMinDate.get(Calendar.YEAR) == year) {
        enabledDayRangeStart = mMinDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeStart = 1;
    }
    final int enabledDayRangeEnd;
    if (mMaxDate.get(Calendar.MONTH) == month && mMaxDate.get(Calendar.YEAR) == year) {
        enabledDayRangeEnd = mMaxDate.get(Calendar.DAY_OF_MONTH);
    } else {
        enabledDayRangeEnd = 31;
    }
    v.setMonthParams(selectedDay, month, year, mFirstDayOfWeek, enabledDayRangeStart, enabledDayRangeEnd);
    final ViewHolder holder = new ViewHolder(position, itemView, v);
    mItems.put(position, holder);
    container.addView(itemView);
    return holder;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The condition within the 'if' statement that determines `selectedDay` (specifically the additional check for the year in `mSelectedDay.get(Calendar.YEAR) == year`) has been changed, leading to a modification in a control dependency, which is type 3.","Despite the control dependency change, the potential range of returned values for `selectedDay` remains the same (-1 to the maximum number of days in a month). The change only refines the condition under which a specific day is selected but doesn't introduce a change that would cause the method to return a different type or a value that wasn't possible in the early version. Therefore, there is no compatibility issue, and the type is 0."
591,"<android.provider.MediaStore.Audio.Genres.Members: Uri getContentUri(String,long)>",28,29,"<android.provider.MediaStore.Audio.Genres.Members: Uri getContentUri(String,long)>","<android.provider.MediaStore.Audio.Genres.Members: Uri getContentUri(String,long)>",0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/genres/"" + genreId + ""/members"");
}","{
    return ContentUris.withAppendedId(Audio.Genres.getContentUri(volumeName), genreId).buildUpon().appendPath(""members"").build();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed entirely. It went from manually constructing a Uri from a string to using `ContentUris.withAppendedId()` method to append the genre ID and then appending the ""members"" path segment. This change indicates that the method now relies on a different API (`ContentUris.withAppendedId()` and `Audio.Genres.getContentUri(volumeName)`) to generate the Uri, and thus both the return statement and the dependent API have changed, making the code change types 1 and 5.","The change in the method used to create the Uri could lead to a different return value, hence there's a possibility of a Compatibility Issue due to the potential change in the returned Uri, even if the intent is to maintain the same logical endpoint. Therefore, the CI classification is 1."
594,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailablePhysicalCameraRequestKeys()>,28,29,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailablePhysicalCameraRequestKeys()>,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailablePhysicalCameraRequestKeys()>,0,"{
    if (mAvailablePhysicalRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS);
        if (filterTags == null) {
            return null;
        }
        mAvailablePhysicalRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags);
    }
    return mAvailablePhysicalRequestKeys;
}","{
    if (mAvailablePhysicalRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS);
        if (filterTags == null) {
            return null;
        }
        mAvailablePhysicalRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags, /*includeSynthetic*/
        false);
    }
    return mAvailablePhysicalRequestKeys;
}",1,"/**
 * <p>Returns a subset of {@link #getAvailableCaptureRequestKeys} keys that can
 * be overriden for physical devices backing a logical multi-camera.</p>
 *
 * <p>This is a subset of android.request.availableRequestKeys which contains a list
 * of keys that can be overriden using {@link CaptureRequest.Builder#setPhysicalCameraKey }.
 * The respective value of such request key can be obtained by calling
 * {@link CaptureRequest.Builder#getPhysicalCameraKey }. Capture requests that contain
 * individual physical device requests must be built via
 * {@link android.hardware.camera2.CameraDevice#createCaptureRequest(int, Set)}.
 * Such extended capture requests can be passed only to
 * {@link CameraCaptureSession#capture } or {@link CameraCaptureSession#captureBurst } and
 * not to {@link CameraCaptureSession#setRepeatingRequest } or
 * {@link CameraCaptureSession#setRepeatingBurst }.</p>
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * @return List of keys that can be overriden in individual physical device requests.
 * In case the camera device doesn't support such keys the list can be null.
 */
","/**
 * <p>Returns a subset of {@link #getAvailableCaptureRequestKeys} keys that can
 * be overridden for physical devices backing a logical multi-camera.</p>
 *
 * <p>This is a subset of android.request.availableRequestKeys which contains a list
 * of keys that can be overridden using {@link CaptureRequest.Builder#setPhysicalCameraKey }.
 * The respective value of such request key can be obtained by calling
 * {@link CaptureRequest.Builder#getPhysicalCameraKey }. Capture requests that contain
 * individual physical device requests must be built via
 * {@link android.hardware.camera2.CameraDevice#createCaptureRequest(int, Set)}.
 * Such extended capture requests can be passed only to
 * {@link CameraCaptureSession#capture } or {@link CameraCaptureSession#captureBurst } and
 * not to {@link CameraCaptureSession#setRepeatingRequest } or
 * {@link CameraCaptureSession#setRepeatingBurst }.</p>
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * @return List of keys that can be overridden in individual physical device requests.
 * In case the camera device doesn't support such keys the list can be null.
 */
",-1,"[@SuppressWarnings({ ""unchecked"" })]","[@SuppressWarnings({ ""unchecked"" })]",-1,-1,-1,-1,-1,-1,"4,5",1,"The method getAvailableKeyList has received an additional boolean parameter in the late version. This change affects how the method behaves internally, which falls under code change type 4 (Other statement changed) and code change type 5 (Dependent API changed) since the called method's signature has changed.","The addition of a new parameter to the method getAvailableKeyList (setting the includeSynthetic flag to false) will potentially affect the return value because the list of keys returned by the method could be different with this new parameter. Therefore, a CI might arise due to this change, and the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
595,<android.util.ArrayMap: V removeAt(int)>,28,29,<android.util.ArrayMap: V removeAt(int)>,<android.util.ArrayMap: V removeAt(int)>,0,"{
    final Object old = mArray[(index << 1) + 1];
    final int osize = mSize;
    final int nsize;
    if (osize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        freeArrays(ohashes, oarray, osize);
        nsize = 0;
    } else {
        nsize = osize - 1;
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = osize > (BASE_SIZE * 2) ? (osize + (osize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
                throw new ConcurrentModificationException();
            }
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
        } else {
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
            mArray[nsize << 1] = null;
            mArray[(nsize << 1) + 1] = null;
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = nsize;
    return (V) old;
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    final Object old = mArray[(index << 1) + 1];
    final int osize = mSize;
    final int nsize;
    if (osize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to 0"");
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        freeArrays(ohashes, oarray, osize);
        nsize = 0;
    } else {
        nsize = osize - 1;
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = osize > (BASE_SIZE * 2) ? (osize + (osize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, ""remove: shrink from "" + mHashes.length + "" to "" + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
                throw new ConcurrentModificationException();
            }
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from 0-"" + index + "" to 0"");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: copy from "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
        } else {
            if (index < nsize) {
                if (DEBUG)
                    Log.d(TAG, ""remove: move "" + (index + 1) + ""-"" + nsize + "" to "" + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (nsize - index) << 1);
            }
            mArray[nsize << 1] = null;
            mArray[(nsize << 1) + 1] = null;
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS && osize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = nsize;
    return (V) old;
}",1,"/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
","/**
 * Remove the key/value mapping at the given index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
596,<android.app.Activity: void showLockTaskEscapeMessage()>,28,29,<android.app.Activity: void showLockTaskEscapeMessage()>,<android.app.Activity: void showLockTaskEscapeMessage()>,0,"{
    try {
        ActivityManager.getService().showLockTaskEscapeMessage(mToken);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityTaskManager.getService().showLockTaskEscapeMessage(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Shows the user the system defined message for telling the user how to exit
 * lock task mode. The task containing this activity must be in lock task mode at the time
 * of this call for the message to be displayed.
 */
","/**
 * Shows the user the system defined message for telling the user how to exit
 * lock task mode. The task containing this activity must be in lock task mode at the time
 * of this call for the message to be displayed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The API 'ActivityManager.getService()' has changed to 'ActivityTaskManager.getService()', which indicates a change in a dependent API, however, the purpose and exception handling of the method remain unchanged. Hence, the change types are 4,5 (Other statement changed, Dependent API changed).","There is no Compatibility Issue as the method behavior (return value or exception handling) has not changed between these versions. Thus, the CI type is 0."
598,<android.view.WindowInsets: boolean hasStableInsets()>,28,29,<android.view.WindowInsets: boolean hasStableInsets()>,<android.view.WindowInsets: boolean hasStableInsets()>,0,"{
    return mStableInsets.top != 0 || mStableInsets.left != 0 || mStableInsets.right != 0 || mStableInsets.bottom != 0;
}","{
    return !getStableInsets().equals(Insets.NONE);
}",1,"/**
 * Returns true if this WindowInsets has nonzero stable insets.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return true if any of the stable inset values are nonzero
 */
","/**
 * Returns true if this WindowInsets has nonzero stable insets.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return true if any of the stable inset values are nonzero
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method used to determine the boolean result has changed from using direct comparison with member variables of 'mStableInsets' to calling a method 'getStableInsets()' and comparing its result with 'Insets.NONE', which implies that the dependent API 'getStableInsets' has changed; hence the change types are 4 and 5.","Since the implementation logic has changed from a direct comparison to utilizing a different method, which could potentially be based on a different implementation, the return value of the method could differ, causing a potential Compatibility Issue due to different return values or types; thus, the CI type is 1."
599,<android.content.ContentResolver: String getType(Uri)>,28,29,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            // Manager will kill this process shortly anyway.
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.getType(url);
    } catch (RemoteException e) {
        return null;
    }
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            // Manager will kill this process shortly anyway.
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,[@Nullable],"[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"3,5",1,"The try block that includes `mWrapped.getType(url)` has been added and changed the flow of control dependency in case `mWrapped` is not null and no exception is thrown, thus resulting in changes of type 3 (Control dependency changed) and 5 (Dependent API changed, due to the introduction of a dependency on `mWrapped`).","Due to the added conditional check for `mWrapped` and a new return possibilityif `mWrapped` is not null and `mWrapped.getType(url)` does not throw an exception, then the method will return a possibly different value than it would have in the early version. Hence, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
600,<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig createWithHints(Collection<String>)>,28,29,<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig createWithHints(Collection<String>)>,<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig createWithHints(Collection<String>)>,0,"{
    return new EntityConfig(/* useHints */
    true, hints, /* includedEntityTypes */
    null, /* excludedEntityTypes */
    null);
}","{
    return new EntityConfig.Builder().includeTypesFromTextClassifier(true).setHints(hints).build();
}",1,"/**
 * Creates an EntityConfig.
 *
 * @param hints Hints for the TextClassifier to determine what types of entities to find.
 */
","/**
 * Creates an EntityConfig.
 *
 * @param hints Hints for the TextClassifier to determine what types of entities to find.
 *
 * @deprecated Use {@link Builder} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The implementation has been changed to use a Builder pattern for creating the `EntityConfig` object instead of using the constructor directly. This indicates a change in a dependent API as the way of constructing an `EntityConfig` object has changed, so the code change type is 5.","There are no compatibility issues arising from this change because the returned object should still conform to the same contract defined by the `EntityConfig` class. The Builder is used here presumably to create an object of the same type with the same state as before, so from the client's perspective who is using this method, there should be no observable change in behavior. This means that the API should not return different values, and the change should not cause the API to throw new exceptions or handle exceptions differently. Hence, there is no Compatibility Issue, classified as 0."
601,<android.hardware.usb.UsbAccessory: int hashCode()>,28,29,<android.hardware.usb.UsbAccessory: int hashCode()>,<android.hardware.usb.UsbAccessory: int hashCode()>,0,"{
    return mManufacturer.hashCode() ^ mModel.hashCode() ^ (mDescription == null ? 0 : mDescription.hashCode()) ^ (mVersion == null ? 0 : mVersion.hashCode()) ^ (mUri == null ? 0 : mUri.hashCode()) ^ (mSerial == null ? 0 : mSerial.hashCode());
}","{
    return mManufacturer.hashCode() ^ mModel.hashCode() ^ (mDescription == null ? 0 : mDescription.hashCode()) ^ (mVersion == null ? 0 : mVersion.hashCode()) ^ (mUri == null ? 0 : mUri.hashCode());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The hashCode calculation is changed by removing the XOR operation with mSerial.hashCode(), so it's a return statement changed, code change type is 1.","The removed XOR operation on mSerial.hashCode() will result in a different hash code if mSerial was not null, therefore the API will return a different value in such case. This leads to a potential Compatibility Issue of type 1."
602,"<android.app.Activity: void finishActivityFromChild(Activity,int)>",28,29,"<android.app.Activity: void finishActivityFromChild(Activity,int)>","<android.app.Activity: void finishActivityFromChild(Activity,int)>",0,"{
    try {
        ActivityManager.getService().finishSubActivity(mToken, child.mEmbeddedID, requestCode);
    } catch (RemoteException e) {
    // Empty
    }
}","{
    try {
        ActivityTaskManager.getService().finishSubActivity(mToken, child.mEmbeddedID, requestCode);
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * This is called when a child activity of this one calls its
 * finishActivity().
 *
 * @param child The activity making the call.
 * @param requestCode Request code that had been used to start the
 * activity.
 */
","/**
 * This is called when a child activity of this one calls its
 * finishActivity().
 *
 * @param child The activity making the call.
 * @param requestCode Request code that had been used to start the
 * activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method invoked inside the try block has changed from `ActivityManager.getService().finishSubActivity` to `ActivityTaskManager.getService().finishSubActivity`, indicating that the dependent API has changed, so the code change type is 5.","Even though the dependent service class's name has been changed, the signature of the method `finishSubActivity` that's being called seems to remain the same. There's no indication that the method's behavior has been altered, nor does the change affect the return or the exception handling of the `finishActivityFromChild` method. Thus, no compatibility issue should arise, and the CI type is 0."
603,<android.content.ContentValues: boolean equals(Object)>,28,29,<android.content.ContentValues: boolean equals(Object)>,<android.content.ContentValues: boolean equals(Object)>,0,"{
    if (!(object instanceof ContentValues)) {
        return false;
    }
    return mValues.equals(((ContentValues) object).mValues);
}","{
    if (!(object instanceof ContentValues)) {
        return false;
    }
    return mMap.equals(((ContentValues) object).mMap);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The calling method on 'mValues' has been changed to 'mMap'. This indicates that the dependent member variable or field name has changed. However, the type of the comparison object has not changed, and neither has the logic of the method. Therefore, the code change type is 5.","There is no Compatibility Issue because, even though the implementation now uses 'mMap' instead of 'mValues', the logic for comparison remains the same, assuming that 'mMap' is a new name for 'mValues' or an equivalent representation of the same data in the object, just under a different name. As a result, the behavior remains compatible, and thus there's no potential for a CI related to different return values or exception handlings."
607,<android.view.textclassifier.TextLinks.Request.Builder: Request build()>,28,29,<android.view.textclassifier.TextLinks.Request.Builder: Request build()>,<android.view.textclassifier.TextLinks.Request.Builder: Request build()>,0,"{
    return new Request(mText, mDefaultLocales, mEntityConfig, mLegacyFallback, mCallingPackageName);
}","{
    return new Request(mText, mDefaultLocales, mEntityConfig, mLegacyFallback, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns the request object.
 */
","/**
 * Builds and returns the request object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"There has been an addition of a conditional expression to handle the case where mExtras is null, which does not change the method signature or its return type but changes how the returned Request object is instantiated. Therefore, the change is classified as Other statement changed (4) and Dependent API changed (5) because the constructor of Request might handle the mExtras differently.","There is no Compatibility Issue detected because the changes do not affect the behavior of the method in a way that the API contract is broken. The method still returns a Request object, and the contract regarding nullability is unchanged (as indicated by the @NonNull annotation preservation). The change only provides a default non-null value for mExtras, so the created Request object may have different internal state, but it does not affect how the method is used by the API consumers."
609,"<android.provider.DocumentsContract: boolean removeDocument(ContentResolver,Uri,Uri)>",28,29,"<android.provider.DocumentsContract: boolean removeDocument(ContentResolver,Uri,Uri)>","<android.provider.DocumentsContract: boolean removeDocument(ContentResolver,Uri,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        removeDocument(client, documentUri, parentDocumentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to remove document"", e);
        rethrowIfNecessary(resolver, e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, documentUri);
        in.putParcelable(DocumentsContract.EXTRA_PARENT_URI, parentDocumentUri);
        content.call(documentUri.getAuthority(), METHOD_REMOVE_DOCUMENT, null, in);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to remove document"", e);
        rethrowIfNecessary(e);
        return false;
    }
}",1,"/**
 * Removes the given document from a parent directory.
 *
 * <p>In contrast to {@link #deleteDocument} it requires specifying the parent.
 * This method is especially useful if the document can be in multiple parents.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_REMOVE}
 * @param parentDocumentUri parent document of the document to remove.
 * @return true if the document was removed successfully.
 */
","/**
 * Removes the given document from a parent directory.
 *
 * <p>In contrast to {@link #deleteDocument} it requires specifying the parent.
 * This method is especially useful if the document can be in multiple parents.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_REMOVE}
 * @param parentDocumentUri parent document of the document to remove.
 * @return true if the document was removed successfully.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The early implementation acquires a ContentProviderClient and calls a method removeDocument that method is removed in the late version. Instead, a Bundle is created with URIs, and content.call is used, indicating 'Dependent API changed'. This also affects the return behavior, signaling a 'Return statement changed'. The exception handling block is still present but modifies the 'rethrowIfNecessary' method call, signaling 'Exception handling statement changed'. So, the code change types are 1, 2, 5.","There is a change in the entire workflow of how a document is removed, which can lead to a 'Compatibility Issue caused by potential different return values or types' if the new implementation behaves differently under any circumstance, which is likely here. There's also a change in the exception handling ('rethrowIfNecessary(e)' instead of 'rethrowIfNecessary(resolver, e)'), leading to a 'Compatibility Issue caused by potential different exception handlings.' Hence the CI types are 1, 2."
610,<android.hardware.usb.UsbDevice: UsbConfiguration getConfiguration(int)>,28,29,<android.hardware.usb.UsbDevice: UsbConfiguration getConfiguration(int)>,<android.hardware.usb.UsbDevice: UsbConfiguration getConfiguration(int)>,0,"{
    return (UsbConfiguration) mConfigurations[index];
}","{
    return mConfigurations[index];
}",1,"/**
 * Returns the {@link UsbConfiguration} at the given index.
 *
 * @return the configuration
 */
","/**
 * Returns the {@link UsbConfiguration} at the given index.
 *
 * @return the configuration
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The code change is the removal of the cast to `(UsbConfiguration)` from the `return` statement. This is simply a cast removal because `mConfigurations[index]` is already of type `UsbConfiguration`. Therefore, the change is only related to the casting, so the code change type is classified as 4 (Other statement changed).","There is no Compatibility Issue caused by this change, as the return type and the value remain the same; the object returned is of the same type and comes from the same array index as before the change. The casting was redundant, likely because the `mConfigurations` array is already of type `UsbConfiguration[]`. Therefore, the compatibility is maintained, and the CI type is 0 (No Compatibility Issue)."
611,<android.util.SparseLongArray: int keyAt(int)>,28,29,<android.util.SparseLongArray: int keyAt(int)>,<android.util.SparseLongArray: int keyAt(int)>,0,"{
    return mKeys[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return mKeys[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseLongArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseLongArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"There is a new exception throwing statement added and a new if condition added, the code change types are 3 for the control dependency change and 4 for the other statement change.","The addition of a new throw statement within an if condition that checks the index introduces a possible Compatibility Issue, as it may throw a new ArrayIndexOutOfBoundsException that did not exist in the previous version when the index is out of bounds. Hence, the CI type is 2 due to potential different exception handling."
613,"<android.view.inputmethod.InputMethodManager: void dispatchKeyEventFromInputMethod(View,KeyEvent)>",28,29,"<android.view.inputmethod.InputMethodManager: void dispatchKeyEventFromInputMethod(View,KeyEvent)>","<android.view.inputmethod.InputMethodManager: void dispatchKeyEventFromInputMethod(View,KeyEvent)>",0,"{
    synchronized (mH) {
        ViewRootImpl viewRootImpl = targetView != null ? targetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mServedView != null) {
                viewRootImpl = mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(targetView);
    if (fallbackImm != null) {
        fallbackImm.dispatchKeyEventFromInputMethod(targetView, event);
        return;
    }
    synchronized (mH) {
        ViewRootImpl viewRootImpl = targetView != null ? targetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mServedView != null) {
                viewRootImpl = mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
}",1,"/**
 * Provides the default implementation of {@link InputConnection#sendKeyEvent(KeyEvent)}, which
 * is expected to dispatch an keyboard event sent from the IME to an appropriate event target
 * depending on the given {@link View} and the current focus state.
 *
 * <p>CAUTION: This method is provided only for the situation where
 * {@link InputConnection#sendKeyEvent(KeyEvent)} needs to be implemented without relying on
 * {@link BaseInputConnection}. Do not use this API for anything else.</p>
 *
 * @param targetView the default target view. If {@code null} is specified, then this method
 * tries to find a good event target based on the current focus state.
 * @param event the key event to be dispatched.
 */
","/**
 * Provides the default implementation of {@link InputConnection#sendKeyEvent(KeyEvent)}, which
 * is expected to dispatch an keyboard event sent from the IME to an appropriate event target
 * depending on the given {@link View} and the current focus state.
 *
 * <p>CAUTION: This method is provided only for the situation where
 * {@link InputConnection#sendKeyEvent(KeyEvent)} needs to be implemented without relying on
 * {@link BaseInputConnection}. Do not use this API for anything else.</p>
 *
 * @param targetView the default target view. If {@code null} is specified, then this method
 * tries to find a good event target based on the current focus state.
 * @param event the key event to be dispatched.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code change includes the addition of a block of new statements that check for a context mismatch and possibly re-dispatch the key event, so the code change types are 3 and 4.","Because of the newly introduced block, there is a change in the behavior of the method when there is a context mismatch. The event might now be dispatched by a different `InputMethodManager`, which potentially changes the method's behavior. Previously, there was no redirection or re-dispatching logic, and thus this change can lead to a different result under specific conditions, making the CI type 1."
614,<android.view.MotionEvent: String toString()>,28,29,<android.view.MotionEvent: String toString()>,<android.view.MotionEvent: String toString()>,0,"{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    appendUnless(""0"", msg, "", actionButton="", buttonStateToString(getActionButton()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        appendUnless(i, msg, "", id["" + i + ""]="", getPointerId(i));
        float x = getX(i);
        float y = getY(i);
        if (!DEBUG_CONCISE_TOSTRING || x != 0f || y != 0f) {
            msg.append("", x["").append(i).append(""]="").append(x);
            msg.append("", y["").append(i).append(""]="").append(y);
        }
        appendUnless(TOOL_TYPE_SYMBOLIC_NAMES.get(TOOL_TYPE_FINGER), msg, "", toolType["" + i + ""]="", toolTypeToString(getToolType(i)));
    }
    appendUnless(""0"", msg, "", buttonState="", MotionEvent.buttonStateToString(getButtonState()));
    appendUnless(""0"", msg, "", metaState="", KeyEvent.metaStateToString(getMetaState()));
    appendUnless(""0"", msg, "", flags=0x"", Integer.toHexString(getFlags()));
    appendUnless(""0"", msg, "", edgeFlags=0x"", Integer.toHexString(getEdgeFlags()));
    appendUnless(1, msg, "", pointerCount="", pointerCount);
    appendUnless(0, msg, "", historySize="", getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    if (!DEBUG_CONCISE_TOSTRING) {
        msg.append("", downTime="").append(getDownTime());
        msg.append("", deviceId="").append(getDeviceId());
        msg.append("", source=0x"").append(Integer.toHexString(getSource()));
    }
    msg.append("" }"");
    return msg.toString();
}","{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    appendUnless(""0"", msg, "", actionButton="", buttonStateToString(getActionButton()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        appendUnless(i, msg, "", id["" + i + ""]="", getPointerId(i));
        float x = getX(i);
        float y = getY(i);
        if (!DEBUG_CONCISE_TOSTRING || x != 0f || y != 0f) {
            msg.append("", x["").append(i).append(""]="").append(x);
            msg.append("", y["").append(i).append(""]="").append(y);
        }
        appendUnless(TOOL_TYPE_SYMBOLIC_NAMES.get(TOOL_TYPE_FINGER), msg, "", toolType["" + i + ""]="", toolTypeToString(getToolType(i)));
    }
    appendUnless(""0"", msg, "", buttonState="", MotionEvent.buttonStateToString(getButtonState()));
    appendUnless(classificationToString(CLASSIFICATION_NONE), msg, "", classification="", classificationToString(getClassification()));
    appendUnless(""0"", msg, "", metaState="", KeyEvent.metaStateToString(getMetaState()));
    appendUnless(""0"", msg, "", flags=0x"", Integer.toHexString(getFlags()));
    appendUnless(""0"", msg, "", edgeFlags=0x"", Integer.toHexString(getEdgeFlags()));
    appendUnless(1, msg, "", pointerCount="", pointerCount);
    appendUnless(0, msg, "", historySize="", getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    if (!DEBUG_CONCISE_TOSTRING) {
        msg.append("", downTime="").append(getDownTime());
        msg.append("", deviceId="").append(getDeviceId());
        msg.append("", source=0x"").append(Integer.toHexString(getSource()));
        msg.append("", displayId="").append(getDisplayId());
    }
    msg.append("" }"");
    return msg.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An invocation of a new method (classificationToString(getClassification())) is introduced and another new method (getDisplayId()) is used inside the conditionally executed code. This results in a change to the return statement as well as other statements inside the method, so the code change type is 1,4.","The changes include additional information in the string being returned (classification and displayId details). This means the method will return a different value in the later version, and therefore the CI type is 1."
615,<android.app.Activity: boolean isLocalVoiceInteractionSupported()>,28,29,<android.app.Activity: boolean isLocalVoiceInteractionSupported()>,<android.app.Activity: boolean isLocalVoiceInteractionSupported()>,0,"{
    try {
        return ActivityManager.getService().supportsLocalVoiceInteraction();
    } catch (RemoteException re) {
    }
    return false;
}","{
    try {
        return ActivityTaskManager.getService().supportsLocalVoiceInteraction();
    } catch (RemoteException re) {
    }
    return false;
}",1,"/**
 * Queries whether the currently enabled voice interaction service supports returning
 * a voice interactor for use by the activity. This is valid only for the duration of the
 * activity.
 *
 * @return whether the current voice interaction service supports local voice interaction
 */
","/**
 * Queries whether the currently enabled voice interaction service supports returning
 * a voice interactor for use by the activity. This is valid only for the duration of the
 * activity.
 *
 * @return whether the current voice interaction service supports local voice interaction
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the service class from which `supportsLocalVoiceInteraction` is being called (from `ActivityManager.getService()` to `ActivityTaskManager.getService()`), so the code change type is 5.","Although the underlying service class has changed, the API method `supportsLocalVoiceInteraction()` remains the same and there is no change in its call parameters or return type; furthermore, the try-catch block handles the `RemoteException` the same way and the same default value is returned in case of an exception. Therefore, this change does not result in a CI, and the CI type is 0."
616,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>",28,29,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>","<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String,CancellationSignal)>",0,"{
    if (mTables == null) {
        return null;
    }
    if (mStrict && selection != null && selection.length() > 0) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        String sqlForValidation = buildQuery(projectionIn, ""("" + selection + "")"", groupBy, having, sortOrder, limit);
        // will throw if query is invalid
        db.validateSql(sqlForValidation, cancellationSignal);
    }
    String sql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Performing query: "" + sql);
    }
    return db.rawQueryWithFactory(mFactory, sql, selectionArgs, SQLiteDatabase.findEditTable(mTables), // will throw if query is invalid
    cancellationSignal);
}","{
    if (mTables == null) {
        return null;
    }
    final String sql;
    final String unwrappedSql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (mStrict && selection != null && selection.length() > 0) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        // NOTE: The ordering of the below operations is important; we must
        // execute the wrapped query to ensure the untrusted clause has been
        // fully isolated.
        // Validate the unwrapped query
        // will throw if query is invalid
        db.validateSql(unwrappedSql, cancellationSignal);
        // Execute wrapped query for extra protection
        final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy, having, sortOrder, limit);
        sql = wrappedSql;
    } else {
        // Execute unwrapped query
        sql = unwrappedSql;
    }
    final String[] sqlArgs = selectionArgs;
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        if (Build.IS_DEBUGGABLE) {
            Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
        } else {
            Log.d(TAG, sql);
        }
    }
    return db.rawQueryWithFactory(mFactory, sql, sqlArgs, SQLiteDatabase.findEditTable(mTables), // will throw if query is invalid
    cancellationSignal);
}",1,"/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
","/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL {@code WHERE} clause (excluding the {@code WHERE}
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL {@code GROUP BY} clause (excluding the {@code GROUP BY}
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL {@code HAVING} clause (excluding the {@code HAVING} itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * {@code ORDER BY} clause (excluding the {@code ORDER BY} itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as {@code LIMIT} clause. Passing null denotes no {@code LIMIT} clause.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Changes include control dependency change due to modification in the 'if' condition block and restructuring of code; other statement changes due to the logging condition and how the SQL is being validated and built differently in the new version. Also, there is a change in how the result from buildQuery() is assigned to 'sql' variable and the introduction of new variable 'unwrappedSql' and 'wrappedSql' which shows a return statement change.","The return statement is changed because it now executes a different SQL query based on the new condition, and the API now returns a different Cursor object based on changes in how 'sql' is constructed which could potentially return a different value, hence the CI type is 1."
618,<android.widget.AbsSeekBar: Mode getThumbTintMode()>,28,29,<android.widget.AbsSeekBar: Mode getThumbTintMode()>,<android.widget.AbsSeekBar: Mode getThumbTintMode()>,0,"{
    return mThumbTintMode;
}","{
    return mThumbBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mThumbBlendMode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the thumb drawable,
 * if specified.
 *
 * @return the blending mode used to apply the tint to the thumb drawable
 * @attr ref android.R.styleable#SeekBar_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the thumb drawable,
 * if specified.
 *
 * @return the blending mode used to apply the tint to the thumb drawable
 * @attr ref android.R.styleable#SeekBar_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method's return statement has changed, and it is now contingent on the result of `BlendMode.blendModeToPorterDuffMode(mThumbBlendMode)`. Additionally, there is a change to the type of value the method returns, dictated by whether `mThumbBlendMode` is not `null`. Alongside these changes, a dependent API `BlendMode.blendModeToPorterDuffMode` is utilized in the late version, which does not exist in the early version. This indicates the change type is 1,5.","Given the different return statements, the late version of the API could potentially return different values or types, depending on the state of `mThumbBlendMode` and the functionality of `BlendMode.blendModeToPorterDuffMode`. Thus, the CI type is 1."
621,<android.provider.MediaStore.Audio.Media: Uri getContentUriForPath(String)>,28,29,<android.provider.MediaStore.Audio.Media: Uri getContentUriForPath(String)>,<android.provider.MediaStore.Audio.Media: Uri getContentUriForPath(String)>,0,"{
    for (String ep : EXTERNAL_PATHS) {
        if (path.startsWith(ep)) {
            return EXTERNAL_CONTENT_URI;
        }
    }
    return (path.startsWith(Environment.getExternalStorageDirectory().getPath()) ? EXTERNAL_CONTENT_URI : INTERNAL_CONTENT_URI);
}","{
    return getContentUri(getVolumeName(new File(path)));
}",1,,"/**
 * Get the content:// style URI for the given audio media file.
 *
 * @deprecated Apps may not have filesystem permissions to directly
 * access this path.
 */
",-1,,"[@Deprecated, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed entirely from a complex condition with a loop to a single method call, getContentUri(getVolumeName(new File(path))). Also, the logic to determine which content URI to return was redefined and now relies on a new method getVolumeName, indicating a change in dependent API, so the code change type is 1,5.","This change will make the API potentially return a different value since the logic on how the return value is determined has been altered, and this constitutes a Compatibility Issue of type 1."
622,<android.app.job.JobInfo.Builder: JobInfo build()>,28,29,<android.app.job.JobInfo.Builder: JobInfo build()>,<android.app.job.JobInfo.Builder: JobInfo build()>,0,"{
    // Allow jobs with no constraints - What am I, a database?
    if (!mHasEarlyConstraint && !mHasLateConstraint && mConstraintFlags == 0 && mNetworkRequest == null && mTriggerContentUris == null) {
        throw new IllegalArgumentException(""You're trying to build a job with no "" + ""constraints, this is not allowed."");
    }
    // Check that network estimates require network type
    if ((mNetworkDownloadBytes > 0 || mNetworkUploadBytes > 0) && mNetworkRequest == null) {
        throw new IllegalArgumentException(""Can't provide estimated network usage without requiring a network"");
    }
    // We can't serialize network specifiers
    if (mIsPersisted && mNetworkRequest != null && mNetworkRequest.networkCapabilities.getNetworkSpecifier() != null) {
        throw new IllegalArgumentException(""Network specifiers aren't supported for persistent jobs"");
    }
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic) {
        if (mMaxExecutionDelayMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
        }
        if (mMinLatencyMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
        }
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""periodic job"");
        }
    }
    if (mIsPersisted) {
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""persisted job"");
        }
        if (!mTransientExtras.isEmpty()) {
            throw new IllegalArgumentException(""Can't call setTransientExtras() on a "" + ""persisted job"");
        }
        if (mClipData != null) {
            throw new IllegalArgumentException(""Can't call setClipData() on a "" + ""persisted job"");
        }
    }
    if ((mFlags & FLAG_IMPORTANT_WHILE_FOREGROUND) != 0 && mHasEarlyConstraint) {
        throw new IllegalArgumentException(""An important while foreground job cannot "" + ""have a time delay"");
    }
    if (mBackoffPolicySet && (mConstraintFlags & CONSTRAINT_FLAG_DEVICE_IDLE) != 0) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    return new JobInfo(this);
}","{
    // Check that network estimates require network type
    if ((mNetworkDownloadBytes > 0 || mNetworkUploadBytes > 0) && mNetworkRequest == null) {
        throw new IllegalArgumentException(""Can't provide estimated network usage without requiring a network"");
    }
    // We can't serialize network specifiers
    if (mIsPersisted && mNetworkRequest != null && mNetworkRequest.networkCapabilities.getNetworkSpecifier() != null) {
        throw new IllegalArgumentException(""Network specifiers aren't supported for persistent jobs"");
    }
    // Check that a deadline was not set on a periodic job.
    if (mIsPeriodic) {
        if (mMaxExecutionDelayMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setOverrideDeadline() on a "" + ""periodic job."");
        }
        if (mMinLatencyMillis != 0L) {
            throw new IllegalArgumentException(""Can't call setMinimumLatency() on a "" + ""periodic job"");
        }
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""periodic job"");
        }
    }
    if (mIsPersisted) {
        if (mTriggerContentUris != null) {
            throw new IllegalArgumentException(""Can't call addTriggerContentUri() on a "" + ""persisted job"");
        }
        if (!mTransientExtras.isEmpty()) {
            throw new IllegalArgumentException(""Can't call setTransientExtras() on a "" + ""persisted job"");
        }
        if (mClipData != null) {
            throw new IllegalArgumentException(""Can't call setClipData() on a "" + ""persisted job"");
        }
    }
    if ((mFlags & FLAG_IMPORTANT_WHILE_FOREGROUND) != 0 && mHasEarlyConstraint) {
        throw new IllegalArgumentException(""An important while foreground job cannot "" + ""have a time delay"");
    }
    if (mBackoffPolicySet && (mConstraintFlags & CONSTRAINT_FLAG_DEVICE_IDLE) != 0) {
        throw new IllegalArgumentException(""An idle mode job will not respect any"" + "" back-off policy, so calling setBackoffCriteria with"" + "" setRequiresDeviceIdle is an error."");
    }
    return new JobInfo(this);
}",1,"/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
","/**
 * @return The job object to hand to the JobScheduler. This object is immutable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
623,<android.view.textclassifier.TextSelection.Request.Builder: Request build()>,28,29,<android.view.textclassifier.TextSelection.Request.Builder: Request build()>,<android.view.textclassifier.TextSelection.Request.Builder: Request build()>,0,"{
    return new Request(mText, mStartIndex, mEndIndex, mDefaultLocales, mDarkLaunchAllowed);
}","{
    return new Request(new SpannedString(mText), mStartIndex, mEndIndex, mDefaultLocales, mDarkLaunchAllowed, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns the request object.
 */
","/**
 * Builds and returns the request object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The change is in the return statement, where the mText parameter is now wrapped in a new `SpannedString()` call. Additionally, a conditional check for `mExtras` has been added to pass `Bundle.EMPTY` if `mExtras` is null or `mExtras` if it's not null. This is both a return statement change and an other statement changed because of the added conditional logic around `mExtras`, which is an argument change to the `Request` constructor. There is also a change to the dependent API because of the addition of the `mExtras` parameter (which is a change to the `Request` constructor's signature). Therefore, the code change types are 1, 4, and 5.","A new SpannedString object is created from mText, which could potentially alter the behavior since it's a different type being passed to the Request constructor, meaning the method could return a different value in the late version. Also, the inclusion of `mExtras` or `Bundle.EMPTY` based on the condition affects the returned `Request` object, leading to a potential difference in behavior. Thus, the CI type is 1."
624,<android.hardware.display.BrightnessConfiguration.Builder: BrightnessConfiguration build()>,28,29,<android.hardware.display.BrightnessConfiguration.Builder: BrightnessConfiguration build()>,<android.hardware.display.BrightnessConfiguration.Builder: BrightnessConfiguration build()>,0,"{
    if (mCurveLux == null || mCurveNits == null) {
        throw new IllegalStateException(""A curve must be set!"");
    }
    return new BrightnessConfiguration(mCurveLux, mCurveNits, mDescription);
}","{
    if (mCurveLux == null || mCurveNits == null) {
        throw new IllegalStateException(""A curve must be set!"");
    }
    return new BrightnessConfiguration(mCurveLux, mCurveNits, mCorrectionsByPackageName, mCorrectionsByCategory, mDescription);
}",1,"/**
 * Builds the {@link BrightnessConfiguration}.
 *
 * A brightness curve <b>must</b> be set before calling this.
 */
","/**
 * Builds the {@link BrightnessConfiguration}.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for BrightnessConfiguration in the return statement has different parameters, and this indicates that there is a new or modified dependent API being used in the return statement. Therefore, the code change type is 1,5.","The late version of the API has additional parameters in the BrightnessConfiguration constructor call (mCorrectionsByPackageName, mCorrectionsByCategory). This can lead to different behavior because the constructed object may now consider additional data that wasn't present in the early version. Consequently, the API can potentially return a different value, which corresponds to CI type 1."
625,<android.net.IpPrefix: InetAddress getAddress()>,28,29,<android.net.IpPrefix: InetAddress getAddress()>,<android.net.IpPrefix: InetAddress getAddress()>,0,"{
    try {
        return InetAddress.getByAddress(address);
    } catch (UnknownHostException e) {
        // array is the wrong length, but we check that in the constructor.
        return null;
    }
}","{
    try {
        return InetAddress.getByAddress(address);
    } catch (UnknownHostException e) {
        // array is the wrong length, but we check that in the constructor.
        throw new IllegalArgumentException(""Address is invalid"");
    }
}",1,"/**
 * Returns a copy of the first IP address in the prefix. Modifying the returned object does not
 * change this object's contents.
 *
 * @return the address in the form of a byte array.
 */
","/**
 * Returns a copy of the first IP address in the prefix. Modifying the returned object does not
 * change this object's contents.
 *
 * @return the address in the form of a byte array.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The exception handling changed from returning `null` to throwing a new `IllegalArgumentException`, so the code change type is 2.","The behavior of the API has changed in exception scenarios; it used to return `null`, but now it throws an exception. This change leads to a CI caused by potentially different exception handlings, reflected in CI type 2."
626,"<android.view.Choreographer: void doFrame(long,int)>",28,29,"<android.view.Choreographer: void doFrame(long,int)>","<android.view.Choreographer: void doFrame(long,int)>",0,"{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
            mDebugPrintNextFrameTimeDelta = false;
            Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
        }
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG_JANK) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG_JANK) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        if (mFPSDivisor > 1) {
            long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;
            if (timeSinceVsync < (mFrameIntervalNanos * mFPSDivisor) && timeSinceVsync > 0) {
                scheduleVsyncLocked();
                return;
            }
        }
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame"");
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}","{
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            // no work to do
            return;
        }
        if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
            mDebugPrintNextFrameTimeDelta = false;
            Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
        }
        long intendedFrameTimeNanos = frameTimeNanos;
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            if (DEBUG_JANK) {
                Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (mFrameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
            }
            frameTimeNanos = startNanos - lastFrameOffset;
        }
        if (frameTimeNanos < mLastFrameTimeNanos) {
            if (DEBUG_JANK) {
                Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
            }
            scheduleVsyncLocked();
            return;
        }
        if (mFPSDivisor > 1) {
            long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;
            if (timeSinceVsync < (mFrameIntervalNanos * mFPSDivisor) && timeSinceVsync > 0) {
                scheduleVsyncLocked();
                return;
            }
        }
        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame"");
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}",1,,,-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,,,,
628,"<com.android.server.SystemConfig: void readPermissions(File,int)>",28,29,"<com.android.server.SystemConfig: void readPermissions(File,int)>","<com.android.server.SystemConfig: void readPermissions(File,int)>",0,"{
    // Read permissions from given directory.
    if (!libraryDir.exists() || !libraryDir.isDirectory()) {
        if (permissionFlag == ALLOW_ALL) {
            Slog.w(TAG, ""No directory "" + libraryDir + "", skipping"");
        }
        return;
    }
    if (!libraryDir.canRead()) {
        Slog.w(TAG, ""Directory "" + libraryDir + "" cannot be read"");
        return;
    }
    // Iterate over the files in the directory and scan .xml files
    File platformFile = null;
    for (File f : libraryDir.listFiles()) {
        // We'll read platform.xml last
        if (f.getPath().endsWith(""etc/permissions/platform.xml"")) {
            platformFile = f;
            continue;
        }
        if (!f.getPath().endsWith("".xml"")) {
            Slog.i(TAG, ""Non-xml file "" + f + "" in "" + libraryDir + "" directory, ignoring"");
            continue;
        }
        if (!f.canRead()) {
            Slog.w(TAG, ""Permissions library file "" + f + "" cannot be read"");
            continue;
        }
        readPermissionsFromXml(f, permissionFlag);
    }
    // Read platform permissions last so it will take precedence
    if (platformFile != null) {
        readPermissionsFromXml(platformFile, permissionFlag);
    }
}","{
    // Read permissions from given directory.
    if (!libraryDir.exists() || !libraryDir.isDirectory()) {
        if (permissionFlag == ALLOW_ALL) {
            Slog.w(TAG, ""No directory "" + libraryDir + "", skipping"");
        }
        return;
    }
    if (!libraryDir.canRead()) {
        Slog.w(TAG, ""Directory "" + libraryDir + "" cannot be read"");
        return;
    }
    // Iterate over the files in the directory and scan .xml files
    File platformFile = null;
    for (File f : libraryDir.listFiles()) {
        if (!f.isFile()) {
            continue;
        }
        // We'll read platform.xml last
        if (f.getPath().endsWith(""etc/permissions/platform.xml"")) {
            platformFile = f;
            continue;
        }
        if (!f.getPath().endsWith("".xml"")) {
            Slog.i(TAG, ""Non-xml file "" + f + "" in "" + libraryDir + "" directory, ignoring"");
            continue;
        }
        if (!f.canRead()) {
            Slog.w(TAG, ""Permissions library file "" + f + "" cannot be read"");
            continue;
        }
        readPermissionsFromXml(f, permissionFlag);
    }
    // Read platform permissions last so it will take precedence
    if (platformFile != null) {
        readPermissionsFromXml(platformFile, permissionFlag);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,The change involves adding a condition to check if the current file is a file (if (!f.isFile())) before proceeding with further processing in the for loop. This is a change in the control dependency.,"The newly introduced check (if (!f.isFile())) will filter out any non-file entities (like directories), but since the subsequent checks were already looking for regular files by checking if the filenames end with "".xml"", this additional check does not alter the behavior with respect to which files will be processed - it only possibly prevents unnecessary warnings for non-files. There isn't any new or modified return value or exception handling that would affect the caller, so there would be no compatibility issue."
629,<android.net.http.HttpResponseCache: int getNetworkCount()>,28,29,<android.net.http.HttpResponseCache: int getNetworkCount()>,<android.net.http.HttpResponseCache: int getNetworkCount()>,0,"{
    return delegate.getNetworkCount();
}","{
    return mDelegate.getNetworkCount();
}",1,"/**
 * Returns the number of HTTP requests that required the network to either
 * supply a response or validate a locally cached response.
 */
","/**
 * Returns the number of HTTP requests that required the network to either
 * supply a response or validate a locally cached response.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change here is the renaming of a member variable from 'delegate' to 'mDelegate.' Therefore, the code change type is 4.","Since the method's behavior has not been altered in terms of logic, return values, exception handling, or control dependencies, no Compatibility Issue arises. The underlying functionality should remain the same assuming that 'delegate' and 'mDelegate' refer to the same object. Thus, the CI type is 0."
630,<android.os.StrictMode.AndroidBlockGuardPolicy: void onUnbufferedIO()>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void onUnbufferedIO()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onUnbufferedIO()>,0,"{
    if ((mPolicyMask & DETECT_UNBUFFERED_IO) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new UnbufferedIoViolation());
}","{
    if ((mThreadPolicyMask & DETECT_THREAD_UNBUFFERED_IO) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new UnbufferedIoViolation());
}",1,"// Not part of BlockGuard.Policy; just part of StrictMode:
","// Not part of BlockGuard.Policy; just part of StrictMode:
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The condition in the if-statement changed from checking `mPolicyMask & DETECT_UNBUFFERED_IO` to `mThreadPolicyMask & DETECT_THREAD_UNBUFFERED_IO`. However, the functionality intended to be performed (checking if the unbuffered I/O should be detected) remains the same, just using a different mask constant and potentially a different variable for the policy mask. Additionally, the dependent API (the constant DETECT_UNBUFFERED_IO replaced with DETECT_THREAD_UNBUFFERED_IO) changed, so the code change types are 3 and 5.","There is no Compatibility Issue since the overall structure of the code and the behavior it enforces (detecting unbuffered I/O violations) does not fundamentally change between versions. The method still checks a policy mask for unbuffered I/O, exits early in specific conditions, and handles a violation the same way. Therefore, despite the renaming of the constants and potential use of a different variable, the method's behavior is consistent between versions, leading to no CI."
633,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getTraversalBefore()>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getTraversalBefore()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getTraversalBefore()>,0,"{
    enforceSealed();
    return getNodeForAccessibilityId(mTraversalBefore);
}","{
    enforceSealed();
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mTraversalBefore);
}",1,"/**
 * Gets the node before which this one is visited during traversal. A screen-reader
 * must visit the content of this node before the content of the one it precedes.
 *
 * @return The succeeding node if such or <code>null</code>.
 *
 * @see #setTraversalBefore(android.view.View)
 * @see #setTraversalBefore(android.view.View, int)
 */
","/**
 * Gets the node before which this one is visited during traversal. A screen-reader
 * must visit the content of this node before the content of the one it precedes.
 *
 * @return The succeeding node if such or <code>null</code>.
 *
 * @see #setTraversalBefore(android.view.View)
 * @see #setTraversalBefore(android.view.View, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method 'getNodeForAccessibilityId' is called with different arguments between the two versions. The number of parameters has increased in the late version, so the code change types are 1 (return statement changed due to the increased number of parameters in the method call) and 5 (dependent API changed because the call to 'getNodeForAccessibilityId' now has different parameters).","As the method 'getNodeForAccessibilityId' is called with different arguments which can alter the behavior of the method, there is a potential that the API will return a different value, hence the CI type is 1."
634,<android.view.textclassifier.TextClassificationSession: void onSelectionEvent(SelectionEvent)>,28,29,<android.view.textclassifier.TextClassificationSession: void onSelectionEvent(SelectionEvent)>,<android.view.textclassifier.TextClassificationSession: void onSelectionEvent(SelectionEvent)>,0,"{
    checkDestroyed();
    Preconditions.checkNotNull(event);
    if (mEventHelper.sanitizeEvent(event)) {
        mDelegate.onSelectionEvent(event);
    }
}","{
    try {
        if (mEventHelper.sanitizeEvent(event)) {
            mDelegate.onSelectionEvent(event);
        }
    } catch (Exception e) {
        // Avoid crashing for event reporting.
        Log.e(LOG_TAG, ""Error reporting text classifier selection event"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,5",2,"The early version of the API does not have a try-catch block, while the late version wraps the code in a try-catch to handle any exceptions that may occur. Also, the direct call to checkDestroyed() and Preconditions.checkNotNull(event) is removed which indicates dependent API change as well, so the change types are 2, 3, and 5.","The late version catches all exceptions that may occur during the method execution and logs an error without rethrowing the exception, as opposed to the early version where an unchecked exception could propagate up the call stack. This change potentially alters the exceptions that the API may throw when an error occurs, leading to a CI caused by potential different exception handlings, hence the CI type is 2."
635,<android.inputmethodservice.InputMethodService: boolean shouldOfferSwitchingToNextInputMethod()>,28,29,<android.inputmethodservice.InputMethodService: boolean shouldOfferSwitchingToNextInputMethod()>,<android.inputmethodservice.InputMethodService: boolean shouldOfferSwitchingToNextInputMethod()>,0,"{
    return mImm.shouldOfferSwitchingToNextInputMethodInternal(mToken);
}","{
    return mPrivOps.shouldOfferSwitchingToNextInputMethod();
}",1,"/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 */
","/**
 * Returns true if the current IME needs to offer the users ways to switch to a next input
 * method (e.g. a globe key.).
 * When an IME sets supportsSwitchingToNextInputMethod and this method returns true,
 * the IME has to offer ways to to invoke {@link #switchToNextInputMethod} accordingly.
 * <p> Note that the system determines the most appropriate next input method
 * and subtype in order to provide the consistent user experience in switching
 * between IMEs and subtypes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method now calls `mPrivOps.shouldOfferSwitchingToNextInputMethod()` instead of `mImm.shouldOfferSwitchingToNextInputMethodInternal(mToken)`, indicating that the underlying API on which this method depends has changed. However, this does not necessarily lead to a behavior change from the perspective of the method's caller, assuming the new dependent API is functionally equivalent. The code change type is 5.","As the change is only related to the dependent API, and there is no direct implication that this will lead to different behaviors (assuming the new implementation is designed to produce the same result), there does not seem to be a Compatibility Issue based on the information provided."
637,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>",28,29,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    // Ensure that any SharedPreferences writes have landed *before*
    // we potentially try to back up the underlying files directly.
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data, quotaBytes, transportFlags));
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // ... and then again after, as in the doBackup() case
        waitForSharedPrefs();
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opComplete(token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}","{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    // Ensure that any SharedPreferences writes have landed *before*
    // we potentially try to back up the underlying files directly.
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data, quotaBytes, transportFlags));
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // ... and then again after, as in the doBackup() case
        waitForSharedPrefs();
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the code is calling `callbackBinder.opCompleteForUser(getBackupUserId(), token, 0)` instead of `callbackBinder.opComplete(token, 0)` in the `finally` block, indicating a change in the dependent API being called, so the code change type is 4,5.","There is no compatibility issue with respect to return values or exceptions thrown because the change does not affect the control flow of the method nor does it introduce new exceptions or return statements. Therefore, there's no compatibility issue, which corresponds to 0."
639,<android.content.ContentValues: Boolean getAsBoolean(String)>,28,29,<android.content.ContentValues: Boolean getAsBoolean(String)>,<android.content.ContentValues: Boolean getAsBoolean(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            // false.
            return Boolean.valueOf(value.toString()) || ""1"".equals(value);
        } else if (value instanceof Number) {
            return ((Number) value).intValue() != 0;
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Boolean: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return (Boolean) value;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            // false.
            return Boolean.valueOf(value.toString()) || ""1"".equals(value);
        } else if (value instanceof Number) {
            return ((Number) value).intValue() != 0;
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Boolean: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Boolean.
 *
 * @param key the value to get
 * @return the Boolean value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Boolean.
 *
 * @param key the value to get
 * @return the Boolean value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The internal implementation changed from using `mValues.get(key)` to using `mMap.get(key)` to obtain the object associated with the specified key. Since the change is isolated to the internal data representation and assuming `mMap` is equivalent to `mValues`, there is no observable behavior difference expected from this particular change. Therefore, the code change type is 4.","There is no Compatibility Issue since both versions return the same type of value (Boolean) based on the same key, and the exception handling, control flow, return statements, and behavior are identical."
640,<android.service.autofill.SaveInfo.Builder: Builder setFlags(int)>,28,29,<android.service.autofill.SaveInfo.Builder: Builder setFlags(int)>,<android.service.autofill.SaveInfo.Builder: Builder setFlags(int)>,0,"{
    throwIfDestroyed();
    mFlags = Preconditions.checkFlagsArgument(flags, FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE | FLAG_DONT_SAVE_ON_FINISH);
    return this;
}","{
    throwIfDestroyed();
    mFlags = Preconditions.checkFlagsArgument(flags, FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE | FLAG_DONT_SAVE_ON_FINISH | FLAG_DELAY_SAVE);
    return this;
}",1,"/**
 * Sets flags changing the save behavior.
 *
 * @param flags {@link #FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE},
 * {@link #FLAG_DONT_SAVE_ON_FINISH}, or {@code 0}.
 * @return This builder.
 */
","/**
 * Sets flags changing the save behavior.
 *
 * @param flags {@link #FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE},
 * {@link #FLAG_DONT_SAVE_ON_FINISH}, {@link #FLAG_DELAY_SAVE}, or {@code 0}.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The method setFlags(int) now accepts an additional flag, FLAG_DELAY_SAVE, as part of the input flags argument, which is a change in the assignment statement of mFlags. This is an ""Other statement changed"" as well as a ""Return statement changed"" due to a different value potentially being assigned to mFlags.","This alteration potentially leads to different return values, as the set of flags that will be checked is different and the resulting mFlags could now include or exclude the new FLAG_DELAY_SAVE. Thus, the CI type is 1 (CI caused by potential different return values or types)."
641,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,28,29,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,0,"{
    final WindowInsets result = new WindowInsets(this);
    result.mDisplayCutout = null;
    result.mDisplayCutoutConsumed = true;
    return result;
}","{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null);
}",1,"/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
","/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement was changed, with the construction and population of a new WindowInsets object being modified, and since the method of instantiation has changed, so the code change types are 1 and 4.","The change in how the WindowInsets object is instantiated (no longer simply nullifying mDisplayCutout and setting mDisplayCutoutConsumed, but rather using a new set of parameters) could lead to the API returning a WindowInsets object with different properties, hence the CI type is 1."
642,"<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>",28,29,"<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void registerNetworkCallback(NetworkRequest,PendingIntent)>",0,"{
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}","{
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}",1,"/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 */
","/**
 * Registers a PendingIntent to be sent when a network is available which satisfies the given
 * {@link NetworkRequest}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #unregisterNetworkCallback(android.app.PendingIntent)}.
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 */
",-1,[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)],[@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)],-1,-1,-1,-1,-1,-1,4,0,"A call to the method 'printStackTrace()' has been added at the beginning of the late version of the method execution, so the code change type is 4.","The addition of 'printStackTrace()' does not affect the method's behavior in terms of its output values or exception handling. It merely logs the current stack trace for debugging purposes. Thus, there is no Compatibility Issue, and the CI type is 0."
643,<android.bluetooth.le.ScanFilter: boolean matches(ScanResult)>,28,29,<android.bluetooth.le.ScanFilter: boolean matches(ScanResult)>,<android.bluetooth.le.ScanFilter: boolean matches(ScanResult)>,0,"{
    if (scanResult == null) {
        return false;
    }
    BluetoothDevice device = scanResult.getDevice();
    // Device match.
    if (mDeviceAddress != null && (device == null || !mDeviceAddress.equals(device.getAddress()))) {
        return false;
    }
    ScanRecord scanRecord = scanResult.getScanRecord();
    // Scan record is null but there exist filters on it.
    if (scanRecord == null && (mDeviceName != null || mServiceUuid != null || mManufacturerData != null || mServiceData != null)) {
        return false;
    }
    // Local name match.
    if (mDeviceName != null && !mDeviceName.equals(scanRecord.getDeviceName())) {
        return false;
    }
    // UUID match.
    if (mServiceUuid != null && !matchesServiceUuids(mServiceUuid, mServiceUuidMask, scanRecord.getServiceUuids())) {
        return false;
    }
    // Service data match
    if (mServiceDataUuid != null) {
        if (!matchesPartialData(mServiceData, mServiceDataMask, scanRecord.getServiceData(mServiceDataUuid))) {
            return false;
        }
    }
    // Manufacturer data match.
    if (mManufacturerId >= 0) {
        if (!matchesPartialData(mManufacturerData, mManufacturerDataMask, scanRecord.getManufacturerSpecificData(mManufacturerId))) {
            return false;
        }
    }
    // All filters match.
    return true;
}","{
    if (scanResult == null) {
        return false;
    }
    BluetoothDevice device = scanResult.getDevice();
    // Device match.
    if (mDeviceAddress != null && (device == null || !mDeviceAddress.equals(device.getAddress()))) {
        return false;
    }
    ScanRecord scanRecord = scanResult.getScanRecord();
    // Scan record is null but there exist filters on it.
    if (scanRecord == null && (mDeviceName != null || mServiceUuid != null || mManufacturerData != null || mServiceData != null || mServiceSolicitationUuid != null)) {
        return false;
    }
    // Local name match.
    if (mDeviceName != null && !mDeviceName.equals(scanRecord.getDeviceName())) {
        return false;
    }
    // UUID match.
    if (mServiceUuid != null && !matchesServiceUuids(mServiceUuid, mServiceUuidMask, scanRecord.getServiceUuids())) {
        return false;
    }
    // solicitation UUID match.
    if (mServiceSolicitationUuid != null && !matchesServiceSolicitationUuids(mServiceSolicitationUuid, mServiceSolicitationUuidMask, scanRecord.getServiceSolicitationUuids())) {
        return false;
    }
    // Service data match
    if (mServiceDataUuid != null) {
        if (!matchesPartialData(mServiceData, mServiceDataMask, scanRecord.getServiceData(mServiceDataUuid))) {
            return false;
        }
    }
    // Manufacturer data match.
    if (mManufacturerId >= 0) {
        if (!matchesPartialData(mManufacturerData, mManufacturerDataMask, scanRecord.getManufacturerSpecificData(mManufacturerId))) {
            return false;
        }
    }
    // All filters match.
    return true;
}",1,"/**
 * Check if the scan filter matches a {@code scanResult}. A scan result is considered as a match
 * if it matches all the field filters.
 */
","/**
 * Check if the scan filter matches a {@code scanResult}. A scan result is considered as a match
 * if it matches all the field filters.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There has been a control dependency change in the 'if' condition statement, where `mServiceSolicitationUuid != null` has been added to the condition that checks if the scan record is null. The body of an earlier 'if' condition has been extended with an additional check for service solicitation UUID match, which is a new feature in the late version. It is categorized as control dependency change (3) and other statement changed (4) because of the new 'if' block added for the service solicitation UUID matching logic.","There is no Compatibility Issue. The change in the control dependency and newly added statements do not introduce any different exceptions or return values since the return statements and exception handling remain the same. The additional condition just introduces another layer of filtering, which would not change the behavior of the method for code that was originally compatible with the earlier API version, as it would have never encountered a scan result with a service solicitation UUID to be matched."
644,<android.util.ArraySet: E valueAt(int)>,28,29,<android.util.ArraySet: E valueAt(int)>,<android.util.ArraySet: E valueAt(int)>,0,"{
    return (E) mArray[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return valueAtUnchecked(index);
}",1,"/**
 * Return the value at the given index in the array.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value stored at the given index.
 */
","/**
 * Return the value at the given index in the array.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value stored at the given index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","In the late implementation, a new control structure (if statement) has been introduced that checks the index against mSize. Additionally, there is an exception handling statement change with the introduction of a throw for ArrayIndexOutOfBoundsException. Furthermore, the return statement has been changed from directly accessing the array to using valueAtUnchecked(index) method. Therefore, the code change types are 1, 2, and 3.","Due to the additionally introduced control dependency (if statement that can throw an ArrayIndexOutOfBoundsException) and the change of the return statement to use another method (valueAtUnchecked), there is the potential for both a different value to be returned and a different exception to be thrown. This leads to CI types 1 (potential different return values or types) and 2 (potential different exception handlings)."
645,<android.service.autofill.FillResponse: String toString()>,28,29,<android.service.autofill.FillResponse: String toString()>,<android.service.autofill.FillResponse: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    return builder.append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    if (mUserData != null) {
        builder.append("", userData="").append(mUserData);
    }
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional block to check and append `mUserData` to the `StringBuilder` has been added to the late version. The rest of the method remains unchanged. This is classified as 'Other statement changed' (code change type is 4) as it's neither a return statement, exception handling, control dependency, nor a dependent API change. It's an additional statement added to a `toString()` method.","This change does not introduce a Compatibility Issue because the `toString()` method is designed to return a human-readable string representation of the object, and it does not affect the object's behavior or the results of other API methods. It is generally used for logging or debugging purposes, and the addition of new information to this representation does not alter the functional behavior of the API. Therefore, there is no potential Compatibility Issue (the CI situation is 0)."
646,<android.print.PrintFileDocumentAdapter.WriteFileAsyncTask: Void doInBackground(Void)>,28,29,<android.print.PrintFileDocumentAdapter.WriteFileAsyncTask: Void doInBackground(Void)>,<android.print.PrintFileDocumentAdapter.WriteFileAsyncTask: Void doInBackground(Void)>,0,"{
    try (InputStream in = new FileInputStream(mFile);
        OutputStream out = new FileOutputStream(mDestination.getFileDescriptor())) {
        FileUtils.copy(in, out, null, mCancellationSignal);
    } catch (OperationCanceledException e) {
    // Ignored; already handled below
    } catch (IOException e) {
        Log.e(LOG_TAG, ""Error writing data!"", e);
        mResultCallback.onWriteFailed(mContext.getString(R.string.write_fail_reason_cannot_write));
    }
    return null;
}","{
    try (InputStream in = new FileInputStream(mFile);
        OutputStream out = new FileOutputStream(mDestination.getFileDescriptor())) {
        FileUtils.copy(in, out, mCancellationSignal, null, null);
    } catch (OperationCanceledException e) {
    // Ignored; already handled below
    } catch (IOException e) {
        Log.e(LOG_TAG, ""Error writing data!"", e);
        mResultCallback.onWriteFailed(mContext.getString(R.string.write_fail_reason_cannot_write));
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The parameters of the FileUtils.copy() method changed, but the function's behavior related to the API's return values or exception handling doesn't seem to be affected as the exceptions it catches and the return value remain the same.","There is no Compatibility Issue detected since the changes made do not affect the method's return values or exception handling behavior. The try-catch blocks remain unchanged, and the method still returns null regardless of the version."
647,"<android.view.View: boolean isOnScrollbar(float,float)>",28,29,"<android.view.View: boolean isOnScrollbar(float,float)>","<android.view.View: boolean isOnScrollbar(float,float)>",0,"{
    if (mScrollCache == null) {
        return false;
    }
    x += getScrollX();
    y += getScrollY();
    if (isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden()) {
        final Rect touchBounds = mScrollCache.mScrollBarTouchBounds;
        getVerticalScrollBarBounds(null, touchBounds);
        if (touchBounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    if (isHorizontalScrollBarEnabled()) {
        final Rect touchBounds = mScrollCache.mScrollBarTouchBounds;
        getHorizontalScrollBarBounds(null, touchBounds);
        if (touchBounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    return false;
}","{
    if (mScrollCache == null) {
        return false;
    }
    x += getScrollX();
    y += getScrollY();
    final boolean canScrollVertically = computeVerticalScrollRange() > computeVerticalScrollExtent();
    if (isVerticalScrollBarEnabled() && !isVerticalScrollBarHidden() && canScrollVertically) {
        final Rect touchBounds = mScrollCache.mScrollBarTouchBounds;
        getVerticalScrollBarBounds(null, touchBounds);
        if (touchBounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    final boolean canScrollHorizontally = computeHorizontalScrollRange() > computeHorizontalScrollExtent();
    if (isHorizontalScrollBarEnabled() && canScrollHorizontally) {
        final Rect touchBounds = mScrollCache.mScrollBarTouchBounds;
        getHorizontalScrollBarBounds(null, touchBounds);
        if (touchBounds.contains((int) x, (int) y)) {
            return true;
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"There are additional condition checks introduced in the late version for both vertical and horizontal scroll bars by evaluating `canScrollVertically` and `canScrollHorizontally` which are based on the comparison of the scroll ranges and extents. These changes fall under control dependency change, so the code change type is 3.","The additional conditions introduced could change the behavior of the method by potentially causing a different return value. Previously if scroll bars were enabled (and not hidden for vertical), the function could return true if the touch was within bounds. Now, there is the additional check to see if the view can actually scroll; if it cannot scroll further, even if the touch is on the scrollbar, the function will return false. Thus, there is a Compatibility Issue caused by potential different return values, and the CI type is 1."
650,<android.net.Network: SocketFactory getSocketFactory()>,28,29,<android.net.Network: SocketFactory getSocketFactory()>,<android.net.Network: SocketFactory getSocketFactory()>,0,"{
    if (mNetworkBoundSocketFactory == null) {
        synchronized (mLock) {
            if (mNetworkBoundSocketFactory == null) {
                mNetworkBoundSocketFactory = new NetworkBoundSocketFactory(netId);
            }
        }
    }
    return mNetworkBoundSocketFactory;
}","{
    if (mNetworkBoundSocketFactory == null) {
        synchronized (mLock) {
            if (mNetworkBoundSocketFactory == null) {
                mNetworkBoundSocketFactory = new NetworkBoundSocketFactory();
            }
        }
    }
    return mNetworkBoundSocketFactory;
}",1,"/**
 * Returns a {@link SocketFactory} bound to this network.  Any {@link Socket} created by
 * this factory will have its traffic sent over this {@code Network}.  Note that if this
 * {@code Network} ever disconnects, this factory and any {@link Socket} it produced in the
 * past or future will cease to work.
 *
 * @return a {@link SocketFactory} which produces {@link Socket} instances bound to this
 * {@code Network}.
 */
","/**
 * Returns a {@link SocketFactory} bound to this network.  Any {@link Socket} created by
 * this factory will have its traffic sent over this {@code Network}.  Note that if this
 * {@code Network} ever disconnects, this factory and any {@link Socket} it produced in the
 * past or future will cease to work.
 *
 * @return a {@link SocketFactory} which produces {@link Socket} instances bound to this
 * {@code Network}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The constructor call for NetworkBoundSocketFactory has changed; it no longer takes the parameter netId. This is a change in the dependent API, so the code change type is 5.","Even though there's a change in how the NetworkBoundSocketFactory object is constructed, there's no indication that the behavior of the getSocketFactory() method's returned object has changed. There's no Compatibility Issue here since the method still returns an instance of NetworkBoundSocketFactory, hence CI type is 0."
651,<android.util.Half: float toFloat(short)>,28,29,<android.util.Half: float toFloat(short)>,<android.util.Half: float toFloat(short)>,0,"{
    int bits = h & 0xffff;
    int s = bits & FP16_SIGN_MASK;
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0) {
        // Denormal or 0
        if (m != 0) {
            // Convert denorm fp16 into normalized fp32
            float o = Float.intBitsToFloat(FP32_DENORMAL_MAGIC + m);
            o -= FP32_DENORMAL_FLOAT;
            return s == 0 ? o : -o;
        }
    } else {
        outM = m << 13;
        if (e == 0x1f) {
            // Infinite or NaN
            outE = 0xff;
        } else {
            outE = e - FP16_EXPONENT_BIAS + FP32_EXPONENT_BIAS;
        }
    }
    int out = (s << 16) | (outE << FP32_EXPONENT_SHIFT) | outM;
    return Float.intBitsToFloat(out);
}","{
    int bits = h & 0xffff;
    int s = bits & FP16_SIGN_MASK;
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0) {
        // Denormal or 0
        if (m != 0) {
            // Convert denorm fp16 into normalized fp32
            float o = Float.intBitsToFloat(FP32_DENORMAL_MAGIC + m);
            o -= FP32_DENORMAL_FLOAT;
            return s == 0 ? o : -o;
        }
    } else {
        outM = m << 13;
        if (e == 0x1f) {
            // Infinite or NaN
            outE = 0xff;
            if (outM != 0) {
                // SNaNs are quieted
                outM |= FP32_QNAN_MASK;
            }
        } else {
            outE = e - FP16_EXPONENT_BIAS + FP32_EXPONENT_BIAS;
        }
    }
    int out = (s << 16) | (outE << FP32_EXPONENT_SHIFT) | outM;
    return Float.intBitsToFloat(out);
}",1,"/**
 * <p>Converts the specified half-precision float value into a
 * single-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is {@link #NaN}, the returned value is {@link Float#NaN}</li>
 * <li>If the input is {@link #POSITIVE_INFINITY} or
 * {@link #NEGATIVE_INFINITY}, the returned value is respectively
 * {@link Float#POSITIVE_INFINITY} or {@link Float#NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is +/-0.0f</li>
 * <li>Otherwise, the returned value is a normalized single-precision float value</li>
 * </ul>
 *
 * @param h The half-precision float value to convert to single-precision
 * @return A normalized single-precision float value
 */
","/**
 * <p>Converts the specified half-precision float value into a
 * single-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is {@link #NaN}, the returned value is {@link Float#NaN}</li>
 * <li>If the input is {@link #POSITIVE_INFINITY} or
 * {@link #NEGATIVE_INFINITY}, the returned value is respectively
 * {@link Float#POSITIVE_INFINITY} or {@link Float#NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is +/-0.0f</li>
 * <li>Otherwise, the returned value is a normalized single-precision float value</li>
 * </ul>
 *
 * @param h The half-precision float value to convert to single-precision
 * @return A normalized single-precision float value
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional if statement inside an existing control statement that modifies the outM variable when certain conditions are met (checking for signaling NaNs and quieting them). This additional check does not introduce a new control structure but alters an existing one specifically for a signaling NaN case. Hence, the code change type falls under 4 as an 'Other statement changed'.","The addition does not change the return type or general exception handling mechanism; it only affects the internal representation of a specific NaN case (signaling NaNs converted to quiet NaNs). The intended functionality and behavior from the point of view of the API user remain the same, that is when called with a signaling NaN it will now return a quiet NaN, which is still within the expected behavior of dealing with NaN values. Thus, no compatibility issue arises due to this change regarding the return value or the exception handling. Therefore, the CI type is 0."
652,"<android.app.Dialog: boolean onPreparePanel(int,View,Menu)>",28,29,"<android.app.Dialog: boolean onPreparePanel(int,View,Menu)>","<android.app.Dialog: boolean onPreparePanel(int,View,Menu)>",0,"{
    if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
        return onPrepareOptionsMenu(menu) && menu.hasVisibleItems();
    }
    return true;
}","{
    if (featureId == Window.FEATURE_OPTIONS_PANEL) {
        return onPrepareOptionsMenu(menu) && menu.hasVisibleItems();
    }
    return true;
}",1,"/**
 * @see Activity#onPreparePanel(int, View, Menu)
 */
","/**
 * @see Activity#onPreparePanel(int, View, Menu)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed because the condition in the if statement has been simplified, the check for `menu != null` has been removed. This change type is 3.","There is no compatibility issue caused by this change because the original check `(menu != null)` was redundant in determining the return value, as both `onPrepareOptionsMenu(menu)` and `menu.hasVisibleItems()` would require `menu` to be non-null to avoid a NullPointerException. No new paths or outcomes are introduced by the change, so the behavior remains consistent between the two versions. Hence, the CI type is 0."
653,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,28,29,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.uncanonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
","/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
",-1,[@Nullable],"[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"1,4",0,"A pair of new try-catch control structures with return statement inside and a new check for mWrapped has been added, so there is an 'Other statement changed' (4). Also, the return statement inside the new try-catch could potentially return a different value. Hence, there is also 'Return statement changed' (1). The structure of the existing try-catch-finally blocks remains unchanged.","The newly introduced try-catch does not lead to a Compatibility Issue because it returns `null` in the catch block, which aligns with the behavior of the catch block in the existing code. The logic for the case when mWrapped is not null is newly introduced; however, this doesn't constitute a Compatibility Issue as it simply calls a method on mWrapped if it is present, and if not, the old logic will be executed, ensuring any earlier behavior remains possible. The 'return' behavior in successful and exceptional cases remains consistent between versions as both versions return 'null' when RemoteException is caught. Thus, there is 'No Compatibility Issue' (0)."
654,<android.app.Activity: ComponentName getCallingActivity()>,28,29,<android.app.Activity: ComponentName getCallingActivity()>,<android.app.Activity: ComponentName getCallingActivity()>,0,"{
    try {
        return ActivityManager.getService().getCallingActivity(mToken);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return ActivityTaskManager.getService().getCallingActivity(mToken);
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Return the name of the activity that invoked this activity.  This is
 * who the data in {@link #setResult setResult()} will be sent to.  You
 * can use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.
 *
 * @return The ComponentName of the activity that will receive your
 * reply, or null if none.
 */
","/**
 * Return the name of the activity that invoked this activity.  This is
 * who the data in {@link #setResult setResult()} will be sent to.  You
 * can use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.
 *
 * @return The ComponentName of the activity that will receive your
 * reply, or null if none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The change here is that the early version uses `ActivityManager.getService()` to obtain the service and the late version uses `ActivityTaskManager.getService()` for the same purpose. Both have the same `getCallingActivity(mToken)` called on the obtained service. This is a Dependent API change, so the code change type is 5.","There is no change in the return statement or exception handling; the change is restricted to internal service acquisition without altering the method's external behavior. Thus, there is no Compatibility Issue, and the CI type is 0."
655,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,28,29,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,<android.content.ContentResolver: List<UriPermission> getPersistedUriPermissions()>,0,"{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return UriGrantsManager.getService().getUriPermissions(mPackageName, true, /* incoming */
        true).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */
","/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from ActivityManager.getService().getPersistedUriPermissions(...) to UriGrantsManager.getService().getUriPermissions(...) with additional parameters for the method call, so the code change type is 5.","Both versions throw the same exception and return the same type. Since the signature of the method did not change, and the method seems to be performing the same higher-level operation from an API consumer's point of view, no compatibility issue is detected due to the dependent API change. Therefore, the CI type is 0."
656,"<android.text.format.Formatter: String formatFileSize(Context,long)>",28,29,"<android.text.format.Formatter: String formatFileSize(Context,long)>","<android.text.format.Formatter: String formatFileSize(Context,long)>",0,"{
    if (context == null) {
        return """";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SI_UNITS);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}","{
    return formatFileSize(context, sizeBytes, FLAG_SI_UNITS);
}",1,"/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * <p>As of O, the prefixes are used in their standard meanings in the SI system, so kB = 1000
 * bytes, MB = 1,000,000 bytes, etc.</p>
 *
 * <p class=""note"">In {@link android.os.Build.VERSION_CODES#N} and earlier, powers of 1024 are
 * used instead, with KB = 1024 bytes, MB = 1,048,576 bytes, etc.</p>
 *
 * <p>If the context has a right-to-left locale, the returned string is wrapped in bidi
 * formatting characters to make sure it's displayed correctly if inserted inside a
 * right-to-left string. (This is useful in cases where the unit strings, like ""MB"", are
 * left-to-right, but the locale is right-to-left.)</p>
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */
","/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * <p>As of O, the prefixes are used in their standard meanings in the SI system, so kB = 1000
 * bytes, MB = 1,000,000 bytes, etc.</p>
 *
 * <p class=""note"">In {@link android.os.Build.VERSION_CODES#N} and earlier, powers of 1024 are
 * used instead, with KB = 1024 bytes, MB = 1,048,576 bytes, etc.</p>
 *
 * <p>If the context has a right-to-left locale, the returned string is wrapped in bidi
 * formatting characters to make sure it's displayed correctly if inserted inside a
 * right-to-left string. (This is useful in cases where the unit strings, like ""MB"", are
 * left-to-right, but the locale is right-to-left.)</p>
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"There's a significant change in the late implementation where the code is now using a call to formatFileSize with specific flags instead of the previous logic. This change means there's no direct access or manipulation of resources or calling of 'bidiWrap'. It also indicates a change in the dependent API with different logic being used to determine the formatted file size, so the code change type is 4,5.","This change will likely result in a different return value because the method now delegates the formatting to a different method which may have its own implementation details. Hence, there's a potential Compatibility Issue due to the different return values, so the CI type is 1."
657,<android.util.SparseIntArray: int valueAt(int)>,28,29,<android.util.SparseIntArray: int valueAt(int)>,<android.util.SparseIntArray: int valueAt(int)>,0,"{
    return mValues[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return mValues[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseIntArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseIntArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",2,"There is an added conditional block with an exception throwing mechanism and a control dependency on an external configuration. Therefore, the code change types include 2 (exception handling statement changed), 3 (control dependency change), and 4 (other statement changed).","The late version can introduce a new `ArrayIndexOutOfBoundsException` that the early version does not throw due to the added conditional, leading to a potential different exception being thrown, and thus the CI type is 2."
659,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,28,29,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,0,"{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + "": run() previously called at "" + Log.getStackTraceString(mPreviousRunStacktrace));
        }
        mCurIntent = null;
        mDispatched = true;
        mPreviousRunStacktrace = new Throwable(""Previous stacktrace"");
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            intent.prepareToEnterProcess();
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}","{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + (mRunCalled ? "", run() has already been called"" : """"));
        }
        mCurIntent = null;
        mDispatched = true;
        mRunCalled = true;
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            intent.prepareToEnterProcess();
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists in replacing the log message detail ""run() previously called at "" with ""run() has already been called"" and removing the storing of Throwable into mPreviousRunStacktrace variable. Therefore, only an other statement has changed. The change type is 4.","This change does not affect the return value or exception handling of the method; it simply alters an internal state and logging detail that does not reflect a different outward behavior by the API. Hence, there is no Compatibility Issue in this case."
661,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",28,29,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",0,"{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        boolean isReprocess = request.isReprocess();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, isReprocess);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, isReprocess);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
662,<android.util.LongSparseArray: void removeAt(int)>,28,29,<android.util.LongSparseArray: void removeAt(int)>,<android.util.LongSparseArray: void removeAt(int)>,0,"{
    if (mValues[index] != DELETED) {
        mValues[index] = DELETED;
        mGarbage = true;
    }
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mValues[index] != DELETED) {
        mValues[index] = DELETED;
        mGarbage = true;
    }
}",1,"/**
 * Removes the mapping at the specified index.
 */
","/**
 * Removes the mapping at the specified index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An additional if condition has been added to throw an ArrayIndexOutOfBoundsException if a certain condition is met, and a control dependency has been added as it introduces an additional check (for index and UtilConfig.sThrowExceptionForUpperArrayOutOfBounds), so the code change types are 2,3.","Due to the additional if condition that throws a new ArrayIndexOutOfBoundsException, there is a change in the exception handling behaviour of the method. Now, it has the potential to throw an exception where it previously would not, so the CI type is 2."
664,<android.util.Base64OutputStream: void close()>,28,29,<android.util.Base64OutputStream: void close()>,<android.util.Base64OutputStream: void close()>,0,"{
    IOException thrown = null;
    try {
        flushBuffer();
        internalWrite(EMPTY, 0, 0, true);
    } catch (IOException e) {
        thrown = e;
    }
    try {
        if ((flags & Base64.NO_CLOSE) == 0) {
            out.close();
        } else {
            out.flush();
        }
    } catch (IOException e) {
        if (thrown != null) {
            thrown = e;
        }
    }
    if (thrown != null) {
        throw thrown;
    }
}","{
    IOException thrown = null;
    try {
        flushBuffer();
        internalWrite(EMPTY, 0, 0, true);
    } catch (IOException e) {
        thrown = e;
    }
    try {
        if ((flags & Base64.NO_CLOSE) == 0) {
            out.close();
        } else {
            out.flush();
        }
    } catch (IOException e) {
        if (thrown == null) {
            thrown = e;
        } else {
            thrown.addSuppressed(e);
        }
    }
    if (thrown != null) {
        throw thrown;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"An if-else statement within a catch block has been modified to add a suppressed exception to the thrown exception if it is not null, resulting in a change of type 4. Additionally, this modification affects how exceptions are handled which leads to a change of type 2.","The handling of the IOException has changed, causing the method to potentially throw an exception with additional suppressed exceptions attached to it. This change in exception handling introduces a potential Compatibility Issue of type 2 since this could affect the calling code that may not expect suppressed exceptions."
666,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo focusSearch(int)>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo focusSearch(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo focusSearch(int)>,0,"{
    enforceSealed();
    enforceValidFocusDirection(direction);
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    return AccessibilityInteractionClient.getInstance().focusSearch(mConnectionId, mWindowId, mSourceNodeId, direction);
}","{
    enforceSealed();
    enforceValidFocusDirection(direction);
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    return AccessibilityInteractionClient.getInstance().focusSearch(mConnectionId, mWindowId, mSourceNodeId, direction);
}",1,"/**
 * Searches for the nearest view in the specified direction that can take
 * the input focus.
 *
 * @param direction The direction. Can be one of:
 * {@link View#FOCUS_DOWN},
 * {@link View#FOCUS_UP},
 * {@link View#FOCUS_LEFT},
 * {@link View#FOCUS_RIGHT},
 * {@link View#FOCUS_FORWARD},
 * {@link View#FOCUS_BACKWARD}.
 *
 * @return The node info for the view that can take accessibility focus.
 */
","/**
 * Searches for the nearest view in the specified direction that can take
 * the input focus.
 *
 * @param direction The direction. Can be one of:
 * {@link View#FOCUS_DOWN},
 * {@link View#FOCUS_UP},
 * {@link View#FOCUS_LEFT},
 * {@link View#FOCUS_RIGHT},
 * {@link View#FOCUS_FORWARD},
 * {@link View#FOCUS_BACKWARD}.
 *
 * @return The node info for the view that can take accessibility focus.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The canPerformRequestOverConnection method call in the condition has its parameters changed, which indicates a change to the signature or behavior of a dependent API. So, the code change type is 5.","Despite the change in the canPerformRequestOverConnection method parameters, this does not directly affect the return value or the exception handling of the focusSearch method. This change only impacts the internal decision logic to return null or proceed with the call, but the overall method signature, return type, and exception handling remain the same. Therefore, there is no compatibility issue caused by potential different return values or types and no compatibility issue caused by potential different exception handlings. The CI type is 0."
667,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,28,29,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,<android.app.ActivityManager: ConfigurationInfo getDeviceConfigurationInfo()>,0,"{
    try {
        return getService().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getTaskService().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Get the device configuration attributes.
 */
","/**
 * Get the device configuration attributes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is that the dependent API used to obtain the device configuration info has been changed from getService().getDeviceConfigurationInfo() to getTaskService().getDeviceConfigurationInfo(). Hence, the change type is 5.","There's no change in the return type or exception handling of this method. The code change is only in how the service is being retrieved, which doesn't inherently lead to a compatibility issue. Therefore, the CI type is 0."
668,<android.content.Intent: int filterHashCode()>,28,29,<android.content.Intent: int filterHashCode()>,<android.content.Intent: int filterHashCode()>,0,"{
    int code = 0;
    if (mAction != null) {
        code += mAction.hashCode();
    }
    if (mData != null) {
        code += mData.hashCode();
    }
    if (mType != null) {
        code += mType.hashCode();
    }
    if (mPackage != null) {
        code += mPackage.hashCode();
    }
    if (mComponent != null) {
        code += mComponent.hashCode();
    }
    if (mCategories != null) {
        code += mCategories.hashCode();
    }
    return code;
}","{
    int code = 0;
    if (mAction != null) {
        code += mAction.hashCode();
    }
    if (mData != null) {
        code += mData.hashCode();
    }
    if (mType != null) {
        code += mType.hashCode();
    }
    if (mIdentifier != null) {
        code += mIdentifier.hashCode();
    }
    if (mPackage != null) {
        code += mPackage.hashCode();
    }
    if (mComponent != null) {
        code += mComponent.hashCode();
    }
    if (mCategories != null) {
        code += mCategories.hashCode();
    }
    return code;
}",1,"/**
 * Generate hash code that matches semantics of filterEquals().
 *
 * @return Returns the hash value of the action, data, type, class, and
 * categories.
 *
 * @see #filterEquals
 */
","/**
 * Generate hash code that matches semantics of filterEquals().
 *
 * @return Returns the hash value of the action, data, type, class, and
 * categories.
 *
 * @see #filterEquals
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The if-statement checking for mPackage is replaced by a check for mIdentifier, which is a change in the control dependency structure, implying that mPackage and mIdentifier are different fields. Besides this, there is also a change in the return statement because the hashCode computation might differ due to the change from mPackage to mIdentifier. Therefore, the code change type is 1,4.","Since the hashCode calculation now depends on a different field (mIdentifier instead of mPackage), the return value could potentially be different when the method is called with the same input but in different versions. Thus, the API may return different values which is a Compatibility Issue of type 1."
669,<android.app.Activity: boolean isInPictureInPictureMode()>,28,29,<android.app.Activity: boolean isInPictureInPictureMode()>,<android.app.Activity: boolean isInPictureInPictureMode()>,0,"{
    try {
        return ActivityManager.getService().isInPictureInPictureMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return ActivityTaskManager.getService().isInPictureInPictureMode(mToken);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Returns true if the activity is currently in picture-in-picture mode.
 * @see android.R.attr#supportsPictureInPicture
 *
 * @return True if the activity is in picture-in-picture mode.
 */
","/**
 * Returns true if the activity is currently in picture-in-picture mode.
 * @see android.R.attr#supportsPictureInPicture
 *
 * @return True if the activity is in picture-in-picture mode.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change involves calling a method on a different class: `ActivityManager.getService().isInPictureInPictureMode(mToken)` has been changed to `ActivityTaskManager.getService().isInPictureInPictureMode(mToken)`. Therefore, the dependent API changed, accounting for a change type of 5.","Assuming `ActivityTaskManager.getService().isInPictureInPictureMode(mToken)` is intended to serve the same purpose and behave the same way as `ActivityManager.getService().isInPictureInPictureMode(mToken)` in this context (which seems likely given they are both related to ""Activity"" services and the method name did not change), there should be no difference in the return value nor the exception handling between the two versions, so there is no CI."
670,<android.os.UserManager: String getUserName()>,28,29,<android.os.UserManager: String getUserName()>,<android.os.UserManager: String getUserName()>,0,"{
    UserInfo user = getUserInfo(getUserHandle());
    return user == null ? """" : user.name;
}","{
    try {
        return mService.getUserName();
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the user name of the user making this call.  This call is only
 * available to applications on the system image; it requires the
 * MANAGE_USERS permission.
 * @return the user name
 */
","/**
 * Returns the user name of the user making this call.  This call is only
 * available to applications on the system image; it requires the
 * {@code android.permission.MANAGE_USERS} or {@code android.permission.GET_ACCOUNTS_PRIVILEGED}
 * permissions.
 * @return the user name
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from 'return user == null ? """" : user.name;' in the early version to 'return mService.getUserName();' in the late version, which shows a modification in how the user name is retrieved and indicates a change in the return value source. Additionally, the early version extracts the information from a locally obtained `UserInfo` object, while the late version calls a method on a remote service (mService). This accounts for a change in both the return statement and a dependent API, hence the code change type is 1,5.","The change implies that the method now potentially returns a different value obtained from a remote service, which introduces the possibility of differing behavior between the two versions. Thus, the CI type is 1, due to potential different return values."
671,"<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>)>",28,29,"<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>)>","<android.view.textclassifier.TextLinks.Builder: Builder addLink(int,int,Map<String, Float>)>",0,"{
    mLinks.add(new TextLink(start, end, entityScores, null));
    return this;
}","{
    return addLink(start, end, entityScores, Bundle.EMPTY, null);
}",1,"/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
","/**
 * Adds a TextLink.
 *
 * @param start The start index of the identified subsequence
 * @param end The end index of the identified subsequence
 * @param entityScores A mapping of entity type to confidence score
 *
 * @throws IllegalArgumentException if entityScores is null or empty.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation in the late version calls an overloaded method addLink with additional parameters (Bundle.EMPTY, null). This is an example of a Dependent API changed as it calls a different overloaded method which still aims to perform the same operation, just with additional parameters that have default values.","There is no Compatibility Issue here as the fundamental behavior of the method has not been altered. It's still adding a link, just with more options specified. The original entityScores are still being used and the additional parameters have default or null values which do not affect the core functionality exposed by this API."
673,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>",28,29,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>","<android.app.LocalActivityManager: Window startActivity(String,Intent)>",0,"{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<ReferrerIntent> intents = new ArrayList<>(1);
                intents.add(new ReferrerIntent(intent, mParent.getPackageName()));
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                mActivityThread.performNewIntents(r, intents, false);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}","{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<ReferrerIntent> intents = new ArrayList<>(1);
                intents.add(new ReferrerIntent(intent, mParent.getPackageName()));
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                mActivityThread.handleNewIntent(r, intents);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}",1,"/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
","/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
674,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,28,29,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,0,"{
    try {
        return mService.getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getPrimaryClipDescription(mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 *
 * @see #setPrimaryClip(ClipData)
 */
","/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 *
 * <em>If the application is not the default IME or does not have input focus this return
 * {@code null}.</em>
 *
 * @see #setPrimaryClip(ClipData)
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The dependent API mService.getPrimaryClipDescription has an additional parameter in the late version implementation, so the code change type is 5.","There is no Compatibility Issue because the additional parameter (mContext.getUserId()) is an internal change that does not affect the return type or exception handling for the clients of this API method. The behavior from the client's perspective is consistent between versions, assuming the internal use of getUserId is properly handling user sessions within the same application environment. The return type and exception thrown remain the same."
675,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterX()>,28,29,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterX()>,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterX()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterX();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center X"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterX(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center X"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}",1,"/**
 * Returns the unscaled screen-relative X coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative X coordinate of the center of
 * the magnified region
 */
","/**
 * Returns the unscaled screen-relative X coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative X coordinate of the center of
 * the magnified region
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getMagnificationCenterX() called on the connection object has changed to include an additional parameter mDisplayId in the late version, indicating that a dependent API has changed. Therefore, the code change type is 5.","Since the try block will catch and handle RemoteExceptions the same way in both versions and the value returned in the event of a null connection or after catching an exception is the same (0.0f), this change should not cause any compatibility issues inherently. However, the change in the dependent API could potentially yield a different return value if the behavior of getMagnificationCenterX(int displayId) is different from getMagnificationCenterX(). But judging strictly from the given code, there is no direct evidence suggesting a different return value or exception handling based on the change, as the default behavior and exception handling did not change. Therefore, we consider that there's No Compatibility Issue."
677,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",28,29,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>","<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int,Bundle)>",0,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess(this);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManager.getService().startActivityIntentSender(mMainThread.getApplicationThread(), intent != null ? intent.getTarget() : null, intent != null ? intent.getWhitelistToken() : null, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.migrateExtraStreamToClipData();
            fillInIntent.prepareToLeaveProcess(this);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityTaskManager.getService().startActivityIntentSender(mMainThread.getApplicationThread(), intent != null ? intent.getTarget() : null, intent != null ? intent.getWhitelistToken() : null, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues, options);
        if (result == ActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API used within the method implementation has changed from ActivityManager.getService() to ActivityTaskManager.getService(). The rest of the code remains unchanged, which indicates that the change is related to the dependent service that the method is using. Hence, the code change type is 5 (Dependent API changed).","Although a dependent API has been modified, the change does not affect the method contract or its behavior from the caller's perspective. Both versions of the method throw the same exceptions, and since the return type is void, there's no change in the value being returned. Therefore, there's no compatibility issue detected (0), assuming that the new ActivityTaskManager.getService() provides the same functionality replacing the old ActivityManager.getService()."
678,<android.net.http.HttpResponseCache: long size()>,28,29,<android.net.http.HttpResponseCache: long size()>,<android.net.http.HttpResponseCache: long size()>,0,"{
    try {
        return delegate.size();
    } catch (IOException e) {
        // This can occur if the cache failed to lazily initialize.
        return -1;
    }
}","{
    try {
        return mDelegate.getSize();
    } catch (IOException e) {
        // This can occur if the cache failed to lazily initialize.
        return -1;
    }
}",1,"/**
 * Returns the number of bytes currently being used to store the values in
 * this cache. This may be greater than the {@link #maxSize} if a background
 * deletion is pending. {@code -1} is returned if the size cannot be determined.
 */
","/**
 * Returns the number of bytes currently being used to store the values in
 * this cache. This may be greater than the {@link #maxSize} if a background
 * deletion is pending. {@code -1} is returned if the size cannot be determined.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the method called on the delegate object from size() to getSize(), without any other changes to the logic or return statements. So the code change type is 5.","There is no Compatibility Issue because the method's behavior and exception handling have not changed, and the try-catch block still returns -1 for the same case as before. The method's signature and its return value remain consistent upon catching the IOException."
679,<android.app.usage.UsageStats: void add(UsageStats)>,28,29,<android.app.usage.UsageStats: void add(UsageStats)>,<android.app.usage.UsageStats: void add(UsageStats)>,0,"{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    // regards to their mEndTimeStamp.
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // Even though incoming UsageStat begins after this one, its last time used fields
        // may somehow be empty or chronologically preceding the older UsageStat.
        mLastEvent = Math.max(mLastEvent, right.mLastEvent);
        mLastTimeUsed = Math.max(mLastTimeUsed, right.mLastTimeUsed);
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
    mAppLaunchCount += right.mAppLaunchCount;
    if (mChooserCounts == null) {
        mChooserCounts = right.mChooserCounts;
    } else if (right.mChooserCounts != null) {
        final int chooserCountsSize = right.mChooserCounts.size();
        for (int i = 0; i < chooserCountsSize; i++) {
            String action = right.mChooserCounts.keyAt(i);
            ArrayMap<String, Integer> counts = right.mChooserCounts.valueAt(i);
            if (!mChooserCounts.containsKey(action) || mChooserCounts.get(action) == null) {
                mChooserCounts.put(action, counts);
                continue;
            }
            final int annotationSize = counts.size();
            for (int j = 0; j < annotationSize; j++) {
                String key = counts.keyAt(j);
                int rightValue = counts.valueAt(j);
                int leftValue = mChooserCounts.get(action).getOrDefault(key, 0);
                mChooserCounts.get(action).put(key, leftValue + rightValue);
            }
        }
    }
}","{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    // regards to their mEndTimeStamp.
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // Even though incoming UsageStat begins after this one, its last time used fields
        // may somehow be empty or chronologically preceding the older UsageStat.
        mergeEventMap(mActivities, right.mActivities);
        mergeEventMap(mForegroundServices, right.mForegroundServices);
        mLastTimeUsed = Math.max(mLastTimeUsed, right.mLastTimeUsed);
        mLastTimeVisible = Math.max(mLastTimeVisible, right.mLastTimeVisible);
        mLastTimeForegroundServiceUsed = Math.max(mLastTimeForegroundServiceUsed, right.mLastTimeForegroundServiceUsed);
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mTotalTimeVisible += right.mTotalTimeVisible;
    mTotalTimeForegroundServiceUsed += right.mTotalTimeForegroundServiceUsed;
    mLaunchCount += right.mLaunchCount;
    mAppLaunchCount += right.mAppLaunchCount;
    if (mChooserCounts == null) {
        mChooserCounts = right.mChooserCounts;
    } else if (right.mChooserCounts != null) {
        final int chooserCountsSize = right.mChooserCounts.size();
        for (int i = 0; i < chooserCountsSize; i++) {
            String action = right.mChooserCounts.keyAt(i);
            ArrayMap<String, Integer> counts = right.mChooserCounts.valueAt(i);
            if (!mChooserCounts.containsKey(action) || mChooserCounts.get(action) == null) {
                mChooserCounts.put(action, counts);
                continue;
            }
            final int annotationSize = counts.size();
            for (int j = 0; j < annotationSize; j++) {
                String key = counts.keyAt(j);
                int rightValue = counts.valueAt(j);
                int leftValue = mChooserCounts.get(action).getOrDefault(key, 0);
                mChooserCounts.get(action).put(key, leftValue + rightValue);
            }
        }
    }
}",1,"/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
","/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The if condition ""right.mBeginTimeStamp > mBeginTimeStamp"" logic remains the same, but the statements within the block have changed as the method ""mergeEventMap"" has been added and some variables have been added (mLastTimeVisible, mLastTimeForegroundServiceUsed, mTotalTimeVisible, mTotalTimeForegroundServiceUsed). There is also a removal of the statement ""mLastEvent = Math.max(mLastEvent, right.mLastEvent);"". These changes are related to control dependency (3) and other statements change (4).","Despite the changes in the implementation, there's no indication of change in the APIs return type or its exception handling. The method doesn't return a value (it's a void method) and doesn't throw any new or different exceptions. The changes within the method's body reflect the internal behavior and calculation but don't affect the API's interface contracts. Thus, there's no Compatibility Issue as per the definitions provided."
680,"<android.text.util.Linkify: boolean addLinks(TextView,int)>",28,29,"<android.text.util.Linkify: boolean addLinks(TextView,int)>","<android.text.util.Linkify: boolean addLinks(TextView,int)>",0,"{
    if (mask == 0) {
        return false;
    }
    final Context context = text.getContext();
    final CharSequence t = text.getText();
    if (t instanceof Spannable) {
        if (addLinks((Spannable) t, mask, context)) {
            addLinkMovementMethod(text);
            return true;
        }
        return false;
    } else {
        SpannableString s = SpannableString.valueOf(t);
        if (addLinks(s, mask, context)) {
            addLinkMovementMethod(text);
            text.setText(s);
            return true;
        }
        return false;
    }
}","{
    if (mask == 0) {
        return false;
    }
    final Context context = text.getContext();
    final CharSequence t = text.getText();
    if (t instanceof Spannable) {
        if (addLinks((Spannable) t, mask, context, null)) {
            addLinkMovementMethod(text);
            return true;
        }
        return false;
    } else {
        SpannableString s = SpannableString.valueOf(t);
        if (addLinks(s, mask, context, null)) {
            addLinkMovementMethod(text);
            text.setText(s);
            return true;
        }
        return false;
    }
}",1,"/**
 * Scans the text of the provided TextView and turns all occurrences of
 * the link types indicated in the mask into clickable links.  If matches
 * are found the movement method for the TextView is set to
 * LinkMovementMethod.
 *
 * @param text TextView whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 */
","/**
 * Scans the text of the provided TextView and turns all occurrences of
 * the link types indicated in the mask into clickable links.  If matches
 * are found the movement method for the TextView is set to
 * LinkMovementMethod.
 *
 * @param text TextView whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 *
 * @see #addLinks(Spannable, int, Function)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call addLinks() has its signature changed by the inclusion of a new parameter; the other API addLinks() is now invoked with an additional 'null' argument in both conditional branches, indicating a change in the dependent API, so the code change type is 5.","Although a new argument is added to the method addLinks() calls, this does not constitute a change in the external behavior of the addLinks(TextView, int) API with respect to different return values, types, or exceptions that it might throw, because the internal implementation of addLinks() is not part of the API contract of the method in question. Therefore, assuming that the functionality of addLinks() remains consistent even after the change, there's no Compatibility Issue, hence type 0."
681,<android.widget.RemoteViewsAdapter.RemoteServiceHandler: void handleMessage(Message)>,28,29,<android.widget.RemoteViewsAdapter.RemoteServiceHandler: void handleMessage(Message)>,<android.widget.RemoteViewsAdapter.RemoteServiceHandler: void handleMessage(Message)>,0,"{
    RemoteViewsAdapter adapter = mAdapter.get();
    switch(msg.what) {
        case MSG_REQUEST_BIND:
            {
                if (adapter == null || mRemoteViewsFactory != null) {
                    enqueueDeferredUnbindServiceMessage();
                }
                if (mBindRequested) {
                    return;
                }
                int flags = Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE;
                final IServiceConnection sd = mContext.getServiceDispatcher(this, this, flags);
                Intent intent = (Intent) msg.obj;
                int appWidgetId = msg.arg1;
                mBindRequested = AppWidgetManager.getInstance(mContext).bindRemoteViewsService(mContext, appWidgetId, intent, sd, flags);
                return;
            }
        case MSG_NOTIFY_DATA_SET_CHANGED:
            {
                enqueueDeferredUnbindServiceMessage();
                if (adapter == null) {
                    return;
                }
                if (mRemoteViewsFactory == null) {
                    mNotifyDataSetChangedPending = true;
                    adapter.requestBindService();
                    return;
                }
                if (!sendNotifyDataSetChange(true)) {
                    return;
                }
                // Flush the cache so that we can reload new items from the service
                synchronized (adapter.mCache) {
                    adapter.mCache.reset();
                }
                // Re-request the new metadata (only after the notification to the factory)
                adapter.updateTemporaryMetaData(mRemoteViewsFactory);
                int newCount;
                int[] visibleWindow;
                synchronized (adapter.mCache.getTemporaryMetaData()) {
                    newCount = adapter.mCache.getTemporaryMetaData().count;
                    visibleWindow = adapter.getVisibleWindow(newCount);
                }
                // widget notifies that its data has changed.
                for (int position : visibleWindow) {
                    // representation.
                    if (position < newCount) {
                        adapter.updateRemoteViews(mRemoteViewsFactory, position, false);
                    }
                }
                // Propagate the notification back to the base adapter
                adapter.mMainHandler.sendEmptyMessage(MSG_MAIN_HANDLER_COMMIT_METADATA);
                adapter.mMainHandler.sendEmptyMessage(MSG_MAIN_HANDLER_SUPER_NOTIFY_DATA_SET_CHANGED);
                return;
            }
        case MSG_LOAD_NEXT_ITEM:
            {
                if (adapter == null || mRemoteViewsFactory == null) {
                    return;
                }
                removeMessages(MSG_UNBIND_SERVICE);
                // Get the next index to load
                final int position = adapter.mCache.getNextIndexToLoad();
                if (position > -1) {
                    // Load the item, and notify any existing RemoteViewsFrameLayouts
                    adapter.updateRemoteViews(mRemoteViewsFactory, position, true);
                    // Queue up for the next one to load
                    sendEmptyMessage(MSG_LOAD_NEXT_ITEM);
                } else {
                    // No more items to load, so queue unbind
                    enqueueDeferredUnbindServiceMessage();
                }
                return;
            }
        case MSG_UNBIND_SERVICE:
            {
                unbindNow();
                return;
            }
    }
}","{
    RemoteViewsAdapter adapter = mAdapter.get();
    switch(msg.what) {
        case MSG_REQUEST_BIND:
            {
                if (adapter == null || mRemoteViewsFactory != null) {
                    enqueueDeferredUnbindServiceMessage();
                }
                if (mBindRequested) {
                    return;
                }
                int flags = Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE;
                final IServiceConnection sd = mContext.getServiceDispatcher(this, this, flags);
                Intent intent = (Intent) msg.obj;
                int appWidgetId = msg.arg1;
                try {
                    mBindRequested = AppWidgetManager.getInstance(mContext).bindRemoteViewsService(mContext, appWidgetId, intent, sd, flags);
                } catch (Exception e) {
                    Log.e(TAG, ""Failed to bind remoteViewsService: "" + e.getMessage());
                }
                return;
            }
        case MSG_NOTIFY_DATA_SET_CHANGED:
            {
                enqueueDeferredUnbindServiceMessage();
                if (adapter == null) {
                    return;
                }
                if (mRemoteViewsFactory == null) {
                    mNotifyDataSetChangedPending = true;
                    adapter.requestBindService();
                    return;
                }
                if (!sendNotifyDataSetChange(true)) {
                    return;
                }
                // Flush the cache so that we can reload new items from the service
                synchronized (adapter.mCache) {
                    adapter.mCache.reset();
                }
                // Re-request the new metadata (only after the notification to the factory)
                adapter.updateTemporaryMetaData(mRemoteViewsFactory);
                int newCount;
                int[] visibleWindow;
                synchronized (adapter.mCache.getTemporaryMetaData()) {
                    newCount = adapter.mCache.getTemporaryMetaData().count;
                    visibleWindow = adapter.getVisibleWindow(newCount);
                }
                // widget notifies that its data has changed.
                for (int position : visibleWindow) {
                    // representation.
                    if (position < newCount) {
                        adapter.updateRemoteViews(mRemoteViewsFactory, position, false);
                    }
                }
                // Propagate the notification back to the base adapter
                adapter.mMainHandler.sendEmptyMessage(MSG_MAIN_HANDLER_COMMIT_METADATA);
                adapter.mMainHandler.sendEmptyMessage(MSG_MAIN_HANDLER_SUPER_NOTIFY_DATA_SET_CHANGED);
                return;
            }
        case MSG_LOAD_NEXT_ITEM:
            {
                if (adapter == null || mRemoteViewsFactory == null) {
                    return;
                }
                removeMessages(MSG_UNBIND_SERVICE);
                // Get the next index to load
                final int position = adapter.mCache.getNextIndexToLoad();
                if (position > -1) {
                    // Load the item, and notify any existing RemoteViewsFrameLayouts
                    adapter.updateRemoteViews(mRemoteViewsFactory, position, true);
                    // Queue up for the next one to load
                    sendEmptyMessage(MSG_LOAD_NEXT_ITEM);
                } else {
                    // No more items to load, so queue unbind
                    enqueueDeferredUnbindServiceMessage();
                }
                return;
            }
        case MSG_UNBIND_SERVICE:
            {
                unbindNow();
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
682,<android.service.wallpaper.WallpaperService.Engine: void detach()>,28,29,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mDisplayManager != null) {
        mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mIWallpaperEngine.mDisplayManager != null) {
        mIWallpaperEngine.mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change consists of only a reference change from 'mDisplayManager' to 'mIWallpaperEngine.mDisplayManager'. Because the change does not affect the control flow or the potential outcome of the method, it's classified as an 'other statement changed'.","There's no Compatibility Issue since the behavior of the method hasn't changed. The method execution logic remains consistent between versions, and the output of the method is not altered by this reference change."
685,"<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",28,29,"<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>","<android.provider.MediaStore.Images.Thumbnails: Bitmap getThumbnail(ContentResolver,long,int,Options)>",0,"{
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, false);
}","{
    final Uri uri = ContentUris.withAppendedId(Images.Media.EXTERNAL_CONTENT_URI, imageId);
    return InternalThumbnails.getThumbnail(cr, uri, kind, options);
}",1,"/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND.
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image
 * associated with origId doesn't exist or memory is not enough.
 */
","/**
 * Return thumbnail representing a specific image item. If a
 * thumbnail doesn't exist, this method will block until it's
 * generated. Callers are responsible for their own in-memory
 * caching of returned values.
 *
 * @param imageId the image item to obtain a thumbnail for.
 * @param kind optimal thumbnail size desired.
 * @return decoded thumbnail, or {@code null} if problem was
 * encountered.
 * @deprecated Callers should migrate to using
 * {@link ContentResolver#loadThumbnail}, since it
 * offers richer control over requested thumbnail sizes
 * and cancellation behavior.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method's implementation has changed significantly. There's a new local variable 'uri' being created and there's also a change in the method signature of 'getThumbnail' being called. The previous implementation passed more arguments than the later implementation. Additionally, the way the URI is constructed has also changed, which could affect the returned Bitmap. So, the code change type is 1,4,5.","The potential differing 'getThumbnail' method signatures and its arguments used in the implementation can result in a different Bitmap being returned. Therefore, the CI type is 1, which is caused by a potential return of a different value."
686,"<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>",28,29,"<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>","<android.view.ViewGroup: void dispatchProvideAutofillStructure(ViewStructure,int)>",0,"{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideAutofillStructure(): not laid out, ignoring "" + mChildrenCount + "" children of "" + getAutofillId());
        }
        return;
    }
    final ChildListForAutoFill children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}","{
    super.dispatchProvideAutofillStructure(structure, flags);
    if (structure.getChildCount() != 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideAutofillStructure(): not laid out, ignoring "" + mChildrenCount + "" children of "" + getAutofillId());
        }
        return;
    }
    final ChildListForAutofill children = getChildrenForAutofill(flags);
    final int childrenCount = children.size();
    structure.setChildCount(childrenCount);
    for (int i = 0; i < childrenCount; i++) {
        final View child = children.get(i);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideAutofillStructure(cstructure, flags);
    }
    children.recycle();
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
","/**
 * {@inheritDoc}
 *
 * <p>This implementation adds in all child views of the view group, in addition to calling the
 * default {@link View} implementation.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no detectable code change between the early and late version, as both implementations are identical.",No Compatibility Issue because there is no code change.
687,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,28,29,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,<android.net.ConnectivityManager: void unregisterNetworkCallback(NetworkCallback)>,0,"{
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.networkRequest != null, ""NetworkCallback was not registered"");
        Preconditions.checkArgument(networkCallback.networkRequest != ALREADY_UNREGISTERED, ""NetworkCallback was already unregistered"");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = ALREADY_UNREGISTERED;
    }
}","{
    printStackTrace();
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.networkRequest != null, ""NetworkCallback was not registered"");
        if (networkCallback.networkRequest == ALREADY_UNREGISTERED) {
            Log.d(TAG, ""NetworkCallback was already unregistered"");
            return;
        }
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = ALREADY_UNREGISTERED;
    }
}",1,"/**
 * Unregisters a {@code NetworkCallback} and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.
 * If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * Notifications that would have triggered that {@code NetworkCallback} will immediately stop
 * triggering it as soon as this call returns.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
","/**
 * Unregisters a {@code NetworkCallback} and possibly releases networks originating from
 * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and
 * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.
 * If the given {@code NetworkCallback} had previously been used with
 * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request
 * will be disconnected.
 *
 * Notifications that would have triggered that {@code NetworkCallback} will immediately stop
 * triggering it as soon as this call returns.
 *
 * @param networkCallback The {@link NetworkCallback} used when making the request.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early implementation throws an exception if the `NetworkCallback` has already been unregistered, while the late implementation logs the event and returns early without throwing an exception. Also, a new method call `printStackTrace();` is introduced at the beginning of the late implementation, which is a change in the other statements, so the code change types are 1,4.","The change in exception handling could lead to a different behavior since in the late version, the method no longer throws an `IllegalArgumentException` if the `NetworkCallback` is already unregistered, instead it just logs an informational message. The introduction of the `printStackTrace();` method call does not influence the compatibility, so the only CI type here is 1, which is caused by the change in exception handling that leads to different behavior in terms of whether an exception is thrown."
688,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,28,29,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_ENQUEUED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                args.recycle();
                Adjustment adjustment = onNotificationEnqueued(sbn);
                if (adjustment != null) {
                    if (!isBound())
                        return;
                    try {
                        getNotificationInterface().applyEnqueuedAdjustmentFromAssistant(mWrapper, adjustment);
                    } catch (android.os.RemoteException ex) {
                        Log.v(TAG, ""Unable to contact notification manager"", ex);
                        throw ex.rethrowFromSystemServer();
                    }
                }
                break;
            }
        case MSG_ON_NOTIFICATION_SNOOZED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                String snoozeCriterionId = (String) args.arg2;
                args.recycle();
                onNotificationSnoozedUntilContext(sbn, snoozeCriterionId);
                break;
            }
    }
}","{
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_ENQUEUED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                NotificationChannel channel = (NotificationChannel) args.arg2;
                args.recycle();
                Adjustment adjustment = onNotificationEnqueued(sbn, channel);
                setAdjustmentIssuer(adjustment);
                if (adjustment != null) {
                    if (!isBound()) {
                        Log.w(TAG, ""MSG_ON_NOTIFICATION_ENQUEUED: service not bound, skip."");
                        return;
                    }
                    try {
                        getNotificationInterface().applyEnqueuedAdjustmentFromAssistant(mWrapper, adjustment);
                    } catch (android.os.RemoteException ex) {
                        Log.v(TAG, ""Unable to contact notification manager"", ex);
                        throw ex.rethrowFromSystemServer();
                    } catch (SecurityException e) {
                        // app cannot catch and recover from this, so do on their behalf
                        Log.w(TAG, ""Enqueue adjustment failed; no longer connected"", e);
                    }
                }
                break;
            }
        case MSG_ON_NOTIFICATION_SNOOZED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                String snoozeCriterionId = (String) args.arg2;
                args.recycle();
                onNotificationSnoozedUntilContext(sbn, snoozeCriterionId);
                break;
            }
        case MSG_ON_NOTIFICATIONS_SEEN:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                List<String> keys = (List<String>) args.arg1;
                args.recycle();
                onNotificationsSeen(keys);
                break;
            }
        case MSG_ON_NOTIFICATION_EXPANSION_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isUserAction = args.argi1 == 1;
                boolean isExpanded = args.argi2 == 1;
                args.recycle();
                onNotificationExpansionChanged(key, isUserAction, isExpanded);
                break;
            }
        case MSG_ON_NOTIFICATION_DIRECT_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                args.recycle();
                onNotificationDirectReplied(key);
                break;
            }
        case MSG_ON_SUGGESTED_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                CharSequence reply = (CharSequence) args.arg2;
                int source = args.argi2;
                args.recycle();
                onSuggestedReplySent(key, reply, source);
                break;
            }
        case MSG_ON_ACTION_INVOKED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                Notification.Action action = (Notification.Action) args.arg2;
                int source = args.argi2;
                args.recycle();
                onActionInvoked(key, action, source);
                break;
            }
        case MSG_ON_ALLOWED_ADJUSTMENTS_CHANGED:
            {
                onAllowedAdjustmentsChanged();
                break;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The implementation of the switch-case MSG_ON_NOTIFICATION_ENQUEUED has changed, with an additional cast of args.arg2 to NotificationChannel and call to onNotificationEnqueued() with an additional parameter, as well as setting the adjustment issuer afterwards. There are newly introduced exception handling for a SecurityException, and new LOG statements. Additionally, new switch-cases are added (MSG_ON_NOTIFICATIONS_SEEN, MSG_ON_NOTIFICATION_EXPANSION_CHANGED, MSG_ON_NOTIFICATION_DIRECT_REPLY_SENT, MSG_ON_SUGGESTED_REPLY_SENT, MSG_ON_ACTION_INVOKED, and MSG_ON_ALLOWED_ADJUSTMENTS_CHANGED), which constitutes changes in return statements, exception handling statements, control dependencies, and other statements. So the code change types here are 1,2,3,4.","Since the call to onNotificationEnqueued has changed by now having the additional variable, channel, provided to it, and setAdjustmentIssuer is called afterwards, this can cause a different Adjustment to be returned, which is a potential return value change. The newly introduced control flow for handling SecurityException might alter exception handling at runtime, meaning there's a potential for different exception outcomes. The addition of new cases in the switch statement means new behaviors for the function that weren't present before, leading to different returns and different exceptions being handled. Thus, the CI types are 1,2."
690,<android.app.Activity: void setTurnScreenOn(boolean)>,28,29,<android.app.Activity: void setTurnScreenOn(boolean)>,<android.app.Activity: void setTurnScreenOn(boolean)>,0,"{
    try {
        ActivityManager.getService().setTurnScreenOn(mToken, turnScreenOn);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to call setTurnScreenOn"", e);
    }
}","{
    try {
        ActivityTaskManager.getService().setTurnScreenOn(mToken, turnScreenOn);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Specifies whether the screen should be turned on when the {@link Activity} is resumed.
 * Normally an activity will be transitioned to the stopped state if it is started while the
 * screen if off, but with this flag set the activity will cause the screen to turn on if the
 * activity will be visible and resumed due to the screen coming on. The screen will not be
 * turned on if the activity won't be visible after the screen is turned on. This flag is
 * normally used in conjunction with the {@link android.R.attr#showWhenLocked} flag to make sure
 * the activity is visible after the screen is turned on when the lockscreen is up. In addition,
 * if this flag is set and the activity calls {@link
 * KeyguardManager#requestDismissKeyguard(Activity, KeyguardManager.KeyguardDismissCallback)}
 * the screen will turn on.
 *
 * @param turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
 *
 * @see #setShowWhenLocked(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 */
","/**
 * Specifies whether the screen should be turned on when the {@link Activity} is resumed.
 * Normally an activity will be transitioned to the stopped state if it is started while the
 * screen if off, but with this flag set the activity will cause the screen to turn on if the
 * activity will be visible and resumed due to the screen coming on. The screen will not be
 * turned on if the activity won't be visible after the screen is turned on. This flag is
 * normally used in conjunction with the {@link android.R.attr#showWhenLocked} flag to make sure
 * the activity is visible after the screen is turned on when the lockscreen is up. In addition,
 * if this flag is set and the activity calls {@link
 * KeyguardManager#requestDismissKeyguard(Activity, KeyguardManager.KeyguardDismissCallback)}
 * the screen will turn on.
 *
 * @param turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
 *
 * @see #setShowWhenLocked(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The dependent API getService() has changed from ActivityManager.getService() to ActivityTaskManager.getService(), and the exception handling statement has also changed from logging an error to throwing an exception, so the code change type is 2,5.","Since the method now throws an exception instead of logging it, the caller of this method would experience a different behavior in terms of exception handling, making the CI type 2."
692,<android.app.Activity: void setRequestedOrientation(int)>,28,29,<android.app.Activity: void setRequestedOrientation(int)>,<android.app.Activity: void setRequestedOrientation(int)>,0,"{
    if (mParent == null) {
        try {
            ActivityManager.getService().setRequestedOrientation(mToken, requestedOrientation);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.setRequestedOrientation(requestedOrientation);
    }
}","{
    if (mParent == null) {
        try {
            ActivityTaskManager.getService().setRequestedOrientation(mToken, requestedOrientation);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.setRequestedOrientation(requestedOrientation);
    }
}",1,"/**
 * Change the desired orientation of this activity.  If the activity
 * is currently in the foreground or otherwise impacting the screen
 * orientation, the screen will immediately be changed (possibly causing
 * the activity to be restarted). Otherwise, this will be used the next
 * time the activity is visible.
 *
 * @param requestedOrientation An orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Change the desired orientation of this activity.  If the activity
 * is currently in the foreground or otherwise impacting the screen
 * orientation, the screen will immediately be changed (possibly causing
 * the activity to be restarted). Otherwise, this will be used the next
 * time the activity is visible.
 *
 * @param requestedOrientation An orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from using ActivityManager.getService() to ActivityTaskManager.getService(). Hence, the dependent API has been changed, resulting in code change type 5.","Since the exception is caught and not handled (the catch block is empty), and the behavior of the API for the client remains the same as before, there is no Compatibility Issue arising from the change. The modification to the dependent API does not necessarily introduce a change in behavior from the caller's perspective as long as the contract of the service's method hasn't changed."
693,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectUnbufferedIo()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectUnbufferedIo()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectUnbufferedIo()>,0,"{
    return enable(DETECT_UNBUFFERED_IO);
}","{
    return enable(DETECT_THREAD_UNBUFFERED_IO);
}",1,"/**
 * Detect unbuffered input/output operations.
 */
","/**
 * Detect unbuffered input/output operations.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The change from enable(DETECT_UNBUFFERED_IO) to enable(DETECT_THREAD_UNBUFFERED_IO) indicates not only the return statement has potentially changed (reflecting the change in the functionality of what is being enabled), but also that a dependent API has changed, which is the method that is being called with new parameters. Therefore, the code change types are 1 and 5.","Since the implementation has changed the behavior of the enabling function from DETECT_UNBUFFERED_IO to DETECT_THREAD_UNBUFFERED_IO, it suggests that the API's behavior has changed, potentially affecting the conditions under which unbuffered I/O is detected. Therefore, this could lead to a change in return values or behavior, indicating a CI of type 1."
694,<android.os.Looper: void loop()>,28,29,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt(""log.looper."" + Process.myUid() + ""."" + Thread.currentThread().getName() + "".slow"", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        try {
            msg.target.dispatchMessage(msg);
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, ""Drained"");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, ""delivery"", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, ""dispatch"", msg);
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt(""log.looper."" + Process.myUid() + ""."" + Thread.currentThread().getName() + "".slow"", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, ""Drained"");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, ""delivery"", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, ""dispatch"", msg);
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
695,<android.content.ContentValues: Long getAsLong(String)>,28,29,<android.content.ContentValues: Long getAsLong(String)>,<android.content.ContentValues: Long getAsLong(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).longValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Long.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return value != null ? ((Number) value).longValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Long.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Long value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Long: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Long.
 *
 * @param key the value to get
 * @return the Long value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed from mValues.get(key) to mMap.get(key), which implies a change in the internal structure being used to store the values. However, this does not affect the return value or the behavior of the method from the caller's perspective, as the structure is encapsulated within the method and the data it retrieves remains the same. Therefore, the code change type is 4.","The change does not lead to a compatibility issue, as the method's contract and behavior from the perspective of an API consumer remain unchanged. The method's return type and potential return values or exceptions it may throw are not altered by this change, so there is no compatibility issue."
696,"<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>",28,29,"<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>","<android.view.inputmethod.InputMethodManager: void setInputMethodAndSubtype(IBinder,String,InputMethodSubtype)>",0,"{
    setInputMethodAndSubtypeInternal(token, id, subtype);
}","{
    if (token == null) {
        Log.e(TAG, ""setInputMethodAndSubtype() does not accept null token on Android Q "" + ""and later."");
        return;
    }
    InputMethodPrivilegedOperationsRegistry.get(token).setInputMethodAndSubtype(id, subtype);
}",1,"/**
 * Force switch to a new input method and subtype. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @param subtype The new subtype of the new input method to be switched to.
 * @deprecated Use
 * {@link InputMethodService#switchInputMethod(String, InputMethodSubtype)}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
","/**
 * Force switch to a new input method and subtype. This can only be called
 * from an application or a service which has a token of the currently active input method.
 *
 * <p>On Android {@link Build.VERSION_CODES#Q} and later devices, {@code token} cannot be
 * {@code null} even with {@link android.Manifest.permission#WRITE_SECURE_SETTINGS}. Instead,
 * update {@link android.provider.Settings.Secure#DEFAULT_INPUT_METHOD} and
 * {@link android.provider.Settings.Secure#SELECTED_INPUT_METHOD_SUBTYPE} directly.</p>
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @param subtype The new subtype of the new input method to be switched to.
 * @deprecated Use
 * {@link InputMethodService#switchInputMethod(String, InputMethodSubtype)}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The late version introduces a new check for null on the parameter 'token' followed by an early return if the check fails, a change from directly calling setInputMethodAndSubtypeInternal to using InputMethodPrivilegedOperationsRegistry.get(token).setInputMethodAndSubtype(id, subtype), and a logging statement. This accounts for changes in exception handling (because a NullPointerException would no longer be thrown implicitly), control dependency (a new if statement with a return), other statement change (new logging statement), and dependent API change (use of a different method to set the input method and subtype). Hence, the code change types are 2, 3, 4, and 5.","There is a new branch that returns early if the token is null, which could potentially skip the execution of setInputMethodAndSubtype, reducing the previous implicit null-check to an explicit one. Formerly if there was a null token, a NullPointerException might be implicitly thrown by the JVM; in the late version, this condition is checked and handled explicitly. Additionally, the method call to setInputMethodAndSubtype has changed, which changes the dependent method's behavior. This raises a possibility for the late version to not execute the original method setInputMethodAndSubtypeInternal at all when token is null, and for a changed behavior due to the usage of a different method even when token is not null. These changes can cause a compatibility issue both in the returned value (or lack thereof) and in the exception handling behavior. Therefore, the compatibility issue types are 1 and 2."
697,<android.view.DisplayCutout: String toString()>,28,29,<android.view.DisplayCutout: String toString()>,<android.view.DisplayCutout: String toString()>,0,"{
    return ""DisplayCutout{insets="" + mSafeInsets + "" boundingRect="" + mBounds.getBounds() + ""}"";
}","{
    return ""DisplayCutout{insets="" + mSafeInsets + "" boundingRect={"" + mBounds + ""}"" + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code changed the way of constructing the string representation of the object by altering how the boundingRect part of the string is created. The information itself has not been altered, simply the format of the string returned has changed. Therefore, the code change type is 4.","There is no compatibility issue as the toString() method is meant to return a string representation of the object. While the format of the string has changed, it does not affect the behavior of the method from an execution standpoint. The method still returns a string and does not affect any control flow or exception throwing. Therefore, the type of CI is 0."
700,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromDatagramSocket(DatagramSocket)>,28,29,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromDatagramSocket(DatagramSocket)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromDatagramSocket(DatagramSocket)>,0,"{
    FileDescriptor fd = datagramSocket.getFileDescriptor$();
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}","{
    FileDescriptor fd = datagramSocket.getFileDescriptor$();
    try {
        return fd != null ? ParcelFileDescriptor.dup(fd) : null;
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}",1,"/**
 * Create a new ParcelFileDescriptor from the specified DatagramSocket.
 *
 * @param datagramSocket The DatagramSocket whose FileDescriptor is used
 * to create a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with the FileDescriptor of the
 * specified DatagramSocket.
 */
","/**
 * Create a new ParcelFileDescriptor from the specified DatagramSocket. The
 * new ParcelFileDescriptor holds a dup of the original FileDescriptor in
 * the DatagramSocket, so you must still close the DatagramSocket as well
 * as the new ParcelFileDescriptor.
 * <p>
 * <strong>WARNING:</strong> Prior to API level 29, this function would not
 * actually dup the DatagramSocket's FileDescriptor, and would take a
 * reference to the its internal FileDescriptor instead. If the DatagramSocket
 * gets garbage collected before the ParcelFileDescriptor, this may
 * lead to the ParcelFileDescriptor being unexpectedly closed. To avoid
 * this, the following pattern can be used:
 * <pre>{@code
 * ParcelFileDescriptor pfd = ParcelFileDescriptor.fromDatagramSocket(socket).dup();
 * }</pre>
 *
 * @param datagramSocket The DatagramSocket whose FileDescriptor is used
 * to create a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with a duped copy of the
 * FileDescriptor of the specified Socket.
 *
 * @throws UncheckedIOException if {@link #dup(FileDescriptor)} throws IOException.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The method fromDatagramSocket's implementation has changed significantly. In the late version, there is a new try-catch block, and the creation of ParcelFileDescriptor has changed from a simple constructor call to a method call of ParcelFileDescriptor.dup(fd), indicating changes in return statement, exception handling, and a dependent API change, which are code change types 1, 2, and 5.","Since a new try-catch block is introduced which throws a new RuntimeException (UncheckedIOException) if an IOException occurs during the call to ParcelFileDescriptor.dup(fd), there is a Compatibility Issue of a different exception handling type which is type 2. Additionally, the use of ParcelFileDescriptor.dup instead of the constructor could potentially result in different return values based on the system's behavior and implementation of dup versus the constructor. This leads to a potential Compatibility Issue of different return values or types which is type 1."
701,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,28,29,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,0,"{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(getId());
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""summary: "").append(mNonLocalizedSummary);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}","{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""nonInteractiveUiTimeout: "").append(mNonInteractiveUiTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""interactiveUiTimeout: "").append(mInteractiveUiTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(getId());
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""summary: "").append(mNonLocalizedSummary);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation of the method has introduced new lines to append ""nonInteractiveUiTimeout"" and ""interactiveUiTimeout"" to the StringBuilder object. This is an addition of statements and not just changes to the existing control structures, signaling an Other statement changed (4), and since the content of the returned string has been modified, we have a Return statement changed (1) as well.","Due to the additional information appended to the returned string, the return value has changed, which constitutes a Compatibility Issue of type 1, as clients calling this method will receive additional details in the generated string."
702,<android.view.WindowInsets: int getStableInsetTop()>,28,29,<android.view.WindowInsets: int getStableInsetTop()>,<android.view.WindowInsets: int getStableInsetTop()>,0,"{
    return mStableInsets.top;
}","{
    return getStableInsets().top;
}",1,"/**
 * Returns the top stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The top stable inset
 */
","/**
 * Returns the top stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The top stable inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has been changed from direct access of a field 'mStableInsets.top' to calling a method 'getStableInsets().top'. This change is an example of other statement change and a change in the dependent API. Therefore, the code change type is 4,5.","This change could lead to a different return value if the implementation of 'getStableInsets()' differs from the direct access of 'mStableInsets'. Thus, it results in a potential Compatibility Issue due to a different return value, which is CI type 1."
704,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",28,29,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>","<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",0,"{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, null);
        final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}","{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,The changes in the code are:,"- The implementation of how the 'displayId' is derived has been moved to a method call instead of being done inline within the API, thus it also involves a statement change that is other than a control, return or exception handling (4)."
707,<android.service.autofill.FillCallback: void onFailure(CharSequence)>,28,29,<android.service.autofill.FillCallback: void onFailure(CharSequence)>,<android.service.autofill.FillCallback: void onFailure(CharSequence)>,0,"{
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(mRequestId, message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}","{
    Log.w(TAG, ""onFailure(): "" + message);
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(mRequestId, message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}",1,"/**
 * Notifies the Android System that an
 * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} could not be fulfilled by the service.
 *
 * @param message error message to be displayed to the user.
 */
","/**
 * Notifies the Android System that a fill request (
 * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)}) could not be fulfilled by the service (for example, because the user data was
 * not available yet), so the request could be retried later.
 *
 * <p><b>Note: </b>this method should not be used when the service didn't have the heursitics to
 * fulfill the request; in this case, the service should call {@link #onSuccess(FillResponse)
 * onSuccess(null)} instead.
 *
 * <p><b>Note: </b>prior to {@link android.os.Build.VERSION_CODES#Q}, this
 * method was not working as intended and the service should always call
 * {@link #onSuccess(FillResponse) onSuccess(null)} instead.
 *
 * <p><b>Note: </b>for apps targeting {@link android.os.Build.VERSION_CODES#Q} or higher, this
 * method just logs the message on {@code logcat}; for apps targetting older SDKs, it also
 * displays the message to user using a {@link android.widget.Toast}. Generally speaking, you
 * should not display an error to the user if the request failed, unless the request had the
 * {@link FillRequest#FLAG_MANUAL_REQUEST} flag.
 *
 * @param message error message. <b>Note: </b> this message should <b>not</b> contain PII
 * (Personally Identifiable Information, such as username or email address).
 *
 * @throws IllegalStateException if this method or {@link #onSuccess(FillResponse)} was already
 * called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A log warning statement is introduced, so there is an other statement change, which is classified as code change type 4.","Adding a log message does not affect the external behavior of the API, so it does not introduce a Compatibility Issue. The log statement would not lead to different return values or types, nor would it alter how exceptions are handled for the consumer of the API. Hence, there is no Compatibility Issue, so the type is 0."
708,<android.app.Activity: void stopLockTask()>,28,29,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"{
    try {
        ActivityManager.getService().stopLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityTaskManager.getService().stopLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the code is in the method call to stop the lock task mode, where the service being called has changed from ActivityManager.getService() to ActivityTaskManager.getService(). It's a change in the dependent API, hence the change type is 5.","There is no change to the control flow, exception handling, or return values, and the change in the dependent API doesnt necessarily indicate a change in the behavior of the method that would lead to a compatibility issue. Therefore, no compatibility issue is expected, and the CI type is 0."
709,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",28,29,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(values, ""values"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    Preconditions.checkNotNull(values, ""values"");
    try {
        if (mWrapped != null)
            return mWrapped.bulkInsert(url, values);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
","/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version, an additional try-catch block has been introduced to check if mWrapped is not null and call its bulkInsert method, which is a new control dependency change. There is also an addition of the @Override annotation, but that doesn't impact functionality, so it's not considered a change. The newly added try-catch block and the condition ""if (mWrapped != null)"" are considered other statement changes. Therefore, the change types are 3 and 4.","Despite the added control dependency and other statement changes, the new try-catch block with ""if (mWrapped != null)"" does not introduce a new behavior that could cause a compatibility issue because the rest of the code and exception handling remain unchanged. If mWrapped is null, the method proceeds to execute the same code as in the early version. Therefore, there is no compatibility issue."
710,<android.widget.Toast: void show()>,28,29,<android.widget.Toast: void show()>,<android.widget.Toast: void show()>,0,"{
    if (mNextView == null) {
        throw new RuntimeException(""setView must have been called"");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}","{
    if (mNextView == null) {
        throw new RuntimeException(""setView must have been called"");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    final int displayId = mContext.getDisplayId();
    try {
        service.enqueueToast(pkg, tn, mDuration, displayId);
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * Show the view for the specified duration.
 */
","/**
 * Show the view for the specified duration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change comprises adding a new local variable (`final int displayId = mContext.getDisplayId();`) and modifying the parameters of the `service.enqueueToast` method call by adding `displayId` as an additional argument. Therefore, the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue in respect to return values, types, or exception handling, because the caller's perspective remains unaffected. The show() method has no return type (void) and no new exceptions are thrown in the late version. The change in the implementation details does not alter the method's contract, syntax, or expected behavior from the caller's standpoint. The empty catch block for RemoteException remains identical, hence the API's external behavior is not expected to change. Therefore, the CI type is 0."
712,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",28,29,"<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>","<android.service.notification.NotificationListenerService.RankingMap: boolean getRanking(String,Ranking)>",0,"{
    int rank = getRank(key);
    outRanking.populate(key, rank, !isIntercepted(key), getVisibilityOverride(key), getSuppressedVisualEffects(key), getImportance(key), getImportanceExplanation(key), getOverrideGroupKey(key), getChannel(key), getOverridePeople(key), getSnoozeCriteria(key), getShowBadge(key), getUserSentiment(key), getHidden(key));
    return rank >= 0;
}","{
    if (mRankings.containsKey(key)) {
        outRanking.populate(mRankings.get(key));
        return true;
    }
    return false;
}",1,"/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
","/**
 * Populates outRanking with ranking information for the notification
 * with the given key.
 *
 * @return true if a valid key has been passed and outRanking has
 * been populated; false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement, control dependency, and the dependent API use have all changed. The early implementation computes a rank and populates the outRanking, while the late implementation checks if `mRankings` contains the key and directly populates `outRanking` with `mRankings.get(key)`. There is no longer a call to multiple methods like `getRank(key)` or `isIntercepted(key)` to populate `outRanking`, and the return value is now directly based on the presence of the key in `mRankings`. This amounts to changes in the return statement, control structure, and dependent API use, hence the code change type is 1,3,5.","The return value has changed since the early implementation's return value depends on the computed rank, while the late implementation returns true if the key is found in `mRankings`. This could lead to different behaviors if, for example, the conditions for key presence in `mRankings` are different from the conditions computed by the previous rank-based checks. Consequently, the late implementation may return different true/false results than the early implementation for the same input. Therefore, the CI type is 1."
713,<android.view.textclassifier.TextClassification.Request.Builder: Request build()>,28,29,<android.view.textclassifier.TextClassification.Request.Builder: Request build()>,<android.view.textclassifier.TextClassification.Request.Builder: Request build()>,0,"{
    return new Request(mText, mStartIndex, mEndIndex, mDefaultLocales, mReferenceTime);
}","{
    return new Request(new SpannedString(mText), mStartIndex, mEndIndex, mDefaultLocales, mReferenceTime, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns the request object.
 */
","/**
 * Builds and returns the request object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been changed to include new arguments `new SpannedString(mText)` and conditionally also `mExtras`, and it is also passing a different argument type for the text (SpannedString wrapper instead of the direct mText). Additionally, The dependency on the constructor of `Request` has changed to include a new parameter, which represents a change in a dependent API. Thus, the code change types are 1,4,5.","There is a difference in the type of object being created (`SpannedString` of `mText` instead of `mText` directly) and potentially the presence of an extra `mExtras` argument, which will result in a different object being returned by the `build()` method. This means the behavior of the API has potentially changed, causing a CI type 1."
714,<android.view.autofill.AutofillManager: List<String> getAvailableFieldClassificationAlgorithms()>,28,29,<android.view.autofill.AutofillManager: List<String> getAvailableFieldClassificationAlgorithms()>,<android.view.autofill.AutofillManager: List<String> getAvailableFieldClassificationAlgorithms()>,0,"{
    final String[] algorithms;
    try {
        algorithms = mService.getAvailableFieldClassificationAlgorithms();
        return algorithms != null ? Arrays.asList(algorithms) : Collections.emptyList();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getAvailableFieldClassificationAlgorithms(receiver);
        final String[] algorithms = receiver.getStringArrayResult();
        return algorithms != null ? Arrays.asList(algorithms) : Collections.emptyList();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}",1,"/**
 * Gets the name of all algorithms currently available for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it returns an empty list if the caller currently doesn't have an enabled autofill service
 * for the user.
 */
","/**
 * Gets the name of all algorithms currently available for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it returns an empty list if the caller currently doesn't have an enabled autofill service
 * for the user.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"The way of obtaining available field classification algorithms has been changed from direct method call to using a SyncResultReceiver, and the dependent API mService.getAvailableFieldClassificationAlgorithms() is now being called with different parameters. This is a change of type 4,5.","The structure of obtaining the algorithms has changed, which means the list of Strings returned could potentially be different due to the introduction of the SyncResultReceiver and changes in how the service method is called, leading to a different potential return value. Hence, a Compatibility Issue of type 1 could arise."
715,"<android.app.admin.DevicePolicyManager: List<NetworkEvent> retrieveNetworkLogs(ComponentName,long)>",28,29,"<android.app.admin.DevicePolicyManager: List<NetworkEvent> retrieveNetworkLogs(ComponentName,long)>","<android.app.admin.DevicePolicyManager: List<NetworkEvent> retrieveNetworkLogs(ComponentName,long)>",0,"{
    throwIfParentInstance(""retrieveNetworkLogs"");
    try {
        return mService.retrieveNetworkLogs(admin, batchToken);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""retrieveNetworkLogs"");
    try {
        return mService.retrieveNetworkLogs(admin, mContext.getPackageName(), batchToken);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by device owner to retrieve the most recent batch of network logging events.
 * A device owner has to provide a batchToken provided as part of
 * {@link DeviceAdminReceiver#onNetworkLogsAvailable} callback. If the token doesn't match the
 * token of the most recent available batch of logs, {@code null} will be returned.
 *
 * <p> {@link NetworkEvent} can be one of {@link DnsEvent} or {@link ConnectEvent}.
 *
 * <p> The list of network events is sorted chronologically, and contains at most 1200 events.
 *
 * <p> Access to the logs is rate limited and this method will only return a new batch of logs
 * after the device device owner has been notified via
 * {@link DeviceAdminReceiver#onNetworkLogsAvailable}.
 *
 * <p>If a secondary user or profile is created, calling this method will throw a
 * {@link SecurityException} until all users become affiliated again. It will also no longer be
 * possible to retrieve the network logs batch with the most recent batchToken provided
 * by {@link DeviceAdminReceiver#onNetworkLogsAvailable}. See
 * {@link DevicePolicyManager#setAffiliationIds}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param batchToken A token of the batch to retrieve
 * @return A new batch of network logs which is a list of {@link NetworkEvent}. Returns
 * {@code null} if the batch represented by batchToken is no longer available or if
 * logging is disabled.
 * @throws SecurityException if {@code admin} is not a device owner, or there is at least one
 * profile or secondary user that is not affiliated with the device.
 * @see #setAffiliationIds
 * @see DeviceAdminReceiver#onNetworkLogsAvailable
 */
","/**
 * Called by device owner or delegated app with {@link #DELEGATION_NETWORK_LOGGING} to retrieve
 * the most recent batch of network logging events.
 * A device owner has to provide a batchToken provided as part of
 * {@link DeviceAdminReceiver#onNetworkLogsAvailable} callback. If the token doesn't match the
 * token of the most recent available batch of logs, {@code null} will be returned.
 *
 * <p> {@link NetworkEvent} can be one of {@link DnsEvent} or {@link ConnectEvent}.
 *
 * <p> The list of network events is sorted chronologically, and contains at most 1200 events.
 *
 * <p> Access to the logs is rate limited and this method will only return a new batch of logs
 * after the device device owner has been notified via
 * {@link DeviceAdminReceiver#onNetworkLogsAvailable}.
 *
 * <p>If a secondary user or profile is created, calling this method will throw a
 * {@link SecurityException} until all users become affiliated again. It will also no longer be
 * possible to retrieve the network logs batch with the most recent batchToken provided
 * by {@link DeviceAdminReceiver#onNetworkLogsAvailable}. See
 * {@link DevicePolicyManager#setAffiliationIds}.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with, or
 * {@code null} if called by a delegated app.
 * @param batchToken A token of the batch to retrieve
 * @return A new batch of network logs which is a list of {@link NetworkEvent}. Returns
 * {@code null} if the batch represented by batchToken is no longer available or if
 * logging is disabled.
 * @throws SecurityException if {@code admin} is not a device owner, or there is at least one
 * profile or secondary user that is not affiliated with the device.
 * @see #setAffiliationIds
 * @see DeviceAdminReceiver#onNetworkLogsAvailable
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The early and late versions of the implementation have an additional parameter 'mContext.getPackageName()' passed to 'mService.retrieveNetworkLogs' method. This is a change to a dependent API, so the code change type is 5.","Although the dependent API mService.retrieveNetworkLogs has an additional parameter in the late version, it is an internal detail and does not change the method contract or behavior from the client's perspective. The method's signature, return type, the exception it throws, and the nullability contract indicated by the annotations remain the same. Therefore, there is no compatibility issue, and the type is 0."
716,"<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>",28,29,"<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>","<android.view.inputmethod.InputMethodManager: void setInputMethod(IBinder,String)>",0,"{
    setInputMethodInternal(token, id);
}","{
    if (token == null) {
        // temporary remedy.
        if (id == null) {
            return;
        }
        if (Process.myUid() == Process.SYSTEM_UID) {
            Log.w(TAG, ""System process should not be calling setInputMethod() because almost "" + ""always it is a bug under multi-user / multi-profile environment. "" + ""Consider interacting with InputMethodManagerService directly via "" + ""LocalServices."");
            return;
        }
        final Context fallbackContext = ActivityThread.currentApplication();
        if (fallbackContext == null) {
            return;
        }
        if (fallbackContext.checkSelfPermission(WRITE_SECURE_SETTINGS) != PackageManager.PERMISSION_GRANTED) {
            return;
        }
        final List<InputMethodInfo> imis = getEnabledInputMethodList();
        final int numImis = imis.size();
        boolean found = false;
        for (int i = 0; i < numImis; ++i) {
            final InputMethodInfo imi = imis.get(i);
            if (id.equals(imi.getId())) {
                found = true;
                break;
            }
        }
        if (!found) {
            Log.e(TAG, ""Ignoring setInputMethod(null, "" + id + "") because the specified "" + ""id not found in enabled IMEs."");
            return;
        }
        Log.w(TAG, ""The undocumented behavior that setInputMethod() accepts null token "" + ""when the caller has WRITE_SECURE_SETTINGS is deprecated. This behavior may "" + ""be completely removed in a future version.  Update secure settings directly "" + ""instead."");
        final ContentResolver resolver = fallbackContext.getContentResolver();
        Settings.Secure.putInt(resolver, Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE, NOT_A_SUBTYPE_ID);
        Settings.Secure.putString(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, id);
        return;
    }
    InputMethodPrivilegedOperationsRegistry.get(token).setInputMethod(id);
}",1,"/**
 * Force switch to a new input method component. This can only be called
 * from an application or a service which has a token of the currently active input method.
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @deprecated Use {@link InputMethodService#switchInputMethod(String)}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
","/**
 * Force switch to a new input method component. This can only be called
 * from an application or a service which has a token of the currently active input method.
 *
 * <p>On Android {@link Build.VERSION_CODES#Q} and later devices, the undocumented behavior that
 * token can be {@code null} when the caller has
 * {@link android.Manifest.permission#WRITE_SECURE_SETTINGS} is deprecated. Instead, update
 * {@link android.provider.Settings.Secure#DEFAULT_INPUT_METHOD} and
 * {@link android.provider.Settings.Secure#SELECTED_INPUT_METHOD_SUBTYPE} directly.</p>
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param id The unique identifier for the new input method to be switched to.
 * @deprecated Use {@link InputMethodService#switchInputMethod(String)}
 * instead. This method was intended for IME developers who should be accessing APIs through
 * the service. APIs in this class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The late version introduces new control structures (if-else blocks), exception handling (checkSelfPermission()), and other statements (logging, settings changes). There is a change in control dependency because of the newly added conditional checks, a change in exception handling due to permission check, and other changes like logging messages and direct writing to secure settings. So, the code change type is 1,2,3,4.","The late version introduces additional checks and behaviors that were not present in the early version. This includes returning early in several new scenarios and potentially not calling setInputMethodInternal() or InputMethodPrivilegedOperationsRegistry.get(token).setInputMethod(id). Since these additional checks could lead to different return behaviors (due to the new 'return' statements) and different exceptions (due to the new permission check leading to early exits), there is a compatibility issue of types 1 and 2."
717,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",28,29,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>","<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",0,"{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
            if (pointerIcon != null) {
                if (preorderedList != null)
                    preorderedList.clear();
                return pointerIcon;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}","{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
            if (pointerIcon != null) {
                if (preorderedList != null)
                    preorderedList.clear();
                return pointerIcon;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the method implementation is the modification of the method call from `canViewReceivePointerEvents(child)` to `child.canReceivePointerEvents()`. This represents an internal refactoring, potentially changing the way the method is invoked without altering the external behavior of the API, therefore the change type is 4.","Since this change does not affect the return value, nor does it introduce new exception handling, there is no Compatibility Issue (CI type is 0). It's an internal change to how the method call is made on the object, which should not impact the contract of the method as perceived by the caller."
718,<android.inputmethodservice.InputMethodService: void onDestroy()>,28,29,<android.inputmethodservice.InputMethodService: void onDestroy()>,<android.inputmethodservice.InputMethodService: void onDestroy()>,0,"{
    super.onDestroy();
    mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
    doFinishInput();
    if (mWindowAdded) {
        // Disable exit animation for the current IME window
        // to avoid the race condition between the exit and enter animations
        // when the current IME is being switched to another one.
        mWindow.getWindow().setWindowAnimations(0);
        mWindow.dismiss();
    }
    if (mSettingsObserver != null) {
        mSettingsObserver.unregister();
        mSettingsObserver = null;
    }
}","{
    super.onDestroy();
    mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
    doFinishInput();
    mWindow.dismissForDestroyIfNecessary();
    if (mSettingsObserver != null) {
        mSettingsObserver.unregister();
        mSettingsObserver = null;
    }
    if (mToken != null) {
        // This is completely optional, but allows us to show more explicit error messages
        // when IME developers are doing something unsupported.
        InputMethodPrivilegedOperationsRegistry.remove(mToken);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"There is a change in method invocation from mWindow.dismiss(); to mWindow.dismissForDestroyIfNecessary();, and there is an addition of a new conditional block which checks if mToken is not null and removes it from the InputMethodPrivilegedOperationsRegistry. These changes are both other statement changes and dependent API changes (4,5), because even though the mWindow.dismiss() method invocation has changed, mWindow is of a class member type, hence mWindow.dismissForDestroyIfNecessary() is considered a dependent API change.","There is no compatibility issue detected here. Although the implementation has changed, neither of these changes should affect the external behavior of the onDestroy() method from the perspective of the function's contract. The new code performs similar functionality to the old code while adding a removal from InputMethodPrivilegedOperationsRegistry, which should not affect how onDestroy() operates from the client's point of view. Hence, these changes do not lead to different return values or different exception handlings to the users of the API, thus no CI is detected."
719,<android.hardware.usb.UsbDevice: String getSerialNumber()>,28,29,<android.hardware.usb.UsbDevice: String getSerialNumber()>,<android.hardware.usb.UsbDevice: String getSerialNumber()>,0,"{
    return mSerialNumber;
}","{
    try {
        return mSerialNumberReader.getSerial(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}",1,"/**
 * Returns the serial number of the device.
 *
 * @return the serial number name, or {@code null} if the property could not be read
 */
","/**
 * Returns the serial number of the device.
 *
 * @return the serial number name, or {@code null} if the property could not be read
 *
 * @throws SecurityException if the app targets SDK >= {@value android.os.Build.VERSION_CODES#Q}
 * and the app does not have permission to read from the device.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The return statement changed from directly returning a field to involving a method call that may throw an exception. A new catch block for `RemoteException` is introduced with new behavior, i.e., calling `e.rethrowFromSystemServer()` instead of just logging the exception or returning a default value. Additionally, there is a change concerning the Dependent API because `mSerialNumberReader.getSerial` is a new method dependency. Therefore, the change types are 1, 2, and 5.","This change introduces both a different return type/value and exception handling behavior. Since a new method call is introduced, there's a potential for `getSerial()` to fail and throw a RemoteException, which wasn't possible before. The RemoteException is then rethrown as a system server exception, changing the nature of how exceptions are processed and handled. The original method would never throw an exception, simply returning null, while the new implementation may cause a RemoteException to propagate as a different exception type after being rethrown from the system server. Thus, both return values and exceptions could differ, leading to CI types 1 and 2."
720,<android.view.WindowInsets: boolean hasInsets()>,28,29,<android.view.WindowInsets: boolean hasInsets()>,<android.view.WindowInsets: boolean hasInsets()>,0,"{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets() || mDisplayCutout != null;
}","{
    return !getInsets(mTypeInsetsMap, all()).equals(Insets.NONE) || !getInsets(mTypeMaxInsetsMap, all()).equals(Insets.NONE) || mDisplayCutout != null;
}",1,"/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
","/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method invocation within the return statement has been changed from direct method calls (e.g., hasSystemWindowInsets()) to calls involving getInsets() with different parameters, and a comparison with 'Insets.NONE' has also been introduced. This indicates both a return statement change and a change in the dependent API. The code change type is 1,5.","The new implementation is using a different mechanism to determine if the WindowInsets has insets. This change can potentially lead to the method returning different results compared to the previous implementation. Therefore, there is a potential for a different return value, which is why the CI type is 1."
721,"<android.app.Instrumentation: Activity startActivitySync(Intent,Bundle)>",28,29,"<android.app.Instrumentation: Activity startActivitySync(Intent,Bundle)>","<android.app.Instrumentation: Activity startActivitySync(Intent,Bundle)>",0,"{
    validateNotAppThread();
    synchronized (mSync) {
        intent = new Intent(intent);
        ActivityInfo ai = intent.resolveActivityInfo(getTargetContext().getPackageManager(), 0);
        if (ai == null) {
            throw new RuntimeException(""Unable to resolve activity for: "" + intent);
        }
        String myProc = mThread.getProcessName();
        if (!ai.processName.equals(myProc)) {
            // there is a single match that is in our package.
            throw new RuntimeException(""Intent in process "" + myProc + "" resolved to different process "" + ai.processName + "": "" + intent);
        }
        intent.setComponent(new ComponentName(ai.applicationInfo.packageName, ai.name));
        final ActivityWaiter aw = new ActivityWaiter(intent);
        if (mWaitingActivities == null) {
            mWaitingActivities = new ArrayList();
        }
        mWaitingActivities.add(aw);
        getTargetContext().startActivity(intent, options);
        do {
            try {
                mSync.wait();
            } catch (InterruptedException e) {
            }
        } while (mWaitingActivities.contains(aw));
        return aw.activity;
    }
}","{
    validateNotAppThread();
    synchronized (mSync) {
        intent = new Intent(intent);
        ActivityInfo ai = intent.resolveActivityInfo(getTargetContext().getPackageManager(), 0);
        if (ai == null) {
            throw new RuntimeException(""Unable to resolve activity for: "" + intent);
        }
        String myProc = mThread.getProcessName();
        if (!ai.processName.equals(myProc)) {
            // there is a single match that is in our package.
            throw new RuntimeException(""Intent in process "" + myProc + "" resolved to different process "" + ai.processName + "": "" + intent);
        }
        intent.setComponent(new ComponentName(ai.applicationInfo.packageName, ai.name));
        final ActivityWaiter aw = new ActivityWaiter(intent);
        if (mWaitingActivities == null) {
            mWaitingActivities = new ArrayList();
        }
        mWaitingActivities.add(aw);
        getTargetContext().startActivity(intent, options);
        do {
            try {
                mSync.wait();
            } catch (InterruptedException e) {
            }
        } while (mWaitingActivities.contains(aw));
        waitForEnterAnimationComplete(aw.activity);
        return aw.activity;
    }
}",1,"/**
 * Start a new activity and wait for it to begin running before returning.
 * In addition to being synchronous, this method as some semantic
 * differences from the standard {@link Context#startActivity} call: the
 * activity component is resolved before talking with the activity manager
 * (its class name is specified in the Intent that this method ultimately
 * starts), and it does not allow you to start activities that run in a
 * different process.  In addition, if the given Intent resolves to
 * multiple activities, instead of displaying a dialog for the user to
 * select an activity, an exception will be thrown.
 *
 * <p>The function returns as soon as the activity goes idle following the
 * call to its {@link Activity#onCreate}.  Generally this means it has gone
 * through the full initialization including {@link Activity#onResume} and
 * drawn and displayed its initial window.
 *
 * @param intent Description of the activity to start.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.  See {@link android.app.ActivityOptions}
 * for how to build the Bundle supplied here; there are no supported definitions
 * for building it manually.
 *
 * @see Context#startActivity(Intent, Bundle)
 */
","/**
 * Start a new activity and wait for it to begin running before returning.
 * In addition to being synchronous, this method as some semantic
 * differences from the standard {@link Context#startActivity} call: the
 * activity component is resolved before talking with the activity manager
 * (its class name is specified in the Intent that this method ultimately
 * starts), and it does not allow you to start activities that run in a
 * different process.  In addition, if the given Intent resolves to
 * multiple activities, instead of displaying a dialog for the user to
 * select an activity, an exception will be thrown.
 *
 * <p>The function returns as soon as the activity goes idle following the
 * call to its {@link Activity#onCreate}.  Generally this means it has gone
 * through the full initialization including {@link Activity#onResume} and
 * drawn and displayed its initial window.
 *
 * @param intent Description of the activity to start.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.  See {@link android.app.ActivityOptions}
 * for how to build the Bundle supplied here; there are no supported definitions
 * for building it manually.
 *
 * @see Context#startActivity(Intent, Bundle)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"The additional method call `waitForEnterAnimationComplete(aw.activity)` does not alter the return value or the throwing of an exception, so the change type is 3 for control dependency change due to loop modification and 4 for another statement changed that doesn't impact the behavior detected by clients.","Although the code has the addition of the method call `waitForEnterAnimationComplete(aw.activity)`, this should not cause a compatibility issue as it does not affect the type or value of the returned `aw.activity`, nor does it introduce a change in exception handling. The contract of the method appears intact, and additional waiting for an animation to complete before returning does not change the return value or the exceptions that could be thrown by this method. Thus, there is no compatibility issue."
722,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",28,29,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>","<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null);
    context.setResources(packageInfo.getResources());
    return context;
}","{
    return createAppContext(mainThread, packageInfo, null);
}",1,,,-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"1,5",1,"The late version of the method delegates to another overloaded method, createAppContext(mainThread, packageInfo, null). This shows that a new dependent API is called instead of the previous direct instantiation and configuration of ContextImpl, indicating that there is a dependent API change. Additionally, the return statement is now calling a different method, which could potentially return different values, so both types 1 and 5 changes have occurred.","The change of the return statement to call another overloaded method suggests a potential Compatibility Issue of type 1 due to the possibility of different return values or types, depending on the implementation of the newly called method."
723,"<android.content.ContentProviderOperation: void writeToParcel(Parcel,int)>",28,29,"<android.content.ContentProviderOperation: void writeToParcel(Parcel,int)>","<android.content.ContentProviderOperation: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mType);
    Uri.writeToParcel(dest, mUri);
    if (mValues != null) {
        dest.writeInt(1);
        mValues.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSelection != null) {
        dest.writeInt(1);
        dest.writeString(mSelection);
    } else {
        dest.writeInt(0);
    }
    if (mSelectionArgs != null) {
        dest.writeInt(1);
        dest.writeStringArray(mSelectionArgs);
    } else {
        dest.writeInt(0);
    }
    if (mExpectedCount != null) {
        dest.writeInt(1);
        dest.writeInt(mExpectedCount);
    } else {
        dest.writeInt(0);
    }
    if (mValuesBackReferences != null) {
        dest.writeInt(1);
        mValuesBackReferences.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSelectionArgsBackReferences != null) {
        dest.writeInt(1);
        dest.writeInt(mSelectionArgsBackReferences.size());
        for (Map.Entry<Integer, Integer> entry : mSelectionArgsBackReferences.entrySet()) {
            dest.writeInt(entry.getKey());
            dest.writeInt(entry.getValue());
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mYieldAllowed ? 1 : 0);
}","{
    dest.writeInt(mType);
    Uri.writeToParcel(dest, mUri);
    if (mValues != null) {
        dest.writeInt(1);
        mValues.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSelection != null) {
        dest.writeInt(1);
        dest.writeString(mSelection);
    } else {
        dest.writeInt(0);
    }
    if (mSelectionArgs != null) {
        dest.writeInt(1);
        dest.writeStringArray(mSelectionArgs);
    } else {
        dest.writeInt(0);
    }
    if (mExpectedCount != null) {
        dest.writeInt(1);
        dest.writeInt(mExpectedCount);
    } else {
        dest.writeInt(0);
    }
    if (mValuesBackReferences != null) {
        dest.writeInt(1);
        mValuesBackReferences.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSelectionArgsBackReferences != null) {
        dest.writeInt(1);
        dest.writeInt(mSelectionArgsBackReferences.size());
        for (Map.Entry<Integer, Integer> entry : mSelectionArgsBackReferences.entrySet()) {
            dest.writeInt(entry.getKey());
            dest.writeInt(entry.getValue());
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mYieldAllowed ? 1 : 0);
    dest.writeInt(mFailureAllowed ? 1 : 0);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of a new line ""dest.writeInt(mFailureAllowed ? 1 : 0);"" which is a new field being written to the Parcel that wasn't written before, so the change type is 4.","The new line added merely writes additional data to the Parcel and doesn't affect the operation of the current API nor the existing behavior, so there is no Compatibility Issue."
724,<android.widget.TextView: void onEditorAction(int)>,28,29,<android.widget.TextView: void onEditorAction(int)>,<android.widget.TextView: void onEditorAction(int)>,0,"{
    final Editor.InputContentType ict = mEditor == null ? null : mEditor.mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_FORWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_FORWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_BACKWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_BACKWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            return;
        }
    }
    ViewRootImpl viewRootImpl = getViewRootImpl();
    if (viewRootImpl != null) {
        long eventTime = SystemClock.uptimeMillis();
        viewRootImpl.dispatchKeyFromIme(new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION));
        viewRootImpl.dispatchKeyFromIme(new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION));
    }
}","{
    final Editor.InputContentType ict = mEditor == null ? null : mEditor.mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_FORWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_FORWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_BACKWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_BACKWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = getInputMethodManager();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            return;
        }
    }
    ViewRootImpl viewRootImpl = getViewRootImpl();
    if (viewRootImpl != null) {
        long eventTime = SystemClock.uptimeMillis();
        viewRootImpl.dispatchKeyFromIme(new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION));
        viewRootImpl.dispatchKeyFromIme(new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION));
    }
}",1,"/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
","/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to obtain the `InputMethodManager` has changed; it used to be `InputMethodManager.peekInstance()` but now is `getInputMethodManager()`. So the code changes are classified as 4,5.","The method `getInputMethodManager()` is expected to return the same instance of `InputMethodManager` as `InputMethodManager.peekInstance()`, assuming `getInputMethodManager()` is just a renamed or refactored version not changing the semantical behavior. Therefore, we could infer that there's no Compatibility Issue as the return value or the behavior of the method is not expected to change, leading to pred_CI 0."
726,<android.content.Intent: boolean filterEquals(Intent)>,28,29,<android.content.Intent: boolean filterEquals(Intent)>,<android.content.Intent: boolean filterEquals(Intent)>,0,"{
    if (other == null) {
        return false;
    }
    if (!Objects.equals(this.mAction, other.mAction))
        return false;
    if (!Objects.equals(this.mData, other.mData))
        return false;
    if (!Objects.equals(this.mType, other.mType))
        return false;
    if (!Objects.equals(this.mPackage, other.mPackage))
        return false;
    if (!Objects.equals(this.mComponent, other.mComponent))
        return false;
    if (!Objects.equals(this.mCategories, other.mCategories))
        return false;
    return true;
}","{
    if (other == null) {
        return false;
    }
    if (!Objects.equals(this.mAction, other.mAction))
        return false;
    if (!Objects.equals(this.mData, other.mData))
        return false;
    if (!Objects.equals(this.mType, other.mType))
        return false;
    if (!Objects.equals(this.mIdentifier, other.mIdentifier))
        return false;
    if (!Objects.equals(this.mPackage, other.mPackage))
        return false;
    if (!Objects.equals(this.mComponent, other.mComponent))
        return false;
    if (!Objects.equals(this.mCategories, other.mCategories))
        return false;
    return true;
}",1,"/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */
","/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type, identity,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.  Note that technically when actually
 * matching against an {@link IntentFilter} the identifier is ignored, while here
 * it is directly compared for equality like the other fields.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The condition `!Objects.equals(this.mComponent, other.mComponent)` has been replaced with `!Objects.equals(this.mIdentifier, other.mIdentifier)`. This is a change in the object field being compared, leading to different return values when the compared field is not the same between `this` and `other`, so the change type includes 1 for changed return statement and 4 for other statement changed (change in the content of comparison).","Because the change in the comparison statement could lead to a different boolean result being returned than in the previous API version, the API now has a potential Compatibility Issue caused by potential different return values, which corresponds to CI type 1."
727,<android.util.SparseArray: E valueAt(int)>,28,29,<android.util.SparseArray: E valueAt(int)>,<android.util.SparseArray: E valueAt(int)>,0,"{
    if (mGarbage) {
        gc();
    }
    return (E) mValues[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mGarbage) {
        gc();
    }
    return (E) mValues[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>,
 * the behavior is undefined.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>,
 * the behavior is undefined for apps targeting {@link android.os.Build.VERSION_CODES#P} and
 * earlier, and an {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"2,3",2,"The late version introduces an additional index bounds check along with a new throw statement for an ArrayIndexOutOfBoundsException inside a new if-block, which are changes of types 2 and 3 in the code.","Exception handling has been changed by adding a new exception throw for ArrayIndexOutOfBoundsException when the index is out of bounds, which was not present in the early version. This introduces a new behavior where an exception might be thrown where previously there would have been none, thus the CI type is 2."
728,<android.app.NotificationChannelGroup: NotificationChannelGroup clone()>,28,29,<android.app.NotificationChannelGroup: NotificationChannelGroup clone()>,<android.app.NotificationChannelGroup: NotificationChannelGroup clone()>,0,"{
    NotificationChannelGroup cloned = new NotificationChannelGroup(getId(), getName());
    cloned.setDescription(getDescription());
    cloned.setBlocked(isBlocked());
    cloned.setChannels(getChannels());
    return cloned;
}","{
    NotificationChannelGroup cloned = new NotificationChannelGroup(getId(), getName());
    cloned.setDescription(getDescription());
    cloned.setBlocked(isBlocked());
    cloned.setChannels(getChannels());
    cloned.lockFields(mUserLockedFields);
    return cloned;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new statement `cloned.lockFields(mUserLockedFields);` has been introduced that does not change the return statement nor the exception handling, so the change type is 4.","The added method call to set some internal state (lockFields) does not affect the return type or values, nor does it affect exception handling. Thus, there is no compatibility issue, and the CI type is 0."
729,<android.view.autofill.AutofillId: String toString()>,28,29,<android.view.autofill.AutofillId: String toString()>,<android.view.autofill.AutofillId: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder().append(mViewId);
    if (mVirtual) {
        builder.append(':').append(mVirtualId);
    }
    return builder.toString();
}","{
    final StringBuilder builder = new StringBuilder().append(mViewId);
    if (isVirtualInt()) {
        builder.append(':').append(mVirtualIntId);
    } else if (isVirtualLong()) {
        builder.append(':').append(mVirtualLongId);
    }
    if (hasSession()) {
        builder.append('@').append(mSessionId);
    }
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Control statements have been added, and other statements changed with added conditions to append different values to the StringBuilder object (mVirtualIntId or mVirtualLongId), also there's an additional condition to append mSessionId. Hence, the change types are 3 and 4.","The addition of conditions introduces different string construction behaviors, which will alter the return value when the method is invoked. As a result, the API has a potential to return different values in the new version than the old one, which constitutes a Compatibility Issue of type 1."
730,<android.service.notification.ZenModeConfig.EventInfo: EventInfo copy()>,28,29,<android.service.notification.ZenModeConfig.EventInfo: EventInfo copy()>,<android.service.notification.ZenModeConfig.EventInfo: EventInfo copy()>,0,"{
    final EventInfo rt = new EventInfo();
    rt.userId = userId;
    rt.calendar = calendar;
    rt.reply = reply;
    return rt;
}","{
    final EventInfo rt = new EventInfo();
    rt.userId = userId;
    rt.calName = calName;
    rt.reply = reply;
    rt.calendarId = calendarId;
    return rt;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation adds a new field assignment to rt.calendarId and changes an assignment from rt.calendar to rt.calName. Therefore, there is the addition of a new assignment statement and a change to the data being set on the object, which are not part of the return, exception handling, or control dependency changes, so the code change types are 1 (for the return object having additional fields set) and 4 (for the change in what data is being set on the object).","The change will lead the API to potentially return an object with different data, which specifically includes additional data (calendarId) and modifications to existing data (calName instead of calendar). This qualifies as a Compatibility Issue caused by potential different return values, and thus the CI type is 1."
731,<android.bluetooth.le.ScanFilter: String toString()>,28,29,<android.bluetooth.le.ScanFilter: String toString()>,<android.bluetooth.le.ScanFilter: String toString()>,0,"{
    return ""BluetoothLeScanFilter [mDeviceName="" + mDeviceName + "", mDeviceAddress="" + mDeviceAddress + "", mUuid="" + mServiceUuid + "", mUuidMask="" + mServiceUuidMask + "", mServiceDataUuid="" + Objects.toString(mServiceDataUuid) + "", mServiceData="" + Arrays.toString(mServiceData) + "", mServiceDataMask="" + Arrays.toString(mServiceDataMask) + "", mManufacturerId="" + mManufacturerId + "", mManufacturerData="" + Arrays.toString(mManufacturerData) + "", mManufacturerDataMask="" + Arrays.toString(mManufacturerDataMask) + ""]"";
}","{
    return ""BluetoothLeScanFilter [mDeviceName="" + mDeviceName + "", mDeviceAddress="" + mDeviceAddress + "", mUuid="" + mServiceUuid + "", mUuidMask="" + mServiceUuidMask + "", mServiceSolicitationUuid="" + mServiceSolicitationUuid + "", mServiceSolicitationUuidMask="" + mServiceSolicitationUuidMask + "", mServiceDataUuid="" + Objects.toString(mServiceDataUuid) + "", mServiceData="" + Arrays.toString(mServiceData) + "", mServiceDataMask="" + Arrays.toString(mServiceDataMask) + "", mManufacturerId="" + mManufacturerId + "", mManufacturerData="" + Arrays.toString(mManufacturerData) + "", mManufacturerDataMask="" + Arrays.toString(mManufacturerDataMask) + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The return statement is modified to include additional information about `mServiceSolicitationUuid` and `mServiceSolicitationUuidMask`, replacing the `mServiceDataUuid`. Besides the return statement, there's no change to the logic of the method, so the changes are only in the return string format (class 1) and the other statement changed due to the addition of variables in the string (class 4).","Even though the return statement has changed, the method's behavior in terms of computation and outcome type remains the same. The method always returns a `String`, and the format of that string has no impact on the programmatic functionality of the API. Thus, the modifications do not cause compatibility issues in terms of changing the return value behavior of the method or the exception handling. Therefore there is no compatibility issue."
732,"<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>",28,29,"<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>","<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>",0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mCompletions = completions;
        if (mCurMethod != null) {
            try {
                mCurMethod.displayCompletions(mCompletions);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.displayCompletions(view, completions);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mCompletions = completions;
        if (mCurMethod != null) {
            try {
                mCurMethod.displayCompletions(mCompletions);
            } catch (RemoteException e) {
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is an additional block of code that checks if there is a necessity to get a fallback `InputMethodManager` and calls the `displayCompletions` method of the fallback instance if needed. Also, variable scoping and sequencing of operations has changed with the introduction of the fallback logic before the `checkFocus` and `synchronized` block. Thus, the code change type is 3 (due to different sequence of operations i.e., control dependency change), and 4 (because of the addition of new code that does not fall under the previous categories).","There is no Compatibility Issue, because the fallback `InputMethodManager` will call the same `displayCompletions` method on itself with the same parameters, and if the fallback is not necessary, the original operation flow is preserved. Changes are made to support different context situations without affecting the original behavior when the context is correct, so no difference in exception handling or return values under normal operation conditions are expected. Therefore, the CI type is 0."
733,"<android.provider.DocumentsContract: Uri copyDocument(ContentResolver,Uri,Uri)>",28,29,"<android.provider.DocumentsContract: Uri copyDocument(ContentResolver,Uri,Uri)>","<android.provider.DocumentsContract: Uri copyDocument(ContentResolver,Uri,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(sourceDocumentUri.getAuthority());
    try {
        return copyDocument(client, sourceDocumentUri, targetParentDocumentUri);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to copy document"", e);
        rethrowIfNecessary(resolver, e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, sourceDocumentUri);
        in.putParcelable(DocumentsContract.EXTRA_TARGET_URI, targetParentDocumentUri);
        final Bundle out = content.call(sourceDocumentUri.getAuthority(), METHOD_COPY_DOCUMENT, null, in);
        return out.getParcelable(DocumentsContract.EXTRA_URI);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to copy document"", e);
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Copies the given document.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_COPY}
 * @param targetParentDocumentUri document which will become a parent of the source
 * document's copy.
 * @return the copied document, or {@code null} if failed.
 */
","/**
 * Copies the given document.
 *
 * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_COPY}
 * @param targetParentDocumentUri document which will become a parent of the source
 * document's copy.
 * @return the copied document, or {@code null} if failed.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","There are changes in the signature of the method being called and how the exception is rethrown, as well as the implementation logic and control flow. The statements in the 'try' block and 'catch' block have been altered significantly, including the deletion of a call to acquireUnstableContentProviderClient, rethrowIfNecessary(resolver, e) and ContentProviderClient.releaseQuietly(client) in the finally block, so the code change types are 1,2,3,4,5.","With the deletion of the return null statement which may have happened in the previous version in case of an exception that wasn't necessary to rethrow, and the change in how exceptions are handled (rethrowIfNecessary(e) without passing the resolver), along with a new method of creating the output Uri, there are potential Compatibility Issues in both value returned (type 1) and exception handling (type 2)."
734,<android.inputmethodservice.InputMethodService: boolean switchToNextInputMethod(boolean)>,28,29,<android.inputmethodservice.InputMethodService: boolean switchToNextInputMethod(boolean)>,<android.inputmethodservice.InputMethodService: boolean switchToNextInputMethod(boolean)>,0,"{
    return mImm.switchToNextInputMethodInternal(mToken, onlyCurrentIme);
}","{
    return mPrivOps.switchToNextInputMethod(onlyCurrentIme);
}",1,"/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 */
","/**
 * Force switch to the next input method and subtype. If there is no IME enabled except
 * current IME and subtype, do nothing.
 * @param onlyCurrentIme if true, the framework will find the next subtype which
 * belongs to the current IME
 * @return true if the current input method and subtype was successfully switched to the next
 * input method and subtype.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from calling mImm.switchToNextInputMethodInternal(...) to mPrivOps.switchToNextInputMethod(...), this indicates that a Dependent API changed, hence the code change type is 5.","Even though the method invoked changed, there is no indication of a change in behavior that would lead to a Compatibility Issue. As the method name and return type remain the same, and there is no explicit alteration of the return value or exception handling, the CI type is 0."
735,<android.app.Activity: void performPause()>,28,29,<android.app.Activity: void performPause()>,<android.app.Activity: void performPause()>,0,"{
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    writeEventLog(LOG_AM_ON_PAUSE_CALLED, ""performPause"");
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
}","{
    dispatchActivityPrePaused();
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    writeEventLog(LOG_AM_ON_PAUSE_CALLED, ""performPause"");
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    dispatchActivityPostPaused();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The addition of dispatchActivityPrePaused() before the existing code and dispatchActivityPostPaused() after the existing code are the only changes, which account for Other statement changed, so the code change type is 4.","The added method calls to dispatchActivityPrePaused() and dispatchActivityPostPaused() do not affect the existing control flow or exception handling, nor do they change the return type or throw new exceptions. They are likely used for internal state management or callbacks which do not alter the behavior observed by the caller of performPause(). Therefore, these changes do not lead to a Compatibility Issue."
736,"<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>",28,29,"<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>","<android.app.usage.NetworkStatsManager: NetworkStats querySummary(int,String,long,long)>",0,"{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
    result.startSummaryEnumeration();
    return result;
}","{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, ""Cannot create template"", e);
        return null;
    }
    return querySummary(template, startTime, endTime);
}",1,"/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state, uid, default network, metered, or roaming. This
 * means buckets' start and end timestamps are going to be the same as the 'startTime' and
 * 'endTime' parameters. State, uid, metered, and roaming are going to vary, and tag is going to
 * be the same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
","/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state, uid, default network, metered, or roaming. This
 * means buckets' start and end timestamps are going to be the same as the 'startTime' and
 * 'endTime' parameters. State, uid, metered, and roaming are going to vary, and tag is going to
 * be the same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed to invoke a different method called `querySummary` with different parameters. Previously, the method was manually creating a `NetworkStats` object and starting summary enumeration on it, but now it just calls `querySummary`. This constitutes a dependent API change as well, since the implementation now depends on the `querySummary` method signature and behavior, which could be changed. Hence, the code change type is 1,5.","Since the return statement changed, and it is now using a different method to obtain `NetworkStats`, the returned `NetworkStats` can be different based on the internal implementation of `querySummary`. The change in the return value could potentially cause a compatibility issue if the behavior of `querySummary` differs from the manually instantiated `NetworkStats` in the early version. Therefore, the CI type is 1."
737,"<android.view.animation.AnimationSet: boolean getTransformation(long,Transformation)>",28,29,"<android.view.animation.AnimationSet: boolean getTransformation(long,Transformation)>","<android.view.animation.AnimationSet: boolean getTransformation(long,Transformation)>",0,"{
    final int count = mAnimations.size();
    final ArrayList<Animation> animations = mAnimations;
    final Transformation temp = mTempTransformation;
    boolean more = false;
    boolean started = false;
    boolean ended = true;
    t.clear();
    for (int i = count - 1; i >= 0; --i) {
        final Animation a = animations.get(i);
        temp.clear();
        more = a.getTransformation(currentTime, temp, getScaleFactor()) || more;
        t.compose(temp);
        started = started || a.hasStarted();
        ended = a.hasEnded() && ended;
    }
    if (started && !mStarted) {
        if (mListener != null) {
            mListener.onAnimationStart(this);
        }
        mStarted = true;
    }
    if (ended != mEnded) {
        if (mListener != null) {
            mListener.onAnimationEnd(this);
        }
        mEnded = ended;
    }
    return more;
}","{
    final int count = mAnimations.size();
    final ArrayList<Animation> animations = mAnimations;
    final Transformation temp = mTempTransformation;
    boolean more = false;
    boolean started = false;
    boolean ended = true;
    t.clear();
    for (int i = count - 1; i >= 0; --i) {
        final Animation a = animations.get(i);
        temp.clear();
        more = a.getTransformation(currentTime, temp, getScaleFactor()) || more;
        t.compose(temp);
        started = started || a.hasStarted();
        ended = a.hasEnded() && ended;
    }
    if (started && !mStarted) {
        dispatchAnimationStart();
        mStarted = true;
    }
    if (ended != mEnded) {
        dispatchAnimationEnd();
        mEnded = ended;
    }
    return more;
}",1,"/**
 * The transformation of an animation set is the concatenation of all of its
 * component animations.
 *
 * @see android.view.animation.Animation#getTransformation
 */
","/**
 * The transformation of an animation set is the concatenation of all of its
 * component animations.
 *
 * @see android.view.animation.Animation#getTransformation
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method calls within the 'if' statements have changed from direct listener calls to dispatch methods (dispatchAnimationStart() and dispatchAnimationEnd()), so the code change type is 4.","There is no Compatibility Issue caused by this change, as the behavior of starting and ending the animation is still being communicated through internal dispatch methods rather than directly invoking listener methods. The outward behavior and the return value of this method remain unchanged. The change is an internal refactoring that does not affect the method's contract."
738,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,28,29,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the early version and late version of the method is the lock object used in the synchronized block: it changes from `mDeviceBusy` to `mDeviceBusyLock`. This is an internal synchronization implementation detail and does not reflect a change in the API's external behavior, so the code change type is 4.","Since the method's external behavior and its return values remain consistent irrespective of the internal lock object used for synchronization, there is no compatibility issue, and the CI type is 0."
739,<android.view.WindowInsets: WindowInsets replaceSystemWindowInsets(Rect)>,28,29,<android.view.WindowInsets: WindowInsets replaceSystemWindowInsets(Rect)>,<android.view.WindowInsets: WindowInsets replaceSystemWindowInsets(Rect)>,0,"{
    final WindowInsets result = new WindowInsets(this);
    result.mSystemWindowInsets = new Rect(systemWindowInsets);
    return result;
}","{
    return replaceSystemWindowInsets(systemWindowInsets.left, systemWindowInsets.top, systemWindowInsets.right, systemWindowInsets.bottom);
}",1,"/**
 * Returns a copy of this WindowInsets with selected system window insets replaced
 * with new values.
 *
 * @param systemWindowInsets New system window insets. Each field is the inset in pixels
 * for that edge
 * @return A modified copy of this WindowInsets
 */
","/**
 * Returns a copy of this WindowInsets with selected system window insets replaced
 * with new values.
 *
 * <p>Note: If the system window insets are already consumed, this method will return them
 * unchanged on {@link android.os.Build.VERSION_CODES#Q Q} and later. Prior to
 * {@link android.os.Build.VERSION_CODES#Q Q}, the new values were applied regardless of
 * whether they were consumed, and this method returns invalid non-zero consumed insets.
 *
 * @param systemWindowInsets New system window insets. Each field is the inset in pixels
 * for that edge
 * @return A modified copy of this WindowInsets
 * @deprecated use {@code Builder#Builder(WindowInsets)} with
 * {@link Builder#setSystemWindowInsets(Insets)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has been changed to call `replaceSystemWindowInsets` with individual edge inset values instead of passing a `Rect` object. This indicates a dependent API change as well as a change in the return statement because the construction of `WindowInsets` is now presumably different, so the change type is 1,5.","The change from creating a new `WindowInsets` object and setting the `mSystemWindowInsets` field directly to invoking the `replaceSystemWindowInsets` with different parameters could potentially lead to different return values. The fact that a different method is called with distinct parameters indicates that the resulting `WindowInsets` object might not be exactly the same as before, which could result in different behavior. Thus, there is a compatibility issue of type 1."
740,<android.net.UrlQuerySanitizer: String unescape(String)>,28,29,<android.net.UrlQuerySanitizer: String unescape(String)>,<android.net.UrlQuerySanitizer: String unescape(String)>,0,"{
    // Early exit if no escaped characters.
    int firstEscape = string.indexOf('%');
    if (firstEscape < 0) {
        firstEscape = string.indexOf('+');
        if (firstEscape < 0) {
            return string;
        }
    }
    int length = string.length();
    StringBuilder stringBuilder = new StringBuilder(length);
    stringBuilder.append(string.substring(0, firstEscape));
    for (int i = firstEscape; i < length; i++) {
        char c = string.charAt(i);
        if (c == '+') {
            c = ' ';
        } else if (c == '%' && i + 2 < length) {
            char c1 = string.charAt(i + 1);
            char c2 = string.charAt(i + 2);
            if (isHexDigit(c1) && isHexDigit(c2)) {
                c = (char) (decodeHexDigit(c1) * 16 + decodeHexDigit(c2));
                i += 2;
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}","{
    final Matcher matcher = plusOrPercent.matcher(string);
    if (!matcher.find())
        return string;
    final int firstEscape = matcher.start();
    int length = string.length();
    StringBuilder stringBuilder = new StringBuilder(length);
    stringBuilder.append(string.substring(0, firstEscape));
    for (int i = firstEscape; i < length; i++) {
        char c = string.charAt(i);
        if (c == '+') {
            c = ' ';
        } else if (c == '%' && i + 2 < length) {
            char c1 = string.charAt(i + 1);
            char c2 = string.charAt(i + 2);
            if (isHexDigit(c1) && isHexDigit(c2)) {
                c = (char) (decodeHexDigit(c1) * 16 + decodeHexDigit(c2));
                i += 2;
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}",1,"/**
 * Unescape an escaped string.
 * <ul>
 * <li>'+' characters are replaced by
 * ' ' characters.
 * <li>Valid ""%xx"" escape sequences are replaced by the
 * corresponding unescaped character.
 * <li>Invalid escape sequences such as %1z"", are passed through unchanged.
 * <ol>
 * @param string the escaped string
 * @return the unescaped string.
 */
",,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method implementation changed in the way it identifies the first escaped character, but eventually does the same thing. Instead of string.indexOf, it uses a Matcher to spot the first occurrence of either '+' or '%'. Therefore, the type of change is 'Other statement changed' (4).","Although there is a change in the implementation, there is no Compatibility Issue caused by this change. The method behaves the same way, finding the first occurrence of '%' or '+', and then unescaping the string accordingly. The result will still be the same as before, meaning that the return values will be consistent between versions, and no new exceptions are thrown. Therefore, there is 'No Compatibility Issue' (0)."
741,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",28,29,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>","<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",0,"{
    boolean result = false;
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            result = service.reportError(device, error);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.reportError(device, error);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in retrieving the service, the method 'getService()' is called instead of accessing 'mService' directly, so the change type is 4.","This change does not affect the functionality of the 'reportError' method, nor does it change the return value or potential exceptions thrown by the method. Therefore, there is no compatibility issue."
742,<android.view.View: float getRotation()>,28,29,<android.view.View: float getRotation()>,<android.view.View: float getRotation()>,0,"{
    return mRenderNode.getRotation();
}","{
    return mRenderNode.getRotationZ();
}",1,"/**
 * The degrees that the view is rotated around the pivot point.
 *
 * @see #setRotation(float)
 * @see #getPivotX()
 * @see #getPivotY()
 *
 * @return The degrees of rotation.
 */
","/**
 * The degrees that the view is rotated around the pivot point.
 *
 * @see #setRotation(float)
 * @see #getPivotX()
 * @see #getPivotY()
 *
 * @return The degrees of rotation.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing""), @InspectableProperty]",-1,-1,-1,-1,-1,-1,5,1,"There is a change in the dependent API from `getRotation()` to `getRotationZ()`, so the code change type is 5.","The change from `getRotation()` to `getRotationZ()` indicates a different method is being called which may lead to a different return value, hence the CI type is 1."
743,<android.net.LinkProperties: String toString()>,28,29,<android.net.LinkProperties: String toString()>,<android.net.LinkProperties: String toString()>,0,"{
    String ifaceName = (mIfaceName == null ? """" : ""InterfaceName: "" + mIfaceName + "" "");
    String linkAddresses = ""LinkAddresses: ["";
    for (LinkAddress addr : mLinkAddresses) linkAddresses += addr.toString() + "","";
    linkAddresses += ""] "";
    String dns = ""DnsAddresses: ["";
    for (InetAddress addr : mDnses) dns += addr.getHostAddress() + "","";
    dns += ""] "";
    String usePrivateDns = ""UsePrivateDns: "" + mUsePrivateDns + "" "";
    String privateDnsServerName = """";
    if (privateDnsServerName != null) {
        privateDnsServerName = ""PrivateDnsServerName: "" + mPrivateDnsServerName + "" "";
    }
    String validatedPrivateDns = """";
    if (!mValidatedPrivateDnses.isEmpty()) {
        validatedPrivateDns = ""ValidatedPrivateDnsAddresses: ["";
        for (InetAddress addr : mValidatedPrivateDnses) {
            validatedPrivateDns += addr.getHostAddress() + "","";
        }
        validatedPrivateDns += ""] "";
    }
    String domainName = ""Domains: "" + mDomains;
    String mtu = "" MTU: "" + mMtu;
    String tcpBuffSizes = """";
    if (mTcpBufferSizes != null) {
        tcpBuffSizes = "" TcpBufferSizes: "" + mTcpBufferSizes;
    }
    String routes = "" Routes: ["";
    for (RouteInfo route : mRoutes) routes += route.toString() + "","";
    routes += ""] "";
    String proxy = (mHttpProxy == null ? """" : "" HttpProxy: "" + mHttpProxy.toString() + "" "");
    String stacked = """";
    if (mStackedLinks.values().size() > 0) {
        stacked += "" Stacked: ["";
        for (LinkProperties link : mStackedLinks.values()) {
            stacked += "" ["" + link.toString() + "" ],"";
        }
        stacked += ""] "";
    }
    return ""{"" + ifaceName + linkAddresses + routes + dns + usePrivateDns + privateDnsServerName + domainName + mtu + tcpBuffSizes + proxy + stacked + ""}"";
}","{
    // Space as a separator, so no need for spaces at start/end of the individual fragments.
    final StringJoiner resultJoiner = new StringJoiner("" "", ""{"", ""}"");
    if (mIfaceName != null) {
        resultJoiner.add(""InterfaceName:"");
        resultJoiner.add(mIfaceName);
    }
    resultJoiner.add(""LinkAddresses: ["");
    if (!mLinkAddresses.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mLinkAddresses));
    }
    resultJoiner.add(""]"");
    resultJoiner.add(""DnsAddresses: ["");
    if (!mDnses.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mDnses));
    }
    resultJoiner.add(""]"");
    if (mUsePrivateDns) {
        resultJoiner.add(""UsePrivateDns: true"");
    }
    if (mPrivateDnsServerName != null) {
        resultJoiner.add(""PrivateDnsServerName:"");
        resultJoiner.add(mPrivateDnsServerName);
    }
    if (!mPcscfs.isEmpty()) {
        resultJoiner.add(""PcscfAddresses: ["");
        resultJoiner.add(TextUtils.join("","", mPcscfs));
        resultJoiner.add(""]"");
    }
    if (!mValidatedPrivateDnses.isEmpty()) {
        final StringJoiner validatedPrivateDnsesJoiner = new StringJoiner("","", ""ValidatedPrivateDnsAddresses: ["", ""]"");
        for (final InetAddress addr : mValidatedPrivateDnses) {
            validatedPrivateDnsesJoiner.add(addr.getHostAddress());
        }
        resultJoiner.add(validatedPrivateDnsesJoiner.toString());
    }
    resultJoiner.add(""Domains:"");
    resultJoiner.add(mDomains);
    resultJoiner.add(""MTU:"");
    resultJoiner.add(Integer.toString(mMtu));
    if (mTcpBufferSizes != null) {
        resultJoiner.add(""TcpBufferSizes:"");
        resultJoiner.add(mTcpBufferSizes);
    }
    resultJoiner.add(""Routes: ["");
    if (!mRoutes.isEmpty()) {
        resultJoiner.add(TextUtils.join("","", mRoutes));
    }
    resultJoiner.add(""]"");
    if (mHttpProxy != null) {
        resultJoiner.add(""HttpProxy:"");
        resultJoiner.add(mHttpProxy.toString());
    }
    if (mNat64Prefix != null) {
        resultJoiner.add(""Nat64Prefix:"");
        resultJoiner.add(mNat64Prefix.toString());
    }
    final Collection<LinkProperties> stackedLinksValues = mStackedLinks.values();
    if (!stackedLinksValues.isEmpty()) {
        final StringJoiner stackedLinksJoiner = new StringJoiner("","", ""Stacked: ["", ""]"");
        for (final LinkProperties lp : stackedLinksValues) {
            stackedLinksJoiner.add(""[ "" + lp + "" ]"");
        }
        resultJoiner.add(stackedLinksJoiner.toString());
    }
    return resultJoiner.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
744,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",28,29,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>","<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",0,"{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    int currentGeneration = -1;
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
                if (mGenerationTracker != null) {
                    currentGeneration = mGenerationTracker.getCurrentGeneration();
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                            mValues.put(name, value);
                        }
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                mValues.put(name, value);
            }
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    int currentGeneration = -1;
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
                if (mGenerationTracker != null) {
                    currentGeneration = mGenerationTracker.getCurrentGeneration();
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                            }
                        }
                        if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                            mValues.put(name, value);
                        }
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                mValues.put(name, value);
            }
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,,,,
745,<android.net.NetworkCapabilities: String toString()>,28,29,<android.net.NetworkCapabilities: String toString()>,<android.net.NetworkCapabilities: String toString()>,0,"{
    final StringBuilder sb = new StringBuilder(""["");
    if (0 != mTransportTypes) {
        sb.append("" Transports: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, ""|"");
    }
    if (0 != mNetworkCapabilities) {
        sb.append("" Capabilities: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (0 != mNetworkCapabilities) {
        sb.append("" Unwanted: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append("" LinkUpBandwidth>="").append(mLinkUpBandwidthKbps).append(""Kbps"");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append("" LinkDnBandwidth>="").append(mLinkDownBandwidthKbps).append(""Kbps"");
    }
    if (mNetworkSpecifier != null) {
        sb.append("" Specifier: <"").append(mNetworkSpecifier).append("">"");
    }
    if (hasSignalStrength()) {
        sb.append("" SignalStrength: "").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append("" Uid: "").append(mUids.valueAt(0).start);
        } else {
            sb.append("" Uids: <"").append(mUids).append("">"");
        }
    }
    if (mEstablishingVpnAppUid != INVALID_UID) {
        sb.append("" EstablishingAppUid: "").append(mEstablishingVpnAppUid);
    }
    if (null != mSSID) {
        sb.append("" SSID: "").append(mSSID);
    }
    sb.append(""]"");
    return sb.toString();
}","{
    final StringBuilder sb = new StringBuilder(""["");
    if (0 != mTransportTypes) {
        sb.append("" Transports: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, ""|"");
    }
    if (0 != mNetworkCapabilities) {
        sb.append("" Capabilities: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (0 != mUnwantedNetworkCapabilities) {
        sb.append("" Unwanted: "");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, ""&"");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append("" LinkUpBandwidth>="").append(mLinkUpBandwidthKbps).append(""Kbps"");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append("" LinkDnBandwidth>="").append(mLinkDownBandwidthKbps).append(""Kbps"");
    }
    if (mNetworkSpecifier != null) {
        sb.append("" Specifier: <"").append(mNetworkSpecifier).append("">"");
    }
    if (mTransportInfo != null) {
        sb.append("" TransportInfo: <"").append(mTransportInfo).append("">"");
    }
    if (hasSignalStrength()) {
        sb.append("" SignalStrength: "").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append("" Uid: "").append(mUids.valueAt(0).start);
        } else {
            sb.append("" Uids: <"").append(mUids).append("">"");
        }
    }
    if (mEstablishingVpnAppUid != INVALID_UID) {
        sb.append("" EstablishingAppUid: "").append(mEstablishingVpnAppUid);
    }
    if (null != mSSID) {
        sb.append("" SSID: "").append(mSSID);
    }
    sb.append(""]"");
    return sb.toString();
}",1,,,-1,[@Override],"[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,"3,4",0,"There is a control dependency change where an entirely new 'if' statement was introduced to check nullity of `mTransportInfo`, and then append its string representation if it's non-null. Additionally, an 'if' condition that checks `mUnwantedNetworkCapabilities` has been corrected to use the appropriate variable name. The Other statement changed is due to the insertion of new statements to handle `mTransportInfo`.","While these are code changes, they do not cause a Compatibility Issue because they either correct previous logic (to check the correct variable) or add additional information to the string representation, which does not affect the return type or structure in a way that would cause backwards incompatibility. The appended information does not impact existing behavior for older clients that would use this method."
746,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",28,29,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",0,"{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            final InflateException ie = new InflateException(e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } catch (Exception e) {
            final InflateException ie = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
        return result;
    }
}","{
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""inflate"");
        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;
        try {
            advanceToRootNode(parser);
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            final InflateException ie = new InflateException(e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } catch (Exception e) {
            final InflateException ie = new InflateException(getParserStateDescription(inflaterContext, attrs) + "": "" + e.getMessage(), e);
            ie.setStackTrace(EMPTY_STACK_TRACE);
            throw ie;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
        return result;
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
747,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",28,29,"<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>","<android.content.ContentResolver: void releasePersistableUriPermission(Uri,int)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        ActivityManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    try {
        UriGrantsManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
","/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is calling UriGrantsManager.getService() instead of ActivityManager.getService() for the releasePersistableUriPermission method, so the code change type is 5.","Although the underlying service that the method relies on has changed, this does not affect the method's contract regarding either return value or exception handling. The method signature is unchanged and it still does not have a return statement that could alter the behavior or throw a new exception. Thus, no Compatibility Issue is detected."
749,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",28,29,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mWinFrame, mContentInsets, mStableInsets, mOutsets, mDisplayCutout, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mDisplayCutout, mMergedConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
                mDisplayCutout.set(mDisplayCutout.get().inset(-padding.left, -padding.top, -padding.right, -padding.bottom));
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(mDisplayCutout.get());
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mDispatchedDisplayCutout = mDisplayCutout.get();
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, null, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false, mDispatchedDisplayCutout);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            if (!fixedSize) {
                mLayout.width = myWidth;
                mLayout.height = myHeight;
            } else {
                // Force the wallpaper to cover the screen in both dimensions
                // only internal implementations like ImageWallpaper
                DisplayInfo displayInfo = new DisplayInfo();
                mDisplay.getDisplayInfo(displayInfo);
                final float layoutScale = Math.max((float) displayInfo.logicalHeight / (float) myHeight, (float) displayInfo.logicalWidth / (float) myWidth);
                mLayout.height = (int) (myHeight * layoutScale);
                mLayout.width = (int) (myWidth * layoutScale);
                mWindowFlags |= WindowManager.LayoutParams.FLAG_SCALED;
            }
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mWinFrame, mContentInsets, mStableInsets, mOutsets, mDisplayCutout, mInputChannel, mInsetsState) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
                mLayout.surfaceInsets.left += mOutsets.left;
                mLayout.surfaceInsets.top += mOutsets.top;
                mLayout.surfaceInsets.right += mOutsets.right;
                mLayout.surfaceInsets.bottom += mOutsets.bottom;
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mDisplayCutout, mMergedConfiguration, mSurfaceControl, mInsetsState);
            if (mSurfaceControl.isValid()) {
                mSurfaceHolder.mSurface.copyFrom(mSurfaceControl);
                mSurfaceControl.release();
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right + mOutsets.left + mOutsets.right;
                h += padding.top + padding.bottom + mOutsets.top + mOutsets.bottom;
                mOverscanInsets.left += padding.left;
                mOverscanInsets.top += padding.top;
                mOverscanInsets.right += padding.right;
                mOverscanInsets.bottom += padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
                mDisplayCutout.set(mDisplayCutout.get().inset(-padding.left, -padding.top, -padding.right, -padding.bottom));
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedOverscanInsets.equals(mOverscanInsets);
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedOutsets.equals(mOutsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(mDisplayCutout.get());
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedOverscanInsets.set(mOverscanInsets);
                    mDispatchedOverscanInsets.left += mOutsets.left;
                    mDispatchedOverscanInsets.top += mOutsets.top;
                    mDispatchedOverscanInsets.right += mOutsets.right;
                    mDispatchedOverscanInsets.bottom += mOutsets.bottom;
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedOutsets.set(mOutsets);
                    mDispatchedDisplayCutout = mDisplayCutout.get();
                    mFinalSystemInsets.set(mDispatchedOverscanInsets);
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false, mDispatchedDisplayCutout);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
750,<android.app.admin.DevicePolicyManager: int getPasswordMaximumLength(int)>,28,29,<android.app.admin.DevicePolicyManager: int getPasswordMaximumLength(int)>,<android.app.admin.DevicePolicyManager: int getPasswordMaximumLength(int)>,0,"{
    // Kind-of arbitrary.
    return 16;
}","{
    PackageManager pm = mContext.getPackageManager();
    if (!pm.hasSystemFeature(PackageManager.FEATURE_SECURE_LOCK_SCREEN)) {
        return 0;
    }
    // Kind-of arbitrary.
    return 16;
}",1,"/**
 * Return the maximum password length that the device supports for a
 * particular password quality.
 * @param quality The quality being interrogated.
 * @return Returns the maximum length that the user can enter.
 */
","/**
 * Return the maximum password length that the device supports for a
 * particular password quality.
 * <p>On devices not supporting {@link PackageManager#FEATURE_SECURE_LOCK_SCREEN} feature, the
 * password is always empty and this method always returns 0.
 * @param quality The quality being interrogated.
 * @return Returns the maximum length that the user can enter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late version added a new control dependency (the 'if' statement with condition pm.hasSystemFeature(PackageManager.FEATURE_SECURE_LOCK_SCREEN)) and a dependent API changed (the mContext.getPackageManager() and pm.hasSystemFeature() are newly introduced), so the code change type is 1,4,5.","The new control dependency introduces a scenario where 0 can now be returned instead of the hardcoded 16 in the early version, potentially leading to a different return value. The introduction of a new return statement (return 0) under certain conditions is evidence of a Compatibility Issue caused by potential different return values or types, which is type 1."
751,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,28,29,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
752,<android.widget.AutoCompleteTextView: void doAfterTextChanged()>,28,29,<android.widget.AutoCompleteTextView: void doAfterTextChanged()>,<android.widget.AutoCompleteTextView: void doAfterTextChanged()>,0,"{
    if (mBlockCompletion)
        return;
    // called performCompletion() and we shouldn't do any more processing.
    if (DEBUG)
        Log.v(TAG, ""after text changed: openBefore="" + mOpenBefore + "" open="" + isPopupShowing());
    if (mOpenBefore && !isPopupShowing()) {
        return;
    }
    // was typed in the text view
    if (enoughToFilter()) {
        if (mFilter != null) {
            mPopupCanBeUpdated = true;
            performFiltering(getText(), mLastKeyCode);
        }
    } else {
        // are deleted from the text view
        if (!mPopup.isDropDownAlwaysVisible()) {
            dismissDropDown();
        }
        if (mFilter != null) {
            mFilter.filter(null);
        }
    }
}","{
    mAutoCompleteTextWatcher.afterTextChanged(null);
}",1,,"/**
 * This function is deprecated. Please use {@link #refreshAutoCompleteResults} instead.
 * Note: Remove {@link #mAutoCompleteTextWatcher} after removing this function.
 */
",-1,,[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire body of the method has been replaced with a call to mAutoCompleteTextWatcher.afterTextChanged(null), and there's an annotation change indicating some restriction in the use of the method for newer target SDKs beyond P. The code change types are 1, for the change in the return behavior, 4, since we see entirely different statements, and 5, because it is dependent on the behavior change in mAutoCompleteTextWatcher.afterTextChanged().","The change to the implementation completely changes the behavior of the method, as the original logic has been removed and replaced with a single method call. Therefore, it could lead to different return values or effects depending on how mAutoCompleteTextWatcher.afterTextChanged() is implemented internally, introducing a potential compatibility issue of type 1."
753,<android.app.Activity: boolean moveTaskToBack(boolean)>,28,29,<android.app.Activity: boolean moveTaskToBack(boolean)>,<android.app.Activity: boolean moveTaskToBack(boolean)>,0,"{
    try {
        return ActivityManager.getService().moveActivityTaskToBack(mToken, nonRoot);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}","{
    try {
        return ActivityTaskManager.getService().moveActivityTaskToBack(mToken, nonRoot);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}",1,"/**
 * Move the task containing this activity to the back of the activity
 * stack.  The activity's order within the task is unchanged.
 *
 * @param nonRoot If false then this only works if the activity is the root
 * of a task; if true it will work for any activity in
 * a task.
 *
 * @return If the task was moved (or it was already at the
 * back) true is returned, else false.
 */
","/**
 * Move the task containing this activity to the back of the activity
 * stack.  The activity's order within the task is unchanged.
 *
 * @param nonRoot If false then this only works if the activity is the root
 * of a task; if true it will work for any activity in
 * a task.
 *
 * @return If the task was moved (or it was already at the
 * back) true is returned, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method being called within the try block has changed from ActivityManager.getService().moveActivityTaskToBack to ActivityTaskManager.getService().moveActivityTaskToBack, so the change type is 5 (Dependent API changed).","There is no compatibility issue detected because the signature of the called method remains the same and the overall behavior of moveTaskToBack(boolean) seems to be unaffected by this particular change. The change appears to be an internal refactoring, possibly due to architectural changes in the Android framework, which should not affect existing clients of the moveTaskToBack method assuming the new ActivityTaskManager provides the same functionality as the previous ActivityManager in this context."
754,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,28,29,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
        case MSG_INSETS_CHANGED:
            return ""MSG_INSETS_CHANGED"";
        case MSG_INSETS_CONTROL_CHANGED:
            return ""MSG_INSETS_CONTROL_CHANGED"";
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the implementation includes additional case statements (MSG_INSETS_CHANGED, MSG_INSETS_CONTROL_CHANGED, and MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED) within the switch block, which constitutes adding new return statements. Additionally, these are other statements which weren't present in the early version. This means the code change types are 1 and 4.","The late version introduces new return values for cases that did not exist in the early version. Therefore, calls to getMessageName with these new message types will now return a specific string rather than invoking the superclass's getMessageName method, as would have happened in the early version. As a result, the API in the late version may potentially return different values for these new cases, corresponding to a CI type of 1."
756,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,28,29,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getDevicesMatchingConnectionStates(states);
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    } finally {
        mServiceLock.readLock().unlock();
    }
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getDevicesMatchingConnectionStates(states);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The variable name ""mService"" has been replaced with a call to the method ""getService()"", and there is no longer a read lock used around the service calls. This indicates a change in how the BluetoothA2dp service instance is retrieved and a change in concurrency control, which is classified as code change type 4 (Other statement changed). In addition, the way the BluetoothA2dp service is accessed (dependent API) has changed, which is classified as code change type 5.","Despite the changes in the internal implementation details, the behavior of the getDevicesMatchingConnectionStates method itself should not be affected. Clients calling this method can expect the same output for the same input, as there is no change in the return values or the exceptions that the method can throw. Therefore, there is no compatibility issue (CI type 0)."
757,<android.view.ViewGroup: boolean dispatchTooltipHoverEvent(MotionEvent)>,28,29,<android.view.ViewGroup: boolean dispatchTooltipHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTooltipHoverEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    switch(action) {
        case MotionEvent.ACTION_HOVER_ENTER:
            break;
        case MotionEvent.ACTION_HOVER_MOVE:
            View newTarget = null;
            // Check what the child under the pointer says about the tooltip.
            final int childrenCount = mChildrenCount;
            if (childrenCount != 0) {
                final float x = event.getX();
                final float y = event.getY();
                final ArrayList<View> preorderedList = buildOrderedChildList();
                final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                final View[] children = mChildren;
                for (int i = childrenCount - 1; i >= 0; i--) {
                    final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                    final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                    if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                        continue;
                    }
                    if (dispatchTooltipHoverEvent(event, child)) {
                        newTarget = child;
                        break;
                    }
                }
                if (preorderedList != null)
                    preorderedList.clear();
            }
            if (mTooltipHoverTarget != newTarget) {
                if (mTooltipHoverTarget != null) {
                    event.setAction(MotionEvent.ACTION_HOVER_EXIT);
                    mTooltipHoverTarget.dispatchTooltipHoverEvent(event);
                    event.setAction(action);
                }
                mTooltipHoverTarget = newTarget;
            }
            if (mTooltipHoverTarget != null) {
                if (mTooltipHoveredSelf) {
                    mTooltipHoveredSelf = false;
                    event.setAction(MotionEvent.ACTION_HOVER_EXIT);
                    super.dispatchTooltipHoverEvent(event);
                    event.setAction(action);
                }
                return true;
            }
            mTooltipHoveredSelf = super.dispatchTooltipHoverEvent(event);
            return mTooltipHoveredSelf;
        case MotionEvent.ACTION_HOVER_EXIT:
            if (mTooltipHoverTarget != null) {
                mTooltipHoverTarget.dispatchTooltipHoverEvent(event);
                mTooltipHoverTarget = null;
            } else if (mTooltipHoveredSelf) {
                super.dispatchTooltipHoverEvent(event);
                mTooltipHoveredSelf = false;
            }
            break;
    }
    return false;
}","{
    final int action = event.getAction();
    switch(action) {
        case MotionEvent.ACTION_HOVER_ENTER:
            break;
        case MotionEvent.ACTION_HOVER_MOVE:
            View newTarget = null;
            // Check what the child under the pointer says about the tooltip.
            final int childrenCount = mChildrenCount;
            if (childrenCount != 0) {
                final float x = event.getX();
                final float y = event.getY();
                final ArrayList<View> preorderedList = buildOrderedChildList();
                final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                final View[] children = mChildren;
                for (int i = childrenCount - 1; i >= 0; i--) {
                    final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                    final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                    if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                        continue;
                    }
                    if (dispatchTooltipHoverEvent(event, child)) {
                        newTarget = child;
                        break;
                    }
                }
                if (preorderedList != null)
                    preorderedList.clear();
            }
            if (mTooltipHoverTarget != newTarget) {
                if (mTooltipHoverTarget != null) {
                    event.setAction(MotionEvent.ACTION_HOVER_EXIT);
                    mTooltipHoverTarget.dispatchTooltipHoverEvent(event);
                    event.setAction(action);
                }
                mTooltipHoverTarget = newTarget;
            }
            if (mTooltipHoverTarget != null) {
                if (mTooltipHoveredSelf) {
                    mTooltipHoveredSelf = false;
                    event.setAction(MotionEvent.ACTION_HOVER_EXIT);
                    super.dispatchTooltipHoverEvent(event);
                    event.setAction(action);
                }
                return true;
            }
            mTooltipHoveredSelf = super.dispatchTooltipHoverEvent(event);
            return mTooltipHoveredSelf;
        case MotionEvent.ACTION_HOVER_EXIT:
            if (mTooltipHoverTarget != null) {
                mTooltipHoverTarget.dispatchTooltipHoverEvent(event);
                mTooltipHoverTarget = null;
            } else if (mTooltipHoveredSelf) {
                super.dispatchTooltipHoverEvent(event);
                mTooltipHoveredSelf = false;
            }
            break;
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method `canViewReceivePointerEvents(child)` in the early version has been replaced with `child.canReceivePointerEvents()` in the late version. This change indicates a change in the dependent API; however, it's likely that the logic remains the same, just that the method is probably moved to be an instance method of View rather than a static method or external utility function. Therefore, the change type is 5.","While the dependent API has changed, if the semantics of `canViewReceivePointerEvents(child)` and `child.canReceivePointerEvents()` are the same, there would be no Compatibility Issue arising since the behavior of the API would not differ from the user's perspective. Hence, the predicated Compatibility Issue is 0."
758,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityWindowInfo getWindow()>,28,29,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityWindowInfo getWindow()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityWindowInfo getWindow()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, mWindowId);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.getWindow(mConnectionId, mWindowId);
}",1,"/**
 * Gets the window to which this node belongs.
 *
 * @return The window.
 *
 * @see android.accessibilityservice.AccessibilityService#getWindows()
 */
","/**
 * Gets the window to which this node belongs.
 *
 * @return The window.
 *
 * @see android.accessibilityservice.AccessibilityService#getWindows()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The control dependency has changed since the method signature for canPerformRequestOverConnection has been updated with different parameters. Additionally, the dependent API enforceSealed has been updated, so the change is a combination of types 3 and 5.","There is no compatibility issue in this specific case because the changes do not modify the behavior in a way that would return different values or throw different exceptions. The method getWindow is still returning the result of client.getWindow with the same parameters as before, and the condition checked is still determining whether or not the operation can continue, which if failed will return null as in the previous version."
759,<android.view.View: void draw(Canvas)>,28,29,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
        if (debugDraw()) {
            debugDrawFocus(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        if (drawTop) {
            canvas.saveUnclippedLayer(left, top, right, top + length);
        }
        if (drawBottom) {
            canvas.saveUnclippedLayer(left, bottom - length, right, bottom);
        }
        if (drawLeft) {
            canvas.saveUnclippedLayer(left, top, left + length, bottom);
        }
        if (drawRight) {
            canvas.saveUnclippedLayer(right - length, top, right, bottom);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    drawAutofilledHighlight(canvas);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
    if (debugDraw()) {
        debugDrawFocus(canvas);
    }
}","{
    final int privateFlags = mPrivateFlags;
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    drawBackground(canvas);
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);
        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);
        if (debugDraw()) {
            debugDrawFocus(canvas);
        }
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int topSaveCount = -1;
    int bottomSaveCount = -1;
    int leftSaveCount = -1;
    int rightSaveCount = -1;
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        if (drawTop) {
            topSaveCount = canvas.saveUnclippedLayer(left, top, right, top + length);
        }
        if (drawBottom) {
            bottomSaveCount = canvas.saveUnclippedLayer(left, bottom - length, right, bottom);
        }
        if (drawLeft) {
            leftSaveCount = canvas.saveUnclippedLayer(left, top, left + length, bottom);
        }
        if (drawRight) {
            rightSaveCount = canvas.saveUnclippedLayer(right - length, top, right, bottom);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    // must be restored in the reverse order that they were saved
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(rightSaveCount, p);
        } else {
            canvas.drawRect(right - length, top, right, bottom, p);
        }
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(leftSaveCount, p);
        } else {
            canvas.drawRect(left, top, left + length, bottom, p);
        }
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(bottomSaveCount, p);
        } else {
            canvas.drawRect(left, bottom - length, right, bottom, p);
        }
    }
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        if (solidColor == 0) {
            canvas.restoreUnclippedLayer(topSaveCount, p);
        } else {
            canvas.drawRect(left, top, right, top + length, p);
        }
    }
    canvas.restoreToCount(saveCount);
    drawAutofilledHighlight(canvas);
    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
    if (debugDraw()) {
        debugDrawFocus(canvas);
    }
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,[@CallSuper],[@CallSuper],-1,-1,-1,-1,-1,-1,,,,
760,<android.util.LongSparseArray: E valueAt(int)>,28,29,<android.util.LongSparseArray: E valueAt(int)>,<android.util.LongSparseArray: E valueAt(int)>,0,"{
    if (mGarbage) {
        gc();
    }
    return (E) mValues[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mGarbage) {
        gc();
    }
    return (E) mValues[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"2,3",2,"There is a new if condition that checks the index and may throw an ArrayIndexOutOfBoundsException, also a new control dependency is introduced before the return. Thus, the change types are 2 and 3.","The introduction of a new control statement that checks the index and potentially throws an ArrayIndexOutOfBoundsException creates a scenario where a different exception could be thrown in the late version, leading to a CI type of 2."
761,"<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,Bitmap,String,String)>",28,29,"<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,Bitmap,String,String)>","<android.provider.MediaStore.Images.Media: String insertImage(ContentResolver,Bitmap,String,String)>",0,"{
    ContentValues values = new ContentValues();
    values.put(Images.Media.TITLE, title);
    values.put(Images.Media.DESCRIPTION, description);
    values.put(Images.Media.MIME_TYPE, ""image/jpeg"");
    Uri url = null;
    String stringUrl = null;
    try {
        url = cr.insert(EXTERNAL_CONTENT_URI, values);
        if (source != null) {
            OutputStream imageOut = cr.openOutputStream(url);
            try {
                source.compress(Bitmap.CompressFormat.JPEG, 50, imageOut);
            } finally {
                imageOut.close();
            }
            long id = ContentUris.parseId(url);
            // Wait until MINI_KIND thumbnail is generated.
            Bitmap miniThumb = Images.Thumbnails.getThumbnail(cr, id, Images.Thumbnails.MINI_KIND, null);
            // This is for backward compatibility.
            Bitmap microThumb = StoreThumbnail(cr, miniThumb, id, 50F, 50F, Images.Thumbnails.MICRO_KIND);
        } else {
            Log.e(TAG, ""Failed to create thumbnail, removing original"");
            cr.delete(url, null, null);
            url = null;
        }
    } catch (Exception e) {
        Log.e(TAG, ""Failed to insert image"", e);
        if (url != null) {
            cr.delete(url, null, null);
            url = null;
        }
    }
    if (url != null) {
        stringUrl = url.toString();
    }
    return stringUrl;
}","{
    if (TextUtils.isEmpty(title))
        title = ""Image"";
    final PendingParams params = new PendingParams(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, title, ""image/jpeg"");
    final Context context = AppGlobals.getInitialApplication();
    final Uri pendingUri = createPending(context, params);
    try (PendingSession session = openPending(context, pendingUri)) {
        try (OutputStream out = session.openOutputStream()) {
            source.compress(Bitmap.CompressFormat.JPEG, 90, out);
        }
        return session.publish().toString();
    } catch (Exception e) {
        Log.w(TAG, ""Failed to insert image"", e);
        context.getContentResolver().delete(pendingUri, null, null);
        return null;
    }
}",1,"/**
 * Insert an image and create a thumbnail for it.
 *
 * @param cr The content resolver to use
 * @param source The stream to use for the image
 * @param title The name of the image
 * @param description The description of the image
 * @return The URL to the newly created image, or <code>null</code> if the image failed to be stored
 * for any reason.
 */
","/**
 * Insert an image and create a thumbnail for it.
 *
 * @param cr The content resolver to use
 * @param source The stream to use for the image
 * @param title The name of the image
 * @param description The description of the image
 * @return The URL to the newly created image, or <code>null</code> if the image failed to be stored
 * for any reason.
 * @deprecated inserting of images should be performed using
 * {@link MediaColumns#IS_PENDING}, which offers richer
 * control over lifecycle.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementation has undergone substantial changes, including the introduction of new variables like `PendingParams`, `PendingSession`, and the use of `createPending` and `openPending`. The entire structure of the try-catch block and the way in which an image is inserted and compressed have also been modified. Hence, the change types include 1, 3, 4, and 5 due to the change in the control structure, other statements, and the use of dependent APIs that have changed or were introduced.","There are several reasons a CI could arise from these changes. New exception handling logic could lead to different behavior in error conditions, and the change in how the image is compressed and saved could result in different return values. Most notably, the late version can return `null` in an exception case, where the early version might have returned some string URL or `null` based on different conditions. Thus, the CI type is 1 due to potential different return values."
763,"<android.content.Intent: Intent parseUri(String,int)>",28,29,"<android.content.Intent: Intent parseUri(String,int)>","<android.content.Intent: Intent parseUri(String,int)>",0,"{
    int i = 0;
    try {
        final boolean androidApp = uri.startsWith(""android-app:"");
        // Validate intent scheme if requested.
        if ((flags & (URI_INTENT_SCHEME | URI_ANDROID_APP_SCHEME)) != 0) {
            if (!uri.startsWith(""intent:"") && !androidApp) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        i = uri.lastIndexOf(""#"");
        // simple case
        if (i == -1) {
            if (!androidApp) {
                return new Intent(ACTION_VIEW, Uri.parse(uri));
            }
        // old format Intent URI
        } else if (!uri.startsWith(""#Intent;"", i)) {
            if (!androidApp) {
                return getIntentOld(uri, flags);
            } else {
                i = -1;
            }
        }
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        Intent baseIntent = intent;
        boolean explicitAction = false;
        boolean inSelector = false;
        // fetch data part, if present
        String scheme = null;
        String data;
        if (i >= 0) {
            data = uri.substring(0, i);
            // length of ""#Intent;""
            i += 8;
        } else {
            data = uri;
        }
        // loop over contents of Intent, all name=value;
        while (i >= 0 && !uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            if (eq < 0)
                eq = i - 1;
            int semi = uri.indexOf(';', i);
            String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : """";
            // action
            if (uri.startsWith(""action="", i)) {
                intent.setAction(value);
                if (!inSelector) {
                    explicitAction = true;
                }
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
                if ((flags & URI_ALLOW_UNSAFE) == 0) {
                    intent.mFlags &= ~IMMUTABLE_FLAGS;
                }
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                if (inSelector) {
                    intent.mData = Uri.parse(value + "":"");
                } else {
                    scheme = value;
                }
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // selector
            if (semi == (i + 3) && uri.startsWith(""SEL"", i)) {
                intent = new Intent();
                inSelector = true;
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (inSelector) {
            // The Intent had a selector; fix it up.
            if (baseIntent.mPackage == null) {
                baseIntent.setSelector(intent);
            }
            intent = baseIntent;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            } else if (data.startsWith(""android-app:"")) {
                if (data.charAt(12) == '/' && data.charAt(13) == '/') {
                    // Correctly formed android-app, first part is package name.
                    int end = data.indexOf('/', 14);
                    if (end < 0) {
                        // All we have is a package name.
                        intent.mPackage = data.substring(14);
                        if (!explicitAction) {
                            intent.setAction(ACTION_MAIN);
                        }
                        data = """";
                    } else {
                        // Target the Intent at the given package name always.
                        String authority = null;
                        intent.mPackage = data.substring(14, end);
                        int newEnd;
                        if ((end + 1) < data.length()) {
                            if ((newEnd = data.indexOf('/', end + 1)) >= 0) {
                                // Found a scheme, remember it.
                                scheme = data.substring(end + 1, newEnd);
                                end = newEnd;
                                if (end < data.length() && (newEnd = data.indexOf('/', end + 1)) >= 0) {
                                    // Found a authority, remember it.
                                    authority = data.substring(end + 1, newEnd);
                                    end = newEnd;
                                }
                            } else {
                                // All we have is a scheme.
                                scheme = data.substring(end + 1);
                            }
                        }
                        if (scheme == null) {
                            // If there was no scheme, then this just targets the package.
                            if (!explicitAction) {
                                intent.setAction(ACTION_MAIN);
                            }
                            data = """";
                        } else if (authority == null) {
                            data = scheme + "":"";
                        } else {
                            data = scheme + ""://"" + authority + data.substring(end);
                        }
                    }
                } else {
                    data = """";
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}","{
    int i = 0;
    try {
        final boolean androidApp = uri.startsWith(""android-app:"");
        // Validate intent scheme if requested.
        if ((flags & (URI_INTENT_SCHEME | URI_ANDROID_APP_SCHEME)) != 0) {
            if (!uri.startsWith(""intent:"") && !androidApp) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        i = uri.lastIndexOf(""#"");
        // simple case
        if (i == -1) {
            if (!androidApp) {
                return new Intent(ACTION_VIEW, Uri.parse(uri));
            }
        // old format Intent URI
        } else if (!uri.startsWith(""#Intent;"", i)) {
            if (!androidApp) {
                return getIntentOld(uri, flags);
            } else {
                i = -1;
            }
        }
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        Intent baseIntent = intent;
        boolean explicitAction = false;
        boolean inSelector = false;
        // fetch data part, if present
        String scheme = null;
        String data;
        if (i >= 0) {
            data = uri.substring(0, i);
            // length of ""#Intent;""
            i += 8;
        } else {
            data = uri;
        }
        // loop over contents of Intent, all name=value;
        while (i >= 0 && !uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            if (eq < 0)
                eq = i - 1;
            int semi = uri.indexOf(';', i);
            String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : """";
            // action
            if (uri.startsWith(""action="", i)) {
                intent.setAction(value);
                if (!inSelector) {
                    explicitAction = true;
                }
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // identifier
            if (uri.startsWith(""identifier="", i)) {
                intent.mIdentifier = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
                if ((flags & URI_ALLOW_UNSAFE) == 0) {
                    intent.mFlags &= ~IMMUTABLE_FLAGS;
                }
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                if (inSelector) {
                    intent.mData = Uri.parse(value + "":"");
                } else {
                    scheme = value;
                }
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // selector
            if (semi == (i + 3) && uri.startsWith(""SEL"", i)) {
                intent = new Intent();
                inSelector = true;
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (inSelector) {
            // The Intent had a selector; fix it up.
            if (baseIntent.mPackage == null) {
                baseIntent.setSelector(intent);
            }
            intent = baseIntent;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            } else if (data.startsWith(""android-app:"")) {
                if (data.charAt(12) == '/' && data.charAt(13) == '/') {
                    // Correctly formed android-app, first part is package name.
                    int end = data.indexOf('/', 14);
                    if (end < 0) {
                        // All we have is a package name.
                        intent.mPackage = data.substring(14);
                        if (!explicitAction) {
                            intent.setAction(ACTION_MAIN);
                        }
                        data = """";
                    } else {
                        // Target the Intent at the given package name always.
                        String authority = null;
                        intent.mPackage = data.substring(14, end);
                        int newEnd;
                        if ((end + 1) < data.length()) {
                            if ((newEnd = data.indexOf('/', end + 1)) >= 0) {
                                // Found a scheme, remember it.
                                scheme = data.substring(end + 1, newEnd);
                                end = newEnd;
                                if (end < data.length() && (newEnd = data.indexOf('/', end + 1)) >= 0) {
                                    // Found a authority, remember it.
                                    authority = data.substring(end + 1, newEnd);
                                    end = newEnd;
                                }
                            } else {
                                // All we have is a scheme.
                                scheme = data.substring(end + 1);
                            }
                        }
                        if (scheme == null) {
                            // If there was no scheme, then this just targets the package.
                            if (!explicitAction) {
                                intent.setAction(ACTION_MAIN);
                            }
                            data = """";
                        } else if (authority == null) {
                            data = scheme + "":"";
                        } else {
                            data = scheme + ""://"" + authority + data.substring(end);
                        }
                    }
                } else {
                    data = """";
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}",1,"/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
","/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
764,<android.provider.MediaStore.Audio.Albums: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Audio.Albums: Uri getContentUri(String)>,<android.provider.MediaStore.Audio.Albums: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/albums"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""audio"").appendPath(""albums"").build();
}",1,"/**
 * Get the content:// style URI for the albums table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio albums table on the given volume
 */
","/**
 * Get the content:// style URI for the albums table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio albums table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method for constructing the Uri return value has changed, changing from `Uri.parse` to `AUTHORITY_URI.buildUpon()` with chained `appendPath` methods and `build()`. There is a significant change in how the URI is constructed, which includes a different API being called (from `Uri.parse` to `AUTHORITY_URI.buildUpon()` and associated methods). Therefore, the change types are 1 and 5.","The change in how the Uri is constructed could potentially return a different Uri value, even though the intention may be to represent the same resource. Since the Uri being returned is constructed differently, it could lead to different behaviour, such as differences in encoding or canonicalization. Given this change, a Compatibility Issue could arise due to potentially different return values. Hence, the CI type is 1."
766,<android.util.LongSparseArray: long keyAt(int)>,28,29,<android.util.LongSparseArray: long keyAt(int)>,<android.util.LongSparseArray: long keyAt(int)>,0,"{
    if (mGarbage) {
        gc();
    }
    return mKeys[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mGarbage) {
        gc();
    }
    return mKeys[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * LongSparseArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new exception handling statement is introduced along with a new condition which is to check whether the parameter index exceeds the upper boundary. Additionally, exception throwing is dependent on a configuration flag. This change falls into the exception handling statement changed (2) and control dependency changed (3).","Since a new exception could be thrown when the index parameter is out of bounds, which wasn't the case in the early version, this constitutes a compatibility issue caused by potential different exception handlings and thus the type is 2."
767,<android.text.PrecomputedText.Params: boolean equals(Object)>,28,29,<android.text.PrecomputedText.Params: boolean equals(Object)>,<android.text.PrecomputedText.Params: boolean equals(Object)>,0,"{
    if (o == this) {
        return true;
    }
    if (o == null || !(o instanceof Params)) {
        return false;
    }
    Params param = (Params) o;
    return isSameTextMetricsInternal(param.mPaint, param.mTextDir, param.mBreakStrategy, param.mHyphenationFrequency);
}","{
    if (o == this) {
        return true;
    }
    if (o == null || !(o instanceof Params)) {
        return false;
    }
    Params param = (Params) o;
    return checkResultUsable(param.mPaint, param.mTextDir, param.mBreakStrategy, param.mHyphenationFrequency) == Params.USABLE;
}",1,"/**
 * Check if the same text layout.
 *
 * @return true if this and the given param result in the same text layout
 */
","/**
 * Check if the same text layout.
 *
 * @return true if this and the given param result in the same text layout
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called in the return statement changed from isSameTextMetricsInternal to checkResultUsable, and a comparison to Params.USABLE is added, so the code change type is 1,5.","The method substitution in the return statement likely leads to this method returning a different result. Since the return value now depends on a comparison, the behavior when comparing Params objects may differ from before. Thus, the potential CI is due to different return values, meaning the CI type is 1."
768,<android.app.ActivityManager: void setVrThread(int)>,28,29,<android.app.ActivityManager: void setVrThread(int)>,<android.app.ActivityManager: void setVrThread(int)>,0,"{
    try {
        getService().setVrThread(tid);
    } catch (RemoteException e) {
    // pass
    }
}","{
    try {
        getTaskService().setVrThread(tid);
    } catch (RemoteException e) {
    // pass
    }
}",1,"/**
 * Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one
 * thread can be a VR thread in a process at a time, and that thread may be subject to
 * restrictions on the amount of time it can run.
 *
 * If persistent VR mode is set, whatever thread has been granted aggressive scheduling via this
 * method will return to normal operation, and calling this method will do nothing while
 * persistent VR mode is enabled.
 *
 * To reset the VR thread for an application, a tid of 0 can be passed.
 *
 * @see android.os.Process#myTid()
 * @param tid tid of the VR thread
 */
","/**
 * Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one
 * thread can be a VR thread in a process at a time, and that thread may be subject to
 * restrictions on the amount of time it can run.
 *
 * If persistent VR mode is set, whatever thread has been granted aggressive scheduling via this
 * method will return to normal operation, and calling this method will do nothing while
 * persistent VR mode is enabled.
 *
 * To reset the VR thread for an application, a tid of 0 can be passed.
 *
 * @see android.os.Process#myTid()
 * @param tid tid of the VR thread
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method has changed from getService().setVrThread(tid) to getTaskService().setVrThread(tid), which indicates a change in the dependent API being called. Hence, the code change is categorized as 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in the method used to set the VR thread, the try-catch block structure has remained the same, and since there's no change in the exceptions being caught or any return value (as the method return type is void), no compatibility issue arises from this change. Therefore, the CI type is 0 (No Compatibility Issue)."
770,<android.hardware.camera2.params.StreamConfigurationMap: int checkArgumentFormatInternal(int)>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: int checkArgumentFormatInternal(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int checkArgumentFormatInternal(int)>,0,"{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
        case HAL_PIXEL_FORMAT_Y16:
            return format;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException(""ImageFormat.JPEG is an unknown internal format"");
        default:
            return checkArgumentFormat(format);
    }
}","{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
        case HAL_PIXEL_FORMAT_Y16:
            return format;
        case ImageFormat.JPEG:
        case ImageFormat.HEIC:
            throw new IllegalArgumentException(""An unknown internal format: "" + format);
        default:
            return checkArgumentFormat(format);
    }
}",1,"/**
 * Ensures that the format is either user-defined or implementation defined.
 *
 * <p>If a format has a different internal representation than the public representation,
 * passing in the public representation here will fail.</p>
 *
 * <p>For example if trying to use {@link ImageFormat#JPEG}:
 * it has a different public representation than the internal representation
 * {@code HAL_PIXEL_FORMAT_BLOB}, this check will fail.</p>
 *
 * <p>Any invalid/undefined formats will raise an exception.</p>
 *
 * @param format image format
 * @return the format
 *
 * @throws IllegalArgumentException if the format was invalid
 */
","/**
 * Ensures that the format is either user-defined or implementation defined.
 *
 * <p>If a format has a different internal representation than the public representation,
 * passing in the public representation here will fail.</p>
 *
 * <p>For example if trying to use {@link ImageFormat#JPEG}:
 * it has a different public representation than the internal representation
 * {@code HAL_PIXEL_FORMAT_BLOB}, this check will fail.</p>
 *
 * <p>Any invalid/undefined formats will raise an exception.</p>
 *
 * @param format image format
 * @return the format
 *
 * @throws IllegalArgumentException if the format was invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","The change can be seen in the 'switch' case control structure and in an 'throw' exception statement inside it. A 'case' for ImageFormat.HEIC has been added to the switch statement. Additionally, the message in the IllegalArgumentException for ImageFormat.JPEG has changed to include the format variable, and thus the code change types are 1,3.","The addition of a new case (ImageFormat.HEIC) leads to a new condition where an IllegalArgumentException is thrown where it wasn't before. This indicates a potential Compatibility Issue due to the introduction of new exception behavior, which is CI type 2. The change in the exception message also indicates a potential CI due to a different value (the message itself), which is CI type 1."
771,<android.inputmethodservice.InputMethodService: boolean isInputViewShown()>,28,29,<android.inputmethodservice.InputMethodService: boolean isInputViewShown()>,<android.inputmethodservice.InputMethodService: boolean isInputViewShown()>,0,"{
    return mIsInputViewShown && mWindowVisible;
}","{
    return mCanPreRender ? mWindowVisible : mIsInputViewShown && mDecorViewVisible;
}",1,"/**
 * Return whether the soft input view is <em>currently</em> shown to the
 * user.  This is the state that was last determined and
 * applied by {@link #updateInputViewShown()}.
 */
","/**
 * Return whether the soft input view is <em>currently</em> shown to the
 * user.  This is the state that was last determined and
 * applied by {@link #updateInputViewShown()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is a change in the return statement where a new condition has been introduced using the ternary operator. Additionally, there is a change in the variables being checked to return a true/false value, making the code change type include 1 (Return statement changed), 3 (Control dependency changed due to new condition check), and 4 (Other statement changed due to the introduction of a new condition).","Because the return statement now depends on an additional condition (mCanPreRender) and the logic that determines the return value has been altered significantly, the late version of the API could potentially return a different boolean value when compared to the early version. Therefore, the API has a potential Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
772,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,28,29,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,0,"{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final float x = event.getX();
        final float y = event.getY();
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                if (preorderedList != null)
                    preorderedList.clear();
                return true;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}","{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final float x = event.getX();
        final float y = event.getY();
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                if (preorderedList != null)
                    preorderedList.clear();
                return true;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `canViewReceivePointerEvents` has been changed to `child.canReceivePointerEvents()`, which indicates an Other statement changed (4) and a Dependent API changed (5).","Although a dependent method was called on the `View` class, this is an instance method call on the View object that does not affect the return value of the `dispatchGenericPointerEvent` method. Additionally, it does not introduce any new control flow or exception handling. Therefore, there is No Compatibility Issue (0)."
775,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,28,29,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null);
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    return context;
}","{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null, null);
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    return context;
}",1,,,-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"The constructor call for 'ContextImpl' has been changed with the addition of a new parameter (a null at the end). It indicates that the constructor's signature has changed, but since we are only passing null, it doesn't inherently change the behavior if the constructor is designed to handle the null as default or optional. This is thus classified as other statement changed.","There is no Compatibility Issue since the addition of a null parameter to the constructor does not change the existing behavior or flow of the method, assuming that the constructor is properly handling the additional null parameter. If the constructor's implementation is correctly designed to manage this, it will not lead to a change in the returned 'ContextImpl' object."
776,"<android.bluetooth.BluetoothHidDevice: boolean replyReport(BluetoothDevice,byte,byte,byte[])>",28,29,"<android.bluetooth.BluetoothHidDevice: boolean replyReport(BluetoothDevice,byte,byte,byte[])>","<android.bluetooth.BluetoothHidDevice: boolean replyReport(BluetoothDevice,byte,byte,byte[])>",0,"{
    boolean result = false;
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            result = service.replyReport(device, type, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.replyReport(device, type, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Sends report to remote host as reply for GET_REPORT request from {@link
 * Callback#onGetReport(BluetoothDevice, byte, byte, int)}.
 *
 * @param type Report Type, as in request.
 * @param id Report Id, as in request.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends report to remote host as reply for GET_REPORT request from {@link
 * Callback#onGetReport(BluetoothDevice, byte, byte, int)}.
 *
 * @param type Report Type, as in request.
 * @param id Report Id, as in request.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to get the service has changed from a direct field access to a method call (getService()), but the service behavior is not altered. This is categorized as a change in a dependent API (5).","There is no Compatibility Issue as the proxy method getService() is assumed to return the same service object that was previously directly accessed via the field. Hence, the behavior of the API should remain consistent."
777,<android.view.WindowInsets: int getStableInsetLeft()>,28,29,<android.view.WindowInsets: int getStableInsetLeft()>,<android.view.WindowInsets: int getStableInsetLeft()>,0,"{
    return mStableInsets.left;
}","{
    return getStableInsets().left;
}",1,"/**
 * Returns the left stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The left stable inset
 */
","/**
 * Returns the left stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The left stable inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method changed from directly accessing mStableInsets.left to calling getStableInsets().left, which indicates a dependent API change, thus the code change type is 5.","There is no direct indication that the return type or value will change; it depends on whether getStableInsets() returns the same value that was previously held in mStableInsets. However, without evidence of a change in behavior of getStableInsets(), we can't assume there's a Compatibility Issue, thus the CI type is 0."
778,"<android.bluetooth.BluetoothHidDevice: boolean registerApp(BluetoothHidDeviceAppSdpSettings,BluetoothHidDeviceAppQosSettings,BluetoothHidDeviceAppQosSettings,Executor,Callback)>",28,29,"<android.bluetooth.BluetoothHidDevice: boolean registerApp(BluetoothHidDeviceAppSdpSettings,BluetoothHidDeviceAppQosSettings,BluetoothHidDeviceAppQosSettings,Executor,Callback)>","<android.bluetooth.BluetoothHidDevice: boolean registerApp(BluetoothHidDeviceAppSdpSettings,BluetoothHidDeviceAppQosSettings,BluetoothHidDeviceAppQosSettings,Executor,Callback)>",0,"{
    boolean result = false;
    if (sdp == null) {
        throw new IllegalArgumentException(""sdp parameter cannot be null"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""executor parameter cannot be null"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""callback parameter cannot be null"");
    }
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            CallbackWrapper cbw = new CallbackWrapper(executor, callback);
            result = service.registerApp(sdp, inQos, outQos, cbw);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    if (sdp == null) {
        throw new IllegalArgumentException(""sdp parameter cannot be null"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""executor parameter cannot be null"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""callback parameter cannot be null"");
    }
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            CallbackWrapper cbw = new CallbackWrapper(executor, callback);
            result = service.registerApp(sdp, inQos, outQos, cbw);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Registers application to be used for HID device. Connections to HID Device are only possible
 * when application is registered. Only one application can be registered at one time. When an
 * application is registered, the HID Host service will be disabled until it is unregistered.
 * When no longer used, application should be unregistered using {@link #unregisterApp()}. The
 * app will be automatically unregistered if it is not foreground. The registration status
 * should be tracked by the application by handling callback from Callback#onAppStatusChanged.
 * The app registration status is not related to the return value of this method.
 *
 * @param sdp {@link BluetoothHidDeviceAppSdpSettings} object of HID Device SDP record. The HID
 * Device SDP record is required.
 * @param inQos {@link BluetoothHidDeviceAppQosSettings} object of Incoming QoS Settings. The
 * Incoming QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param outQos {@link BluetoothHidDeviceAppQosSettings} object of Outgoing QoS Settings. The
 * Outgoing QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param executor {@link Executor} object on which callback will be executed. The Executor
 * object is required.
 * @param callback {@link Callback} object to which callback messages will be sent. The Callback
 * object is required.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Registers application to be used for HID device. Connections to HID Device are only possible
 * when application is registered. Only one application can be registered at one time. When an
 * application is registered, the HID Host service will be disabled until it is unregistered.
 * When no longer used, application should be unregistered using {@link #unregisterApp()}. The
 * app will be automatically unregistered if it is not foreground. The registration status
 * should be tracked by the application by handling callback from Callback#onAppStatusChanged.
 * The app registration status is not related to the return value of this method.
 *
 * @param sdp {@link BluetoothHidDeviceAppSdpSettings} object of HID Device SDP record. The HID
 * Device SDP record is required.
 * @param inQos {@link BluetoothHidDeviceAppQosSettings} object of Incoming QoS Settings. The
 * Incoming QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param outQos {@link BluetoothHidDeviceAppQosSettings} object of Outgoing QoS Settings. The
 * Outgoing QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param executor {@link Executor} object on which callback will be executed. The Executor
 * object is required.
 * @param callback {@link Callback} object to which callback messages will be sent. The Callback
 * object is required.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API getService() has been used instead of directly accessing mService, so the code change type is 5.","No Compatibility Issue should arise since the replacement of mService with getService() does not inherently change the behavior visible to the API consumers, assuming getService() has the same functional contract as direct mService use; hence, type 0."
779,<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,28,29,<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,0,"{
    synchronized (mH) {
        try {
            mService.showInputMethodAndSubtypeEnablerFromClient(mClient, imiId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    try {
        mService.showInputMethodAndSubtypeEnablerFromClient(mClient, imiId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Show the settings for enabling subtypes of the specified input method.
 * @param imiId An input method, whose subtypes settings will be shown. If imiId is null,
 * subtypes of all input methods will be shown.
 */
","/**
 * Show the settings for enabling subtypes of the specified input method.
 * @param imiId An input method, whose subtypes settings will be shown. If imiId is null,
 * subtypes of all input methods will be shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change includes the removal of the synchronized block (synchronized (mH)), which is a change in control dependency (3), and could be considered an ""other statement changed"" (4).","However, the removal of the synchronized block does not affect the external behavior of the method in terms of its functionality. The method's return type is void and it communicates with a remote service, so the actual operations that might fail due to concurrency are handled within the remote service. As such, no Compatibility Issue relating to differences in return values, return types, or exceptions thrown by the method itself should arise from this change. Thus, the CI type is 0."
781,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,28,29,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(Uri)>,0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireUnstableProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, false);
    }
    return null;
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    IContentProvider provider = acquireUnstableProvider(uri);
    if (provider != null) {
        return new ContentProviderClient(this, provider, uri.getAuthority(), false);
    }
    return null;
}",1,"/**
 * Like {@link #acquireContentProviderClient(Uri)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
","/**
 * Like {@link #acquireContentProviderClient(Uri)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The constructor for ContentProviderClient has changed, it includes an additional parameter 'uri.getAuthority()'. This is a dependent API that has been changed, which constitutes a change type 5.","Although there is a change in the dependent API, it doesn't lead to a compatibility issue since the method still returns a ContentProviderClient object or null as before. The additional parameter is just extra information passed to the constructor and does not alter the type or value of the method's return. Thus, there's no CI regarding return types/values or exception handling."
782,<android.app.Activity: void finishAffinity()>,28,29,<android.app.Activity: void finishAffinity()>,<android.app.Activity: void finishAffinity()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can not be called from an embedded activity"");
    }
    if (mResultCode != RESULT_CANCELED || mResultData != null) {
        throw new IllegalStateException(""Can not be called to deliver a result"");
    }
    try {
        if (ActivityManager.getService().finishActivityAffinity(mToken)) {
            mFinished = true;
        }
    } catch (RemoteException e) {
    // Empty
    }
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can not be called from an embedded activity"");
    }
    if (mResultCode != RESULT_CANCELED || mResultData != null) {
        throw new IllegalStateException(""Can not be called to deliver a result"");
    }
    try {
        if (ActivityTaskManager.getService().finishActivityAffinity(mToken)) {
            mFinished = true;
        }
    } catch (RemoteException e) {
    // Empty
    }
}",1,"/**
 * Finish this activity as well as all activities immediately below it
 * in the current task that have the same affinity.  This is typically
 * used when an application can be launched on to another task (such as
 * from an ACTION_VIEW of a content type it understands) and the user
 * has used the up navigation to switch out of the current task and in
 * to its own task.  In this case, if the user has navigated down into
 * any other activities of the second application, all of those should
 * be removed from the original task as part of the task switch.
 *
 * <p>Note that this finish does <em>not</em> allow you to deliver results
 * to the previous activity, and an exception will be thrown if you are trying
 * to do so.</p>
 */
","/**
 * Finish this activity as well as all activities immediately below it
 * in the current task that have the same affinity.  This is typically
 * used when an application can be launched on to another task (such as
 * from an ACTION_VIEW of a content type it understands) and the user
 * has used the up navigation to switch out of the current task and in
 * to its own task.  In this case, if the user has navigated down into
 * any other activities of the second application, all of those should
 * be removed from the original task as part of the task switch.
 *
 * <p>Note that this finish does <em>not</em> allow you to deliver results
 * to the previous activity, and an exception will be thrown if you are trying
 * to do so.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call has changed from ActivityManager.getService().finishActivityAffinity(mToken) to ActivityTaskManager.getService().finishActivityAffinity(mToken), which indicates a change in a dependent API; thus, the code change type is 5.","There is no indication of altered behavior in the API itself, given that the method signature for finishActivityAffinity is unchanged and assuming the new getService method is expected to behave identically to the originally used getService. Hence, no Compatibility Issue is expected from this change."
783,<android.view.WindowInsets: int getStableInsetBottom()>,28,29,<android.view.WindowInsets: int getStableInsetBottom()>,<android.view.WindowInsets: int getStableInsetBottom()>,0,"{
    return mStableInsets.bottom;
}","{
    return getStableInsets().bottom;
}",1,"/**
 * Returns the bottom stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The bottom stable inset
 */
","/**
 * Returns the bottom stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The bottom stable inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation now calls a method getStableInsets() to get the stable insets before accessing the 'bottom' field, so the code change type is 5.","There's no compatibility issue here, since the returned value is still the same field 'bottom' of the stable insets, and the actual behavior as perceived by the end-user should remain the same assuming getStableInsets() returns a valid object with the correct fields -- the structure containing the insets. Therefore, there'll be no difference in the values returned by the early version and the late version of the API."
785,"<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>",28,29,"<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>","<android.content.ContentProviderOperation: ContentProviderResult apply(ContentProvider,ContentProviderResult[],int)>",0,"{
    ContentValues values = resolveValueBackReferences(backRefs, numBackRefs);
    String[] selectionArgs = resolveSelectionArgsBackReferences(backRefs, numBackRefs);
    if (mType == TYPE_INSERT) {
        Uri newUri = provider.insert(mUri, values);
        if (newUri == null) {
            throw new OperationApplicationException(""insert failed"");
        }
        return new ContentProviderResult(newUri);
    }
    int numRows;
    if (mType == TYPE_DELETE) {
        numRows = provider.delete(mUri, mSelection, selectionArgs);
    } else if (mType == TYPE_UPDATE) {
        numRows = provider.update(mUri, values, mSelection, selectionArgs);
    } else if (mType == TYPE_ASSERT) {
        // Assert that all rows match expected values
        String[] projection = null;
        if (values != null) {
            // Build projection map from expected values
            final ArrayList<String> projectionList = new ArrayList<String>();
            for (Map.Entry<String, Object> entry : values.valueSet()) {
                projectionList.add(entry.getKey());
            }
            projection = projectionList.toArray(new String[projectionList.size()]);
        }
        final Cursor cursor = provider.query(mUri, projection, mSelection, selectionArgs, null);
        try {
            numRows = cursor.getCount();
            if (projection != null) {
                while (cursor.moveToNext()) {
                    for (int i = 0; i < projection.length; i++) {
                        final String cursorValue = cursor.getString(i);
                        final String expectedValue = values.getAsString(projection[i]);
                        if (!TextUtils.equals(cursorValue, expectedValue)) {
                            // Throw exception when expected values don't match
                            Log.e(TAG, this.toString());
                            throw new OperationApplicationException(""Found value "" + cursorValue + "" when expected "" + expectedValue + "" for column "" + projection[i]);
                        }
                    }
                }
            }
        } finally {
            cursor.close();
        }
    } else {
        Log.e(TAG, this.toString());
        throw new IllegalStateException(""bad type, "" + mType);
    }
    if (mExpectedCount != null && mExpectedCount != numRows) {
        Log.e(TAG, this.toString());
        throw new OperationApplicationException(""wrong number of rows: "" + numRows);
    }
    return new ContentProviderResult(numRows);
}","{
    if (mFailureAllowed) {
        try {
            return applyInternal(provider, backRefs, numBackRefs);
        } catch (Exception e) {
            return new ContentProviderResult(e.getMessage());
        }
    } else {
        return applyInternal(provider, backRefs, numBackRefs);
    }
}",1,"/**
 * Applies this operation using the given provider. The backRefs array is used to resolve any
 * back references that were requested using
 * {@link Builder#withValueBackReferences(ContentValues)} and
 * {@link Builder#withSelectionBackReference}.
 * @param provider the {@link ContentProvider} on which this batch is applied
 * @param backRefs a {@link ContentProviderResult} array that will be consulted
 * to resolve any requested back references.
 * @param numBackRefs the number of valid results on the backRefs array.
 * @return a {@link ContentProviderResult} that contains either the {@link Uri} of the inserted
 * row if this was an insert otherwise the number of rows affected.
 * @throws OperationApplicationException thrown if either the insert fails or
 * if the number of rows affected didn't match the expected count
 */
","/**
 * Applies this operation using the given provider. The backRefs array is used to resolve any
 * back references that were requested using
 * {@link Builder#withValueBackReferences(ContentValues)} and
 * {@link Builder#withSelectionBackReference}.
 * @param provider the {@link ContentProvider} on which this batch is applied
 * @param backRefs a {@link ContentProviderResult} array that will be consulted
 * to resolve any requested back references.
 * @param numBackRefs the number of valid results on the backRefs array.
 * @return a {@link ContentProviderResult} that contains either the {@link Uri} of the inserted
 * row if this was an insert otherwise the number of rows affected.
 * @throws OperationApplicationException thrown if either the insert fails or
 * if the number of rows affected didn't match the expected count
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"There is a significant control dependency change as new control structures are introduced (if-else) related to `mFailureAllowed`. Also, there is a new return statement that returns a different type of ContentProviderResult depending on the nature of the exception caught. Furthermore, the early version's implementation logic has been extracted into an `applyInternal` method based on the late version signature, which leads to a dependent API change. Therefore, the change types involved are 1, 3, and 5.","The late implementation introduces a conditional return based on `mFailureAllowed`. If an exception is caught when `mFailureAllowed` is true, a new `ContentProviderResult` is constructed with the exception message, which is a different behavior from the early version that throws the exception. Moreover, the early version would throw an exception if certain conditions were not met (insert failed, wrong number of rows, bad type, etc.), but in the late version, this can be converted into a `ContentProviderResult` containing an error message. These changes potentially result in different return types or values, thus the CI type is 1."
786,<android.hardware.camera2.impl.CameraDeviceImpl.RequestLastFrameNumbersHolder: long getLastFrameNumber()>,28,29,<android.hardware.camera2.impl.CameraDeviceImpl.RequestLastFrameNumbersHolder: long getLastFrameNumber()>,<android.hardware.camera2.impl.CameraDeviceImpl.RequestLastFrameNumbersHolder: long getLastFrameNumber()>,0,"{
    return Math.max(mLastRegularFrameNumber, mLastReprocessFrameNumber);
}","{
    return Math.max(mLastZslStillFrameNumber, Math.max(mLastRegularFrameNumber, mLastReprocessFrameNumber));
}",1,"/**
 * Return the last frame number overall.
 */
","/**
 * Return the last frame number overall.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement's logic has changed by incorporating an additional max operation with the variable mLastZslStillFrameNumber. This introduces a new variable into the calculation, which is a dependent API change, so the code change type is 1,5.","The change in logic for the return value introduces a new potential maximum value that the method could return (mLastZslStillFrameNumber). Since this could lead to the method returning a different long value from what it would in the early version, the CI type is 1."
787,"<android.app.admin.DevicePolicyManager: void setAlwaysOnVpnPackage(ComponentName,String,boolean)>",28,29,"<android.app.admin.DevicePolicyManager: void setAlwaysOnVpnPackage(ComponentName,String,boolean)>","<android.app.admin.DevicePolicyManager: void setAlwaysOnVpnPackage(ComponentName,String,boolean)>",0,"{
    throwIfParentInstance(""setAlwaysOnVpnPackage"");
    if (mService != null) {
        try {
            if (!mService.setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled)) {
                throw new NameNotFoundException(vpnPackage);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled, Collections.emptySet());
}",1,"/**
 * Called by a device or profile owner to configure an always-on VPN connection through a
 * specific application for the current user. This connection is automatically granted and
 * persisted after a reboot.
 * <p>
 * To support the always-on feature, an app must
 * <ul>
 * <li>declare a {@link android.net.VpnService} in its manifest, guarded by
 * {@link android.Manifest.permission#BIND_VPN_SERVICE};</li>
 * <li>target {@link android.os.Build.VERSION_CODES#N API 24} or above; and</li>
 * <li><i>not</i> explicitly opt out of the feature through
 * {@link android.net.VpnService#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON}.</li>
 * </ul>
 * The call will fail if called with the package name of an unsupported VPN app.
 *
 * @param vpnPackage The package name for an installed VPN app on the device, or {@code null} to
 * remove an existing always-on VPN configuration.
 * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
 * {@code false} otherwise. This carries the risk that any failure of the VPN provider
 * could break networking for all apps. This has no effect when clearing.
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 * @throws NameNotFoundException if {@code vpnPackage} is not installed.
 * @throws UnsupportedOperationException if {@code vpnPackage} exists but does not support being
 * set as always-on, or if always-on VPN is not available.
 */
","/**
 * Called by a device or profile owner to configure an always-on VPN connection through a
 * specific application for the current user. This connection is automatically granted and
 * persisted after a reboot.
 * <p> To support the always-on feature, an app must
 * <ul>
 * <li>declare a {@link android.net.VpnService} in its manifest, guarded by
 * {@link android.Manifest.permission#BIND_VPN_SERVICE};</li>
 * <li>target {@link android.os.Build.VERSION_CODES#N API 24} or above; and</li>
 * <li><i>not</i> explicitly opt out of the feature through
 * {@link android.net.VpnService#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON}.</li>
 * </ul>
 * The call will fail if called with the package name of an unsupported VPN app.
 * <p> Enabling lockdown via {@code lockdownEnabled} argument carries the risk that any failure
 * of the VPN provider could break networking for all apps. This method clears any lockdown
 * whitelist set by {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)}.
 *
 * @param vpnPackage The package name for an installed VPN app on the device, or {@code null} to
 * remove an existing always-on VPN configuration.
 * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
 * {@code false} otherwise. This has no effect when clearing.
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 * @throws NameNotFoundException if {@code vpnPackage} is not installed.
 * @throws UnsupportedOperationException if {@code vpnPackage} exists but does not support being
 * set as always-on, or if always-on VPN is not available.
 * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method changed to call another method with additional parameters. The original logic is offloaded to this new method signature (setAlwaysOnVpnPackage with four arguments), indicating a dependent API change, so the code change type is 5.","There is no direct evidence that a compatibility issue could arise from this change because the internal implementation details are not provided. The change does not directly affect the method's signature or its contract. Thus, no Compatibility Issue is detected, and CI type is 0."
788,<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig createWithExplicitEntityList(Collection<String>)>,28,29,<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig createWithExplicitEntityList(Collection<String>)>,<android.view.textclassifier.TextClassifier.EntityConfig: EntityConfig createWithExplicitEntityList(Collection<String>)>,0,"{
    return new EntityConfig(/* useHints */
    false, /* hints */
    null, /* includedEntityTypes */
    entityTypes, /* excludedEntityTypes */
    null);
}","{
    return new EntityConfig.Builder().setIncludedTypes(entityTypes).includeTypesFromTextClassifier(false).build();
}",1,"/**
 * Creates an EntityConfig with an explicit entity list.
 *
 * @param entityTypes Complete set of entities, e.g. {@link #TYPE_URL} to find.
 */
","/**
 * Creates an EntityConfig with an explicit entity list.
 *
 * @param entityTypes Complete set of entities, e.g. {@link #TYPE_URL} to find.
 *
 * @deprecated Use {@link Builder} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The method of creating EntityConfig has changed from using a constructor to using a Builder pattern. Additionally, the 'includeTypesFromTextClassifier' method with 'false' as an argument is used in the late version, which was not present in the early version. Therefore, the code change types are 4 (Other statement changed) and 5 (Dependent API changed).","Although the creation of EntityConfig object has changed in its implementation, this change does not directly affect the return type or value of the 'createWithExplicitEntityList' API method itself; the returned object should still meet its contract requirements. The late implementation is also not introducing any new exceptions or changing exception handling. Therefore, the change is unlikely to lead to a CI, hence the prediction is 0 (No Compatibility Issue)."
789,"<android.net.http.HttpResponseCache: CacheResponse get(URI,String,Map<String, List<String>>)>",28,29,"<android.net.http.HttpResponseCache: CacheResponse get(URI,String,Map<String, List<String>>)>","<android.net.http.HttpResponseCache: CacheResponse get(URI,String,Map<String, List<String>>)>",0,"{
    return delegate.get(uri, requestMethod, requestHeaders);
}","{
    return mDelegate.get(uri, requestMethod, requestHeaders);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The code change here is just the renaming of the variable from `delegate` to `mDelegate`. So the code change type is 4.,"The renaming of a variable does not affect the behavior of the method as long as it refers to the same object and has no other side effects. Therefore, there is no compatibility issue in this case, hence the CI type is 0."
790,<android.util.SparseBooleanArray: int keyAt(int)>,28,29,<android.util.SparseBooleanArray: int keyAt(int)>,<android.util.SparseBooleanArray: int keyAt(int)>,0,"{
    return mKeys[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return mKeys[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseBooleanArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseBooleanArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An if condition and a throw statement for an exception have been added in the late implementation, which constitutes a control dependency change (3) and an exception handling statement change (2).","The new code introduces a potential new exception that could be thrown if the index is out of the current bounds. This is a change in the exception handling behaviour of the method, leading to a Compatibility Issue of type 2 due to a potential different exception being thrown."
792,<android.widget.TextView: boolean canPaste()>,28,29,<android.widget.TextView: boolean canPaste()>,<android.widget.TextView: boolean canPaste()>,0,"{
    return (mText instanceof Editable && mEditor != null && mEditor.mKeyListener != null && getSelectionStart() >= 0 && getSelectionEnd() >= 0 && ((ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE)).hasPrimaryClip());
}","{
    return (mText instanceof Editable && mEditor != null && mEditor.mKeyListener != null && getSelectionStart() >= 0 && getSelectionEnd() >= 0 && getClipboardManagerForUser().hasPrimaryClip());
}",1,,,-1,,[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"4,5",0,"The code has changed to call a different method for retrieving the clipboard manager (from calling getContext().getSystemService(Context.CLIPBOARD_SERVICE) to calling getClipboardManagerForUser()). There are no control flow or exception handling changes; thus, the code change includes type 4 for the method call change and type 5 for dependent API change.","Although there is a change in how the clipboard manager is obtained, this change does not impact the return type or the conditions under which the method returns. It is still returning a boolean result based on the same conditions, so there is no compatibility issue in terms of different return values or types; hence the CI type is 0."
793,"<android.view.PointerIcon: PointerIcon getSystemIcon(Context,int)>",28,29,"<android.view.PointerIcon: PointerIcon getSystemIcon(Context,int)>","<android.view.PointerIcon: PointerIcon getSystemIcon(Context,int)>",0,"{
    if (context == null) {
        throw new IllegalArgumentException(""context must not be null"");
    }
    if (type == TYPE_NULL) {
        return gNullIcon;
    }
    PointerIcon icon = gSystemIcons.get(type);
    if (icon != null) {
        return icon;
    }
    int typeIndex = getSystemIconTypeIndex(type);
    if (typeIndex == 0) {
        typeIndex = getSystemIconTypeIndex(TYPE_DEFAULT);
    }
    int defStyle = sUseLargeIcons ? com.android.internal.R.style.LargePointer : com.android.internal.R.style.Pointer;
    TypedArray a = context.obtainStyledAttributes(null, com.android.internal.R.styleable.Pointer, 0, defStyle);
    int resourceId = a.getResourceId(typeIndex, -1);
    a.recycle();
    if (resourceId == -1) {
        Log.w(TAG, ""Missing theme resources for pointer icon type "" + type);
        return type == TYPE_DEFAULT ? gNullIcon : getSystemIcon(context, TYPE_DEFAULT);
    }
    icon = new PointerIcon(type);
    if ((resourceId & 0xff000000) == 0x01000000) {
        icon.mSystemIconResourceId = resourceId;
    } else {
        icon.loadResource(context, context.getResources(), resourceId);
    }
    gSystemIcons.append(type, icon);
    return icon;
}","{
    if (context == null) {
        throw new IllegalArgumentException(""context must not be null"");
    }
    if (type == TYPE_NULL) {
        return gNullIcon;
    }
    if (sDisplayListener == null) {
        registerDisplayListener(context);
    }
    final int displayId = context.getDisplayId();
    SparseArray<PointerIcon> systemIcons = gSystemIconsByDisplay.get(displayId);
    if (systemIcons == null) {
        systemIcons = new SparseArray<>();
        gSystemIconsByDisplay.put(displayId, systemIcons);
    }
    PointerIcon icon = systemIcons.get(type);
    // Reload if not in the same display.
    if (icon != null) {
        return icon;
    }
    int typeIndex = getSystemIconTypeIndex(type);
    if (typeIndex == 0) {
        typeIndex = getSystemIconTypeIndex(TYPE_DEFAULT);
    }
    int defStyle = sUseLargeIcons ? com.android.internal.R.style.LargePointer : com.android.internal.R.style.Pointer;
    TypedArray a = context.obtainStyledAttributes(null, com.android.internal.R.styleable.Pointer, 0, defStyle);
    int resourceId = a.getResourceId(typeIndex, -1);
    a.recycle();
    if (resourceId == -1) {
        Log.w(TAG, ""Missing theme resources for pointer icon type "" + type);
        return type == TYPE_DEFAULT ? gNullIcon : getSystemIcon(context, TYPE_DEFAULT);
    }
    icon = new PointerIcon(type);
    if ((resourceId & 0xff000000) == 0x01000000) {
        icon.mSystemIconResourceId = resourceId;
    } else {
        icon.loadResource(context, context.getResources(), resourceId);
    }
    systemIcons.append(type, icon);
    return icon;
}",1,"/**
 * Gets a system pointer icon for the given type.
 * If typeis not recognized, returns the default pointer icon.
 *
 * @param context The context.
 * @param type The pointer icon type.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 */
","/**
 * Gets a system pointer icon for the given type.
 * If typeis not recognized, returns the default pointer icon.
 *
 * @param context The context.
 * @param type The pointer icon type.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,There are several changes in the late version compared to the early one:,- There is an additional variable `systemIcons` representing a `SparseArray` and related logic to create and manage this collection.
794,<android.view.textclassifier.TextClassification.Builder: Builder addAction(RemoteAction)>,28,29,<android.view.textclassifier.TextClassification.Builder: Builder addAction(RemoteAction)>,<android.view.textclassifier.TextClassification.Builder: Builder addAction(RemoteAction)>,0,"{
    Preconditions.checkArgument(action != null);
    mActions.add(action);
    return this;
}","{
    return addAction(action, null);
}",1,"/**
 * Adds an action that may be performed on the classified text. Actions should be added in
 * order of likelihood that the user will use them, with the most likely action being added
 * first.
 */
","/**
 * Adds an action that may be performed on the classified text. Actions should be added in
 * order of likelihood that the user will use them, with the most likely action being added
 * first.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from direct code to a delegation to another method (`addAction(action, null)`), but the input and output remain the same. This indicates that another addAction method with different parameters is being used in the late version. So the change types are 4 and 5.","There is no Compatibility Issue detected because the method signature has not changed, the NonNull annotation remains the same, and the method's return type has not been altered. The action being passed is not fundamentally changed because it is still non-null, so the behavior of adding the action should remain consistent. Therefore, the late version should be behaviorally compatible with apps targeting the early version."
795,<android.net.http.HttpResponseCache: int getHitCount()>,28,29,<android.net.http.HttpResponseCache: int getHitCount()>,<android.net.http.HttpResponseCache: int getHitCount()>,0,"{
    return delegate.getHitCount();
}","{
    return mDelegate.getHitCount();
}",1,"/**
 * Returns the number of HTTP requests whose response was provided by the
 * cache. This may include conditional {@code GET} requests that were
 * validated over the network.
 */
","/**
 * Returns the number of HTTP requests whose response was provided by the
 * cache. This may include conditional {@code GET} requests that were
 * validated over the network.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change from delegate to mDelegate is a change of the internal reference variable name. There is no change in behavior, thus the code change type is 4.","Since the change is only in the variable name and not in the behavior of the method, there is no Compatibility Issue; the API still returns the same value from an internal hit count counter."
796,<android.app.Activity: void setTaskDescription(TaskDescription)>,28,29,<android.app.Activity: void setTaskDescription(TaskDescription)>,<android.app.Activity: void setTaskDescription(TaskDescription)>,0,"{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(icon);
        }
    }
    try {
        ActivityManager.getService().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}","{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(icon);
        }
    }
    try {
        ActivityTaskManager.getService().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
","/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is in the invocation of a method from a possibly different class (ActivityManager.getService() to ActivityTaskManager.getService()), thus indicating that a dependent API might have changed, so the change type is 5.","Since the change does not alter the behavior of the method 'setTaskDescription' itself, but just the class from which a method is called, and given no other details indicate a change in the expected behavior (no added exceptions, no change in control flow, and no alteration in the return type or value), there's no compatibility issue with respect to the API's functionality from the perspective of the caller. Hence, the CI type is 0."
798,<android.view.WindowInsets: int getSystemWindowInsetLeft()>,28,29,<android.view.WindowInsets: int getSystemWindowInsetLeft()>,<android.view.WindowInsets: int getSystemWindowInsetLeft()>,0,"{
    return mSystemWindowInsets.left;
}","{
    return getSystemWindowInsets().left;
}",1,"/**
 * Returns the left system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The left system window inset
 */
","/**
 * Returns the left system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The left system window inset
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of getting the left inset has changed from directly accessing 'mSystemWindowInsets.left' to calling 'getSystemWindowInsets().left'. This means that a dependent API, 'getSystemWindowInsets()', is now being used, hence the code change type is 5.","There is no Compatibility Issue detected as the change does not alter the behavior of the method in a way that it would return a different value or throw a different exception under the same conditions. The method is still returning an int value representing the left system window inset, simply through a different mechanism of accessing it."
799,<android.content.ContentValues: boolean containsKey(String)>,28,29,<android.content.ContentValues: boolean containsKey(String)>,<android.content.ContentValues: boolean containsKey(String)>,0,"{
    return mValues.containsKey(key);
}","{
    return mMap.containsKey(key);
}",1,"/**
 * Returns true if this object has the named value.
 *
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise
 */
","/**
 * Returns true if this object has the named value.
 *
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the variable name containing the map from `mValues` to `mMap`, and there is no additional context suggesting a change in the underlying map's behavior, so the code change type is 4 and 5.","There's no Compatibility Issue arising from this change if the underlying map referenced by the two different variable names (`mValues` and `mMap`) represents the same data structure. This change alone doesnt indicate any difference in behavior or semantics; thus, the compatibility issue type is 0."
800,<android.util.ArrayMap: K keyAt(int)>,28,29,<android.util.ArrayMap: K keyAt(int)>,<android.util.ArrayMap: K keyAt(int)>,0,"{
    return (K) mArray[index << 1];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return (K) mArray[index << 1];
}",1,"/**
 * Return the key at the given index in the array.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the key stored at the given index.
 */
","/**
 * Return the key at the given index in the array.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the key stored at the given index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An exception handling statement and control dependency have been added to throw an ArrayIndexOutOfBoundsException, so the code change type is 2,3.","The late version introduces new exception handling that could throw an ArrayIndexOutOfBoundsException when the condition is met, which alters the method's behavior compared to the early version. Thus, the CI type is 2."
802,<android.view.View: Mode getBackgroundTintMode()>,28,29,<android.view.View: Mode getBackgroundTintMode()>,<android.view.View: Mode getBackgroundTintMode()>,0,"{
    return mBackgroundTint != null ? mBackgroundTint.mTintMode : null;
}","{
    PorterDuff.Mode porterDuffMode;
    if (mBackgroundTint != null && mBackgroundTint.mBlendMode != null) {
        porterDuffMode = BlendMode.blendModeToPorterDuffMode(mBackgroundTint.mBlendMode);
    } else {
        porterDuffMode = null;
    }
    return porterDuffMode;
}",1,"/**
 * Return the blending mode used to apply the tint to the background
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the background
 * drawable
 * @attr ref android.R.styleable#View_backgroundTintMode
 * @see #setBackgroundTintMode(PorterDuff.Mode)
 */
","/**
 * Return the blending mode used to apply the tint to the background
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the background
 * drawable
 * @attr ref android.R.styleable#View_backgroundTintMode
 * @see #setBackgroundTintBlendMode(BlendMode)
 */
",-1,[@Nullable],"[@Nullable, @InspectableProperty]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been modified with an added conditional check and a conversion method (BlendMode.blendModeToPorterDuffMode), and also, the structure of the method body changed with the introduction of a new local variable `porterDuffMode`. So, the change type is 1,4,5 due to the altered return statement, new local variable logic, and dependency on the new conversion method from `BlendMode` to `PorterDuff.Mode`.","The method now includes logic that potentially returns a different value derived from the new conversion logic (BlendMode.blendModeToPorterDuffMode), which could result in different behavior from the previous version where it simply returned the 'mTintMode' or 'null'. This change can cause the API to return different values depending on whether 'mBlendMode' is not null and how 'blendModeToPorterDuffMode' maps 'mBlendMode' to 'PorterDuff.Mode', so the CI type is 1."
803,<android.app.ContextImpl: Context createContextForSplit(String)>,28,29,<android.app.ContextImpl: Context createContextForSplit(String)>,<android.app.ContextImpl: Context createContextForSplit(String)>,0,"{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader);
    final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
    context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader));
    return context;
}","{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, splitName, mActivityToken, mUser, mFlags, classLoader, null);
    final int displayId = getDisplayId();
    context.setResources(ResourcesManager.getInstance().getResources(mActivityToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader));
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,The code has two changes: ,
804,"<android.provider.DocumentsContract: boolean deleteDocument(ContentResolver,Uri)>",28,29,"<android.provider.DocumentsContract: boolean deleteDocument(ContentResolver,Uri)>","<android.provider.DocumentsContract: boolean deleteDocument(ContentResolver,Uri)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        deleteDocument(client, documentUri);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to delete document"", e);
        rethrowIfNecessary(resolver, e);
        return false;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    try {
        final Bundle in = new Bundle();
        in.putParcelable(DocumentsContract.EXTRA_URI, documentUri);
        content.call(documentUri.getAuthority(), METHOD_DELETE_DOCUMENT, null, in);
        return true;
    } catch (Exception e) {
        Log.w(TAG, ""Failed to delete document"", e);
        rethrowIfNecessary(e);
        return false;
    }
}",1,"/**
 * Delete the given document.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_DELETE}
 * @return if the document was deleted successfully.
 */
","/**
 * Delete the given document.
 *
 * @param documentUri document with {@link Document#FLAG_SUPPORTS_DELETE}
 * @return if the document was deleted successfully.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The implementation of the deleteDocument method in the late version does not use ContentProviderClient; it uses the 'content' call method with a new Bundle object instead. This is a different execution path, meaning the original exception handling, return statements, and other statements are changed, as is the dependent API PaymentManager.deleteDocument. The code change types are 1 (return statement involving true/false values is modified), 2 (exception handling modified especially the 'rethrowIfNecessary' which now does not take resolver as a parameter), 4 (other statement changed due to the removal of Bundle object creation and ContentProviderClient related code), and 5 (the dependent method 'deleteDocument' in PaymentManager is not directly invoked, but rather a call to 'content.call' with METHOD_DELETE_DOCUMENT which means the dependent API changed).",The change in implementation could lead to different behaviors: 
805,<android.accessibilityservice.AccessibilityService.MagnificationController: float getScale()>,28,29,<android.accessibilityservice.AccessibilityService.MagnificationController: float getScale()>,<android.accessibilityservice.AccessibilityService.MagnificationController: float getScale()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationScale();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 1.0f;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationScale(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 1.0f;
}",1,"/**
 * Returns the current magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 1.0f}.
 *
 * @return the current magnification scale
 */
","/**
 * Returns the current magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 1.0f}.
 *
 * @return the current magnification scale
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method connection.getMagnificationScale() has added a new parameter mDisplayId in the late version, which makes it a dependent API change. However, there are no changes to the return statement or exception handling that could lead to different behavior by themselves, so the change type is 4,5.","There is no Compatibility Issue here as there are no changes in behavior within the method itself. The return values remain the same, and the way exceptions are handled has not changed. However, if the behavior of connection.getMagnificationScale(mDisplayId) differs from connection.getMagnificationScale(), only then the users of this method could observe different behavior. As the implementation within the method hasn't changed in a way that could lead to a Compatibility Issue (assuming that the behavior of getMagnificationScale when invoked with and without mDisplayId is compatible), there is no CI caused by this change."
806,<android.bluetooth.BluetoothHealth: boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration)>,28,29,<android.bluetooth.BluetoothHealth: boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration)>,<android.bluetooth.BluetoothHealth: boolean unregisterAppConfiguration(BluetoothHealthAppConfiguration)>,0,"{
    boolean result = false;
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && config != null) {
        try {
            result = service.unregisterAppConfiguration(config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return result;
}","{
    Log.e(TAG, ""unregisterAppConfiguration(): BluetoothHealth is deprecated"");
    return false;
}",1,"/**
 * Unregister an application configuration that has been registered using
 * {@link #registerSinkAppConfiguration}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param config The health app configuration
 * @return Success or failure.
 */
","/**
 * Unregister an application configuration that has been registered using
 * {@link #registerSinkAppConfiguration}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param config The health app configuration
 * @return Success or failure.
 *
 * @deprecated Health Device Profile (HDP) and MCAP protocol are no longer used. New
 * apps should use Bluetooth Low Energy based solutions such as {@link BluetoothGatt},
 * {@link BluetoothAdapter#listenUsingL2capChannel()(int)}, or
 * {@link BluetoothDevice#createL2capChannel(int)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The control dependency, exception handling, and return statement in the early implementation have been removed. In the late implementation, the method simply logs a deprecation message and returns false. This qualifies as both return statement change and other statement change because the entire structure of the method has changed.","The change will result in a Compatibility Issue due to the potential different return values. In earlier versions, the result could be true or false based on conditions, but in the later version, it will always return false. The CI type is 1."
807,<android.text.Layout: float getLineRight(int)>,28,29,<android.text.Layout: float getLineRight(int)>,<android.text.Layout: float getLineRight(int)>,0,"{
    int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    if (align == Alignment.ALIGN_LEFT) {
        return getParagraphLeft(line) + getLineMax(line);
    } else if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return mWidth;
        else
            return getParagraphLeft(line) + getLineMax(line);
    } else if (align == Alignment.ALIGN_RIGHT) {
        return mWidth;
    } else if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return getLineMax(line);
        else
            return mWidth;
    } else {
        /* align == Alignment.ALIGN_CENTER */
        int left = getParagraphLeft(line);
        int right = getParagraphRight(line);
        int max = ((int) getLineMax(line)) & ~1;
        return right - ((right - left) - max) / 2;
    }
}","{
    final int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    // To keep consistency, we convert a null alignment to ALIGN_CENTER.
    if (align == null) {
        align = Alignment.ALIGN_CENTER;
    }
    final Alignment resultAlign;
    switch(align) {
        case ALIGN_NORMAL:
            resultAlign = dir == DIR_RIGHT_TO_LEFT ? Alignment.ALIGN_RIGHT : Alignment.ALIGN_LEFT;
            break;
        case ALIGN_OPPOSITE:
            resultAlign = dir == DIR_RIGHT_TO_LEFT ? Alignment.ALIGN_LEFT : Alignment.ALIGN_RIGHT;
            break;
        case ALIGN_CENTER:
            resultAlign = Alignment.ALIGN_CENTER;
            break;
        case ALIGN_RIGHT:
            resultAlign = Alignment.ALIGN_RIGHT;
            break;
        default:
            /* align == Alignment.ALIGN_LEFT */
            resultAlign = Alignment.ALIGN_LEFT;
    }
    switch(resultAlign) {
        case ALIGN_CENTER:
            final int right = getParagraphRight(line);
            final float max = getLineMax(line);
            // text in this line. If this condition doesn't meet anymore, please change here.
            return (float) Math.ceil(right - (mWidth - max) / 2);
        case ALIGN_RIGHT:
            return mWidth;
        default:
            /* resultAlign == Alignment.ALIGN_LEFT */
            return getLineMax(line);
    }
}",1,"/**
 * Get the rightmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
","/**
 * Get the rightmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control flow and some statements within the method have been heavily refactored: a null check for the `align` variable has been introduced, the if-else structure has been replaced with a switch-case structure, and assignments to the resultAlign variable. These changes fall under categories 3 and 4.","The change in the control flow structure and introduction of a null check for alignment could lead to different return values under certain conditions. For instance, previously an unexpected null 'align' could potentially result in a NullPointerException, whereas in the late version, it will default to center alignment. This could cause the earlier version to crash in cases where the late version would not. Similarly, the logic change in computation of right adjustment for ALIGN_CENTER could result in a different value being returned, so the CI type is 1."
808,<android.app.Activity: void stopLocalVoiceInteraction()>,28,29,<android.app.Activity: void stopLocalVoiceInteraction()>,<android.app.Activity: void stopLocalVoiceInteraction()>,0,"{
    try {
        ActivityManager.getService().stopLocalVoiceInteraction(mToken);
    } catch (RemoteException re) {
    }
}","{
    try {
        ActivityTaskManager.getService().stopLocalVoiceInteraction(mToken);
    } catch (RemoteException re) {
    }
}",1,"/**
 * Request to terminate the current voice interaction that was previously started
 * using {@link #startLocalVoiceInteraction(Bundle)}. When the interaction is
 * terminated, {@link #onLocalVoiceInteractionStopped()} will be called.
 */
","/**
 * Request to terminate the current voice interaction that was previously started
 * using {@link #startLocalVoiceInteraction(Bundle)}. When the interaction is
 * terminated, {@link #onLocalVoiceInteractionStopped()} will be called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used inside the try block changed from ActivityManager.getService().stopLocalVoiceInteraction to ActivityTaskManager.getService().stopLocalVoiceInteraction, so the code change type is 5.","Despite the name of the service has changed, the replacement service still provides the same functionality and the signature of stopLocalVoiceInteraction remains the same. Therefore, there is no compatibility issue because the method's behavior has not changed from the perspective of what is visible to client code calling stopLocalVoiceInteraction, hence CI type is 0."
809,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",28,29,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>","<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",0,"{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.ActivityTaskDescription);
    if (mTaskDescription.getPrimaryColor() == 0) {
        int colorPrimary = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
        if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
            mTaskDescription.setPrimaryColor(colorPrimary);
        }
    }
    int colorBackground = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
    if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
        mTaskDescription.setBackgroundColor(colorBackground);
    }
    final int statusBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_statusBarColor, 0);
    if (statusBarColor != 0) {
        mTaskDescription.setStatusBarColor(statusBarColor);
    }
    final int navigationBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_navigationBarColor, 0);
    if (navigationBarColor != 0) {
        mTaskDescription.setNavigationBarColor(navigationBarColor);
    }
    a.recycle();
    setTaskDescription(mTaskDescription);
}","{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.ActivityTaskDescription);
    if (mTaskDescription.getPrimaryColor() == 0) {
        int colorPrimary = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
        if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
            mTaskDescription.setPrimaryColor(colorPrimary);
        }
    }
    int colorBackground = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
    if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
        mTaskDescription.setBackgroundColor(colorBackground);
    }
    final int statusBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_statusBarColor, 0);
    if (statusBarColor != 0) {
        mTaskDescription.setStatusBarColor(statusBarColor);
    }
    final int navigationBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_navigationBarColor, 0);
    if (navigationBarColor != 0) {
        mTaskDescription.setNavigationBarColor(navigationBarColor);
    }
    final int targetSdk = getApplicationInfo().targetSdkVersion;
    final boolean targetPreQ = targetSdk < Build.VERSION_CODES.Q;
    if (!targetPreQ) {
        mTaskDescription.setEnsureStatusBarContrastWhenTransparent(a.getBoolean(R.styleable.ActivityTaskDescription_enforceStatusBarContrast, false));
        mTaskDescription.setEnsureNavigationBarContrastWhenTransparent(a.getBoolean(R.styleable.ActivityTaskDescription_enforceNavigationBarContrast, true));
    }
    a.recycle();
    setTaskDescription(mTaskDescription);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The late version introduces a new block of code determining the target SDK version and setting contrast properties on the `mTaskDescription` object if the condition is met. This is not in the early version, indicating a change of type 3 for control dependency and 4 for other statement changes.","This addition can potentially result in a different state of the `mTaskDescription` object, which is used to set the task description of the activity. This can particularly affect activities targeting API levels post-Q (version code for Q/10) differently from activities targeting lower API levels. It is a compatibility issue of type 1 due to potential changes in behavior based on the contrast requirements changes for the status bar and navigation bar."
810,<android.bluetooth.le.ScanFilter.Builder: ScanFilter build()>,28,29,<android.bluetooth.le.ScanFilter.Builder: ScanFilter build()>,<android.bluetooth.le.ScanFilter.Builder: ScanFilter build()>,0,"{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask);
}","{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceSolicitationUuid, mServiceSolicitationUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask);
}",1,"/**
 * Build {@link ScanFilter}.
 *
 * @throws IllegalArgumentException If the filter cannot be built.
 */
","/**
 * Build {@link ScanFilter}.
 *
 * @throws IllegalArgumentException If the filter cannot be built.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor call for ScanFilter has different parameters, which indicates that the constructor itself has been changed to accept different or additional parameters. As a result, this corresponds to changes in dependent API, so the code change types are 1 for return statement changed and 5 for dependent API changed.","This change leads to constructing a ScanFilter object with potentially different behavior due to the change in the parameters passed into the constructor. Since the constructor parameters have been modified, this could result in different return values, thus causing a compatibility issue of type 1."
811,<android.nfc.NfcAdapter: boolean invokeBeam(Activity)>,28,29,<android.nfc.NfcAdapter: boolean invokeBeam(Activity)>,<android.nfc.NfcAdapter: boolean invokeBeam(Activity)>,0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity may not be null."");
    }
    enforceResumed(activity);
    try {
        sService.invokeBeam();
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""invokeBeam: NFC process has died."");
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return false;
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity may not be null."");
    }
    enforceResumed(activity);
    try {
        sService.invokeBeam();
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""invokeBeam: NFC process has died."");
        attemptDeadServiceRecovery(e);
        return false;
    }
}",1,"/**
 * Manually invoke Android Beam to share data.
 *
 * <p>The Android Beam animation is normally only shown when two NFC-capable
 * devices come into range.
 * By calling this method, an Activity can invoke the Beam animation directly
 * even if no other NFC device is in range yet. The Beam animation will then
 * prompt the user to tap another NFC-capable device to complete the data
 * transfer.
 *
 * <p>The main advantage of using this method is that it avoids the need for the
 * user to tap the screen to complete the transfer, as this method already
 * establishes the direction of the transfer and the consent of the user to
 * share data. Callers are responsible for making sure that the user has
 * consented to sharing data on NFC tap.
 *
 * <p>Note that to use this method, the passed in Activity must have already
 * set data to share over Beam by using method calls such as
 * {@link #setNdefPushMessageCallback} or
 * {@link #setBeamPushUrisCallback}.
 *
 * @param activity the current foreground Activity that has registered data to share
 * @return whether the Beam animation was successfully invoked
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Manually invoke Android Beam to share data.
 *
 * <p>The Android Beam animation is normally only shown when two NFC-capable
 * devices come into range.
 * By calling this method, an Activity can invoke the Beam animation directly
 * even if no other NFC device is in range yet. The Beam animation will then
 * prompt the user to tap another NFC-capable device to complete the data
 * transfer.
 *
 * <p>The main advantage of using this method is that it avoids the need for the
 * user to tap the screen to complete the transfer, as this method already
 * establishes the direction of the transfer and the consent of the user to
 * share data. Callers are responsible for making sure that the user has
 * consented to sharing data on NFC tap.
 *
 * <p>Note that to use this method, the passed in Activity must have already
 * set data to share over Beam by using method calls such as
 * {@link #setNdefPushMessageCallback} or
 * {@link #setBeamPushUrisCallback}.
 *
 * @param activity the current foreground Activity that has registered data to share
 * @return whether the Beam animation was successfully invoked
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated this feature is deprecated. File sharing can work using other technology like
 * Bluetooth.
 */
",-1,,[@java.lang.Deprecated],-1,-1,-1,-1,-1,-1,"3,4",1,"The late version introduces a new conditional check for `sHasBeamFeature` within the synchronized block, which can potentially affect the execution flow, marking a control dependency change (code change type 3). Additionally, the method has been annotated as Deprecated, which is an indication of other changes (code change type 4).","Due to the introduction of the `if (!sHasBeamFeature)` condition and corresponding early return (`return false;`), there's a scenario where the newer version of the API can return a different value without calling `sService.invokeBeam()` (CI type 1)."
812,<android.util.ArrayMap: V valueAt(int)>,28,29,<android.util.ArrayMap: V valueAt(int)>,<android.util.ArrayMap: V valueAt(int)>,0,"{
    return (V) mArray[(index << 1) + 1];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return (V) mArray[(index << 1) + 1];
}",1,"/**
 * Return the value at the given index in the array.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value stored at the given index.
 */
","/**
 * Return the value at the given index in the array.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value stored at the given index.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The late version introduces a new control flow 'if' to check the index, adds a new exception handling with 'throw new ArrayIndexOutOfBoundsException(index)', and maintains the original return statement. Therefore, the changes are in the categories of control dependency (3), exception handling (2), and others due to the new configuration check (1).","The newly introduced 'if' check can lead to a new ArrayIndexOutOfBoundsException that was not present in the early version. Additionally, this exception is thrown based on the condition involving the configuration option 'UtilConfig.sThrowExceptionForUpperArrayOutOfBounds', which might affect the behavior depending upon how this configuration is set. Also, there is no change in the return type or value when the condition is not met. Hence, there is a Compatibility Issue caused by potential different exception handlings (2) and no change in return values or types (1), as the return statement remains the same."
813,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,28,29,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,0,"{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeHeight;
    that.minResizeHeight = this.minResizeHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label == null ? null : this.label.substring(0);
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    that.providerInfo = this.providerInfo;
    that.widgetFeatures = this.widgetFeatures;
    return that;
}","{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeHeight;
    that.minResizeHeight = this.minResizeHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label;
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    that.providerInfo = this.providerInfo;
    that.widgetFeatures = this.widgetFeatures;
    return that;
}",1,,,-1,"[@Override, @SuppressWarnings(""deprecation"")]","[@Override, @SuppressWarnings(""deprecation"")]",-1,-1,-1,-1,-1,-1,4,0,The method 'clone()' now directly assigns the label from 'this.label' instead of creating a substring copy with 'this.label.substring(0)'. This is classified as a change type 4 (Other statement changed).,"The change should not cause a compatibility issue because 'this.label.substring(0)' simply created a new String identical to 'this.label'. The new implementation avoids creating an unnecessary substring and uses the same label String object, but this does not change the behavior from an API consumer perspective. Strings in Java are immutable, so using the substring or the direct reference doesn't affect the immutability or the content of the String object. Hence, there is no compatibility issue."
815,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,28,29,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,0,"{
    byte[] newPayload = null;
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            // TODO: http://b/22388012
            newPayload = nm.getBackupPayload(UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
            newPayload = null;
        }
    }
    return newPayload;
}","{
    byte[] newPayload = null;
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            newPayload = nm.getBackupPayload(mUserId);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
            newPayload = null;
        }
    }
    return newPayload;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change occurs where the method getBackupPayload is called with a different argument: from a constant (UserHandle.USER_SYSTEM) to a variable (mUserId), which indicates an other statement change.","Although the method call argument within `nm.getBackupPayload` changed from a constant to a variable, this doesn't necessarily cause a Compatibility Issue, since it doesn't inherently imply a difference in behavior if mUserId and UserHandle.USER_SYSTEM have the same value in the context where getBackupPayload is used. There's no additional information indicating that the value of mUserId would lead to a different behavior, so there's no CI detected based on given details."
816,"<android.nfc.NfcAdapter: void setBeamPushUrisCallback(CreateBeamUrisCallback,Activity)>",28,29,"<android.nfc.NfcAdapter: void setBeamPushUrisCallback(CreateBeamUrisCallback,Activity)>","<android.nfc.NfcAdapter: void setBeamPushUrisCallback(CreateBeamUrisCallback,Activity)>",0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    mNfcActivityManager.setNdefPushContentUriCallback(activity, callback);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    mNfcActivityManager.setNdefPushContentUriCallback(activity, callback);
}",1,"/**
 * Set a callback that will dynamically generate one or more {@link Uri}s
 * to send using Android Beam (TM). Every Uri the callback provides
 * must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this callback, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUrisCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the Uri(s) will be pushed
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Set a callback that will dynamically generate one or more {@link Uri}s
 * to send using Android Beam (TM). Every Uri the callback provides
 * must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this callback, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUrisCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the Uri(s) will be pushed
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated this feature is deprecated. File sharing can work using other technology like
 * Bluetooth.
 */
",-1,,[@java.lang.Deprecated],-1,-1,-1,-1,-1,-1,"1,2,3","1,2","A return statement has been added within a new conditional check inside the synchronized block, and a new control dependency has been introduced. So the change types are 1,2,3.","The addition of a new control dependency with a return statement can potentially lead to the method returning early without executing the remaining code. This change could lead to a different return value or type, and the addition of `throw new UnsupportedOperationException();` within the synchronized block can lead to a different exception being thrown. Thus, the CI types are 1,2."
817,"<android.provider.DocumentsProvider: String[] getDocumentStreamTypes(String,String)>",28,29,"<android.provider.DocumentsProvider: String[] getDocumentStreamTypes(String,String)>","<android.provider.DocumentsProvider: String[] getDocumentStreamTypes(String,String)>",0,"{
    Cursor cursor = null;
    try {
        cursor = queryDocument(documentId, null);
        if (cursor.moveToFirst()) {
            final String mimeType = cursor.getString(cursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));
            final long flags = cursor.getLong(cursor.getColumnIndexOrThrow(Document.COLUMN_FLAGS));
            if ((flags & Document.FLAG_VIRTUAL_DOCUMENT) == 0 && mimeType != null && mimeTypeMatches(mimeTypeFilter, mimeType)) {
                return new String[] { mimeType };
            }
        }
    } catch (FileNotFoundException e) {
        return null;
    } finally {
        IoUtils.closeQuietly(cursor);
    }
    // No streamable MIME types.
    return null;
}","{
    Cursor cursor = null;
    try {
        cursor = queryDocument(documentId, null);
        if (cursor.moveToFirst()) {
            final String mimeType = cursor.getString(cursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));
            final long flags = cursor.getLong(cursor.getColumnIndexOrThrow(Document.COLUMN_FLAGS));
            if ((flags & Document.FLAG_VIRTUAL_DOCUMENT) == 0 && mimeType != null && MimeTypeFilter.matches(mimeType, mimeTypeFilter)) {
                return new String[] { mimeType };
            }
        }
    } catch (FileNotFoundException e) {
        return null;
    } finally {
        IoUtils.closeQuietly(cursor);
    }
    // No streamable MIME types.
    return null;
}",1,"/**
 * Return a list of streamable MIME types matching the filter, which can be passed to
 * {@link #openTypedDocument(String, String, Bundle, CancellationSignal)}.
 *
 * <p>The default implementation returns a MIME type provided by
 * {@link #queryDocument(String, String[])} as long as it matches the filter and the document
 * does not have the {@link Document#FLAG_VIRTUAL_DOCUMENT} flag set.
 *
 * <p>Virtual documents must have at least one streamable format.
 *
 * @see #getStreamTypes(Uri, String)
 * @see #openTypedDocument(String, String, Bundle, CancellationSignal)
 */
","/**
 * Return a list of streamable MIME types matching the filter, which can be passed to
 * {@link #openTypedDocument(String, String, Bundle, CancellationSignal)}.
 *
 * <p>The default implementation returns a MIME type provided by
 * {@link #queryDocument(String, String[])} as long as it matches the filter and the document
 * does not have the {@link Document#FLAG_VIRTUAL_DOCUMENT} flag set.
 *
 * <p>Virtual documents must have at least one streamable format.
 *
 * @see #getStreamTypes(Uri, String)
 * @see #openTypedDocument(String, String, Bundle, CancellationSignal)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call `mimeTypeMatches(mimeTypeFilter, mimeType)` was replaced by `MimeTypeFilter.matches(mimeType, mimeTypeFilter)` which indicates a dependent API change (5). There is no change in the return statements or the exception handling, so the other change type is 4 (Other statement changed).","There does not appear to be a compatibility issue here because the method's functionality is expected to remain the same despite the internal call to a different method, assuming that `MimeTypeFilter.matches()` is functionally equivalent to `mimeTypeMatches()`. The signature and exception handling of the method have not been altered."
818,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,28,29,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,0,"{
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.isA2dpPlaying(device);
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}","{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.isA2dpPlaying(device);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}",1,"/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */
","/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The variable for the service object was changed from mService to a local variable service, initialized by the getService() method. There is no change to the logic of the method, the return statements, or the exceptions handled.",There's no compatibility issue detected because there is no change in the behaviour of the method. The return values and exceptions that could be thrown remain the same as before despite the change in the implementation detail.
819,<android.app.NotificationChannel: boolean equals(Object)>,28,29,<android.app.NotificationChannel: boolean equals(Object)>,<android.app.NotificationChannel: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    if (getImportance() != that.getImportance())
        return false;
    if (mBypassDnd != that.mBypassDnd)
        return false;
    if (getLockscreenVisibility() != that.getLockscreenVisibility())
        return false;
    if (mLights != that.mLights)
        return false;
    if (getLightColor() != that.getLightColor())
        return false;
    if (getUserLockedFields() != that.getUserLockedFields())
        return false;
    if (mVibrationEnabled != that.mVibrationEnabled)
        return false;
    if (mShowBadge != that.mShowBadge)
        return false;
    if (isDeleted() != that.isDeleted())
        return false;
    if (isBlockableSystem() != that.isBlockableSystem())
        return false;
    if (getId() != null ? !getId().equals(that.getId()) : that.getId() != null)
        return false;
    if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) {
        return false;
    }
    if (getDescription() != null ? !getDescription().equals(that.getDescription()) : that.getDescription() != null) {
        return false;
    }
    if (getSound() != null ? !getSound().equals(that.getSound()) : that.getSound() != null) {
        return false;
    }
    if (!Arrays.equals(mVibration, that.mVibration))
        return false;
    if (getGroup() != null ? !getGroup().equals(that.getGroup()) : that.getGroup() != null) {
        return false;
    }
    return getAudioAttributes() != null ? getAudioAttributes().equals(that.getAudioAttributes()) : that.getAudioAttributes() == null;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    return getImportance() == that.getImportance() && mBypassDnd == that.mBypassDnd && getLockscreenVisibility() == that.getLockscreenVisibility() && mLights == that.mLights && getLightColor() == that.getLightColor() && getUserLockedFields() == that.getUserLockedFields() && isFgServiceShown() == that.isFgServiceShown() && mVibrationEnabled == that.mVibrationEnabled && mShowBadge == that.mShowBadge && isDeleted() == that.isDeleted() && isBlockableSystem() == that.isBlockableSystem() && mAllowBubbles == that.mAllowBubbles && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(mDesc, that.mDesc) && Objects.equals(getSound(), that.getSound()) && Arrays.equals(mVibration, that.mVibration) && Objects.equals(getGroup(), that.getGroup()) && Objects.equals(getAudioAttributes(), that.getAudioAttributes()) && mImportanceLockedByOEM == that.mImportanceLockedByOEM && mImportanceLockedDefaultApp == that.mImportanceLockedDefaultApp;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The change is in the return statement, where the implementation now uses a single return statement using logical AND operators to combine all conditions instead of multiple return statements for each check, and two new checks are added: `isFgServiceShown() == that.isFgServiceShown()` and `mAllowBubbles == that.mAllowBubbles`. There is also a change in the condition `getDescription() != null` which has been altered to compare `mDesc` instead, so the change type is 1,3.","The change in return statement logic and the addition of new equality checks could cause the API to return different values when the equals method is called between versions. In addition, changing the `getDescription()` condition to check `mDesc` instead could potentially alter the equality comparison result. Therefore, the CI type is 1."
820,<android.content.ContentValues: String toString()>,28,29,<android.content.ContentValues: String toString()>,<android.content.ContentValues: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    for (String name : mValues.keySet()) {
        String value = getAsString(name);
        if (sb.length() > 0)
            sb.append("" "");
        sb.append(name + ""="" + value);
    }
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    for (String name : mMap.keySet()) {
        String value = getAsString(name);
        if (sb.length() > 0)
            sb.append("" "");
        sb.append(name + ""="" + value);
    }
    return sb.toString();
}",1,"/**
 * Returns a string containing a concise, human-readable description of this object.
 * @return a printable representation of this object.
 */
","/**
 * Returns a string containing a concise, human-readable description of this object.
 * @return a printable representation of this object.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The code has changed the variable name from mValues to mMap, which is only a name change and therefore falls under the category of other statement change (4). Additionally, this suggests that there might have been a change in the underlying data structure, which could be a dependent API change (5).","Since it's just a renaming of a variable, and assuming that mMap and mValues are equivalent in their role and functionality, there would not be a Compatibility Issue, as the output of the toString() method would remain the same (no different return values or types and no different exception handlings)."
821,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",28,29,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>","<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",0,"{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName(), mContext.getDisplayId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home apps</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
","/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home apps</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API changed from sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName()) to sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName(), mContext.getDisplayId()); an additional parameter 'mContext.getDisplayId()' is added to the method call, so the code change type is 1,5.","The change in the dependent API call with an additional parameter being passed can potentially result in a different behavior, and since this is a void method without a return type, the CI is related to the potential different behavior of the API call due to the altered method signature, so the CI type is 1."
823,<android.app.servertransaction.PendingTransactionActions.StopInfo: void run()>,28,29,<android.app.servertransaction.PendingTransactionActions.StopInfo: void run()>,<android.app.servertransaction.PendingTransactionActions.StopInfo: void run()>,0,"{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + mActivity);
        // TODO(lifecycler): Use interface callback instead of AMS.
        ActivityManager.getService().activityStopped(mActivity.token, mState, mPersistentState, mDescription);
    } catch (RemoteException ex) {
        // Dump statistics about bundle to help developers debug
        final LogWriter writer = new LogWriter(Log.WARN, TAG);
        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, ""  "");
        pw.println(""Bundle stats:"");
        Bundle.dumpStats(pw, mState);
        pw.println(""PersistableBundle stats:"");
        Bundle.dumpStats(pw, mPersistentState);
        if (ex instanceof TransactionTooLargeException && mActivity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}","{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + mActivity);
        // TODO(lifecycler): Use interface callback instead of AMS.
        ActivityTaskManager.getService().activityStopped(mActivity.token, mState, mPersistentState, mDescription);
    } catch (RemoteException ex) {
        // Dump statistics about bundle to help developers debug
        final LogWriter writer = new LogWriter(Log.WARN, TAG);
        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, ""  "");
        pw.println(""Bundle stats:"");
        Bundle.dumpStats(pw, mState);
        pw.println(""PersistableBundle stats:"");
        Bundle.dumpStats(pw, mPersistentState);
        if (ex instanceof TransactionTooLargeException && mActivity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The method getService() call on ActivityManager has changed to getService() call on ActivityTaskManager, there is a modification in the dependent API's call which is a type 5 change. ","The switch from ActivityManager.getService() to ActivityTaskManager.getService() indicates that there is a change in the dependent API which can cause a potential Compatibility Issue if the behavior of the new API is different, hence CI type 1."
824,<android.view.autofill.AutofillManager: String getUserDataId()>,28,29,<android.view.autofill.AutofillManager: String getUserDataId()>,<android.view.autofill.AutofillManager: String getUserDataId()>,0,"{
    try {
        return mService.getUserDataId();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}","{
    try {
        final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
        mService.getUserDataId(receiver);
        return receiver.getStringResult();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}",1,"/**
 * Gets the id of the {@link UserData} used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>This method is useful when the service must check the status of the {@link UserData} in
 * the device without fetching the whole object.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return id of the {@link UserData} previously set by {@link #setUserData(UserData)}
 * or {@code null} if it was reset or if the caller currently does not have an enabled autofill
 * service for the user.
 */
","/**
 * Gets the id of the {@link UserData} used for
 * <a href=""AutofillService.html#FieldClassification"">field classification</a>.
 *
 * <p>This method is useful when the service must check the status of the {@link UserData} in
 * the device without fetching the whole object.
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 *
 * @return id of the {@link UserData} previously set by {@link #setUserData(UserData)}
 * or {@code null} if it was reset or if the caller currently does not have an enabled autofill
 * service for the user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The method call inside the try block has been replaced with a new approach to retrieve the result; also, a new API dependency on SyncResultReceiver is used to obtain the string result. The return type remains the same (`String`), and the exception handling has not changed, so the code change type is 5.","There is no compatibility issue present. Although the mechanism to retrieve the user data ID has changed, it does not alter the contract of the method. The method still returns a `String` or null, and the exception handling has not been modified. As a result, from a caller's perspective, the method's behavior remains consistent, and hence, there is no potential for a compatibility issue."
827,<android.app.UiAutomationConnection.Repeater: void run()>,28,29,<android.app.UiAutomationConnection.Repeater: void run()>,<android.app.UiAutomationConnection.Repeater: void run()>,0,"{
    try {
        final byte[] buffer = new byte[8192];
        int readByteCount;
        while (true) {
            readByteCount = readFrom.read(buffer);
            if (readByteCount < 0) {
                break;
            }
            writeTo.write(buffer, 0, readByteCount);
            writeTo.flush();
        }
    } catch (IOException ioe) {
        throw new RuntimeException(""Error while reading/writing "", ioe);
    } finally {
        IoUtils.closeQuietly(readFrom);
        IoUtils.closeQuietly(writeTo);
    }
}","{
    try {
        final byte[] buffer = new byte[8192];
        int readByteCount;
        while (true) {
            readByteCount = readFrom.read(buffer);
            if (readByteCount < 0) {
                break;
            }
            writeTo.write(buffer, 0, readByteCount);
            writeTo.flush();
        }
    } catch (IOException ioe) {
        Log.w(TAG, ""Error while reading/writing to streams"");
    } finally {
        IoUtils.closeQuietly(readFrom);
        IoUtils.closeQuietly(writeTo);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The code has changed in the exception handling statement. In the early version, an IOException leads to throwing a new RuntimeException which contains the original IOException, whereas in the late version, it simply logs a warning message without throwing an exception.","Because the late version of the method no longer throws a RuntimeException in case of an IOException, the API's behavior when encountering such an exception has changed. This change can lead to callers receiving fewer exceptions than they would with the early version, which is a potential Compatibility Issue caused by different exception handlings, marking the CI type as 2."
828,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(SparseArray<Surface>)>,28,29,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(SparseArray<Surface>)>,<android.hardware.camera2.legacy.LegacyCameraDevice: int configureOutputs(SparseArray<Surface>)>,0,"{
    List<Pair<Surface, Size>> sizedSurfaces = new ArrayList<>();
    if (outputs != null) {
        int count = outputs.size();
        for (int i = 0; i < count; i++) {
            Surface output = outputs.valueAt(i);
            if (output == null) {
                Log.e(TAG, ""configureOutputs - null outputs are not allowed"");
                return BAD_VALUE;
            }
            if (!output.isValid()) {
                Log.e(TAG, ""configureOutputs - invalid output surfaces are not allowed"");
                return BAD_VALUE;
            }
            StreamConfigurationMap streamConfigurations = mStaticCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            // Validate surface size and format.
            try {
                Size s = getSurfaceSize(output);
                int surfaceType = detectSurfaceType(output);
                boolean flexibleConsumer = isFlexibleConsumer(output);
                Size[] sizes = streamConfigurations.getOutputSizes(surfaceType);
                if (sizes == null) {
                    if (surfaceType == ImageFormat.PRIVATE) {
                        // YUV_420_888 is always present in LEGACY for all
                        // IMPLEMENTATION_DEFINED output sizes, and is publicly visible in the
                        // API (i.e. {@code #getOutputSizes} works here).
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.YUV_420_888);
                    } else if (surfaceType == LegacyMetadataMapper.HAL_PIXEL_FORMAT_BLOB) {
                        sizes = streamConfigurations.getOutputSizes(ImageFormat.JPEG);
                    }
                }
                if (!ArrayUtils.contains(sizes, s)) {
                    if (flexibleConsumer && (s = findClosestSize(s, sizes)) != null) {
                        sizedSurfaces.add(new Pair<>(output, s));
                    } else {
                        String reason = (sizes == null) ? ""format is invalid."" : (""size not in valid set: "" + Arrays.toString(sizes));
                        Log.e(TAG, String.format(""Surface with size (w=%d, h=%d) and format "" + ""0x%x is not valid, %s"", s.getWidth(), s.getHeight(), surfaceType, reason));
                        return BAD_VALUE;
                    }
                } else {
                    sizedSurfaces.add(new Pair<>(output, s));
                }
                // Lock down the size before configuration
                setSurfaceDimens(output, s.getWidth(), s.getHeight());
            } catch (BufferQueueAbandonedException e) {
                Log.e(TAG, ""Surface bufferqueue is abandoned, cannot configure as output: "", e);
                return BAD_VALUE;
            }
        }
    }
    boolean success = false;
    if (mDeviceState.setConfiguring()) {
        mRequestThreadManager.configure(sizedSurfaces);
        success = mDeviceState.setIdle();
    }
    if (success) {
        mConfiguredSurfaces = outputs;
    } else {
        return LegacyExceptionUtils.INVALID_OPERATION;
    }
    return LegacyExceptionUtils.NO_ERROR;
}","{
    return configureOutputs(outputs, /*validateSurfacesOnly*/
    false);
}",1,"/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set. LegacyCameraDevice will take ownership of this
 * list; it must not be modified by the caller once it's passed in.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
","/**
 * Configure the device with a set of output surfaces.
 *
 * <p>Using empty or {@code null} {@code outputs} is the same as unconfiguring.</p>
 *
 * <p>Every surface in {@code outputs} must be non-{@code null}.</p>
 *
 * @param outputs a list of surfaces to set. LegacyCameraDevice will take ownership of this
 * list; it must not be modified by the caller once it's passed in.
 * @return an error code for this binder operation, or {@link NO_ERROR}
 * on success.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole implementation of the method has been changed from a detailed implementation to a single return statement calling another method ""configureOutputs(outputs, false);"" with a different signature. Also, the dependent API of configureOutputs(SparseArray<Surface>, boolean) is different from the early version, so the code change type is 1,5.","Since the entire logic of the method has been redirected to another method with an additional boolean parameter, the behavior of the API could potentially be different, so a Compatibility Issue could arise due to the possibility of different return values or types, and the CI type is 1."
829,<android.os.StrictMode.AndroidBlockGuardPolicy: void onCustomSlowCall(String)>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void onCustomSlowCall(String)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onCustomSlowCall(String)>,0,"{
    if ((mPolicyMask & DETECT_CUSTOM) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new CustomViolation(name));
}","{
    if ((mThreadPolicyMask & DETECT_THREAD_CUSTOM) == 0) {
        return;
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new CustomViolation(name));
}",1,"// Not part of BlockGuard.Policy; just part of StrictMode:
","// Not part of BlockGuard.Policy; just part of StrictMode:
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The condition in the if-statement has changed from checking `mPolicyMask & DETECT_CUSTOM` to checking `mThreadPolicyMask & DETECT_THREAD_CUSTOM`. Additionally, the mask constant used also changed from DETECT_CUSTOM to DETECT_THREAD_CUSTOM, and the name of the member variable changed. These are changes of type 3 (Control dependency change), 4 (Other statement changed), and 5 (Dependent API changed).","There is no Compatibility Issue here because all the changes, while they modify the logic, do not affect what the method returns or what exceptions it throws. The API will still return void and does not introduce any new exception handling. The change in the mask constant and member variable name does not lead to a change in behavior that would lead to different return types or values from the API nor a difference in exception handling. Thus, the CI type is 0."
830,<android.widget.AutoCompleteTextView.MyWatcher: void afterTextChanged(Editable)>,28,29,<android.widget.AutoCompleteTextView.MyWatcher: void afterTextChanged(Editable)>,<android.widget.AutoCompleteTextView.MyWatcher: void afterTextChanged(Editable)>,0,"{
    doAfterTextChanged();
}","{
    if (mBlockCompletion)
        return;
    // called performCompletion() and we shouldn't do any more processing.
    if (DEBUG) {
        Log.v(TAG, ""after text changed: openBefore="" + mOpenBefore + "" open="" + isPopupShowing());
    }
    if (mOpenBefore && !isPopupShowing())
        return;
    refreshAutoCompleteResults();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are new control dependency changes with the added conditional statements, and other changes include additional log statements and a method call to refreshAutoCompleteResults  this identifies the code change types as 3 and 4.","Despite the added control statements and change in method calls, these changes do not seem to lead to any difference in the return values or exception handling, because the method return type is void and there doesn't appear to be any throw statements. Therefore, no Compatibility Issue is detected as per the given rules."
831,<android.view.SurfaceControl.Builder: SurfaceControl build()>,28,29,<android.view.SurfaceControl.Builder: SurfaceControl build()>,<android.view.SurfaceControl.Builder: SurfaceControl build()>,0,"{
    if (mWidth <= 0 || mHeight <= 0) {
        throw new IllegalArgumentException(""width and height must be set"");
    }
    return new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mWindowType, mOwnerUid);
}","{
    if (mWidth < 0 || mHeight < 0) {
        throw new IllegalStateException(""width and height must be positive or unset"");
    }
    if ((mWidth > 0 || mHeight > 0) && (isColorLayerSet() || isContainerLayerSet())) {
        throw new IllegalStateException(""Only buffer layers can set a valid buffer size."");
    }
    return new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata);
}",1,"/**
 * Construct a new {@link SurfaceControl} with the set parameters.
 */
","/**
 * Construct a new {@link SurfaceControl} with the set parameters. The builder
 * remains valid.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The exception thrown changed from IllegalArgumentException to IllegalStateException with a different message text, and the conditions that trigger the exception have been modified (from <= 0 to < 0). A new conditional block with a new exception throwing statement has been added. Also, there are changes in the parameters passed to the constructor of SurfaceControl, removing mWindowType and mOwnerUid, and adding mMetadata, and a new check for layer types. These are changes of types 1, 2, 4, 5.","The change in conditions that trigger the exception throwing behavior as well as the change in exceptions themselves means the method could throw different exceptions under certain conditions which create CI of type 2. The changes in the constructor's parameters could lead to different return values, especially since the metadata parameter is added, and different exceptions might be thrown based on the new conditional check; therefore, CI type 1 is also applicable."
833,<android.app.Service: void stopForeground(int)>,28,29,<android.app.Service: void stopForeground(int)>,<android.app.Service: void stopForeground(int)>,0,"{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, 0, null, flags);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, 0, null, flags, 0);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Remove this service from foreground state, allowing it to be killed if
 * more memory is needed.  This does not stop the service from running (for that
 * you use {@link #stopSelf()} or related methods), just takes it out of the
 * foreground state.
 *
 * @param flags additional behavior options.
 * @see #startForeground(int, Notification)
 */
","/**
 * Remove this service from foreground state, allowing it to be killed if
 * more memory is needed.  This does not stop the service from running (for that
 * you use {@link #stopSelf()} or related methods), just takes it out of the
 * foreground state.
 *
 * @param flags additional behavior options.
 * @see #startForeground(int, Notification)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method `mActivityManager.setServiceForeground` now expects an extra parameter according to the implementation change but there's no change to the return statements or the exception handling structure, so the change types are 4 and 5.","The extra parameter in the `setServiceForeground` method call does not change the return value or the exception throwing behavior of the `stopForeground` API, hence there's no Compatibility Issue introduced by this change."
834,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertisingSet(AdvertisingSetParameters,AdvertiseData,AdvertiseData,PeriodicAdvertisingParameters,AdvertiseData,int,int,AdvertisingSetCallback,Handler)>",28,29,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertisingSet(AdvertisingSetParameters,AdvertiseData,AdvertiseData,PeriodicAdvertisingParameters,AdvertiseData,int,int,AdvertisingSetCallback,Handler)>","<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertisingSet(AdvertisingSetParameters,AdvertiseData,AdvertiseData,PeriodicAdvertisingParameters,AdvertiseData,int,int,AdvertisingSetCallback,Handler)>",0,"{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy scan response data too big"");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException(""Unsupported primary PHY selected"");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException(""Unsupported secondary PHY selected"");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException(""Advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException(""Scan response data too big"");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException(""Periodic advertising data too big"");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException(""Controller does not support LE Periodic Advertising"");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException(""maxExtendedAdvertisingEvents out of range: "" + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException(""Can't use maxExtendedAdvertisingEvents with controller that don't support "" + ""LE Extended Advertising"");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException(""duration out of range: "" + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to get Bluetooth gatt - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException(""callback instance already associated with advertising"");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to start advertising set - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
}","{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy scan response data too big"");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException(""Unsupported primary PHY selected"");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException(""Unsupported secondary PHY selected"");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException(""Advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException(""Scan response data too big"");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException(""Periodic advertising data too big"");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException(""Controller does not support LE Periodic Advertising"");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException(""maxExtendedAdvertisingEvents out of range: "" + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException(""Can't use maxExtendedAdvertisingEvents with controller that don't support "" + ""LE Extended Advertising"");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException(""duration out of range: "" + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to get Bluetooth GATT - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    if (gatt == null) {
        Log.e(TAG, ""Bluetooth GATT is null"");
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException(""callback instance already associated with advertising"");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to start advertising set - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
}",1,"/**
 * Creates a new advertising set. If operation succeed, device will start advertising. This
 * method returns immediately, the operation status is delivered through
 * {@code callback.onAdvertisingSetStarted()}.
 * <p>
 *
 * @param parameters Advertising set parameters.
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags.
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param periodicParameters Periodic advertisng parameters. If null, periodic advertising will
 * not be started.
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to 65535
 * (655,350 ms). 0 means advertising should continue until stopped.
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended advertising, even if the
 * duration has not expired. Valid range is from 1 to 255. 0 means no maximum.
 * @param callback Callback for advertising set.
 * @param handler Thread upon which the callbacks will be invoked.
 * @throws IllegalArgumentException When any of the data parameter exceed the maximum allowable
 * size, or unsupported advertising PHY is selected, or when attempt to use Periodic Advertising
 * feature is made when it's not supported by the controller, or when
 * maxExtendedAdvertisingEvents is used on a controller that doesn't support the LE Extended
 * Advertising
 */
","/**
 * Creates a new advertising set. If operation succeed, device will start advertising. This
 * method returns immediately, the operation status is delivered through
 * {@code callback.onAdvertisingSetStarted()}.
 * <p>
 *
 * @param parameters Advertising set parameters.
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags.
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param periodicParameters Periodic advertisng parameters. If null, periodic advertising will
 * not be started.
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to 65535
 * (655,350 ms). 0 means advertising should continue until stopped.
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended advertising, even if the
 * duration has not expired. Valid range is from 1 to 255. 0 means no maximum.
 * @param callback Callback for advertising set.
 * @param handler Thread upon which the callbacks will be invoked.
 * @throws IllegalArgumentException When any of the data parameter exceed the maximum allowable
 * size, or unsupported advertising PHY is selected, or when attempt to use Periodic Advertising
 * feature is made when it's not supported by the controller, or when
 * maxExtendedAdvertisingEvents is used on a controller that doesn't support the LE Extended
 * Advertising
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
835,<android.bluetooth.le.ScanFilter: int hashCode()>,28,29,<android.bluetooth.le.ScanFilter: int hashCode()>,<android.bluetooth.le.ScanFilter: int hashCode()>,0,"{
    return Objects.hash(mDeviceName, mDeviceAddress, mManufacturerId, Arrays.hashCode(mManufacturerData), Arrays.hashCode(mManufacturerDataMask), mServiceDataUuid, Arrays.hashCode(mServiceData), Arrays.hashCode(mServiceDataMask), mServiceUuid, mServiceUuidMask);
}","{
    return Objects.hash(mDeviceName, mDeviceAddress, mManufacturerId, Arrays.hashCode(mManufacturerData), Arrays.hashCode(mManufacturerDataMask), mServiceDataUuid, Arrays.hashCode(mServiceData), Arrays.hashCode(mServiceDataMask), mServiceUuid, mServiceUuidMask, mServiceSolicitationUuid, mServiceSolicitationUuidMask);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The hashCode method's return statement has changed by adding two new parameters: mServiceSolicitationUuid and mServiceSolicitationUuidMask, so the code change type is 1.","With the addition of new parameters to the hashCode computation, the returned hash value could potentially be different. Therefore, the CI type is 1, as the API's behavior can change, leading to a different return value."
836,<android.provider.MediaStore.Audio.Genres: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Audio.Genres: Uri getContentUri(String)>,<android.provider.MediaStore.Audio.Genres: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/genres"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""audio"").appendPath(""genres"").build();
}",1,"/**
 * Get the content:// style URI for the audio genres table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio genres table on the given volume
 */
","/**
 * Get the content:// style URI for the audio genres table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio genres table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method of constructing the Uri has changed, with different methods and classes used in the implementation, therefore the changes include return statement, other statement, and dependent API (Uri.parse vs. AUTHORITY_URI.buildUpon()), so the code change type is 1,4,5.","Even though the intent of the implementations is the same (constructing and returning a Uri), the way the Uri is constructed has changed and may potentially result in a different Uri being returned. This constitutes a change in the return value, hence the CI type is 1."
837,<android.widget.TextView: boolean hasOverlappingRendering()>,28,29,<android.widget.TextView: boolean hasOverlappingRendering()>,<android.widget.TextView: boolean hasOverlappingRendering()>,0,"{
    // horizontal fading edge causes SaveLayerAlpha, which doesn't support alpha modulation
    return ((getBackground() != null && getBackground().getCurrent() != null) || mSpannable != null || hasSelection() || isHorizontalFadingEdgeEnabled());
}","{
    // horizontal fading edge causes SaveLayerAlpha, which doesn't support alpha modulation
    return ((getBackground() != null && getBackground().getCurrent() != null) || mSpannable != null || hasSelection() || isHorizontalFadingEdgeEnabled() || mShadowColor != 0);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"There is an additional or condition 'mShadowColor != 0' in the return statement, indicating a control dependency change. As a result, the code change involves both 1 (Return statement changed) and 3 (Control dependency changed).","The addition of a new condition 'mShadowColor != 0' to the return statement could alter the return value of the method, potentially causing different behavior in the late version compared to the early version. Hence, the CI type is 1 (Compatibility Issue caused by potential different return values)."
839,<android.service.notification.ZenModeConfig.EventInfo: int hashCode()>,28,29,<android.service.notification.ZenModeConfig.EventInfo: int hashCode()>,<android.service.notification.ZenModeConfig.EventInfo: int hashCode()>,0,"{
    return 0;
}","{
    return Objects.hash(userId, calName, calendarId, reply);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement is changed from a constant return value (0) to a calculated hash value using Objects.hash. Therefore, the code change type is 1.","This will result in a different return value for any inputs where the object's fields (userId, calName, calendarId, reply) are not all null or zeros, which is almost always the case for a hash function. Hence, there is a potential difference in return values, so the CI type is 1."
840,<android.text.Layout.HorizontalMeasurementProvider: float get(int)>,28,29,<android.text.Layout.HorizontalMeasurementProvider: float get(int)>,<android.text.Layout.HorizontalMeasurementProvider: float get(int)>,0,"{
    if (mHorizontals == null) {
        return getHorizontal(offset, mPrimary);
    } else {
        return mHorizontals[offset - mLineStartOffset];
    }
}","{
    final int index = offset - mLineStartOffset;
    if (mHorizontals == null || index < 0 || index >= mHorizontals.length) {
        return getHorizontal(offset, mPrimary);
    } else {
        return mHorizontals[index];
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The condition in the 'if' statement has changed, adding checks for the index boundaries. Additionally, the index is now being calculated before being used in the return statement, so the change type is 1 due to the content of return statements potentially changing, and 3 because of the change in the control flow condition.","Given that the late version includes additional checks on the index range before accessing 'mHorizontals', this could lead to a different return value when 'index' is out of bounds. Previously, such a scenario would lead to an ArrayIndexOutOfBoundsException, but now it will return the result of 'getHorizontal(offset, mPrimary)' instead. Therefore, the CI type is 1 due to the API potentially returning different values under certain conditions."
841,<android.net.http.HttpResponseCache: int getRequestCount()>,28,29,<android.net.http.HttpResponseCache: int getRequestCount()>,<android.net.http.HttpResponseCache: int getRequestCount()>,0,"{
    return delegate.getRequestCount();
}","{
    return mDelegate.getRequestCount();
}",1,"/**
 * Returns the total number of HTTP requests that were made. This includes
 * both client requests and requests that were made on the client's behalf
 * to handle a redirects and retries.
 */
","/**
 * Returns the total number of HTTP requests that were made. This includes
 * both client requests and requests that were made on the client's behalf
 * to handle a redirects and retries.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is from `delegate.getRequestCount()` to `mDelegate.getRequestCount()`, which indicates a change in the instance variable name. This is categorized under other statement changed because it is not a control structure, return statement, or exception handling change.",This change does not result in a compatibility issue since the method's behavior and return value are expected to remain the same; only the member variable name has been altered for internal reference within the object without affecting the external API contract.
843,<android.widget.TextView: Mode getCompoundDrawableTintMode()>,28,29,<android.widget.TextView: Mode getCompoundDrawableTintMode()>,<android.widget.TextView: Mode getCompoundDrawableTintMode()>,0,"{
    return mDrawables != null ? mDrawables.mTintMode : null;
}","{
    BlendMode mode = getCompoundDrawableTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the compound
 * drawables, if specified.
 *
 * @return the blending mode used to apply the tint to the compound
 * drawables
 * @attr ref android.R.styleable#TextView_drawableTintMode
 * @see #setCompoundDrawableTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the compound
 * drawables, if specified.
 *
 * @return the blending mode used to apply the tint to the compound
 * drawables
 * @attr ref android.R.styleable#TextView_drawableTintMode
 * @see #setCompoundDrawableTintMode(PorterDuff.Mode)
 */
",-1,,"[@InspectableProperty(name = ""drawableTintMode"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation now relies on a new method `getCompoundDrawableTintBlendMode()` and the conversion from this method's return type to another type with `BlendMode.blendModeToPorterDuffMode(mode)`, so the changes include a new dependent API call and logic to convert its result. The code change type is 1,5.","Since the implementation now converts the `BlendMode` obtained from a new method to `Mode` using `blendModeToPorterDuffMode(mode)`, it could potentially return a different value than the previous version, hence the CI type is 1."
844,<android.app.ActivityManager.AppTask: void moveToFront()>,28,29,<android.app.ActivityManager.AppTask: void moveToFront()>,<android.app.ActivityManager.AppTask: void moveToFront()>,0,"{
    try {
        mAppTaskImpl.moveToFront();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        ActivityThread thread = ActivityThread.currentActivityThread();
        IApplicationThread appThread = thread.getApplicationThread();
        String packageName = ActivityThread.currentPackageName();
        mAppTaskImpl.moveToFront(appThread, packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Bring this task to the foreground.  If it contains activities, they will be
 * brought to the foreground with it and their instances re-created if needed.
 * If it doesn't contain activities, the root activity of the task will be
 * re-launched.
 */
","/**
 * Bring this task to the foreground.  If it contains activities, they will be
 * brought to the foreground with it and their instances re-created if needed.
 * If it doesn't contain activities, the root activity of the task will be
 * re-launched.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code changes include additional method calls to retrieve the 'ActivityThread' and 'packageName' which are then used as parameters for 'mAppTaskImpl.moveToFront'. This indicates a change in other statements (4) and additionally a change in the dependent API (5), since 'moveToFront' method is now called with new parameters.","There is no CI detected in this change. Although the implementation calls 'moveToFront' with additional parameters, this doesn't necessarily cause the API to return a different value or throw a new exception because this new implementation doesn't alter the control flow or exception handling path of the method; the exception caught is still the same, and the way it's rethrown hasn't changed. The call to 'moveToFront' is internal and will abstract away this complexity from the caller. Hence, the behaviour observed by the caller of 'moveToFront' should remain unchanged, leading to no compatibility issue (0)."
845,<android.provider.MediaStore.Video.Media: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Video.Media: Uri getContentUri(String)>,<android.provider.MediaStore.Video.Media: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/video/media"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""video"").appendPath(""media"").build();
}",1,"/**
 * Get the content:// style URI for the video media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the video media table on the given volume
 */
","/**
 * Get the content:// style URI for the video media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the video media table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed from direct string parsing to using the Uri builder mechanism to construct the Uri, so the code change type is 1.","The change in the return statement means that the method will return a potentially different Uri value, even though they are intended to represent the same logical Uri. This could lead to a Compatibility Issue when the caller of the method expects the string representation of the Uri to be unchanged, thus the CI type is 1."
846,<android.app.Activity: void reportFullyDrawn()>,28,29,<android.app.Activity: void reportFullyDrawn()>,<android.app.Activity: void reportFullyDrawn()>,0,"{
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityManager.getService().reportActivityFullyDrawn(mToken, mRestoredFromBundle);
        } catch (RemoteException e) {
        }
    }
}","{
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityTaskManager.getService().reportActivityFullyDrawn(mToken, mRestoredFromBundle);
            VMRuntime.getRuntime().notifyStartupCompleted();
        } catch (RemoteException e) {
        }
    }
}",1,"/**
 * Report to the system that your app is now fully drawn, purely for diagnostic
 * purposes (calling it does not impact the visible behavior of the activity).
 * This is only used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 */
","/**
 * Report to the system that your app is now fully drawn, purely for diagnostic
 * purposes (calling it does not impact the visible behavior of the activity).
 * This is only used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"Within the try block, an additional method call `VMRuntime.getRuntime().notifyStartupCompleted();` has been added and the service name has changed from `ActivityManager.getService()` to `ActivityTaskManager.getService()`. Therefore, the code change type is 4,5.","Even though there are changes to the method body, none of these changes introduce a new return statement or modify the existing return value (since there was no return value to begin with), nor do they alter the exception handling mechanics. Therefore, there is no compatibility issue, hence CI type is 0."
847,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",28,29,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}","{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no difference between the early and the late version of the implementation. The switch statement and all of its cases remain the same.,No Compatibility Issue is detected because there are no changes in the implementation between the two versions of the API.
848,<android.content.ContentValues: int size()>,28,29,<android.content.ContentValues: int size()>,<android.content.ContentValues: int size()>,0,"{
    return mValues.size();
}","{
    return mMap.size();
}",1,"/**
 * Returns the number of values.
 *
 * @return the number of values
 */
","/**
 * Returns the number of values.
 *
 * @return the number of values
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is limited to renaming the variable from mValues to mMap, which is internal to the method and does not affect the method's behavior. Therefore, the code change type is 4.","Given that the only change is a renaming of a variable and it's assumed that mMap and mValues refer to the same underlying data structure within the implementation of ContentValues, there would be no change in behavior expected from the perspective of the client code. The values returned would still be the size of the collection. Thus, there is no Compatibility Issue, and the CI type is 0."
849,<android.app.Activity: boolean isTaskRoot()>,28,29,<android.app.Activity: boolean isTaskRoot()>,<android.app.Activity: boolean isTaskRoot()>,0,"{
    try {
        return ActivityManager.getService().getTaskForActivity(mToken, true) >= 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return ActivityTaskManager.getService().getTaskForActivity(mToken, true) >= 0;
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Return whether this activity is the root of a task.  The root is the
 * first activity in a task.
 *
 * @return True if this is the root activity, else false.
 */
","/**
 * Return whether this activity is the root of a task.  The root is the
 * first activity in a task.
 *
 * @return True if this is the root activity, else false.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"There's a change in the dependent API from ActivityManager.getService() to ActivityTaskManager.getService(), which is only a change in the API being called to retrieve the service. Since the actual logic and return value are not affected by this change assuming the dependent API has the same behavior, the code change type is 5.",No Compatibility Issue detected since the return type and exceptions potentially thrown remain the same and assuming the new service method called has the same contract as the previous one.
850,<android.widget.ProgressBar: Mode getProgressTintMode()>,28,29,<android.widget.ProgressBar: Mode getProgressTintMode()>,<android.widget.ProgressBar: Mode getProgressTintMode()>,0,"{
    return mProgressTintInfo != null ? mProgressTintInfo.mProgressTintMode : null;
}","{
    BlendMode mode = getProgressTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the progress
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the progress
 * drawable
 * @attr ref android.R.styleable#ProgressBar_progressTintMode
 * @see #setProgressTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the progress
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the progress
 * drawable
 * @attr ref android.R.styleable#ProgressBar_progressTintMode
 * @see #setProgressTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement now uses a new method getProgressTintBlendMode() and a conversion method BlendMode.blendModeToPorterDuffMode(mode), and a member variable mProgressTintInfo is no longer being referenced directly in the return statement. This indicates a change in both the method's implementation and the underlying dependent API, hence the change type is 1,5.","Since there is a different method being used to calculate the return value, and because the transformation function blendModeToPorterDuffMode could potentially yield a different result than the direct field access used in the early version, there is a possibility that the API will return a different value in the late version, which leads to a CI type of 1."
851,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,28,29,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,0,"{
    if (VDBG)
        log(""getState("" + device + "")"");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.getConnectionState(device);
        }
        if (mService == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.STATE_DISCONNECTED;
    } finally {
        mServiceLock.readLock().unlock();
    }
}","{
    if (VDBG)
        log(""getState("" + device + "")"");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionState(device);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.STATE_DISCONNECTED;
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @BtProfileState]",-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from using the instance variable `mService` directly to calling a method `getService()` for obtaining the service instance, but the logic remains the same. Therefore, the code change type is 5.","Despite the change in how the service instance is obtained, it does not affect the behavior of the API as far as returning different values or throwing exceptions is concerned. The control flow and return values remain consistent. Thus, there is no Compatibility Issue."
852,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,28,29,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(mTag, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}","{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = mContext.getSystemService(InputMethodManager.class);
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(mTag, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                // The IME could not handle it, so skip along to the next InputStage
                return FORWARD;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the way the `InputMethodManager` instance is acquired, changing from `InputMethodManager.peekInstance()` to `mContext.getSystemService(InputMethodManager.class)`. Therefore, this is a change in the method used to get the dependency (dependent API changed), but the behavior of the rest of the code structure remains the same, as such it is both a dependent API change (5) and other change (4).","Despite the change in obtaining the `InputMethodManager`, this does not inherently lead to a compatibility issue because the behavior and the way how `imm` is used after this change remain the same. The method will still return the same results under the same conditions, so there is no compatibility issue (0)."
854,<android.text.SpannableStringBuilder: boolean equals(Object)>,28,29,<android.text.SpannableStringBuilder: boolean equals(Object)>,<android.text.SpannableStringBuilder: boolean equals(Object)>,0,"{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        Spanned other = (Spanned) o;
        // Check span data
        Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                Object thisSpan = mSpans[i];
                Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}","{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        final Spanned other = (Spanned) o;
        // Check span data
        final Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        final Object[] thisSpans = getSpans(0, length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                final Object thisSpan = thisSpans[i];
                final Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}",1,"// Same as SpannableStringInternal
","// Same as SpannableStringInternal
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method adds an extra statement to initialize the `thisSpans` variable from the `this` object, which is an internal change that does not directly affect the return type or exception handling of the method. Thus, the change is classified as both 4 (Other statement changed) and 5 (Dependent API changed) since it adds a dependency on the `getSpans(0, length(), Object.class)` method in the same object.","There is no Compatibility Issue because the logic and control flow of the method remain unchanged, and the return values are consistent with the early version. The method's behavior when comparing the spans is still identical; it just uses a local copy of the spans from `this` rather than referencing them directly."
856,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,28,29,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the synchronization lock object, from `mDeviceBusy` to `mDeviceBusyLock`. This does not affect the return values or exception handling and therefore is classified as 4 (other statement changed).","There is no Compatibility Issue since this change does not affect the API's behavior regarding its return values or exceptions thrown. The method's logic remains the same and it synchronizes on a different object, which will not be visible to the API users. Hence, the CI type is 0."
857,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,28,29,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,<android.view.inputmethod.InputMethodManager: boolean switchToLastInputMethod(IBinder)>,0,"{
    return switchToPreviousInputMethodInternal(imeToken);
}","{
    return InputMethodPrivilegedOperationsRegistry.get(imeToken).switchToPreviousInputMethod();
}",1,"/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToPreviousInputMethod()} instead. This method
 * was intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
","/**
 * Force switch to the last used input method and subtype. If the last input method didn't have
 * any subtypes, the framework will simply switch to the last input method with no subtype
 * specified.
 * @param imeToken Supplies the identifying token given to an input method when it was started,
 * which allows it to perform this operation on itself.
 * @return true if the current input method and subtype was successfully switched to the last
 * used input method and subtype.
 * @deprecated Use {@link InputMethodService#switchToPreviousInputMethod()} instead. This method
 * was intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The implementation relies on different methods to achieve functionality between the versions, changing from calling switchToPreviousInputMethodInternal(imeToken) to calling a method on an object retrieved via InputMethodPrivilegedOperationsRegistry.get(imeToken). Therefore, the code change type is 5.","Since the new method call InputMethodPrivilegedOperationsRegistry.get(imeToken).switchToPreviousInputMethod() is expected to maintain the same behavior as the former internal method switchToPreviousInputMethodInternal(imeToken), we assume that the API contract is honored by the InputMethodPrivilegedOperationsRegistry class, and no new exceptions or return types are introduced. Hence, there is no compatibility issue detected, so CI type is 0."
858,<android.text.SpannableStringInternal: boolean equals(Object)>,28,29,<android.text.SpannableStringInternal: boolean equals(Object)>,<android.text.SpannableStringInternal: boolean equals(Object)>,0,"{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        Spanned other = (Spanned) o;
        // Check span data
        Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                Object thisSpan = mSpans[i];
                Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}","{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        final Spanned other = (Spanned) o;
        // Check span data
        final Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        final Object[] thisSpans = getSpans(0, length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                final Object thisSpan = thisSpans[i];
                final Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}",1,"// Same as SpannableStringBuilder
","// Same as SpannableStringBuilder
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method's implementation now includes the declaration of a new array thisSpans to hold the spans of the current object, and the use of getSpans() to retrieve the current object's spans instead of directly accessing mSpans[]. The iteration now operates over thisSpans[] rather than mSpans[]. These constitute changes to the statements which include declaration and assignment operations (change type 4) and control dependency due to the introduction of a new local variable that affects the loop operation (change type 3).","Although there is a change in the implementation, this does not result in any behavioral change since both the early and late versions ultimately perform the same logic and checks, only through slightly different means. The final result of the equals comparison remains the same. Hence, there is no compatibility issue caused by potential different return values or different exception handlings."
859,"<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>",28,29,"<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>","<android.view.inputmethod.InputMethodManager: void hideSoftInputFromInputMethod(IBinder,int)>",0,"{
    hideSoftInputFromInputMethodInternal(token, flags);
}","{
    InputMethodPrivilegedOperationsRegistry.get(token).hideMySoftInput(flags);
}",1,"/**
 * Close/hide the input method's soft input area, so the user no longer
 * sees it or can interact with it.  This can only be called
 * from the currently active input method, as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 * @deprecated Use {@link InputMethodService#requestHideSelf(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
","/**
 * Close/hide the input method's soft input area, so the user no longer
 * sees it or can interact with it.  This can only be called
 * from the currently active input method, as validated by the given token.
 *
 * @param token Supplies the identifying token given to an input method
 * when it was started, which allows it to perform this operation on
 * itself.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 * @deprecated Use {@link InputMethodService#requestHideSelf(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The body of the method has changed to call a different method (from hideSoftInputFromInputMethodInternal() to the method of an object obtained from InputMethodPrivilegedOperationsRegistry.get(token)), indicating a change in the dependent API, so the code change type is 5.","Despite the API it depends on has changed, this replacement does not indicate a change in the behavior of the method in terms of returning a value or throwing an exception because the method's signature indicates it is void and does not throw checked exceptions. Therefore, this particular change does not introduce a Compatibility Issue, and CI type is 0."
863,<android.content.ContentValues: int hashCode()>,28,29,<android.content.ContentValues: int hashCode()>,<android.content.ContentValues: int hashCode()>,0,"{
    return mValues.hashCode();
}","{
    return mMap.hashCode();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The implementation changed from using a member variable named `mValues` to another named `mMap`. This indicates that the internal representation of the data (`mValues` to `mMap`) may have changed, and it is a dependent API change, so the code change type is 5.","Changing from `mValues` to `mMap` for the hashCode computation suggests that the underlying data structure of the ContentValues object has changed. Therefore, this can lead to different hash codes being returned for the same set of content values between the two versions indicative of a change in `return` behavior, so the CI type is 1."
864,<android.content.pm.PackageInstaller: Session openSession(int)>,28,29,<android.content.pm.PackageInstaller: Session openSession(int)>,<android.content.pm.PackageInstaller: Session openSession(int)>,0,"{
    try {
        return new Session(mInstaller.openSession(sessionId));
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        try {
            return new Session(mInstaller.openSession(sessionId));
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    }
}",1,"/**
 * Open an existing session to actively perform work. To succeed, the caller
 * must be the owner of the install session.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
","/**
 * Open an existing session to actively perform work. To succeed, the caller
 * must be the owner of the install session.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when the caller does not own the session, or
 * the session is invalid.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,3,0,"The change consists only of the reordering of catch blocks for different exception types without altering the behavior of the method, so the code change type is 3.","The reordering of catch blocks does not affect the method's contract, expected exceptions, or return values, thus there is no Compatibility Issue. The method's behavior remains consistent between the two versions, as no new exceptions are thrown nor is there any change in the return type or value. The annotations also remain the same, ensuring the contract is clear and unchanged."
865,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",28,29,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>","<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",0,"{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            mSelectionStart = editor.getTextView().getSelectionStart();
            mSelectionEnd = editor.getTextView().getSelectionEnd();
            mLogger.logSelectionAction(textView.getSelectionStart(), textView.getSelectionEnd(), SelectionEvent.ACTION_RESET, null);
        }
        return selected;
    }
    return false;
}","{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            mSelectionStart = editor.getTextView().getSelectionStart();
            mSelectionEnd = editor.getTextView().getSelectionEnd();
            mLogger.logSelectionAction(textView.getSelectionStart(), textView.getSelectionEnd(), SelectionEvent.ACTION_RESET, /* actionLabel= */
            null, /* classification= */
            null);
        }
        return selected;
    }
    return false;
}",1,"/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
","/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method logSelectionAction() call in the late version has two additional comments within its parameters, but the actual arguments passed to the method and its functionality have not changed. Therefore, the code change type is 4.","The comments added to the method parameters have no effect on its execution or behavior. It is simply more information for readers or maintainers of the code. As such, there is no compatibility issue here, so the CI type is 0."
866,"<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>",28,29,"<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    if (DEBUG) {
        Slog.v(TAG, ""Got restore of "" + key);
    }
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            // TODO: http://b/22388012
            nm.applyRestore(payload, UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
        }
    }
}","{
    if (DEBUG) {
        Slog.v(TAG, ""Got restore of "" + key);
    }
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            nm.applyRestore(payload, mUserId);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The only change is the parameter passed to the applyRestore methodfrom UserHandle.USER_SYSTEM to mUserIdso the code change type is 4.,"The change doesn't lead to a Compatibility Issue as it does not impact the API's return type or value (since it's a `void` method), nor does it change the exception handling. Therefore, the CI type is 0."
867,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,28,29,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (shouldDisplayEdgeEffects()) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (shouldDisplayEdgeEffects()) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
868,<android.content.ContentResolver: void requestSync(SyncRequest)>,28,29,<android.content.ContentResolver: void requestSync(SyncRequest)>,<android.content.ContentResolver: void requestSync(SyncRequest)>,0,"{
    try {
        getContentService().sync(request);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        // Note ActivityThread.currentPackageName() may not be accurate in a shared process
        // case, but it's only for debugging.
        getContentService().sync(request, ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Register a sync with the SyncManager. These requests are built using the
 * {@link SyncRequest.Builder}.
 */
","/**
 * Register a sync with the SyncManager. These requests are built using the
 * {@link SyncRequest.Builder}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API getContentService().sync(...) has been given an additional parameter in the late version, therefore, the code change type is 4,5.","There is no Compatibility Issue detected because even though the dependent API sync has a new parameter, the method's functionality remains unchanged from a caller's perspective, and the calling conventions for requestSync have not changed. The method does not return any value, and the exception handling remains identical."
870,<android.app.KeyguardManager.KeyguardLock: void disableKeyguard()>,28,29,<android.app.KeyguardManager.KeyguardLock: void disableKeyguard()>,<android.app.KeyguardManager.KeyguardLock: void disableKeyguard()>,0,"{
    try {
        mWM.disableKeyguard(mToken, mTag);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mWM.disableKeyguard(mToken, mTag, mContext.getUserId());
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Disable the keyguard from showing.  If the keyguard is currently
 * showing, hide it.  The keyguard will be prevented from showing again
 * until {@link #reenableKeyguard()} is called.
 *
 * A good place to call this is from {@link android.app.Activity#onResume()}
 *
 * Note: This call has no effect while any {@link android.app.admin.DevicePolicyManager}
 * is enabled that requires a password.
 *
 * @see #reenableKeyguard()
 */
","/**
 * Disable the keyguard from showing.  If the keyguard is currently
 * showing, hide it.  The keyguard will be prevented from showing again
 * until {@link #reenableKeyguard()} is called.
 *
 * A good place to call this is from {@link android.app.Activity#onResume()}
 *
 * Note: This call has no effect while any {@link android.app.admin.DevicePolicyManager}
 * is enabled that requires a password.
 *
 * @see #reenableKeyguard()
 */
",-1,[@RequiresPermission(Manifest.permission.DISABLE_KEYGUARD)],[@RequiresPermission(Manifest.permission.DISABLE_KEYGUARD)],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the try block has changed to include an additional parameter, mContext.getUserId(), leading to a change type of 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue detected here based on the rules provided, as both versions catch the RemoteException and there is no change in how exceptions are handled or in the control flow that would affect return values or thrown exceptions. It is expected that the method being called (mWM.disableKeyguard) still behaves the same way with regards to exceptions and return values, only with an additional context of the user ID."
871,<android.util.Xml: XmlPullParser newPullParser()>,28,29,<android.util.Xml: XmlPullParser newPullParser()>,<android.util.Xml: XmlPullParser newPullParser()>,0,"{
    try {
        KXmlParser parser = new KXmlParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_DOCDECL, true);
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
        return parser;
    } catch (XmlPullParserException e) {
        throw new AssertionError();
    }
}","{
    try {
        XmlPullParser parser = XmlObjectFactory.newXmlPullParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_DOCDECL, true);
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
        return parser;
    } catch (XmlPullParserException e) {
        throw new AssertionError();
    }
}",1,"/**
 * Returns a new pull parser with namespace support.
 */
","/**
 * Returns a new pull parser with namespace support.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The instantiation of the parser object has changed from `new KXmlParser()` to `XmlObjectFactory.newXmlPullParser()`. Additionally, the type of the parser variable has been changed from `KXmlParser` to `XmlPullParser`. The changes relate to the instantiation and assignment statements, which is other statement change type 4. Also, since `XmlObjectFactory.newXmlPullParser()` implies a method invocation from another class `XmlObjectFactory`, it's also a dependent API change, type 5.","There is no Compatibility Issue because although the implementation changed, this does not affect the behavior observed by the callers of the `newPullParser()` method. Callers will still receive an instance of `XmlPullParser` with the same features enabled. The logic for handling `XmlPullParserException` is unchanged, so it won't cause a CI regarding different exception handlings either. Hence, the type is 0."
872,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",28,29,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mode, ""mode"");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}","{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(mode, ""mode"");
    try {
        if (mWrapped != null)
            return mWrapped.openAssetFile(uri, mode, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
873,<android.net.http.HttpResponseCache: long maxSize()>,28,29,<android.net.http.HttpResponseCache: long maxSize()>,<android.net.http.HttpResponseCache: long maxSize()>,0,"{
    return delegate.maxSize();
}","{
    return mDelegate.getMaxSize();
}",1,"/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */
","/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call changed from delegate.maxSize() to mDelegate.getMaxSize(), which indicates a change in the way the maximum size is accessed, likely through a different variable or method. This is an ""Other statement changed"" (4) and a ""Dependent API changed"" (5).","There is no compatibility issue detected as both method calls are intended to retrieve the maximum size value of the cache. The difference in method names indicates a change in implementation detail, which should not affect the overall behavior from the perspective of the API user, provided that both methods correctly return the cache's maximum size. Thus, there should be no CI regarding the values returned by the API."
874,"<android.view.WindowInsets: WindowInsets replaceSystemWindowInsets(int,int,int,int)>",28,29,"<android.view.WindowInsets: WindowInsets replaceSystemWindowInsets(int,int,int,int)>","<android.view.WindowInsets: WindowInsets replaceSystemWindowInsets(int,int,int,int)>",0,"{
    final WindowInsets result = new WindowInsets(this);
    result.mSystemWindowInsets = new Rect(left, top, right, bottom);
    return result;
}","{
    // The behavior is now keeping them consumed and discarding the new insets.
    if (mSystemWindowInsetsConsumed) {
        return this;
    }
    return new Builder(this).setSystemWindowInsets(Insets.of(left, top, right, bottom)).build();
}",1,"/**
 * Returns a copy of this WindowInsets with selected system window insets replaced
 * with new values.
 *
 * @param left New left inset in pixels
 * @param top New top inset in pixels
 * @param right New right inset in pixels
 * @param bottom New bottom inset in pixels
 * @return A modified copy of this WindowInsets
 */
","/**
 * Returns a copy of this WindowInsets with selected system window insets replaced
 * with new values.
 *
 * <p>Note: If the system window insets are already consumed, this method will return them
 * unchanged on {@link android.os.Build.VERSION_CODES#Q Q} and later. Prior to
 * {@link android.os.Build.VERSION_CODES#Q Q}, the new values were applied regardless of
 * whether they were consumed, and this method returns invalid non-zero consumed insets.
 *
 * @param left New left inset in pixels
 * @param top New top inset in pixels
 * @param right New right inset in pixels
 * @param bottom New bottom inset in pixels
 * @return A modified copy of this WindowInsets
 * @deprecated use {@code Builder#Builder(WindowInsets)} with
 * {@link Builder#setSystemWindowInsets(Insets)} instead.
 */
",-1,,"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement has been completely changed. There is now a new condition checking if `mSystemWindowInsetsConsumed` is true, and if so, it returns `this` instead of creating a new instance. Additionally, the new implementation uses a `new Builder(this)` with chained methods `setSystemWindowInsets` and `build()` to achieve the prior result, and a new field `mSystemWindowInsetsConsumed` is introduced which represents a Dependent API change. All of these make the code change type 1,3,5.","The change in the return statement can lead to a situation where the late version API may return the current instance (`this`) instead of a new one with replaced insets, this represents a potential return value change and thus the CI type is 1."
876,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,28,29,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,<android.view.inputmethod.InputMethodManager: void restartInput(View)>,0,"{
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(InputMethodClient.START_INPUT_REASON_APP_CALLED_RESTART_INPUT_API, null, 0, 0, 0);
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.restartInput(view);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) {
            return;
        }
        mServedConnecting = true;
    }
    startInputInner(StartInputReason.APP_CALLED_RESTART_INPUT_API, null, 0, 0, 0);
}",1,"/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
","/**
 * If the input method is currently connected to the given view,
 * restart it with its new contents.  You should call this when the text
 * within your view changes outside of the normal input method or key
 * input flow, such as when an application calls TextView.setText().
 *
 * @param view The view whose text has changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version of the API has a new control statement that checks for a context mismatch and calls a fallback method, leading to a potential different behavior if the new block is executed. Additionally, there is a minor change in the argument `InputMethodClient.START_INPUT_REASON_APP_CALLED_RESTART_INPUT_API` which has been changed to `StartInputReason.APP_CALLED_RESTART_INPUT_API`. This could reflect either a class name change or a constant being moved to another class. Therefore, the code changes include a new control structure (3), a method or constant being accessed differently (4), and a changed return point due to the new early return (1).","The added block of code with its new return statement can lead to an early exit from the method, causing it to potentially return at a different point than the earlier implementation. This constitutes a different return behavior (1). There's no change in exception handling, so this would not be a compatibility issue in terms of exception handling (2)."
877,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,28,29,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,0,"{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false);
        } else {
            id = view.getAutofillId();
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true);
                } else {
                    view.setAutofilled(false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false);
            }
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        if (id == null) {
            id = view.getAutofillId();
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false);
        } else {
            id = view.getAutofillId();
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true);
                } else {
                    view.setAutofilled(false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false);
            }
        }
        if (mForAugmentedAutofillOnly) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged(): not notifying system server on "" + ""augmented-only mode"");
            }
            return;
        }
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        if (id == null) {
            id = view.getAutofillId();
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}",1,"/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
","/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The control dependency has changed with the condition from `if (!mEnabled || !isActiveLocked())` to `if (mForAugmentedAutofillOnly)` being added before checking `mEnabled` and `isActiveLocked()`. This is identified as a Control dependency change.,"The modification introduces an additional return path before reaching the previous control statements that could disable the autofill update (`if (!mEnabled || !isActiveLocked())`). However, it doesn't directly cause a change in return type or exceptions thrown but only determines whether the system server should be notified. Since this would not alter the behaviour of the method itself from the perspective of its contract (going by the assumption that `mForAugmentedAutofillOnly` is an internal state and not part of the method's contract), there is No Compatibility Issue."
878,"<android.view.RoundScrollbarRenderer: void drawRoundScrollbars(Canvas,float,Rect)>",28,29,"<android.view.RoundScrollbarRenderer: void drawRoundScrollbars(Canvas,float,Rect)>","<android.view.RoundScrollbarRenderer: void drawRoundScrollbars(Canvas,float,Rect)>",0,"{
    if (alpha == 0) {
        return;
    }
    // Get information about the current scroll state of the parent view.
    float maxScroll = mParent.computeVerticalScrollRange();
    float scrollExtent = mParent.computeVerticalScrollExtent();
    if (scrollExtent <= 0 || maxScroll <= scrollExtent) {
        return;
    }
    float currentScroll = Math.max(0, mParent.computeVerticalScrollOffset());
    float linearThumbLength = mParent.computeVerticalScrollExtent();
    float thumbWidth = mParent.getWidth() * WIDTH_PERCENTAGE;
    mThumbPaint.setStrokeWidth(thumbWidth);
    mTrackPaint.setStrokeWidth(thumbWidth);
    setThumbColor(applyAlpha(DEFAULT_THUMB_COLOR, alpha));
    setTrackColor(applyAlpha(DEFAULT_TRACK_COLOR, alpha));
    // Normalize the sweep angle for the scroll bar.
    float sweepAngle = (linearThumbLength / maxScroll) * SCROLLBAR_ANGLE_RANGE;
    sweepAngle = clamp(sweepAngle, MIN_SCROLLBAR_ANGLE_SWIPE, MAX_SCROLLBAR_ANGLE_SWIPE);
    // Normalize the start angle so that it falls on the track.
    float startAngle = (currentScroll * (SCROLLBAR_ANGLE_RANGE - sweepAngle)) / (maxScroll - linearThumbLength) - SCROLLBAR_ANGLE_RANGE / 2;
    startAngle = clamp(startAngle, -SCROLLBAR_ANGLE_RANGE / 2, SCROLLBAR_ANGLE_RANGE / 2 - sweepAngle);
    // Draw the track and the scroll bar.
    mRect.set(bounds.left - thumbWidth / 2, bounds.top, bounds.right - thumbWidth / 2, bounds.bottom);
    canvas.drawArc(mRect, -SCROLLBAR_ANGLE_RANGE / 2, SCROLLBAR_ANGLE_RANGE, false, mTrackPaint);
    canvas.drawArc(mRect, startAngle, sweepAngle, false, mThumbPaint);
}","{
    if (alpha == 0) {
        return;
    }
    // Get information about the current scroll state of the parent view.
    float maxScroll = mParent.computeVerticalScrollRange();
    float scrollExtent = mParent.computeVerticalScrollExtent();
    if (scrollExtent <= 0 || maxScroll <= scrollExtent) {
        return;
    }
    float currentScroll = Math.max(0, mParent.computeVerticalScrollOffset());
    float linearThumbLength = mParent.computeVerticalScrollExtent();
    float thumbWidth = mParent.getWidth() * WIDTH_PERCENTAGE;
    mThumbPaint.setStrokeWidth(thumbWidth);
    mTrackPaint.setStrokeWidth(thumbWidth);
    setThumbColor(applyAlpha(DEFAULT_THUMB_COLOR, alpha));
    setTrackColor(applyAlpha(DEFAULT_TRACK_COLOR, alpha));
    // Normalize the sweep angle for the scroll bar.
    float sweepAngle = (linearThumbLength / maxScroll) * SCROLLBAR_ANGLE_RANGE;
    sweepAngle = clamp(sweepAngle, MIN_SCROLLBAR_ANGLE_SWIPE, MAX_SCROLLBAR_ANGLE_SWIPE);
    // Normalize the start angle so that it falls on the track.
    float startAngle = (currentScroll * (SCROLLBAR_ANGLE_RANGE - sweepAngle)) / (maxScroll - linearThumbLength) - SCROLLBAR_ANGLE_RANGE / 2;
    startAngle = clamp(startAngle, -SCROLLBAR_ANGLE_RANGE / 2, SCROLLBAR_ANGLE_RANGE / 2 - sweepAngle);
    // Draw the track and the thumb.
    float inset = thumbWidth / 2 + mMaskThickness;
    mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
    canvas.drawArc(mRect, -SCROLLBAR_ANGLE_RANGE / 2, SCROLLBAR_ANGLE_RANGE, false, mTrackPaint);
    canvas.drawArc(mRect, startAngle, sweepAngle, false, mThumbPaint);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code changes involve the modification of the `mRect.set()` parameters where the `inset` calculation for the bounds has been added. However, the semantics of the drawing operation remains the same.","There is no Compatibility Issue as the modified `mRect.set()` call still configures the bounds for drawing in the same `canvas.drawArc()` operations with the same start and sweep angles, just with different bounds adjusted by `inset`. The behavior of drawing the round scrollbars does not fundamentally change."
879,"<android.service.autofill.UserData.Builder: Builder add(String,String)>",28,29,"<android.service.autofill.UserData.Builder: Builder add(String,String)>","<android.service.autofill.UserData.Builder: Builder add(String,String)>",0,"{
    throwIfDestroyed();
    checkNotEmpty(""categoryId"", categoryId);
    checkValidValue(value);
    if (!mUniqueCategoryIds.contains(categoryId)) {
        // New category - check size
        Preconditions.checkState(mUniqueCategoryIds.size() < getMaxCategoryCount(), ""already added "" + mUniqueCategoryIds.size() + "" unique category ids"");
    }
    Preconditions.checkState(!mValues.contains(value), // Don't include value on message because it could contain PII
    ""already has entry with same value"");
    Preconditions.checkState(mValues.size() < getMaxUserDataSize(), ""already added "" + mValues.size() + "" elements"");
    addMapping(value, categoryId);
    return this;
}","{
    throwIfDestroyed();
    checkNotEmpty(""categoryId"", categoryId);
    checkValidValue(value);
    if (!mUniqueCategoryIds.contains(categoryId)) {
        // New category - check size
        Preconditions.checkState(mUniqueCategoryIds.size() < getMaxCategoryCount(), ""already added "" + mUniqueCategoryIds.size() + "" unique category ids"");
    }
    Preconditions.checkState(mValues.size() < getMaxUserDataSize(), ""already added "" + mValues.size() + "" elements"");
    addMapping(value, categoryId);
    return this;
}",1,"/**
 * Adds a new value for user data.
 *
 * @param value value of the user data.
 * @param categoryId string used to identify the category the value is associated with.
 *
 * @throws IllegalStateException if:
 * <ul>
 * <li>{@link #build()} already called</li>
 * <li>the {@code value} has already been added</li>
 * <li>the number of unique {@code categoryId} values added so far is more than
 * {@link UserData#getMaxCategoryCount()}</li>
 * <li>the number of {@code values} added so far is is more than
 * {@link UserData#getMaxUserDataSize()}</li>
 * </ul>
 *
 * @throws IllegalArgumentException if any of the following occurs:
 * <ul>
 * <li>{@code id} is empty</li>
 * <li>{@code categoryId} is empty</li>
 * <li>{@code value} is empty</li>
 * <li>the length of {@code value} is lower than {@link UserData#getMinValueLength()}</li>
 * <li>the length of {@code value} is higher than
 * {@link UserData#getMaxValueLength()}</li>
 * </ul>
 */
","/**
 * Adds a new value for user data.
 *
 * @param value value of the user data.
 * @param categoryId string used to identify the category the value is associated with.
 *
 * @throws IllegalStateException if:
 * <ul>
 * <li>{@link #build()} already called</li>
 * <li>the {@code value} has already been added (<b>Note: </b> this restriction was
 * lifted on Android {@link android.os.Build.VERSION_CODES#Q} and later)</li>
 * <li>the number of unique {@code categoryId} values added so far is more than
 * {@link UserData#getMaxCategoryCount()}</li>
 * <li>the number of {@code values} added so far is is more than
 * {@link UserData#getMaxUserDataSize()}</li>
 * </ul>
 *
 * @throws IllegalArgumentException if any of the following occurs:
 * <ul>
 * <li>{@code id} is empty</li>
 * <li>{@code categoryId} is empty</li>
 * <li>{@code value} is empty</li>
 * <li>the length of {@code value} is lower than {@link UserData#getMinValueLength()}</li>
 * <li>the length of {@code value} is higher than
 * {@link UserData#getMaxValueLength()}</li>
 * </ul>
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The condition check for whether the value already exists in mValues is removed in the Late_Version, which is represented as other statement changed. Therefore, the code change type is 4.","The removal of an existing check (Preconditions.checkState(!mValues.contains(value))) means that the behavior related to detecting duplicate values will no longer occur, but since the method's contract does not seem to guarantee anything regarding duplicate handling, this code change likely does not create a compatibility issue as it should not affect the return type or value. Thus the CI type is 0."
880,<android.view.View: String toString()>,28,29,<android.view.View: String toString()>,<android.view.View: String toString()>,0,"{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id > 0 && Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    out.append(""}"");
    return out.toString();
}","{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id > 0 && Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    if (mAutofillId != null) {
        out.append("" aid="");
        out.append(mAutofillId);
    }
    out.append(""}"");
    return out.toString();
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,,,,
882,<android.app.ActivityThread.GcIdler: boolean queueIdle()>,28,29,<android.app.ActivityThread.GcIdler: boolean queueIdle()>,<android.app.ActivityThread.GcIdler: boolean queueIdle()>,0,"{
    doGcIfNeeded();
    return false;
}","{
    doGcIfNeeded();
    purgePendingResources();
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional method call to purgePendingResources() is introduced in the late implementation, which is neither a return statement change, exception handling change, nor a control dependency change. So the code change type is 4.","Since only an extra method (purgePendingResources()) is being called that does not alter the method's return type or value and does not introduce a new exception handling, there is no compatibility issue. The API method's final return value remains 'false' as before, and no new exceptions are thrown that would be visible to the callers of the method. The type is 0."
883,<android.content.ContentValues: Short getAsShort(String)>,28,29,<android.content.ContentValues: Short getAsShort(String)>,<android.content.ContentValues: Short getAsShort(String)>,0,"{
    Object value = mValues.get(key);
    try {
        return value != null ? ((Number) value).shortValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Short.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Short value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Short: "" + value, e);
            return null;
        }
    }
}","{
    Object value = mMap.get(key);
    try {
        return value != null ? ((Number) value).shortValue() : null;
    } catch (ClassCastException e) {
        if (value instanceof CharSequence) {
            try {
                return Short.valueOf(value.toString());
            } catch (NumberFormatException e2) {
                Log.e(TAG, ""Cannot parse Short value for "" + value + "" at key "" + key);
                return null;
            }
        } else {
            Log.e(TAG, ""Cannot cast value for "" + key + "" to a Short: "" + value, e);
            return null;
        }
    }
}",1,"/**
 * Gets a value and converts it to a Short.
 *
 * @param key the value to get
 * @return the Short value, or {@code null} if the value is missing or cannot be converted
 */
","/**
 * Gets a value and converts it to a Short.
 *
 * @param key the value to get
 * @return the Short value, or {@code null} if the value is missing or cannot be converted
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is from mValues.get(key) to mMap.get(key); this indicates a change in an internal data structure from mValues to mMap, so the code change type is 4 and 5.","Despite the data structure name change, there is no behavioral change indicated by the method signature and implementation that would cause a difference in returned values or exception handling. Therefore, there's no Compatibility Issue and the CI type is 0."
884,<android.hardware.usb.UsbAccessory: String toString()>,28,29,<android.hardware.usb.UsbAccessory: String toString()>,<android.hardware.usb.UsbAccessory: String toString()>,0,"{
    return ""UsbAccessory[mManufacturer="" + mManufacturer + "", mModel="" + mModel + "", mDescription="" + mDescription + "", mVersion="" + mVersion + "", mUri="" + mUri + "", mSerial="" + mSerial + ""]"";
}","{
    return ""UsbAccessory[mManufacturer="" + mManufacturer + "", mModel="" + mModel + "", mDescription="" + mDescription + "", mVersion="" + mVersion + "", mUri="" + mUri + "", mSerialNumberReader="" + mSerialNumberReader + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement is modified from referring to mSerial to referring to mSerialNumberReader, which indicates a change in the property that the toString() method is returning. This constitutes a change of type 1. There is also a part of the implementation that has changed but it is not a control dependency, exception handling, or a dependent API, so it's an ""Other statement changed,"" which is of type 4.","As the API potentially returns a different value in the late version due to the change in the property included in the toString() result, the CI type is 1."
885,<android.app.KeyguardManager: boolean isKeyguardSecure()>,28,29,<android.app.KeyguardManager: boolean isKeyguardSecure()>,<android.app.KeyguardManager: boolean isKeyguardSecure()>,0,"{
    try {
        return mWM.isKeyguardSecure();
    } catch (RemoteException ex) {
        return false;
    }
}","{
    try {
        return mWM.isKeyguardSecure(mContext.getUserId());
    } catch (RemoteException ex) {
        return false;
    }
}",1,"/**
 * Return whether the keyguard is secured by a PIN, pattern or password or a SIM card
 * is currently locked.
 *
 * <p>See also {@link #isDeviceSecure()} which ignores SIM locked states.
 *
 * @return true if a PIN, pattern or password is set or a SIM card is locked.
 */
","/**
 * Return whether the keyguard is secured by a PIN, pattern or password or a SIM card
 * is currently locked.
 *
 * <p>See also {@link #isDeviceSecure()} which ignores SIM locked states.
 *
 * @return true if a PIN, pattern or password is set or a SIM card is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the code is the addition of `mContext.getUserId()` as a parameter to the `isKeyguardSecure()` method call, so the code change types are 4 and 5 as this is a change in the method call parameters but not a structural change to control flow or exception handling.","Although there is a change in the method call parameters, since `isKeyguardSecure()` method always returns a boolean and the catch block remains the same, returning `false` on a `RemoteException`, there is no Compatibility Issue with respect to return types or exception handling. Thus, there is no CI in terms of different return values or types or different exceptions being thrown."
888,<android.os.PowerManager: void wakeUp(long)>,28,29,<android.os.PowerManager: void wakeUp(long)>,<android.os.PowerManager: void wakeUp(long)>,0,"{
    try {
        mService.wakeUp(time, ""wakeUp"", mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    wakeUp(time, WAKE_REASON_UNKNOWN, ""wakeUp"");
}",1,"/**
 * Forces the device to wake up from sleep.
 * <p>
 * If the device is currently asleep, wakes it up, otherwise does nothing.
 * This is what happens when the power key is pressed to turn on the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to wake up was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the wake up request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to wake up.
 *
 * @see #userActivity
 * @see #goToSleep
 *
 * @removed Requires signature permission.
 */
","/**
 * Forces the device to wake up from sleep.
 * <p>
 * If the device is currently asleep, wakes it up, otherwise does nothing.
 * This is what happens when the power key is pressed to turn on the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to wake up was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the wake up request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to wake up.
 *
 * @see #userActivity
 * @see #goToSleep
 *
 * @deprecated Use {@link #wakeUp(long, int, String)} instead.
 * @removed Requires signature permission.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The method invocation within the `wakeUp` method has been changed from directly dealing with `mService.wakeUp` to calling another overload of the `wakeUp` method. This indicates that the implementation is now relying on a different API (the overload of `wakeUp`), which is classified as a dependent API change, thus the code change type is 5.","There is no compatibility issue detected in this case. Despite the implementation using a different method overload, which could indicate a dependent API change, there are no changes in the method signature or the exposed behavior from the perspective of the caller of `wakeUp(long)`. Thus, it can be assumed that the additional methods and internal re-routing maintain the same functionality and public contract, leading to no compatibility issue (type 0)."
889,<android.view.inputmethod.InputMethodManager: boolean setCurrentInputMethodSubtype(InputMethodSubtype)>,28,29,<android.view.inputmethod.InputMethodManager: boolean setCurrentInputMethodSubtype(InputMethodSubtype)>,<android.view.inputmethod.InputMethodManager: boolean setCurrentInputMethodSubtype(InputMethodSubtype)>,0,"{
    synchronized (mH) {
        try {
            return mService.setCurrentInputMethodSubtype(subtype);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    if (Process.myUid() == Process.SYSTEM_UID) {
        Log.w(TAG, ""System process should not call setCurrentInputMethodSubtype() because "" + ""almost always it is a bug under multi-user / multi-profile environment. "" + ""Consider directly interacting with InputMethodManagerService "" + ""via LocalServices."");
        return false;
    }
    if (subtype == null) {
        // See the JavaDoc. This is how this method has worked.
        return false;
    }
    final Context fallbackContext = ActivityThread.currentApplication();
    if (fallbackContext == null) {
        return false;
    }
    if (fallbackContext.checkSelfPermission(WRITE_SECURE_SETTINGS) != PackageManager.PERMISSION_GRANTED) {
        return false;
    }
    final ContentResolver contentResolver = fallbackContext.getContentResolver();
    final String imeId = Settings.Secure.getString(contentResolver, Settings.Secure.DEFAULT_INPUT_METHOD);
    if (ComponentName.unflattenFromString(imeId) == null) {
        // Null or invalid IME ID format.
        return false;
    }
    final List<InputMethodSubtype> enabledSubtypes;
    try {
        enabledSubtypes = mService.getEnabledInputMethodSubtypeList(imeId, true);
    } catch (RemoteException e) {
        return false;
    }
    final int numSubtypes = enabledSubtypes.size();
    for (int i = 0; i < numSubtypes; ++i) {
        final InputMethodSubtype enabledSubtype = enabledSubtypes.get(i);
        if (enabledSubtype.equals(subtype)) {
            Settings.Secure.putInt(contentResolver, Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE, enabledSubtype.hashCode());
            return true;
        }
    }
    return false;
}",1,"/**
 * Switch to a new input method subtype of the current input method.
 * @param subtype A new input method subtype to switch.
 * @return true if the current subtype was successfully switched. When the specified subtype is
 * null, this method returns false.
 */
","/**
 * Switch to a new input method subtype of the current input method.
 * @param subtype A new input method subtype to switch.
 * @return true if the current subtype was successfully switched. When the specified subtype is
 * null, this method returns false.
 * @deprecated If the calling process is an IME, use
 * {@link InputMethodService#switchInputMethod(String, InputMethodSubtype)}, which
 * does not require any permission as long as the caller is the current IME.
 * If the calling process is some privileged app that already has
 * {@link android.Manifest.permission#WRITE_SECURE_SETTINGS} permission, just
 * directly update {@link Settings.Secure#SELECTED_INPUT_METHOD_SUBTYPE}.
 */
",-1,[@RequiresPermission(WRITE_SECURE_SETTINGS)],"[@Deprecated, @RequiresPermission(WRITE_SECURE_SETTINGS)]",-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The control flow in the early version is very straightforward, with a try-catch block wrapping a call to mService.setCurrentInputMethodSubtype(subtype). In the late version, the control flow has been significantly altered to introduce new permission checks, process identity checks, and additional logic before attempting to set the input method subtype. New return statements with constant values and additional dependencies on the Process, Log, PackageManager, ContentResolver, Settings, and List classes have been introduced, making the changes fall into the categories 1,3,4,5.","The late implementation introduces several situations where different return values are given (e.g., return false under various conditions before reaching the original logic), and the permission check may throw a SecurityException if the permission is not granted. As the early version has no such return statements or permission checks that would cause method exit before attempting to set the subtype, this results in a CI both because return values could be different, as well as different exceptions thrown (not caught in the new version), reflecting the CI types 1,2."
890,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",28,29,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), getUser());
}","{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, null, mMainThread.getHandler(), null, getUser());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method bindServiceCommon() now takes additional parameters (null before mMainThread.getHandler() and null as the second to last parameter), so the types of changes are 1 and 5.","Because bindServiceCommon() now takes additional parameters, the behavior of the API could potentially change depending on the implementation of bindServiceCommon(). Therefore, the CI type is 1 caused by the potential different return value."
893,<android.net.Network: boolean equals(Object)>,28,29,<android.net.Network: boolean equals(Object)>,<android.net.Network: boolean equals(Object)>,0,"{
    if (obj instanceof Network == false)
        return false;
    Network other = (Network) obj;
    return this.netId == other.netId;
}","{
    if (!(obj instanceof Network))
        return false;
    Network other = (Network) obj;
    return this.netId == other.netId;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no actual change in functionality; the `if` statement condition has simply been rewritten in a semantically equivalent but syntactically different way.,There is no Compatibility Issue in this change because the behavior of the API remains the same. The change does not affect the return value or the exceptions thrown by the method.
894,"<android.os.Message: void writeToParcel(Parcel,int)>",28,29,"<android.os.Message: void writeToParcel(Parcel,int)>","<android.os.Message: void writeToParcel(Parcel,int)>",0,"{
    if (callback != null) {
        throw new RuntimeException(""Can't marshal callbacks across processes."");
    }
    dest.writeInt(what);
    dest.writeInt(arg1);
    dest.writeInt(arg2);
    if (obj != null) {
        try {
            Parcelable p = (Parcelable) obj;
            dest.writeInt(1);
            dest.writeParcelable(p, flags);
        } catch (ClassCastException e) {
            throw new RuntimeException(""Can't marshal non-Parcelable objects across processes."");
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeLong(when);
    dest.writeBundle(data);
    Messenger.writeMessengerOrNullToParcel(replyTo, dest);
    dest.writeInt(sendingUid);
}","{
    if (callback != null) {
        throw new RuntimeException(""Can't marshal callbacks across processes."");
    }
    dest.writeInt(what);
    dest.writeInt(arg1);
    dest.writeInt(arg2);
    if (obj != null) {
        try {
            Parcelable p = (Parcelable) obj;
            dest.writeInt(1);
            dest.writeParcelable(p, flags);
        } catch (ClassCastException e) {
            throw new RuntimeException(""Can't marshal non-Parcelable objects across processes."");
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeLong(when);
    dest.writeBundle(data);
    Messenger.writeMessengerOrNullToParcel(replyTo, dest);
    dest.writeInt(sendingUid);
    dest.writeInt(workSourceUid);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change is the introduction of a new statement: dest.writeInt(workSourceUid); so the code change type is 4.,"No Compatibility Issue arises from this change because it is an addition of data being written to the Parcel that is likely meant to include new information for future use; it does not alter the behavior of existing code or change the way data is read from the Parcel. Existing clients will remain unaffected by this additional write operation, thus there is no CI."
895,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,28,29,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,<android.app.NotificationManager: StatusBarNotification[] getActiveNotifications()>,0,"{
    final INotificationManager service = getService();
    final String pkg = mContext.getPackageName();
    try {
        final ParceledListSlice<StatusBarNotification> parceledList = service.getAppActiveNotifications(pkg, mContext.getUserId());
        final List<StatusBarNotification> list = parceledList.getList();
        return list.toArray(new StatusBarNotification[list.size()]);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    final INotificationManager service = getService();
    final String pkg = mContext.getPackageName();
    try {
        final ParceledListSlice<StatusBarNotification> parceledList = service.getAppActiveNotifications(pkg, mContext.getUserId());
        if (parceledList != null) {
            final List<StatusBarNotification> list = parceledList.getList();
            return list.toArray(new StatusBarNotification[list.size()]);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return new StatusBarNotification[0];
}",1,"/**
 * Recover a list of active notifications: ones that have been posted by the calling app that
 * have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.
 *
 * Each notification is embedded in a {@link StatusBarNotification} object, including the
 * original <code>tag</code> and <code>id</code> supplied to
 * {@link #notify(String, int, Notification) notify()}
 * (via {@link StatusBarNotification#getTag() getTag()} and
 * {@link StatusBarNotification#getId() getId()}) as well as a copy of the original
 * {@link Notification} object (via {@link StatusBarNotification#getNotification()}).
 *
 * @return An array of {@link StatusBarNotification}.
 */
","/**
 * Recover a list of active notifications: ones that have been posted by the calling app that
 * have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.
 *
 * <p><Each notification is embedded in a {@link StatusBarNotification} object, including the
 * original <code>tag</code> and <code>id</code> supplied to
 * {@link #notify(String, int, Notification) notify()}
 * (via {@link StatusBarNotification#getTag() getTag()} and
 * {@link StatusBarNotification#getId() getId()}) as well as a copy of the original
 * {@link Notification} object (via {@link StatusBarNotification#getNotification()}).
 * </p>
 * <p>From {@link Build.VERSION_CODES#Q}, will also return notifications you've posted as an
 * app's notification delegate via
 * {@link NotificationManager#notifyAsPackage(String, String, int, Notification)}.
 * </p>
 *
 * @return An array of {@link StatusBarNotification}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new null check for `parceledList` and a return statement returning an empty array has been introduced in the late version, thus resulting in the change type 1,3.","The late version of the API includes a check to see if `parceledList` is null, in which case it will return an empty StatusBarNotification array. This adds a new branch that could return a different value (an empty array), compared to the early version, which could throw a NullPointerException in a similar scenario. Hence, the API behavior has potentially changed, resulting in the CI type 1."
896,<android.service.carrier.CarrierIdentifier: int hashCode()>,28,29,<android.service.carrier.CarrierIdentifier: int hashCode()>,<android.service.carrier.CarrierIdentifier: int hashCode()>,0,"{
    int result = 1;
    result = 31 * result + Objects.hashCode(mMcc);
    result = 31 * result + Objects.hashCode(mMnc);
    result = 31 * result + Objects.hashCode(mSpn);
    result = 31 * result + Objects.hashCode(mImsi);
    result = 31 * result + Objects.hashCode(mGid1);
    result = 31 * result + Objects.hashCode(mGid2);
    return result;
}","{
    return Objects.hash(mMcc, mMnc, mSpn, mImsi, mGid1, mGid2, mCarrierId, mSpecificCarrierId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode() method implementation has been changed from manual calculation of the hash to using the Objects.hash() method including additional fields mCarrierId, mSpecificCarrierId which are not included in the early version. This constitutes a change in the method return statement and the algorithm used to calculate the hash value (statement change), so the code change type is 1,4.","The change in the implementation of hashCode() method will lead to a different hash value being returned, so the CI type is 1."
897,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,28,29,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,0,"{
    return batteryLevel == o.batteryLevel && batteryStatus == o.batteryStatus && batteryHealth == o.batteryHealth && batteryPlugType == o.batteryPlugType && batteryTemperature == o.batteryTemperature && batteryVoltage == o.batteryVoltage && batteryChargeUAh == o.batteryChargeUAh && states == o.states && states2 == o.states2 && currentTime == o.currentTime;
}","{
    return batteryLevel == o.batteryLevel && batteryStatus == o.batteryStatus && batteryHealth == o.batteryHealth && batteryPlugType == o.batteryPlugType && batteryTemperature == o.batteryTemperature && batteryVoltage == o.batteryVoltage && batteryChargeUAh == o.batteryChargeUAh && modemRailChargeMah == o.modemRailChargeMah && wifiRailChargeMah == o.wifiRailChargeMah && states == o.states && states2 == o.states2 && currentTime == o.currentTime;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Two new conditions have been added to the return statement (modemRailChargeMah == o.modemRailChargeMah and wifiRailChargeMah == o.wifiRailChargeMah), which constitutes a change in the return statement and an other statement change, so the code change type is 1,4.","The addition of new conditions in the return statement means that the method could potentially return a different value if either modemRailChargeMah or wifiRailChargeMah do not match. Hence, the CI type is 1."
898,<android.app.Activity: boolean showAssist(Bundle)>,28,29,<android.app.Activity: boolean showAssist(Bundle)>,<android.app.Activity: boolean showAssist(Bundle)>,0,"{
    try {
        return ActivityManager.getService().showAssistFromActivity(mToken, args);
    } catch (RemoteException e) {
    }
    return false;
}","{
    try {
        return ActivityTaskManager.getService().showAssistFromActivity(mToken, args);
    } catch (RemoteException e) {
    }
    return false;
}",1,"/**
 * Ask to have the current assistant shown to the user.  This only works if the calling
 * activity is the current foreground activity.  It is the same as calling
 * {@link android.service.voice.VoiceInteractionService#showSession
 * VoiceInteractionService.showSession} and requesting all of the possible context.
 * The receiver will always see
 * {@link android.service.voice.VoiceInteractionSession#SHOW_SOURCE_APPLICATION} set.
 * @return Returns true if the assistant was successfully invoked, else false.  For example
 * false will be returned if the caller is not the current top activity.
 */
","/**
 * Ask to have the current assistant shown to the user.  This only works if the calling
 * activity is the current foreground activity.  It is the same as calling
 * {@link android.service.voice.VoiceInteractionService#showSession
 * VoiceInteractionService.showSession} and requesting all of the possible context.
 * The receiver will always see
 * {@link android.service.voice.VoiceInteractionSession#SHOW_SOURCE_APPLICATION} set.
 * @return Returns true if the assistant was successfully invoked, else false.  For example
 * false will be returned if the caller is not the current top activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from using ActivityManager.getService() to ActivityTaskManager.getService(). There is no change in control flow or exception handling, hence the code change type is 5 (Dependent API changed).","Despite the API used to show the assist functionality has changed, the method signature, exception handling, return type, and returned value in case of success or RemoteException remain the same. No compatibility issue is introduced by this change."
899,<android.bluetooth.BluetoothHidDevice: boolean disconnect(BluetoothDevice)>,28,29,<android.bluetooth.BluetoothHidDevice: boolean disconnect(BluetoothDevice)>,<android.bluetooth.BluetoothHidDevice: boolean disconnect(BluetoothDevice)>,0,"{
    boolean result = false;
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            result = service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Disconnects from currently connected host. The connection state should be tracked by the
 * application by handling callback from Callback#onConnectionStateChanged. The connection state
 * is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Disconnects from currently connected host. The connection state should be tracked by the
 * application by handling callback from Callback#onConnectionStateChanged. The connection state
 * is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method call within the assignment of 'service' variable has changed from 'mService' to 'getService()', indicating that a dependent API 'getService()' is being used in the late version instead of directly accessing a field 'mService'. This is a change in the code but not in the behavior, so the change type is 5.","There is no Compatibility Issue as the method 'getService()' retrieves the service the same way 'mService' presumably did. Assuming 'getService()' is correctly implemented, it should not cause the API to return different values or to throw different exceptions, so the CI type is 0."
900,<android.provider.MediaStore.Audio.Media: Uri getContentUri(String)>,28,29,<android.provider.MediaStore.Audio.Media: Uri getContentUri(String)>,<android.provider.MediaStore.Audio.Media: Uri getContentUri(String)>,0,"{
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + ""/audio/media"");
}","{
    return AUTHORITY_URI.buildUpon().appendPath(volumeName).appendPath(""audio"").appendPath(""media"").build();
}",1,"/**
 * Get the content:// style URI for the audio media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio media table on the given volume
 */
","/**
 * Get the content:// style URI for the audio media table on the
 * given volume.
 *
 * @param volumeName the name of the volume to get the URI for
 * @return the URI to the audio media table on the given volume
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed from using Uri.parse() to using a Uri.Builder with chained appendPath() and build() methods. This change is classified as 4, which is 'Other statement changed'.","Even though the code implementation is different, both methods are expected to return the same Uri for the same input, meaning that the behavior has not changed. Therefore, there is no Compatibility Issue, indicated by 0."
901,"<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options)>",28,29,"<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options)>","<android.provider.MediaStore.Video.Thumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options)>",0,"{
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}","{
    return getThumbnail(cr, videoId, kind, options);
}",1,"/**
 * This method checks if the thumbnails of the specified image (origId) has been created.
 * It will be blocked until the thumbnails are generated.
 *
 * @param cr ContentResolver used to dispatch queries to MediaProvider.
 * @param origId Original image id associated with thumbnail of interest.
 * @param groupId the id of group to which this request belongs
 * @param kind The type of thumbnail to fetch. Should be either MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @return A Bitmap instance. It could be null if the original image associated with
 * origId doesn't exist or memory is not enough.
 */
","/**
 * Return thumbnail representing a specific video item. If a
 * thumbnail doesn't exist, this method will block until it's
 * generated. Callers are responsible for their own in-memory
 * caching of returned values.
 *
 * @param videoId the video item to obtain a thumbnail for.
 * @param kind optimal thumbnail size desired.
 * @return decoded thumbnail, or {@code null} if problem was
 * encountered.
 * @deprecated Callers should migrate to using
 * {@link ContentResolver#loadThumbnail}, since it
 * offers richer control over requested thumbnail sizes
 * and cancellation behavior.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed with a different dependent method call along with the change in number of parameters passed to it, so the code change type is 1,5.","The dependent API call in the return statement has changed, leading the API to potentially return different bitmap objects. The late version also has fewer parameters, which means the invocation of this method might not consider the 'groupId' parameter as in the early version. Therefore, there is a CI caused by potential different return values or types, so CI type is 1."
902,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",28,29,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>","<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",0,"{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (Binder.CHECK_PARCEL_SIZE && total > 20 * 1024) {
        Slog.d(""Error"", ""ERR: exClass="" + exceptionClassName);
        Slog.d(""Error"", ""ERR: exMsg="" + exceptionMessage);
        Slog.d(""Error"", ""ERR: file="" + throwFileName);
        Slog.d(""Error"", ""ERR: class="" + throwClassName);
        Slog.d(""Error"", ""ERR: method="" + throwMethodName + "" line="" + throwLineNumber);
        Slog.d(""Error"", ""ERR: stack="" + stackTrace);
        Slog.d(""Error"", ""ERR: TOTAL BYTES WRITTEN: "" + (dest.dataPosition() - start));
    }
}","{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    dest.writeString(crashTag);
    int total = dest.dataPosition() - start;
    if (Binder.CHECK_PARCEL_SIZE && total > 20 * 1024) {
        Slog.d(""Error"", ""ERR: exClass="" + exceptionClassName);
        Slog.d(""Error"", ""ERR: exMsg="" + exceptionMessage);
        Slog.d(""Error"", ""ERR: file="" + throwFileName);
        Slog.d(""Error"", ""ERR: class="" + throwClassName);
        Slog.d(""Error"", ""ERR: method="" + throwMethodName + "" line="" + throwLineNumber);
        Slog.d(""Error"", ""ERR: stack="" + stackTrace);
        Slog.d(""Error"", ""ERR: TOTAL BYTES WRITTEN: "" + (dest.dataPosition() - start));
    }
}",1,"/**
 * Save a CrashInfo instance to a parcel.
 */
","/**
 * Save a CrashInfo instance to a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"An additional writeString statement has been added to write the 'crashTag' field to the parcel (dest.writeString(crashTag)), and the log message content has not been modified; these are the reasons for the classifications 1 and 4.","Even though the addition of a writeString statement for 'crashTag' is a change in the code and a new field is being written to the parcel, it does not affect the behavior of this method with respect to the existing fields; it is just an additional piece of data being serialized. Since there is no alteration in the logic that could change the behavior for existing clients or alter the method's interaction with existing fields, this would not constitute a Compatibility Issue. The method's contract remains the same with respect to the previous fields."
903,<android.os.StrictMode.AndroidBlockGuardPolicy: int getPolicyMask()>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: int getPolicyMask()>,<android.os.StrictMode.AndroidBlockGuardPolicy: int getPolicyMask()>,0,"{
    return mPolicyMask;
}","{
    return mThreadPolicyMask;
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The field from which the value is returned has been changed from mPolicyMask to mThreadPolicyMask, which is considered an ""Other statement changed"" (code change type 4). Additionally, because a different field is being returned, the ""Return statement changed"" (code change type 1) category also applies.","The return statement has changed to return a different variable, which will cause the API to return a potentially different value. This is a ""Compatibility Issue caused by potential different return values or types"" (CI type 1)."
904,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",28,29,"<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>","<android.content.ContentResolver: Bundle call(Uri,String,String,Bundle)>",0,"{
    Preconditions.checkNotNull(uri, ""uri"");
    Preconditions.checkNotNull(method, ""method"");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        final Bundle res = provider.call(mPackageName, method, arg, extras);
        Bundle.setDefusable(res, true);
        return res;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    return call(uri.getAuthority(), method, arg, extras);
}",1,"/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
","/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The late version implementation now calls another overloaded version of the 'call' method instead of directly interacting with the content provider. Therefore, there is a change in a dependent API which leads to change type 5, and since the whole implementation has been changed, we also have a return statement change (type 1).","Since the late version invokes a different method that could potentially return a different result than directly interacting with the content provider, a compatibility issue due to a potential different return value arises, which is type 1."
905,<android.net.http.HttpResponseCache: void flush()>,28,29,<android.net.http.HttpResponseCache: void flush()>,<android.net.http.HttpResponseCache: void flush()>,0,"{
    try {
        delegate.flush();
    } catch (IOException ignored) {
    }
}","{
    try {
        mDelegate.flush();
    } catch (IOException ignored) {
    }
}",1,"/**
 * Force buffered operations to the filesystem. This ensures that responses
 * written to the cache will be available the next time the cache is opened,
 * even if this process is killed.
 */
","/**
 * Force buffered operations to the filesystem. This ensures that responses
 * written to the cache will be available the next time the cache is opened,
 * even if this process is killed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change consists of using a different variable name from 'delegate' to 'mDelegate', which indicates a potential change in the reference being used. So the code change type is 4.","There seems to be no change affecting the behavior of the API, since 'delegate' and 'mDelegate' appear to reference the same underlying object and only an internal reference was renamed. This would not cause a compatibility issue for clients of the API as the method's contract and behavior remain unchanged. The method still catches and ignores `IOException`, and no changes were made to the method's return type or exception handling that are visible to the caller. Hence, there is no compatibility issue."
906,<android.os.ZygoteProcess.ZygoteState: void close()>,28,29,<android.os.ZygoteProcess.ZygoteState: void close()>,<android.os.ZygoteProcess.ZygoteState: void close()>,0,"{
    try {
        socket.close();
    } catch (IOException ex) {
        Log.e(LOG_TAG, ""I/O exception on routine close"", ex);
    }
    mClosed = true;
}","{
    try {
        mZygoteSessionSocket.close();
    } catch (IOException ex) {
        Log.e(LOG_TAG, ""I/O exception on routine close"", ex);
    }
    mClosed = true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object on which the close() method is called has changed from `socket` to `mZygoteSessionSocket`. This constitutes an ""Other statement changed"" since it is altering which object's method is invoked. However, the behavior of the method - to close a socket - remains the same, so it is a change in the statement that does not affect the control flow or dependencies.","Since the action performed is of a similar nature (closing a socket) and there is no alteration to the method's control flow, return values, or exception handling, there is no Compatibility Issue. The intention and effect remain the same, which is to close a Zygote process' communication socket."
907,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,28,29,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,<android.app.WallpaperManager: WallpaperInfo getWallpaperInfo()>,0,"{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            return sGlobals.mService.getWallpaperInfo(mContext.getUserId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getWallpaperInfo(mContext.getUserId());
}",1,"/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */
","/**
 * Returns the information about the wallpaper if the current wallpaper is
 * a live wallpaper component. Otherwise, if the wallpaper is a static image,
 * this returns null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The exception handling statement and control dependency have been removed. The method now directly returns the result of getWallpaperInfo(mContext.getUserId()), relying on the new, possibly altered, getWallpaperInfo(int) which is a dependent API change. The code change types are 1,4,5.","The removal of the sGlobals.mService null check, exception handling, and direct return without these checks could lead to different behaviors or exceptions, which weren't present in the early version if sGlobals.mService was null. Hence, there is a potential for different return values or types causing the CI type to be 1."
908,<android.hardware.usb.UsbAccessory: String getSerial()>,28,29,<android.hardware.usb.UsbAccessory: String getSerial()>,<android.hardware.usb.UsbAccessory: String getSerial()>,0,"{
    return mSerial;
}","{
    try {
        return mSerialNumberReader.getSerial(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return null;
    }
}",1,"/**
 * Returns the unique serial number for the accessory.
 * This is an optional serial number that can be used to differentiate
 * between individual accessories of the same model and manufacturer
 *
 * @return the unique serial number, or {@code null} if not set
 */
","/**
 * Returns the unique serial number for the accessory.
 * This is an optional serial number that can be used to differentiate
 * between individual accessories of the same model and manufacturer
 *
 * @return the unique serial number, or {@code null} if not set
 *
 * @throws SecurityException if the app targets SDK >= {@value android.os.Build.VERSION_CODES#Q}
 * and the app does not have permission to read from the accessory.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The early version simply returns a member variable, while the late version is now using a dependent API (mSerialNumberReader.getSerial) which can throw an exception, and in case of an exception, rethrows it and returns null. Therefore, the changes are observed in 1) the return statement, 2) the exception handling, and 5) the dependent API. ",The introduction of a new try-catch block with potentially new behavior in exception handling (where the RemoteException is rethrown) and the change in the way the serial number is retrieved (via a dependent API) creates possibilities for both 1) potential difference in return values and 2) different exception handlings.
909,"<android.util.SparseArray: void setValueAt(int,E)>",28,29,"<android.util.SparseArray: void setValueAt(int,E)>","<android.util.SparseArray: void setValueAt(int,E)>",0,"{
    if (mGarbage) {
        gc();
    }
    mValues[index] = value;
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mGarbage) {
        gc();
    }
    mValues[index] = value;
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, sets a new
 * value for the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"The late version implementation introduces a new control statement that checks if the index is out of bounds and potentially throws a new exception. Additionally, there's a conditional dependency on a static field (UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) that wasn't present in the early version, so the code changes include 2, 3, and 5 because of the new exception statement, new control statement, and the new dependency on a field of another class respectively.","The new condition check and throw statement could lead to a new ArrayIndexOutOfBoundsException that was not present in the previous version of the API, leading to a compatibility issue related to exception handling, so the CI type is 2."
910,<android.widget.Switch: Mode getTrackTintMode()>,28,29,<android.widget.Switch: Mode getTrackTintMode()>,<android.widget.Switch: Mode getTrackTintMode()>,0,"{
    return mTrackTintMode;
}","{
    BlendMode mode = getTrackTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}",1,"/**
 * @return the blending mode used to apply the tint to the track
 * drawable
 * @attr ref android.R.styleable#Switch_trackTintMode
 * @see #setTrackTintMode(PorterDuff.Mode)
 */
","/**
 * @return the blending mode used to apply the tint to the track
 * drawable
 * @attr ref android.R.styleable#Switch_trackTintMode
 * @see #setTrackTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method's logic has been modified to retrieve the tint mode through a new method getTrackTintBlendMode() and convert it before returning, instead of directly returning the member variable mTrackTintMode. Since getTrackTintBlendMode() and BlendMode.blendModeToPorterDuffMode(mode) are dependent APIs and their behavior could change the output, the change type is 1,5.","The introduction of new method calls and a possible different conversion logic could potentially result in different return values, resulting in CI type 1."
913,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,28,29,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,0,"{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    InputManager.getInstance().injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
}","{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    try {
        WindowManagerGlobal.getWindowManagerService().injectInputAfterTransactionsApplied(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
","/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from InputManager.getInstance().injectInputEvent to WindowManagerGlobal.getWindowManagerService().injectInputAfterTransactionsApplied, and there is an addition of a try-catch block for RemoteException which was not present earlier. However, the RemoteException is caught and ignored with an empty catch block, implying that the behavior from the client's perspective remains unchanged. This represents a change in the dependent API and not a change in the exception handling from the client's perspective.","The addition of a try-catch block that catches and ignores the RemoteException does not change the exception behavior from the viewpoint of the API client. RemoteException is a checked exception that, if thrown, would have to be declared or caught by any client code that invokes the method. Since the try-catch block in the late version handles and effectively swallows the RemoteException internally, there is no difference in the exception behavior that would be visible to or expected by the client. Thus, no compatibility issue arises from this change."
914,"<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>",28,29,"<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>","<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method call warnIfCallingFromSystemProcess() has been removed, so the code change type is 4.","The removed method call warnIfCallingFromSystemProcess() is likely for logging or warning purposes and does not affect the return type or exception handling of the method. Therefore, it would not cause a Compatibility Issue, and the CI type is 0."
915,<android.util.SparseArray: int keyAt(int)>,28,29,<android.util.SparseArray: int keyAt(int)>,<android.util.SparseArray: int keyAt(int)>,0,"{
    if (mGarbage) {
        gc();
    }
    return mKeys[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    if (mGarbage) {
        gc();
    }
    return mKeys[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>,
 * the behavior is undefined.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>,
 * the behavior is undefined for apps targeting {@link android.os.Build.VERSION_CODES#P} and
 * earlier, and an {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","Control dependency and exception handling has changed. An if statement, which can throw an ArrayIndexOutOfBoundsException, is added at the beginning of the late version method implementation. ","The added if statement can trigger a new exception, which was not present in the early version. Also, this new condition changes the control flow which could potentially affect the returned value by not caling the 'gc()' method if the exception is thrown. Hence, the compatibility issue is due to both different return values or types and different exception handlings, which are CI type 1 and 2."
916,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",28,29,"<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>","<android.view.View: void invalidateInternal(int,int,int,int,boolean,boolean)>",0,"{
    if (mGhostView != null) {
        mGhostView.invalidate(true);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
    }
}","{
    if (mGhostView != null) {
        mGhostView.invalidate(true);
        return;
    }
    if (skipInvalidate()) {
        return;
    }
    // Reset content capture caches
    mCachedContentCaptureSession = null;
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
        if (fullInvalidate) {
            mLastIsOpaque = isOpaque();
            mPrivateFlags &= ~PFLAG_DRAWN;
        }
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        // Propagate the damage rectangle to the parent view.
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        if (p != null && ai != null && l < r && t < b) {
            final Rect damage = ai.mTmpInvalRect;
            damage.set(l, t, r, b);
            p.invalidateChild(this, damage);
        }
        // Damage the entire projection receiver, if necessary.
        if (mBackground != null && mBackground.isProjected()) {
            final View receiver = getProjectionReceiver();
            if (receiver != null) {
                receiver.damageInParent();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement `mCachedContentCaptureSession = null;` has been added in the late implementation, which resets the content capture caches. This is classified as 'Other statement changed'.","The added statement does not alter the method's behavior in terms of its return value (since it's a void method) or the exceptions it may throw. So, there is no Compatibility Issue based on the given information."
917,<android.view.textclassifier.TextClassification: String toString()>,28,29,<android.view.textclassifier.TextClassification: String toString()>,<android.view.textclassifier.TextClassification: String toString()>,0,"{
    return String.format(Locale.US, ""TextClassification {text=%s, entities=%s, actions=%s, id=%s}"", mText, mEntityConfidence, mActions, mId);
}","{
    return String.format(Locale.US, ""TextClassification {text=%s, entities=%s, actions=%s, id=%s, extras=%s}"", mText, mEntityConfidence, mActions, mId, mExtras);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed, with the addition of a new format specifier and an additional argument (`mExtras`) included in the string returned by `toString()` method, so the code change type is 1.","The change will cause the `toString()` method to potentially return a different value due to the inclusion of `mExtras`, so the CI type is 1."
918,<android.app.Activity: String getCallingPackage()>,28,29,<android.app.Activity: String getCallingPackage()>,<android.app.Activity: String getCallingPackage()>,0,"{
    try {
        return ActivityManager.getService().getCallingPackage(mToken);
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return ActivityTaskManager.getService().getCallingPackage(mToken);
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Return the name of the package that invoked this activity.  This is who
 * the data in {@link #setResult setResult()} will be sent to.  You can
 * use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.</p>
 *
 * <p class=""note"">Note: prior to {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * the result from this method was unstable.  If the process hosting the calling
 * package was no longer running, it would return null instead of the proper package
 * name.  You can use {@link #getCallingActivity()} and retrieve the package name
 * from that instead.</p>
 *
 * @return The package of the activity that will receive your
 * reply, or null if none.
 */
","/**
 * Return the name of the package that invoked this activity.  This is who
 * the data in {@link #setResult setResult()} will be sent to.  You can
 * use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.</p>
 *
 * <p class=""note"">Note: prior to {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * the result from this method was unstable.  If the process hosting the calling
 * package was no longer running, it would return null instead of the proper package
 * name.  You can use {@link #getCallingActivity()} and retrieve the package name
 * from that instead.</p>
 *
 * @return The package of the activity that will receive your
 * reply, or null if none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The code change is that the method call within the try block has changed from ActivityManager.getService().getCallingPackage(mToken) to ActivityTaskManager.getService().getCallingPackage(mToken), which indicates a change in the dependent API being used. There is no change in the control flow, return statements, or exception handling. Thus, the code change type is 5.","Despite the change in the dependent API, there is no indication that this change would lead to different return values or types or a difference in exception handling. The method signatures are identical and are designed to return the same information. The RemoteException is still caught and handled in the same way as before. For these reasons, there is no compatibility issue, and the CI type is 0."
919,"<android.content.ContentResolver: int delete(Uri,String,String[])>",28,29,"<android.content.ContentResolver: int delete(Uri,String,String[])>","<android.content.ContentResolver: int delete(Uri,String,String[])>",0,"{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.delete(url, where, selectionArgs);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
","/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There is the addition of a new control structure (`if (mWrapped != null)`), and a new potential return statement within it. The catch block has changed the return value from -1 to 0 when `RemoteException` is caught. There are no changes in exception types thrown by the method; thus, the change types are 3 and 4.","Despite the changes, the overall contract of the method does not change because the exceptions caught and handled internally are still the same (`RemoteException`), and the method's contract does not promise anything about specific return values in success or exception scenarios. The return value change in the catch block from -1 to 0 does not indicate a change in the API's behavior from the caller's perspective, as both values can be interpreted as an error or non-successful operation without further context from the documentation. Thus, there is no Compatibility Issue."
920,"<android.app.DownloadManager.Request: Request setDestinationInExternalPublicDir(String,String)>",28,29,"<android.app.DownloadManager.Request: Request setDestinationInExternalPublicDir(String,String)>","<android.app.DownloadManager.Request: Request setDestinationInExternalPublicDir(String,String)>",0,"{
    File file = Environment.getExternalStoragePublicDirectory(dirType);
    if (file == null) {
        throw new IllegalStateException(""Failed to get external storage public directory"");
    } else if (file.exists()) {
        if (!file.isDirectory()) {
            throw new IllegalStateException(file.getAbsolutePath() + "" already exists and is not a directory"");
        }
    } else {
        if (!file.mkdirs()) {
            throw new IllegalStateException(""Unable to create directory: "" + file.getAbsolutePath());
        }
    }
    setDestinationFromBase(file, subPath);
    return this;
}","{
    File file = Environment.getExternalStoragePublicDirectory(dirType);
    if (file == null) {
        throw new IllegalStateException(""Failed to get external storage public directory"");
    }
    final Context context = AppGlobals.getInitialApplication();
    if (context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.Q || !Environment.isExternalStorageLegacy()) {
        try (ContentProviderClient client = context.getContentResolver().acquireContentProviderClient(Downloads.Impl.AUTHORITY)) {
            final Bundle extras = new Bundle();
            extras.putString(Downloads.DIR_TYPE, dirType);
            client.call(Downloads.CALL_CREATE_EXTERNAL_PUBLIC_DIR, null, extras);
        } catch (RemoteException e) {
            throw new IllegalStateException(""Unable to create directory: "" + file.getAbsolutePath());
        }
    } else {
        if (file.exists()) {
            if (!file.isDirectory()) {
                throw new IllegalStateException(file.getAbsolutePath() + "" already exists and is not a directory"");
            }
        } else if (!file.mkdirs()) {
            throw new IllegalStateException(""Unable to create directory: "" + file.getAbsolutePath());
        }
    }
    setDestinationFromBase(file, subPath);
    return this;
}",1,"/**
 * Set the local destination for the downloaded file to a path within
 * the public external storage directory (as returned by
 * {@link Environment#getExternalStoragePublicDirectory(String)}).
 * <p>
 * The downloaded file is not scanned by MediaScanner. But it can be
 * made scannable by calling {@link #allowScanningByMediaScanner()}.
 *
 * @param dirType the directory type to pass to {@link Environment#getExternalStoragePublicDirectory(String)}
 * @param subPath the path within the external directory, including the
 * destination filename
 * @return this object
 * @throws IllegalStateException If the external storage directory
 * cannot be found or created.
 */
","/**
 * Set the local destination for the downloaded file to a path within
 * the public external storage directory (as returned by
 * {@link Environment#getExternalStoragePublicDirectory(String)}).
 * <p>
 * The downloaded file is not scanned by MediaScanner. But it can be
 * made scannable by calling {@link #allowScanningByMediaScanner()}.
 *
 * <p> For applications targeting {@link android.os.Build.VERSION_CODES#Q} or above,
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE}
 * permission is not needed and the {@code dirType} must be one of the known public
 * directories like {@link Environment#DIRECTORY_DOWNLOADS},
 * {@link Environment#DIRECTORY_PICTURES}, {@link Environment#DIRECTORY_MOVIES}, etc.
 *
 * @param dirType the directory type to pass to {@link Environment#getExternalStoragePublicDirectory(String)}
 * @param subPath the path within the external directory, including the
 * destination filename
 * @return this object
 * @throws IllegalStateException If the external storage directory
 * cannot be found or created.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","There is a new parameter check added, a change in the logic for directory creation that involves target SDK version and legacy storage check, and a new dependent API call to ContentProviderClient. Therefore, the code change includes changes in exception handling (adding new catch block for RemoteException), control dependency (new if-else condition), and dependent API (use of ContentProviderClient internal API), so the change type is 2,3,5.","The newly introduced if condition based on the target SDK version and external storage legacy status introduces a new code path that could potentially throw different exceptions and return different results from the previous version, which leads to a CI caused by potential different return values or types and different exception handlings, so the CI type is 1,2."
921,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,28,29,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,0,"{
    if (mText == null) {
        Log.e(TAG, ""null synthesis text"");
        return false;
    }
    if (mText.length() >= TextToSpeech.getMaxSpeechInputLength()) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}","{
    if (mText == null) {
        Log.e(TAG, ""null synthesis text"");
        return false;
    }
    if (mText.length() > TextToSpeech.getMaxSpeechInputLength()) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The comparison operator in the if statement changed from 'greater than or equal to (>=)' to 'greater than (>)', which affects the control flow. Hence, the code change type is 3 due to the change in a control flow statement.","The change in the comparison operator will affect when the method returns false, potentially resulting in a different return value when the length of the text is equal to the maximum speech input length. Thus, a Compatibility Issue can arise due to the potential of different return values, making the CI type 1."
922,"<com.android.server.backup.PermissionBackupHelper: void applyRestoredPayload(String,byte[])>",28,29,"<com.android.server.backup.PermissionBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.PermissionBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                pm.restorePermissionGrants(payload, UserHandle.USER_SYSTEM);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.w(TAG, ""Unable to restore key "" + key);
    }
}","{
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                mPermissionManager.restoreRuntimePermissions(payload, mUser);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.w(TAG, ""Unable to restore key "" + key);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change in the implementation is the replacement of pm.restorePermissionGrants with mPermissionManager.restoreRuntimePermissions and a change in the parameters passed to it. However, none of the return statements, exception handling, or control dependencies have changed. The code change is related to the use of a different API (Dependent API changed), so the change type is 4,5.","Since this method does not return any value (it's void) and the exception handling has not changed, there should be no compatibility issue arising from different return values or types. Also, the code change does not introduce any new exceptions or change the nature or circumstances under which exceptions would be thrown. Therefore, there is no Compatibility Issue."
923,<android.os.StrictMode.AndroidBlockGuardPolicy: void onNetwork()>,28,29,<android.os.StrictMode.AndroidBlockGuardPolicy: void onNetwork()>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onNetwork()>,0,"{
    if ((mPolicyMask & DETECT_NETWORK) == 0) {
        return;
    }
    if ((mPolicyMask & PENALTY_DEATH_ON_NETWORK) != 0) {
        throw new NetworkOnMainThreadException();
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new NetworkViolation());
}","{
    if ((mThreadPolicyMask & DETECT_THREAD_NETWORK) == 0) {
        return;
    }
    if ((mThreadPolicyMask & PENALTY_DEATH_ON_NETWORK) != 0) {
        throw new NetworkOnMainThreadException();
    }
    if (tooManyViolationsThisLoop()) {
        return;
    }
    startHandlingViolationException(new NetworkViolation());
}",1,"// Part of BlockGuard.Policy interface:
","// Part of BlockGuard.Policy interface:
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the variable name has changed from mPolicyMask to mThreadPolicyMask within the if conditions, which does not affect the flow or output of the method, hence the change type is 4.","Since the functionality of the method has not been altered and the variable name change will not result in any different behavior for clients using this API, there is no compatibility issue, which corresponds to CI type 0."
924,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,28,29,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,0,"{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityManager.getService().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}","{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityTaskManager.getService().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}",1,"/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
","/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change between the two versions is from ActivityManager.getService() to ActivityTaskManager.getService(). This is a change in a dependent API, which is indicated by the different class used to acquire the service, thus the code change type is 5.","Even though there's a change in the dependent API, this change does not introduce any new return values or exceptions, nor does it alter the control flow. The error handling remains the same for the given exceptions (RemoteException and NameNotFoundException), and they still cause the method to return false. Therefore, there is no Compatibility Issue, so the CI type is 0."
925,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,28,29,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,<android.net.ConnectivityManager: void reportBadNetwork(Network)>,0,"{
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    printStackTrace();
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Report a problem network to the framework.  This provides a hint to the system
 * that there might be connectivity problems on this network and may cause
 * the framework to re-evaluate network connectivity and/or switch to another
 * network.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @deprecated Use {@link #reportNetworkConnectivity} which allows reporting both
 * working and non-working connectivity.
 */
","/**
 * Report a problem network to the framework.  This provides a hint to the system
 * that there might be connectivity problems on this network and may cause
 * the framework to re-evaluate network connectivity and/or switch to another
 * network.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @deprecated Use {@link #reportNetworkConnectivity} which allows reporting both
 * working and non-working connectivity.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The method now calls printStackTrace() before executing its original logic, which is a change unrelated to the return statements or exception handling. Therefore, the code change type is 4.","The addition of printStackTrace() is solely for logging purposes and does not affect the functionality, return value, or exception handling of the API. Thus, there is no Compatibility Issue; the CI type is 0."
926,"<android.view.Surface.HwuiContext: Canvas lockCanvas(int,int)>",28,29,"<android.view.Surface.HwuiContext: Canvas lockCanvas(int,int)>","<android.view.Surface.HwuiContext: Canvas lockCanvas(int,int)>",0,"{
    if (mCanvas != null) {
        throw new IllegalStateException(""Surface was already locked!"");
    }
    mCanvas = mRenderNode.start(width, height);
    return mCanvas;
}","{
    if (mCanvas != null) {
        throw new IllegalStateException(""Surface was already locked!"");
    }
    mCanvas = mRenderNode.beginRecording(width, height);
    return mCanvas;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the method body changed from mRenderNode.start(width, height) to mRenderNode.beginRecording(width, height). Therefore, the method on which the implementation depends has changed, so the code change types are 1 and 5.","The difference in the dependent method call (mRenderNode.start versus mRenderNode.beginRecording) could potentially lead to a different return value. Hence, the change could cause the API to return a different Canvas object depending on the implementation of the start and beginRecording methods, and the CI type is 1."
928,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",28,29,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null) {
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event)) {
            return true;
        }
    }
    if (mMovement != null && mLayout != null) {
        if (mMovement.onKeyUp(this, mSpannable, keyCode, event)) {
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = getInputMethodManager();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = getInputMethodManager();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null) {
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event)) {
            return true;
        }
    }
    if (mMovement != null && mLayout != null) {
        if (mMovement.onKeyUp(this, mSpannable, keyCode, event)) {
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
929,"<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>",28,29,"<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>","<android.nfc.NfcAdapter: void setOnNdefPushCompleteCallback(OnNdefPushCompleteCallback,Activity,Activity)>",0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setOnNdefPushCompleteCallback(activity, callback);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setOnNdefPushCompleteCallback(a, callback);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    int targetSdkVersion = getSdkVersion();
    try {
        if (activity == null) {
            throw new NullPointerException(""activity cannot be null"");
        }
        mNfcActivityManager.setOnNdefPushCompleteCallback(activity, callback);
        for (Activity a : activities) {
            if (a == null) {
                throw new NullPointerException(""activities cannot contain null"");
            }
            mNfcActivityManager.setOnNdefPushCompleteCallback(a, callback);
        }
    } catch (IllegalStateException e) {
        if (targetSdkVersion < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            // Less strict on old applications - just log the error
            Log.e(TAG, ""Cannot call API with Activity that has already "" + ""been destroyed"", e);
        } else {
            // Prevent new applications from making this mistake, re-throw
            throw (e);
        }
    }
}",1,"/**
 * Set a callback on successful Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setOnNdefPushCompleteCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Set a callback on successful Android Beam (TM).
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the callback can only occur when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>The API allows for multiple activities to be specified at a time,
 * but it is strongly recommended to just register one at a time,
 * and to do so during the activity's {@link Activity#onCreate}. For example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setOnNdefPushCompleteCallback(callback, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the callback and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param callback callback, or null to disable
 * @param activity activity for which the NDEF message will be pushed
 * @param activities optional additional activities, however we strongly recommend
 * to only register one at a time, and to do so in that activity's
 * {@link Activity#onCreate}
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated this feature is deprecated. File sharing can work using other technology like
 * Bluetooth.
 */
",-1,,[@java.lang.Deprecated],-1,-1,-1,-1,-1,-1,"1,4",0,The code change includes an added conditional check for `sHasBeamFeature` followed by a `return` statement within a `synchronized` block. This change represents both a change in the return statement (case 1) and an other kind of change (case 4).,"Although there is a change in the return statement due to the added condition, it does not potentially cause the API to return a different value or throw a different exception for the existing API behavior. The new `return` statement only affects execution in scenarios where `sHasBeamFeature` is false, which would not have run successfully in the early version due to the subsequent operations requiring `sHasBeamFeature` to be true. Therefore, there is no Compatibility Issue caused by potential different return values or types, and no Compatibility Issue caused by potential different exception handlings (0)."
930,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: int getShowMode()>,28,29,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: int getShowMode()>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: int getShowMode()>,0,"{
    try {
        return Settings.Secure.getInt(mService.getContentResolver(), Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE);
    } catch (Settings.SettingNotFoundException e) {
        Log.v(LOG_TAG, ""Failed to obtain the soft keyboard mode"", e);
        // The settings hasn't been changed yet, so it's value is null. Return the default.
        return 0;
    }
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getSoftKeyboardShowMode();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re);
            re.rethrowFromSystemServer();
        }
    }
    return SHOW_MODE_AUTO;
}",1,"/**
 * Returns the show mode of the soft keyboard. The default show mode is
 * {@code SHOW_MODE_AUTO}, where the soft keyboard is shown when a text input field is
 * focused. An AccessibilityService can also request the show mode
 * {@code SHOW_MODE_HIDDEN}, where the soft keyboard is never shown.
 *
 * @return the current soft keyboard show mode
 */
","/**
 * Returns the show mode of the soft keyboard.
 *
 * @return the current soft keyboard show mode
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
",-1,[@SoftKeyboardShowMode],[@SoftKeyboardShowMode],-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The implementation of the method has changed in several ways: The early version uses Settings.Secure.getInt to obtain the soft keyboard mode and handles Settings.SettingNotFoundException, while the late version obtains a connection through AccessibilityInteractionClient and calls connection.getSoftKeyboardShowMode, which may throw a RemoteException. Additionally, the return values in the exception handling and at the end of the method have changed, which is indicative of Return statement changed (1), Exception handling statement changed (2), Control dependency changed (3), and Dependent API changed (5).","The late version of the method employs a different mechanism to retrieve the soft keyboard show mode, which could result in a different return value, even if no exception is thrown. Therefore, there is a Compatibility Issue caused by potential different return values (1). Moreover, the exception handling has changed to throw the exception after logging instead of swallowing it, which could result in different exception handling behavior (2)."
931,<android.bluetooth.BluetoothHidDevice: int getConnectionState(BluetoothDevice)>,28,29,<android.bluetooth.BluetoothHidDevice: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothHidDevice: int getConnectionState(BluetoothDevice)>,0,"{
    final IBluetoothHidDevice service = mService;
    if (service != null) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return STATE_DISCONNECTED;
}","{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return STATE_DISCONNECTED;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation between the early and late versions. The method calls, control structures, exception handling, and return statements remain the same.","Since there is no change in the code, there is no potential for a Compatibility Issue."
932,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,28,29,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,0,"{
    try {
        final FileDescriptor fd = Os.dup(orig);
        return new ParcelFileDescriptor(fd);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor fd = new FileDescriptor();
        int intfd = Os.fcntlInt(orig, (isAtLeastQ() ? F_DUPFD_CLOEXEC : F_DUPFD), 0);
        fd.setInt$(intfd);
        return new ParcelFileDescriptor(fd);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create a new ParcelFileDescriptor that is a dup of an existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
","/**
 * Create a new ParcelFileDescriptor that is a dup of an existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,There is a significant implementation change:,"- The try block logic has changed in how the FileDescriptor is duplicated, reflecting a change in the abstract flow of the operation."
937,<android.app.AppOpsManager: void stopWatchingMode(OnOpChangedListener)>,28,29,<android.app.AppOpsManager: void stopWatchingMode(OnOpChangedListener)>,<android.app.AppOpsManager: void stopWatchingMode(OnOpChangedListener)>,0,"{
    synchronized (mModeWatchers) {
        IAppOpsCallback cb = mModeWatchers.get(callback);
        if (cb != null) {
            try {
                mService.stopWatchingMode(cb);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}","{
    synchronized (mModeWatchers) {
        IAppOpsCallback cb = mModeWatchers.remove(callback);
        if (cb != null) {
            try {
                mService.stopWatchingMode(cb);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}",1,"/**
 * Stop monitoring that was previously started with {@link #startWatchingMode}.  All
 * monitoring associated with this callback will be removed.
 */
","/**
 * Stop monitoring that was previously started with {@link #startWatchingMode}.  All
 * monitoring associated with this callback will be removed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's a change within the synchronized block, `mModeWatchers.get(callback)` in the early version has been replaced with `mModeWatchers.remove(callback)` in the late version. This is classified as ""Other statement changed"" because it modifies how the method interacts with the collection `mModeWatchers`.","There is no Compatibility Issue because the change from get to remove does not affect the outward behavior of the `stopWatchingMode` method. It only affects the internal state of `mModeWatchers` by potentially removing an element, but this does not change what the method returns or the exceptions it throws. This internal change should be transparent to the caller as long as the contract of the method is not to reflect the state of the `mModeWatchers` map."
938,<android.hardware.camera2.params.StreamConfigurationMap: int[] getValidOutputFormatsForInput(int)>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: int[] getValidOutputFormatsForInput(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int[] getValidOutputFormatsForInput(int)>,0,"{
    if (mInputOutputFormatsMap == null) {
        return new int[0];
    }
    return mInputOutputFormatsMap.getOutputs(inputFormat);
}","{
    if (mInputOutputFormatsMap == null) {
        return new int[0];
    }
    int[] outputs = mInputOutputFormatsMap.getOutputs(inputFormat);
    if (mHeicOutputFormats.size() > 0) {
        // All reprocessing formats map contain JPEG.
        int[] outputsWithHeic = Arrays.copyOf(outputs, outputs.length + 1);
        outputsWithHeic[outputs.length] = ImageFormat.HEIC;
        return outputsWithHeic;
    } else {
        return outputs;
    }
}",1,"/**
 * Get the image {@code format} output formats for a reprocessing input format.
 *
 * <p>When submitting a {@link CaptureRequest} with an input Surface of a given format,
 * the only allowed target outputs of the {@link CaptureRequest} are the ones with a format
 * listed in the return value of this method. Including any other output Surface as a target
 * will throw an IllegalArgumentException. If no output format is supported given the input
 * format, an empty int[] will be returned.</p>
 *
 * <p>All image formats returned by this function will be defined in either {@link ImageFormat}
 * or in {@link PixelFormat} (and there is no possibility of collision).</p>
 *
 * <p>Formats listed in this array are guaranteed to return true if queried with
 * {@link #isOutputSupportedFor(int)}.</p>
 *
 * @return an array of integer format
 *
 * @see ImageFormat
 * @see PixelFormat
 */
","/**
 * Get the image {@code format} output formats for a reprocessing input format.
 *
 * <p>When submitting a {@link CaptureRequest} with an input Surface of a given format,
 * the only allowed target outputs of the {@link CaptureRequest} are the ones with a format
 * listed in the return value of this method. Including any other output Surface as a target
 * will throw an IllegalArgumentException. If no output format is supported given the input
 * format, an empty int[] will be returned.</p>
 *
 * <p>All image formats returned by this function will be defined in either {@link ImageFormat}
 * or in {@link PixelFormat} (and there is no possibility of collision).</p>
 *
 * <p>Formats listed in this array are guaranteed to return true if queried with
 * {@link #isOutputSupportedFor(int)}.</p>
 *
 * @return an array of integer format
 *
 * @see ImageFormat
 * @see PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The method's late implementation has a newly added conditional block and return statement which modifies the returned array of valid output formats to include the HEIC format when applicable. Thus, this changed content structure and the return statement, so the code change type is 1,3.","Because the late implementation includes additional logic to modify the output array by potentially adding the HEIC format, the API could return a different value or values than the early version under certain conditions. Hence, the late version of the API might return an array with an additional format while the early version will not, causing a CI of type 1."
939,<android.transition.TransitionSet: TransitionSet clone()>,28,29,<android.transition.TransitionSet: TransitionSet clone()>,<android.transition.TransitionSet: TransitionSet clone()>,0,"{
    TransitionSet clone = (TransitionSet) super.clone();
    clone.mTransitions = new ArrayList<Transition>();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        clone.addTransition((Transition) mTransitions.get(i).clone());
    }
    return clone;
}","{
    TransitionSet clone = (TransitionSet) super.clone();
    clone.mTransitions = new ArrayList<Transition>();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        clone.addTransitionInternal((Transition) mTransitions.get(i).clone());
    }
    return clone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the 'for' loop has changed from addTransition() to addTransitionInternal(). There is a Dependent API change, but no change in control statements, returns, or exception handling. This is classified as code change types 4 and 5.","There is no Compatibility Issue as the behavior of the clone() method itself should not differ from the perspective of the caller. The internals of how clone manages its transitions list have changed, but the contract of the clone() method, to return a new TransitionSet that is a copy of the current one, remains the same. The caller receives the same value (a cloned TransitionSet) with the same outward behavior, so there is no CI."
940,<android.os.StrictMode.VmPolicy.Builder: Builder disable(int)>,28,29,<android.os.StrictMode.VmPolicy.Builder: Builder disable(int)>,<android.os.StrictMode.VmPolicy.Builder: Builder disable(int)>,0,"{
    mMask &= ~bit;
    return this;
}","{
    mMask &= ~mask;
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the parameter name from 'bit' to 'mask', which is an internal change and likely just a rename of the variable; hence, the type of code change is 4.",There is no Compatibility Issue as the internal renaming of the parameter does not affect the external behavior of the API; the value returned by the API ('this') remains the same.
941,<android.service.autofill.AutofillService: IBinder onBind(Intent)>,28,29,<android.service.autofill.AutofillService: IBinder onBind(Intent)>,<android.service.autofill.AutofillService: IBinder onBind(Intent)>,0,"{
    if (SERVICE_INTERFACE.equals(intent.getAction())) {
        return mInterface.asBinder();
    }
    Log.w(TAG, ""Tried to bind to wrong intent: "" + intent);
    return null;
}","{
    if (SERVICE_INTERFACE.equals(intent.getAction())) {
        return mInterface.asBinder();
    }
    Log.w(TAG, ""Tried to bind to wrong intent (should be "" + SERVICE_INTERFACE + "": "" + intent);
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The only change in this instance is the literal passed to the Log.w() call inside the 'if' statement. This does not affect the control flow or the output of the method; hence the change type is 4.,There is no Compatibility Issue as the changes in the log message do not impact the API's contract regarding return values or exceptions; the return behavior remains intact.
944,<android.os.ParcelFileDescriptor.AutoCloseInputStream: void close()>,28,29,<android.os.ParcelFileDescriptor.AutoCloseInputStream: void close()>,<android.os.ParcelFileDescriptor.AutoCloseInputStream: void close()>,0,"{
    try {
        mPfd.close();
    } finally {
        super.close();
    }
}","{
    try {
        super.close();
    } finally {
        mPfd.close();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is about the sequence of method calls within the try and finally blocks. They have been swapped between the two versions, which is a change in other statement ('super.close()' and 'mPfd.close()' have switched places), so the code change type is 4.","Although there is a change in the sequence of closing streams, both 'super.close()' and 'mPfd.close()' are still called one after another. There is no introduction of a new return type or value, and the exception handling remains consistent as both versions try and close both resources no matter what. This rearrangement should not affect outward behavior such as return values or types and exceptions thrown by 'close()', as both resources will still attempt to close in either order. Therefore, there is no Compatibility Issue, and the CI type is 0."
945,"<com.android.server.backup.AccountSyncSettingsBackupHelper: void performBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",28,29,"<com.android.server.backup.AccountSyncSettingsBackupHelper: void performBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>","<com.android.server.backup.AccountSyncSettingsBackupHelper: void performBackup(ParcelFileDescriptor,BackupDataOutput,ParcelFileDescriptor)>",0,"{
    try {
        JSONObject dataJSON = serializeAccountSyncSettingsToJSON();
        if (DEBUG) {
            Log.d(TAG, ""Account sync settings JSON: "" + dataJSON);
        }
        // Encode JSON data to bytes.
        byte[] dataBytes = dataJSON.toString().getBytes(JSON_FORMAT_ENCODING);
        byte[] oldMd5Checksum = readOldMd5Checksum(oldState);
        byte[] newMd5Checksum = generateMd5Checksum(dataBytes);
        if (!Arrays.equals(oldMd5Checksum, newMd5Checksum)) {
            int dataSize = dataBytes.length;
            output.writeEntityHeader(JSON_FORMAT_HEADER_KEY, dataSize);
            output.writeEntityData(dataBytes, dataSize);
            Log.i(TAG, ""Backup successful."");
        } else {
            Log.i(TAG, ""Old and new MD5 checksums match. Skipping backup."");
        }
        writeNewMd5Checksum(newState, newMd5Checksum);
    } catch (JSONException | IOException | NoSuchAlgorithmException e) {
        Log.e(TAG, ""Couldn't backup account sync settings\n"" + e);
    }
}","{
    try {
        JSONObject dataJSON = serializeAccountSyncSettingsToJSON(mUserId);
        if (DEBUG) {
            Log.d(TAG, ""Account sync settings JSON: "" + dataJSON);
        }
        // Encode JSON data to bytes.
        byte[] dataBytes = dataJSON.toString().getBytes(JSON_FORMAT_ENCODING);
        byte[] oldMd5Checksum = readOldMd5Checksum(oldState);
        byte[] newMd5Checksum = generateMd5Checksum(dataBytes);
        if (!Arrays.equals(oldMd5Checksum, newMd5Checksum)) {
            int dataSize = dataBytes.length;
            output.writeEntityHeader(JSON_FORMAT_HEADER_KEY, dataSize);
            output.writeEntityData(dataBytes, dataSize);
            Log.i(TAG, ""Backup successful."");
        } else {
            Log.i(TAG, ""Old and new MD5 checksums match. Skipping backup."");
        }
        writeNewMd5Checksum(newState, newMd5Checksum);
    } catch (JSONException | IOException | NoSuchAlgorithmException e) {
        Log.e(TAG, ""Couldn't backup account sync settings\n"" + e);
    }
}",1,"/**
 * Take a snapshot of the current account sync settings and write them to the given output.
 */
","/**
 * Take a snapshot of the current account sync settings and write them to the given output.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method implementation has not changed, but there is a change in the method signature of a dependent API call. The dependent API `serializeAccountSyncSettingsToJSON` has an additional parameter `mUserId` in the late version, so the change type is 5.","There is no compatibility issue detected because the behavior of the `performBackup` method is not altered directly by the change. The addition of an argument to a method it calls does not constitute a change in its own behavior. It suggests that there might be an adaptation to how the user's account sync settings are serialized, potentially using the `mUserId` to cater to multi-user scenarios, but it doesn't affect the execution flow, return values, or exceptions of the `performBackup` method itself as seen in the exposed API. Therefore, there is no compatibility issue, and the CI type is 0."
947,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,28,29,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,<android.content.ContentResolver: ContentProviderClient acquireUnstableContentProviderClient(String)>,0,"{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireUnstableProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, false);
    }
    return null;
}","{
    Preconditions.checkNotNull(name, ""name"");
    IContentProvider provider = acquireUnstableProvider(name);
    if (provider != null) {
        return new ContentProviderClient(this, provider, name, false);
    }
    return null;
}",1,"/**
 * Like {@link #acquireContentProviderClient(String)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
","/**
 * Like {@link #acquireContentProviderClient(String)}, but for use when you do
 * not trust the stability of the target content provider.  This turns off
 * the mechanism in the platform clean up processes that are dependent on
 * a content provider if that content provider's process goes away.  Normally
 * you can safely assume that once you have acquired a provider, you can freely
 * use it as needed and it won't disappear, even if your process is in the
 * background.  If using this method, you need to take care to deal with any
 * failures when communicating with the provider, and be sure to close it
 * so that it can be re-opened later.  In particular, catching a
 * {@link android.os.DeadObjectException} from the calls there will let you
 * know that the content provider has gone away; at that point the current
 * ContentProviderClient object is invalid, and you should release it.  You
 * can acquire a new one if you would like to try to restart the provider
 * and perform new operations on it.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for ContentProviderClient has been modified to include an additional parameter 'name'. This is a change in the dependent API, and a return statement changed because the constructor call now includes a new argument, so the code change types are 1,5.","The addition of the 'name' parameter to the constructor call could potentially alter the returned ContentProviderClient object because the object now can contain additional information or behave differently with the new parameter, thus the CI type is 1."
948,"<android.content.ContentResolver: ParcelFileDescriptor openFileDescriptor(Uri,String,CancellationSignal)>",28,29,"<android.content.ContentResolver: ParcelFileDescriptor openFileDescriptor(Uri,String,CancellationSignal)>","<android.content.ContentResolver: ParcelFileDescriptor openFileDescriptor(Uri,String,CancellationSignal)>",0,"{
    AssetFileDescriptor afd = openAssetFileDescriptor(uri, mode, cancellationSignal);
    if (afd == null) {
        return null;
    }
    if (afd.getDeclaredLength() < 0) {
        // This is a full file!
        return afd.getParcelFileDescriptor();
    }
    // we got and bail with an exception.
    try {
        afd.close();
    } catch (IOException e) {
    }
    throw new FileNotFoundException(""Not a whole file"");
}","{
    try {
        if (mWrapped != null)
            return mWrapped.openFile(uri, mode, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    AssetFileDescriptor afd = openAssetFileDescriptor(uri, mode, cancellationSignal);
    if (afd == null) {
        return null;
    }
    if (afd.getDeclaredLength() < 0) {
        // This is a full file!
        return afd.getParcelFileDescriptor();
    }
    // we got and bail with an exception.
    try {
        afd.close();
    } catch (IOException e) {
    }
    throw new FileNotFoundException(""Not a whole file"");
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * is like {@link #openAssetFileDescriptor(Uri, String)}, but uses the
 * underlying {@link ContentProvider#openFile}
 * ContentProvider.openFile()} method, so will <em>not</em> work with
 * providers that return sub-sections of files.  If at all possible,
 * you should use {@link #openAssetFileDescriptor(Uri, String)}.  You
 * will receive a FileNotFoundException exception if the provider returns a
 * sub-section of a file.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 * <p>
 * If opening with the exclusive ""r"" or ""w"" modes, the returned
 * ParcelFileDescriptor could be a pipe or socket pair to enable streaming
 * of data. Opening with the ""rw"" mode implies a file on disk that supports
 * seeking. If possible, always use an exclusive mode to give the underlying
 * {@link ContentProvider} the most flexibility.
 * <p>
 * If you are writing a file, and need to communicate an error to the
 * provider, use {@link ParcelFileDescriptor#closeWithError(String)}.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openFile
 * ContentProvider.openFile}.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException if no
 * file exists under the URI or the mode is invalid.
 * @see #openAssetFileDescriptor(Uri, String)
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * is like {@link #openAssetFileDescriptor(Uri, String)}, but uses the
 * underlying {@link ContentProvider#openFile}
 * ContentProvider.openFile()} method, so will <em>not</em> work with
 * providers that return sub-sections of files.  If at all possible,
 * you should use {@link #openAssetFileDescriptor(Uri, String)}.  You
 * will receive a FileNotFoundException exception if the provider returns a
 * sub-section of a file.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 * <p>
 * If opening with the exclusive ""r"" or ""w"" modes, the returned
 * ParcelFileDescriptor could be a pipe or socket pair to enable streaming
 * of data. Opening with the ""rw"" mode implies a file on disk that supports
 * seeking. If possible, always use an exclusive mode to give the underlying
 * {@link ContentProvider} the most flexibility.
 * <p>
 * If you are writing a file, and need to communicate an error to the
 * provider, use {@link ParcelFileDescriptor#closeWithError(String)}.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openFile
 * ContentProvider.openFile}.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException if no
 * file exists under the URI or the mode is invalid.
 * @see #openAssetFileDescriptor(Uri, String)
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"3,4","1,2","There is the introduction of a try block with an if statement and a catch block for RemoteException. Also, the method behavior is altered such that if 'mWrapped' is not null, a different code path is taken. These are Control Dependency Changes and Other Statement Changes.","Both the return value and exception handling could be different because of the new control path added. If 'mWrapped' is not null, the method may return the result of 'mWrapped.openFile' instead of proceeding with the usual implementation. Additionally, if a RemoteException is thrown, the method now returns null instead of potentially propagating the exception up the call stack. Therefore, this could cause a Compatibility Issue due to a potential different return value (type 1) and due to potential different exception handling (type 2)."
950,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,28,29,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,<android.net.ConnectivityManager: boolean setProcessDefaultNetwork(Network)>,0,"{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getBoundNetworkForProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // TODO: Deprecate this static method and replace it with a non-static version.
        try {
            Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        } catch (SecurityException e) {
            // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
            Log.e(TAG, ""Can't set proxy properties"", e);
        }
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}","{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    boolean isSameNetId = (netId == NetworkUtils.getBoundNetworkForProcess());
    if (netId != NETID_UNSET) {
        netId = network.getNetIdForResolv();
    }
    if (!NetworkUtils.bindProcessToNetwork(netId)) {
        return false;
    }
    if (!isSameNetId) {
        // TODO: Deprecate this static method and replace it with a non-static version.
        try {
            Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        } catch (SecurityException e) {
            // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
            Log.e(TAG, ""Can't set proxy properties"", e);
        }
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
    }
    return true;
}",1,"/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 * @deprecated This function can throw {@link IllegalStateException}.  Use
 * {@link #bindProcessToNetwork} instead.  {@code bindProcessToNetwork}
 * is a direct replacement.
 */
","/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 * @deprecated This function can throw {@link IllegalStateException}.  Use
 * {@link #bindProcessToNetwork} instead.  {@code bindProcessToNetwork}
 * is a direct replacement.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The control flow has been significantly altered: An `isSameNetId` boolean variable is introduced to check if `netId` is the same as the result of `NetworkUtils.getBoundNetworkForProcess()`. A new branch to set `netId` using `network.getNetIdForResolv()` if `netId` is not `NETID_UNSET` has been added. The condition for applying the proxy settings, clearing the DNS cache, and notifying network configuration change is now dependent on the `!isSameNetId` condition instead of always occurring after binding the process to the new network. These changes involve control dependency (type 3), a different variable being returned (type 1), and the dependency on `network.getNetIdForResolv()` indicates that a dependent API has changed (type 5).","Since the logic to apply settings only when `netId` is different implies that in cases where it is the same as before, certain actions will not be executed which previously were always executed, this could lead to different return value or types (type 1). Moreover, the method now only returns false if `NetworkUtils.bindProcessToNetwork(netId)` fails, whereas previously, it could also return false in other circumstances, indicating a potential difference in returned values or types (type 1)."
951,<android.widget.RemoteViews: int getLayoutId()>,28,29,<android.widget.RemoteViews: int getLayoutId()>,<android.widget.RemoteViews: int getLayoutId()>,0,"{
    return mLayoutId;
}","{
    return hasFlags(FLAG_USE_LIGHT_BACKGROUND_LAYOUT) && (mLightBackgroundLayoutId != 0) ? mLightBackgroundLayoutId : mLayoutId;
}",1,"/**
 * Returns the layout id of the root layout associated with this RemoteViews. In the case
 * that the RemoteViews has both a landscape and portrait root, this will return the layout
 * id associated with the portrait layout.
 *
 * @return the layout id.
 */
","/**
 * Returns the layout id of the root layout associated with this RemoteViews. In the case
 * that the RemoteViews has both a landscape and portrait root, this will return the layout
 * id associated with the portrait layout.
 *
 * @return the layout id.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed to include a conditional operator, which may result in a different layout ID being returned if certain conditions are met. Thus, the code change type is 1.","The change in return statement means that the API could potentially return a different value based on the evaluation of the condition; previously it always returned mLayoutId, whereas now it may return mLightBackgroundLayoutId under certain conditions. This leads to a CI type of 1."
953,<android.view.Surface.HwuiContext: void unlockAndPost(Canvas)>,28,29,<android.view.Surface.HwuiContext: void unlockAndPost(Canvas)>,<android.view.Surface.HwuiContext: void unlockAndPost(Canvas)>,0,"{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    mRenderNode.end(mCanvas);
    mCanvas = null;
    nHwuiDraw(mHwuiRenderer);
}","{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    mRenderNode.endRecording();
    mCanvas = null;
    nHwuiDraw(mHwuiRenderer);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the method calling on mRenderNode object; from mRenderNode.end(mCanvas) to mRenderNode.endRecording(). This suggests a method inside the class of the object mRenderNode has changed, which classifies as type 4 (Other statement changed) and 5 (Dependent API changed) because it involves a change in the method of a dependent API.","Though the method called on the mRenderNode object has changed, as long as the external behavior of mRenderNode.endRecording() is the same as mRenderNode.end(mCanvas) in terms of how it affects the state of mRenderNode and does not cause it to throw a new exception or affect the state of 'mCanvas' variable, there wouldn't be a compatibility issue. There's no indication that the behavior is different; it may just be a renaming or internal refactoring without any effect on external behavior. Hence, without evidence of impact on return value or exception throwing behavior, we classify this as 0, No Compatibility Issue."
954,"<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",28,29,"<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>","<android.content.ContentResolver: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",0,"{
    Preconditions.checkNotNull(authority, ""authority"");
    Preconditions.checkNotNull(operations, ""operations"");
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}","{
    Preconditions.checkNotNull(authority, ""authority"");
    Preconditions.checkNotNull(operations, ""operations"");
    try {
        if (mWrapped != null)
            return mWrapped.applyBatch(authority, operations);
    } catch (RemoteException e) {
        return null;
    }
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}",1,"/**
 * Applies each of the {@link ContentProviderOperation} objects and returns an array
 * of their results. Passes through OperationApplicationException, which may be thrown
 * by the call to {@link ContentProviderOperation#apply}.
 * If all the applications succeed then a {@link ContentProviderResult} array with the
 * same number of elements as the operations will be returned. It is implementation-specific
 * how many, if any, operations will have been successfully applied if a call to
 * apply results in a {@link OperationApplicationException}.
 * @param authority the authority of the ContentProvider to which this batch should be applied
 * @param operations the operations to apply
 * @return the results of the applications
 * @throws OperationApplicationException thrown if an application fails.
 * See {@link ContentProviderOperation#apply} for more information.
 * @throws RemoteException thrown if a RemoteException is encountered while attempting
 * to communicate with a remote provider.
 */
","/**
 * Applies each of the {@link ContentProviderOperation} objects and returns an array
 * of their results. Passes through OperationApplicationException, which may be thrown
 * by the call to {@link ContentProviderOperation#apply}.
 * If all the applications succeed then a {@link ContentProviderResult} array with the
 * same number of elements as the operations will be returned. It is implementation-specific
 * how many, if any, operations will have been successfully applied if a call to
 * apply results in a {@link OperationApplicationException}.
 * @param authority the authority of the ContentProvider to which this batch should be applied
 * @param operations the operations to apply
 * @return the results of the applications
 * @throws OperationApplicationException thrown if an application fails.
 * See {@link ContentProviderOperation#apply} for more information.
 * @throws RemoteException thrown if a RemoteException is encountered while attempting
 * to communicate with a remote provider.
 */
",-1,[@NonNull],"[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The introduction of a new try block and a catch clause that returns null introduces a new return statement and a different exception handling strategy. This, combined with the presence of a conditionally executed return statement that depends on 'mWrapped' which wasn't present in the early implementation, accounts for the changes in control dependency and potentially different return values or exception handlings.",
955,<android.service.autofill.FillContext: String toString()>,28,29,<android.service.autofill.FillContext: String toString()>,<android.service.autofill.FillContext: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    return ""FillContext [reqId="" + mRequestId + ""]"";
}","{
    if (!sDebug)
        return super.toString();
    return ""FillContext [reqId="" + mRequestId + "", focusedId="" + mFocusedId + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement for the 'toString' method is modified to include additional information ("", focusedId="" + mFocusedId) in the Late_Version, so the change type is 1.","As the alteration to the return statement could lead to 'toString' method returning a different text representation of the object, which includes additional information not present in the Early_Version, there is a Compatibility Issue of type 1, indicating potential different return values."
956,<android.provider.MediaStore: String getVersion(Context)>,28,29,<android.provider.MediaStore: String getVersion(Context)>,<android.provider.MediaStore: String getVersion(Context)>,0,"{
    Cursor c = context.getContentResolver().query(Uri.parse(CONTENT_AUTHORITY_SLASH + ""none/version""), null, null, null, null);
    if (c != null) {
        try {
            if (c.moveToFirst()) {
                return c.getString(0);
            }
        } finally {
            c.close();
        }
    }
    return null;
}","{
    return getVersion(context, VOLUME_EXTERNAL_PRIMARY);
}",1,"/**
 * Get the media provider's version.
 * Applications that import data from the media provider into their own caches
 * can use this to detect that the media provider changed, and reimport data
 * as needed. No other assumptions should be made about the meaning of the version.
 * @param context Context to use for performing the query.
 * @return A version string, or null if the version could not be determined.
 */
","/**
 * Return an opaque version string describing the {@link MediaStore} state.
 * <p>
 * Applications that import data from {@link MediaStore} into their own
 * caches can use this to detect that {@link MediaStore} has undergone
 * substantial changes, and that data should be rescanned.
 * <p>
 * No other assumptions should be made about the meaning of the version.
 * <p>
 * This method returns the version for
 * {@link MediaStore#VOLUME_EXTERNAL_PRIMARY}; to obtain a version for a
 * different volume, use {@link #getVersion(Context, String)}.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation of the method has changed. The early version uses a Cursor to query and return a version string from the database, while the late version now delegates the call to another method getVersion(context, VOLUME_EXTERNAL_PRIMARY). The change includes a new return statement and a change in the dependent API, thus the change type is 1,4,5.","Since the method's logic has been entirely changed to call a different method, the return value might potentially differ, so the CI type is 1. Additionally, the late version is annotated with @NonNull, which introduces a contract that the return value should never be null, unlike the early version that could return null. Hence, the change could lead to different behaviour for cases where null was previously returned."
957,"<android.view.LayoutInflater: View inflate(int,ViewGroup,boolean)>",28,29,"<android.view.LayoutInflater: View inflate(int,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(int,ViewGroup,boolean)>",0,"{
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, ""INFLATING from resource: \"""" + res.getResourceName(resource) + ""\"" ("" + Integer.toHexString(resource) + "")"");
    }
    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}","{
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, ""INFLATING from resource: \"""" + res.getResourceName(resource) + ""\"" ("" + Integer.toHexString(resource) + "")"");
    }
    View view = tryInflatePrecompiled(resource, res, root, attachToRoot);
    if (view != null) {
        return view;
    }
    XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified xml resource. Throws
 * {@link InflateException} if there is an error.
 *
 * @param resource ID for an XML layout resource to load (e.g.,
 * <code>R.layout.main_page</code>)
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified xml resource. Throws
 * {@link InflateException} if there is an error.
 *
 * @param resource ID for an XML layout resource to load (e.g.,
 * <code>R.layout.main_page</code>)
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new method call tryInflatePrecompiled() has been introduced, along with additional control flow to check if the view is not null and to return the view early if it is. There's also an addition of a different return statement. So there are changes in the return statement (1), other statement (4), and control dependency (3).","This change in control flow could potentially result in a different view being returned if tryInflatePrecompiled() succeeds, which constitutes a different return variable. Hence, the compatibility issue is caused by potentially different return values (1)."
958,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,28,29,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {
                deltaY -= mScrollConsumed[1];
                vtev.offsetLocation(0, mScrollOffset[1]);
                mNestedYOffset += mScrollOffset[1];
            }
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y - mScrollOffset[1];
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true) && !hasNestedScrollingParent()) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                final int scrolledDeltaY = mScrollY - oldY;
                final int unconsumedY = deltaY - scrolledDeltaY;
                if (dispatchNestedScroll(0, scrolledDeltaY, 0, unconsumedY, mScrollOffset)) {
                    mLastMotionY -= mScrollOffset[1];
                    vtev.offsetLocation(0, mScrollOffset[1]);
                    mNestedYOffset += mScrollOffset[1];
                } else if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight(), ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight(), 1.f - ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                    flingWithNestedDispatch(-initialVelocity);
                } else if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}","{
    initVelocityTrackerIfNotExists();
    MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {
                deltaY -= mScrollConsumed[1];
                vtev.offsetLocation(0, mScrollOffset[1]);
                mNestedYOffset += mScrollOffset[1];
            }
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y - mScrollOffset[1];
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true) && !hasNestedScrollingParent()) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                final int scrolledDeltaY = mScrollY - oldY;
                final int unconsumedY = deltaY - scrolledDeltaY;
                if (dispatchNestedScroll(0, scrolledDeltaY, 0, unconsumedY, mScrollOffset)) {
                    mLastMotionY -= mScrollOffset[1];
                    vtev.offsetLocation(0, mScrollOffset[1]);
                    mNestedYOffset += mScrollOffset[1];
                } else if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight(), ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight(), 1.f - ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (shouldDisplayEdgeEffects() && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                    flingWithNestedDispatch(-initialVelocity);
                } else if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
960,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",28,29,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>","<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",0,"{
    try {
        if (maxNum < 0) {
            throw new IllegalArgumentException(""The requested number of tasks should be >= 0"");
        }
        return getService().getRecentTasks(maxNum, flags, mContext.getUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        if (maxNum < 0) {
            throw new IllegalArgumentException(""The requested number of tasks should be >= 0"");
        }
        return getTaskService().getRecentTasks(maxNum, flags, mContext.getUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
","/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The method call within the return statement has been changed from getService().getRecentTasks to getTaskService().getRecentTasks, which implies that the underlying method called is different (dependent API changed). However, the method signature (input parameters and the return type) and exception handling have not been altered, so the overall behaviour from an API consumer perspective remains consistent with respect to the definition of CI.",There is no Compatibility Issue detected as the change does not impact the potential return value or the exceptions that are thrown by the method - the change in the underlying service method call is presumed to be an internal change with the same expectations regarding input and output.
961,"<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int,Bundle)>",28,29,"<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int,Bundle)>","<android.view.accessibility.AccessibilityNodeInfo: boolean performAction(int,Bundle)>",0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mWindowId, mSourceNodeId, action, arguments);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.performAccessibilityAction(mConnectionId, mWindowId, mSourceNodeId, action, arguments);
}",1,"/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @param arguments A bundle with additional arguments.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Performs an action on the node.
 * <p>
 * <strong>Note:</strong> An action can be performed only if the request is made
 * from an {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param action The action to perform.
 * @param arguments A bundle with additional arguments.
 * @return True if the action was performed.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the argument list of the method canPerformRequestOverConnection(); in the early version, it only takes one parameter mSourceNodeId, whereas in the late version, it takes three parameters mConnectionId, mWindowId, and mSourceNodeId. Thus, the dependent API has changed, which is indicated by type 5. There's also an other statement change due to the modification of the method call, which is type 4.","While the argument list of the dependent API canPerformRequestOverConnection has changed, this doesn't necessarily result in a behavior that leads to a Compatibility Issue. The return value, type, and exception handling remain the same as the method's functionality is preserved despite the modification in parameters. The contract of the method seems to stay the same, hence no Compatibility Issue is expected, which is indicated by type 0."
962,<android.app.AutomaticZenRule: boolean equals(Object)>,28,29,<android.app.AutomaticZenRule: boolean equals(Object)>,<android.app.AutomaticZenRule: boolean equals(Object)>,0,"{
    if (!(o instanceof AutomaticZenRule))
        return false;
    if (o == this)
        return true;
    final AutomaticZenRule other = (AutomaticZenRule) o;
    return other.enabled == enabled && Objects.equals(other.name, name) && other.interruptionFilter == interruptionFilter && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.owner, owner) && other.creationTime == creationTime;
}","{
    if (!(o instanceof AutomaticZenRule))
        return false;
    if (o == this)
        return true;
    final AutomaticZenRule other = (AutomaticZenRule) o;
    return other.enabled == enabled && other.mModified == mModified && Objects.equals(other.name, name) && other.interruptionFilter == interruptionFilter && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.owner, owner) && Objects.equals(other.mZenPolicy, mZenPolicy) && Objects.equals(other.configurationActivity, configurationActivity) && other.creationTime == creationTime;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified to include additional object equality checks (other.mModified == mModified and additional Objects.equals() comparisons), and also additional member variables are being compared (mZenPolicy and configurationActivity). This constitutes a return statement change and an other statement change, so the code change type is 1,4.","These modifications in the equality check can potentially lead to a change in the return value (true/false) whenever equals() is called with an AutomaticZenRule object that has different values for mModified, mZenPolicy, or configurationActivity. Therefore, the CI type is 1."
963,"<android.app.slice.SliceManager: int checkSlicePermission(Uri,int,int)>",28,29,"<android.app.slice.SliceManager: int checkSlicePermission(Uri,int,int)>","<android.app.slice.SliceManager: int checkSlicePermission(Uri,int,int)>",0,"{
    try {
        return mService.checkSlicePermission(uri, null, pid, uid, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.checkSlicePermission(uri, mContext.getPackageName(), null, pid, uid, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a specific slice URI.
 *
 * @param uri The uri that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 *
 * @return {@link PackageManager#PERMISSION_GRANTED} if the given
 * pid/uid is allowed to access that uri, or
 * {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #grantSlicePermission(String, Uri)
 */
","/**
 * Determine whether a particular process and user ID has been granted
 * permission to access a specific slice URI.
 *
 * @param uri The uri that is being checked.
 * @param pid The process ID being checked against.  Must be &gt; 0.
 * @param uid The user ID being checked against.  A uid of 0 is the root
 * user, which will pass every permission check.
 *
 * @return {@link PackageManager#PERMISSION_GRANTED} if the given
 * pid/uid is allowed to access that uri, or
 * {@link PackageManager#PERMISSION_DENIED} if it is not.
 *
 * @see #grantSlicePermission(String, Uri)
 */
",-1,[@PermissionResult],[@PermissionResult],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `checkSlicePermission` within the `try` block has a change in its parameters: the second argument is added with `mContext.getPackageName()`, so the code change type is 4 for Other statement changed and 5 for Dependent API changed.","Despite the change in the parameter, this does not constitute a change to the return type or a different exception potentially being thrown by the API. The internal implementation of 'checkSlicePermission' handles the extra parameter without affecting the contract of the method 'checkSlicePermission(Uri,int,int)'. Therefore, there is no Compatibility Issue, so the CI type is 0."
964,<android.widget.TextView: boolean canPasteAsPlainText()>,28,29,<android.widget.TextView: boolean canPasteAsPlainText()>,<android.widget.TextView: boolean canPasteAsPlainText()>,0,"{
    if (!canPaste()) {
        return false;
    }
    final ClipData clipData = ((ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE)).getPrimaryClip();
    final ClipDescription description = clipData.getDescription();
    final boolean isPlainType = description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN);
    final CharSequence text = clipData.getItemAt(0).getText();
    if (isPlainType && (text instanceof Spanned)) {
        Spanned spanned = (Spanned) text;
        if (TextUtils.hasStyleSpan(spanned)) {
            return true;
        }
    }
    return description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML);
}","{
    if (!canPaste()) {
        return false;
    }
    final ClipData clipData = getClipboardManagerForUser().getPrimaryClip();
    final ClipDescription description = clipData.getDescription();
    final boolean isPlainType = description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN);
    final CharSequence text = clipData.getItemAt(0).getText();
    if (isPlainType && (text instanceof Spanned)) {
        Spanned spanned = (Spanned) text;
        if (TextUtils.hasStyleSpan(spanned)) {
            return true;
        }
    }
    return description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method that is called to obtain the ClipboardManager instance has changed from getContext().getSystemService(Context.CLIPBOARD_SERVICE) to getClipboardManagerForUser(). This code change type is not about the return statement, exception handling statement, or a control dependency, so it is classified as 4. Since the method getClipboardManagerForUser() is expected to return an instance of ClipboardManager just like getContext().getSystemService(Context.CLIPBOARD_SERVICE) did previously, this is also classified as 5 (Dependent API changed).","There seems to be no change in behavior as the new method getClipboardManagerForUser() should return a ClipboardManager instance just like the old code. Assuming that getClipboardManagerForUser() is a compatible replacement for getContext().getSystemService(Context.CLIPBOARD_SERVICE) in obtaining a ClipboardManager, there is no Compatibility Issue arising from this change, so the CI type is 0."
965,<android.app.ActivityTransitionState: int addExitTransitionCoordinator(ExitTransitionCoordinator)>,28,29,<android.app.ActivityTransitionState: int addExitTransitionCoordinator(ExitTransitionCoordinator)>,<android.app.ActivityTransitionState: int addExitTransitionCoordinator(ExitTransitionCoordinator)>,0,"{
    if (mExitTransitionCoordinators == null) {
        mExitTransitionCoordinators = new SparseArray<WeakReference<ExitTransitionCoordinator>>();
    }
    WeakReference<ExitTransitionCoordinator> ref = new WeakReference(exitTransitionCoordinator);
    // clean up old references:
    for (int i = mExitTransitionCoordinators.size() - 1; i >= 0; i--) {
        WeakReference<ExitTransitionCoordinator> oldRef = mExitTransitionCoordinators.valueAt(i);
        if (oldRef.get() == null) {
            mExitTransitionCoordinators.removeAt(i);
        }
    }
    int newKey = mExitTransitionCoordinatorsKey++;
    mExitTransitionCoordinators.append(newKey, ref);
    return newKey;
}","{
    if (mExitTransitionCoordinators == null) {
        mExitTransitionCoordinators = new SparseArray<>();
    }
    WeakReference<ExitTransitionCoordinator> ref = new WeakReference(exitTransitionCoordinator);
    // clean up old references:
    for (int i = mExitTransitionCoordinators.size() - 1; i >= 0; i--) {
        WeakReference<ExitTransitionCoordinator> oldRef = mExitTransitionCoordinators.valueAt(i);
        if (oldRef.get() == null) {
            mExitTransitionCoordinators.removeAt(i);
        }
    }
    int newKey = mExitTransitionCoordinatorsKey++;
    mExitTransitionCoordinators.append(newKey, ref);
    return newKey;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no functional change in the code. The only difference is the removal of the explicit type parameter in `new SparseArray<WeakReference<ExitTransitionCoordinator>>();` which is replaced by the diamond operator `new SparseArray<>();`. Since Java supports type inference for generic instance creation, this change does not affect the behavior of the code.","There is no compatibility issue since the change does not affect the return value, exception handling, or control flow of the method."
966,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",28,29,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>","<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",0,"{
    if (position == INVALID_POSITION) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    final boolean isItemEnabled;
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemEnabled = ((AbsListView.LayoutParams) lp).isEnabled;
    } else {
        isItemEnabled = false;
    }
    if (!isEnabled() || !isItemEnabled) {
        info.setEnabled(false);
        return;
    }
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        info.addAction(AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        info.addAction(AccessibilityAction.ACTION_SELECT);
    }
    if (isItemClickable(view)) {
        info.addAction(AccessibilityAction.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        info.addAction(AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}","{
    if (position == INVALID_POSITION) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    final boolean isItemEnabled;
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemEnabled = ((AbsListView.LayoutParams) lp).isEnabled && isEnabled();
    } else {
        isItemEnabled = false;
    }
    info.setEnabled(isItemEnabled);
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_SELECT);
    }
    if (isItemClickable(view)) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}",1,"/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
","/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The changes include modification of a condition 'if (lp instanceof AbsListView.LayoutParams)' to include '&& isEnabled()' in the late version, extraction of a conditional action addition into a new method (addAccessibilityActionIfEnabled), and change of how the 'info' object is set to enabled or not. Additionally, there is a new dependent API changed (addAccessibilityActionIfEnabled method). All these lead to the code change type being 1,3,4,5.","Since the implementation altered the conditions under which accessibility actions might be added to 'info' and the enabled/disabled state of 'info' is also affected, it is likely that the API can exhibit different behaviors. For example, with different actions added or not added based on the state of 'isItemEnabled', and the change in isEnabled property of info, the API might perform differently than before when interacted with accessibility services. Thus, the type of CI is 1."
967,<android.appwidget.AppWidgetHostView: View getDefaultView()>,28,29,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
            defaultView.setOnClickListener(this::onDefaultViewClicked);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional method call (defaultView.setOnClickListener(this::onDefaultViewClicked)) in the Late_Implementation, which is an other statement change, so the code change type is 4.","The additional method call will not affect the return value of the getDefaultView() method or change the exceptions that it might throw, so there is no compatibility issue and the CI type is 0."
969,<android.os.Build: String getSerial()>,28,29,<android.os.Build: String getSerial()>,<android.os.Build: String getSerial()>,0,"{
    IDeviceIdentifiersPolicyService service = IDeviceIdentifiersPolicyService.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));
    try {
        return service.getSerial();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    return UNKNOWN;
}","{
    IDeviceIdentifiersPolicyService service = IDeviceIdentifiersPolicyService.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));
    try {
        Application application = ActivityThread.currentApplication();
        String callingPackage = application != null ? application.getPackageName() : null;
        return service.getSerialForPackage(callingPackage);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    return UNKNOWN;
}",1,"/**
 * Gets the hardware serial number, if available.
 *
 * <p class=""note""><b>Note:</b> Root access may allow you to modify device identifiers, such as
 * the hardware serial number. If you change these identifiers, you can use
 * <a href=""/training/articles/security-key-attestation.html"">key attestation</a> to obtain
 * proof of the device's original identifiers.
 *
 * @return The serial number if specified.
 */
","/**
 * Gets the hardware serial number, if available.
 *
 * <p class=""note""><b>Note:</b> Root access may allow you to modify device identifiers, such as
 * the hardware serial number. If you change these identifiers, you can use
 * <a href=""/training/articles/security-key-attestation.html"">key attestation</a> to obtain
 * proof of the device's original identifiers.
 *
 * <p>Requires Permission: READ_PRIVILEGED_PHONE_STATE, for the calling app to be the device or
 * profile owner and have the READ_PHONE_STATE permission, or that the calling app has carrier
 * privileges (see {@link android.telephony.TelephonyManager#hasCarrierPrivileges}). The profile
 * owner is an app that owns a managed profile on the device; for more details see <a
 * href=""https://developer.android.com/work/managed-profiles"">Work profiles</a>. Profile owner
 * access is deprecated and will be removed in a future release.
 *
 * <p>If the calling app does not meet one of these requirements then this method will behave
 * as follows:
 *
 * <ul>
 * <li>If the calling app's target SDK is API level 28 or lower and the app has the
 * READ_PHONE_STATE permission then {@link Build#UNKNOWN} is returned.</li>
 * <li>If the calling app's target SDK is API level 28 or lower and the app does not have
 * the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
 * higher, then a SecurityException is thrown.</li>
 * </ul>
 * *
 * @return The serial number if specified.
 */
",-1,[@RequiresPermission(Manifest.permission.READ_PHONE_STATE)],"[// No support for device / profile owner.
@SuppressAutoDoc, @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method getSerial() changes to getSerialForPackage(callingPackage) with a different parameter, and a new variable 'callingPackage' is introduced to capture the package name for the current application. Therefore, the code change types are 1,4,5.","The change in the dependent API from getSerial() to getSerialForPackage() with the introduction of 'callingPackage' could lead to a different return value. The additional logic to obtain the package name also affects the serial number returned based on the calling package. Hence, the CI is of type 1."
970,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>",28,29,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>","<android.text.util.Linkify: boolean addLinks(Spannable,int)>",0,"{
    return addLinks(text, mask, null);
}","{
    return addLinks(text, mask, null, null);
}",1,"/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 *
 * @param text Spannable whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 */
","/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 *
 * @param text Spannable whose text is to be marked-up with links
 * @param mask Mask to define which kinds of links will be searched.
 *
 * @return True if at least one link is found and applied.
 *
 * @see #addLinks(Spannable, int, Function)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent method call inside the implementation changed from addLinks(text, mask, null) to addLinks(text, mask, null, null), meaning the number of parameters in the method call has changed, thus indicating a change in the dependent API. This is a change of type 4,5.","There is no Compatibility Issue because the method's signature has not changed, and it is still expected to return the same type of result (boolean). The internal call to a different overload of the method does not change the expected outcome of the original method; hence, there's no change that leads to a different return value or exception handling from the perspective of the caller. Therefore, the CI type is 0."
972,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,28,29,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,<android.hardware.camera2.impl.CameraDeviceImpl: void flush()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceExecutor.execute(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceExecutor.execute(mCallOnIdle);
            return;
        }
        long lastFrameNumber = mRemoteDevice.flush();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber);
            mRepeatingRequestId = REQUEST_ID_NONE;
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        mDeviceExecutor.execute(mCallOnBusy);
        // flush.
        if (mIdle) {
            mDeviceExecutor.execute(mCallOnIdle);
            return;
        }
        long lastFrameNumber = mRemoteDevice.flush();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            checkEarlyTriggerSequenceComplete(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is an additional parameter, mRepeatingRequestTypes, passed to the method checkEarlyTriggerSequenceComplete(), but this is an internal change to how the method is called. Also, the assignment of null to the mRepeatingRequestTypes has been added. Therefore, the code change type is 4.","The added parameter passed to checkEarlyTriggerSequenceComplete() does not affect the external behavior of the flush() method. The method's return type is void, and no additional exceptions are introduced. Hence, this change will not cause any Compatibility Issues, and the CI type is 0."
973,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",28,29,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        // the context without reloading Resources.
        return new ContextImpl(this, mMainThread, mPackageInfo, null, mActivityToken, user, flags, null);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, user, flags, null);
        final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        // the context without reloading Resources.
        return new ContextImpl(this, mMainThread, mPackageInfo, null, mActivityToken, user, flags, null, null);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, user, flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mActivityToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The constructor for `ContextImpl` has changed by adding an additional `null` parameter, and a method `getDisplayId()` is introduced to replace the inline display ID fetching logic. These changes don't affect the return values directly but contribute to other statement changes, so the code change type is 4.","There is no Compatibility Issue because the behavior of the method is fundamentally the same: it returns a `ContextImpl` object with the same parameters, except for the additional `null` which likely indicates a new but unused parameter in the context of this API. Additionally, the `getDisplayId()` consolidates the logic that was already present, so the execution path leading to returned values or thrown exceptions is unchanged. The potential change in internal implementation does not impact the overall method contract."
974,"<android.os.Parcel: void writeMapInternal(Map<String, Object>)>",28,29,"<android.os.Parcel: void writeMapInternal(Map<String, Object>)>","<android.os.Parcel: void writeMapInternal(Map<String, Object>)>",0,"{
    if (val == null) {
        writeInt(-1);
        return;
    }
    Set<Map.Entry<String, Object>> entries = val.entrySet();
    writeInt(entries.size());
    for (Map.Entry<String, Object> e : entries) {
        writeValue(e.getKey());
        writeValue(e.getValue());
    }
}","{
    if (val == null) {
        writeInt(-1);
        return;
    }
    Set<Map.Entry<String, Object>> entries = val.entrySet();
    int size = entries.size();
    writeInt(size);
    for (Map.Entry<String, Object> e : entries) {
        writeValue(e.getKey());
        writeValue(e.getValue());
        size--;
    }
    if (size != 0) {
        throw new BadParcelableException(""Map size does not match number of entries!"");
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,2,"An extra variable `size` is introduced to keep track of the remaining elements in the map and a new conditional statement with a `throw` statement is added which throws a `BadParcelableException` if the number of written entries does not match the expected size. So, the change type is 4.","The change could lead to a different exception being thrown that was not possible before (BadParcelableException), so the CI type is 2."
975,"<android.nfc.NfcAdapter: void setBeamPushUris(Uri[],Activity)>",28,29,"<android.nfc.NfcAdapter: void setBeamPushUris(Uri[],Activity)>","<android.nfc.NfcAdapter: void setBeamPushUris(Uri[],Activity)>",0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    if (uris != null) {
        for (Uri uri : uris) {
            if (uri == null)
                throw new NullPointerException(""Uri not "" + ""allowed to be null"");
            String scheme = uri.getScheme();
            if (scheme == null || (!scheme.equalsIgnoreCase(""file"") && !scheme.equalsIgnoreCase(""content""))) {
                throw new IllegalArgumentException(""URI needs to have "" + ""either scheme file or scheme content"");
            }
        }
    }
    mNfcActivityManager.setNdefPushContentUri(activity, uris);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    if (activity == null) {
        throw new NullPointerException(""activity cannot be null"");
    }
    if (uris != null) {
        for (Uri uri : uris) {
            if (uri == null)
                throw new NullPointerException(""Uri not "" + ""allowed to be null"");
            String scheme = uri.getScheme();
            if (scheme == null || (!scheme.equalsIgnoreCase(""file"") && !scheme.equalsIgnoreCase(""content""))) {
                throw new IllegalArgumentException(""URI needs to have "" + ""either scheme file or scheme content"");
            }
        }
    }
    mNfcActivityManager.setNdefPushContentUri(activity, uris);
}",1,"/**
 * Set one or more {@link Uri}s to send using Android Beam (TM). Every
 * Uri you provide must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this method, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUris(new Uri[] {uri1, uri2}, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically supply Uri(s),
 * then set a callback using {@link #setBeamPushUrisCallback} instead
 * of using this method.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param uris an array of Uri(s) to push over Android Beam
 * @param activity activity for which the Uri(s) will be pushed
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Set one or more {@link Uri}s to send using Android Beam (TM). Every
 * Uri you provide must have either scheme 'file' or scheme 'content'.
 *
 * <p>For the data provided through this method, Android Beam tries to
 * switch to alternate transports such as Bluetooth to achieve a fast
 * transfer speed. Hence this method is very suitable
 * for transferring large files such as pictures or songs.
 *
 * <p>The receiving side will store the content of each Uri in
 * a file and present a notification to the user to open the file
 * with a {@link android.content.Intent} with action
 * {@link android.content.Intent#ACTION_VIEW}.
 * If multiple URIs are sent, the {@link android.content.Intent} will refer
 * to the first of the stored files.
 *
 * <p>This method may be called at any time before {@link Activity#onDestroy},
 * but the URI(s) are only made available for Android Beam when the
 * specified activity(s) are in resumed (foreground) state. The recommended
 * approach is to call this method during your Activity's
 * {@link Activity#onCreate} - see sample
 * code below. This method does not immediately perform any I/O or blocking work,
 * so is safe to call on your main thread.
 *
 * <p>{@link #setBeamPushUris} and {@link #setBeamPushUrisCallback}
 * have priority over both {@link #setNdefPushMessage} and
 * {@link #setNdefPushMessageCallback}.
 *
 * <p>If {@link #setBeamPushUris} is called with a null Uri array,
 * and/or {@link #setBeamPushUrisCallback} is called with a null callback,
 * then the Uri push will be completely disabled for the specified activity(s).
 *
 * <p>Code example:
 * <pre>
 * protected void onCreate(Bundle savedInstanceState) {
 * super.onCreate(savedInstanceState);
 * NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
 * if (nfcAdapter == null) return;  // NFC not available on this device
 * nfcAdapter.setBeamPushUris(new Uri[] {uri1, uri2}, this);
 * }</pre>
 * And that is it. Only one call per activity is necessary. The Android
 * OS will automatically release its references to the Uri(s) and the
 * Activity object when it is destroyed if you follow this pattern.
 *
 * <p>If your Activity wants to dynamically supply Uri(s),
 * then set a callback using {@link #setBeamPushUrisCallback} instead
 * of using this method.
 *
 * <p class=""note"">Do not pass in an Activity that has already been through
 * {@link Activity#onDestroy}. This is guaranteed if you call this API
 * during {@link Activity#onCreate}.
 *
 * <p class=""note"">If this device does not support alternate transports
 * such as Bluetooth or WiFI, calling this method does nothing.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param uris an array of Uri(s) to push over Android Beam
 * @param activity activity for which the Uri(s) will be pushed
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated this feature is deprecated. File sharing can work using other technology like
 * Bluetooth.
 */
",-1,,[@java.lang.Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the addition of a check (`if (!sHasBeamFeature)`) followed by a return statement inside the synchronized block, which may prevent the method from further execution. However, since there are no changes in the existing control flow related to exception handling or return statements outside this addition, the change type is 4.","There is no Compatibility Issue because the method either throws an UnsupportedOperationException for lack of NFC feature (which is unchanged between versions) or simply returns without performing any further actions, and none of the other existing behaviors of the method have been altered. As such, no existing code paths lead to new exceptions or different return values."
976,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,28,29,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingDisplayCutout.get().equals(args.arg9) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe,
                    // about move to display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingDisplayCutout.get().equals(args.arg9) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingDisplayCutout.set((DisplayCutout) args.arg9);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeNavBar = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && framesChanged) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                handleWindowFocusChanged();
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from Autofill to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
            {
            }
        // fall through
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingStableInsets.equals(args.arg6) && mPendingDisplayCutout.get().equals(args.arg9) && mPendingVisibleInsets.equals(args.arg3) && mPendingOutsets.equals(args.arg7) && mPendingBackDropFrame.equals(args.arg8) && args.arg4 == null && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                boolean configChanged = false;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe,
                    // about move to display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                    configChanged = true;
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingOverscanInsets.equals(args.arg5) || !mPendingContentInsets.equals(args.arg2) || !mPendingStableInsets.equals(args.arg6) || !mPendingDisplayCutout.get().equals(args.arg9) || !mPendingVisibleInsets.equals(args.arg3) || !mPendingOutsets.equals(args.arg7);
                setFrame((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingStableInsets.set((Rect) args.arg6);
                mPendingDisplayCutout.set((DisplayCutout) args.arg9);
                mPendingVisibleInsets.set((Rect) args.arg3);
                mPendingOutsets.set((Rect) args.arg7);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeSystemBars = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && (framesChanged || configChanged)) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_INSETS_CHANGED:
            mInsetsController.onStateChanged((InsetsState) msg.obj);
            break;
        case MSG_INSETS_CONTROL_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInsetsController.onControlsChanged((InsetsSourceControl[]) args.arg2);
                mInsetsController.onStateChanged((InsetsState) args.arg1);
                break;
            }
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mTmpFrame.left = l;
                mTmpFrame.right = l + w;
                mTmpFrame.top = t;
                mTmpFrame.bottom = t + h;
                setFrame(mTmpFrame);
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                handleWindowFocusChanged();
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from Autofill to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = mContext.getSystemService(InputMethodManager.class);
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
            {
            }
        // fall through
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            {
                systemGestureExclusionChanged();
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
977,<android.accessibilityservice.AccessibilityButtonController: boolean isAccessibilityButtonAvailable()>,28,29,<android.accessibilityservice.AccessibilityButtonController: boolean isAccessibilityButtonAvailable()>,<android.accessibilityservice.AccessibilityButtonController: boolean isAccessibilityButtonAvailable()>,0,"{
    try {
        return mServiceConnection.isAccessibilityButtonAvailable();
    } catch (RemoteException re) {
        Slog.w(LOG_TAG, ""Failed to get accessibility button availability."", re);
        re.rethrowFromSystemServer();
        return false;
    }
}","{
    if (mServiceConnection != null) {
        try {
            return mServiceConnection.isAccessibilityButtonAvailable();
        } catch (RemoteException re) {
            Slog.w(LOG_TAG, ""Failed to get accessibility button availability."", re);
            re.rethrowFromSystemServer();
            return false;
        }
    }
    return false;
}",1,"/**
 * Retrieves whether the accessibility button in the system's navigation area is
 * available to the calling service.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 * </p>
 *
 * @return {@code true} if the accessibility button in the system's navigation area is
 * available to the calling service, {@code false} otherwise
 */
","/**
 * Retrieves whether the accessibility button in the system's navigation area is
 * available to the calling service.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 * </p>
 *
 * @return {@code true} if the accessibility button in the system's navigation area is
 * available to the calling service, {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early version of the implementation doesn't check if mServiceConnection is null before calling isAccessibilityButtonAvailable(), resulting in a NullPointerException if mServiceConnection were null. In the late version, a null check is added before the try-catch block which means a NullPointerException will not be thrown but rather a false will be returned if mServiceConnection is null. Additionally, an extra return false statement was added outside of the try-catch block, which is redundant with the existing return within the catch block. Therefore, the changes are in the control dependency and another statement has also been changed, which are classified as types 3 and 4, respectively.","No Compatibility Issue arises from this change, as the behaviour of the implementation remains consistent for callers regardless of whether mServiceConnection is null or encounters a RemoteException. The addition of the null check for mServiceConnection does not affect the observable behavior of the method when called by existing clients, as the result would either be a false return value or a thrown RemoteException, which is already handled in the method. Thus, the CI type is 0."
978,<android.database.DefaultDatabaseErrorHandler: void onCorruption(SQLiteDatabase)>,28,29,<android.database.DefaultDatabaseErrorHandler: void onCorruption(SQLiteDatabase)>,<android.database.DefaultDatabaseErrorHandler: void onCorruption(SQLiteDatabase)>,0,"{
    Log.e(TAG, ""Corruption reported by sqlite on database: "" + dbObj.getPath());
    // is the corruption detected even before database could be 'opened'?
    if (!dbObj.isOpen()) {
        // database files are not even openable. delete this database file.
        // NOTE if the database has attached databases, then any of them could be corrupt.
        // and not deleting all of them could cause corrupted database file to remain and
        // make the application crash on database open operation. To avoid this problem,
        // the application should provide its own {@link DatabaseErrorHandler} impl class
        // to delete ALL files of the database (including the attached databases).
        deleteDatabaseFile(dbObj.getPath());
        return;
    }
    List<Pair<String, String>> attachedDbs = null;
    try {
        // before that, get the attached database list first.
        try {
            attachedDbs = dbObj.getAttachedDbs();
        } catch (SQLiteException e) {
        /* ignore */
        }
        try {
            dbObj.close();
        } catch (SQLiteException e) {
        /* ignore */
        }
    } finally {
        // Delete all files of this corrupt database and/or attached databases
        if (attachedDbs != null) {
            for (Pair<String, String> p : attachedDbs) {
                deleteDatabaseFile(p.second);
            }
        } else {
            // attachedDbs = null is possible when the database is so corrupt that even
            // ""PRAGMA database_list;"" also fails. delete the main database file
            deleteDatabaseFile(dbObj.getPath());
        }
    }
}","{
    Log.e(TAG, ""Corruption reported by sqlite on database: "" + dbObj.getPath());
    SQLiteDatabase.wipeDetected(dbObj.getPath(), ""corruption"");
    // is the corruption detected even before database could be 'opened'?
    if (!dbObj.isOpen()) {
        // database files are not even openable. delete this database file.
        // NOTE if the database has attached databases, then any of them could be corrupt.
        // and not deleting all of them could cause corrupted database file to remain and
        // make the application crash on database open operation. To avoid this problem,
        // the application should provide its own {@link DatabaseErrorHandler} impl class
        // to delete ALL files of the database (including the attached databases).
        deleteDatabaseFile(dbObj.getPath());
        return;
    }
    List<Pair<String, String>> attachedDbs = null;
    try {
        // before that, get the attached database list first.
        try {
            attachedDbs = dbObj.getAttachedDbs();
        } catch (SQLiteException e) {
        /* ignore */
        }
        try {
            dbObj.close();
        } catch (SQLiteException e) {
        /* ignore */
        }
    } finally {
        // Delete all files of this corrupt database and/or attached databases
        if (attachedDbs != null) {
            for (Pair<String, String> p : attachedDbs) {
                deleteDatabaseFile(p.second);
            }
        } else {
            // attachedDbs = null is possible when the database is so corrupt that even
            // ""PRAGMA database_list;"" also fails. delete the main database file
            deleteDatabaseFile(dbObj.getPath());
        }
    }
}",1,"/**
 * defines the default method to be invoked when database corruption is detected.
 * @param dbObj the {@link SQLiteDatabase} object representing the database on which corruption
 * is detected.
 */
","/**
 * defines the default method to be invoked when database corruption is detected.
 * @param dbObj the {@link SQLiteDatabase} object representing the database on which corruption
 * is detected.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method now includes a call to SQLiteDatabase.wipeDetected(dbObj.getPath(), ""corruption""); this is an additional statement and a new method from SQLiteDatabase class, so the change type is 4 and 5. There are no return statement changes or exception handling changes.","While there is an additional method call to SQLiteDatabase.wipeDetected, it does not appear to affect the return value or exception handling of the onCorruption method. The method still continues to execute the same set of actions post calling wipeDetected and before it was added, and would not lead to compatibility issues as it doesn't change the contract of the onCorruption method, hence the CI type is 0."
979,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,28,29,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,0,"{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mId);
}","{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mId, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns {@link TextSelection} object.
 */
","/**
 * Builds and returns {@link TextSelection} object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,1,"The constructor invocation of TextSelection has an additional argument in the late version (mExtras == null ? Bundle.EMPTY : mExtras), which indicates a new return statement construction, so the code change type is 1.","The additional parameter in the constructor may result in a 'TextSelection' object with different content (specifically the 'mExtras' member variable), which leads to a potential different return value. Therefore, the CI type is 1."
982,"<android.appwidget.AppWidgetHostView: Rect getDefaultPaddingForWidget(Context,ComponentName,Rect)>",28,29,"<android.appwidget.AppWidgetHostView: Rect getDefaultPaddingForWidget(Context,ComponentName,Rect)>","<android.appwidget.AppWidgetHostView: Rect getDefaultPaddingForWidget(Context,ComponentName,Rect)>",0,"{
    ApplicationInfo appInfo = null;
    try {
        appInfo = context.getPackageManager().getApplicationInfo(component.getPackageName(), 0);
    } catch (NameNotFoundException e) {
    // if we can't find the package, ignore
    }
    return getDefaultPaddingForWidget(context, appInfo, padding);
}","{
    return getDefaultPaddingForWidget(context, padding);
}",1,"/**
 * As of ICE_CREAM_SANDWICH we are automatically adding padding to widgets targeting
 * ICE_CREAM_SANDWICH and higher. The new widget design guidelines strongly recommend
 * that widget developers do not add extra padding to their widgets. This will help
 * achieve consistency among widgets.
 *
 * Note: this method is only needed by developers of AppWidgetHosts. The method is provided in
 * order for the AppWidgetHost to account for the automatic padding when computing the number
 * of cells to allocate to a particular widget.
 *
 * @param context the current context
 * @param component the component name of the widget
 * @param padding Rect in which to place the output, if null, a new Rect will be allocated and
 * returned
 * @return default padding for this widget, in pixels
 */
","/**
 * As of ICE_CREAM_SANDWICH we are automatically adding padding to widgets targeting
 * ICE_CREAM_SANDWICH and higher. The new widget design guidelines strongly recommend
 * that widget developers do not add extra padding to their widgets. This will help
 * achieve consistency among widgets.
 *
 * Note: this method is only needed by developers of AppWidgetHosts. The method is provided in
 * order for the AppWidgetHost to account for the automatic padding when computing the number
 * of cells to allocate to a particular widget.
 *
 * @param context the current context
 * @param component the component name of the widget
 * @param padding Rect in which to place the output, if null, a new Rect will be allocated and
 * returned
 * @return default padding for this widget, in pixels
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late version of the method removed the code that retrieves `ApplicationInfo` and the exception handling code for `NameNotFoundException`, which means that the intermediary call to `getDefaultPaddingForWidget(context, appInfo, padding)` has been replaced with `getDefaultPaddingForWidget(context, padding)`. This changes not only the method signature being called, but also removes the dependency on the `component` parameter entirely. So the code change type is 1,5.","The removal of the `ApplicationInfo` usage and the passage of this object to the `getDefaultPaddingForWidget` method may result in different behavior of the application padding computation, potentially yielding a different `Rect` being returned. Hence, there could be a Compatibility Issue because of the potential for different return values as a result of this implementation change, thus the CI type is 1."
983,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitResourceMismatches()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitResourceMismatches()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitResourceMismatches()>,0,"{
    return disable(DETECT_RESOURCE_MISMATCH);
}","{
    return disable(DETECT_THREAD_RESOURCE_MISMATCH);
}",1,"/**
 * Disable detection of mismatches between defined resource types and getter calls.
 */
","/**
 * Disable detection of mismatches between defined resource types and getter calls.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from disable(DETECT_RESOURCE_MISMATCH) to disable(DETECT_THREAD_RESOURCE_MISMATCH), and the parameter of the disable() method is different, implying changes in the dependent API call. Therefore, the code change types are 1 (Return statement changed) and 5 (Dependent API changed).","This change in the return statement and the dependent API potentially causes the API to return a different value since the behavior of the `disable()` method could change based on the new parameter being passed. As a result, there is a Compatibility Issue caused by potential different return values (type 1)."
984,<android.view.View: void buildLayer()>,28,29,<android.view.View: void buildLayer()>,<android.view.View: void buildLayer()>,0,"{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    if (getWidth() == 0 || getHeight() == 0) {
        return;
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            updateDisplayListIfDirty();
            if (attachInfo.mThreadedRenderer != null && mRenderNode.isValid()) {
                attachInfo.mThreadedRenderer.buildLayer(mRenderNode);
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}","{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    if (getWidth() == 0 || getHeight() == 0) {
        return;
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            updateDisplayListIfDirty();
            if (attachInfo.mThreadedRenderer != null && mRenderNode.hasDisplayList()) {
                attachInfo.mThreadedRenderer.buildLayer(mRenderNode);
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}",1,"/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
","/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call changed from mRenderNode.isValid() to mRenderNode.hasDisplayList(), so the code change type is 5.","The change from mRenderNode.isValid() to mRenderNode.hasDisplayList() does not imply a difference in control flow or exception handling in the context of this method's functionality. This seems like an internal check to determine whether we can proceed with buildLayer operation. Unless the semantics of hasDisplayList() are different from isValid() in a way that would change the flow of the code execution, which is not indicated here, we would not expect a Compatibility Issue. Therefore, no Compatibility Issue has been detected in this context."
985,<android.app.VoiceInteractor: Request getActiveRequest(String)>,28,29,<android.app.VoiceInteractor: Request getActiveRequest(String)>,<android.app.VoiceInteractor: Request getActiveRequest(String)>,0,"{
    synchronized (mActiveRequests) {
        final int N = mActiveRequests.size();
        for (int i = 0; i < N; i++) {
            Request req = mActiveRequests.valueAt(i);
            if (name == req.getName() || (name != null && name.equals(req.getName()))) {
                return req;
            }
        }
    }
    return null;
}","{
    if (isDestroyed()) {
        Log.w(TAG, ""Cannot interact with a destroyed voice interactor"");
        return null;
    }
    synchronized (mActiveRequests) {
        final int N = mActiveRequests.size();
        for (int i = 0; i < N; i++) {
            Request req = mActiveRequests.valueAt(i);
            if (name == req.getName() || (name != null && name.equals(req.getName()))) {
                return req;
            }
        }
    }
    return null;
}",1,"/**
 * Return any currently active request that was submitted with the given name.
 *
 * @param name The name used to submit the request, as per
 * {@link #submitRequest(android.app.VoiceInteractor.Request, String)}.
 * @return Returns the active request with that name, or null if there was none.
 */
","/**
 * Return any currently active request that was submitted with the given name.
 *
 * @param name The name used to submit the request, as per
 * {@link #submitRequest(android.app.VoiceInteractor.Request, String)}.
 * @return Returns the active request with that name, or null if there was none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The late version has an additional check for `isDestroyed()` at the beginning, and it logs a warning and returns `null` if the interactor is destroyed. This is a change in control dependency (3) but it does not remove any existing behavior or paths that would have previously returned a non-null value or thrown an exception.","There is no compatibility issue because the additional check only adds a new condition that would return `null`, which is a value that could also have been returned in the early version if the name did not match any active requests. The API behavior is consistent when `isDestroyed()` returns `false`, which would be the majority of operational use cases. Therefore, the change does not introduce a new return value or type nor a new exception that wasn't previously possible from the method's operation."
986,<android.accessibilityservice.AccessibilityService.MagnificationController: Region getMagnificationRegion()>,28,29,<android.accessibilityservice.AccessibilityService.MagnificationController: Region getMagnificationRegion()>,<android.accessibilityservice.AccessibilityService.MagnificationController: Region getMagnificationRegion()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationRegion();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain magnified region"", re);
            re.rethrowFromSystemServer();
        }
    }
    return Region.obtain();
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationRegion(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain magnified region"", re);
            re.rethrowFromSystemServer();
        }
    }
    return Region.obtain();
}",1,"/**
 * Returns the region of the screen currently active for magnification. Changes to
 * magnification scale and center only affect this portion of the screen. The rest of the
 * screen, for example input methods, cannot be magnified. This region is relative to the
 * unscaled screen and is independent of the scale and center point.
 * <p>
 * The returned region will be empty if magnification is not active. Magnification is active
 * if magnification gestures are enabled or if a service is running that can control
 * magnification.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return an empty region.
 *
 * @return the region of the screen currently active for magnification, or an empty region
 * if magnification is not active.
 */
","/**
 * Returns the region of the screen currently active for magnification. Changes to
 * magnification scale and center only affect this portion of the screen. The rest of the
 * screen, for example input methods, cannot be magnified. This region is relative to the
 * unscaled screen and is independent of the scale and center point.
 * <p>
 * The returned region will be empty if magnification is not active. Magnification is active
 * if magnification gestures are enabled or if a service is running that can control
 * magnification.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return an empty region.
 *
 * @return the region of the screen currently active for magnification, or an empty region
 * if magnification is not active.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method invocation `connection.getMagnificationRegion()` has been changed to `connection.getMagnificationRegion(mDisplayId)` with an additional parameter, therefore the code change type is 5.","Even though the method signature for `getMagnificationRegion` now includes an additional parameter, the return type is still `Region`, and there's no indication that the behavior apart from the input parameter has changed. Hence, as per the definitions provided, this does not indicate a compatibility issue as the change seems backward compatible. The method still catches a `RemoteException` and handles it in the same way as before. Thus, the CI type is 0."
987,<android.view.WindowInsets: boolean equals(Object)>,28,29,<android.view.WindowInsets: boolean equals(Object)>,<android.view.WindowInsets: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || !(o instanceof WindowInsets))
        return false;
    WindowInsets that = (WindowInsets) o;
    return mIsRound == that.mIsRound && mAlwaysConsumeNavBar == that.mAlwaysConsumeNavBar && mSystemWindowInsetsConsumed == that.mSystemWindowInsetsConsumed && mWindowDecorInsetsConsumed == that.mWindowDecorInsetsConsumed && mStableInsetsConsumed == that.mStableInsetsConsumed && mDisplayCutoutConsumed == that.mDisplayCutoutConsumed && Objects.equals(mSystemWindowInsets, that.mSystemWindowInsets) && Objects.equals(mWindowDecorInsets, that.mWindowDecorInsets) && Objects.equals(mStableInsets, that.mStableInsets) && Objects.equals(mDisplayCutout, that.mDisplayCutout);
}","{
    if (this == o)
        return true;
    if (o == null || !(o instanceof WindowInsets))
        return false;
    WindowInsets that = (WindowInsets) o;
    return mIsRound == that.mIsRound && mAlwaysConsumeSystemBars == that.mAlwaysConsumeSystemBars && mSystemWindowInsetsConsumed == that.mSystemWindowInsetsConsumed && mStableInsetsConsumed == that.mStableInsetsConsumed && mDisplayCutoutConsumed == that.mDisplayCutoutConsumed && Arrays.equals(mTypeInsetsMap, that.mTypeInsetsMap) && Arrays.equals(mTypeMaxInsetsMap, that.mTypeMaxInsetsMap) && Arrays.equals(mTypeVisibilityMap, that.mTypeVisibilityMap) && Objects.equals(mDisplayCutout, that.mDisplayCutout);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The variable name has changed from mAlwaysConsumeNavBar to mAlwaysConsumeSystemBars and the method used for comparison has changed from Objects.equals() to Arrays.equals() for certain fields. Additionally, some fields that were compared in the early version are not present in the late version. These include mWindowDecorInsetsConsumed, mWindowDecorInsets, and mStableInsets while new fields mTypeInsetsMap, mTypeMaxInsetsMap, and mTypeVisibilityMap are present in the late version. Therefore, the code change types are 1 and 4.","The changes in the fields of the WindowInsets object being compared can potentially cause the equals method to return different results for the same input when compared across versions. Hence, this can be classified as a CI due to the potential for different return values, making the CI type 1."
988,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,28,29,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,<android.widget.CheckedTextView: Mode getCheckMarkTintMode()>,0,"{
    return mCheckMarkTintMode;
}","{
    return mCheckMarkBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null;
}",1,"/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
","/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the late implementation has changed to return a value based on a conditional statement that converts `mCheckMarkBlendMode` to a `PorterDuffMode`, and the dependent API `BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode)` is also used. This constitutes changes of type 1 and 5.","The change in the return statement indicates a potential difference in the returned value or type between the two versions. Specifically, the value returned in the late version is now contingent on a conversion method, which can lead to a different value being returned compared to the early version. The CI type is 1."
989,<android.app.ActivityView.SurfaceCallback: void surfaceDestroyed(SurfaceHolder)>,28,29,<android.app.ActivityView.SurfaceCallback: void surfaceDestroyed(SurfaceHolder)>,<android.app.ActivityView.SurfaceCallback: void surfaceDestroyed(SurfaceHolder)>,0,"{
    mSurface.release();
    mSurface = null;
    if (mVirtualDisplay != null) {
        mVirtualDisplay.setSurface(null);
    }
    cleanTapExcludeRegion();
}","{
    if (mVirtualDisplay != null) {
        mVirtualDisplay.setDisplayState(false);
    }
    clearActivityViewGeometryForIme();
    cleanTapExcludeRegion();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes in the implementation between early and late versions: a call to mSurface.release() and setting mSurface to null are removed, and there is also a change from mVirtualDisplay.setSurface(null) to mVirtualDisplay.setDisplayState(false), in addition to replacing cleanTapExcludeRegion(); with clearActivityViewGeometryForIme(); and there's also a method call order change. These changes consist of a control dependency change and other statement changed (as the operations performed on mSurface and mVirtualDisplay are different), signifying a 3,4 code change type.","Despite removing and changing some method calls, all these changes do not introduce any new behavior regarding what the API method returns (since it's a void method) or the exceptions it might throw. Hence, there's no Compatibility Issue, which corresponds to 0."
991,<android.util.Half: short parseHalf(String)>,28,29,<android.util.Half: short parseHalf(String)>,<android.util.Half: short parseHalf(String)>,0,"{
    return toHalf(FloatingDecimal.parseFloat(s));
}","{
    return toHalf(Float.parseFloat(s));
}",1,"/**
 * Returns the half-precision float value represented by the specified string.
 * Calling this method is equivalent to calling
 * <code>toHalf(Float.parseString(h))</code>. See {@link Float#valueOf(String)}
 * for more information on the format of the string representation.
 *
 * @param s The string to be parsed
 * @return A half-precision float value represented by the string
 * @throws NumberFormatException if the string does not contain a parsable
 * half-precision float value
 */
","/**
 * Returns the half-precision float value represented by the specified string.
 * Calling this method is equivalent to calling
 * <code>toHalf(Float.parseString(h))</code>. See {@link Float#valueOf(String)}
 * for more information on the format of the string representation.
 *
 * @param s The string to be parsed
 * @return A half-precision float value represented by the string
 * @throws NumberFormatException if the string does not contain a parsable
 * half-precision float value
 */
",-1,[@HalfFloat],[@HalfFloat],-1,-1,-1,-1,-1,-1,5,0,"The change is in the use of a dependent API where 'FloatingDecimal.parseFloat(s)' has been replaced with 'Float.parseFloat(s)'. Therefore, the code change type is 5.","There is no Compatibility Issue since both 'FloatingDecimal.parseFloat(s)' and 'Float.parseFloat(s)' return a float which is then processed by the same 'toHalf' method, thus preserving the behavior and the output between versions."
993,<android.view.autofill.AutofillManager: boolean isAutofillSupported()>,28,29,<android.view.autofill.AutofillManager: boolean isAutofillSupported()>,<android.view.autofill.AutofillManager: boolean isAutofillSupported()>,0,"{
    if (mService == null)
        return false;
    try {
        return mService.isServiceSupported(mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null)
        return false;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isServiceSupported(mContext.getUserId(), receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@code true} if autofill is supported by the current device and
 * is supported for this user.
 *
 * <p>Autofill is typically supported, but it could be unsupported in cases like:
 * <ol>
 * <li>Low-end devices.
 * <li>Device policy rules that forbid its usage.
 * </ol>
 */
","/**
 * Returns {@code true} if autofill is supported by the current device and
 * is supported for this user.
 *
 * <p>Autofill is typically supported, but it could be unsupported in cases like:
 * <ol>
 * <li>Low-end devices.
 * <li>Device policy rules that forbid its usage.
 * </ol>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the API has undergone changes involving a new statement 'final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);', a change in the method invocation from 'mService.isServiceSupported(mContext.getUserId())' to 'mService.isServiceSupported(mContext.getUserId(), receiver)', and the addition of a check on the receiver's result 'receiver.getIntResult() == 1'. These modifications collectively contribute to the categories 1 (Return statement changed), 4 (Other statement changed), and 5 (Dependent API changed).","The return value of the API could potentially be different between versions, as the previous implementation directly returned the boolean result of 'mService.isServiceSupported', whereas the new version translates the int result from 'receiver.getIntResult()' into a boolean. This constitutes a CI type 1 due to the potential difference in return values."
996,"<android.widget.AdapterView: void onProvideAutofillStructure(ViewStructure,int)>",28,29,"<android.widget.AdapterView: void onProvideAutofillStructure(ViewStructure,int)>","<android.widget.AdapterView: void onProvideAutofillStructure(ViewStructure,int)>",0,"{
    super.onProvideAutofillStructure(structure, flags);
    final Adapter adapter = getAdapter();
    if (adapter == null)
        return;
    final CharSequence[] options = adapter.getAutofillOptions();
    if (options != null) {
        structure.setAutofillOptions(options);
    }
}","{
    super.onProvideAutofillStructure(structure, flags);
}",1,"/**
 * {@inheritDoc}
 *
 * <p>It also sets the autofill options in the structure; when overridden, it should set it as
 * well, either explicitly by calling {@link ViewStructure#setAutofillOptions(CharSequence[])}
 * or implicitly by calling {@code super.onProvideAutofillStructure(structure, flags)}.
 */
","/**
 * {@inheritDoc}
 *
 * <p>It also sets the autofill options in the structure; when overridden, it should set it as
 * well, either explicitly by calling {@link ViewStructure#setAutofillOptions(CharSequence[])}
 * or implicitly by calling {@code super.onProvideAutofillStructure(structure, flags)}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late version of the method has been simplified, and substantial code involving interaction with adapter for autofill options has been removed, but the early and the late version will return nothing as it is a void method, so the change type is 4.","Despite code being removed, since the method return type is void, the behaviors related to return statements are not affected. There is also no change in exception handling. There's no Compatibility Issue since the removed code does not impact the return types or exception handlings; it merely modifies the autofill behavior which is not in the scope of Compatibility Issue types defined."
997,<android.view.GestureDetector.GestureHandler: void handleMessage(Message)>,28,29,<android.view.GestureDetector.GestureHandler: void handleMessage(Message)>,<android.view.GestureDetector.GestureHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case SHOW_PRESS:
            mListener.onShowPress(mCurrentDownEvent);
            break;
        case LONG_PRESS:
            dispatchLongPress();
            break;
        case TAP:
            // If the user's finger is still down, do not count it as a tap
            if (mDoubleTapListener != null) {
                if (!mStillDown) {
                    mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent);
                } else {
                    mDeferConfirmSingleTap = true;
                }
            }
            break;
        default:
            // never
            throw new RuntimeException(""Unknown message "" + msg);
    }
}","{
    switch(msg.what) {
        case SHOW_PRESS:
            mListener.onShowPress(mCurrentDownEvent);
            break;
        case LONG_PRESS:
            recordGestureClassification(msg.arg1);
            dispatchLongPress();
            break;
        case TAP:
            // If the user's finger is still down, do not count it as a tap
            if (mDoubleTapListener != null) {
                if (!mStillDown) {
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
                    mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent);
                } else {
                    mDeferConfirmSingleTap = true;
                }
            }
            break;
        default:
            // never
            throw new RuntimeException(""Unknown message "" + msg);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a control dependency change with additional calls to `recordGestureClassification(msg.arg1)` and `recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP)` inside the `LONG_PRESS` and `TAP` cases respectively, which falls under ""Other statement changed"". The additional statements are recording gesture classifications but do not affect the return value or the exceptions thrown by the method, so the code change types are 3,4.","Despite adding new functionality to record the gesture classification, there are no changes that affect the return type or exceptions thrown directly by this method. The new code does not change the control flow in such a way that would cause a Compatibility Issue because it does not involve returning a different value or throwing a different exception. Therefore, there is no Compatibility Issue, hence the CI type is 0."
998,<android.view.autofill.AutofillManager: boolean hasEnabledAutofillServices()>,28,29,<android.view.autofill.AutofillManager: boolean hasEnabledAutofillServices()>,<android.view.autofill.AutofillManager: boolean hasEnabledAutofillServices()>,0,"{
    if (mService == null)
        return false;
    try {
        return mService.isServiceEnabled(mContext.getUserId(), mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null)
        return false;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isServiceEnabled(mContext.getUserId(), mContext.getPackageName(), receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@code true} if the calling application provides a {@link AutofillService} that is
 * enabled for the current user, or {@code false} otherwise.
 */
","/**
 * Returns {@code true} if the calling application provides a {@link AutofillService} that is
 * enabled for the current user, or {@code false} otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,There are multiple changes between the versions:,"- The 'mService.isServiceEnabled' method call has a new parameter added (receiver), indicating a change in the method signature (dependent API changed)."
999,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,28,29,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change is in the lock object used in the synchronized block: from `mDeviceBusy` to `mDeviceBusyLock`. This is an internal synchronization detail change and is classified as other statement changed (4).,"There is no Compatibility Issue because the public behavior of the API has not changed. The lock object's name change does not affect the method's external behavior, return values, or exception handling. Therefore, the API would behave identically from an external point of view; hence, no Compatibility Issue arises (0)."
1000,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",28,29,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>","<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",0,"{
    if (!restarting) {
        doFinishInput();
    }
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mWindowVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    }
}","{
    if (!restarting) {
        doFinishInput();
    }
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mDecorViewVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    } else if (mCanPreRender && mInputEditorInfo != null && mStartedInputConnection != null) {
        // pre-render IME window and keep it invisible.
        if (DEBUG)
            Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName);
        if (mInShowWindow) {
            Log.w(TAG, ""Re-entrance in to showWindow"");
            return;
        }
        mDecorViewWasVisible = mDecorViewVisible;
        mInShowWindow = true;
        startViews(prepareWindow(true));
        // compute visibility
        mIsPreRendered = true;
        onPreRenderedWindowVisibilityChanged(false);
        // When IME is not pre-rendered, this will actually show the IME.
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
        maybeNotifyPreRendered();
        mDecorViewWasVisible = true;
        mInShowWindow = false;
    } else {
        mIsPreRendered = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed, and new statements are introduced including 'else if' clause and new logic within the block. Therefore, the code change types are 3,4.","Although the control flow and added statements present changes to the method's implementation, they occur within a context that does not affect the method's signature or its expected behavior from a caller's perspective. The method signature remains void, and there's no change in exception throwing or return types, as the method does not return any value and there are no new exceptions being thrown. The method's expected behavior, in this case, starting input, remains consistent. Thus, no compatibility issue is detected."
1001,<android.view.ScaleGestureDetector: float getScaleFactor()>,28,29,<android.view.ScaleGestureDetector: float getScaleFactor()>,<android.view.ScaleGestureDetector: float getScaleFactor()>,0,"{
    if (inAnchoredScaleMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}","{
    if (inAnchoredScaleMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= mSpanSlop ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}",1,"/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
","/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The condition in the return statement within the if block changed from `mPrevSpan <= 0` to `mPrevSpan <= mSpanSlop`. This leads to a potential different return value, thus the code change type is 1.","As the return condition has changed from `mPrevSpan <= 0` to `mPrevSpan <= mSpanSlop`, it can potentially return a different value when `mPrevSpan` is between 0 and `mSpanSlop`. This means the output of the method could differ, causing a CI type of 1."
1002,<android.util.SparseIntArray: int keyAt(int)>,28,29,<android.util.SparseIntArray: int keyAt(int)>,<android.util.SparseIntArray: int keyAt(int)>,0,"{
    return mKeys[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return mKeys[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseIntArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the key from the <code>index</code>th key-value mapping that this
 * SparseIntArray stores.
 *
 * <p>The keys corresponding to indices in ascending order are guaranteed to
 * be in ascending order, e.g., <code>keyAt(0)</code> will return the
 * smallest key and <code>keyAt(size()-1)</code> will return the largest
 * key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An if statement that includes an exception throw has been introduced, so the code change type is 2,3.","The new exception handling statement could throw an ArrayIndexOutOfBoundsException that was not present in the early version under certain conditions. This represents a change in exception behavior, thus the CI type is 2."
1003,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectNetwork()>,28,29,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectNetwork()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder detectNetwork()>,0,"{
    return enable(DETECT_NETWORK);
}","{
    return enable(DETECT_THREAD_NETWORK);
}",1,"/**
 * Enable detection of network operations.
 */
","/**
 * Enable detection of network operations.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from enable(DETECT_NETWORK) to enable(DETECT_THREAD_NETWORK), involving a change in the parameter being passed to the enable method, indicating a difference in API usage which is classified under code change type 1. Additionally, the method being invoked has changed, suggesting a change in the dependent API, hence code change type 5.","Since the enable method's parameter has changed, this could potentially cause the API to return a different value or perform a different action than what was previously expected. As such, there is a Compatibility Issue of type 1, due to the potential for different return values or behavior of the API."
1004,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByViewId(String)>,28,29,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByViewId(String)>,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByViewId(String)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByViewId(mConnectionId, mWindowId, mSourceNodeId, viewId);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByViewId(mConnectionId, mWindowId, mSourceNodeId, viewId);
}",1,"/**
 * Finds {@link AccessibilityNodeInfo}s by the fully qualified view id's resource
 * name where a fully qualified id is of the from ""package:id/id_resource_name"".
 * For example, if the target application's package is ""foo.bar"" and the id
 * resource name is ""baz"", the fully qualified resource id is ""foo.bar:id/baz"".
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * <p>
 * <strong>Note:</strong> The primary usage of this API is for UI test automation
 * and in order to report the fully qualified view id if an {@link AccessibilityNodeInfo}
 * the client has to set the {@link AccessibilityServiceInfo#FLAG_REPORT_VIEW_IDS}
 * flag when configuring his {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param viewId The fully qualified resource name of the view id to find.
 * @return A list of node info.
 */
","/**
 * Finds {@link AccessibilityNodeInfo}s by the fully qualified view id's resource
 * name where a fully qualified id is of the from ""package:id/id_resource_name"".
 * For example, if the target application's package is ""foo.bar"" and the id
 * resource name is ""baz"", the fully qualified resource id is ""foo.bar:id/baz"".
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * <p>
 * <strong>Note:</strong> The primary usage of this API is for UI test automation
 * and in order to report the fully qualified view id if an {@link AccessibilityNodeInfo}
 * the client has to set the {@link AccessibilityServiceInfo#FLAG_REPORT_VIEW_IDS}
 * flag when configuring his {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 *
 * @param viewId The fully qualified resource name of the view id to find.
 * @return A list of node info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The if condition statement's function parameter has been changed from mSourceNodeId to (mConnectionId, mWindowId, mSourceNodeId), and a local variable's (client) initialization did not change but the method called inside the condition did. So, these changes include Control dependency changed (3), Other statement changed (4), and Dependent API changed (5).","There's no new exception handling or return value change, the change is internal to the method logic and the return type and exception handling of the method did not change. Therefore, no compatibility issue arises due to the mentioned changes, so the CI type is 0."
1006,"<android.database.sqlite.SQLiteConnection.OperationLog: int beginOperation(String,String,Object[])>",28,29,"<android.database.sqlite.SQLiteConnection.OperationLog: int beginOperation(String,String,Object[])>","<android.database.sqlite.SQLiteConnection.OperationLog: int beginOperation(String,String,Object[])>",0,"{
    synchronized (mOperations) {
        final int index = (mIndex + 1) % MAX_RECENT_OPERATIONS;
        Operation operation = mOperations[index];
        if (operation == null) {
            operation = new Operation();
            mOperations[index] = operation;
        } else {
            operation.mFinished = false;
            operation.mException = null;
            if (operation.mBindArgs != null) {
                operation.mBindArgs.clear();
            }
        }
        operation.mStartWallTime = System.currentTimeMillis();
        operation.mStartTime = SystemClock.uptimeMillis();
        operation.mKind = kind;
        operation.mSql = sql;
        if (bindArgs != null) {
            if (operation.mBindArgs == null) {
                operation.mBindArgs = new ArrayList<Object>();
            } else {
                operation.mBindArgs.clear();
            }
            for (int i = 0; i < bindArgs.length; i++) {
                final Object arg = bindArgs[i];
                if (arg != null && arg instanceof byte[]) {
                    // Don't hold onto the real byte array longer than necessary.
                    operation.mBindArgs.add(EMPTY_BYTE_ARRAY);
                } else {
                    operation.mBindArgs.add(arg);
                }
            }
        }
        operation.mCookie = newOperationCookieLocked(index);
        if (Trace.isTagEnabled(Trace.TRACE_TAG_DATABASE)) {
            Trace.asyncTraceBegin(Trace.TRACE_TAG_DATABASE, operation.getTraceMethodName(), operation.mCookie);
        }
        mIndex = index;
        return operation.mCookie;
    }
}","{
    mResultLong = Long.MIN_VALUE;
    mResultString = null;
    synchronized (mOperations) {
        final int index = (mIndex + 1) % MAX_RECENT_OPERATIONS;
        Operation operation = mOperations[index];
        if (operation == null) {
            operation = new Operation();
            mOperations[index] = operation;
        } else {
            operation.mFinished = false;
            operation.mException = null;
            if (operation.mBindArgs != null) {
                operation.mBindArgs.clear();
            }
        }
        operation.mStartWallTime = System.currentTimeMillis();
        operation.mStartTime = SystemClock.uptimeMillis();
        operation.mKind = kind;
        operation.mSql = sql;
        operation.mPath = mPool.getPath();
        operation.mResultLong = Long.MIN_VALUE;
        operation.mResultString = null;
        if (bindArgs != null) {
            if (operation.mBindArgs == null) {
                operation.mBindArgs = new ArrayList<Object>();
            } else {
                operation.mBindArgs.clear();
            }
            for (int i = 0; i < bindArgs.length; i++) {
                final Object arg = bindArgs[i];
                if (arg != null && arg instanceof byte[]) {
                    // Don't hold onto the real byte array longer than necessary.
                    operation.mBindArgs.add(EMPTY_BYTE_ARRAY);
                } else {
                    operation.mBindArgs.add(arg);
                }
            }
        }
        operation.mCookie = newOperationCookieLocked(index);
        if (Trace.isTagEnabled(Trace.TRACE_TAG_DATABASE)) {
            Trace.asyncTraceBegin(Trace.TRACE_TAG_DATABASE, operation.getTraceMethodName(), operation.mCookie);
        }
        mIndex = index;
        return operation.mCookie;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two new assignments have been added at the start of the Late_Implementation (`mResultLong = Long.MIN_VALUE; mResultString = null;`), and there are two more assignments in the middle (`operation.mPath = mPool.getPath(); operation.mResultLong = Long.MIN_VALUE; operation.mResultString = null;`). Since these new statements are assignments that do not affect the return value or exception handling of the method, the code change type is 4.","There is no Compatibility Issue detected because the added assignments do not impact the operation's returned cookie value (`operation.mCookie`). The return value remains unaffected by these changes, nor is there a change in the exception handling. The execution flow related to how the cookie is derived and returned is essentially the same."
1007,<android.app.Notification.Builder: int resolveNeutralColor()>,28,29,<android.app.Notification.Builder: int resolveNeutralColor()>,<android.app.Notification.Builder: int resolveNeutralColor()>,0,"{
    if (mNeutralColor != COLOR_INVALID) {
        return mNeutralColor;
    }
    int background = mContext.getColor(com.android.internal.R.color.notification_material_background_color);
    mNeutralColor = NotificationColorUtil.resolveDefaultColor(mContext, background);
    if (Color.alpha(mNeutralColor) < 255) {
        // alpha doesn't go well for color filters, so let's blend it manually
        mNeutralColor = NotificationColorUtil.compositeColors(mNeutralColor, background);
    }
    return mNeutralColor;
}","{
    if (mNeutralColor != COLOR_INVALID) {
        return mNeutralColor;
    }
    int background = mContext.getColor(com.android.internal.R.color.notification_material_background_color);
    mNeutralColor = ContrastColorUtil.resolveDefaultColor(mContext, background, mInNightMode);
    if (Color.alpha(mNeutralColor) < 255) {
        // alpha doesn't go well for color filters, so let's blend it manually
        mNeutralColor = ContrastColorUtil.compositeColors(mNeutralColor, background);
    }
    return mNeutralColor;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,There is a change in the method that is used to calculate 'mNeutralColor'. It's changed from NotificationColorUtil to ContrastColorUtil and also a new parameter 'mInNightMode' is included in the method call. These represent the dependent API changes (5) and other statement changes (4).,"The internal implementation details on how 'mNeutralColor' is computed have changed, but this does not necessarily result in a different behavior that would be visible to the code calling the resolveNeutralColor() method, provided that the ContrastColorUtil's resolveDefaultColor and compositeColors methods are meant to behave the same way as their NotificationColorUtil counterparts with respect to the return value. Therefore, there is No Compatibility Issue (0). The change is internal and does not affect the return value in a way that is visible to the caller, assuming backward compatibility in the utility methods themselves."
1008,<android.inputmethodservice.InputMethodService: int getInputMethodWindowRecommendedHeight()>,28,29,<android.inputmethodservice.InputMethodService: int getInputMethodWindowRecommendedHeight()>,<android.inputmethodservice.InputMethodService: int getInputMethodWindowRecommendedHeight()>,0,"{
    return mImm.getInputMethodWindowVisibleHeight();
}","{
    Log.w(TAG, ""getInputMethodWindowRecommendedHeight() is deprecated and now always returns 0."" + "" Do not use this method."");
    return 0;
}",1,"/**
 * @return The recommended height of the input method window.
 * An IME author can get the last input method's height as the recommended height
 * by calling this in
 * {@link android.inputmethodservice.InputMethodService#onStartInputView(EditorInfo, boolean)}.
 * If you don't need to use a predefined fixed height, you can avoid the window-resizing of IME
 * switching by using this value as a visible inset height. It's efficient for the smooth
 * transition between different IMEs. However, note that this may return 0 (or possibly
 * unexpectedly low height). You should thus avoid relying on the return value of this method
 * all the time. Please make sure to use a reasonable height for the IME.
 */
","/**
 * Aimed to return the previous input method's {@link Insets#contentTopInsets}, but its actual
 * semantics has never been well defined.
 *
 * <p>Note that the previous document clearly mentioned that this method could return {@code 0}
 * at any time for whatever reason.  Now this method is just always returning {@code 0}.</p>
 *
 * @return on Android {@link android.os.Build.VERSION_CODES#Q} and later devices this method
 * always returns {@code 0}
 * @deprecated the actual behavior of this method has never been well defined.  You cannot use
 * this method in a reliable and predictable way
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has changed with an added Log warning and a change in the return value from a dynamic height (mImm.getInputMethodWindowVisibleHeight()) to a fixed value (0). Additionally, there's the introduction of a deprecation annotation in the late version. Hence, the change types are 1 (return statement changed) and 4 (other statement changed).","Since the late version of the method always returns a fixed value (0) irrespective of the previous calculations or state, this will lead to a potential different return value when compared to the early version that computed the value. The method's behavior has changed significantly due to the modification in the return value, and because of this, there is a CI of type 1 (Compatibility Issue caused by potential different return values). The addition of the deprecation annotation and the logging statement does not directly cause a compatibility issue in terms of changing the behavior or the return value of the method."
1009,<android.os.ConditionVariable: boolean block(long)>,28,29,<android.os.ConditionVariable: boolean block(long)>,<android.os.ConditionVariable: boolean block(long)>,0,"{
    // this code for the common case.
    if (timeout != 0) {
        synchronized (this) {
            long now = System.currentTimeMillis();
            long end = now + timeout;
            while (!mCondition && now < end) {
                try {
                    this.wait(end - now);
                } catch (InterruptedException e) {
                }
                now = System.currentTimeMillis();
            }
            return mCondition;
        }
    } else {
        this.block();
        return true;
    }
}","{
    // this code for the common case.
    if (timeoutMs != 0) {
        synchronized (this) {
            long now = SystemClock.elapsedRealtime();
            long end = now + timeoutMs;
            while (!mCondition && now < end) {
                try {
                    this.wait(end - now);
                } catch (InterruptedException e) {
                }
                now = SystemClock.elapsedRealtime();
            }
            return mCondition;
        }
    } else {
        this.block();
        return true;
    }
}",1,"/**
 * Block the current thread until the condition is opened or until
 * timeout milliseconds have passed.
 *
 * <p>
 * If the condition is already opened, return immediately.
 *
 * @param timeout the maximum time to wait in milliseconds.
 *
 * @return true if the condition was opened, false if the call returns
 * because of the timeout.
 */
","/**
 * Block the current thread until the condition is opened or until
 * timeoutMs milliseconds have passed.
 *
 * <p>
 * If the condition is already opened, return immediately.
 *
 * @param timeoutMs the maximum time to wait in milliseconds.
 *
 * @return true if the condition was opened, false if the call returns
 * because of the timeout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists of replacing `System.currentTimeMillis()` with `SystemClock.elapsedRealtime()` to calculate the 'now' variable, which is a change of other statements (type 4).","This does not lead to a compatibility issue because both `System.currentTimeMillis()` and `SystemClock.elapsedRealtime()` measure time in milliseconds, and the logic of the method has not changed. The method still calculates a duration and waits the same amount of time before re-evaluating the condition or returning. As a result, the behavior of the API is consistent, and no CI is detected (type 0)."
1010,"<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>",28,29,"<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>","<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>",0,"{
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        mTmpCursorRect.set(left, top, right, bottom);
        if (!mCursorRect.equals(mTmpCursorRect)) {
            if (DEBUG)
                Log.d(TAG, ""updateCursor"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""CURSOR CHANGE: "" + mCurMethod);
                mCurMethod.updateCursor(mTmpCursorRect);
                mCursorRect.set(mTmpCursorRect);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursor(view, left, top, right, bottom);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        mTmpCursorRect.set(left, top, right, bottom);
        if (!mCursorRect.equals(mTmpCursorRect)) {
            if (DEBUG)
                Log.d(TAG, ""updateCursor"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""CURSOR CHANGE: "" + mCurMethod);
                mCurMethod.updateCursor(mTmpCursorRect);
                mCursorRect.set(mTmpCursorRect);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}",1,"/**
 * Report the current cursor location in its window.
 *
 * @deprecated Use {@link #updateCursorAnchorInfo(View, CursorAnchorInfo)} instead.
 */
","/**
 * Report the current cursor location in its window.
 *
 * @deprecated Use {@link #updateCursorAnchorInfo(View, CursorAnchorInfo)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,"An early code block is added before the previous implementation. This block checks if a fallback InputMethodManager is necessary, and if so, it redirects the cursor update to the fallback manager and returns early, which does not change the return type but includes addition of other statements and control statements. Therefore, the changes belong to the categories 3 and 4.","Despite the addition of a new code block and re-dispatching mechanism to the fallback InputMethodManager, this does not lead to a compatibility issue since the method's signature and return type remain the same, and no change in exception handling or potential returned values from this method are introduced. The method still does not return any values and the exception handling remains the same. The new code merely ensures the operation is carried out by the correct InputMethodManager instance. Thus, there is no compatibility issue."
1011,<android.app.Notification.Action.Builder: Action build()>,28,29,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"{
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction);
}","{
    checkContextualActionNullFields();
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = (RemoteInput[]) mExtras.getParcelableArray(EXTRA_DATA_ONLY_INPUTS);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction, mIsContextual);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The new method checkContextualActionNullFields() is called and a new parameter, mIsContextual, is added to the Action object's constructor. These changes are not modifying existing return statements, exception handling or control dependencies, and there is no indication that the dependent API has changed. It's an 'Other statement changed' type - 4.","There is no Compatibility Issue here, as the changes do not affect the return type or value and do not introduce any new exception handling. The added method and new constructor parameter do not inherently cause a behavior change that would lead to a Compatibility Issue - 0."
1012,<android.service.autofill.CustomDescription: String toString()>,28,29,<android.service.autofill.CustomDescription: String toString()>,<android.service.autofill.CustomDescription: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""CustomDescription: [presentation="").append(mPresentation).append("", transformations="").append(mTransformations == null ? ""N/A"" : mTransformations.size()).append("", updates="").append(mUpdates == null ? ""N/A"" : mUpdates.size()).append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    return new StringBuilder(""CustomDescription: [presentation="").append(mPresentation).append("", transformations="").append(mTransformations == null ? ""N/A"" : mTransformations.size()).append("", updates="").append(mUpdates == null ? ""N/A"" : mUpdates.size()).append("", actions="").append(mActions == null ? ""N/A"" : mActions.size()).append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There's an additional field 'actions' appended to the StringBuilder in the toString() method. This is classified as an 'Other statement changed' as it doesn't affect the return statement, exception handling, or control dependency directly.","Since the change is only in the debug output and does not affect the API's main functionality or its interaction with other components, there is no Compatibility Issue. The behavior of the method remains consistent in terms of execution, it just provides additional debug information when enabled."
1013,<android.content.ContentResolver: Uri canonicalize(Uri)>,28,29,<android.content.ContentResolver: Uri canonicalize(Uri)>,<android.content.ContentResolver: Uri canonicalize(Uri)>,0,"{
    Preconditions.checkNotNull(url, ""url"");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.canonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Preconditions.checkNotNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.canonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.canonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
","/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
",-1,[@Nullable],"[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"3,4,5",1,"The late implementation version has added a try-catch block with a conditional check (`if (mWrapped != null)`) for a different object `mWrapped` calling `canonicalize(url)` and additional exception handling for `RemoteException`, which represent a control dependency change (3). Additionally, the invocation of a new object `mWrapped` that does not exist in the early version implies a dependent API change (5). The structure inside the try-catch block around `acquireProvider(url)` is unchanged; therefore, the other changes are related to the new if-statement and exception flow (4).","Because there's a new conditional check (`if (mWrapped != null)`) that may cause the method to return a value without proceeding to the original implementation containing `acquireProvider(url)`, the late version may potentially return a different value than the early version for cases when `mWrapped` is not null. Therefore, there is a potential compatibility issue due to different return values or types (1)."
1014,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableSessionKeys()>,28,29,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableSessionKeys()>,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableSessionKeys()>,0,"{
    if (mAvailableSessionKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_SESSION_KEYS);
        if (filterTags == null) {
            return null;
        }
        mAvailableSessionKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags);
    }
    return mAvailableSessionKeys;
}","{
    if (mAvailableSessionKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_SESSION_KEYS);
        if (filterTags == null) {
            return null;
        }
        mAvailableSessionKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags, /*includeSynthetic*/
        false);
    }
    return mAvailableSessionKeys;
}",1,"/**
 * <p>Returns a subset of {@link #getAvailableCaptureRequestKeys} keys that the
 * camera device can pass as part of the capture session initialization.</p>
 *
 * <p>This list includes keys that are difficult to apply per-frame and
 * can result in unexpected delays when modified during the capture session
 * lifetime. Typical examples include parameters that require a
 * time-consuming hardware re-configuration or internal camera pipeline
 * change. For performance reasons we suggest clients to pass their initial
 * values as part of {@link SessionConfiguration#setSessionParameters}. Once
 * the camera capture session is enabled it is also recommended to avoid
 * changing them from their initial values set in
 * {@link SessionConfiguration#setSessionParameters }.
 * Control over session parameters can still be exerted in capture requests
 * but clients should be aware and expect delays during their application.
 * An example usage scenario could look like this:</p>
 * <ul>
 * <li>The camera client starts by quering the session parameter key list via
 * {@link android.hardware.camera2.CameraCharacteristics#getAvailableSessionKeys }.</li>
 * <li>Before triggering the capture session create sequence, a capture request
 * must be built via {@link CameraDevice#createCaptureRequest } using an
 * appropriate template matching the particular use case.</li>
 * <li>The client should go over the list of session parameters and check
 * whether some of the keys listed matches with the parameters that
 * they intend to modify as part of the first capture request.</li>
 * <li>If there is no such match, the capture request can be  passed
 * unmodified to {@link SessionConfiguration#setSessionParameters }.</li>
 * <li>If matches do exist, the client should update the respective values
 * and pass the request to {@link SessionConfiguration#setSessionParameters }.</li>
 * <li>After the capture session initialization completes the session parameter
 * key list can continue to serve as reference when posting or updating
 * further requests. As mentioned above further changes to session
 * parameters should ideally be avoided, if updates are necessary
 * however clients could expect a delay/glitch during the
 * parameter switch.</li>
 * </ul>
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * @return List of keys that can be passed during capture session initialization. In case the
 * camera device doesn't support such keys the list can be null.
 */
","/**
 * <p>Returns a subset of {@link #getAvailableCaptureRequestKeys} keys that the
 * camera device can pass as part of the capture session initialization.</p>
 *
 * <p>This list includes keys that are difficult to apply per-frame and
 * can result in unexpected delays when modified during the capture session
 * lifetime. Typical examples include parameters that require a
 * time-consuming hardware re-configuration or internal camera pipeline
 * change. For performance reasons we suggest clients to pass their initial
 * values as part of {@link SessionConfiguration#setSessionParameters}. Once
 * the camera capture session is enabled it is also recommended to avoid
 * changing them from their initial values set in
 * {@link SessionConfiguration#setSessionParameters }.
 * Control over session parameters can still be exerted in capture requests
 * but clients should be aware and expect delays during their application.
 * An example usage scenario could look like this:</p>
 * <ul>
 * <li>The camera client starts by querying the session parameter key list via
 * {@link android.hardware.camera2.CameraCharacteristics#getAvailableSessionKeys }.</li>
 * <li>Before triggering the capture session create sequence, a capture request
 * must be built via {@link CameraDevice#createCaptureRequest } using an
 * appropriate template matching the particular use case.</li>
 * <li>The client should go over the list of session parameters and check
 * whether some of the keys listed matches with the parameters that
 * they intend to modify as part of the first capture request.</li>
 * <li>If there is no such match, the capture request can be  passed
 * unmodified to {@link SessionConfiguration#setSessionParameters }.</li>
 * <li>If matches do exist, the client should update the respective values
 * and pass the request to {@link SessionConfiguration#setSessionParameters }.</li>
 * <li>After the capture session initialization completes the session parameter
 * key list can continue to serve as reference when posting or updating
 * further requests. As mentioned above further changes to session
 * parameters should ideally be avoided, if updates are necessary
 * however clients could expect a delay/glitch during the
 * parameter switch.</li>
 * </ul>
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * @return List of keys that can be passed during capture session initialization. In case the
 * camera device doesn't support such keys the list can be null.
 */
",-1,"[@SuppressWarnings({ ""unchecked"" })]","[@SuppressWarnings({ ""unchecked"" })]",-1,-1,-1,-1,-1,-1,"4,5",1,"A new parameter ('false' for the argument 'includeSynthetic') is added to the method call getAvailableKeyList(), and it changes the number of parameters in the method invocation. So, this is an ""Other statement changed"" and ""Dependent API changed"", change types 4 and 5.","The change in the method invocation for getAvailableKeyList(), due to the additional parameter, could potentially lead to a different list of available keys being returned compared to the earlier implementation, causing a CI type 1."
1015,"<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>",28,29,"<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>","<android.app.SharedElementCallback: Parcelable onCaptureSharedElementSnapshot(View,Matrix,RectF)>",0,"{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}","{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                    ColorSpace cs = bitmap.getColorSpace();
                    if (cs != null) {
                        bundle.putInt(BUNDLE_SNAPSHOT_COLOR_SPACE, cs.getId());
                    }
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}",1,"/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
","/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The code change consists of adding a new if statement that checks for a not-null `ColorSpace` and accordingly puts an integer corresponding to the color space ID into the bundle. This change represents an Other statement changed, so the change type is 4.","Since a new piece of data (the color space ID) is being added to the bundle being returned, this change could lead to the API returning a different value in certain situations (specifically, when the bitmap's color space is not null), which would not have been present in the earlier version. Consequently, this represents a Compatibility Issue caused by potential different return values, and the CI type is 1."
1016,"<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>",28,29,"<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>","<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>",0,"{
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    String innerPrefix = prefix + ""  "";
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, fd, writer, args);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    final AutofillManager afm = getAutofillManager();
    if (afm != null) {
        writer.print(prefix);
        writer.print(""Autofill Compat Mode: "");
        writer.println(isAutofillCompatibilityEnabled());
        afm.dump(prefix, writer);
    } else {
        writer.print(prefix);
        writer.println(""No AutofillManager"");
    }
    ResourcesManager.getInstance().dump(prefix, writer);
}","{
    if (args != null && args.length > 0) {
        // Handle special cases
        switch(args[0]) {
            case ""--autofill"":
                dumpAutofillManager(prefix, writer);
                return;
            case ""--contentcapture"":
                dumpContentCaptureManager(prefix, writer);
                return;
        }
    }
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    String innerPrefix = prefix + ""  "";
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, fd, writer, args);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    dumpAutofillManager(prefix, writer);
    dumpContentCaptureManager(prefix, writer);
    ResourcesManager.getInstance().dump(prefix, writer);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is a new control dependency (if-statement with checks on 'args' and implementation of switch-case logic), and new method calls (`dumpAutofillManager` and `dumpContentCaptureManager`) that replace the earlier implementation related to autofill logic and handler for content capture. This leads to a change type 3 and 4. Since some `return` statements were introduced within the switch-case, it can change the behavior of the method, making the change type 1 as well. ","The newly introduced control dependency (if-statement and switch-case logic) can change the flow of the method such that it can return prematurely based on the values in 'args'. This constitutes a potentially different return behavior and thus a CI of type 1. Additionally, the previous version of the method always executed the autofill logic and ResourcesManager dump, regardless of the arguments, which are now conditionally executed based on the arguments, again indicating different return behavior."
1017,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",28,29,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    if (constructor != null && !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object lastContext = mConstructorArgs[0];
        if (mConstructorArgs[0] == null) {
            // Fill in the context if not already within inflation.
            mConstructorArgs[0] = mContext;
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        mConstructorArgs[0] = lastContext;
        return view;
    } catch (NoSuchMethodException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Class is not a View "" + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}","{
    Context context = (Context) mConstructorArgs[0];
    if (context == null) {
        context = mContext;
    }
    return createView(context, name, prefix, attrs);
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader. To use an explicit Context in the View
 * constructor, use {@link #createView(Context, String, String, AttributeSet)} instead.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The entire implementation of the method has been changed to a single line that calls another method, so the change type is 5.","Since the original implementation has been completely replaced with a call to a different method, there is a possibility that the behavior of the method has changed in terms of the value it returns. Therefore, the CI type is 1."
1018,<android.view.View: Mode getForegroundTintMode()>,28,29,<android.view.View: Mode getForegroundTintMode()>,<android.view.View: Mode getForegroundTintMode()>,0,"{
    return mForegroundInfo != null && mForegroundInfo.mTintInfo != null ? mForegroundInfo.mTintInfo.mTintMode : null;
}","{
    BlendMode blendMode = mForegroundInfo != null && mForegroundInfo.mTintInfo != null ? mForegroundInfo.mTintInfo.mBlendMode : null;
    if (blendMode != null) {
        return BlendMode.blendModeToPorterDuffMode(blendMode);
    } else {
        return null;
    }
}",1,"/**
 * Return the blending mode used to apply the tint to the foreground
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the foreground
 * drawable
 * @attr ref android.R.styleable#View_foregroundTintMode
 * @see #setForegroundTintMode(PorterDuff.Mode)
 */
","/**
 * Return the blending mode used to apply the tint to the foreground
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the foreground
 * drawable
 * @attr ref android.R.styleable#View_foregroundTintMode
 * @see #setForegroundTintMode(PorterDuff.Mode)
 */
",-1,[@Nullable],"[@InspectableProperty, @Nullable]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early implementation is a single line with a ternary conditional operator, whereas the late implementation splits the logic into multiple statements, introducing a new variable `blendMode`, a new `if` condition, and calls a new method `BlendMode.blendModeToPorterDuffMode(blendMode)`. This suggests there are changes in return statement, other statements (assignment of `blendMode`), and dependent API changed (introduction of new method `BlendMode.blendModeToPorterDuffMode()`). The code change type is therefore 1,4,5.","Since the late version of the method introduces a new method call and also changes the logic for determining the return value, the API potentially returns a different type. The conversion from `BlendMode` to the `Mode` using `blendModeToPorterDuffMode(blendMode)` could yield a different `Mode` than what would have been returned previously, causing a Compatibility Issue of type 1."
1019,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",28,29,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",0,"{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        ensureSharedTempPointerCapacity(1);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        pp[0].clear();
        pp[0].id = 0;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        pc[0].clear();
        pc[0].x = x;
        pc[0].y = y;
        pc[0].pressure = pressure;
        pc[0].size = size;
        ev.mNativePtr = nativeInitialize(ev.mNativePtr, deviceId, InputDevice.SOURCE_UNKNOWN, action, 0, edgeFlags, metaState, 0, 0, 0, xPrecision, yPrecision, downTime * NS_PER_MS, eventTime * NS_PER_MS, 1, pp, pc);
        return ev;
    }
}","{
    return obtain(downTime, eventTime, action, x, y, pressure, size, metaState, xPrecision, yPrecision, deviceId, edgeFlags, InputDevice.SOURCE_UNKNOWN, DEFAULT_DISPLAY);
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the method no longer initializes the MotionEvent directly in its body; instead, it calls another version of obtain(), with a different set of parameters excluding the manual handling of pointer properties and pointer coordinates. Also, the internal synchronization block and related operations on shared temporary structures are removed. The obtain() method signature and implementation in both versions are clearly different. Therefore, the changes types are 1 (Return statement changed) and 4 (Other statement changed).","The behavior of the method could have changed because the internal initialization process has been altered. This might affect how the MotionEvent is constructed and initialized, which could potentially cause it to return a different MotionEvent object. Since the API now delegates to a different obtain() method rather than setting parameters manually, the returned MotionEvent might have different properties, thus causing a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
1020,<android.view.autofill.AutofillManager: boolean isFieldClassificationEnabled()>,28,29,<android.view.autofill.AutofillManager: boolean isFieldClassificationEnabled()>,<android.view.autofill.AutofillManager: boolean isFieldClassificationEnabled()>,0,"{
    try {
        return mService.isFieldClassificationEnabled();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return false;
    }
}","{
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.isFieldClassificationEnabled(receiver);
        return receiver.getIntResult() == 1;
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return false;
    }
}",1,"/**
 * Checks if <a href=""AutofillService.html#FieldClassification"">field classification</a> is
 * enabled.
 *
 * <p>As field classification is an expensive operation, it could be disabled, either
 * temporarily (for example, because the service exceeded a rate-limit threshold) or
 * permanently (for example, because the device is a low-level device).
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
","/**
 * Checks if <a href=""AutofillService.html#FieldClassification"">field classification</a> is
 * enabled.
 *
 * <p>As field classification is an expensive operation, it could be disabled, either
 * temporarily (for example, because the service exceeded a rate-limit threshold) or
 * permanently (for example, because the device is a low-level device).
 *
 * <p><b>Note:</b> This method should only be called by an app providing an autofill service,
 * and it's ignored if the caller currently doesn't have an enabled autofill service for
 * the user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method of obtaining the boolean result has changed from a direct service call (mService.isFieldClassificationEnabled()) in the early version to using a SyncResultReceiver in the late version (mService.isFieldClassificationEnabled(receiver); receiver.getIntResult() == 1). Additionally, the dependent API 'isFieldClassificationEnabled' is now being called with a different signature (it now accepts a 'receiver' parameter). Therefore, the return statement has changed along with a change to a dependent API, which is categorized under changes 1 and 5.","Since the implementation has changed on how the result is obtained and processed, it might lead to different return values, hence causing a Compatibility Issue. Therefore, the detected CI is due to potential different return values or types, categorized under CI type 1."
1022,<android.view.autofill.AutofillManager: ComponentName getAutofillServiceComponentName()>,28,29,<android.view.autofill.AutofillManager: ComponentName getAutofillServiceComponentName()>,<android.view.autofill.AutofillManager: ComponentName getAutofillServiceComponentName()>,0,"{
    if (mService == null)
        return null;
    try {
        return mService.getAutofillServiceComponentName();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (mService == null)
        return null;
    final SyncResultReceiver receiver = new SyncResultReceiver(SYNC_CALLS_TIMEOUT_MS);
    try {
        mService.getAutofillServiceComponentName(receiver);
        return receiver.getParcelableResult();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the component name of the {@link AutofillService} that is enabled for the current
 * user.
 */
","/**
 * Returns the component name of the {@link AutofillService} that is enabled for the current
 * user.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",1,"The method of acquiring the ComponentName object has changed. In the late version, there is an introduction of new local variable SyncResultReceiver and a new method call to receiver.getParcelableResult(). The call to mService.getAutofillServiceComponentName() has been modified to include a SyncResultReceiver argument. This change is not solely related to return statement, exception statement, or control dependency, thus the code change type is 4,5.","This code change potentially leads to a different return value because the process by which the value is obtained has been changed. In the late version, it's using a SyncResultReceiver to receive the result asynchronously, which may affect the result that getAutofillServiceComponentName() will return. Thus, the CI type is 1."
1023,"<android.view.View: void setFlags(int,int)>",28,29,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    boolean shouldNotifyFocusableAvailable = false;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
            if (mParent instanceof ViewGroup) {
                ((ViewGroup) mParent).clearFocusedInCluster();
            }
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    shouldNotifyFocusableAvailable = canTakeFocus();
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // a view becoming visible is worth notifying the parent about in case nothing has
            // focus. Even if this specific view isn't focusable, it may contain something that
            // is, so let the root view try to give this focus if nothing else does.
            shouldNotifyFocusableAvailable = hasSize();
        }
    }
    if ((changed & ENABLED_MASK) != 0) {
        if ((mViewFlags & ENABLED_MASK) == ENABLED) {
            // a view becoming enabled should notify the parent as long as the view is also
            // visible and the parent wasn't already notified by becoming visible during this
            // setFlags invocation.
            shouldNotifyFocusableAvailable = canTakeFocus();
        } else {
            if (isFocused())
                clearFocus();
        }
    }
    if (shouldNotifyFocusableAvailable && mParent != null) {
        mParent.focusableViewAvailable(this);
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus()) {
                clearFocus();
                if (mParent instanceof ViewGroup) {
                    ((ViewGroup) mParent).clearFocusedInCluster();
                }
            }
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus()) {
                    clearFocus();
                    if (mParent instanceof ViewGroup) {
                        ((ViewGroup) mParent).clearFocusedInCluster();
                    }
                }
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        // a state change, so we really don't need to report other changes.
        if (isAccessibilityPane()) {
            changed &= ~VISIBILITY_MASK;
        }
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    boolean shouldNotifyFocusableAvailable = false;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
            if (mParent instanceof ViewGroup) {
                ((ViewGroup) mParent).clearFocusedInCluster();
            }
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    shouldNotifyFocusableAvailable = canTakeFocus();
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // a view becoming visible is worth notifying the parent about in case nothing has
            // focus. Even if this specific view isn't focusable, it may contain something that
            // is, so let the root view try to give this focus if nothing else does.
            shouldNotifyFocusableAvailable = hasSize();
        }
    }
    if ((changed & ENABLED_MASK) != 0) {
        if ((mViewFlags & ENABLED_MASK) == ENABLED) {
            // a view becoming enabled should notify the parent as long as the view is also
            // visible and the parent wasn't already notified by becoming visible during this
            // setFlags invocation.
            shouldNotifyFocusableAvailable = canTakeFocus();
        } else {
            if (isFocused())
                clearFocus();
        }
    }
    if (shouldNotifyFocusableAvailable && mParent != null) {
        mParent.focusableViewAvailable(this);
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus()) {
                clearFocus();
                if (mParent instanceof ViewGroup) {
                    ((ViewGroup) mParent).clearFocusedInCluster();
                }
            }
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus()) {
                    clearFocus();
                    if (mParent instanceof ViewGroup) {
                        ((ViewGroup) mParent).clearFocusedInCluster();
                    }
                }
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ViewGroup parent = (ViewGroup) mParent;
            parent.onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            parent.invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        // a state change, so we really don't need to report other changes.
        if (isAccessibilityPane()) {
            changed &= ~VISIBILITY_MASK;
        }
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)]",-1,-1,-1,-1,-1,-1,,,,
1025,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",28,29,"<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>","<android.app.Activity: boolean startNextMatchingActivity(Intent,Bundle)>",0,"{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            return ActivityManager.getService().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(this);
            return ActivityTaskManager.getService().startNextMatchingActivity(mToken, intent, options);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called to start the next matching activity has changed from `ActivityManager.getService().startNextMatchingActivity()` to `ActivityTaskManager.getService().startNextMatchingActivity()`, so the code change type is 5.","There is no Compatibility Issue indicated since the method signature and return statements have not changed, and there is no indication that the behavior of `startNextMatchingActivity` from `ActivityTaskManager` is different from `ActivityManager`. The change seems to internalize the implementation details which do not affect the method's contract. Therefore, there is no CI."
1026,"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>",28,29,"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>","<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>",0,"{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message, 0);
}","{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message, 0);
}",1,"/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */
","/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4",0,"The method has introduced a new condition inside the synchronized block which checks `sHasBeamFeature` and returns if it's not present, this is a control dependency change (3). Also adding a new return statement constitutes other statement change (4).","Although a new control flow statement and a return statement have been introduced, these modifications do not constitute a compatibility issue. The new condition and return statement may prevent the method from continuing its execution, which means that the API behaves correctly according to its updated design. If `sHasBeamFeature` is false, the method is supposed to return without performing its original operation, adhering to the updated condition. This does not lead to different return types or exception throwing behaviors, considering the context of the use case. Therefore, there is no compatibility issue (0)."
1028,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,28,29,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,0,"{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
            return HAL_DATASPACE_DEPTH;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
            return HAL_DATASPACE_DEPTH;
        case ImageFormat.DEPTH_JPEG:
            return HAL_DATASPACE_DYNAMIC_DEPTH;
        case ImageFormat.HEIC:
            return HAL_DATASPACE_HEIF;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH_JPEG => HAL_DATASPACE_DYNAMIC_DEPTH
 * <li>ImageFormat.HEIC => HAL_DATASPACE_HEIF
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"Cases for the switch statement have been added (ImageFormat.DEPTH_JPEG and ImageFormat.HEIC), so the code change type is 3.","New return values are introduced for the cases ImageFormat.DEPTH_JPEG and ImageFormat.HEIC. Hence, for some inputs, the API will return different values, which means the CI type is 1."
1029,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,28,29,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,0,"{
    byte[] dataBytes = new byte[data.size()];
    try {
        // Read the data and convert it to a String.
        data.read(dataBytes);
        String dataString = new String(dataBytes, JSON_FORMAT_ENCODING);
        // Convert data to a JSON object.
        JSONObject dataJSON = new JSONObject(dataString);
        boolean masterSyncEnabled = dataJSON.getBoolean(KEY_MASTER_SYNC_ENABLED);
        JSONArray accountJSONArray = dataJSON.getJSONArray(KEY_ACCOUNTS);
        boolean currentMasterSyncEnabled = ContentResolver.getMasterSyncAutomatically();
        if (currentMasterSyncEnabled) {
            // Disable master sync to prevent any syncs from running.
            ContentResolver.setMasterSyncAutomatically(false);
        }
        try {
            restoreFromJsonArray(accountJSONArray);
        } finally {
            // Set the master sync preference to the value from the backup set.
            ContentResolver.setMasterSyncAutomatically(masterSyncEnabled);
        }
        Log.i(TAG, ""Restore successful."");
    } catch (IOException | JSONException e) {
        Log.e(TAG, ""Couldn't restore account sync settings\n"" + e);
    }
}","{
    byte[] dataBytes = new byte[data.size()];
    try {
        // Read the data and convert it to a String.
        data.read(dataBytes);
        String dataString = new String(dataBytes, JSON_FORMAT_ENCODING);
        // Convert data to a JSON object.
        JSONObject dataJSON = new JSONObject(dataString);
        boolean masterSyncEnabled = dataJSON.getBoolean(KEY_MASTER_SYNC_ENABLED);
        JSONArray accountJSONArray = dataJSON.getJSONArray(KEY_ACCOUNTS);
        boolean currentMasterSyncEnabled = ContentResolver.getMasterSyncAutomaticallyAsUser(mUserId);
        if (currentMasterSyncEnabled) {
            // Disable master sync to prevent any syncs from running.
            ContentResolver.setMasterSyncAutomaticallyAsUser(false, mUserId);
        }
        try {
            restoreFromJsonArray(accountJSONArray, mUserId);
        } finally {
            // Set the master sync preference to the value from the backup set.
            ContentResolver.setMasterSyncAutomaticallyAsUser(masterSyncEnabled, mUserId);
        }
        Log.i(TAG, ""Restore successful."");
    } catch (IOException | JSONException e) {
        Log.e(TAG, ""Couldn't restore account sync settings\n"" + e);
    }
}",1,"/**
 * Restore account sync settings from the given data input stream.
 */
","/**
 * Restore account sync settings from the given data input stream.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,The change involves calling different versions of methods related to ContentResolver's master sync setting methods (with and without user ID parameters) and the added parameter to the restoreFromJsonArray() method. This is a clear example of a dependent API change (5).,"Though the implementation of this method relies on other APIs which have changed to include a user ID (as seen in getMasterSyncAutomaticallyAsUser, setMasterSyncAutomaticallyAsUser, and restoreFromJsonArray with mUserId parameter), these changes do not lead to different return values/types or exception handlings from the perspective of restoreEntity method itself. Consequently, this does not constitute a Compatibility Issue as per the provided definitions since the behavior of restoreEntity would remain consistent from the caller's perspective. Thus, the answer is 0 for no Compatibility Issue."
1030,"<android.service.autofill.UserData.Builder: Builder setFieldClassificationAlgorithm(String,Bundle)>",28,29,"<android.service.autofill.UserData.Builder: Builder setFieldClassificationAlgorithm(String,Bundle)>","<android.service.autofill.UserData.Builder: Builder setFieldClassificationAlgorithm(String,Bundle)>",0,"{
    throwIfDestroyed();
    mAlgorithm = name;
    mAlgorithmArgs = args;
    return this;
}","{
    throwIfDestroyed();
    mDefaultAlgorithm = name;
    mDefaultArgs = args;
    return this;
}",1,"/**
 * Sets the algorithm used for <a href=""#FieldClassification"">field classification</a>.
 *
 * <p>The currently available algorithms can be retrieve through
 * {@link AutofillManager#getAvailableFieldClassificationAlgorithms()}.
 *
 * <p>If not set, the
 * {@link AutofillManager#getDefaultFieldClassificationAlgorithm() default algorithm} is
 * used instead.
 *
 * @param name name of the algorithm or {@code null} to used default.
 * @param args optional arguments to the algorithm.
 *
 * @return this builder
 */
","/**
 * Sets the default algorithm used for
 * <a href=""#FieldClassification"">field classification</a>.
 *
 * <p>The currently available algorithms can be retrieve through
 * {@link AutofillManager#getAvailableFieldClassificationAlgorithms()}.
 *
 * <p>If not set, the
 * {@link AutofillManager#getDefaultFieldClassificationAlgorithm() default algorithm} is
 * used instead.
 *
 * @param name name of the algorithm or {@code null} to used default.
 * @param args optional arguments to the algorithm.
 *
 * @return this builder
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The fields `mAlgorithm` and `mAlgorithmArgs` have been renamed to `mDefaultAlgorithm` and `mDefaultArgs`, respectively. Since these are internal field changes and the arguments, return type and exception throwing behavior of the method signature has not changed, the method externally behaves the same. Therefore, the code change type is 4 (Other statement changed).","There appears to be no Compatibility Issue since the renaming of fields does not affect the method's contract, the method's return value or the exceptions it might throw. The behavior from a client's perspective remains unchanged; hence the CI type is 0 (No Compatibility Issue)."
1031,<android.util.SparseLongArray: long valueAt(int)>,28,29,<android.util.SparseLongArray: long valueAt(int)>,<android.util.SparseLongArray: long valueAt(int)>,0,"{
    return mValues[index];
}","{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    return mValues[index];
}",1,"/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseLongArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 */
","/**
 * Given an index in the range <code>0...size()-1</code>, returns
 * the value from the <code>index</code>th key-value mapping that this
 * SparseLongArray stores.
 *
 * <p>The values corresponding to indices in ascending order are guaranteed
 * to be associated with keys in ascending order, e.g.,
 * <code>valueAt(0)</code> will return the value associated with the
 * smallest key and <code>valueAt(size()-1)</code> will return the value
 * associated with the largest key.</p>
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","A new control dependency (if statement) and exception handling code (throw new ArrayIndexOutOfBoundsException) that throws an exception have been introduced in the late implementation, so the change type is 2,3.","Because of the new 'if' check and potential 'throw' statement in the late implementation, the API now has both the possibility to throw a new exception and to return different values (or not return a value at all due to the exception), compared to the early implementation. Thus, the CI type is 1,2."
1033,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",28,29,"<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>","<android.net.ConnectivityManager: void requestNetwork(NetworkRequest,PendingIntent)>",0,"{
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}","{
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}",1,"/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfing a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}.
 */
","/**
 * Request a network to satisfy a set of {@link android.net.NetworkCapabilities}.
 *
 * This function behaves identically to the version that takes a NetworkCallback, but instead
 * of {@link NetworkCallback} a {@link PendingIntent} is used.  This means
 * the request may outlive the calling application and get called back when a suitable
 * network is found.
 * <p>
 * The operation is an Intent broadcast that goes to a broadcast receiver that
 * you registered with {@link Context#registerReceiver} or through the
 * &lt;receiver&gt; tag in an AndroidManifest.xml file
 * <p>
 * The operation Intent is delivered with two extras, a {@link Network} typed
 * extra called {@link #EXTRA_NETWORK} and a {@link NetworkRequest}
 * typed extra called {@link #EXTRA_NETWORK_REQUEST} containing
 * the original requests parameters.  It is important to create a new,
 * {@link NetworkCallback} based request before completing the processing of the
 * Intent to reserve the network or it will be released shortly after the Intent
 * is processed.
 * <p>
 * If there is already a request for this Intent registered (with the equality of
 * two Intents defined by {@link Intent#filterEquals}), then it will be removed and
 * replaced by this one, effectively releasing the previous {@link NetworkRequest}.
 * <p>
 * The request may be released normally by calling
 * {@link #releaseNetworkRequest(android.app.PendingIntent)}.
 * <p>It is presently unsupported to request a network with either
 * {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED} or
 * {@link NetworkCapabilities#NET_CAPABILITY_CAPTIVE_PORTAL}
 * as these {@code NetworkCapabilities} represent states that a particular
 * network may never attain, and whether a network will attain these states
 * is unknown prior to bringing up the network so the framework does not
 * know how to go about satisfying a request with these capabilities.
 *
 * <p>This method requires the caller to hold either the
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE} permission
 * or the ability to modify system settings as determined by
 * {@link android.provider.Settings.System#canWrite}.</p>
 *
 * @param request {@link NetworkRequest} describing this request.
 * @param operation Action to perform when the network is available (corresponds
 * to the {@link NetworkCallback#onAvailable} call.  Typically
 * comes from {@link PendingIntent#getBroadcast}. Cannot be null.
 * @throws IllegalArgumentException if {@code request} contains invalid network capabilities.
 * @throws SecurityException if missing the appropriate permissions.
 * @throws RuntimeException if request limit per UID is exceeded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A printStackTrace() method invocation has been added before the checkPendingIntentNotNull(operation) call. Since it is solely a diagnostic method and not connected to the functionality of the API, the code change type is 4.","The added printStackTrace() call should not affect the return value or the exceptions thrown by this method, thus no potential Compatibility Issue is detected, and the CI type is 0."
1034,<android.view.View: boolean onHoverEvent(MotionEvent)>,28,29,<android.view.View: boolean onHoverEvent(MotionEvent)>,<android.view.View: boolean onHoverEvent(MotionEvent)>,0,"{
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && event.isFromSource(InputDevice.SOURCE_MOUSE) && isOnScrollbar(event.getX(), event.getY())) {
        awakenScrollBars();
    }
    // handle changing state in response to ENTER and EXIT events.
    if (isHoverable() || isHovered()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}","{
    if (mTouchDelegate != null && dispatchTouchExplorationHoverEvent(event)) {
        return true;
    }
    // The root view may receive hover (or touch) events that are outside the bounds of
    // the window.  This code ensures that we only send accessibility events for
    // hovers that are actually within the bounds of the root view.
    final int action = event.getActionMasked();
    if (!mSendingHoverAccessibilityEvents) {
        if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && !hasHoveredChild() && pointInView(event.getX(), event.getY())) {
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
            mSendingHoverAccessibilityEvents = true;
        }
    } else {
        if (action == MotionEvent.ACTION_HOVER_EXIT || (action == MotionEvent.ACTION_HOVER_MOVE && !pointInView(event.getX(), event.getY()))) {
            mSendingHoverAccessibilityEvents = false;
            sendAccessibilityHoverEvent(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
        }
    }
    if ((action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE) && event.isFromSource(InputDevice.SOURCE_MOUSE) && isOnScrollbar(event.getX(), event.getY())) {
        awakenScrollBars();
    }
    // handle changing state in response to ENTER and EXIT events.
    if (isHoverable() || isHovered()) {
        switch(action) {
            case MotionEvent.ACTION_HOVER_ENTER:
                setHovered(true);
                break;
            case MotionEvent.ACTION_HOVER_EXIT:
                setHovered(false);
                break;
        }
        // Dispatch the event to onGenericMotionEvent before returning true.
        // This is to provide compatibility with existing applications that
        // handled HOVER_MOVE events in onGenericMotionEvent and that would
        // break because of the new default handling for hoverable views
        // in onHoverEvent.
        // Note that onGenericMotionEvent will be called by default when
        // onHoverEvent returns false (refer to dispatchGenericMotionEvent).
        dispatchGenericMotionEventInternal(event);
        // return true.
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
","/**
 * Implement this method to handle hover events.
 * <p>
 * This method is called whenever a pointer is hovering into, over, or out of the
 * bounds of a view and the view is not currently being touched.
 * Hover events are represented as pointer events with action
 * {@link MotionEvent#ACTION_HOVER_ENTER}, {@link MotionEvent#ACTION_HOVER_MOVE},
 * or {@link MotionEvent#ACTION_HOVER_EXIT}.
 * </p>
 * <ul>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_ENTER}
 * when the pointer enters the bounds of the view.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_MOVE}
 * when the pointer has already entered the bounds of the view and has moved.</li>
 * <li>The view receives a hover event with action {@link MotionEvent#ACTION_HOVER_EXIT}
 * when the pointer has exited the bounds of the view or when the pointer is
 * about to go down due to a button click, tap, or similar user action that
 * causes the view to be touched.</li>
 * </ul>
 * <p>
 * The view should implement this method to return true to indicate that it is
 * handling the hover event, such as by changing its drawable state.
 * </p><p>
 * The default implementation calls {@link #setHovered} to update the hovered state
 * of the view when a hover enter or hover exit event is received, if the view
 * is enabled and is clickable.  The default implementation also sends hover
 * accessibility events.
 * </p>
 *
 * @param event The motion event that describes the hover.
 * @return True if the view handled the hover event.
 *
 * @see #isHovered
 * @see #setHovered
 * @see #onHoverChanged
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change involves an added if-statement (`if (mTouchDelegate != null && dispatchTouchExplorationHoverEvent(event))`) at the beginning of the method, which is an additional control to check if the touch delegate is non-null and if a touch exploration hover event is dispatched. This conditional block does not modify existing control flows or return values for conditions that would have otherwise been met in the early version.","There is no Compatibility Issue since the change introduces a new condition that, when true, would return `true`, but in the cases where this new condition is not met, the original behavior of the method is preserved. This means the methods behavior regarding return values and exception handling remains unchanged for existing cases covered by the early version."
1036,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",28,29,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>","<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",0,"{
    Preconditions.checkNotNull(method, ""method"");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    return call(mAuthority, method, arg, extras);
}",1,"/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
","/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The late implementation entirely replaces the early one with a call to a different method signature (call(mAuthority, method, arg, extras) instead of mContentProvider.call(mPackageName, method, arg, extras)), changes the exception handling by removing the try-catch block, and also removes the pre and post remote call hooks. Therefore, the code change type is classified as 1,2,3,5.","There is a CI of type 1 due to the change in the method called, which could potentially return a different Bundle object. Additionally, the exception handling has also changed. The catch block for DeadObjectException and its handling with mContentResolver.unstableProviderDied(mContentProvider) has been removed, which could lead to different exceptions being thrown, thereby causing a CI of type 2."
1037,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,28,29,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,0,"{
    final boolean focusChanged = mServedView != mNextServedView;
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""onViewClicked: "" + focusChanged);
            mCurMethod.viewClicked(focusChanged);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.viewClicked(view);
        return;
    }
    final boolean focusChanged = mServedView != mNextServedView;
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""onViewClicked: "" + focusChanged);
            mCurMethod.viewClicked(focusChanged);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,"/**
 * Notify the event when the user tapped or clicked the text view.
 */
","/**
 * Notify the event when the user tapped or clicked the text view.
 *
 * @param view {@link View} which is being clicked.
 * @see InputMethodService#onViewClicked(boolean)
 * @deprecated The semantics of this method can never be defined well for composite {@link View}
 * that works as a giant ""Canvas"", which can host its own UI hierarchy and sub focus
 * state. {@link android.webkit.WebView} is a good example. Application / IME
 * developers should not rely on this method.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"There is an addition of a few lines at the beginning of the method to check for a context mismatch and use a ""fallback"" `InputMethodManager` if necessary. However, the original functionality after the addition remains unchanged. ","There is no change that directly alters the return type or exception handling of the public API; thus there is no compatibility issue concerning return values or exceptions thrown. However, it's worth noting that the new logic could potentially affect which `InputMethodManager` handles the `viewClicked` operation if there is a context mismatch. But from the perspective of clients calling `viewClicked`, they still receive the same API contract, and no exception handling or return statement is changed from their viewpoint."
1038,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableCaptureRequestKeys()>,28,29,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableCaptureRequestKeys()>,<android.hardware.camera2.CameraCharacteristics: Key<?>> getAvailableCaptureRequestKeys()>,0,"{
    if (mAvailableRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS);
        if (filterTags == null) {
            throw new AssertionError(""android.request.availableRequestKeys must be non-null "" + ""in the characteristics"");
        }
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags);
    }
    return mAvailableRequestKeys;
}","{
    if (mAvailableRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS);
        if (filterTags == null) {
            throw new AssertionError(""android.request.availableRequestKeys must be non-null "" + ""in the characteristics"");
        }
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags, /*includeSynthetic*/
        true);
    }
    return mAvailableRequestKeys;
}",1,"/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureRequest}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureRequests.
 */
","/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureRequest}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureRequests.
 */
",-1,"[@SuppressWarnings({ ""unchecked"" }), @NonNull]","[@SuppressWarnings({ ""unchecked"" }), @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",1,"There is an addition of a new boolean parameter (/*includeSynthetic*/ true) to the method call getAvailableKeyList(), which is a dependent API change, so the code change type is 4,5.","The addition of the new parameter in the method call potentially changes the returned value of mAvailableRequestKeys, so the CI type is 1."
