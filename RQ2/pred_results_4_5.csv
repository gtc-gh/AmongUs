Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,<android.webkit.WebViewCore: Picture copyContentPicture()>,4,5,<android.webkit.WebViewCore: Picture copyContentPicture()>,<android.webkit.WebViewCore: Picture copyContentPicture()>,0,"{
    Picture result = new Picture();
    nativeCopyContentToPicture(result);
    return result;
}","{
    Picture result = new Picture();
    if (0 != mNativeClass) {
        nativeCopyContentToPicture(result);
    }
    return result;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An 'if' statement has been introduced in the later version which controls whether the nativeCopyContentToPicture(result) will be executed. So, the code change type is 3.","Depending on the 'if' condition, the 'nativeCopyContentToPicture(result)' may not be executed in the later version, this could lead the 'result' in return statement having a different value in the later version. Therefore, the Compatibility Issue type is 1."
2,"<android.view.View: Bitmap createSnapshot(Config,int)>",4,5,"<android.view.View: Bitmap createSnapshot(Config,int)>","<android.view.View: Bitmap createSnapshot(Config,int)>",0,"{
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    Bitmap bitmap = Bitmap.createBitmap(width, height, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Canvas canvas;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
        dispatchDraw(canvas);
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}","{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
        dispatchDraw(canvas);
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}",1,"/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
","/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, 'width' and 'height' are scaled with 'scale' before creating the bitmap and an additional method 'bitmap.setDensity(getResources().getDisplayMetrics().densityDpi)' has been added. The canvas scaling operation 'canvas.scale(scale, scale)' is added as well, causing a change in the return statement and the control dependency change. Therefore, the code change type is 1,3,4.","With the scaling operations and the addition of 'setDensity', the returned bitmap may contain different data, resulting in potential different return values. Hence, the CI type is 1."
3,"<android.webkit.WebView: boolean savePicture(Bundle,File)>",4,5,"<android.webkit.WebView: boolean savePicture(Bundle,File)>","<android.webkit.WebView: boolean savePicture(Bundle,File)>",0,"{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    try {
        final FileOutputStream out = new FileOutputStream(dest);
        p.writeToStream(out);
        out.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    }
    if (dest.length() > 0) {
        b.putInt(""scrollX"", mScrollX);
        b.putInt(""scrollY"", mScrollY);
        b.putFloat(""scale"", mActualScale);
        return true;
    }
    return false;
}","{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    try {
        final FileOutputStream out = new FileOutputStream(dest);
        p.writeToStream(out);
        out.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    }
    if (dest.length() > 0) {
        b.putInt(""scrollX"", mScrollX);
        b.putInt(""scrollY"", mScrollY);
        b.putFloat(""scale"", mActualScale);
        if (mInZoomOverview) {
            b.putFloat(""lastScale"", mLastScale);
        }
        return true;
    }
    return false;
}",1,"/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
","/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"An additional control conditional code block 'if(mInZoomOverview)' is added in the later version, making this a 'Control dependency changed'.","Though a new control conditional code block is added, it does not impact the return values (or types) nor does it change the exception handling. Hence, no Compatibility Issue exists in this change."
5,<android.webkit.WebView: boolean pageUp(boolean)>,4,5,<android.webkit.WebView: boolean pageUp(boolean)>,<android.webkit.WebView: boolean pageUp(boolean)>,0,"{
    if (mNativeClass == 0) {
        return false;
    }
    nativeClearFocus(-1, -1);
    if (top) {
        // go to the top of the document
        return pinScrollTo(mScrollX, 0, true, 0);
    }
    // Page up
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = -h + PAGE_SCROLL_OVERLAP;
    } else {
        y = -h / 2;
    }
    mUserScroll = true;
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}","{
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (top) {
        // go to the top of the document
        return pinScrollTo(mScrollX, 0, true, 0);
    }
    // Page up
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = -h + PAGE_SCROLL_OVERLAP;
    } else {
        y = -h / 2;
    }
    mUserScroll = true;
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}",1,"/**
 * Scroll the contents of the view up by half the view size
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
","/**
 * Scroll the contents of the view up by half the view size
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The API call 'nativeClearFocus(-1, -1)' has been replaced by 'nativeClearCursor()'. Thus the code change types are Other statement changed (4) and Dependent API changed (5).","As the implementation of 'pageUp' now calls 'nativeClearCursor()' instead of 'nativeClearFocus(-1, -1)', it could potentially lead to the function returning a different result. Hence, the API has a compatibility issue of potential different return values or types (1)."
6,<android.net.http.Request: void readResponse(AndroidHttpClientConnection)>,4,5,<android.net.http.Request: void readResponse(AndroidHttpClientConnection)>,<android.net.http.Request: void readResponse(AndroidHttpClientConnection)>,0,"{
    // don't send cancelled requests
    if (mCancelled)
        return;
    StatusLine statusLine = null;
    boolean hasBody = false;
    boolean reuse = false;
    httpClientConnection.flush();
    int statusCode = 0;
    Headers header = new Headers();
    do {
        statusLine = httpClientConnection.parseResponseHeader(header);
        statusCode = statusLine.getStatusCode();
    } while (statusCode < HttpStatus.SC_OK);
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponseStatus() "" + statusLine.toString().length() + "" "" + statusLine);
    ProtocolVersion v = statusLine.getProtocolVersion();
    mEventHandler.status(v.getMajor(), v.getMinor(), statusCode, statusLine.getReasonPhrase());
    mEventHandler.headers(header);
    HttpEntity entity = null;
    hasBody = canResponseHaveBody(mHttpRequest, statusCode);
    if (hasBody)
        entity = httpClientConnection.receiveResponseEntity(header);
    if (entity != null) {
        InputStream is = entity.getContent();
        // process gzip content encoding
        Header contentEncoding = entity.getContentEncoding();
        InputStream nis = null;
        try {
            if (contentEncoding != null && contentEncoding.getValue().equals(""gzip"")) {
                nis = new GZIPInputStream(is);
            } else {
                nis = is;
            }
            /* accumulate enough data to make it worth pushing it
                 * up the stack */
            byte[] buf = mConnection.getBuf();
            int len = 0;
            int count = 0;
            int lowWater = buf.length / 2;
            while (len != -1) {
                len = nis.read(buf, count, buf.length - count);
                if (len != -1) {
                    count += len;
                }
                if (len == -1 || count >= lowWater) {
                    if (HttpLog.LOGV)
                        HttpLog.v(""Request.readResponse() "" + count);
                    mEventHandler.data(buf, count);
                    count = 0;
                }
            }
        } catch (EOFException e) {
            /* InflaterInputStream throws an EOFException when the
                   server truncates gzipped content.  Handle this case
                   as we do truncated non-gzipped content: no error */
            if (HttpLog.LOGV)
                HttpLog.v(""readResponse() handling "" + e);
        } catch (IOException e) {
            // don't throw if we have a non-OK status code
            if (statusCode == HttpStatus.SC_OK) {
                throw e;
            }
        } finally {
            if (nis != null) {
                nis.close();
            }
        }
    }
    mConnection.setCanPersist(entity, statusLine.getProtocolVersion(), header.getConnectionType());
    mEventHandler.endData();
    complete();
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponse(): done "" + mHost.getSchemeName() + ""://"" + getHostPort() + mPath);
}","{
    // don't send cancelled requests
    if (mCancelled)
        return;
    StatusLine statusLine = null;
    boolean hasBody = false;
    boolean reuse = false;
    httpClientConnection.flush();
    int statusCode = 0;
    Headers header = new Headers();
    do {
        statusLine = httpClientConnection.parseResponseHeader(header);
        statusCode = statusLine.getStatusCode();
    } while (statusCode < HttpStatus.SC_OK);
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponseStatus() "" + statusLine.toString().length() + "" "" + statusLine);
    ProtocolVersion v = statusLine.getProtocolVersion();
    mEventHandler.status(v.getMajor(), v.getMinor(), statusCode, statusLine.getReasonPhrase());
    mEventHandler.headers(header);
    HttpEntity entity = null;
    hasBody = canResponseHaveBody(mHttpRequest, statusCode);
    if (hasBody)
        entity = httpClientConnection.receiveResponseEntity(header);
    if (entity != null) {
        InputStream is = entity.getContent();
        // process gzip content encoding
        Header contentEncoding = entity.getContentEncoding();
        InputStream nis = null;
        byte[] buf = null;
        int count = 0;
        try {
            if (contentEncoding != null && contentEncoding.getValue().equals(""gzip"")) {
                nis = new GZIPInputStream(is);
            } else {
                nis = is;
            }
            /* accumulate enough data to make it worth pushing it
                 * up the stack */
            buf = mConnection.getBuf();
            int len = 0;
            int lowWater = buf.length / 2;
            while (len != -1) {
                len = nis.read(buf, count, buf.length - count);
                if (len != -1) {
                    count += len;
                }
                if (len == -1 || count >= lowWater) {
                    if (HttpLog.LOGV)
                        HttpLog.v(""Request.readResponse() "" + count);
                    mEventHandler.data(buf, count);
                    count = 0;
                }
            }
        } catch (EOFException e) {
            /* InflaterInputStream throws an EOFException when the
                   server truncates gzipped content.  Handle this case
                   as we do truncated non-gzipped content: no error */
            if (count > 0) {
                // if there is uncommited content, we should commit them
                mEventHandler.data(buf, count);
            }
            if (HttpLog.LOGV)
                HttpLog.v(""readResponse() handling "" + e);
        } catch (IOException e) {
            // don't throw if we have a non-OK status code
            if (statusCode == HttpStatus.SC_OK) {
                throw e;
            }
        } finally {
            if (nis != null) {
                nis.close();
            }
        }
    }
    mConnection.setCanPersist(entity, statusLine.getProtocolVersion(), header.getConnectionType());
    mEventHandler.endData();
    complete();
    if (HttpLog.LOGV)
        HttpLog.v(""Request.readResponse(): done "" + mHost.getSchemeName() + ""://"" + getHostPort() + mPath);
}",1,"/**
 * Receive a single http response.
 *
 * @param httpClientConnection the request to receive the response for.
 */
","/**
 * Receive a single http response.
 *
 * @param httpClientConnection the request to receive the response for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control statement 'if (count > 0)' is newly added, so the code change type is 3.","Although there is change in the control statement, it won't cause the API to return a different value or type, nor will it cause the API to throw a different exception. Therefore, no Compatibility Issue exists."
7,"<android.webkit.CacheManager: void saveCacheFile(String,CacheResult)>",4,5,"<android.webkit.CacheManager: void saveCacheFile(String,CacheResult)>","<android.webkit.CacheManager: void saveCacheFile(String,CacheResult)>",0,"{
    try {
        cacheRet.outStream.close();
    } catch (IOException e) {
        return;
    }
    if (!cacheRet.outFile.exists()) {
        // the file in the cache directory can be removed by the system
        return;
    }
    cacheRet.contentLength = cacheRet.outFile.length();
    if (checkCacheRedirect(cacheRet.httpStatusCode)) {
        // location is in database, no need to keep the file
        cacheRet.contentLength = 0;
        cacheRet.localPath = new String();
        cacheRet.outFile.delete();
    } else if (cacheRet.contentLength == 0) {
        cacheRet.outFile.delete();
        return;
    }
    mDataBase.addCache(url, cacheRet);
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""saveCacheFile for url "" + url);
    }
}","{
    try {
        cacheRet.outStream.close();
    } catch (IOException e) {
        return;
    }
    if (!cacheRet.outFile.exists()) {
        // the file in the cache directory can be removed by the system
        return;
    }
    cacheRet.contentLength = cacheRet.outFile.length();
    boolean redirect = checkCacheRedirect(cacheRet.httpStatusCode);
    if (redirect) {
        // location is in database, no need to keep the file
        cacheRet.contentLength = 0;
        cacheRet.localPath = """";
    }
    if ((redirect || cacheRet.contentLength == 0) && !cacheRet.outFile.delete()) {
        Log.e(LOGTAG, cacheRet.outFile.getPath() + "" delete failed."");
    }
    if (cacheRet.contentLength == 0) {
        return;
    }
    mDataBase.addCache(url, cacheRet);
    if (DebugFlags.CACHE_MANAGER) {
        Log.v(LOGTAG, ""saveCacheFile for url "" + url);
    }
}",1,"// only called from WebCore thread
","// only called from WebCore thread
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"From the early implementation to the late implementation, the method introduces a variable `redirect` and changes the `if` conditions. There is a new log statement introduced in the late version. So the code change type is 1,3,4.","Because of `return` statement changes and the change in control dependency, the method could potentially return before it would in the early version. Thus, the compatibility issue type is 1."
9,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,4,5,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,0,"{
    LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(R.layout.tab_indicator, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    final ImageView iconView = (ImageView) tabIndicator.findViewById(R.id.icon);
    iconView.setImageDrawable(mIcon);
    return tabIndicator;
}","{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(R.layout.tab_indicator, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    final ImageView iconView = (ImageView) tabIndicator.findViewById(R.id.icon);
    iconView.setImageDrawable(mIcon);
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getResources().getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new 'if' control statement and a new local variable 'context' are introduced in the late version, so the code change type is 3,4.","The new 'if' block changes the appearance of the indicator 'tabIndicator', and it is returned at the end of this method, so the API could potentially return a different value. Therefore, the CI type is 1."
11,<android.view.Surface: String toString()>,4,5,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"{
    return ""Surface(native-token="" + mSurface + "")"";
}","{
    return ""Surface(native-token="" + mSurfaceControl + "")"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 4",1,"The return statement has changed with a different string composition - it used 'mSurface' in early version and 'mSurfaceControl' in late version. Also, 'mSurface' and 'mSurfaceControl' can be considered as two different variables in the return statement, therefore, the change types are 1 and 4.","Due to the change in return statement, where a different variable is now being used for string composition, the API is likely to return a different string in the late version. Hence, the CI type is 1."
14,<android.view.MotionEvent: float getHistoricalPressure(int)>,4,5,<android.view.MotionEvent: float getHistoricalPressure(int)>,<android.view.MotionEvent: float getHistoricalPressure(int)>,0,"{
    return mHistory[pos * 4 + 2];
}","{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_PRESSURE];
}",1,"/**
 * Returns a historical pressure coordinate that occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getPressure
 */
","/**
 * {@link #getHistoricalPressure(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The source data of return value has changed completely. Also, the dependent method used to gather the data has changed too. So, this is 'Return statement changed' and 'Dependent API changed', which is categorized as 1,5.","Due to the modification in the return statement, the returned value of the function can potentially be different between two versions, which comes under category 'Compatibility Issue caused by potential different return values or types' i.e., CI Type 1."
15,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,4,5,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,0,"{
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    Drawable dr;
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}","{
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    Drawable dr;
    if (resolvePackageName != null && icon != 0) {
        dr = pm.getDrawable(resolvePackageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}",1,"/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
","/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is a change in the method 'if (icon != 0){...}', which has been extended with an additional if statement. Therefore, the return statement within the 'if' block could be different in both the early and late versions. Also, the control dependency statement, i.e., the 'if' statement, has changed. Hence, the code change type is 1,3.","The changes in the 'if' statement alter the conditions under which the method may return different values. Thus, these changes can potentially lead to different return variables, and the CI type is 1."
17,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,4,5,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,<android.content.SyncManager.SyncHandler: void handleMessage(Message)>,0,"{
    handleSyncHandlerMessage(msg);
}","{
    try {
        waitUntilReadyToRun();
        switch(msg.what) {
            case SyncHandler.MESSAGE_SYNC_FINISHED:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED"");
                }
                SyncHandlerMessagePayload payload = (SyncHandlerMessagePayload) msg.obj;
                if (mActiveSyncContext != payload.activeSyncContext) {
                    if (Config.LOGD) {
                        Log.d(TAG, ""handleSyncHandlerMessage: sync context doesn't match, "" + ""dropping: mActiveSyncContext "" + mActiveSyncContext + "" != "" + payload.activeSyncContext);
                    }
                    return;
                }
                runSyncFinishedOrCanceled(payload.syncResult);
                // since we are no longer syncing, check if it is time to start a new sync
                runStateIdle();
                break;
            case SyncHandler.MESSAGE_SERVICE_CONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: "" + msgData.activeSyncContext + "" active is "" + mActiveSyncContext);
                    }
                    // check that this isn't an old message
                    if (mActiveSyncContext == msgData.activeSyncContext) {
                        runBoundToSyncAdapter(msgData.syncAdapter);
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
                {
                    ServiceConnectionData msgData = (ServiceConnectionData) msg.obj;
                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
                        Log.d(TAG, ""handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: "" + msgData.activeSyncContext + "" active is "" + mActiveSyncContext);
                    }
                    // check that this isn't an old message
                    if (mActiveSyncContext == msgData.activeSyncContext) {
                        // outstanding
                        if (mActiveSyncContext.mSyncAdapter != null) {
                            try {
                                mActiveSyncContext.mSyncAdapter.cancelSync(mActiveSyncContext);
                            } catch (RemoteException e) {
                            // we don't need to retry this in this case
                            }
                        }
                        // pretend that the sync failed with an IOException,
                        // which is a soft error
                        SyncResult syncResult = new SyncResult();
                        syncResult.stats.numIoExceptions++;
                        runSyncFinishedOrCanceled(syncResult);
                        // since we are no longer syncing, check if it is time to start a new
                        // sync
                        runStateIdle();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_SYNC_ALARM:
                {
                    boolean isLoggable = Log.isLoggable(TAG, Log.VERBOSE);
                    if (isLoggable) {
                        Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_SYNC_ALARM"");
                    }
                    mAlarmScheduleTime = null;
                    try {
                        if (mActiveSyncContext != null) {
                            if (isLoggable) {
                                Log.v(TAG, ""handleSyncHandlerMessage: sync context is active"");
                            }
                            runStateSyncing();
                        }
                        // check if it is time to start a new sync
                        if (mActiveSyncContext == null) {
                            if (isLoggable) {
                                Log.v(TAG, ""handleSyncHandlerMessage: "" + ""sync context is not active"");
                            }
                            runStateIdle();
                        }
                    } finally {
                        mHandleAlarmWakeLock.release();
                    }
                    break;
                }
            case SyncHandler.MESSAGE_CHECK_ALARMS:
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS"");
                }
                // we do all the work for this case in the finally block
                break;
        }
    } finally {
        final boolean isSyncInProgress = mActiveSyncContext != null;
        if (!isSyncInProgress) {
            mSyncWakeLock.release();
        }
        manageSyncNotification();
        manageErrorNotification();
        manageSyncAlarm();
        mSyncTimeTracker.update();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, a switch-case structure was introduced to handle different cases for msg. Return statements and Exception handling statement were also added. So, the code change type is 1,3,4.","The introduction of return statements and change in handling conditions can lead to differences in the return values and hence, the behavior of the API in different cases. Therefore, the CI type is 1."
18,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,int)>",4,5,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,int)>",0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = 0;
    ev.mEdgeFlags = 0;
    ev.mDownTime = downTime;
    ev.mEventTime = eventTime;
    ev.mAction = action;
    ev.mX = ev.mRawX = x;
    ev.mY = ev.mRawY = y;
    ev.mPressure = 1.0f;
    ev.mSize = 1.0f;
    ev.mMetaState = metaState;
    ev.mXPrecision = 1.0f;
    ev.mYPrecision = 1.0f;
    return ev;
}","{
    MotionEvent ev = obtain();
    ev.mDeviceId = 0;
    ev.mEdgeFlags = 0;
    ev.mDownTime = downTime;
    ev.mEventTimeNano = eventTime * 1000000;
    ev.mAction = action;
    ev.mNumPointers = 1;
    ev.mMetaState = metaState;
    ev.mXPrecision = 1.0f;
    ev.mYPrecision = 1.0f;
    ev.mNumPointers = 1;
    ev.mNumSamples = 1;
    int[] pointerIds = ev.mPointerIdentifiers;
    pointerIds[0] = 0;
    float[] data = ev.mDataSamples;
    data[SAMPLE_X] = ev.mRawX = x;
    data[SAMPLE_Y] = ev.mRawY = y;
    data[SAMPLE_PRESSURE] = 1.0f;
    data[SAMPLE_SIZE] = 1.0f;
    ev.mTimeSamples[0] = eventTime;
    return ev;
}",1,"/**
 * Create a new MotionEvent, filling in a subset of the basic motion
 * values.  Those not specified here are: device id (always 0), pressure
 * and size (always 1), x and y precision (always 1), and edgeFlags (always 0).
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 */
","/**
 * Create a new MotionEvent, filling in a subset of the basic motion
 * values.  Those not specified here are: device id (always 0), pressure
 * and size (always 1), x and y precision (always 1), and edgeFlags (always 0).
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Several assignments to properties of object 'ev' are either completely new or they are altered in the Late_Implementation. For example, ev.mEventTime is replaced by  ev.mEventTimeNano = eventTime * 1000000, several new assignments like ev.mNumSamples = 1 and ev.mTimeSamples[0] = eventTime, are introduced. Hence, the change type is 1,4.","The change in object 'ev' property values and the addition of new assignments could potentially change the object returned by the API. Therefore, the CI type is 1."
19,<android.webkit.WebSyncManager: void stopSync()>,4,5,<android.webkit.WebSyncManager: void stopSync()>,<android.webkit.WebSyncManager: void stopSync()>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""*** WebSyncManager stopSync ***, Ref count:"" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (--mStartSyncRefCount == 0) {
        mHandler.removeMessages(SYNC_MESSAGE);
    }
}","{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, ""*** WebSyncManager stopSync ***, Ref count:"" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (--mStartSyncRefCount == 0) {
        mHandler.removeMessages(SYNC_MESSAGE);
    }
}",1,"/**
 * stopSync() requests sync manager to stop sync. remove any SYNC_MESSAGE in
 * the queue to break the sync loop
 */
","/**
 * stopSync() requests sync manager to stop sync. remove any SYNC_MESSAGE in
 * the queue to break the sync loop
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The log statement has changed, where the condition statement has modified from WebView.LOGV_ENABLED to DebugFlags.WEB_SYNC_MANAGER, so the code change type is 4.","The change is on the logging functionality, which doesn't modify the functionality, return values, or exceptions of the API. Therefore, there is no compatibility issue (CI type 0)."
20,<android.webkit.StreamLoader: void handleMessage(Message)>,4,5,<android.webkit.StreamLoader: void handleMessage(Message)>,<android.webkit.StreamLoader: void handleMessage(Message)>,0,"{
    if (WebView.DEBUG && mHandler.isSynchronous()) {
        throw new AssertionError();
    }
    switch(msg.what) {
        case MSG_STATUS:
            if (setupStreamAndSendStatus()) {
                // We were able to open the stream, create the array
                // to pass data to the loader
                mData = new byte[8192];
                sendMessage(obtainMessage(MSG_HEADERS));
            }
            break;
        case MSG_HEADERS:
            sendHeaders();
            sendMessage(obtainMessage(MSG_DATA));
            break;
        case MSG_DATA:
            if (sendData()) {
                sendMessage(obtainMessage(MSG_END));
            } else {
                sendMessage(obtainMessage(MSG_DATA));
            }
            break;
        case MSG_END:
            closeStreamAndSendEndData();
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    if (DebugFlags.STREAM_LOADER && mHandler.isSynchronous()) {
        throw new AssertionError();
    }
    if (mHandler.cancelled()) {
        closeStreamAndSendEndData();
        return;
    }
    switch(msg.what) {
        case MSG_STATUS:
            if (setupStreamAndSendStatus()) {
                // We were able to open the stream, create the array
                // to pass data to the loader
                mData = new byte[8192];
                sendMessage(obtainMessage(MSG_HEADERS));
            }
            break;
        case MSG_HEADERS:
            sendHeaders();
            sendMessage(obtainMessage(MSG_DATA));
            break;
        case MSG_DATA:
            if (sendData()) {
                sendMessage(obtainMessage(MSG_END));
            } else {
                sendMessage(obtainMessage(MSG_DATA));
            }
            break;
        case MSG_END:
            closeStreamAndSendEndData();
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,"/* (non-Javadoc)
     * @see android.os.Handler#handleMessage(android.os.Message)
     */
","/* (non-Javadoc)
     * @see android.os.Handler#handleMessage(android.os.Message)
     */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","A new return statement is introduced in the late version('return' after 'closeStreamAndSendEndData()'). Also, the 'if' condition check is changed from 'WebView.DEBUG' to 'DebugFlags.STREAM_LOADER' and a new 'if' condition check 'mHandler.cancelled()' is added. So, the code change type is 1,3.","The introduced return statement can potentially change the execution flow and terminate the method early leading to different return behaviour. Combination of this new return statement and the changed condition check 'mHandler.cancelled()' can potentially throw different exceptions when the condition is met. Therefore, the CI type is 1,2."
22,<android.content.TempProviderSyncAdapter.SyncThread: void run()>,4,5,<android.content.TempProviderSyncAdapter.SyncThread: void run()>,<android.content.TempProviderSyncAdapter.SyncThread: void run()>,0,"{
    Process.setThreadPriority(Process.myTid(), Process.THREAD_PRIORITY_BACKGROUND);
    int uid = Process.myUid();
    mInitialTxBytes = NetStat.getUidTxBytes(uid);
    mInitialRxBytes = NetStat.getUidRxBytes(uid);
    try {
        sync(mSyncContext, mAccount, mExtras);
    } catch (SQLException e) {
        Log.e(TAG, ""Sync failed"", e);
        mResult.databaseError = true;
    } finally {
        mSyncThread = null;
        if (!mIsCanceled) {
            logSyncDetails(NetStat.getUidTxBytes(uid) - mInitialTxBytes, NetStat.getUidRxBytes(uid) - mInitialRxBytes, mResult);
            mSyncContext.onFinished(mResult);
        }
    }
}","{
    Process.setThreadPriority(Process.myTid(), Process.THREAD_PRIORITY_BACKGROUND);
    int uid = Process.myUid();
    mInitialTxBytes = NetStat.getUidTxBytes(uid);
    mInitialRxBytes = NetStat.getUidRxBytes(uid);
    try {
        sync(mSyncContext, mAccount, mAuthority, mExtras);
    } catch (SQLException e) {
        Log.e(TAG, ""Sync failed"", e);
        mResult.databaseError = true;
    } finally {
        mSyncThread = null;
        if (!mIsCanceled) {
            logSyncDetails(NetStat.getUidTxBytes(uid) - mInitialTxBytes, NetStat.getUidRxBytes(uid) - mInitialRxBytes, mResult);
            mSyncContext.onFinished(mResult);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method sync() in the implementation has additional parameter mAuthority in the late version. Hence, the code change type is 4 (Other statement changed because of additional parameter) and also 5 (Dependent API changed as the number of parameters and type has changed in dependent sync() API).","The sync() method's behavior might now differ with addition of new parameter mAuthority, hence potentially returning different results, so the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
23,<android.widget.TabHost: void setup()>,4,5,<android.widget.TabHost: void setup()>,<android.widget.TabHost: void setup()>,0,"{
    mTabWidget = (TabWidget) findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException(""Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'"");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = (FrameLayout) findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException(""Your TabHost must have a FrameLayout whose id attribute is 'android.R.id.tabcontent'"");
    }
}","{
    mTabWidget = (TabWidget) findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException(""Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'"");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = (FrameLayout) findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException(""Your TabHost must have a FrameLayout whose id attribute is "" + ""'android.R.id.tabcontent'"");
    }
}",1,"/**
 * <p>Call setup() before adding tabs if loading TabHost using findViewById().
 * <i><b>However</i></b>: You do not need to call setup() after getTabHost()
 * in {@link android.app.TabActivity TabActivity}.
 * Example:</p>
 * <pre>mTabHost = (TabHost)findViewById(R.id.tabhost);
 * mTabHost.setup();
 * mTabHost.addTab(TAB_TAG_1, ""Hello, world!"", ""Tab 1"");
 */
","/**
 * <p>Call setup() before adding tabs if loading TabHost using findViewById().
 * <i><b>However</i></b>: You do not need to call setup() after getTabHost()
 * in {@link android.app.TabActivity TabActivity}.
 * Example:</p>
 * <pre>mTabHost = (TabHost)findViewById(R.id.tabhost);
 * mTabHost.setup();
 * mTabHost.addTab(TAB_TAG_1, ""Hello, world!"", ""Tab 1"");
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The change is in the string concatenation in the 'RuntimeException' error message. The error message has a part of its text generated dynamically in the late version rather than a static string in the early version. This change falls under the category 'other statement changed'.,No Compatibility Issue exists as an exception message change doesn't alter the API's behavior in returning a value or throwing exceptions under different circumstances.
24,<android.view.MotionEvent: float getHistoricalX(int)>,4,5,<android.view.MotionEvent: float getHistoricalX(int)>,<android.view.MotionEvent: float getHistoricalX(int)>,0,"{
    return mHistory[pos * 4];
}","{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_X];
}",1,"/**
 * Returns a historical X coordinate that occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getX
 */
","/**
 * {@link #getHistoricalX(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the late version of the API, the return value is changed from 'mHistory[pos * 4]' to 'mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_X]'. The dependent API changed because 'mDataSamples' and 'mHistory' is different, so the change type is 1,5.","The change of dependent API and return statement might lead to return a different data, so the CI type is 1."
26,"<android.os.Vibrator: void vibrate(long[],int)>",4,5,"<android.os.Vibrator: void vibrate(long[],int)>","<android.os.Vibrator: void vibrate(long[],int)>",0,"{
    // anyway
    if (repeat < pattern.length) {
        try {
            mService.vibratePattern(pattern, repeat, new Binder());
        } catch (RemoteException e) {
        }
    } else {
        throw new ArrayIndexOutOfBoundsException();
    }
}","{
    // anyway
    if (repeat < pattern.length) {
        try {
            mService.vibratePattern(pattern, repeat, mToken);
        } catch (RemoteException e) {
        }
    } else {
        throw new ArrayIndexOutOfBoundsException();
    }
}",1,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the times at which to turn on or off
 * the vibrator.  The first one is how long to wait before turning it on,
 * and then after that it alternates.  If you want to repeat, pass the
 * index into the pattern at which to start the repeat.
 *
 * @param pattern an array of longs of times to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the times at which to turn on or off
 * the vibrator.  The first one is how long to wait before turning it on,
 * and then after that it alternates.  If you want to repeat, pass the
 * index into the pattern at which to start the repeat.
 *
 * @param pattern an array of longs of times to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The 'new Binder()' in the API vibratePattern() method has been replaced with 'mToken', which classifies it as other statements changed.","This change does not affect the return values or the exception handling of the function since it only modifies the parameters from 'new Binder()' to 'mToken'. Hence, there is no Compatibility Issue with this change."
27,<android.webkit.WebView: int computeHorizontalScrollRange()>,4,5,<android.webkit.WebView: int computeHorizontalScrollRange()>,<android.webkit.WebView: int computeHorizontalScrollRange()>,0,"{
    if (mDrawHistory) {
        return mHistoryWidth;
    } else {
        return contentToView(mContentWidth);
    }
}","{
    if (mDrawHistory) {
        return mHistoryWidth;
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentWidth * mActualScale);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"In the early version, the return statement within the 'else' block is 'return contentToView(mContentWidth)', while in the late version, it changes to 'return (int) Math.floor(mContentWidth * mActualScale)'. Beside this return statement change, the control statement 'contentToView' with parameter 'mContentWidth' is also changed, so the code change type is 1,3.","The change of return statement 'return (int) Math.floor(mContentWidth * mActualScale)' will potentially make the API return a different value than the early version 'return contentToView(mContentWidth)', so the CI type is 1."
28,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,4,5,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    final int x = (int) ev.getX();
    final int y = (int) ev.getY();
    View v;
    int deltaY;
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                int motionPosition = pointToPosition(x, y);
                if (!mDataChanged) {
                    if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                        // User clicked on an actual view (and was not stopping a fling). It might be a
                        // click or a scroll. Assume it is a click until proven otherwise
                        mTouchMode = TOUCH_MODE_DOWN;
                        // FIXME Debounce
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
                            // code in ViewRoot to try to find a nearby view to select
                            return false;
                        }
                        // User clicked on whitespace, or stopped a fling. It is a scroll.
                        createScrollingCache();
                        mTouchMode = TOUCH_MODE_SCROLL;
                        mMotionCorrection = 0;
                        motionPosition = findMotionRow(y);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                }
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                }
                mLastY = Integer.MIN_VALUE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                deltaY = y - mMotionY;
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(deltaY);
                        break;
                    case TOUCH_MODE_SCROLL:
                        if (PROFILE_SCROLLING) {
                            if (!mScrollProfilingStarted) {
                                Debug.startMethodTracing(""AbsListViewScroll"");
                                mScrollProfilingStarted = true;
                            }
                        }
                        if (y != mLastY) {
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            trackMotionScroll(deltaY, incrementalDeltaY);
                            // Check to see if we have bumped into the scroll limit
                            View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                            if (motionView != null) {
                                // supposed to be
                                if (motionView.getTop() != mMotionViewNewTop) {
                                    // We did not scroll the full amount. Treat this essentially like the
                                    // start of a new touch scroll
                                    final int motionPosition = findMotionRow(y);
                                    mMotionCorrection = 0;
                                    motionView = getChildAt(motionPosition - mFirstPosition);
                                    mMotionViewOriginalTop = motionView.getTop();
                                    mMotionY = y;
                                    mMotionPosition = motionPosition;
                                }
                            }
                            mLastY = y;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mChild = child;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                mTouchMode = TOUCH_MODE_TAP;
                                if (!mDataChanged) {
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    postDelayed(new Runnable() {

                                        public void run() {
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                post(performClick);
                                            }
                                            mTouchMode = TOUCH_MODE_REST;
                                        }
                                    }, ViewConfiguration.getPressedStateDuration());
                                }
                                return true;
                            } else {
                                if (!mDataChanged) {
                                    post(performClick);
                                }
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        break;
                    case TOUCH_MODE_SCROLL:
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity();
                        if (Math.abs(initialVelocity) > mMinimumVelocity && (getChildCount() > 0)) {
                            if (mFlingRunnable == null) {
                                mFlingRunnable = new FlingRunnable();
                            }
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                            mFlingRunnable.start(-initialVelocity);
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                }
                setPressed(false);
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                mTouchMode = TOUCH_MODE_REST;
                setPressed(false);
                View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                if (motionView != null) {
                    motionView.setPressed(false);
                }
                clearScrollingCache();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    final int x = (int) ev.getX();
    final int y = (int) ev.getY();
    View v;
    int deltaY;
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                int motionPosition = pointToPosition(x, y);
                if (!mDataChanged) {
                    if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                        // User clicked on an actual view (and was not stopping a fling). It might be a
                        // click or a scroll. Assume it is a click until proven otherwise
                        mTouchMode = TOUCH_MODE_DOWN;
                        // FIXME Debounce
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
                            // code in ViewRoot to try to find a nearby view to select
                            return false;
                        }
                        // User clicked on whitespace, or stopped a fling. It is a scroll.
                        createScrollingCache();
                        mTouchMode = TOUCH_MODE_SCROLL;
                        mMotionCorrection = 0;
                        motionPosition = findMotionRow(y);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                }
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                }
                mLastY = Integer.MIN_VALUE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                deltaY = y - mMotionY;
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(deltaY);
                        break;
                    case TOUCH_MODE_SCROLL:
                        if (PROFILE_SCROLLING) {
                            if (!mScrollProfilingStarted) {
                                Debug.startMethodTracing(""AbsListViewScroll"");
                                mScrollProfilingStarted = true;
                            }
                        }
                        if (y != mLastY) {
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            // No need to do all this work if we're not going to move anyway
                            if (incrementalDeltaY != 0) {
                                trackMotionScroll(deltaY, incrementalDeltaY);
                            }
                            // Check to see if we have bumped into the scroll limit
                            View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                            if (motionView != null) {
                                // supposed to be
                                if (motionView.getTop() != mMotionViewNewTop) {
                                    // We did not scroll the full amount. Treat this essentially like the
                                    // start of a new touch scroll
                                    final int motionPosition = findMotionRow(y);
                                    mMotionCorrection = 0;
                                    motionView = getChildAt(motionPosition - mFirstPosition);
                                    mMotionViewOriginalTop = motionView.getTop();
                                    mMotionY = y;
                                    mMotionPosition = motionPosition;
                                }
                            }
                            mLastY = y;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mChild = child;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                mTouchMode = TOUCH_MODE_TAP;
                                if (!mDataChanged) {
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    postDelayed(new Runnable() {

                                        public void run() {
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                post(performClick);
                                            }
                                            mTouchMode = TOUCH_MODE_REST;
                                        }
                                    }, ViewConfiguration.getPressedStateDuration());
                                }
                                return true;
                            } else {
                                if (!mDataChanged) {
                                    post(performClick);
                                }
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) velocityTracker.getYVelocity();
                                if (Math.abs(initialVelocity) > mMinimumVelocity) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                }
                setPressed(false);
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                mTouchMode = TOUCH_MODE_REST;
                setPressed(false);
                View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                if (motionView != null) {
                    motionView.setPressed(false);
                }
                clearScrollingCache();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Between the early version and the late version of the implementation, there are changes in the control dependency of return statements. Several control statements are added or modified in the late version, such as the addition of `if (!isEnabled())` at the beginning of the method, and the condition after `if (childCount > 0)` is added within `case TOUCH_MODE_SCROLL:`. There are also other changes, therefore, the change type is 3,4.","Due to the changes in the control branches, especially the newly added `if (!isEnabled())`, could cause the API to potentially return different values. Therefore, the CI type is 1."
30,<android.webkit.WebSyncManager: void sync()>,4,5,<android.webkit.WebSyncManager: void sync()>,<android.webkit.WebSyncManager: void sync()>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""*** WebSyncManager sync ***"");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_NOW_INTERVAL);
}","{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, ""*** WebSyncManager sync ***"");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_NOW_INTERVAL);
}",1,"/**
 * sync() forces sync manager to sync now
 */
","/**
 * sync() forces sync manager to sync now
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The boolean condition in the ""if"" statement has changed from WebView.LOGV_ENABLED to DebugFlags.WEB_SYNC_MANAGER, thus the change type is 4 (Other statement changed).","This change will not affect the behavior of the API, as it is only logging related. The 'sync' action isn't influenced by this change. Therefore, there is no compatibility issue (CI type is 0)."
32,<android.app.LauncherActivity: List<ListItem> makeListItems()>,4,5,<android.app.LauncherActivity: List<ListItem> makeListItems()>,<android.app.LauncherActivity: List<ListItem> makeListItems()>,0,"{
    // Load all matching activities and sort correctly
    List<ResolveInfo> list = mPackageManager.queryIntentActivities(mIntent, /* no flags */
    0);
    Collections.sort(list, new ResolveInfo.DisplayNameComparator(mPackageManager));
    IconResizer resizer = new IconResizer();
    ArrayList<ListItem> result = new ArrayList<ListItem>(list.size());
    int listSize = list.size();
    for (int i = 0; i < listSize; i++) {
        ResolveInfo resolveInfo = list.get(i);
        result.add(new ListItem(mPackageManager, resolveInfo, resizer));
    }
    return result;
}","{
    // Load all matching activities and sort correctly
    List<ResolveInfo> list = onQueryPackageManager(mIntent);
    Collections.sort(list, new ResolveInfo.DisplayNameComparator(mPackageManager));
    ArrayList<ListItem> result = new ArrayList<ListItem>(list.size());
    int listSize = list.size();
    for (int i = 0; i < listSize; i++) {
        ResolveInfo resolveInfo = list.get(i);
        result.add(new ListItem(mPackageManager, resolveInfo, null));
    }
    return result;
}",1,"/**
 * Perform the query to determine which results to show and return a list of them.
 */
","/**
 * Perform the query to determine which results to show and return a list of them.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method mPackageManager.queryIntentActivities(mIntent, /* no flags */ 0), has been replaced by onQueryPackageManager(mIntent) which may or may not be an equivalent operation (type 5 change). The passed resizer parameter in the newly created ListItem changes from a 'resizer' instance to 'null' (type 1 and 4 changes).","Since the retrieval and sorting of ResolveInfo list might have changed due to the dependent API change (onQueryPackageManager replaces queryIntentActivities) and the creation of new ListItem instance has changed due to passing null instead of 'resizer', this could potentially return a different List of ListItem. Thus, the CI type is 1."
34,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,4,5,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,0,"{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        mPrivateHandler.removeMessages(SWITCH_TO_ENTER);
        mTrackballDown = true;
        if (mNativeClass != 0) {
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
        }
        if (time - mLastFocusTime <= TRACKBALL_TIMEOUT && !mLastFocusBounds.equals(nativeGetFocusRingBounds())) {
            nativeSelectBestAt(mLastFocusBounds);
        }
        if (LOGV_ENABLED) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastFocusTime="" + mLastFocusTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_ENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_ENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mShiftIsPressed) {
            if (mExtendSelection) {
                commitCopy();
            } else {
                mExtendSelection = true;
            }
        }
        if (LOGV_ENABLED) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
        if (LOGV_ENABLED)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    // no move if we're still waiting on SWITCH_TO_ENTER timeout
    if (mTouchMode == TOUCH_DOUBLECLICK_MODE) {
        if (LOGV_ENABLED)
            Log.v(LOGTAG, ""onTrackballEvent 2 click quit"");
        return true;
    }
    if (mTrackballDown) {
        if (LOGV_ENABLED)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (LOGV_ENABLED)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (LOGV_ENABLED) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (LOGV_ENABLED) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time);
    return true;
}","{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mShiftIsPressed) {
            if (mExtendSelection) {
                commitCopy();
            } else {
                mExtendSelection = true;
            }
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Several statements have been changed within the implementation, such as the deletion of `mPrivateHandler.removeMessages(SWITCH_TO_ENTER);` and replacement with `SWITCH_TO_ENTER` to `LONG_PRESS_CENTER`. The method `nativeGetFocusRingBounds()` has been changed to `nativeGetCursorRingBounds()`, and `mLastFocusTime` has been changed to `mLastCursorTime`. The 'if' condition check for `LOGV_ENABLED` was replaced by `DebugFlags.WEB_VIEW`, and an ""if"" condition which checks `mNativeClass == 0` has also been added. Thus, the code change belongs to type 3 and 4. ","Despite the changes, these modifications do not make the API return a different value or throw a different exception, hence there is no compatibility issue. The changes made only affect the internal process of the implementation and do not alter the overall behavior of the API on the user end."
35,<android.webkit.WebView: boolean pageDown(boolean)>,4,5,<android.webkit.WebView: boolean pageDown(boolean)>,<android.webkit.WebView: boolean pageDown(boolean)>,0,"{
    if (mNativeClass == 0) {
        return false;
    }
    nativeClearFocus(-1, -1);
    if (bottom) {
        return pinScrollTo(mScrollX, mContentHeight, true, 0);
    }
    // Page down.
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = h - PAGE_SCROLL_OVERLAP;
    } else {
        y = h / 2;
    }
    mUserScroll = true;
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}","{
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (bottom) {
        return pinScrollTo(mScrollX, mContentHeight, true, 0);
    }
    // Page down.
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = h - PAGE_SCROLL_OVERLAP;
    } else {
        y = h / 2;
    }
    mUserScroll = true;
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}",1,"/**
 * Scroll the contents of the view down by half the page size
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
","/**
 * Scroll the contents of the view down by half the page size
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's a change in the call of 'nativeClearFocus' to 'nativeClearCursor'. Therefore, the type of code change is 4 (Other statement changed).","The change in the method called does not affect the return variables or the exceptions thrown by the method, hence there's no Compatibility Issue, type 0."
36,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,4,5,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View)>,0,"{
    final View target = root.findViewById(viewId);
    if (target != null && pendingIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                try {
                    // TODO: Unregister this handler if PendingIntent.FLAG_ONE_SHOT?
                    pendingIntent.send();
                } catch (CanceledException e) {
                    throw new ActionException(e.toString());
                }
            }
        };
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target != null && pendingIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                try {
                    // TODO: Unregister this handler if PendingIntent.FLAG_ONE_SHOT?
                    v.getContext().startIntentSender(pendingIntent.getIntentSender(), null, Intent.FLAG_ACTIVITY_NEW_TASK, Intent.FLAG_ACTIVITY_NEW_TASK, 0);
                } catch (IntentSender.SendIntentException e) {
                    android.util.Log.e(LOG_TAG, ""Cannot send pending intent: "", e);
                }
            }
        };
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the late version, the method to send an intent has changed from 'pendingIntent.send()' to 'v.getContext().startIntentSender(pendingIntent.getIntentSender(), null, Intent.FLAG_ACTIVITY_NEW_TASK, Intent.FLAG_ACTIVITY_NEW_TASK, 0)', and the exception handling inside the try-catch block has also changed. So the change type is 1,2,4.","The changes inside the onClick() method can potentially lead to different behaviours. For example, the new way of sending an intent may trigger different activities or services, and the new exception handling may throw a different exception or log different error messages. Therefore, the CI type is 1,2."
37,<android.content.res.Configuration: int hashCode()>,4,5,<android.content.res.Configuration: int hashCode()>,<android.content.res.Configuration: int hashCode()>,0,"{
    return ((int) this.fontScale) + this.mcc + this.mnc + this.locale.hashCode() + this.touchscreen + this.keyboard + this.keyboardHidden + this.hardKeyboardHidden + this.navigation + this.orientation + this.screenLayout;
}","{
    return ((int) this.fontScale) + this.mcc + this.mnc + this.locale.hashCode() + this.touchscreen + this.keyboard + this.keyboardHidden + this.hardKeyboardHidden + this.navigation + this.navigationHidden + this.orientation + this.screenLayout;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The return statement in the late version has introduced a new variable `this.navigationHidden` to calculate the `hashCode`. Therefore, the code change type is 4.","As an additional variable (`this.navigationHidden`) is included in the return statement in the late version, this could potentially cause the API to return different integer values. Hence, the Compatibility Issue type is 1."
39,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",4,5,"<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>","<android.net.ConnectivityManager: int startUsingNetworkFeature(int,String)>",0,"{
    try {
        return mService.startUsingNetworkFeature(networkType, feature);
    } catch (RemoteException e) {
        return -1;
    }
}","{
    try {
        return mService.startUsingNetworkFeature(networkType, feature, new Binder());
    } catch (RemoteException e) {
        return -1;
    }
}",1,"/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 */
","/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API mService.startUsingNetworkFeature has changed its signature by adding a new parameter, Binder. So the code change is of type 1,5.","This change leads to the potential alteration of the return value of the API startUsingNetworkFeature. The type of CI here would be 1, indicating potential different return values or types."
42,<android.webkit.Network: boolean saveState(Bundle)>,4,5,<android.webkit.Network: boolean saveState(Bundle)>,<android.webkit.Network: boolean saveState(Bundle)>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""Network.saveState()"");
    }
    return mSslErrorHandler.saveState(outState);
}","{
    if (DebugFlags.NETWORK) {
        Log.v(LOGTAG, ""Network.saveState()"");
    }
    return mSslErrorHandler.saveState(outState);
}",1,"/**
 * Saves the state of network handlers (user SSL and HTTP-authentication
 * preferences).
 * @param outState The out-state to save (write) to.
 * @return True iff succeeds.
 */
","/**
 * Saves the state of network handlers (user SSL and HTTP-authentication
 * preferences).
 * @param outState The out-state to save (write) to.
 * @return True iff succeeds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition in the `if` statement has changed from checking whether 'LOGV_ENABLED' of 'WebView' is true to checking whether 'NETWORK' of 'DebugFlags' is true, which is a control dependency (condition) change. Additionally, any change of condition can also be regarded as 'Other statement changed', so the code change type is 3,4.","Although the condition statement has been changed, both versions of the methods produce the same return value and there is no difference in the types or value of exceptions thrown. The control dependency change does not affect how the method behaves, so there are no compatibility issues, thus the CI type is 0."
44,"<android.app.Activity: boolean onKeyUp(int,KeyEvent)>",4,5,"<android.app.Activity: boolean onKeyUp(int,KeyEvent)>","<android.app.Activity: boolean onKeyUp(int,KeyEvent)>",0,"{
    return false;
}","{
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
            onBackPressed();
            return true;
        }
    }
    return false;
}",1,"/**
 * Called when a key was released and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyDown
 * @see KeyEvent
 */
","/**
 * Called when a key was released and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>The default implementation handles KEYCODE_BACK to stop the activity
 * and go back.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyDown
 * @see KeyEvent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The logic in the onKeyUp method has changed. In the late version, it now checks if the application's target SDK version is greater than or equal to the ECLAIR version of Android, and then further handles the back key event accordingly. Thus, the code change involves both return statement and control dependencies. Therefore, the change types are 1 and 3.","The return values in the early version and late version of the API may not be the same, resulting a different behavior. Hence, the compatibility issue type is 1."
45,<android.view.MotionEvent: MotionEvent obtain(MotionEvent)>,4,5,<android.view.MotionEvent: MotionEvent obtain(MotionEvent)>,<android.view.MotionEvent: MotionEvent obtain(MotionEvent)>,0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = o.mDeviceId;
    ev.mEdgeFlags = o.mEdgeFlags;
    ev.mDownTime = o.mDownTime;
    ev.mEventTime = o.mEventTime;
    ev.mAction = o.mAction;
    ev.mX = o.mX;
    ev.mRawX = o.mRawX;
    ev.mY = o.mY;
    ev.mRawY = o.mRawY;
    ev.mPressure = o.mPressure;
    ev.mSize = o.mSize;
    ev.mMetaState = o.mMetaState;
    ev.mXPrecision = o.mXPrecision;
    ev.mYPrecision = o.mYPrecision;
    final int N = o.mNumHistory;
    ev.mNumHistory = N;
    if (N > 0) {
        // could be more efficient about this...
        ev.mHistory = (float[]) o.mHistory.clone();
        ev.mHistoryTimes = (long[]) o.mHistoryTimes.clone();
    }
    return ev;
}","{
    MotionEvent ev = obtain();
    ev.mDeviceId = o.mDeviceId;
    ev.mEdgeFlags = o.mEdgeFlags;
    ev.mDownTime = o.mDownTime;
    ev.mEventTimeNano = o.mEventTimeNano;
    ev.mAction = o.mAction;
    ev.mNumPointers = o.mNumPointers;
    ev.mRawX = o.mRawX;
    ev.mRawY = o.mRawY;
    ev.mMetaState = o.mMetaState;
    ev.mXPrecision = o.mXPrecision;
    ev.mYPrecision = o.mYPrecision;
    final int NS = ev.mNumSamples = o.mNumSamples;
    if (ev.mTimeSamples.length >= NS) {
        System.arraycopy(o.mTimeSamples, 0, ev.mTimeSamples, 0, NS);
    } else {
        ev.mTimeSamples = (long[]) o.mTimeSamples.clone();
    }
    final int NP = (ev.mNumPointers = o.mNumPointers);
    if (ev.mPointerIdentifiers.length >= NP) {
        System.arraycopy(o.mPointerIdentifiers, 0, ev.mPointerIdentifiers, 0, NP);
    } else {
        ev.mPointerIdentifiers = (int[]) o.mPointerIdentifiers.clone();
    }
    final int ND = NP * NS * NUM_SAMPLE_DATA;
    if (ev.mDataSamples.length >= ND) {
        System.arraycopy(o.mDataSamples, 0, ev.mDataSamples, 0, ND);
    } else {
        ev.mDataSamples = (float[]) o.mDataSamples.clone();
    }
    return ev;
}",1,"/**
 * Create a new MotionEvent, copying from an existing one.
 */
","/**
 * Create a new MotionEvent, copying from an existing one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The initializations of variables like `mEventTimeNano`, `mNumPointers`, `mTimeSamples`, `mPointerIdentifiers`, and the `mDataSamples`, etc have been introduced and others like `mEventTime`, `mX`, `mY`, `mPressure`, `mSize`, and `mNumHistory` etc have been removed. In addition, logic control changed with the introduction of a new 'if' condition statement on `mTimeSamples`, `mPointerIdentifiers`, and `mDataSamples`, therefore the code change type is 1,3,4.","Variables initialized in the function will affect the fields of the MotionEvent object being returned, hence causing the return value to potentially change. Therefore, there is a Compatibility Issue caused by potential different return values or types, and the CI type is 1."
46,<android.widget.ListView: boolean pageScroll(int)>,4,5,<android.widget.ListView: boolean pageScroll(int)>,<android.widget.ListView: boolean pageScroll(int)>,0,"{
    int nextPage = -1;
    boolean down = false;
    if (direction == FOCUS_UP) {
        nextPage = Math.max(0, mSelectedPosition - getChildCount() - 1);
    } else if (direction == FOCUS_DOWN) {
        nextPage = Math.min(mItemCount - 1, mSelectedPosition + getChildCount() - 1);
        down = true;
    }
    if (nextPage >= 0) {
        int position = lookForSelectablePosition(nextPage, down);
        if (position >= 0) {
            mLayoutMode = LAYOUT_SPECIFIC;
            mSpecificTop = mPaddingTop + getVerticalFadingEdgeLength();
            if (down && position > mItemCount - getChildCount()) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
            }
            if (!down && position < getChildCount()) {
                mLayoutMode = LAYOUT_FORCE_TOP;
            }
            setSelectionInt(position);
            invokeOnItemScrollListener();
            invalidate();
            return true;
        }
    }
    return false;
}","{
    int nextPage = -1;
    boolean down = false;
    if (direction == FOCUS_UP) {
        nextPage = Math.max(0, mSelectedPosition - getChildCount() - 1);
    } else if (direction == FOCUS_DOWN) {
        nextPage = Math.min(mItemCount - 1, mSelectedPosition + getChildCount() - 1);
        down = true;
    }
    if (nextPage >= 0) {
        int position = lookForSelectablePosition(nextPage, down);
        if (position >= 0) {
            mLayoutMode = LAYOUT_SPECIFIC;
            mSpecificTop = mPaddingTop + getVerticalFadingEdgeLength();
            if (down && position > mItemCount - getChildCount()) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
            }
            if (!down && position < getChildCount()) {
                mLayoutMode = LAYOUT_FORCE_TOP;
            }
            setSelectionInt(position);
            invokeOnItemScrollListener();
            if (!awakenScrollBars()) {
                invalidate();
            }
            return true;
        }
    }
    return false;
}",1,"/**
 * Scrolls up or down by the number of items currently present on screen.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 * @return whether selection was moved
 */
","/**
 * Scrolls up or down by the number of items currently present on screen.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 * @return whether selection was moved
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control statement 'if (!awakenScrollBars())' and operation 'invalidate()' inside the 'if' block are newly introduced in the late version, so the change type is 3,4.","The newly added control statement 'if (!awakenScrollBars())', can potentially influence the execute order of 'invalidate()' operation, resulting in a possible behaviour change and different return, thus the CI type is 1."
47,<android.app.ActivityThread.Idler: boolean queueIdle()>,4,5,<android.app.ActivityThread.Idler: boolean queueIdle()>,<android.app.ActivityThread.Idler: boolean queueIdle()>,0,"{
    ActivityRecord a = mNewActivities;
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityRecord prev;
        do {
            if (localLOGV)
                Log.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null ? a.activity.mFinished : false));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token);
                } catch (RemoteException ex) {
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    return false;
}","{
    ActivityRecord a = mNewActivities;
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityRecord prev;
        do {
            if (localLOGV)
                Log.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null ? a.activity.mFinished : false));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method am.activityIdle(a.token) has been changed to am.activityIdle(a.token, a.createdConfig), and a new line has been added that sets a.createdConfig to null, so the code change type should be 4,5.","Although the call to am.activityIdle() in the newer version of the method includes an additional argument and a createdConfig is set to null, it does not influence the final returned value or the exceptions thrown by the method, so no compatibility issue is present."
49,<android.webkit.WebView: void switchOutDrawHistory()>,4,5,<android.webkit.WebView: void switchOutDrawHistory()>,<android.webkit.WebView: void switchOutDrawHistory()>,0,"{
    // CallbackProxy may trigger this
    if (null == mWebViewCore)
        return;
    if (mDrawHistory) {
        mDrawHistory = false;
        invalidate();
        int oldScrollX = mScrollX;
        int oldScrollY = mScrollY;
        mScrollX = pinLocX(mScrollX);
        mScrollY = pinLocY(mScrollY);
        if (oldScrollX != mScrollX || oldScrollY != mScrollY) {
            mUserScroll = false;
            mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, oldScrollX, oldScrollY);
        }
        sendOurVisibleRect();
    }
}","{
    // CallbackProxy may trigger this
    if (null == mWebViewCore)
        return;
    if (mDrawHistory && mWebViewCore.pictureReady()) {
        mDrawHistory = false;
        invalidate();
        int oldScrollX = mScrollX;
        int oldScrollY = mScrollY;
        mScrollX = pinLocX(mScrollX);
        mScrollY = pinLocY(mScrollY);
        if (oldScrollX != mScrollX || oldScrollY != mScrollY) {
            mUserScroll = false;
            mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, oldScrollX, oldScrollY);
        }
        sendOurVisibleRect();
    }
}",1,"// Should only be called in UI thread
","// Should only be called in UI thread
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement in 'if (mDrawHistory) {...}' has changed by adding the check 'mWebViewCore.pictureReady()' in the late version, hence the code change type is 3.","The added condition 'mWebViewCore.pictureReady()' in the condition statement 'if (mDrawHistory && mWebViewCore.pictureReady()) {...}' in the late version could lead to different logical paths compared with early version, which may cause this method to potentially return different result (since it may not execute the code inside this if statement). Therefore, the CI type is 1."
50,<android.view.View: void setEnabled(boolean)>,4,5,<android.view.View: void setEnabled(boolean)>,<android.view.View: void setEnabled(boolean)>,0,"{
    setFlags(enabled ? ENABLED : DISABLED, ENABLED_MASK);
    /*
         * The View most likely has to change its appearance, so refresh
         * the drawable state.
         */
    refreshDrawableState();
    // Invalidate too, since the default behavior for views is to be
    // be drawn at 50% alpha rather than to change the drawable.
    invalidate();
}","{
    if (enabled == isEnabled())
        return;
    setFlags(enabled ? ENABLED : DISABLED, ENABLED_MASK);
    /*
         * The View most likely has to change its appearance, so refresh
         * the drawable state.
         */
    refreshDrawableState();
    // Invalidate too, since the default behavior for views is to be
    // be drawn at 50% alpha rather than to change the drawable.
    invalidate();
}",1,"/**
 * Set the enabled state of this view. The interpretation of the enabled
 * state varies by subclass.
 *
 * @param enabled True if this view is enabled, false otherwise.
 */
","/**
 * Set the enabled state of this view. The interpretation of the enabled
 * state varies by subclass.
 *
 * @param enabled True if this view is enabled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",0,"A new return statement has been introduced to the late version to prevent unnecessary refresh and invalidate when the enabled status hasn't changed. Also, the introduction of an if-statement shows the control dependency has changed, thus the code change type is 1,3.","The change only adds an early-return condition when the desired enabled state matches the current state. This won't change the behavior when the function actually carries out its main task (i.e., changing the enabled state of the view), so there's no compatibility issue here. The CI type is 0."
52,<android.os.Vibrator: void cancel()>,4,5,<android.os.Vibrator: void cancel()>,<android.os.Vibrator: void cancel()>,0,"{
    try {
        mService.cancelVibrate();
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.cancelVibrate(mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Turn the vibrator off.
 */
","/**
 * Turn the vibrator off.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"In the method cancelVibrate(), a parameter is added in the late version making it to be cancelVibrate(mToken). This changes the dependent API, so it is classified as change type 5.","Despite the change in the dependent API, both the early and late version of the cancel() method don't return a value or throw any exception, so there's no compatibility issue. The CI type is 0."
54,<android.webkit.WebView: int findAll(String)>,4,5,<android.webkit.WebView: int findAll(String)>,<android.webkit.WebView: int findAll(String)>,0,"{
    mFindIsUp = true;
    int result = nativeFindAll(find.toLowerCase(), find.toUpperCase());
    invalidate();
    return result;
}","{
    if (mFindIsUp == false) {
        recordNewContentSize(mContentWidth, mContentHeight + mFindHeight, false);
        mFindIsUp = true;
    }
    int result = nativeFindAll(find.toLowerCase(), find.toUpperCase());
    invalidate();
    return result;
}",1,"/*
     * Find all instances of find on the page and highlight them.
     * @param find  String to find.
     * @return int  The number of occurances of the String ""find""
     *              that were found.
     */
","/*
     * Find all instances of find on the page and highlight them.
     * @param find  String to find.
     * @return int  The number of occurances of the String ""find""
     *              that were found.
     */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"An 'if' statement with recordNewContentSize() and mFindIsUp = true within it is added in the late code version, so the code change type is 3 (Control dependency change).","Even though there is a new 'if' statement, it does not impact the return value of the API or the exception it might throw. Therefore, the CI type is 0 (No Compatibility Issue exist)."
58,<android.app.ActivityThread.H: String codeToString(int)>,4,5,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (localLOGV) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
        }
    }
    return ""(unknown)"";
}","{
    if (localLOGV) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
        }
    }
    return ""(unknown)"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The two new case statements were introduced for "SUICIDE" and "REMOVE_PROVIDER" in the late version. These are both control statement changes (type 3) and return statement changes (type 1).,"The added case statements might lead to different return strings. That is, if the input parameter code is either ""SUICIDE"" or ""REMOVE_PROVIDER"", the early version of the API would return ""(unknown)"", but the late version would return ""SUICIDE"" or ""REMOVE_PROVIDER"". Thus, there is a compatibility issue of type 1."
59,"<android.text.method.CharacterPickerDialog.OptionsAdapter: View getView(int,View,ViewGroup)>",4,5,"<android.text.method.CharacterPickerDialog.OptionsAdapter: View getView(int,View,ViewGroup)>","<android.text.method.CharacterPickerDialog.OptionsAdapter: View getView(int,View,ViewGroup)>",0,"{
    Button b = (Button) mInflater.inflate(R.layout.character_picker_button, null);
    b.setText(String.valueOf(mOptions.charAt(position)));
    return b;
}","{
    Button b = (Button) mInflater.inflate(R.layout.character_picker_button, null);
    b.setText(String.valueOf(mOptions.charAt(position)));
    b.setOnClickListener(CharacterPickerDialog.this);
    return b;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"A new statement 'b.setOnClickListener(CharacterPickerDialog.this);' was introduced, thus the code change type is 4.","The new statement is setting the onClickListener for the button 'b'. Although it does not change the returned 'b', it sets a behaviour for 'b', hence it changes the behaviour of method and leads to the potential different behaviour of the API and the CI type is 1."
60,<android.webkit.WebView: void onWindowFocusChanged(boolean)>,4,5,<android.webkit.WebView: void onWindowFocusChanged(boolean)>,<android.webkit.WebView: void onWindowFocusChanged(boolean)>,0,"{
    if (hasWindowFocus) {
        if (hasFocus()) {
            // If our window regained focus, and we have focus, then begin
            // drawing the focus ring, and restore the TextView if
            // necessary.
            mDrawFocusRing = true;
            if (mNeedsUpdateTextEntry) {
                updateTextEntry();
            }
            if (mNativeClass != 0) {
                nativeRecordButtons(true, false, true);
            }
        } else {
            // If our window gained focus, but we do not have it, do not
            // draw the focus ring.
            mDrawFocusRing = false;
        // We do not call nativeRecordButtons here because we assume
        // that when we lost focus, or window focus, it got called with
        // false for the first parameter
        }
    } else {
        if (getSettings().getBuiltInZoomControls() && !mZoomButtonsController.isVisible()) {
            /*
                 * The zoom controls come in their own window, so our window
                 * loses focus. Our policy is to not draw the focus ring if
                 * our window is not focused, but this is an exception since
                 * the user can still navigate the web page with the zoom
                 * controls showing.
                 */
            // If our window has lost focus, stop drawing the focus ring
            mDrawFocusRing = false;
        }
        mGotKeyDown = false;
        mShiftIsPressed = false;
        if (mNativeClass != 0) {
            nativeRecordButtons(false, false, true);
        }
    }
    invalidate();
    super.onWindowFocusChanged(hasWindowFocus);
}","{
    if (hasWindowFocus) {
        if (hasFocus()) {
            // If our window regained focus, and we have focus, then begin
            // drawing the cursor ring
            mDrawCursorRing = true;
            if (mNativeClass != 0) {
                nativeRecordButtons(true, false, true);
                if (inEditingMode()) {
                    mWebViewCore.sendMessage(EventHub.SET_ACTIVE, 1, 0);
                }
            }
        } else {
            // If our window gained focus, but we do not have it, do not
            // draw the cursor ring.
            mDrawCursorRing = false;
        // We do not call nativeRecordButtons here because we assume
        // that when we lost focus, or window focus, it got called with
        // false for the first parameter
        }
    } else {
        if (getSettings().getBuiltInZoomControls() && !mZoomButtonsController.isVisible()) {
            /*
                 * The zoom controls come in their own window, so our window
                 * loses focus. Our policy is to not draw the cursor ring if
                 * our window is not focused, but this is an exception since
                 * the user can still navigate the web page with the zoom
                 * controls showing.
                 */
            // If our window has lost focus, stop drawing the cursor ring
            mDrawCursorRing = false;
        }
        mGotKeyDown = false;
        mShiftIsPressed = false;
        if (mNativeClass != 0) {
            nativeRecordButtons(false, false, true);
        }
        setFocusControllerInactive();
    }
    invalidate();
    super.onWindowFocusChanged(hasWindowFocus);
}",1,"// loses focus.
","// loses focus.
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",0,"Several changes exist in the code: The variable mDrawFocusRing has been changed to mDrawCursorRing; a piece of code regarding to mNeedsUpdateTextEntry and updateTextEntry() has been removed; a fragment of code about inEditingMode() and mWebViewCore.sendMessage(EventHub.SET_ACTIVE, 1, 0) has been added; and a setFocusControllerInactive() statement has been introduced. These changes can be classified as 3 (Control dependency changed) and 4 (Other statement changed) based on their nature. ",No Compatibility Issue exists here because these changes don't cause the method to throw new exceptions or return different results.
61,<android.widget.GridView: void layoutChildren()>,4,5,<android.widget.GridView: void layoutChildren()>,<android.widget.GridView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(sel);
            mSelectedTop = sel.getTop();
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                break;
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillSelection(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(mSelectedPosition, mSpecificTop);
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                // Move the selection relative to its old position
                sel = moveSelection(delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        setSelectedPositionInt(0);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int last = mItemCount - 1;
                        setSelectedPositionInt(last);
                        sel = fillFromBottom(last, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            positionSelector(sel);
            mSelectedTop = sel.getTop();
        } else if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
            View child = getChildAt(mMotionPosition - mFirstPosition);
            if (child != null)
                positionSelector(child);
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The code has an additional condition statement (else if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL)) in the second function version, which can change the flow of control in the function. Therefore, the change type is 3 for Control Dependency Change.","While the control dependency has changed, considering the function does not return any value and the new condition statement also does not throw any new types of exceptions, it does not lead to a compatibility issue. Hence, it's classified as CI type 0. There is no Compatibility Issue."
62,<android.webkit.FrameLoader: boolean executeLoad()>,4,5,<android.webkit.FrameLoader: boolean executeLoad()>,<android.webkit.FrameLoader: boolean executeLoad()>,0,"{
    String url = mListener.url();
    // Attempt to decode the percent-encoded url.
    try {
        url = new String(URLUtil.decode(url.getBytes()));
    } catch (IllegalArgumentException e) {
        // Fail with a bad url error if the decode fails.
        mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
        return false;
    }
    if (URLUtil.isNetworkUrl(url)) {
        if (mSettings.getBlockNetworkLoads()) {
            mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
            return false;
        }
        mNetwork = Network.getInstance(mListener.getContext());
        return handleHTTPLoad();
    } else if (handleLocalFile(url, mListener, mSettings)) {
        return true;
    }
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""FrameLoader.executeLoad: url protocol not supported:"" + mListener.url());
    }
    mListener.error(EventHandler.ERROR_UNSUPPORTED_SCHEME, mListener.getContext().getText(com.android.internal.R.string.httpErrorUnsupportedScheme).toString());
    return false;
}","{
    String url = mListener.url();
    if (URLUtil.isNetworkUrl(url)) {
        if (mSettings.getBlockNetworkLoads()) {
            mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
            return false;
        }
        // Make sure it is correctly URL encoded before sending the request
        if (!URLUtil.verifyURLEncoding(url)) {
            mListener.error(EventHandler.ERROR_BAD_URL, mListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
            return false;
        }
        mNetwork = Network.getInstance(mListener.getContext());
        return handleHTTPLoad();
    } else if (handleLocalFile(url, mListener, mSettings)) {
        return true;
    }
    if (DebugFlags.FRAME_LOADER) {
        Log.v(LOGTAG, ""FrameLoader.executeLoad: url protocol not supported:"" + mListener.url());
    }
    mListener.error(EventHandler.ERROR_UNSUPPORTED_SCHEME, mListener.getContext().getText(com.android.internal.R.string.httpErrorUnsupportedScheme).toString());
    return false;
}",1,"/**
 * Issues the load request.
 *
 * Return value does not indicate if the load was successful or not. It
 * simply indicates that the load request is reasonable.
 *
 * @return true if the load is reasonable.
 */
","/**
 * Issues the load request.
 *
 * Return value does not indicate if the load was successful or not. It
 * simply indicates that the load request is reasonable.
 *
 * @return true if the load is reasonable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The initial part of the method where the url used to be decoded has been removed, and an additional if statement has been introduced to verify the URL Encoding of the url. Also, the log condition has been changed from WebView.LOGV_ENABLED to DebugFlags.FRAME_LOADER. Therefore, the change types are 1,3,4.","The removed decoding segment had an exception handling (IllegalArgumentException) which might be triggered due to unsuccessful decoding of the URL. In the late version, this exception handling has been removed. Thus, the method might behave differently in situations where URL decoding fails, leading to both different return values and exception handlings. This results in both types of compatibility issues, so the CI types are 1,2."
63,<android.view.ViewStub: View inflate()>,4,5,<android.view.ViewStub: View inflate()>,<android.view.ViewStub: View inflate()>,0,"{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory = LayoutInflater.from(mContext);
            final View view = factory.inflate(mLayoutResource, parent, false);
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
            }
            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}","{
    final ViewParent viewParent = getParent();
    if (viewParent != null && viewParent instanceof ViewGroup) {
        if (mLayoutResource != 0) {
            final ViewGroup parent = (ViewGroup) viewParent;
            final LayoutInflater factory = LayoutInflater.from(mContext);
            final View view = factory.inflate(mLayoutResource, parent, false);
            if (mInflatedId != NO_ID) {
                view.setId(mInflatedId);
            }
            final int index = parent.indexOfChild(this);
            parent.removeViewInLayout(this);
            final ViewGroup.LayoutParams layoutParams = getLayoutParams();
            if (layoutParams != null) {
                parent.addView(view, index, layoutParams);
            } else {
                parent.addView(view, index);
            }
            mInflatedViewRef = new WeakReference(view);
            if (mInflateListener != null) {
                mInflateListener.onInflate(this, view);
            }
            return view;
        } else {
            throw new IllegalArgumentException(""ViewStub must have a valid layoutResource"");
        }
    } else {
        throw new IllegalStateException(""ViewStub must have a non-null ViewGroup viewParent"");
    }
}",1,"/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
","/**
 * Inflates the layout resource identified by {@link #getLayoutResource()}
 * and replaces this StubbedView in its parent by the inflated layout resource.
 *
 * @return The inflated layout resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The early version and the late version of this API implementation are almost identical, except there is an extra statement in the late version. This extra statement (mInflatedViewRef = new WeakReference(view);) is adding a new weak reference for the view. Hence, the code change type is 4.","This extra statement does not change anything related to return value or exceptions handling in the late version, so there is no Compatibility Issue. Therefore, the CI_type is 0."
64,"<android.widget.AbsListView: void trackMotionScroll(int,int)>",4,5,"<android.widget.AbsListView: void trackMotionScroll(int,int)>","<android.widget.AbsListView: void trackMotionScroll(int,int)>",0,"{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = listPadding.top - firstTop;
    final int end = getHeight() - listPadding.bottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove >= absIncrementalDeltaY && spaceBelow >= absIncrementalDeltaY) {
        hideSelector();
        offsetChildrenTopAndBottom(incrementalDeltaY);
        invalidate();
        mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    } else {
        final int firstPosition = mFirstPosition;
        if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
            // Don't need to move views down if the top of the first position is already visible
            return;
        }
        if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
            // Don't need to move views up if the bottom of the last position is already visible
            return;
        }
        final boolean down = incrementalDeltaY < 0;
        hideSelector();
        final int headerViewsCount = getHeaderViewsCount();
        final int footerViewsStart = mItemCount - getFooterViewsCount();
        int start = 0;
        int count = 0;
        if (down) {
            final int top = listPadding.top - incrementalDeltaY;
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                if (child.getBottom() >= top) {
                    break;
                } else {
                    count++;
                    int position = firstPosition + i;
                    if (position >= headerViewsCount && position < footerViewsStart) {
                        mRecycler.addScrapView(child);
                        if (ViewDebug.TRACE_RECYCLER) {
                            ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                        }
                    }
                }
            }
        } else {
            final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;
            for (int i = childCount - 1; i >= 0; i--) {
                final View child = getChildAt(i);
                if (child.getTop() <= bottom) {
                    break;
                } else {
                    start = i;
                    count++;
                    int position = firstPosition + i;
                    if (position >= headerViewsCount && position < footerViewsStart) {
                        mRecycler.addScrapView(child);
                        if (ViewDebug.TRACE_RECYCLER) {
                            ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                        }
                    }
                }
            }
        }
        mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
        mBlockLayoutRequests = true;
        detachViewsFromParent(start, count);
        offsetChildrenTopAndBottom(incrementalDeltaY);
        if (down) {
            mFirstPosition += count;
        }
        invalidate();
        fillGap(down);
        mBlockLayoutRequests = false;
        invokeOnItemScrollListener();
    }
}","{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = listPadding.top - firstTop;
    final int end = getHeight() - listPadding.bottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove >= absIncrementalDeltaY && spaceBelow >= absIncrementalDeltaY) {
        hideSelector();
        offsetChildrenTopAndBottom(incrementalDeltaY);
        if (!awakenScrollBars()) {
            invalidate();
        }
        mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    } else {
        final int firstPosition = mFirstPosition;
        if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
            // Don't need to move views down if the top of the first position is already visible
            return;
        }
        if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
            // Don't need to move views up if the bottom of the last position is already visible
            return;
        }
        final boolean down = incrementalDeltaY < 0;
        hideSelector();
        final int headerViewsCount = getHeaderViewsCount();
        final int footerViewsStart = mItemCount - getFooterViewsCount();
        int start = 0;
        int count = 0;
        if (down) {
            final int top = listPadding.top - incrementalDeltaY;
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                if (child.getBottom() >= top) {
                    break;
                } else {
                    count++;
                    int position = firstPosition + i;
                    if (position >= headerViewsCount && position < footerViewsStart) {
                        mRecycler.addScrapView(child);
                        if (ViewDebug.TRACE_RECYCLER) {
                            ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                        }
                    }
                }
            }
        } else {
            final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;
            for (int i = childCount - 1; i >= 0; i--) {
                final View child = getChildAt(i);
                if (child.getTop() <= bottom) {
                    break;
                } else {
                    start = i;
                    count++;
                    int position = firstPosition + i;
                    if (position >= headerViewsCount && position < footerViewsStart) {
                        mRecycler.addScrapView(child);
                        if (ViewDebug.TRACE_RECYCLER) {
                            ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                        }
                    }
                }
            }
        }
        mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
        mBlockLayoutRequests = true;
        detachViewsFromParent(start, count);
        offsetChildrenTopAndBottom(incrementalDeltaY);
        if (down) {
            mFirstPosition += count;
        }
        invalidate();
        fillGap(down);
        mBlockLayoutRequests = false;
        invokeOnItemScrollListener();
        awakenScrollBars();
    }
}",1,"/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 */
","/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the addition of 'awakenScrollBars();' and the replacement of '!awakenScrollBars()' for 'invalidate();', which don't affect the return value or the thrown exceptions.","There is no Compatibility Issue since there is no changes that could potentially lead to different behaviors, either in terms of returned values or thrown exceptions. The added 'awakenScrollBars();' method does not alter the behavior of the original method."
67,"<android.widget.Gallery: void layout(int,boolean)>",4,5,"<android.widget.Gallery: void layout(int,boolean)>","<android.widget.Gallery: void layout(int,boolean)>",0,"{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle an empty gallery by removing all views.
    if (mItemCount == 0) {
        resetList();
        return;
    }
    // Update to the new selected position.
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    // All views go in recycler while we are in layout
    recycleAllViews();
    // Clear out old views
    // removeAllViewsInLayout();
    detachAllViewsFromParent();
    /*
         * These will be used to give initial positions to views entering the
         * gallery as we scroll
         */
    mRightMost = 0;
    mLeftMost = 0;
    // Make selected view and center it
    /*
         * mFirstPosition will be decreased as we add views to the left later
         * on. The 0 for x will be offset in a couple lines down.
         */
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition, 0, 0, true);
    // Put the selected child in the center
    Gallery.LayoutParams lp = (Gallery.LayoutParams) sel.getLayoutParams();
    int selectedOffset = childrenLeft + (childrenWidth / 2) - (sel.getWidth() / 2);
    sel.offsetLeftAndRight(selectedOffset);
    fillToGalleryRight();
    fillToGalleryLeft();
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
    updateSelectedItemMetadata();
}","{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle an empty gallery by removing all views.
    if (mItemCount == 0) {
        resetList();
        return;
    }
    // Update to the new selected position.
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    // All views go in recycler while we are in layout
    recycleAllViews();
    // Clear out old views
    // removeAllViewsInLayout();
    detachAllViewsFromParent();
    /*
         * These will be used to give initial positions to views entering the
         * gallery as we scroll
         */
    mRightMost = 0;
    mLeftMost = 0;
    // Make selected view and center it
    /*
         * mFirstPosition will be decreased as we add views to the left later
         * on. The 0 for x will be offset in a couple lines down.
         */
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition, 0, 0, true);
    // Put the selected child in the center
    int selectedOffset = childrenLeft + (childrenWidth / 2) - (sel.getWidth() / 2);
    sel.offsetLeftAndRight(selectedOffset);
    fillToGalleryRight();
    fillToGalleryLeft();
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
    updateSelectedItemMetadata();
}",1,"/**
 * Creates and positions all views for this Gallery.
 * <p>
 * We layout rarely, most of the time {@link #trackMotionScroll(int)} takes
 * care of repositioning, adding, and removing children.
 *
 * @param delta Change in the selected position. +1 means the selection is
 * moving to the right, so views are scrolling to the left. -1
 * means the selection is moving to the left.
 */
","/**
 * Creates and positions all views for this Gallery.
 * <p>
 * We layout rarely, most of the time {@link #trackMotionScroll(int)} takes
 * care of repositioning, adding, and removing children.
 *
 * @param delta Change in the selected position. +1 means the selection is
 * moving to the right, so views are scrolling to the left. -1
 * means the selection is moving to the left.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no code change in the implementation of the method from the early version to the late version.,"Since there is no change in the method implementation between the two versions, there is no Compatibility Issue."
68,<android.webkit.WebView: String findAddress(String)>,4,5,<android.webkit.WebView: String findAddress(String)>,<android.webkit.WebView: String findAddress(String)>,0,"{
    return WebViewCore.nativeFindAddress(addr);
}","{
    return findAddress(addr, false);
}",1,"/**
 * Return the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * - a house number
 * - a street name
 * - a street type (Road, Circle, etc), either spelled out or abbreviated
 * - a city name
 * - a state or territory, either spelled out or two-letter abbr.
 * - an optional 5 digit or 9 digit zip code.
 *
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 * @param addr The string to search for addresses.
 *
 * @return the address, or if no address is found, return null.
 */
","/**
 * Return the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * - a house number
 * - a street name
 * - a street type (Road, Circle, etc), either spelled out or abbreviated
 * - a city name
 * - a state or territory, either spelled out or two-letter abbr.
 * - an optional 5 digit or 9 digit zip code.
 *
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 * @param addr The string to search for addresses.
 *
 * @return the address, or if no address is found, return null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement and hence the method being invoked has changed from WebViewCore.nativeFindAddress(addr) to findAddress(addr, false). The format of the statement and the number of parameters in the invoked method are different, making this change type 1,5.","The invoked method has changed, which potentially leads to different return values from the API, so the Compatibility Issue (CI) type is 1."
70,<android.widget.TextView: boolean bringPointIntoView(int)>,4,5,<android.widget.TextView: boolean bringPointIntoView(int)>,<android.widget.TextView: boolean bringPointIntoView(int)>,0,"{
    boolean changed = false;
    int line = mLayout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) mLayout.getPrimaryHorizontal(offset);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(mLayout.getLineLeft(line));
    int right = (int) FloatMath.ceil(mLayout.getLineRight(line));
    int ht = mLayout.getHeight();
    int grav;
    switch(mLayout.getParagraphAlignment(line)) {
        case ALIGN_NORMAL:
            grav = 1;
            break;
        case ALIGN_OPPOSITE:
            grav = -1;
            break;
        default:
            grav = 0;
    }
    grav *= mLayout.getParagraphDirection(line);
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // This offsets because getInterestingRect() is in terms of
        // viewport coordinates, but requestRectangleOnScreen()
        // is in terms of content coordinates.
        Rect r = new Rect();
        getInterestingRect(r, x, top, bottom, line);
        r.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(r)) {
            changed = true;
        }
    }
    return changed;
}","{
    boolean changed = false;
    int line = mLayout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) mLayout.getPrimaryHorizontal(offset);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(mLayout.getLineLeft(line));
    int right = (int) FloatMath.ceil(mLayout.getLineRight(line));
    int ht = mLayout.getHeight();
    int grav;
    switch(mLayout.getParagraphAlignment(line)) {
        case ALIGN_NORMAL:
            grav = 1;
            break;
        case ALIGN_OPPOSITE:
            grav = -1;
            break;
        default:
            grav = 0;
    }
    grav *= mLayout.getParagraphDirection(line);
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // This offsets because getInterestingRect() is in terms of
        // viewport coordinates, but requestRectangleOnScreen()
        // is in terms of content coordinates.
        Rect r = new Rect();
        getInterestingRect(r, x, top, bottom, line);
        r.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(r)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The following line has been updated with an additional method call to awakenScrollBars(mScroller.getDuration()), hence the code change type is 4 (Other statement changed).","Since the addition of the method call to awakenScrollBars(mScroller.getDuration()) could potentially alter the state of the system, it could cause the API to behave differently, hence leading to compatibility issues of type 1 (which causes potential different return values)."
73,<android.webkit.WebView: void onDraw(Canvas)>,4,5,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    if (mWebViewCore.mEndScaleZoom) {
        mWebViewCore.mEndScaleZoom = false;
        if (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM) {
            setHorizontalScrollBarEnabled(true);
            setVerticalScrollBarEnabled(true);
            mTouchMode = TOUCH_DONE_MODE;
        }
    }
    int sc = canvas.save();
    if (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM) {
        scrollZoomDraw(canvas);
    } else {
        nativeRecomputeFocus();
        // Update the buttons in the picture, so when we draw the picture
        // to the screen, they are in the correct state.
        // Tell the native side if user is a) touching the screen,
        // b) pressing the trackball down, or c) pressing the enter key
        // If the focus is a button, we need to draw it in the pressed
        // state.
        // If mNativeClass is 0, we should not reach here, so we do not
        // need to check it again.
        nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTrackballDown || mGotEnterDown, false);
        drawCoreAndFocusRing(canvas, mBackgroundColor, mDrawFocusRing);
    }
    canvas.restoreToCount(sc);
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
}","{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    // Update the buttons in the picture, so when we draw the picture
    // to the screen, they are in the correct state.
    // Tell the native side if user is a) touching the screen,
    // b) pressing the trackball down, or c) pressing the enter key
    // If the cursor is on a button, we need to draw it in the pressed
    // state.
    // If mNativeClass is 0, we should not reach here, so we do not
    // need to check it again.
    nativeRecordButtons(hasFocus() && hasWindowFocus(), mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTrackballDown || mGotCenterDown, false);
    drawCoreAndCursorRing(canvas, mBackgroundColor, mDrawCursorRing);
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    if (mTitleBar != null) {
        int y = mScrollY + getVisibleTitleHeight();
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, y, mScrollX + getWidth(), y + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Several statements have been deleted and introduced in the late version. The condition checking part ""if (mWebViewCore.mEndScaleZoom) {...}"" has been removed and new pieces of code related to the mTitleBar are inserted. There are also changes regarding the called dependent APIs (nativeRecordButtons and drawCoreAndCursorRing). Therefore, the code change types are 1 and 4.","The return statement ""return;"" might potentially be called in different cases due to missing condition checking in the modified version, this could cause the late version API to potentially return a different value and thus there is a Compatibility Issue of type 1."
74,<android.view.MotionEvent: float getHistoricalY(int)>,4,5,<android.view.MotionEvent: float getHistoricalY(int)>,<android.view.MotionEvent: float getHistoricalY(int)>,0,"{
    return mHistory[pos * 4 + 1];
}","{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_Y];
}",1,"/**
 * Returns a historical Y coordinate that occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getY
 */
","/**
 * {@link #getHistoricalY(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 4",1,"The calculation method used in the return statement has changed drastically from mHistory[pos * 4 + 1] to mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_Y], indicating a return statement change. Moreover, the change also involves changes on non-control and non-exception handling statements, which is categorized as other statement change.","The changed return statement, which differs significantly in calculation logic, can potentially cause different values to be returned when the API is invoked between the two versions. Hence, there exists a compatibility issue due to the possibility of different return values."
76,"<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String[],String,String,String,String)>",4,5,"<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String[],String,String,String,String)>","<android.database.sqlite.SQLiteQueryBuilder: String buildQuery(String[],String,String[],String,String,String,String)>",0,"{
    String[] projection = computeProjection(projectionIn);
    if (mWhereClause.length() > 0) {
        mWhereClause.append(')');
    }
    // Tack on the user's selection, if present.
    if (selection != null && selection.length() > 0) {
        if (mWhereClause.length() > 0) {
            mWhereClause.append("" AND "");
        }
        mWhereClause.append('(');
        mWhereClause.append(selection);
        mWhereClause.append(')');
    }
    return buildQueryString(mDistinct, mTables, projection, mWhereClause.toString(), groupBy, having, sortOrder, limit);
}","{
    String[] projection = computeProjection(projectionIn);
    StringBuilder where = new StringBuilder();
    if (mWhereClause.length() > 0) {
        where.append(mWhereClause.toString());
        where.append(')');
    }
    // Tack on the user's selection, if present.
    if (selection != null && selection.length() > 0) {
        if (mWhereClause.length() > 0) {
            where.append("" AND "");
        }
        where.append('(');
        where.append(selection);
        where.append(')');
    }
    return buildQueryString(mDistinct, mTables, projection, where.toString(), groupBy, having, sortOrder, limit);
}",1,"/**
 * Construct a SELECT statement suitable for use in a group of
 * SELECT statements that will be joined through UNION operators
 * in buildUnionQuery.
 *
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to
 * prevent reading data from storage that isn't going to be
 * used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself).  Passing null will return all rows for the given
 * URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection.  The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY itself).
 * Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
","/**
 * Construct a SELECT statement suitable for use in a group of
 * SELECT statements that will be joined through UNION operators
 * in buildUnionQuery.
 *
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to
 * prevent reading data from storage that isn't going to be
 * used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself).  Passing null will return all rows for the given
 * URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection.  The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY itself).
 * Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is a change in how the 'where' string is built. In the early version, it is entirely built on 'mWhereClause', while in the late version, 'mWhereClause' is used as a part of the new 'where' StringBuilder, and the user's selection is also appended to 'where'. The change type is 4 since it is an other statement change.","Given that 'where' replaces 'mWhereClause' in the return statement, and 'where' is constructed differently in the two versions, it may lead to the API potentially returning a different value. Therefore, the CI type is 1."
78,"<android.provider.Contacts.Settings: String getSetting(ContentResolver,String,String)>",4,5,"<android.provider.Contacts.Settings: String getSetting(ContentResolver,String,String)>","<android.provider.Contacts.Settings: String getSetting(ContentResolver,String,String)>",0,"{
    // For now we only support a single account and the UI doesn't know what
    // the account name is, so we're using a global setting for SYNC_EVERYTHING.
    // Some day when we add multiple accounts to the UI this should honor the account
    // that was asked for.
    String selectString;
    String[] selectArgs;
    if (false) {
        selectString = (account == null) ? ""_sync_account is null AND key=?"" : ""_sync_account=? AND key=?"";
        selectArgs = (account == null) ? new String[] { key } : new String[] { account, key };
    } else {
        selectString = ""key=?"";
        selectArgs = new String[] { key };
    }
    Cursor cursor = cr.query(Settings.CONTENT_URI, new String[] { VALUE }, selectString, selectArgs, null);
    try {
        if (!cursor.moveToNext())
            return null;
        return cursor.getString(0);
    } finally {
        cursor.close();
    }
}","{
    // For now we only support a single account and the UI doesn't know what
    // the account name is, so we're using a global setting for SYNC_EVERYTHING.
    // Some day when we add multiple accounts to the UI this should honor the account
    // that was asked for.
    String selectString;
    String[] selectArgs;
    if (false) {
        selectString = (account == null) ? ""_sync_account is null AND key=?"" : ""_sync_account=? AND key=?"";
        // : ""_sync_account=? AND _sync_account_type=? AND key=?"";
        selectArgs = (account == null) ? new String[] { key } : new String[] { account, key };
    } else {
        selectString = ""key=?"";
        selectArgs = new String[] { key };
    }
    Cursor cursor = cr.query(Settings.CONTENT_URI, new String[] { VALUE }, selectString, selectArgs, null);
    try {
        if (!cursor.moveToNext())
            return null;
        return cursor.getString(0);
    } finally {
        cursor.close();
    }
}",1,,"/**
 * @deprecated see {@link android.provider.ContactsContract}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,0,0,There are no changes in the method implementation between the two versions.,"The method implementation has not been changed between the two versions, so there is no Compatibility Issue."
79,"<com.google.android.net.GoogleHttpClient: HttpResponse execute(HttpUriRequest,HttpContext)>",4,5,"<com.google.android.net.GoogleHttpClient: HttpResponse execute(HttpUriRequest,HttpContext)>","<com.google.android.net.GoogleHttpClient: HttpResponse execute(HttpUriRequest,HttpContext)>",0,"{
    // Rewrite the supplied URL...
    URI uri = request.getURI();
    String original = uri.toString();
    UrlRules rules = UrlRules.getRules(mResolver);
    UrlRules.Rule rule = rules.matchRule(original);
    String rewritten = rule.apply(original);
    if (rewritten == null) {
        Log.w(TAG, ""Blocked by "" + rule.mName + "": "" + original);
        throw new BlockedRequestException(rule);
    } else if (rewritten == original) {
        // Pass through
        return executeWithoutRewriting(request, context);
    }
    try {
        uri = new URI(rewritten);
    } catch (URISyntaxException e) {
        throw new RuntimeException(""Bad URL from rule: "" + rule.mName, e);
    }
    // Wrap request so we can replace the URI.
    RequestWrapper wrapper = wrapRequest(request);
    wrapper.setURI(uri);
    request = wrapper;
    if (Config.LOGV) {
        Log.v(TAG, ""Rule "" + rule.mName + "": "" + original + "" -> "" + rewritten);
    }
    return executeWithoutRewriting(request, context);
}","{
    // Rewrite the supplied URL...
    URI uri = request.getURI();
    String original = uri.toString();
    UrlRules rules = UrlRules.getRules(mResolver);
    UrlRules.Rule rule = rules.matchRule(original);
    String rewritten = rule.apply(original);
    if (rewritten == null) {
        Log.w(TAG, ""Blocked by "" + rule.mName + "": "" + original);
        throw new BlockedRequestException(rule);
    } else if (rewritten == original) {
        // Pass through
        return executeWithoutRewriting(request, context);
    }
    try {
        uri = new URI(rewritten);
    } catch (URISyntaxException e) {
        throw new RuntimeException(""Bad URL from rule: "" + rule.mName, e);
    }
    // Wrap request so we can replace the URI.
    RequestWrapper wrapper = wrapRequest(request);
    wrapper.setURI(uri);
    request = wrapper;
    if (LOCAL_LOGV)
        Log.v(TAG, ""Rule "" + rule.mName + "": "" + original + "" -> "" + rewritten);
    return executeWithoutRewriting(request, context);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in the internal constant used for the boolean check before the Log statement. This change from ""Config.LOGV"" to ""LOCAL_LOGV"" is simply a renaming of internal constant, causing the code to behave the same way as before. Hence, the code change type is 4.","No compatibility issues, as the change is only the renaming in constant used for boolean check, and it doesn't affect the method's return type, return value, or exceptions. Thus, the CI type is 0."
81,"<android.view.MotionEvent: void offsetLocation(float,float)>",4,5,"<android.view.MotionEvent: void offsetLocation(float,float)>","<android.view.MotionEvent: void offsetLocation(float,float)>",0,"{
    mX += deltaX;
    mY += deltaY;
    final int N = mNumHistory * 4;
    if (N <= 0) {
        return;
    }
    final float[] pos = mHistory;
    for (int i = 0; i < N; i += 4) {
        pos[i] += deltaX;
        pos[i + 1] += deltaY;
    }
}","{
    final int N = mNumPointers * mNumSamples * 4;
    final float[] pos = mDataSamples;
    for (int i = 0; i < N; i += NUM_SAMPLE_DATA) {
        pos[i + SAMPLE_X] += deltaX;
        pos[i + SAMPLE_Y] += deltaY;
    }
}",1,"/**
 * Adjust this event's location.
 * @param deltaX Amount to add to the current X coordinate of the event.
 * @param deltaY Amount to add to the current Y coordinate of the event.
 */
","/**
 * Adjust this event's location.
 * @param deltaX Amount to add to the current X coordinate of the event.
 * @param deltaY Amount to add to the current Y coordinate of the event.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The changes can be seen in the initialization of int N and float[] pos variables, also there have been changes in how these two are used inside the for loop. So, the code change thus falls into the category 1 and 4. ","As the variables mX, mY, mNumHistory have been removed and new variables mNumPoints, mNumSamples, and mDataSamples have been added, this could potentially lead to different return values despite the method is void. Therefore, CI type is 1."
82,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,4,5,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,<android.app.Activity: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    onUserInteraction();
    if (getWindow().superDispatchKeyEvent(event)) {
        return true;
    }
    return event.dispatch(this);
}","{
    onUserInteraction();
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}",1,"/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
","/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version implementation, a new variable 'win' is introduced, and it replaces 'getWindow()'. Moreover, the final return statement includes a new process which is 'decor != null ? decor.getKeyDispatcherState() : null'. Therefore, the types of changes include a differernt return statement type (1), control statement change (3), and other statement change (4).","Due to the changes in return statements and control dependencies, these variations may cause the API to return different values, thus resulting in a compatibility issue of type 1."
83,"<android.widget.ScrollView: void onSizeChanged(int,int,int,int)>",4,5,"<android.widget.ScrollView: void onSizeChanged(int,int,int,int)>","<android.widget.ScrollView: void onSizeChanged(int,int,int,int)>",0,"{
    super.onSizeChanged(w, h, oldw, oldh);
    View currentFocused = findFocus();
    if (null == currentFocused || this == currentFocused)
        return;
    final int maxJump = mBottom - mTop;
    if (isWithinDeltaOfScreen(currentFocused, maxJump)) {
        currentFocused.getDrawingRect(mTempRect);
        offsetDescendantRectToMyCoords(currentFocused, mTempRect);
        int scrollDelta = computeScrollDeltaToGetChildRectOnScreen(mTempRect);
        doScrollY(scrollDelta);
    }
}","{
    super.onSizeChanged(w, h, oldw, oldh);
    View currentFocused = findFocus();
    if (null == currentFocused || this == currentFocused)
        return;
    // view visible with the new screen height.
    if (isWithinDeltaOfScreen(currentFocused, 0, oldh)) {
        currentFocused.getDrawingRect(mTempRect);
        offsetDescendantRectToMyCoords(currentFocused, mTempRect);
        int scrollDelta = computeScrollDeltaToGetChildRectOnScreen(mTempRect);
        doScrollY(scrollDelta);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The argument of 'isWithinDeltaOfScreen' has changed from (currentFocused, maxJump) to (currentFocused, 0, oldh), so the code change type is 3,5.","The change in the arguments of 'isWithinDeltaOfScreen' could potentially lead to different results when calling this method, and thus may lead to different behaviors of the 'doScrollY(scrollDelta)' statement and cause different returned value. Therefore, the CI type is 1."
85,<android.webkit.CallbackProxy: void onPageFinished(String)>,4,5,<android.webkit.CallbackProxy: void onPageFinished(String)>,<android.webkit.CallbackProxy: void onPageFinished(String)>,0,"{
    // been set.
    if (mWebViewClient == null) {
        return;
    }
    // Performance probe
    if (false) {
        Log.d(""WebCore"", ""WebCore thread used "" + (SystemClock.currentThreadTimeMillis() - mWebCoreThreadTime) + "" ms"");
        Network.getInstance(mContext).stopTiming();
    }
    Message msg = obtainMessage(PAGE_FINISHED, url);
    sendMessage(msg);
}","{
    // been set.
    if (mWebViewClient == null) {
        return;
    }
    // Performance probe
    if (PERF_PROBE) {
        // un-comment this if PERF_PROBE is true
        // Looper.myQueue().setWaitCallback(null);
        Log.d(""WebCore"", ""WebCore thread used "" + (SystemClock.currentThreadTimeMillis() - mWebCoreThreadTime) + "" ms and idled "" + mWebCoreIdleTime + "" ms"");
        Network.getInstance(mContext).stopTiming();
    }
    Message msg = obtainMessage(PAGE_FINISHED, url);
    sendMessage(msg);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change happens within the 'if' condition section where it checks if performance probe is turned on. The condition itself is also slightly changed from 'false' to 'PERF_PROBE'. Furthermore, a new logging statement is added inside the 'if' condition, making changes in the behavior under certain condition. Therefore, the types of change are Control dependency change (3) and Other statement change (4).","However, these changes won't affect the returned values of the API, and no additional exceptions are introduced. Thus, no Compatibility Issues exist, so the CI type is 0."
86,<android.view.MotionEvent: long getEventTime()>,4,5,<android.view.MotionEvent: long getEventTime()>,<android.view.MotionEvent: long getEventTime()>,0,"{
    return mEventTime;
}","{
    return mTimeSamples[0];
}",1,"/**
 * Returns the time (in ms) when this specific event was generated.
 */
","/**
 * Returns the time (in ms) when this specific event was generated.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning 'mEventTime' to 'mTimeSamples[0]', so the change type is 1.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
87,<android.content.Intent: Intent getIntentOld(String)>,4,5,<android.content.Intent: Intent getIntentOld(String)>,<android.content.Intent: Intent getIntentOld(String)>,0,"{
    Intent intent;
    int i = uri.lastIndexOf('#');
    if (i >= 0) {
        Uri data = null;
        String action = null;
        if (i > 0) {
            data = Uri.parse(uri.substring(0, i));
        }
        i++;
        if (uri.regionMatches(i, ""action("", 0, 7)) {
            i += 7;
            int j = uri.indexOf(')', i);
            action = uri.substring(i, j);
            i = j + 1;
        }
        intent = new Intent(action, data);
        if (uri.regionMatches(i, ""categories("", 0, 11)) {
            i += 11;
            int j = uri.indexOf(')', i);
            while (i < j) {
                int sep = uri.indexOf('!', i);
                if (sep < 0)
                    sep = j;
                if (i < sep) {
                    intent.addCategory(uri.substring(i, sep));
                }
                i = sep + 1;
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""type("", 0, 5)) {
            i += 5;
            int j = uri.indexOf(')', i);
            intent.mType = uri.substring(i, j);
            i = j + 1;
        }
        if (uri.regionMatches(i, ""launchFlags("", 0, 12)) {
            i += 12;
            int j = uri.indexOf(')', i);
            intent.mFlags = Integer.decode(uri.substring(i, j)).intValue();
            i = j + 1;
        }
        if (uri.regionMatches(i, ""component("", 0, 10)) {
            i += 10;
            int j = uri.indexOf(')', i);
            int sep = uri.indexOf('!', i);
            if (sep >= 0 && sep < j) {
                String pkg = uri.substring(i, sep);
                String cls = uri.substring(sep + 1, j);
                intent.mComponent = new ComponentName(pkg, cls);
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""extras("", 0, 7)) {
            i += 7;
            final int closeParen = uri.indexOf(')', i);
            if (closeParen == -1)
                throw new URISyntaxException(uri, ""EXTRA missing trailing ')'"", i);
            while (i < closeParen) {
                // fetch the key value
                int j = uri.indexOf('=', i);
                if (j <= i + 1 || i >= closeParen) {
                    throw new URISyntaxException(uri, ""EXTRA missing '='"", i);
                }
                char type = uri.charAt(i);
                i++;
                String key = uri.substring(i, j);
                i = j + 1;
                // get type-value
                j = uri.indexOf('!', i);
                if (j == -1 || j >= closeParen)
                    j = closeParen;
                if (i >= j)
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                String value = uri.substring(i, j);
                i = j;
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                // add item to bundle
                try {
                    switch(type) {
                        case 'S':
                            intent.mExtras.putString(key, Uri.decode(value));
                            break;
                        case 'B':
                            intent.mExtras.putBoolean(key, Boolean.parseBoolean(value));
                            break;
                        case 'b':
                            intent.mExtras.putByte(key, Byte.parseByte(value));
                            break;
                        case 'c':
                            intent.mExtras.putChar(key, Uri.decode(value).charAt(0));
                            break;
                        case 'd':
                            intent.mExtras.putDouble(key, Double.parseDouble(value));
                            break;
                        case 'f':
                            intent.mExtras.putFloat(key, Float.parseFloat(value));
                            break;
                        case 'i':
                            intent.mExtras.putInt(key, Integer.parseInt(value));
                            break;
                        case 'l':
                            intent.mExtras.putLong(key, Long.parseLong(value));
                            break;
                        case 's':
                            intent.mExtras.putShort(key, Short.parseShort(value));
                            break;
                        default:
                            throw new URISyntaxException(uri, ""EXTRA has unknown type"", i);
                    }
                } catch (NumberFormatException e) {
                    throw new URISyntaxException(uri, ""EXTRA value can't be parsed"", i);
                }
                char ch = uri.charAt(i);
                if (ch == ')')
                    break;
                if (ch != '!')
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                i++;
            }
        }
        if (intent.mAction == null) {
            // By default, if no action is specified, then use VIEW.
            intent.mAction = ACTION_VIEW;
        }
    } else {
        intent = new Intent(ACTION_VIEW, Uri.parse(uri));
    }
    return intent;
}","{
    Intent intent;
    int i = uri.lastIndexOf('#');
    if (i >= 0) {
        String action = null;
        final int intentFragmentStart = i;
        boolean isIntentFragment = false;
        i++;
        if (uri.regionMatches(i, ""action("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            int j = uri.indexOf(')', i);
            action = uri.substring(i, j);
            i = j + 1;
        }
        intent = new Intent(action);
        if (uri.regionMatches(i, ""categories("", 0, 11)) {
            isIntentFragment = true;
            i += 11;
            int j = uri.indexOf(')', i);
            while (i < j) {
                int sep = uri.indexOf('!', i);
                if (sep < 0)
                    sep = j;
                if (i < sep) {
                    intent.addCategory(uri.substring(i, sep));
                }
                i = sep + 1;
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""type("", 0, 5)) {
            isIntentFragment = true;
            i += 5;
            int j = uri.indexOf(')', i);
            intent.mType = uri.substring(i, j);
            i = j + 1;
        }
        if (uri.regionMatches(i, ""launchFlags("", 0, 12)) {
            isIntentFragment = true;
            i += 12;
            int j = uri.indexOf(')', i);
            intent.mFlags = Integer.decode(uri.substring(i, j)).intValue();
            i = j + 1;
        }
        if (uri.regionMatches(i, ""component("", 0, 10)) {
            isIntentFragment = true;
            i += 10;
            int j = uri.indexOf(')', i);
            int sep = uri.indexOf('!', i);
            if (sep >= 0 && sep < j) {
                String pkg = uri.substring(i, sep);
                String cls = uri.substring(sep + 1, j);
                intent.mComponent = new ComponentName(pkg, cls);
            }
            i = j + 1;
        }
        if (uri.regionMatches(i, ""extras("", 0, 7)) {
            isIntentFragment = true;
            i += 7;
            final int closeParen = uri.indexOf(')', i);
            if (closeParen == -1)
                throw new URISyntaxException(uri, ""EXTRA missing trailing ')'"", i);
            while (i < closeParen) {
                // fetch the key value
                int j = uri.indexOf('=', i);
                if (j <= i + 1 || i >= closeParen) {
                    throw new URISyntaxException(uri, ""EXTRA missing '='"", i);
                }
                char type = uri.charAt(i);
                i++;
                String key = uri.substring(i, j);
                i = j + 1;
                // get type-value
                j = uri.indexOf('!', i);
                if (j == -1 || j >= closeParen)
                    j = closeParen;
                if (i >= j)
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                String value = uri.substring(i, j);
                i = j;
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                // add item to bundle
                try {
                    switch(type) {
                        case 'S':
                            intent.mExtras.putString(key, Uri.decode(value));
                            break;
                        case 'B':
                            intent.mExtras.putBoolean(key, Boolean.parseBoolean(value));
                            break;
                        case 'b':
                            intent.mExtras.putByte(key, Byte.parseByte(value));
                            break;
                        case 'c':
                            intent.mExtras.putChar(key, Uri.decode(value).charAt(0));
                            break;
                        case 'd':
                            intent.mExtras.putDouble(key, Double.parseDouble(value));
                            break;
                        case 'f':
                            intent.mExtras.putFloat(key, Float.parseFloat(value));
                            break;
                        case 'i':
                            intent.mExtras.putInt(key, Integer.parseInt(value));
                            break;
                        case 'l':
                            intent.mExtras.putLong(key, Long.parseLong(value));
                            break;
                        case 's':
                            intent.mExtras.putShort(key, Short.parseShort(value));
                            break;
                        default:
                            throw new URISyntaxException(uri, ""EXTRA has unknown type"", i);
                    }
                } catch (NumberFormatException e) {
                    throw new URISyntaxException(uri, ""EXTRA value can't be parsed"", i);
                }
                char ch = uri.charAt(i);
                if (ch == ')')
                    break;
                if (ch != '!')
                    throw new URISyntaxException(uri, ""EXTRA missing '!'"", i);
                i++;
            }
        }
        if (isIntentFragment) {
            intent.mData = Uri.parse(uri.substring(0, intentFragmentStart));
        } else {
            intent.mData = Uri.parse(uri);
        }
        if (intent.mAction == null) {
            // By default, if no action is specified, then use VIEW.
            intent.mAction = ACTION_VIEW;
        }
    } else {
        intent = new Intent(ACTION_VIEW, Uri.parse(uri));
    }
    return intent;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A number of changes have occurred, including changes within the 'if' statements where URI parsing is replaced by direct string assignment (isIntentFragment = true). This represents changes in control dependency (type 3). Return statements (type 1) are affected by these changes as the content and condition to initialise 'intent' have altered.","The changes may lead to different return values in the late version due to different initialization of 'intent'. Therefore, the Compatibility Issue is 1."
90,<android.view.MotionEvent: float getY()>,4,5,<android.view.MotionEvent: float getY()>,<android.view.MotionEvent: float getY()>,0,"{
    return mY;
}","{
    return mDataSamples[SAMPLE_Y];
}",1,"/**
 * Returns the Y coordinate of this event.  Whole numbers are pixels; the
 * value may have a fraction for input devices that are sub-pixel precise.
 */
","/**
 * {@link #getY(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning 'mY' to returning 'mDataSamples[SAMPLE_Y]', so the code change type is 1.","The changed return statement will lead the API to potentially return a different value, so the CI type is 1."
91,<android.app.NotificationManager: void cancel(int)>,4,5,<android.app.NotificationManager: void cancel(int)>,<android.app.NotificationManager: void cancel(int)>,0,"{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancel("" + id + "")"");
    try {
        service.cancelNotification(pkg, id);
    } catch (RemoteException e) {
    }
}","{
    cancel(null, id);
}",1,"/**
 * Cancel a previously shown notification.  If it's transient, the view
 * will be hidden.  If it's persistent, it will be removed from the status
 * bar.
 */
","/**
 * Cancel a previously shown notification.  If it's transient, the view
 * will be hidden.  If it's persistent, it will be removed from the status
 * bar.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method call service.cancelNotification(pkg, id) is replaced by the method cancel(null, id). Hence, the code change type is 1,5.","The replacement of method call does not alter the behaviour of the API. The 'cancel' method still performs the same operation and gives the same outcome as the 'service.cancelNotification(pkg, id)'. Therefore, there is no Compatibility Issue (CI). CI type is 0."
92,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,4,5,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            setPressed(true);
            onStartTrackingTouch();
            trackTouchEvent(event);
            break;
        case MotionEvent.ACTION_MOVE:
            trackTouchEvent(event);
            attemptClaimDrag();
            break;
        case MotionEvent.ACTION_UP:
            trackTouchEvent(event);
            onStopTrackingTouch();
            setPressed(false);
            break;
        case MotionEvent.ACTION_CANCEL:
            onStopTrackingTouch();
            setPressed(false);
            break;
    }
    return true;
}","{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            setPressed(true);
            onStartTrackingTouch();
            trackTouchEvent(event);
            break;
        case MotionEvent.ACTION_MOVE:
            trackTouchEvent(event);
            attemptClaimDrag();
            break;
        case MotionEvent.ACTION_UP:
            trackTouchEvent(event);
            onStopTrackingTouch();
            setPressed(false);
            // ProgressBar doesn't know to repaint the thumb drawable
            // in its inactive state when the touch stops (because the
            // value has not apparently changed)
            invalidate();
            break;
        case MotionEvent.ACTION_CANCEL:
            onStopTrackingTouch();
            setPressed(false);
            // see above explanation
            invalidate();
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,A new statement 'invalidate();' is added in the 'case MotionEvent.ACTION_UP' and 'case MotionEvent.ACTION_CANCEL'. So the code change type is 4.,"Although new statement 'invalidate();' is added, it will not affect the method's return value or exception handling, therefore, there is no compatibility issue. CI is 0."
96,"<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>",4,5,"<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>","<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            if (isPressed() && mSelectedPosition >= 0 && mAdapter != null && mSelectedPosition < mAdapter.getCount()) {
                final View view = getChildAt(mSelectedPosition - mFirstPosition);
                performItemClick(view, mSelectedPosition, mSelectedRowId);
                setPressed(false);
                if (view != null)
                    view.setPressed(false);
                return true;
            }
    }
    return super.onKeyUp(keyCode, event);
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            if (!isEnabled()) {
                return true;
            }
            if (isClickable() && isPressed() && mSelectedPosition >= 0 && mAdapter != null && mSelectedPosition < mAdapter.getCount()) {
                final View view = getChildAt(mSelectedPosition - mFirstPosition);
                performItemClick(view, mSelectedPosition, mSelectedRowId);
                setPressed(false);
                if (view != null)
                    view.setPressed(false);
                return true;
            }
            break;
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","The 'if' condition statement has been expanded to include an additional function call check ""isEnabled()"" and ""isClickable(), and a new 'break' statement is introduced, Thus, the code change type is 3 (Control Dependency) and 4 (Other Statement).","The additional condition checks ""isEnabled()"" and ""isClickable()"" could potentially lead to different 'return' values in the 'if' statement block of the case conditions 'KeyEvent.KEYCODE_DPAD_CENTER' and 'KeyEvent.KEYCODE_ENTER'. Also, an introduced 'break' could potentially escape the switch construct and call 'super.onKeyUp(keyCode, event)', which could lead to different exception behaviours. Thus, the CI type is 1 and 2 ."
97,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,4,5,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,0,"{
    if (outState == null) {
        return null;
    }
    // We grab a copy of the back/forward list because a client of WebView
    // may have invalidated the history list by calling clearHistory.
    WebBackForwardList list = copyBackForwardList();
    final int currentIndex = list.getCurrentIndex();
    final int size = list.getSize();
    // not in a valid range.
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
        return null;
    }
    outState.putInt(""index"", currentIndex);
    // FIXME: This should just be a byte[][] instead of ArrayList but
    // Parcel.java does not have the code to handle multi-dimensional
    // arrays.
    ArrayList<byte[]> history = new ArrayList<byte[]>(size);
    for (int i = 0; i < size; i++) {
        WebHistoryItem item = list.getItemAtIndex(i);
        byte[] data = item.getFlattenedData();
        if (data == null) {
            // flattened data.
            return null;
        }
        history.add(data);
    }
    outState.putSerializable(""history"", history);
    if (mCertificate != null) {
        outState.putBundle(""certificate"", SslCertificate.saveState(mCertificate));
    }
    return list;
}","{
    if (outState == null) {
        return null;
    }
    // We grab a copy of the back/forward list because a client of WebView
    // may have invalidated the history list by calling clearHistory.
    WebBackForwardList list = copyBackForwardList();
    final int currentIndex = list.getCurrentIndex();
    final int size = list.getSize();
    // not in a valid range.
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
        return null;
    }
    outState.putInt(""index"", currentIndex);
    // FIXME: This should just be a byte[][] instead of ArrayList but
    // Parcel.java does not have the code to handle multi-dimensional
    // arrays.
    ArrayList<byte[]> history = new ArrayList<byte[]>(size);
    for (int i = 0; i < size; i++) {
        WebHistoryItem item = list.getItemAtIndex(i);
        if (null == item) {
            // FIXME: this shouldn't happen
            // need to determine how item got set to null
            Log.w(LOGTAG, ""saveState: Unexpected null history item."");
            return null;
        }
        byte[] data = item.getFlattenedData();
        if (data == null) {
            // flattened data.
            return null;
        }
        history.add(data);
    }
    outState.putSerializable(""history"", history);
    if (mCertificate != null) {
        outState.putBundle(""certificate"", SslCertificate.saveState(mCertificate));
    }
    return list;
}",1,"/**
 * Save the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called. See {@link #savePicture} and {@link #restorePicture} for saving
 * and restoring the display data.
 * @param outState The Bundle to store the WebView state.
 * @return The same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 * @see #savePicture
 * @see #restorePicture
 */
","/**
 * Save the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called. See {@link #savePicture} and {@link #restorePicture} for saving
 * and restoring the display data.
 * @param outState The Bundle to store the WebView state.
 * @return The same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 * @see #savePicture
 * @see #restorePicture
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the loop, there's a newly added check for 'null == item' and a new return statement 'return null'. So change type is 1 and 3.","The new null check and return statement could potentially allow the function to return different values under certain circumstances, thus compatibility issue could be raised. Hence, CI type is 1."
99,<android.webkit.WebView: boolean performLongClick()>,4,5,<android.webkit.WebView: boolean performLongClick()>,<android.webkit.WebView: boolean performLongClick()>,0,"{
    if (inEditingMode()) {
        return mTextEntry.performLongClick();
    } else {
        return super.performLongClick();
    }
}","{
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        // FIXME: When we start respecting changes to the native textfield's
        // selection, need to make sure that this does not change it.
        mWebViewCore.sendMessage(EventHub.CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        rebuildWebTextView();
    }
    if (inEditingMode()) {
        return mWebTextView.performLongClick();
    } else {
        return super.performLongClick();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code has changed with additional 'if' condition added, the return statement changed from mTextEntry.performLongClick() to mWebTextView.performLongClick(), and several new operations/statement related to 'mWebViewCore', 'EventHub' and 'rebuildWebTextView' introduced. Thus, the code change type is 1,3,4.","The return statement change indicates possible different results when invoking performLongClick(), thus causing a compatibility issue. Thus, the CI type is 1."
100,<android.pim.ContactsAsyncHelper.WorkerHandler: void handleMessage(Message)>,4,5,<android.pim.ContactsAsyncHelper.WorkerHandler: void handleMessage(Message)>,<android.pim.ContactsAsyncHelper.WorkerHandler: void handleMessage(Message)>,0,"{
    WorkerArgs args = (WorkerArgs) msg.obj;
    switch(msg.arg1) {
        case EVENT_LOAD_IMAGE:
            InputStream inputStream = Contacts.People.openContactPhotoInputStream(args.context.getContentResolver(), args.uri);
            if (inputStream != null) {
                args.result = Drawable.createFromStream(inputStream, args.uri.toString());
                if (DBG)
                    Log.d(LOG_TAG, ""Loading image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri);
            } else {
                args.result = null;
                if (DBG)
                    Log.d(LOG_TAG, ""Problem with image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri + "", using default image."");
            }
            break;
        default:
    }
    // send the reply to the enclosing class.
    Message reply = ContactsAsyncHelper.this.obtainMessage(msg.what);
    reply.arg1 = msg.arg1;
    reply.obj = msg.obj;
    reply.sendToTarget();
}","{
    WorkerArgs args = (WorkerArgs) msg.obj;
    switch(msg.arg1) {
        case EVENT_LOAD_IMAGE:
            InputStream inputStream = null;
            try {
                inputStream = Contacts.openContactPhotoInputStream(args.context.getContentResolver(), args.uri);
            } catch (Exception e) {
                Log.e(LOG_TAG, ""Error opening photo input stream"", e);
            }
            if (inputStream != null) {
                args.result = Drawable.createFromStream(inputStream, args.uri.toString());
                if (DBG)
                    Log.d(LOG_TAG, ""Loading image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri);
            } else {
                args.result = null;
                if (DBG)
                    Log.d(LOG_TAG, ""Problem with image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri + "", using default image."");
            }
            break;
        default:
    }
    // send the reply to the enclosing class.
    Message reply = ContactsAsyncHelper.this.obtainMessage(msg.what);
    reply.arg1 = msg.arg1;
    reply.obj = msg.obj;
    reply.sendToTarget();
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"2,5","1,2","There is a addition of exception handling statement in the late-version API. And the dependent APIs (Contacts.openContactPhotoInputStream()) have also been changed to Contacts.People.openContactPhotoInputStream(). So the code change type is 2,5.","The addition of the exception handling statement could potentially gives rise to different behaviors, and thus causing Compatibility Issue of type 2. Also, due to the dependent API changes, the value of 'inputStream' and subsequently the 'args.result' can be different, therefore causing Compatibility Issue of type 1."
101,<android.webkit.Network: boolean restoreState(Bundle)>,4,5,<android.webkit.Network: boolean restoreState(Bundle)>,<android.webkit.Network: boolean restoreState(Bundle)>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""Network.restoreState()"");
    }
    return mSslErrorHandler.restoreState(inState);
}","{
    if (DebugFlags.NETWORK) {
        Log.v(LOGTAG, ""Network.restoreState()"");
    }
    return mSslErrorHandler.restoreState(inState);
}",1,"/**
 * Restores the state of network handlers (user SSL and HTTP-authentication
 * preferences).
 * @param inState The in-state to load (read) from.
 * @return True iff succeeds.
 */
","/**
 * Restores the state of network handlers (user SSL and HTTP-authentication
 * preferences).
 * @param inState The in-state to load (read) from.
 * @return True iff succeeds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is within a Log statement where the condition for logging 'Network.restoreState()' has changed from 'WebView.LOGV_ENABLED' to 'DebugFlags.NETWORK'. Therefore, the code change type is 4.","This change in the logging condition but doesn't affect the potential return value or exception handling of the API. Therefore, no Compatibility Issue exists classified as type 0."
102,<android.app.ApplicationContext: Drawable getWallpaper()>,4,5,<android.app.ApplicationContext: Drawable getWallpaper()>,<android.app.ApplicationContext: Drawable getWallpaper()>,0,"{
    Drawable dr = peekWallpaper();
    return dr != null ? dr : getResources().getDrawable(com.android.internal.R.drawable.default_wallpaper);
}","{
    return getWallpaperManager().getDrawable();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from using a condition statement with peekWallpaper() and getResources().getDrawable(com.android.internal.R.drawable.default_wallpaper) to simply calling getWallpaperManager().getDrawable(). The dependent API has also changed from peekWallpaper() and getResources() to getWallpaperManager(), therefore the code change type is 1,5.","The returned value/type of the API may change due to the modification of the return statement and the dependent APIs, which makes it possibly return a different Drawable object, therefore the CI type is 1."
106,"<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>",4,5,"<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>","<android.webkit.WebView: boolean requestChildRectangleOnScreen(View,Rect,boolean)>",0,"{
    rect.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
    int height = getHeight() - getHorizontalScrollbarHeight();
    int screenTop = mScrollY;
    int screenBottom = screenTop + height;
    int scrollYDelta = 0;
    if (rect.bottom > screenBottom && rect.top > screenTop) {
        if (rect.height() > height) {
            scrollYDelta += (rect.top - screenTop);
        } else {
            scrollYDelta += (rect.bottom - screenBottom);
        }
    } else if (rect.top < screenTop) {
        scrollYDelta -= (screenTop - rect.top);
    }
    int width = getWidth() - getVerticalScrollbarWidth();
    int screenLeft = mScrollX;
    int screenRight = screenLeft + width;
    int scrollXDelta = 0;
    if (rect.right > screenRight && rect.left > screenLeft) {
        if (rect.width() > width) {
            scrollXDelta += (rect.left - screenLeft);
        } else {
            scrollXDelta += (rect.right - screenRight);
        }
    } else if (rect.left < screenLeft) {
        scrollXDelta -= (screenLeft - rect.left);
    }
    if ((scrollYDelta | scrollXDelta) != 0) {
        return pinScrollBy(scrollXDelta, scrollYDelta, !immediate, 0);
    }
    return false;
}","{
    rect.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
    int height = getViewHeightWithTitle();
    int screenTop = mScrollY;
    int screenBottom = screenTop + height;
    int scrollYDelta = 0;
    if (rect.bottom > screenBottom) {
        int oneThirdOfScreenHeight = height / 3;
        if (rect.height() > 2 * oneThirdOfScreenHeight) {
            // If the rectangle is too tall to fit in the bottom two thirds
            // of the screen, place it at the top.
            scrollYDelta = rect.top - screenTop;
        } else {
            // If the rectangle will still fit on screen, we want its
            // top to be in the top third of the screen.
            scrollYDelta = rect.top - (screenTop + oneThirdOfScreenHeight);
        }
    } else if (rect.top < screenTop) {
        scrollYDelta = rect.top - screenTop;
    }
    int width = getWidth() - getVerticalScrollbarWidth();
    int screenLeft = mScrollX;
    int screenRight = screenLeft + width;
    int scrollXDelta = 0;
    if (rect.right > screenRight && rect.left > screenLeft) {
        if (rect.width() > width) {
            scrollXDelta += (rect.left - screenLeft);
        } else {
            scrollXDelta += (rect.right - screenRight);
        }
    } else if (rect.left < screenLeft) {
        scrollXDelta -= (screenLeft - rect.left);
    }
    if ((scrollYDelta | scrollXDelta) != 0) {
        return pinScrollBy(scrollXDelta, scrollYDelta, !immediate, 0);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"A simple statement has been changed from 'int height = getHeight() - getHorizontalScrollbarHeight()' to 'int height = getViewHeightWithTitle()', and it involves in the dependent API 'getHeight()'. Therefore, the code change type is 4,5.","As the variable 'height' may have a different value under the changes from 'getHeight()' to 'getViewHeightWithTitle()' API, it will change the behaviors of the nested 'if' statements, and potentially lead to the values of 'scrollYDelta' and 'scrollXDelta' become different. Thus the returned boolean value of pinScrollBy(...) and of the API could be different, the CI type is 1."
107,<android.widget.GridView: boolean pageScroll(int)>,4,5,<android.widget.GridView: boolean pageScroll(int)>,<android.widget.GridView: boolean pageScroll(int)>,0,"{
    int nextPage = -1;
    if (direction == FOCUS_UP) {
        nextPage = Math.max(0, mSelectedPosition - getChildCount() - 1);
    } else if (direction == FOCUS_DOWN) {
        nextPage = Math.min(mItemCount - 1, mSelectedPosition + getChildCount() - 1);
    }
    if (nextPage >= 0) {
        setSelectionInt(nextPage);
        invokeOnItemScrollListener();
        return true;
    }
    return false;
}","{
    int nextPage = -1;
    if (direction == FOCUS_UP) {
        nextPage = Math.max(0, mSelectedPosition - getChildCount() - 1);
    } else if (direction == FOCUS_DOWN) {
        nextPage = Math.min(mItemCount - 1, mSelectedPosition + getChildCount() - 1);
    }
    if (nextPage >= 0) {
        setSelectionInt(nextPage);
        invokeOnItemScrollListener();
        awakenScrollBars();
        return true;
    }
    return false;
}",1,"/**
 * Scrolls up or down by the number of items currently present on screen.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 * @return whether selection was moved
 */
","/**
 * Scrolls up or down by the number of items currently present on screen.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 * @return whether selection was moved
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call 'awakenScrollBars()' has been added in the implementation without altering the flow/control dependency or return statements, so the code change type is 4.","The added method 'awakenScrollBars()' doesn't change the output or exception of the main function, there is no compatibility issue in this case, so the CI type is 0."
108,<android.app.ApplicationContext: void setWallpaper(Bitmap)>,4,5,<android.app.ApplicationContext: void setWallpaper(Bitmap)>,<android.app.ApplicationContext: void setWallpaper(Bitmap)>,0,"{
    try {
        ParcelFileDescriptor fd = getWallpaperService().setWallpaper();
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    }
}","{
    getWallpaperManager().setBitmap(bitmap);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the method has changed dramatically. A try-catch block is fully removed and also the usage of the dependent API change from 'getWallpaperService().setWallpaper()' to 'getWallpaperManager().setBitmap(bitmap)', hence the change type is 1,4,5.","Since the method implementation was changed completely which leads to use another dependent API, the return of method might be different depending on the new logic. Thus, the method has a compatibility issue type 1."
109,<android.view.View: void buildDrawingCache(boolean)>,4,5,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        if (Config.DEBUG && ViewDebug.profileDrawing) {
            EventLog.writeEvent(60002, hashCode());
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
        if (width <= 0 || height <= 0 || (// Projected bitmap size in bytes
        width * height * (opaque ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_4444;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                quality = Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = new SoftReference<Bitmap>(bitmap);
                } else {
                    mUnscaledDrawingCache = new SoftReference<Bitmap>(bitmap);
                }
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
        mPrivateFlags |= DRAWING_CACHE_VALID;
    }
}","{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        if (Config.DEBUG && ViewDebug.profileDrawing) {
            EventLog.writeEvent(60002, hashCode());
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean translucentWindow = attachInfo != null && attachInfo.mTranslucentWindow;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !translucentWindow ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_4444;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = translucentWindow ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = new SoftReference<Bitmap>(bitmap);
                } else {
                    mUnscaledDrawingCache = new SoftReference<Bitmap>(bitmap);
                }
                if (opaque && translucentWindow)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
        mPrivateFlags |= DRAWING_CACHE_VALID;
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependencies related to variable 'opaque' and 'quality' have been changed, as well as some other statements, so the code change is classified as 3,4.","The change in the control dependencies and other statements bring potential changes in the execution path of the method, which may lead the API to return different values, hence the CI type is 1."
110,<android.view.MotionEvent: float getSize()>,4,5,<android.view.MotionEvent: float getSize()>,<android.view.MotionEvent: float getSize()>,0,"{
    return mSize;
}","{
    return mDataSamples[SAMPLE_SIZE];
}",1,"/**
 * Returns a scaled value of the approximate size, of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch  is normalized with the device specific range of values
 * and scaled to a value between 0 and 1. The value of size can be used to
 * determine fat touch events.
 */
","/**
 * {@link #getSize(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mSize to mDataSamples[SAMPLE_SIZE], and the member variable returned by this API has changed, so the code change type is classified as 1,5.","Since the return statement has changed, the API will potentially return a different value, so the CI type is 1."
112,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",4,5,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>","<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",0,"{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        Phone.DataState state = getMobileDataState(intent);
        String reason = intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        boolean unavailable = intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false);
        if (DBG)
            Log.d(TAG, ""Received "" + intent.getAction() + "" broadcast - state = "" + state + "", unavailable = "" + unavailable + "", reason = "" + (reason == null ? ""(unspecified)"" : reason));
        mNetworkInfo.setIsAvailable(!unavailable);
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    if (mInterfaceName != null) {
                        NetworkUtils.resetConnections(mInterfaceName);
                    }
                    mInterfaceName = null;
                    mDefaultGatewayAddr = 0;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mInterfaceName = intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
                    if (mInterfaceName == null) {
                        Log.d(TAG, ""CONNECTED event did not supply interface name."");
                    }
                    setupDnsProperties();
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String reason = intent.getStringExtra(Phone.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        if (DBG)
            Log.d(TAG, ""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        setDetailedState(DetailedState.FAILED, reason, apnName);
    }
    TelephonyManager tm = TelephonyManager.getDefault();
    setRoamingStatus(tm.isNetworkRoaming());
    setSubtype(tm.getNetworkType(), tm.getNetworkTypeName());
}","{
    synchronized (this) {
        if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
            Phone.DataState state = getMobileDataState(intent);
            String reason = intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
            String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
            String apnTypeList = intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
            mApnName = apnName;
            boolean unavailable = intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false);
            // set this regardless of the apnTypeList.  It's all the same radio/network
            // underneath
            mNetworkInfo.setIsAvailable(!unavailable);
            if (isApnTypeIncluded(apnTypeList)) {
                if (mEnabled == false) {
                    // notifications
                    if (state == Phone.DataState.CONNECTED) {
                        if (DBG)
                            Log.d(TAG, ""replacing old mInterfaceName ("" + mInterfaceName + "") with "" + intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY) + "" for "" + mApnType);
                        mInterfaceName = intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
                    }
                    return;
                }
            } else {
                return;
            }
            if (DBG)
                Log.d(TAG, mApnType + "" Received state= "" + state + "", old= "" + mMobileDataState + "", reason= "" + (reason == null ? ""(unspecified)"" : reason) + "", apnTypeList= "" + apnTypeList);
            if (mMobileDataState != state) {
                mMobileDataState = state;
                switch(state) {
                    case DISCONNECTED:
                        if (isTeardownRequested()) {
                            mEnabled = false;
                            setTeardownRequested(false);
                        }
                        setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                        if (mInterfaceName != null) {
                            NetworkUtils.resetConnections(mInterfaceName);
                        }
                        // mDefaultGatewayAddr = 0;
                        break;
                    case CONNECTING:
                        setDetailedState(DetailedState.CONNECTING, reason, apnName);
                        break;
                    case SUSPENDED:
                        setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                        break;
                    case CONNECTED:
                        mInterfaceName = intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
                        if (mInterfaceName == null) {
                            Log.d(TAG, ""CONNECTED event did not supply interface name."");
                        }
                        setDetailedState(DetailedState.CONNECTED, reason, apnName);
                        break;
                }
            }
        } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
            mEnabled = false;
            String reason = intent.getStringExtra(Phone.FAILURE_REASON_KEY);
            String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
            if (DBG)
                Log.d(TAG, ""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
            setDetailedState(DetailedState.FAILED, reason, apnName);
        }
        TelephonyManager tm = TelephonyManager.getDefault();
        setRoamingStatus(tm.isNetworkRoaming());
        setSubtype(tm.getNetworkType(), tm.getNetworkTypeName());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The statements in the method have been wrapped by a synchronized block and an additional statement ""synchronized (this) {}"" has been added, thus the change type is 3(Control dependency change). Also, there are several new statements (e.g., ""if (isApnTypeIncluded(apnTypeList)) {...}"", ""if (isTeardownRequested()) {...}"") as well as some assignments (e.g., ""mApnName = apnName;"", ""mEnabled = false;"") added, which classify it as the change type 4(Other statement changed).","Though the statements and the control dependencies within this method have been updated, the general flow and exceptions of the method remain the same. It may cause the method to perform differently, but it will not result in compatibility issue as these changes do not affect the return type or exceptions thrown. Therefore, no CI exists for the API."
114,<android.view.MotionEvent: String toString()>,4,5,<android.view.MotionEvent: String toString()>,<android.view.MotionEvent: String toString()>,0,"{
    return ""MotionEvent{"" + Integer.toHexString(System.identityHashCode(this)) + "" action="" + mAction + "" x="" + mX + "" y="" + mY + "" pressure="" + mPressure + "" size="" + mSize + ""}"";
}","{
    return ""MotionEvent{"" + Integer.toHexString(System.identityHashCode(this)) + "" action="" + mAction + "" x="" + getX() + "" y="" + getY() + "" pressure="" + getPressure() + "" size="" + getSize() + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The variables used in the return statement have been replaced by their getter methods (mX replaced by getX(), mY by getY(), mPressure by getPressure(), mSize by getSize()) in the late version. Therefore, the change type is 4.","Despite the refactoring of using getter methods instead of direct variable access, this change won't lead to any compatibility issue. The getter methods should return the same values as the corresponding variables. Therefore, no Compatibility Issue exists."
115,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,4,5,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    CharSequence label;
    if (labelRes != 0) {
        label = pm.getText(ci.packageName, labelRes, ai);
        if (label != null) {
            return label;
        }
    }
    return ci.loadLabel(pm);
}","{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    CharSequence label;
    if (resolvePackageName != null && labelRes != 0) {
        label = pm.getText(resolvePackageName, labelRes, null);
        if (label != null) {
            return label;
        }
    }
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    if (labelRes != 0) {
        label = pm.getText(ci.packageName, labelRes, ai);
        if (label != null) {
            return label;
        }
    }
    return ci.loadLabel(pm);
}",1,"/**
 * Retrieve the current textual label associated with this resolution.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the resolutions's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this resolution.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the resolutions's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are changes within the control dependency i.e `if` condition and also changes in other statement (specifically, a new code block has been added checking if `resolvePackageName != null && labelRes != 0`, and if true, retrieving text from `pm` with calls to `getText(resolvePackageName, labelRes, null)`). Therefore, the change type is 3,4.","The change in return statement in added block introduces a new potential return type, which may internally depend on the values of `resolvePackageName` and `labelRes`. So the API could return a different value. Therefore, the CI type is 1."
116,"<android.inputmethodservice.InputMethodService: boolean onKeyDown(int,KeyEvent)>",4,5,"<android.inputmethodservice.InputMethodService: boolean onKeyDown(int,KeyEvent)>","<android.inputmethodservice.InputMethodService: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
        if (mShowInputRequested) {
            // If the soft input area is shown, back closes it and we
            // consume the back key.
            requestHideSelf(0);
            return true;
        } else if (mWindowVisible) {
            if (mCandidatesVisibility == View.VISIBLE) {
                // If we are showing candidates even if no input area, then
                // hide them.
                setCandidatesViewShown(false);
                return true;
            } else {
                // If we have the window visible for some other reason --
                // most likely to show candidates -- then just get rid
                // of it.  This really shouldn't happen, but just in case...
                hideWindow();
                return true;
            }
        }
    }
    return doMovementKey(keyCode, event, MOVEMENT_DOWN);
}","{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (handleBack(false)) {
            event.startTracking();
            return true;
        }
        return false;
    }
    return doMovementKey(keyCode, event, MOVEMENT_DOWN);
}",1,"/**
 * Override this to intercept key down events before they are processed by the
 * application.  If you return true, the application will not itself
 * process the event.  If you return true, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} to hide the current IME UI if it is shown.  In
 * additional, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
","/**
 * Override this to intercept key down events before they are processed by the
 * application.  If you return true, the application will not itself
 * process the event.  If you return true, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} if the IME is currently shown, to
 * possibly hide it when the key goes up (if not canceled or long pressed).  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency in the corresponding 'if' clause has changed from 'event.getRepeatCount() == 0' to only 'event.getKeyCode() == KeyEvent.KEYCODE_BACK', and the logic in the corresponding 'if' clause is simplified and handled by the 'handleBack' method, so the code change type is 1,3.","The change in the condition check and the logic within the 'if' clause can lead to a potential difference in the return value of the function, indicating that the CI type is 1."
117,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,4,5,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,<android.webkit.CookieSyncManager: void syncFromRamToFlash()>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash STARTS"");
    }
    if (!CookieManager.getInstance().acceptCookie()) {
        return;
    }
    ArrayList<Cookie> cookieList = CookieManager.getInstance().getUpdatedCookiesSince(mLastUpdate);
    mLastUpdate = System.currentTimeMillis();
    syncFromRamToFlash(cookieList);
    ArrayList<Cookie> lruList = CookieManager.getInstance().deleteLRUDomain();
    syncFromRamToFlash(lruList);
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash DONE"");
    }
}","{
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash STARTS"");
    }
    if (!CookieManager.getInstance().acceptCookie()) {
        return;
    }
    ArrayList<Cookie> cookieList = CookieManager.getInstance().getUpdatedCookiesSince(mLastUpdate);
    mLastUpdate = System.currentTimeMillis();
    syncFromRamToFlash(cookieList);
    ArrayList<Cookie> lruList = CookieManager.getInstance().deleteLRUDomain();
    syncFromRamToFlash(lruList);
    if (DebugFlags.COOKIE_SYNC_MANAGER) {
        Log.v(LOGTAG, ""CookieSyncManager::syncFromRamToFlash DONE"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the if condition (from WebView.LOGV_ENABLED to DebugFlags.COOKIE_SYNC_MANAGER) for logging has changed, so the code change type is 4.","The change in the if condition doesn't affect the return value or the exception handling of the method, so no Compatibility Issue exists. Hence, the CI type is 0."
119,<android.hardware.Camera.Parameters: int getPreviewFormat()>,4,5,<android.hardware.Camera.Parameters: int getPreviewFormat()>,<android.hardware.Camera.Parameters: int getPreviewFormat()>,0,"{
    return pixelFormatForCameraFormat(get(""preview-format""));
}","{
    return pixelFormatForCameraFormat(get(KEY_PREVIEW_FORMAT));
}",1,"/**
 * Returns the image format for preview pictures.
 *
 * @return the {@link android.graphics.PixelFormat} int representing
 * the preview picture format.
 */
","/**
 * Returns the image format for preview pictures got from
 * {@link PreviewCallback}.
 *
 * @return the {@link android.graphics.PixelFormat} int representing
 * the preview picture format.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The parameters passed to get() method and pixelFormatForCameraFormat() method are changed from "preview-format" to KEY_PREVIEW_FORMAT. Hence the change types 4 and 5.,"The change of parameters will make pixelFormatForCameraFormat() return a different value, hence it indirectly changes the return of the public API, leading to a compatibility issue of type 1."
121,<com.google.android.gdata.client.QueryParamsImpl: String generateQueryUrl(String)>,4,5,<com.google.android.gdata.client.QueryParamsImpl: String generateQueryUrl(String)>,<com.google.android.gdata.client.QueryParamsImpl: String generateQueryUrl(String)>,0,"{
    if (TextUtils.isEmpty(getEntryId()) && mParams.isEmpty()) {
        // nothing to do
        return feedUrl;
    }
    // handle entry IDs
    if (!TextUtils.isEmpty(getEntryId())) {
        if (!mParams.isEmpty()) {
            throw new IllegalStateException(""Cannot set both an entry ID "" + ""and other query paramters."");
        }
        return feedUrl + '/' + getEntryId();
    }
    // otherwise, append the querystring params.
    StringBuilder sb = new StringBuilder();
    sb.append(feedUrl);
    Set<String> params = mParams.keySet();
    boolean first = true;
    if (feedUrl.contains(""?"")) {
        first = false;
    } else {
        sb.append('?');
    }
    for (String param : params) {
        if (first) {
            first = false;
        } else {
            sb.append('&');
        }
        sb.append(param);
        sb.append('=');
        String value = mParams.get(param);
        String encodedValue = null;
        try {
            encodedValue = URLEncoder.encode(value, ""UTF-8"");
        } catch (UnsupportedEncodingException uee) {
            // should not happen.
            Log.w(""QueryParamsImpl"", ""UTF-8 not supported -- should not happen.  "" + ""Using default encoding."", uee);
            encodedValue = URLEncoder.encode(value);
        }
        sb.append(encodedValue);
    }
    return sb.toString();
}","{
    if (TextUtils.isEmpty(getEntryId()) && mParams.isEmpty()) {
        // nothing to do
        return feedUrl;
    }
    // handle entry IDs
    if (!TextUtils.isEmpty(getEntryId())) {
        if (!mParams.isEmpty()) {
            throw new IllegalStateException(""Cannot set both an entry ID "" + ""and other query paramters."");
        }
        return feedUrl + '/' + getEntryId();
    }
    // otherwise, append the querystring params.
    StringBuilder sb = new StringBuilder();
    sb.append(feedUrl);
    Set<String> params = mParams.keySet();
    boolean first = true;
    if (feedUrl.contains(""?"")) {
        first = false;
    } else {
        sb.append('?');
    }
    for (String param : params) {
        String value = mParams.get(param);
        if (value == null)
            continue;
        if (first) {
            first = false;
        } else {
            sb.append('&');
        }
        sb.append(param);
        sb.append('=');
        String encodedValue = null;
        try {
            encodedValue = URLEncoder.encode(value, ""UTF-8"");
        } catch (UnsupportedEncodingException uee) {
            // should not happen.
            Log.w(""QueryParamsImpl"", ""UTF-8 not supported -- should not happen.  "" + ""Using default encoding."", uee);
            encodedValue = URLEncoder.encode(value);
        }
        sb.append(encodedValue);
    }
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"Only the control dependency inside 'for' loop has changed (a new conditional statement ""if (value == null) continue;"" is introduced), so the code change type is 3.","As the control dependency inside 'for' loop has changed, the construction of String 'sb' can be different which will lead to the generateQueryUrl(String) potentially return different result, thus CI type is 1."
122,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,4,5,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,<android.webkit.CacheManager: boolean removeAllCacheFiles()>,0,"{
    // created or upgraded.
    if (mBaseDir == null) {
        // Init() has not been called yet, so just flag that
        // we need to clear the cache when init() is called.
        mClearCacheOnInit = true;
        return true;
    }
    // delete cache in a separate thread to not block UI.
    final Runnable clearCache = new Runnable() {

        public void run() {
            // delete all cache files
            try {
                String[] files = mBaseDir.list();
                // if mBaseDir doesn't exist, files can be null.
                if (files != null) {
                    for (int i = 0; i < files.length; i++) {
                        new File(mBaseDir, files[i]).delete();
                    }
                }
            } catch (SecurityException e) {
            // Ignore SecurityExceptions.
            }
            // delete database
            mDataBase.clearCache();
        }
    };
    new Thread(clearCache).start();
    return true;
}","{
    // created or upgraded.
    if (mBaseDir == null) {
        // Init() has not been called yet, so just flag that
        // we need to clear the cache when init() is called.
        mClearCacheOnInit = true;
        return true;
    }
    // delete cache in a separate thread to not block UI.
    final Runnable clearCache = new Runnable() {

        public void run() {
            // delete all cache files
            try {
                String[] files = mBaseDir.list();
                // if mBaseDir doesn't exist, files can be null.
                if (files != null) {
                    for (int i = 0; i < files.length; i++) {
                        File f = new File(mBaseDir, files[i]);
                        if (!f.delete()) {
                            Log.e(LOGTAG, f.getPath() + "" delete failed."");
                        }
                    }
                }
            } catch (SecurityException e) {
            // Ignore SecurityExceptions.
            }
            // delete database
            mDataBase.clearCache();
        }
    };
    new Thread(clearCache).start();
    return true;
}",1,"// only called from WebCore thread
","// only called from WebCore thread
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An assignment statement and a logging statement are introduced in the late version of the code in the method 'public run()' of the Runnable instance, so the code change type is 4.","There is no Compatibility Issue because the introduced changes are not causing the API to return a different value or to throw an exception, so the CI type is 0."
124,<android.app.Notification: String toString()>,4,5,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(vibrate="");
    if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        sb.append(this.vibrate[N]);
        sb.append(""]"");
    } else if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",sound="");
    if (this.sound != null) {
        sb.append(this.sound.toString());
    } else if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(vibrate="");
    if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",sound="");
    if (this.sound != null) {
        sb.append(this.sound.toString());
    } else if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"In the late version, an 'if' condition 'if (N != -1)' is added compared to the early version, which falls under the category of Control Dependency Change, hence the code change type is 3.","The added condition can potentially change the behaviour of this API. Depending on whether the condition is met, the 'return' statement may return different values in the late version as compared to the early version, thus causing a compatibility issue. Therefore, the CI type is 1."
125,"<android.webkit.FrameLoader: boolean handleLocalFile(String,LoadListener,WebSettings)>",4,5,"<android.webkit.FrameLoader: boolean handleLocalFile(String,LoadListener,WebSettings)>","<android.webkit.FrameLoader: boolean handleLocalFile(String,LoadListener,WebSettings)>",0,"{
    if (URLUtil.isAssetUrl(url)) {
        FileLoader.requestUrl(url, loadListener, loadListener.getContext(), true, settings.getAllowFileAccess());
        return true;
    } else if (URLUtil.isFileUrl(url)) {
        FileLoader.requestUrl(url, loadListener, loadListener.getContext(), false, settings.getAllowFileAccess());
        return true;
    } else if (URLUtil.isContentUrl(url)) {
        // Send the raw url to the ContentLoader because it will do a
        // permission check and the url has to match..
        ContentLoader.requestUrl(loadListener.url(), loadListener, loadListener.getContext());
        return true;
    } else if (URLUtil.isDataUrl(url)) {
        DataLoader.requestUrl(url, loadListener);
        return true;
    } else if (URLUtil.isAboutUrl(url)) {
        loadListener.data(mAboutBlank.getBytes(), mAboutBlank.length());
        loadListener.endData();
        return true;
    }
    return false;
}","{
    // local loaders.
    try {
        url = new String(URLUtil.decode(url.getBytes()));
    } catch (IllegalArgumentException e) {
        loadListener.error(EventHandler.ERROR_BAD_URL, loadListener.getContext().getString(com.android.internal.R.string.httpErrorBadUrl));
        // error.
        return true;
    }
    if (URLUtil.isAssetUrl(url)) {
        FileLoader.requestUrl(url, loadListener, loadListener.getContext(), true, settings.getAllowFileAccess());
        return true;
    } else if (URLUtil.isFileUrl(url)) {
        FileLoader.requestUrl(url, loadListener, loadListener.getContext(), false, settings.getAllowFileAccess());
        return true;
    } else if (URLUtil.isContentUrl(url)) {
        // Send the raw url to the ContentLoader because it will do a
        // permission check and the url has to match..
        ContentLoader.requestUrl(loadListener.url(), loadListener, loadListener.getContext());
        return true;
    } else if (URLUtil.isDataUrl(url)) {
        DataLoader.requestUrl(url, loadListener);
        return true;
    } else if (URLUtil.isAboutUrl(url)) {
        loadListener.data(mAboutBlank.getBytes(), mAboutBlank.length());
        loadListener.endData();
        return true;
    }
    return false;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","In the new version, the method `new String(URLUtil.decode(url.getBytes()))` is added and it's encapsulated in the try catch block which is new as well. This leads to change in exception handling and addition of other statement. Thus, the code change type is 2, 4.","The new try catch block can lead to different exception handling. Additionally, the modification of url by the `decode()` method may lead to a change in the return value of the method based on what URL is checked and which loader is used. Thus, the CI types are 1, 2."
127,"<android.provider.Settings.NameValueTable: boolean putString(ContentResolver,Uri,String,String)>",4,5,"<android.provider.Settings.NameValueTable: boolean putString(ContentResolver,Uri,String,String)>","<android.provider.Settings.NameValueTable: boolean putString(ContentResolver,Uri,String,String)>",0,"{
    // The database will take care of replacing duplicates.
    try {
        ContentValues values = new ContentValues();
        values.put(NAME, name);
        values.put(VALUE, value);
        resolver.insert(uri, values);
        return true;
    } catch (SQLException e) {
        Log.e(TAG, ""Can't set key "" + name + "" in "" + uri, e);
        return false;
    }
}","{
    // The database will take care of replacing duplicates.
    try {
        ContentValues values = new ContentValues();
        values.put(NAME, name);
        values.put(VALUE, value);
        resolver.insert(uri, values);
        return true;
    } catch (SQLException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + uri, e);
        return false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The severity level of the logging of exceptions has changed from Log.e to Log.w, so the code change type is 4.","This change only affects the logging of exceptions and doesn't induce any different return values/types or exception handlings of this API, Therefore, no compatibility issue exists, and the CI type is 0."
130,<android.net.ConnectivityManager: boolean isNetworkTypeValid(int)>,4,5,<android.net.ConnectivityManager: boolean isNetworkTypeValid(int)>,<android.net.ConnectivityManager: boolean isNetworkTypeValid(int)>,0,"{
    return networkType == TYPE_WIFI || networkType == TYPE_MOBILE;
}","{
    return networkType >= 0 && networkType <= MAX_NETWORK_TYPE;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The entire return statement in the method is redefined from ""return networkType == TYPE_WIFI || networkType == TYPE_MOBILE"" to ""return networkType >= 0 && networkType <= MAX_NETWORK_TYPE"", leading to the change type 1.","The variable returned is likely to be different between the two versions because the condition to determine whether a network type is valid changed significantly, which could potentially cause the API to return a different boolean value, leading to CI type 1."
132,<android.database.sqlite.SQLiteDatabase: boolean yieldIfContendedSafely()>,4,5,<android.database.sqlite.SQLiteDatabase: boolean yieldIfContendedSafely()>,<android.database.sqlite.SQLiteDatabase: boolean yieldIfContendedSafely()>,0,"{
    return yieldIfContendedHelper(true);
}","{
    return yieldIfContendedHelper(true, /* check yielding */
    -1);
}",1,"/**
 * Temporarily end the transaction to let other threads run. The transaction is assumed to be
 * successful so far. Do not call setTransactionSuccessful before calling this. When this
 * returns a new transaction will have been created but not marked as successful. This assumes
 * that there are no nested transactions (beginTransaction has only been called once) and will
 * through an exception if that is not the case.
 * @return true if the transaction was yielded
 */
","/**
 * Temporarily end the transaction to let other threads run. The transaction is assumed to be
 * successful so far. Do not call setTransactionSuccessful before calling this. When this
 * returns a new transaction will have been created but not marked as successful. This assumes
 * that there are no nested transactions (beginTransaction has only been called once) and will
 * throw an exception if that is not the case.
 * @return true if the transaction was yielded
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed between the two versions. The late version of the method yieldIfContendedHelper() has an additional parameter, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
133,<android.content.pm.ConfigurationInfo: String toString()>,4,5,<android.content.pm.ConfigurationInfo: String toString()>,<android.content.pm.ConfigurationInfo: String toString()>,0,"{
    return ""ApplicationHardwarePreferences{"" + Integer.toHexString(System.identityHashCode(this)) + "", touchscreen = "" + reqTouchScreen + ""}"" + "", inputMethod = "" + reqKeyboardType + ""}"" + "", navigation = "" + reqNavigation + ""}"" + "", reqInputFeatures = "" + reqInputFeatures + ""}"" + "", reqGlEsVersion = "" + reqGlEsVersion + ""}"";
}","{
    return ""ConfigurationInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" touchscreen = "" + reqTouchScreen + "" inputMethod = "" + reqKeyboardType + "" navigation = "" + reqNavigation + "" reqInputFeatures = "" + reqInputFeatures + "" reqGlEsVersion = "" + reqGlEsVersion + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement is modified, so the code change type is 1.","The return value has changed in the two versions due to the modification of the return statement, thus the CI type is 1."
135,"<android.widget.VideoView: boolean onKeyDown(int,KeyEvent)>",4,5,"<android.widget.VideoView: boolean onKeyDown(int,KeyEvent)>","<android.widget.VideoView: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (mIsPrepared && keyCode != KeyEvent.KEYCODE_BACK && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_MENU && keyCode != KeyEvent.KEYCODE_CALL && keyCode != KeyEvent.KEYCODE_ENDCALL && mMediaPlayer != null && mMediaController != null) {
        if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
            if (mMediaPlayer.isPlaying()) {
                pause();
                mMediaController.show();
            } else {
                start();
                mMediaController.hide();
            }
            return true;
        } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP && mMediaPlayer.isPlaying()) {
            pause();
            mMediaController.show();
        } else {
            toggleMediaControlsVisiblity();
        }
    }
    return super.onKeyDown(keyCode, event);
}","{
    boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_MENU && keyCode != KeyEvent.KEYCODE_CALL && keyCode != KeyEvent.KEYCODE_ENDCALL;
    if (isInPlaybackState() && isKeyCodeSupported && mMediaController != null) {
        if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) {
            if (mMediaPlayer.isPlaying()) {
                pause();
                mMediaController.show();
            } else {
                start();
                mMediaController.hide();
            }
            return true;
        } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP && mMediaPlayer.isPlaying()) {
            pause();
            mMediaController.show();
        } else {
            toggleMediaControlsVisiblity();
        }
    }
    return super.onKeyDown(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The guard condition has changed from checking if `mIsPrepared` to `isInPlaybackState()` and a new variable `isKeyCodeSupported` is added which includes the key code checks. So, the change type is 3,4.","Both versions eventually return the same 'super.onKeyDown(keyCode, event)' or 'true' under the same keycode condition. Therefore, no Compatibility Issue exists, and the CI type is 0."
136,<android.widget.ListView: boolean fullScroll(int)>,4,5,<android.widget.ListView: boolean fullScroll(int)>,<android.widget.ListView: boolean fullScroll(int)>,0,"{
    boolean moved = false;
    if (direction == FOCUS_UP) {
        if (mSelectedPosition != 0) {
            int position = lookForSelectablePosition(0, true);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_TOP;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    } else if (direction == FOCUS_DOWN) {
        if (mSelectedPosition < mItemCount - 1) {
            int position = lookForSelectablePosition(mItemCount - 1, true);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    }
    if (moved) {
        invalidate();
    }
    return moved;
}","{
    boolean moved = false;
    if (direction == FOCUS_UP) {
        if (mSelectedPosition != 0) {
            int position = lookForSelectablePosition(0, true);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_TOP;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    } else if (direction == FOCUS_DOWN) {
        if (mSelectedPosition < mItemCount - 1) {
            int position = lookForSelectablePosition(mItemCount - 1, true);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    }
    if (moved && !awakenScrollBars()) {
        awakenScrollBars();
        invalidate();
    }
    return moved;
}",1,"/**
 * Go to the last or first item if possible (not worrying about panning across or navigating
 * within the internal focus of the currently selected item.)
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */
","/**
 * Go to the last or first item if possible (not worrying about panning across or navigating
 * within the internal focus of the currently selected item.)
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The if statement inside the control dependency statement has changed, adding an additional function call awakenScrollBars(). Therefore, the code change type is 3. A new internal method call awakenScrollBars() has also been introduced even if the condition of it is false, this would make the code change type 4 as well.","Including the awakenScrollBars() behavior change in the last version, the method could potentially return different variable (in different cases the scroll bars may or may not be awoken) and cause the API to behave differently. Thus, the CI type is 1."
137,<android.content.AsyncQueryHandler.WorkerHandler: void handleMessage(Message)>,4,5,<android.content.AsyncQueryHandler.WorkerHandler: void handleMessage(Message)>,<android.content.AsyncQueryHandler.WorkerHandler: void handleMessage(Message)>,0,"{
    final ContentResolver resolver = mResolver.get();
    if (resolver == null)
        return;
    WorkerArgs args = (WorkerArgs) msg.obj;
    int token = msg.what;
    int event = msg.arg1;
    switch(event) {
        case EVENT_ARG_QUERY:
            Cursor cursor;
            try {
                cursor = resolver.query(args.uri, args.projection, args.selection, args.selectionArgs, args.orderBy);
                // which will make the first access on the main thread a lot faster.
                if (cursor != null) {
                    cursor.getCount();
                }
            } catch (Exception e) {
                cursor = null;
            }
            args.result = cursor;
            break;
        case EVENT_ARG_INSERT:
            args.result = resolver.insert(args.uri, args.values);
            break;
        case EVENT_ARG_UPDATE:
            args.result = resolver.update(args.uri, args.values, args.selection, args.selectionArgs);
            break;
        case EVENT_ARG_DELETE:
            args.result = resolver.delete(args.uri, args.selection, args.selectionArgs);
            break;
    }
    // passing the original token value back to the caller
    // on top of the event values in arg1.
    Message reply = args.handler.obtainMessage(token);
    reply.obj = args;
    reply.arg1 = msg.arg1;
    if (localLOGV) {
        Log.d(TAG, ""WorkerHandler.handleMsg: msg.arg1="" + msg.arg1 + "", reply.what="" + reply.what);
    }
    reply.sendToTarget();
}","{
    final ContentResolver resolver = mResolver.get();
    if (resolver == null)
        return;
    WorkerArgs args = (WorkerArgs) msg.obj;
    int token = msg.what;
    int event = msg.arg1;
    switch(event) {
        case EVENT_ARG_QUERY:
            Cursor cursor;
            try {
                cursor = resolver.query(args.uri, args.projection, args.selection, args.selectionArgs, args.orderBy);
                // which will make the first access on the main thread a lot faster.
                if (cursor != null) {
                    cursor.getCount();
                }
            } catch (Exception e) {
                Log.w(TAG, e.toString());
                cursor = null;
            }
            args.result = cursor;
            break;
        case EVENT_ARG_QUERY_ENTITIES:
            EntityIterator iterator = null;
            try {
                iterator = resolver.queryEntities(args.uri, args.selection, args.selectionArgs, args.orderBy);
            } catch (Exception e) {
                Log.w(TAG, e.toString());
            }
            args.result = iterator;
            break;
        case EVENT_ARG_INSERT:
            args.result = resolver.insert(args.uri, args.values);
            break;
        case EVENT_ARG_UPDATE:
            args.result = resolver.update(args.uri, args.values, args.selection, args.selectionArgs);
            break;
        case EVENT_ARG_DELETE:
            args.result = resolver.delete(args.uri, args.selection, args.selectionArgs);
            break;
    }
    // passing the original token value back to the caller
    // on top of the event values in arg1.
    Message reply = args.handler.obtainMessage(token);
    reply.obj = args;
    reply.arg1 = msg.arg1;
    if (localLOGV) {
        Log.d(TAG, ""WorkerHandler.handleMsg: msg.arg1="" + msg.arg1 + "", reply.what="" + reply.what);
    }
    reply.sendToTarget();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The method's body in the late version has introduced a new case statement for EVENT_ARG_QUERY_ENTITIES, which added a new dependent API ""resolver.queryEntities"". Also, the exception handling within 'case EVENT_ARG_QUERY' has added a log statement. Hence, the code change type is 2,3,4,5.","As new dependent API ""resolver.queryEntities"" is being introduced, the output of the function could significantly differ depending on the event being passed which could lead to difference in the return value, hence CI type is 1. Also, exception handling is changed to now log the exception in case of a specific event, hence the CI type is also 2."
138,<android.widget.VideoView: int getDuration()>,4,5,<android.widget.VideoView: int getDuration()>,<android.widget.VideoView: int getDuration()>,0,"{
    if (mMediaPlayer != null && mIsPrepared) {
        if (mDuration > 0) {
            return mDuration;
        }
        mDuration = mMediaPlayer.getDuration();
        return mDuration;
    }
    mDuration = -1;
    return mDuration;
}","{
    if (isInPlaybackState()) {
        if (mDuration > 0) {
            return mDuration;
        }
        mDuration = mMediaPlayer.getDuration();
        return mDuration;
    }
    mDuration = -1;
    return mDuration;
}",1,,"// cache duration as mDuration for faster access
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The conditional check in the 'if' statement has changed from 'mMediaPlayer != null && mIsPrepared' to 'isInPlaybackState()', marking the change type 3.","Due to the changed condition in the if statement, it potentially alters the behavior of the API, making it return a different value. Hence, the CI type is 1."
141,<android.webkit.FileLoader: boolean setupStreamAndSendStatus()>,4,5,<android.webkit.FileLoader: boolean setupStreamAndSendStatus()>,<android.webkit.FileLoader: boolean setupStreamAndSendStatus()>,0,"{
    try {
        if (mIsAsset) {
            try {
                mDataStream = mContext.getAssets().open(mPath);
            } catch (java.io.FileNotFoundException ex) {
                // try the rest files included in the package
                mDataStream = mContext.getAssets().openNonAsset(mPath);
            }
        } else {
            if (!mAllowFileAccess) {
                mHandler.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound));
                return false;
            }
            mDataStream = new FileInputStream(mPath);
            mContentLength = (new File(mPath)).length();
        }
        mHandler.status(1, 1, 0, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, mContext.getString(R.string.httpErrorFileNotFound) + "" "" + ex.getMessage());
        return false;
    } catch (java.io.IOException ex) {
        mHandler.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound) + "" "" + ex.getMessage());
        return false;
    }
    return true;
}","{
    try {
        if (mIsAsset) {
            try {
                mDataStream = mContext.getAssets().open(mPath);
            } catch (java.io.FileNotFoundException ex) {
                // try the rest files included in the package
                mDataStream = mContext.getAssets().openNonAsset(mPath);
            }
        } else {
            if (!mAllowFileAccess) {
                mHandler.error(EventHandler.FILE_ERROR, mContext.getString(R.string.httpErrorFileNotFound));
                return false;
            }
            mDataStream = new FileInputStream(mPath);
            mContentLength = (new File(mPath)).length();
        }
        mHandler.status(1, 1, 0, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, errString(ex));
        return false;
    } catch (java.io.IOException ex) {
        mHandler.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The error handling statement mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, mContext.getString(R.string.httpErrorFileNotFound) + "" "" + ex.getMessage()) in the catch block has been changed mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, errString(ex)) and similarly for a second exception block. This falls under category 4 - Other statement changed.","In both version, the error messages could be different due to the modification of error statement. Thus, it changes the return behavior of the API and leads to a Compatibility Issue of category 1 (Compatibility Issue caused by potential different return values)."
144,"<android.server.BluetoothA2dpService: void dump(FileDescriptor,PrintWriter,String[])>",4,5,"<android.server.BluetoothA2dpService: void dump(FileDescriptor,PrintWriter,String[])>","<android.server.BluetoothA2dpService: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    if (mAudioDevices == null)
        return;
    pw.println(""Cached audio devices:"");
    for (String path : mAudioDevices.keySet()) {
        SinkState sink = mAudioDevices.get(path);
        pw.println(path + "" "" + sink.address + "" "" + BluetoothA2dp.stateToString(sink.state));
    }
}","{
    if (mAudioDevices.isEmpty())
        return;
    pw.println(""Cached audio devices:"");
    for (BluetoothDevice device : mAudioDevices.keySet()) {
        int state = mAudioDevices.get(device);
        pw.println(device + "" "" + BluetoothA2dp.stateToString(state));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The condition statement has changed from `mAudioDevices == null` to `mAudioDevices.isEmpty()`. The type for iteration over `mAudioDevices.keySet()` has also changed from `String path` to `BluetoothDevice device`. The get method `mAudioDevices.get()` changed its parameter type and the logic associated with this mechanism has changed. Thus, the code change belongs to the categories 1, 3, 4, and 5.","Due to the changes in control dependency, return statement and dependent APIs, the API can potentially return a different value in the new version, which results in compatibility issue type 1."
146,<android.hardware.Camera.Parameters: int getPictureFormat()>,4,5,<android.hardware.Camera.Parameters: int getPictureFormat()>,<android.hardware.Camera.Parameters: int getPictureFormat()>,0,"{
    return pixelFormatForCameraFormat(get(""picture-format""));
}","{
    return pixelFormatForCameraFormat(get(KEY_PICTURE_FORMAT));
}",1,"/**
 * Returns the image format for pictures.
 *
 * @return the PixelFormat int representing the picture format
 */
","/**
 * Returns the image format for pictures.
 *
 * @return the PixelFormat int representing the picture format
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the initial implementation, the argument used in the `get()` method was a string literal ""picture-format"", whereas in the later version it was changed to a constant named `KEY_PICTURE_FORMAT`, which can be classified as Other statement changed(4). Also, the dependent API `get()` method is also changed because of the change in its parameter, which can be classified as Dependent API changed(5).","As the `get()` method is now called with a different argument, the returned value may be different in different versions, which can result in the API returning a different value. Therefore, it is a Compatibility Issue caused by potential different return values or types(1)."
147,"<android.provider.Contacts.People: InputStream openContactPhotoInputStream(ContentResolver,Uri)>",4,5,"<android.provider.Contacts.People: InputStream openContactPhotoInputStream(ContentResolver,Uri)>","<android.provider.Contacts.People: InputStream openContactPhotoInputStream(ContentResolver,Uri)>",0,"{
    Uri photoUri = Uri.withAppendedPath(person, Contacts.Photos.CONTENT_DIRECTORY);
    Cursor cursor = cr.query(photoUri, new String[] { Photos.DATA }, null, null, null);
    try {
        if (!cursor.moveToNext()) {
            return null;
        }
        byte[] data = cursor.getBlob(0);
        if (data == null) {
            return null;
        }
        return new ByteArrayInputStream(data);
    } finally {
        cursor.close();
    }
}","{
    Uri photoUri = Uri.withAppendedPath(person, Contacts.Photos.CONTENT_DIRECTORY);
    Cursor cursor = cr.query(photoUri, new String[] { Photos.DATA }, null, null, null);
    try {
        if (cursor == null || !cursor.moveToNext()) {
            return null;
        }
        byte[] data = cursor.getBlob(0);
        if (data == null) {
            return null;
        }
        return new ByteArrayInputStream(data);
    } finally {
        if (cursor != null)
            cursor.close();
    }
}",1,"/**
 * Opens an InputStream for the person's photo and returns the photo as a Bitmap.
 * If the person's photo isn't present returns the placeholderImageResource instead.
 * @param person the person whose photo should be used
 */
","/**
 * Opens an InputStream for the person's photo and returns the photo as a Bitmap.
 * If the person's photo isn't present returns the placeholderImageResource instead.
 * @param person the person whose photo should be used
 * @deprecated see {@link android.provider.ContactsContract}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,3,1,"The condition in the 'if' statement has changed from 'if (!cursor.moveToNext())' to 'if (cursor == null || !cursor.moveToNext())'. Therefore, the code change type is 3.","The modification of the condition in the 'if' statement potentially influences the returned value of the program as the 'return null' could be executed under different conditions in the new version. Thus, the CI type is 1."
151,"<android.app.Activity: boolean onKeyDown(int,KeyEvent)>",4,5,"<android.app.Activity: boolean onKeyDown(int,KeyEvent)>","<android.app.Activity: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
        finish();
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        return getWindow().performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE);
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        if (getWindow().performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(""tel:"" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}",1,"/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation handles KEYCODE_BACK to stop the activity
 * and go back, and other default key handling if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
","/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 * by calling {@link #onBackPressed()}, though the behavior varies based
 * on the application compatibility mode: for
 * {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 * it will set up the dispatch to call {@link #onKeyUp} where the action
 * will be performed; for earlier applications, it will perform the
 * action immediately in on-down, as those versions of the platform
 * behaved.
 *
 * <p>Other additional default key handling may be performed
 * if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The early implementation and late implementation have changes in their statements in the condition 'if (keyCode == KeyEvent.KEYCODE_BACK)' and 'if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT)', these changes fall under type '1' as they influence the return statements and type '3' for the alteration in control statements.","With these code changes, the 'onKeyDown' method of the 'Activity' class might return a different variable as the conditions for returning a value are no longer the same. This can cause compatibility issue of type '1'."
152,<android.webkit.MimeTypeMap: MimeTypeMap getSingleton()>,4,5,<android.webkit.MimeTypeMap: MimeTypeMap getSingleton()>,<android.webkit.MimeTypeMap: MimeTypeMap getSingleton()>,0,"{
    if (sMimeTypeMap == null) {
        sMimeTypeMap = new MimeTypeMap();
        // The following table is based on /etc/mime.types data minus
        // chemical/* MIME types and MIME types that don't map to any
        // file extensions. We also exclude top-level domain names to
        // deal with cases like:
        // 
        // mail.google.com/a/google.com
        // 
        // and ""active"" MIME types (due to potential security issues).
        // 
        // Also, notice that not all data from this table is actually
        // added (see loadEntry method for more details).
        sMimeTypeMap.loadEntry(""application/andrew-inset"", ""ez"", false);
        sMimeTypeMap.loadEntry(""application/dsptype"", ""tsp"", false);
        sMimeTypeMap.loadEntry(""application/futuresplash"", ""spl"", false);
        sMimeTypeMap.loadEntry(""application/hta"", ""hta"", false);
        sMimeTypeMap.loadEntry(""application/mac-binhex40"", ""hqx"", false);
        sMimeTypeMap.loadEntry(""application/mac-compactpro"", ""cpt"", false);
        sMimeTypeMap.loadEntry(""application/mathematica"", ""nb"", false);
        sMimeTypeMap.loadEntry(""application/msaccess"", ""mdb"", false);
        sMimeTypeMap.loadEntry(""application/oda"", ""oda"", false);
        sMimeTypeMap.loadEntry(""application/ogg"", ""ogg"", false);
        sMimeTypeMap.loadEntry(""application/pdf"", ""pdf"", false);
        sMimeTypeMap.loadEntry(""application/pgp-keys"", ""key"", false);
        sMimeTypeMap.loadEntry(""application/pgp-signature"", ""pgp"", false);
        sMimeTypeMap.loadEntry(""application/pics-rules"", ""prf"", false);
        sMimeTypeMap.loadEntry(""application/rar"", ""rar"", false);
        sMimeTypeMap.loadEntry(""application/rdf+xml"", ""rdf"", false);
        sMimeTypeMap.loadEntry(""application/rss+xml"", ""rss"", false);
        sMimeTypeMap.loadEntry(""application/zip"", ""zip"", false);
        sMimeTypeMap.loadEntry(""application/vnd.android.package-archive"", ""apk"", false);
        sMimeTypeMap.loadEntry(""application/vnd.cinderella"", ""cdy"", false);
        sMimeTypeMap.loadEntry(""application/vnd.ms-pki.stl"", ""stl"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.database"", ""odb"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.formula"", ""odf"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics"", ""odg"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics-template"", ""otg"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.image"", ""odi"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet"", ""ods"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet-template"", ""ots"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text"", ""odt"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-master"", ""odm"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-template"", ""ott"", false);
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-web"", ""oth"", false);
        sMimeTypeMap.loadEntry(""application/vnd.rim.cod"", ""cod"", false);
        sMimeTypeMap.loadEntry(""application/vnd.smaf"", ""mmf"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.calc"", ""sdc"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.draw"", ""sda"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdd"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdp"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.math"", ""smf"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""sdw"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""vor"", false);
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer-global"", ""sgl"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc"", ""sxc"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc.template"", ""stc"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw"", ""sxd"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw.template"", ""std"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress"", ""sxi"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress.template"", ""sti"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.math"", ""sxm"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer"", ""sxw"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.global"", ""sxg"", false);
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.template"", ""stw"", false);
        sMimeTypeMap.loadEntry(""application/vnd.visio"", ""vsd"", false);
        sMimeTypeMap.loadEntry(""application/x-abiword"", ""abw"", false);
        sMimeTypeMap.loadEntry(""application/x-apple-diskimage"", ""dmg"", false);
        sMimeTypeMap.loadEntry(""application/x-bcpio"", ""bcpio"", false);
        sMimeTypeMap.loadEntry(""application/x-bittorrent"", ""torrent"", false);
        sMimeTypeMap.loadEntry(""application/x-cdf"", ""cdf"", false);
        sMimeTypeMap.loadEntry(""application/x-cdlink"", ""vcd"", false);
        sMimeTypeMap.loadEntry(""application/x-chess-pgn"", ""pgn"", false);
        sMimeTypeMap.loadEntry(""application/x-cpio"", ""cpio"", false);
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""deb"", false);
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""udeb"", false);
        sMimeTypeMap.loadEntry(""application/x-director"", ""dcr"", false);
        sMimeTypeMap.loadEntry(""application/x-director"", ""dir"", false);
        sMimeTypeMap.loadEntry(""application/x-director"", ""dxr"", false);
        sMimeTypeMap.loadEntry(""application/x-dms"", ""dms"", false);
        sMimeTypeMap.loadEntry(""application/x-doom"", ""wad"", false);
        sMimeTypeMap.loadEntry(""application/x-dvi"", ""dvi"", false);
        sMimeTypeMap.loadEntry(""application/x-flac"", ""flac"", false);
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfa"", false);
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfb"", false);
        sMimeTypeMap.loadEntry(""application/x-font"", ""gsf"", false);
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf"", false);
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf.Z"", false);
        sMimeTypeMap.loadEntry(""application/x-freemind"", ""mm"", false);
        sMimeTypeMap.loadEntry(""application/x-futuresplash"", ""spl"", false);
        sMimeTypeMap.loadEntry(""application/x-gnumeric"", ""gnumeric"", false);
        sMimeTypeMap.loadEntry(""application/x-go-sgf"", ""sgf"", false);
        sMimeTypeMap.loadEntry(""application/x-graphing-calculator"", ""gcf"", false);
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""gtar"", false);
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""tgz"", false);
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""taz"", false);
        sMimeTypeMap.loadEntry(""application/x-hdf"", ""hdf"", false);
        sMimeTypeMap.loadEntry(""application/x-ica"", ""ica"", false);
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""ins"", false);
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""isp"", false);
        sMimeTypeMap.loadEntry(""application/x-iphone"", ""iii"", false);
        sMimeTypeMap.loadEntry(""application/x-iso9660-image"", ""iso"", false);
        sMimeTypeMap.loadEntry(""application/x-jmol"", ""jmz"", false);
        sMimeTypeMap.loadEntry(""application/x-kchart"", ""chrt"", false);
        sMimeTypeMap.loadEntry(""application/x-killustrator"", ""kil"", false);
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skp"", false);
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skd"", false);
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skt"", false);
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skm"", false);
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpr"", false);
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpt"", false);
        sMimeTypeMap.loadEntry(""application/x-kspread"", ""ksp"", false);
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwd"", false);
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwt"", false);
        sMimeTypeMap.loadEntry(""application/x-latex"", ""latex"", false);
        sMimeTypeMap.loadEntry(""application/x-lha"", ""lha"", false);
        sMimeTypeMap.loadEntry(""application/x-lzh"", ""lzh"", false);
        sMimeTypeMap.loadEntry(""application/x-lzx"", ""lzx"", false);
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frm"", false);
        sMimeTypeMap.loadEntry(""application/x-maker"", ""maker"", false);
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frame"", false);
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fb"", false);
        sMimeTypeMap.loadEntry(""application/x-maker"", ""book"", false);
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fbdoc"", false);
        sMimeTypeMap.loadEntry(""application/x-mif"", ""mif"", false);
        sMimeTypeMap.loadEntry(""application/x-ms-wmd"", ""wmd"", false);
        sMimeTypeMap.loadEntry(""application/x-ms-wmz"", ""wmz"", false);
        sMimeTypeMap.loadEntry(""application/x-msi"", ""msi"", false);
        sMimeTypeMap.loadEntry(""application/x-ns-proxy-autoconfig"", ""pac"", false);
        sMimeTypeMap.loadEntry(""application/x-nwc"", ""nwc"", false);
        sMimeTypeMap.loadEntry(""application/x-object"", ""o"", false);
        sMimeTypeMap.loadEntry(""application/x-oz-application"", ""oza"", false);
        sMimeTypeMap.loadEntry(""application/x-pkcs12"", ""p12"", false);
        sMimeTypeMap.loadEntry(""application/x-pkcs7-certreqresp"", ""p7r"", false);
        sMimeTypeMap.loadEntry(""application/x-pkcs7-crl"", ""crl"", false);
        sMimeTypeMap.loadEntry(""application/x-quicktimeplayer"", ""qtl"", false);
        sMimeTypeMap.loadEntry(""application/x-shar"", ""shar"", false);
        sMimeTypeMap.loadEntry(""application/x-stuffit"", ""sit"", false);
        sMimeTypeMap.loadEntry(""application/x-sv4cpio"", ""sv4cpio"", false);
        sMimeTypeMap.loadEntry(""application/x-sv4crc"", ""sv4crc"", false);
        sMimeTypeMap.loadEntry(""application/x-tar"", ""tar"", false);
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texinfo"", false);
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texi"", false);
        sMimeTypeMap.loadEntry(""application/x-troff"", ""t"", false);
        sMimeTypeMap.loadEntry(""application/x-troff"", ""roff"", false);
        sMimeTypeMap.loadEntry(""application/x-troff-man"", ""man"", false);
        sMimeTypeMap.loadEntry(""application/x-ustar"", ""ustar"", false);
        sMimeTypeMap.loadEntry(""application/x-wais-source"", ""src"", false);
        sMimeTypeMap.loadEntry(""application/x-wingz"", ""wz"", false);
        sMimeTypeMap.loadEntry(""application/x-webarchive"", ""webarchive"", // added
        false);
        sMimeTypeMap.loadEntry(""application/x-x509-ca-cert"", ""crt"", false);
        sMimeTypeMap.loadEntry(""application/x-x509-user-cert"", ""crt"", false);
        sMimeTypeMap.loadEntry(""application/x-xcf"", ""xcf"", false);
        sMimeTypeMap.loadEntry(""application/x-xfig"", ""fig"", false);
        sMimeTypeMap.loadEntry(""audio/basic"", ""snd"", false);
        sMimeTypeMap.loadEntry(""audio/midi"", ""mid"", false);
        sMimeTypeMap.loadEntry(""audio/midi"", ""midi"", false);
        sMimeTypeMap.loadEntry(""audio/midi"", ""kar"", false);
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpga"", false);
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpega"", false);
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp2"", false);
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp3"", false);
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""m4a"", false);
        sMimeTypeMap.loadEntry(""audio/mpegurl"", ""m3u"", false);
        sMimeTypeMap.loadEntry(""audio/prs.sid"", ""sid"", false);
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aif"", false);
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aiff"", false);
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aifc"", false);
        sMimeTypeMap.loadEntry(""audio/x-gsm"", ""gsm"", false);
        sMimeTypeMap.loadEntry(""audio/x-mpegurl"", ""m3u"", false);
        sMimeTypeMap.loadEntry(""audio/x-ms-wma"", ""wma"", false);
        sMimeTypeMap.loadEntry(""audio/x-ms-wax"", ""wax"", false);
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ra"", false);
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""rm"", false);
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ram"", false);
        sMimeTypeMap.loadEntry(""audio/x-realaudio"", ""ra"", false);
        sMimeTypeMap.loadEntry(""audio/x-scpls"", ""pls"", false);
        sMimeTypeMap.loadEntry(""audio/x-sd2"", ""sd2"", false);
        sMimeTypeMap.loadEntry(""audio/x-wav"", ""wav"", false);
        // added
        sMimeTypeMap.loadEntry(""image/bmp"", ""bmp"", false);
        sMimeTypeMap.loadEntry(""image/gif"", ""gif"", false);
        // added
        sMimeTypeMap.loadEntry(""image/ico"", ""cur"", false);
        // added
        sMimeTypeMap.loadEntry(""image/ico"", ""ico"", false);
        sMimeTypeMap.loadEntry(""image/ief"", ""ief"", false);
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpeg"", false);
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpg"", false);
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpe"", false);
        sMimeTypeMap.loadEntry(""image/pcx"", ""pcx"", false);
        sMimeTypeMap.loadEntry(""image/png"", ""png"", false);
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svg"", false);
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svgz"", false);
        sMimeTypeMap.loadEntry(""image/tiff"", ""tiff"", false);
        sMimeTypeMap.loadEntry(""image/tiff"", ""tif"", false);
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djvu"", false);
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djv"", false);
        sMimeTypeMap.loadEntry(""image/vnd.wap.wbmp"", ""wbmp"", false);
        sMimeTypeMap.loadEntry(""image/x-cmu-raster"", ""ras"", false);
        sMimeTypeMap.loadEntry(""image/x-coreldraw"", ""cdr"", false);
        sMimeTypeMap.loadEntry(""image/x-coreldrawpattern"", ""pat"", false);
        sMimeTypeMap.loadEntry(""image/x-coreldrawtemplate"", ""cdt"", false);
        sMimeTypeMap.loadEntry(""image/x-corelphotopaint"", ""cpt"", false);
        sMimeTypeMap.loadEntry(""image/x-icon"", ""ico"", false);
        sMimeTypeMap.loadEntry(""image/x-jg"", ""art"", false);
        sMimeTypeMap.loadEntry(""image/x-jng"", ""jng"", false);
        sMimeTypeMap.loadEntry(""image/x-ms-bmp"", ""bmp"", false);
        sMimeTypeMap.loadEntry(""image/x-photoshop"", ""psd"", false);
        sMimeTypeMap.loadEntry(""image/x-portable-anymap"", ""pnm"", false);
        sMimeTypeMap.loadEntry(""image/x-portable-bitmap"", ""pbm"", false);
        sMimeTypeMap.loadEntry(""image/x-portable-graymap"", ""pgm"", false);
        sMimeTypeMap.loadEntry(""image/x-portable-pixmap"", ""ppm"", false);
        sMimeTypeMap.loadEntry(""image/x-rgb"", ""rgb"", false);
        sMimeTypeMap.loadEntry(""image/x-xbitmap"", ""xbm"", false);
        sMimeTypeMap.loadEntry(""image/x-xpixmap"", ""xpm"", false);
        sMimeTypeMap.loadEntry(""image/x-xwindowdump"", ""xwd"", false);
        sMimeTypeMap.loadEntry(""model/iges"", ""igs"", false);
        sMimeTypeMap.loadEntry(""model/iges"", ""iges"", false);
        sMimeTypeMap.loadEntry(""model/mesh"", ""msh"", false);
        sMimeTypeMap.loadEntry(""model/mesh"", ""mesh"", false);
        sMimeTypeMap.loadEntry(""model/mesh"", ""silo"", false);
        sMimeTypeMap.loadEntry(""text/calendar"", ""ics"", true);
        sMimeTypeMap.loadEntry(""text/calendar"", ""icz"", true);
        sMimeTypeMap.loadEntry(""text/comma-separated-values"", ""csv"", true);
        sMimeTypeMap.loadEntry(""text/css"", ""css"", true);
        sMimeTypeMap.loadEntry(""text/h323"", ""323"", true);
        sMimeTypeMap.loadEntry(""text/iuls"", ""uls"", true);
        sMimeTypeMap.loadEntry(""text/mathml"", ""mml"", true);
        // add it first so it will be the default for ExtensionFromMimeType
        sMimeTypeMap.loadEntry(""text/plain"", ""txt"", true);
        sMimeTypeMap.loadEntry(""text/plain"", ""asc"", true);
        sMimeTypeMap.loadEntry(""text/plain"", ""text"", true);
        sMimeTypeMap.loadEntry(""text/plain"", ""diff"", true);
        sMimeTypeMap.loadEntry(""text/plain"", ""pot"", true);
        sMimeTypeMap.loadEntry(""text/richtext"", ""rtx"", true);
        sMimeTypeMap.loadEntry(""text/rtf"", ""rtf"", true);
        sMimeTypeMap.loadEntry(""text/texmacs"", ""ts"", true);
        sMimeTypeMap.loadEntry(""text/text"", ""phps"", true);
        sMimeTypeMap.loadEntry(""text/tab-separated-values"", ""tsv"", true);
        sMimeTypeMap.loadEntry(""text/x-bibtex"", ""bib"", true);
        sMimeTypeMap.loadEntry(""text/x-boo"", ""boo"", true);
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""h++"", true);
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hpp"", true);
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hxx"", true);
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hh"", true);
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""c++"", true);
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cpp"", true);
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cxx"", true);
        sMimeTypeMap.loadEntry(""text/x-chdr"", ""h"", true);
        sMimeTypeMap.loadEntry(""text/x-component"", ""htc"", true);
        sMimeTypeMap.loadEntry(""text/x-csh"", ""csh"", true);
        sMimeTypeMap.loadEntry(""text/x-csrc"", ""c"", true);
        sMimeTypeMap.loadEntry(""text/x-dsrc"", ""d"", true);
        sMimeTypeMap.loadEntry(""text/x-haskell"", ""hs"", true);
        sMimeTypeMap.loadEntry(""text/x-java"", ""java"", true);
        sMimeTypeMap.loadEntry(""text/x-literate-haskell"", ""lhs"", true);
        sMimeTypeMap.loadEntry(""text/x-moc"", ""moc"", true);
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""p"", true);
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""pas"", true);
        sMimeTypeMap.loadEntry(""text/x-pcs-gcd"", ""gcd"", true);
        sMimeTypeMap.loadEntry(""text/x-setext"", ""etx"", true);
        sMimeTypeMap.loadEntry(""text/x-tcl"", ""tcl"", true);
        sMimeTypeMap.loadEntry(""text/x-tex"", ""tex"", true);
        sMimeTypeMap.loadEntry(""text/x-tex"", ""ltx"", true);
        sMimeTypeMap.loadEntry(""text/x-tex"", ""sty"", true);
        sMimeTypeMap.loadEntry(""text/x-tex"", ""cls"", true);
        sMimeTypeMap.loadEntry(""text/x-vcalendar"", ""vcs"", true);
        sMimeTypeMap.loadEntry(""text/x-vcard"", ""vcf"", true);
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3gp"", false);
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3g2"", false);
        sMimeTypeMap.loadEntry(""video/dl"", ""dl"", false);
        sMimeTypeMap.loadEntry(""video/dv"", ""dif"", false);
        sMimeTypeMap.loadEntry(""video/dv"", ""dv"", false);
        sMimeTypeMap.loadEntry(""video/fli"", ""fli"", false);
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpeg"", false);
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpg"", false);
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpe"", false);
        sMimeTypeMap.loadEntry(""video/mp4"", ""mp4"", false);
        sMimeTypeMap.loadEntry(""video/mpeg"", ""VOB"", false);
        sMimeTypeMap.loadEntry(""video/quicktime"", ""qt"", false);
        sMimeTypeMap.loadEntry(""video/quicktime"", ""mov"", false);
        sMimeTypeMap.loadEntry(""video/vnd.mpegurl"", ""mxu"", false);
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsf"", false);
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsx"", false);
        sMimeTypeMap.loadEntry(""video/x-mng"", ""mng"", false);
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asf"", false);
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asx"", false);
        sMimeTypeMap.loadEntry(""video/x-ms-wm"", ""wm"", false);
        sMimeTypeMap.loadEntry(""video/x-ms-wmv"", ""wmv"", false);
        sMimeTypeMap.loadEntry(""video/x-ms-wmx"", ""wmx"", false);
        sMimeTypeMap.loadEntry(""video/x-ms-wvx"", ""wvx"", false);
        sMimeTypeMap.loadEntry(""video/x-msvideo"", ""avi"", false);
        sMimeTypeMap.loadEntry(""video/x-sgi-movie"", ""movie"", false);
        sMimeTypeMap.loadEntry(""x-conference/x-cooltalk"", ""ice"", false);
        sMimeTypeMap.loadEntry(""x-epoc/x-sisx-app"", ""sisx"", false);
    }
    return sMimeTypeMap;
}","{
    if (sMimeTypeMap == null) {
        sMimeTypeMap = new MimeTypeMap();
        // The following table is based on /etc/mime.types data minus
        // chemical/* MIME types and MIME types that don't map to any
        // file extensions. We also exclude top-level domain names to
        // deal with cases like:
        // 
        // mail.google.com/a/google.com
        // 
        // and ""active"" MIME types (due to potential security issues).
        sMimeTypeMap.loadEntry(""application/andrew-inset"", ""ez"");
        sMimeTypeMap.loadEntry(""application/dsptype"", ""tsp"");
        sMimeTypeMap.loadEntry(""application/futuresplash"", ""spl"");
        sMimeTypeMap.loadEntry(""application/hta"", ""hta"");
        sMimeTypeMap.loadEntry(""application/mac-binhex40"", ""hqx"");
        sMimeTypeMap.loadEntry(""application/mac-compactpro"", ""cpt"");
        sMimeTypeMap.loadEntry(""application/mathematica"", ""nb"");
        sMimeTypeMap.loadEntry(""application/msaccess"", ""mdb"");
        sMimeTypeMap.loadEntry(""application/oda"", ""oda"");
        sMimeTypeMap.loadEntry(""application/ogg"", ""ogg"");
        sMimeTypeMap.loadEntry(""application/pdf"", ""pdf"");
        sMimeTypeMap.loadEntry(""application/pgp-keys"", ""key"");
        sMimeTypeMap.loadEntry(""application/pgp-signature"", ""pgp"");
        sMimeTypeMap.loadEntry(""application/pics-rules"", ""prf"");
        sMimeTypeMap.loadEntry(""application/rar"", ""rar"");
        sMimeTypeMap.loadEntry(""application/rdf+xml"", ""rdf"");
        sMimeTypeMap.loadEntry(""application/rss+xml"", ""rss"");
        sMimeTypeMap.loadEntry(""application/zip"", ""zip"");
        sMimeTypeMap.loadEntry(""application/vnd.android.package-archive"", ""apk"");
        sMimeTypeMap.loadEntry(""application/vnd.cinderella"", ""cdy"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-pki.stl"", ""stl"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.database"", ""odb"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.formula"", ""odf"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics"", ""odg"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.graphics-template"", ""otg"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.image"", ""odi"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet"", ""ods"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.spreadsheet-template"", ""ots"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text"", ""odt"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-master"", ""odm"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-template"", ""ott"");
        sMimeTypeMap.loadEntry(""application/vnd.oasis.opendocument.text-web"", ""oth"");
        sMimeTypeMap.loadEntry(""application/msword"", ""doc"");
        sMimeTypeMap.loadEntry(""application/msword"", ""dot"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.wordprocessingml.document"", ""docx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.wordprocessingml.template"", ""dotx"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-excel"", ""xls"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-excel"", ""xlt"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"", ""xlsx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.spreadsheetml.template"", ""xltx"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""ppt"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""pot"");
        sMimeTypeMap.loadEntry(""application/vnd.ms-powerpoint"", ""pps"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.presentation"", ""pptx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.template"", ""potx"");
        sMimeTypeMap.loadEntry(""application/vnd.openxmlformats-officedocument.presentationml.slideshow"", ""ppsx"");
        sMimeTypeMap.loadEntry(""application/vnd.rim.cod"", ""cod"");
        sMimeTypeMap.loadEntry(""application/vnd.smaf"", ""mmf"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.calc"", ""sdc"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.draw"", ""sda"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdd"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.impress"", ""sdp"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.math"", ""smf"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""sdw"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer"", ""vor"");
        sMimeTypeMap.loadEntry(""application/vnd.stardivision.writer-global"", ""sgl"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc"", ""sxc"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.calc.template"", ""stc"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw"", ""sxd"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.draw.template"", ""std"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress"", ""sxi"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.impress.template"", ""sti"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.math"", ""sxm"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer"", ""sxw"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.global"", ""sxg"");
        sMimeTypeMap.loadEntry(""application/vnd.sun.xml.writer.template"", ""stw"");
        sMimeTypeMap.loadEntry(""application/vnd.visio"", ""vsd"");
        sMimeTypeMap.loadEntry(""application/x-abiword"", ""abw"");
        sMimeTypeMap.loadEntry(""application/x-apple-diskimage"", ""dmg"");
        sMimeTypeMap.loadEntry(""application/x-bcpio"", ""bcpio"");
        sMimeTypeMap.loadEntry(""application/x-bittorrent"", ""torrent"");
        sMimeTypeMap.loadEntry(""application/x-cdf"", ""cdf"");
        sMimeTypeMap.loadEntry(""application/x-cdlink"", ""vcd"");
        sMimeTypeMap.loadEntry(""application/x-chess-pgn"", ""pgn"");
        sMimeTypeMap.loadEntry(""application/x-cpio"", ""cpio"");
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""deb"");
        sMimeTypeMap.loadEntry(""application/x-debian-package"", ""udeb"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dcr"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dir"");
        sMimeTypeMap.loadEntry(""application/x-director"", ""dxr"");
        sMimeTypeMap.loadEntry(""application/x-dms"", ""dms"");
        sMimeTypeMap.loadEntry(""application/x-doom"", ""wad"");
        sMimeTypeMap.loadEntry(""application/x-dvi"", ""dvi"");
        sMimeTypeMap.loadEntry(""application/x-flac"", ""flac"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfa"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pfb"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""gsf"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf"");
        sMimeTypeMap.loadEntry(""application/x-font"", ""pcf.Z"");
        sMimeTypeMap.loadEntry(""application/x-freemind"", ""mm"");
        sMimeTypeMap.loadEntry(""application/x-futuresplash"", ""spl"");
        sMimeTypeMap.loadEntry(""application/x-gnumeric"", ""gnumeric"");
        sMimeTypeMap.loadEntry(""application/x-go-sgf"", ""sgf"");
        sMimeTypeMap.loadEntry(""application/x-graphing-calculator"", ""gcf"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""gtar"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""tgz"");
        sMimeTypeMap.loadEntry(""application/x-gtar"", ""taz"");
        sMimeTypeMap.loadEntry(""application/x-hdf"", ""hdf"");
        sMimeTypeMap.loadEntry(""application/x-ica"", ""ica"");
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""ins"");
        sMimeTypeMap.loadEntry(""application/x-internet-signup"", ""isp"");
        sMimeTypeMap.loadEntry(""application/x-iphone"", ""iii"");
        sMimeTypeMap.loadEntry(""application/x-iso9660-image"", ""iso"");
        sMimeTypeMap.loadEntry(""application/x-jmol"", ""jmz"");
        sMimeTypeMap.loadEntry(""application/x-kchart"", ""chrt"");
        sMimeTypeMap.loadEntry(""application/x-killustrator"", ""kil"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skp"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skd"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skt"");
        sMimeTypeMap.loadEntry(""application/x-koan"", ""skm"");
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpr"");
        sMimeTypeMap.loadEntry(""application/x-kpresenter"", ""kpt"");
        sMimeTypeMap.loadEntry(""application/x-kspread"", ""ksp"");
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwd"");
        sMimeTypeMap.loadEntry(""application/x-kword"", ""kwt"");
        sMimeTypeMap.loadEntry(""application/x-latex"", ""latex"");
        sMimeTypeMap.loadEntry(""application/x-lha"", ""lha"");
        sMimeTypeMap.loadEntry(""application/x-lzh"", ""lzh"");
        sMimeTypeMap.loadEntry(""application/x-lzx"", ""lzx"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frm"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""maker"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""frame"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fb"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""book"");
        sMimeTypeMap.loadEntry(""application/x-maker"", ""fbdoc"");
        sMimeTypeMap.loadEntry(""application/x-mif"", ""mif"");
        sMimeTypeMap.loadEntry(""application/x-ms-wmd"", ""wmd"");
        sMimeTypeMap.loadEntry(""application/x-ms-wmz"", ""wmz"");
        sMimeTypeMap.loadEntry(""application/x-msi"", ""msi"");
        sMimeTypeMap.loadEntry(""application/x-ns-proxy-autoconfig"", ""pac"");
        sMimeTypeMap.loadEntry(""application/x-nwc"", ""nwc"");
        sMimeTypeMap.loadEntry(""application/x-object"", ""o"");
        sMimeTypeMap.loadEntry(""application/x-oz-application"", ""oza"");
        sMimeTypeMap.loadEntry(""application/x-pkcs12"", ""p12"");
        sMimeTypeMap.loadEntry(""application/x-pkcs7-certreqresp"", ""p7r"");
        sMimeTypeMap.loadEntry(""application/x-pkcs7-crl"", ""crl"");
        sMimeTypeMap.loadEntry(""application/x-quicktimeplayer"", ""qtl"");
        sMimeTypeMap.loadEntry(""application/x-shar"", ""shar"");
        sMimeTypeMap.loadEntry(""application/x-stuffit"", ""sit"");
        sMimeTypeMap.loadEntry(""application/x-sv4cpio"", ""sv4cpio"");
        sMimeTypeMap.loadEntry(""application/x-sv4crc"", ""sv4crc"");
        sMimeTypeMap.loadEntry(""application/x-tar"", ""tar"");
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texinfo"");
        sMimeTypeMap.loadEntry(""application/x-texinfo"", ""texi"");
        sMimeTypeMap.loadEntry(""application/x-troff"", ""t"");
        sMimeTypeMap.loadEntry(""application/x-troff"", ""roff"");
        sMimeTypeMap.loadEntry(""application/x-troff-man"", ""man"");
        sMimeTypeMap.loadEntry(""application/x-ustar"", ""ustar"");
        sMimeTypeMap.loadEntry(""application/x-wais-source"", ""src"");
        sMimeTypeMap.loadEntry(""application/x-wingz"", ""wz"");
        sMimeTypeMap.loadEntry(""application/x-webarchive"", ""webarchive"");
        sMimeTypeMap.loadEntry(""application/x-x509-ca-cert"", ""crt"");
        sMimeTypeMap.loadEntry(""application/x-x509-user-cert"", ""crt"");
        sMimeTypeMap.loadEntry(""application/x-xcf"", ""xcf"");
        sMimeTypeMap.loadEntry(""application/x-xfig"", ""fig"");
        sMimeTypeMap.loadEntry(""application/xhtml+xml"", ""xhtml"");
        sMimeTypeMap.loadEntry(""audio/basic"", ""snd"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""mid"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""midi"");
        sMimeTypeMap.loadEntry(""audio/midi"", ""kar"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpga"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mpega"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp2"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""mp3"");
        sMimeTypeMap.loadEntry(""audio/mpeg"", ""m4a"");
        sMimeTypeMap.loadEntry(""audio/mpegurl"", ""m3u"");
        sMimeTypeMap.loadEntry(""audio/prs.sid"", ""sid"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aif"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aiff"");
        sMimeTypeMap.loadEntry(""audio/x-aiff"", ""aifc"");
        sMimeTypeMap.loadEntry(""audio/x-gsm"", ""gsm"");
        sMimeTypeMap.loadEntry(""audio/x-mpegurl"", ""m3u"");
        sMimeTypeMap.loadEntry(""audio/x-ms-wma"", ""wma"");
        sMimeTypeMap.loadEntry(""audio/x-ms-wax"", ""wax"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ra"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""rm"");
        sMimeTypeMap.loadEntry(""audio/x-pn-realaudio"", ""ram"");
        sMimeTypeMap.loadEntry(""audio/x-realaudio"", ""ra"");
        sMimeTypeMap.loadEntry(""audio/x-scpls"", ""pls"");
        sMimeTypeMap.loadEntry(""audio/x-sd2"", ""sd2"");
        sMimeTypeMap.loadEntry(""audio/x-wav"", ""wav"");
        sMimeTypeMap.loadEntry(""image/bmp"", ""bmp"");
        sMimeTypeMap.loadEntry(""image/gif"", ""gif"");
        sMimeTypeMap.loadEntry(""image/ico"", ""cur"");
        sMimeTypeMap.loadEntry(""image/ico"", ""ico"");
        sMimeTypeMap.loadEntry(""image/ief"", ""ief"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpeg"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpg"");
        sMimeTypeMap.loadEntry(""image/jpeg"", ""jpe"");
        sMimeTypeMap.loadEntry(""image/pcx"", ""pcx"");
        sMimeTypeMap.loadEntry(""image/png"", ""png"");
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svg"");
        sMimeTypeMap.loadEntry(""image/svg+xml"", ""svgz"");
        sMimeTypeMap.loadEntry(""image/tiff"", ""tiff"");
        sMimeTypeMap.loadEntry(""image/tiff"", ""tif"");
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djvu"");
        sMimeTypeMap.loadEntry(""image/vnd.djvu"", ""djv"");
        sMimeTypeMap.loadEntry(""image/vnd.wap.wbmp"", ""wbmp"");
        sMimeTypeMap.loadEntry(""image/x-cmu-raster"", ""ras"");
        sMimeTypeMap.loadEntry(""image/x-coreldraw"", ""cdr"");
        sMimeTypeMap.loadEntry(""image/x-coreldrawpattern"", ""pat"");
        sMimeTypeMap.loadEntry(""image/x-coreldrawtemplate"", ""cdt"");
        sMimeTypeMap.loadEntry(""image/x-corelphotopaint"", ""cpt"");
        sMimeTypeMap.loadEntry(""image/x-icon"", ""ico"");
        sMimeTypeMap.loadEntry(""image/x-jg"", ""art"");
        sMimeTypeMap.loadEntry(""image/x-jng"", ""jng"");
        sMimeTypeMap.loadEntry(""image/x-ms-bmp"", ""bmp"");
        sMimeTypeMap.loadEntry(""image/x-photoshop"", ""psd"");
        sMimeTypeMap.loadEntry(""image/x-portable-anymap"", ""pnm"");
        sMimeTypeMap.loadEntry(""image/x-portable-bitmap"", ""pbm"");
        sMimeTypeMap.loadEntry(""image/x-portable-graymap"", ""pgm"");
        sMimeTypeMap.loadEntry(""image/x-portable-pixmap"", ""ppm"");
        sMimeTypeMap.loadEntry(""image/x-rgb"", ""rgb"");
        sMimeTypeMap.loadEntry(""image/x-xbitmap"", ""xbm"");
        sMimeTypeMap.loadEntry(""image/x-xpixmap"", ""xpm"");
        sMimeTypeMap.loadEntry(""image/x-xwindowdump"", ""xwd"");
        sMimeTypeMap.loadEntry(""model/iges"", ""igs"");
        sMimeTypeMap.loadEntry(""model/iges"", ""iges"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""msh"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""mesh"");
        sMimeTypeMap.loadEntry(""model/mesh"", ""silo"");
        sMimeTypeMap.loadEntry(""text/calendar"", ""ics"");
        sMimeTypeMap.loadEntry(""text/calendar"", ""icz"");
        sMimeTypeMap.loadEntry(""text/comma-separated-values"", ""csv"");
        sMimeTypeMap.loadEntry(""text/css"", ""css"");
        sMimeTypeMap.loadEntry(""text/h323"", ""323"");
        sMimeTypeMap.loadEntry(""text/iuls"", ""uls"");
        sMimeTypeMap.loadEntry(""text/mathml"", ""mml"");
        // add it first so it will be the default for ExtensionFromMimeType
        sMimeTypeMap.loadEntry(""text/plain"", ""txt"");
        sMimeTypeMap.loadEntry(""text/plain"", ""asc"");
        sMimeTypeMap.loadEntry(""text/plain"", ""text"");
        sMimeTypeMap.loadEntry(""text/plain"", ""diff"");
        // reserve ""pot"" for vnd.ms-powerpoint
        sMimeTypeMap.loadEntry(""text/plain"", ""po"");
        sMimeTypeMap.loadEntry(""text/richtext"", ""rtx"");
        sMimeTypeMap.loadEntry(""text/rtf"", ""rtf"");
        sMimeTypeMap.loadEntry(""text/texmacs"", ""ts"");
        sMimeTypeMap.loadEntry(""text/text"", ""phps"");
        sMimeTypeMap.loadEntry(""text/tab-separated-values"", ""tsv"");
        sMimeTypeMap.loadEntry(""text/xml"", ""xml"");
        sMimeTypeMap.loadEntry(""text/x-bibtex"", ""bib"");
        sMimeTypeMap.loadEntry(""text/x-boo"", ""boo"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""h++"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hpp"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hxx"");
        sMimeTypeMap.loadEntry(""text/x-c++hdr"", ""hh"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""c++"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cpp"");
        sMimeTypeMap.loadEntry(""text/x-c++src"", ""cxx"");
        sMimeTypeMap.loadEntry(""text/x-chdr"", ""h"");
        sMimeTypeMap.loadEntry(""text/x-component"", ""htc"");
        sMimeTypeMap.loadEntry(""text/x-csh"", ""csh"");
        sMimeTypeMap.loadEntry(""text/x-csrc"", ""c"");
        sMimeTypeMap.loadEntry(""text/x-dsrc"", ""d"");
        sMimeTypeMap.loadEntry(""text/x-haskell"", ""hs"");
        sMimeTypeMap.loadEntry(""text/x-java"", ""java"");
        sMimeTypeMap.loadEntry(""text/x-literate-haskell"", ""lhs"");
        sMimeTypeMap.loadEntry(""text/x-moc"", ""moc"");
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""p"");
        sMimeTypeMap.loadEntry(""text/x-pascal"", ""pas"");
        sMimeTypeMap.loadEntry(""text/x-pcs-gcd"", ""gcd"");
        sMimeTypeMap.loadEntry(""text/x-setext"", ""etx"");
        sMimeTypeMap.loadEntry(""text/x-tcl"", ""tcl"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""tex"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""ltx"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""sty"");
        sMimeTypeMap.loadEntry(""text/x-tex"", ""cls"");
        sMimeTypeMap.loadEntry(""text/x-vcalendar"", ""vcs"");
        sMimeTypeMap.loadEntry(""text/x-vcard"", ""vcf"");
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3gp"");
        sMimeTypeMap.loadEntry(""video/3gpp"", ""3g2"");
        sMimeTypeMap.loadEntry(""video/dl"", ""dl"");
        sMimeTypeMap.loadEntry(""video/dv"", ""dif"");
        sMimeTypeMap.loadEntry(""video/dv"", ""dv"");
        sMimeTypeMap.loadEntry(""video/fli"", ""fli"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpeg"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpg"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""mpe"");
        sMimeTypeMap.loadEntry(""video/mp4"", ""mp4"");
        sMimeTypeMap.loadEntry(""video/mpeg"", ""VOB"");
        sMimeTypeMap.loadEntry(""video/quicktime"", ""qt"");
        sMimeTypeMap.loadEntry(""video/quicktime"", ""mov"");
        sMimeTypeMap.loadEntry(""video/vnd.mpegurl"", ""mxu"");
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsf"");
        sMimeTypeMap.loadEntry(""video/x-la-asf"", ""lsx"");
        sMimeTypeMap.loadEntry(""video/x-mng"", ""mng"");
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asf"");
        sMimeTypeMap.loadEntry(""video/x-ms-asf"", ""asx"");
        sMimeTypeMap.loadEntry(""video/x-ms-wm"", ""wm"");
        sMimeTypeMap.loadEntry(""video/x-ms-wmv"", ""wmv"");
        sMimeTypeMap.loadEntry(""video/x-ms-wmx"", ""wmx"");
        sMimeTypeMap.loadEntry(""video/x-ms-wvx"", ""wvx"");
        sMimeTypeMap.loadEntry(""video/x-msvideo"", ""avi"");
        sMimeTypeMap.loadEntry(""video/x-sgi-movie"", ""movie"");
        sMimeTypeMap.loadEntry(""x-conference/x-cooltalk"", ""ice"");
        sMimeTypeMap.loadEntry(""x-epoc/x-sisx-app"", ""sisx"");
    }
    return sMimeTypeMap;
}",1,"/**
 * @return The singleton instance of the MIME-type map.
 */
","/**
 * Get the singleton instance of MimeTypeMap.
 * @return The singleton instance of the MIME-type map.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
153,<android.content.res.Configuration: int diff(Configuration)>,4,5,<android.content.res.Configuration: int diff(Configuration)>,<android.content.res.Configuration: int diff(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    return changed;
}",1,"/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}.
 */
","/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,An 'if' condition block has been added in the late implementation version so it is classified under the 'other statement changed' category.,"Because of the addition of the new condition block, the value of the 'changed' variable that is being returned by the method could potentially be different between the two versions leading to a compatibility issue due to potential different return values or types."
154,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",4,5,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>","<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",0,"{
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadData(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    HashMap arg = new HashMap();
    arg.put(""baseUrl"", baseUrl);
    arg.put(""data"", data);
    arg.put(""mimeType"", mimeType);
    arg.put(""encoding"", encoding);
    arg.put(""failUrl"", failUrl);
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearTextEntry();
}","{
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadData(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mFailUrl = failUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearTextEntry();
}",1,"/**
 * Load the given data into the WebView, use the provided URL as the base
 * URL for the content. The base URL is the URL that represents the page
 * that is loaded through this interface. As such, it is used for the
 * history entry and to resolve any relative URLs. The failUrl is used if
 * browser fails to load the data provided. If it is empty or null, and the
 * load fails, then no history entry is created.
 * <p>
 * Note for post 1.0. Due to the change in the WebKit, the access to asset
 * files through ""file:///android_asset/"" for the sub resources is more
 * restricted. If you provide null or empty string as baseUrl, you won't be
 * able to access asset files. If the baseUrl is anything other than
 * http(s)/ftp(s)/about/javascript as scheme, you can access asset files for
 * sub resources.
 *
 * @param baseUrl Url to resolve relative paths with, if null defaults to
 * ""about:blank""
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data. i.e. text/html. If null,
 * defaults to ""text/html""
 * @param encoding The encoding of the data. i.e. utf-8, us-ascii
 * @param failUrl URL to use if the content fails to load or null.
 */
","/**
 * Load the given data into the WebView, use the provided URL as the base
 * URL for the content. The base URL is the URL that represents the page
 * that is loaded through this interface. As such, it is used for the
 * history entry and to resolve any relative URLs. The failUrl is used if
 * browser fails to load the data provided. If it is empty or null, and the
 * load fails, then no history entry is created.
 * <p>
 * Note for post 1.0. Due to the change in the WebKit, the access to asset
 * files through ""file:///android_asset/"" for the sub resources is more
 * restricted. If you provide null or empty string as baseUrl, you won't be
 * able to access asset files. If the baseUrl is anything other than
 * http(s)/ftp(s)/about/javascript as scheme, you can access asset files for
 * sub resources.
 *
 * @param baseUrl Url to resolve relative paths with, if null defaults to
 * ""about:blank""
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data. i.e. text/html. If null,
 * defaults to ""text/html""
 * @param encoding The encoding of the data. i.e. utf-8, us-ascii
 * @param failUrl URL to use if the content fails to load or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is from using the standard `HashMap` to using the `WebViewCore.BaseUrlData` to hold the data for `sendMessage()`. Both of them are used to store the same set of data for argument 'arg'. Thus, there are both other statement changes (HashMap replaced by WebViewCore.BaseUrlData) and dependent API changes (method signature has been changed), the change type is 4,5.","Although there are changes in the dependent API and other statement, it will not influence the behavior of the API itself, as the input and output of the method remain unchanged. Therefore, it doesn't result in a Compatibility Issue, and the CI type is 0."
155,<android.webkit.WebView.ExtendedZoomControls: boolean hasFocus()>,4,5,<android.webkit.WebView.ExtendedZoomControls: boolean hasFocus()>,<android.webkit.WebView.ExtendedZoomControls: boolean hasFocus()>,0,"{
    return mZoomControls.hasFocus() || mZoomMagnify.hasFocus();
}","{
    return mPlusMinusZoomControls.hasFocus();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method invoked by the return statement has changed from mZoomControls.hasFocus() || mZoomMagnify.hasFocus() to mPlusMinusZoomControls.hasFocus(), so the code change type is 1,5.","The change of the return statement will make the API potentially return different boolean values for the same input, so the CI type is 1."
156,<android.widget.ScrollView: boolean arrowScroll(int)>,4,5,<android.widget.ScrollView: boolean arrowScroll(int)>,<android.widget.ScrollView: boolean arrowScroll(int)>,0,"{
    View currentFocused = findFocus();
    if (currentFocused == this)
        currentFocused = null;
    View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
    final int maxJump = getMaxScrollAmount();
    if (nextFocused != null && isWithinDeltaOfScreen(nextFocused, maxJump)) {
        nextFocused.getDrawingRect(mTempRect);
        offsetDescendantRectToMyCoords(nextFocused, mTempRect);
        int scrollDelta = computeScrollDeltaToGetChildRectOnScreen(mTempRect);
        doScrollY(scrollDelta);
        nextFocused.requestFocus(direction);
    } else {
        // no new focus
        int scrollDelta = maxJump;
        if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
            scrollDelta = getScrollY();
        } else if (direction == View.FOCUS_DOWN) {
            if (getChildCount() > 0) {
                int daBottom = getChildAt(0).getBottom();
                int screenBottom = getScrollY() + getHeight();
                if (daBottom - screenBottom < maxJump) {
                    scrollDelta = daBottom - screenBottom;
                }
            }
        }
        if (scrollDelta == 0) {
            return false;
        }
        doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
    }
    if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
        // previously focused item still has focus and is off screen, give
        // it up (take it back to ourselves)
        // (also, need to temporarily force FOCUS_BEFORE_DESCENDANTS so we are
        // sure to
        // get it)
        // save
        final int descendantFocusability = getDescendantFocusability();
        setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
        requestFocus();
        // restore
        setDescendantFocusability(descendantFocusability);
    }
    return true;
}","{
    View currentFocused = findFocus();
    if (currentFocused == this)
        currentFocused = null;
    View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
    final int maxJump = getMaxScrollAmount();
    if (nextFocused != null && isWithinDeltaOfScreen(nextFocused, maxJump, getHeight())) {
        nextFocused.getDrawingRect(mTempRect);
        offsetDescendantRectToMyCoords(nextFocused, mTempRect);
        int scrollDelta = computeScrollDeltaToGetChildRectOnScreen(mTempRect);
        doScrollY(scrollDelta);
        nextFocused.requestFocus(direction);
    } else {
        // no new focus
        int scrollDelta = maxJump;
        if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
            scrollDelta = getScrollY();
        } else if (direction == View.FOCUS_DOWN) {
            if (getChildCount() > 0) {
                int daBottom = getChildAt(0).getBottom();
                int screenBottom = getScrollY() + getHeight();
                if (daBottom - screenBottom < maxJump) {
                    scrollDelta = daBottom - screenBottom;
                }
            }
        }
        if (scrollDelta == 0) {
            return false;
        }
        doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
    }
    if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
        // previously focused item still has focus and is off screen, give
        // it up (take it back to ourselves)
        // (also, need to temporarily force FOCUS_BEFORE_DESCENDANTS so we are
        // sure to
        // get it)
        // save
        final int descendantFocusability = getDescendantFocusability();
        setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
        requestFocus();
        // restore
        setDescendantFocusability(descendantFocusability);
    }
    return true;
}",1,"/**
 * Handle scrolling in response to an up or down arrow click.
 *
 * @param direction The direction corresponding to the arrow key that was
 * pressed
 * @return True if we consumed the event, false otherwise
 */
","/**
 * Handle scrolling in response to an up or down arrow click.
 *
 * @param direction The direction corresponding to the arrow key that was
 * pressed
 * @return True if we consumed the event, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",2,"The call to the method `isWithinDeltaOfScreen()` in the condition of the 'if' statement has changed. The number and type of parameters it takes have changed - from two in the early version (`nextFocused`, `maxJump`) to three in the late version (`nextFocused`, `maxJump`, `getHeight()`). This falls under the categories of Control Dependency Change (3) and Dependent API Change (5).","The change in the parameters of the `isWithinDeltaOfScreen()` method could potentially lead to a different boolean output, which can alter the control flow and the behavior of the code. As a result, the exception handling could be different, so the CI type is 2."
157,<android.content.BroadcastReceiver: void checkSynchronousHint()>,4,5,<android.content.BroadcastReceiver: void checkSynchronousHint()>,<android.content.BroadcastReceiver: void checkSynchronousHint()>,0,"{
    if (mOrderedHint) {
        return;
    }
    RuntimeException e = new RuntimeException(""BroadcastReceiver trying to return result during a non-ordered broadcast"");
    e.fillInStackTrace();
    Log.e(""BroadcastReceiver"", e.getMessage(), e);
}","{
    // them later when the real broadcast happens again.
    if (mOrderedHint || mInitialStickyHint) {
        return;
    }
    RuntimeException e = new RuntimeException(""BroadcastReceiver trying to return result during a non-ordered broadcast"");
    e.fillInStackTrace();
    Log.e(""BroadcastReceiver"", e.getMessage(), e);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency statement ""if(mOrderedHint)"" was changed to ""if(mOrderedHint || mInitialStickyHint)"", which indicates a control dependency changed.","Given that the control dependency change alters when the function will return and when it will continue executing, it potentially changes the behavior of the API, thereby causing a compatibility issue related to a potential change in return type or value. Hence, the type of CI is 1."
158,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,4,5,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
        return false;
    }
    if (LOGV_ENABLED) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action = ev.getAction();
    float x = ev.getX();
    float y = ev.getY();
    long eventTime = ev.getEventTime();
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeight() - 1) {
        y = getViewHeight() - 1;
    }
    // pass the touch events from UI thread to WebCore thread
    if (mForwardTouchEvents && mTouchMode != SCROLL_ZOOM_OUT && mTouchMode != SCROLL_ZOOM_ANIMATION_IN && mTouchMode != SCROLL_ZOOM_ANIMATION_OUT && (action != MotionEvent.ACTION_MOVE || eventTime - mLastSentTouchTime > TOUCH_SENT_INTERVAL)) {
        WebViewCore.TouchEventData ted = new WebViewCore.TouchEventData();
        ted.mAction = action;
        ted.mX = viewToContent((int) x + mScrollX);
        ted.mY = viewToContent((int) y + mScrollY);
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
        mLastSentTouchTime = eventTime;
    }
    int deltaX = (int) (mLastTouchX - x);
    int deltaY = (int) (mLastTouchY - y);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                if (mTouchMode == SCROLL_ZOOM_ANIMATION_IN || mTouchMode == SCROLL_ZOOM_ANIMATION_OUT) {
                    // no interaction while animation is in progress
                    break;
                } else if (mTouchMode == SCROLL_ZOOM_OUT) {
                    mLastScrollX = mZoomScrollX;
                    mLastScrollY = mZoomScrollY;
                // If two taps are close, ignore the first tap
                } else if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_UPDATE);
                } else if (mShiftIsPressed) {
                    mSelectX = mScrollX + (int) x;
                    mSelectY = mScrollY + (int) y;
                    mTouchMode = TOUCH_SELECT_MODE;
                    if (LOGV_ENABLED) {
                        Log.v(LOGTAG, ""select="" + mSelectX + "","" + mSelectY);
                    }
                    nativeMoveSelection(viewToContent(mSelectX), viewToContent(mSelectY), false);
                    mTouchSelection = mExtendSelection = true;
                } else {
                    mTouchMode = TOUCH_INIT_MODE;
                    mPreventDrag = mForwardTouchEvents;
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EVENT_LOG_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE) {
                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(SWITCH_TO_SHORTPRESS), TAP_TIMEOUT);
                }
                // Remember where the motion event started
                mLastTouchX = x;
                mLastTouchY = y;
                mLastTouchTime = eventTime;
                mVelocityTracker = VelocityTracker.obtain();
                mSnapScrollMode = SNAP_NONE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mTouchMode == TOUCH_DONE_MODE || mTouchMode == SCROLL_ZOOM_ANIMATION_IN || mTouchMode == SCROLL_ZOOM_ANIMATION_OUT) {
                    // no dragging during scroll zoom animation
                    break;
                }
                if (mTouchMode == SCROLL_ZOOM_OUT) {
                    // while fully zoomed out, move the virtual window
                    moveZoomScrollWindow(x, y);
                    break;
                }
                mVelocityTracker.addMovement(ev);
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (mTouchMode == TOUCH_SELECT_MODE) {
                        mSelectX = mScrollX + (int) x;
                        mSelectY = mScrollY + (int) y;
                        if (LOGV_ENABLED) {
                            Log.v(LOGTAG, ""xtend="" + mSelectX + "","" + mSelectY);
                        }
                        nativeMoveSelection(viewToContent(mSelectX), viewToContent(mSelectY), true);
                        invalidate();
                        break;
                    }
                    if (mPreventDrag || (deltaX * deltaX + deltaY * deltaY) < mTouchSlopSquare) {
                        break;
                    }
                    if (mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    } else if (mTouchMode == TOUCH_INIT_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    }
                    // if it starts nearly horizontal or vertical, enforce it
                    int ax = Math.abs(deltaX);
                    int ay = Math.abs(deltaY);
                    if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                        mSnapScrollMode = SNAP_X;
                        mSnapPositive = deltaX > 0;
                    } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                        mSnapScrollMode = SNAP_Y;
                        mSnapPositive = deltaY > 0;
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    WebViewCore.pauseUpdate(mWebViewCore);
                    int contentX = viewToContent((int) x + mScrollX);
                    int contentY = viewToContent((int) y + mScrollY);
                    if (inEditingMode()) {
                        mTextEntry.updateCachedTextfield();
                    }
                    nativeClearFocus(contentX, contentY);
                    // remove the zoom anchor if there is any
                    if (mZoomScale != 0) {
                        mWebViewCore.sendMessage(EventHub.SET_SNAP_ANCHOR, 0, 0);
                    }
                    WebSettings settings = getSettings();
                    if (settings.supportZoom() && settings.getBuiltInZoomControls() && !mZoomButtonsController.isVisible() && (canZoomScrollOut() || mMinZoomScale < mMaxZoomScale)) {
                        mZoomButtonsController.setVisible(true);
                    }
                }
                // do pan
                int newScrollX = pinLocX(mScrollX + deltaX);
                deltaX = newScrollX - mScrollX;
                int newScrollY = pinLocY(mScrollY + deltaY);
                deltaY = newScrollY - mScrollY;
                boolean done = false;
                if (deltaX == 0 && deltaY == 0) {
                    done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ((mSnapPositive && deltaX < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaX > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_X_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ay > MAX_SLOPE_FOR_DIAG * ax) && ((mSnapPositive && deltaY < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaY > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_Y_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_X_LOCK) {
                        scrollBy(deltaX, 0);
                        mLastTouchX = x;
                    } else if (mSnapScrollMode == SNAP_Y || mSnapScrollMode == SNAP_Y_LOCK) {
                        scrollBy(0, deltaY);
                        mLastTouchY = y;
                    } else {
                        scrollBy(deltaX, deltaY);
                        mLastTouchX = x;
                        mLastTouchY = y;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                if (!getSettings().getBuiltInZoomControls()) {
                    boolean showPlusMinus = mMinZoomScale < mMaxZoomScale;
                    boolean showMagnify = canZoomScrollOut();
                    if (mZoomControls != null && (showPlusMinus || showMagnify)) {
                        if (mZoomControls.getVisibility() == View.VISIBLE) {
                            mPrivateHandler.removeCallbacks(mZoomControlRunnable);
                        } else {
                            mZoomControls.show(showPlusMinus, showMagnify);
                        }
                        mPrivateHandler.postDelayed(mZoomControlRunnable, ZOOM_CONTROLS_TIMEOUT);
                    }
                }
                if (done) {
                    // view space
                    return false;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        mTouchMode = TOUCH_DONE_MODE;
                        doShortPress();
                        break;
                    case TOUCH_SELECT_MODE:
                        commitCopy();
                        mTouchSelection = false;
                        break;
                    case SCROLL_ZOOM_ANIMATION_IN:
                    case SCROLL_ZOOM_ANIMATION_OUT:
                        // no action during scroll animation
                        break;
                    case SCROLL_ZOOM_OUT:
                        if (LOGV_ENABLED) {
                            Log.v(LOGTAG, ""ACTION_UP SCROLL_ZOOM_OUT"" + "" eventTime - mLastTouchTime="" + (eventTime - mLastTouchTime));
                        }
                        // for now, always zoom back when the drag completes
                        if (true || eventTime - mLastTouchTime < TAP_TIMEOUT) {
                            // but if we tap, zoom in where we tap
                            if (eventTime - mLastTouchTime < TAP_TIMEOUT) {
                                zoomScrollTap(x, y);
                            }
                            // start zooming in back to the original view
                            setZoomScrollIn();
                            mTouchMode = SCROLL_ZOOM_ANIMATION_IN;
                            invalidate();
                        }
                        break;
                    case TOUCH_DRAG_MODE:
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            mVelocityTracker.addMovement(ev);
                            doFling();
                            break;
                        }
                        WebViewCore.resumeUpdate(mWebViewCore);
                        break;
                    case TOUCH_DRAG_START_MODE:
                    case TOUCH_DONE_MODE:
                        // do nothing
                        break;
                }
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mTouchMode == SCROLL_ZOOM_OUT || mTouchMode == SCROLL_ZOOM_ANIMATION_IN) {
                    scrollTo(mZoomScrollX, mZoomScrollY);
                } else if (mTouchMode == TOUCH_DRAG_MODE) {
                    WebViewCore.resumeUpdate(mWebViewCore);
                }
                mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                mTouchMode = TOUCH_DONE_MODE;
                int contentX = viewToContent((int) mLastTouchX + mScrollX);
                int contentY = viewToContent((int) mLastTouchY + mScrollY);
                if (inEditingMode()) {
                    mTextEntry.updateCachedTextfield();
                }
                nativeClearFocus(contentX, contentY);
                break;
            }
    }
    return true;
}","{
    if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action = ev.getAction();
    float x = ev.getX();
    float y = ev.getY();
    long eventTime = ev.getEventTime();
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeightWithTitle() - 1) {
        y = getViewHeightWithTitle() - 1;
    }
    // pass the touch events from UI thread to WebCore thread
    if (mForwardTouchEvents && (action != MotionEvent.ACTION_MOVE || eventTime - mLastSentTouchTime > TOUCH_SENT_INTERVAL)) {
        WebViewCore.TouchEventData ted = new WebViewCore.TouchEventData();
        ted.mAction = action;
        ted.mX = viewToContentX((int) x + mScrollX);
        ted.mY = viewToContentY((int) y + mScrollY);
        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
        mLastSentTouchTime = eventTime;
    }
    int deltaX = (int) (mLastTouchX - x);
    int deltaY = (int) (mLastTouchY - y);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                mPreventDrag = PREVENT_DRAG_NO;
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_UPDATE);
                } else if (mShiftIsPressed) {
                    mSelectX = mScrollX + (int) x;
                    mSelectY = mScrollY + (int) y;
                    mTouchMode = TOUCH_SELECT_MODE;
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, ""select="" + mSelectX + "","" + mSelectY);
                    }
                    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), false);
                    mTouchSelection = mExtendSelection = true;
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        // commit the short press action for the previous tap
                        doShortPress();
                    // continue, mTouchMode should be still TOUCH_INIT_MODE
                    }
                } else {
                    mTouchMode = TOUCH_INIT_MODE;
                    mPreventDrag = mForwardTouchEvents ? PREVENT_DRAG_MAYBE_YES : PREVENT_DRAG_NO;
                    mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EVENT_LOG_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(SWITCH_TO_SHORTPRESS), TAP_TIMEOUT);
                }
                // Remember where the motion event started
                mLastTouchX = x;
                mLastTouchY = y;
                mLastTouchTime = eventTime;
                mVelocityTracker = VelocityTracker.obtain();
                mSnapScrollMode = SNAP_NONE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                if (mTouchMode == TOUCH_DONE_MODE) {
                    // no dragging during scroll zoom animation
                    break;
                }
                mVelocityTracker.addMovement(ev);
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (mTouchMode == TOUCH_SELECT_MODE) {
                        mSelectX = mScrollX + (int) x;
                        mSelectY = mScrollY + (int) y;
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, ""xtend="" + mSelectX + "","" + mSelectY);
                        }
                        nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), true);
                        invalidate();
                        break;
                    }
                    if ((deltaX * deltaX + deltaY * deltaY) < mTouchSlopSquare) {
                        break;
                    }
                    if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                        // track mLastTouchTime as we may need to do fling at
                        // ACTION_UP
                        mLastTouchTime = eventTime;
                        break;
                    }
                    if (mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    } else if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    }
                    // if it starts nearly horizontal or vertical, enforce it
                    int ax = Math.abs(deltaX);
                    int ay = Math.abs(deltaY);
                    if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                        mSnapScrollMode = SNAP_X;
                        mSnapPositive = deltaX > 0;
                    } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                        mSnapScrollMode = SNAP_Y;
                        mSnapPositive = deltaY > 0;
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    WebViewCore.pauseUpdate(mWebViewCore);
                    if (!mDragFromTextInput) {
                        nativeHideCursor();
                    }
                    WebSettings settings = getSettings();
                    if (settings.supportZoom() && settings.getBuiltInZoomControls() && !mZoomButtonsController.isVisible() && mMinZoomScale < mMaxZoomScale) {
                        mZoomButtonsController.setVisible(true);
                        int count = settings.getDoubleTapToastCount();
                        if (mInZoomOverview && count > 0) {
                            settings.setDoubleTapToastCount(--count);
                            Toast.makeText(mContext, com.android.internal.R.string.double_tap_toast, Toast.LENGTH_LONG).show();
                        }
                    }
                }
                // do pan
                int newScrollX = pinLocX(mScrollX + deltaX);
                deltaX = newScrollX - mScrollX;
                int newScrollY = pinLocY(mScrollY + deltaY);
                deltaY = newScrollY - mScrollY;
                boolean done = false;
                if (deltaX == 0 && deltaY == 0) {
                    done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ((mSnapPositive && deltaX < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaX > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_X_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if ((ax > MAX_SLOPE_FOR_DIAG * ay) && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if ((ay > MAX_SLOPE_FOR_DIAG * ax) && ((mSnapPositive && deltaY < -mMinLockSnapReverseDistance) || (!mSnapPositive && deltaY > mMinLockSnapReverseDistance))) {
                                mSnapScrollMode = SNAP_Y_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_X_LOCK) {
                        if (deltaX == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(deltaX, 0);
                        }
                        mLastTouchX = x;
                    } else if (mSnapScrollMode == SNAP_Y || mSnapScrollMode == SNAP_Y_LOCK) {
                        if (deltaY == 0) {
                            // keep the scrollbar on the screen even there is no
                            // scroll
                            awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                        } else {
                            scrollBy(0, deltaY);
                        }
                        mLastTouchY = y;
                    } else {
                        scrollBy(deltaX, deltaY);
                        mLastTouchX = x;
                        mLastTouchY = y;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                if (!getSettings().getBuiltInZoomControls()) {
                    boolean showPlusMinus = mMinZoomScale < mMaxZoomScale;
                    if (mZoomControls != null && showPlusMinus) {
                        if (mZoomControls.getVisibility() == View.VISIBLE) {
                            mPrivateHandler.removeCallbacks(mZoomControlRunnable);
                        } else {
                            mZoomControls.show(showPlusMinus, false);
                        }
                        mPrivateHandler.postDelayed(mZoomControlRunnable, ZOOM_CONTROLS_TIMEOUT);
                    }
                }
                if (done) {
                    // keep the scrollbar on the screen even there is no scroll
                    awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                    // view space
                    return false;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    case // double tap
                    TOUCH_DOUBLE_TAP_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mTouchMode = TOUCH_DONE_MODE;
                        doDoubleTap();
                        break;
                    case TOUCH_SELECT_MODE:
                        commitCopy();
                        mTouchSelection = false;
                        break;
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if ((deltaX * deltaX + deltaY * deltaY) > mTouchSlopSquare) {
                            Log.w(LOGTAG, ""Miss a drag as we are waiting for"" + "" WebCore's response for touch down."");
                            if (computeHorizontalScrollExtent() < computeHorizontalScrollRange() || computeVerticalScrollExtent() < computeVerticalScrollRange()) {
                                // we will not rewrite drag code here, but we
                                // will try fling if it applies.
                                WebViewCore.pauseUpdate(mWebViewCore);
                            // fall through to TOUCH_DRAG_MODE
                            } else {
                                break;
                            }
                        } else {
                            if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                                // if mPreventDrag is not confirmed, treat it as
                                // no so that it won't block tap or double tap.
                                mPreventDrag = PREVENT_DRAG_NO;
                            }
                            if (mPreventDrag == PREVENT_DRAG_NO) {
                                if (mTouchMode == TOUCH_INIT_MODE) {
                                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(RELEASE_SINGLE_TAP), ViewConfiguration.getDoubleTapTimeout());
                                } else {
                                    mTouchMode = TOUCH_DONE_MODE;
                                    doShortPress();
                                }
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                        // redraw in high-quality, as we're done dragging
                        invalidate();
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            mVelocityTracker.addMovement(ev);
                            doFling();
                            break;
                        }
                        mLastVelocity = 0;
                        WebViewCore.resumeUpdate(mWebViewCore);
                        break;
                    case TOUCH_DRAG_START_MODE:
                    case TOUCH_DONE_MODE:
                        // do nothing
                        break;
                }
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                // mode in the drawing code
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mTouchMode == TOUCH_DRAG_MODE) {
                    WebViewCore.resumeUpdate(mWebViewCore);
                }
                mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                mTouchMode = TOUCH_DONE_MODE;
                nativeHideCursor();
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",1,"Changes include multiple additions and deletions in conditional statements and other operation statements. Therefore, the code change type is 3, 4.","Changes in conditional and operation statements could potentially affect the return value of the method, resulting in different behaviours. Therefore, a compatibility issue of type 1 may arise due to potential differences in return values."
160,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",4,5,"<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>","<android.app.ApplicationErrorReport.CrashInfo: void writeToParcel(Parcel,int)>",0,"{
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeString(stackTrace);
}","{
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
}",1,"/**
 * Save a CrashInfo instance to a parcel.
 */
","/**
 * Save a CrashInfo instance to a parcel.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method has introduced a new line of code to write an integer to the destination Parcel, which is specific to the 'throwLineNumber'. Since it is adding a new operation and doesn't change control flow or exception handling, it is classified as 'Other statement changed'.","Despite the method changes, the added operation is unlikely to introduce a compatibility issue since it only affects the output of the Parcel, while its return type (void) and exception handling remain consistent between versions. Therefore, no compatibility issue is detected."
161,"<android.text.BoringLayout: Metrics isBoring(CharSequence,TextPaint,Metrics)>",4,5,"<android.text.BoringLayout: Metrics isBoring(CharSequence,TextPaint,Metrics)>","<android.text.BoringLayout: Metrics isBoring(CharSequence,TextPaint,Metrics)>",0,"{
    char[] temp = TextUtils.obtain(500);
    int len = text.length();
    boolean boring = true;
    outer: for (int i = 0; i < len; i += 500) {
        int j = i + 500;
        if (j > len)
            j = len;
        TextUtils.getChars(text, i, j, temp, 0);
        int n = j - i;
        for (int a = 0; a < n; a++) {
            char c = temp[a];
            if (c == '\n' || c == '\t' || c >= FIRST_RIGHT_TO_LEFT) {
                boring = false;
                break outer;
            }
        }
    }
    TextUtils.recycle(temp);
    if (boring) {
        Metrics fm = metrics;
        if (fm == null) {
            fm = new Metrics();
        }
        int wid;
        synchronized (sTemp) {
            wid = (int) (FloatMath.ceil(Styled.measureText(paint, sTemp, text, 0, text.length(), fm)));
        }
        fm.width = wid;
        return fm;
    } else {
        return null;
    }
}","{
    char[] temp = TextUtils.obtain(500);
    int len = text.length();
    boolean boring = true;
    outer: for (int i = 0; i < len; i += 500) {
        int j = i + 500;
        if (j > len)
            j = len;
        TextUtils.getChars(text, i, j, temp, 0);
        int n = j - i;
        for (int a = 0; a < n; a++) {
            char c = temp[a];
            if (c == '\n' || c == '\t' || c >= FIRST_RIGHT_TO_LEFT) {
                boring = false;
                break outer;
            }
        }
    }
    TextUtils.recycle(temp);
    if (boring && text instanceof Spanned) {
        Spanned sp = (Spanned) text;
        Object[] styles = sp.getSpans(0, text.length(), ParagraphStyle.class);
        if (styles.length > 0) {
            boring = false;
        }
    }
    if (boring) {
        Metrics fm = metrics;
        if (fm == null) {
            fm = new Metrics();
        }
        int wid;
        synchronized (sTemp) {
            wid = (int) (FloatMath.ceil(Styled.measureText(paint, sTemp, text, 0, text.length(), fm)));
        }
        fm.width = wid;
        return fm;
    } else {
        return null;
    }
}",1,"/**
 * Returns null if not boring; the width, ascent, and descent in the
 * provided Metrics object (or a new one if the provided one was null)
 * if boring.
 */
","/**
 * Returns null if not boring; the width, ascent, and descent in the
 * provided Metrics object (or a new one if the provided one was null)
 * if boring.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The condition statement 'if (boring && text instanceof Spanned)' has been added to check whether the input text is a Spanned or not. So the code change type is 3.,"The newly introduced condition statement modifies the control flow - it checks whether the given text is a kind of 'Spanned'. If so, it changes the value of 'boring' variable which potentially leads to a different return statement execution ('return fm;' or 'return null;'). Therefore, the CI type is 1."
162,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,4,5,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,<android.widget.TabHost.LabelIndicatorStrategy: View createIndicatorView()>,0,"{
    LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(R.layout.tab_indicator, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    return tabIndicator;
}","{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(R.layout.tab_indicator, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getResources().getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency changes on the 'if' statement and some property settings on the 'tabIndicator' are added in the late version, thus the changes belong to types 3 and 4.","As the text color and background color of the 'tabIndicator' (which is the return object) could be different due to the newly added 'if' statement, this change potentially makes the API return a different object. Thus, the CI type is 1."
163,<android.hardware.Camera.Parameters: void setPreviewFormat(int)>,4,5,<android.hardware.Camera.Parameters: void setPreviewFormat(int)>,<android.hardware.Camera.Parameters: void setPreviewFormat(int)>,0,"{
    String s = cameraFormatForPixelFormat(pixel_format);
    if (s == null) {
        throw new IllegalArgumentException();
    }
    set(""preview-format"", s);
}","{
    String s = cameraFormatForPixelFormat(pixel_format);
    if (s == null) {
        throw new IllegalArgumentException(""Invalid pixel_format="" + pixel_format);
    }
    set(KEY_PREVIEW_FORMAT, s);
}",1,"/**
 * Sets the image format for preview pictures.
 * <p>If the image format is not set with this method, then the
 * preview format will default to
 * {@link android.graphics.PixelFormat#YCbCr_420_SP}, which
 * uses the NV21 encoding format.</p>
 *
 * @param pixel_format the desired preview picture format, defined
 * by one of the {@link android.graphics.PixelFormat} constants.
 * (E.g., <var>PixelFormat.YCbCr_420_SP</var> (default),
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
","/**
 * Sets the image format for preview pictures.
 * <p>If this is never called, the default format will be
 * {@link android.graphics.PixelFormat#YCbCr_420_SP}, which
 * uses the NV21 encoding format.</p>
 *
 * @param pixel_format the desired preview picture format, defined
 * by one of the {@link android.graphics.PixelFormat} constants.
 * (E.g., <var>PixelFormat.YCbCr_420_SP</var> (default),
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The method'IllegalArgumentException' carries an error message in the later version compared to the early version and the parameter within set() method changes, so the code change type is 2,5.","The altered exception handling could potentially lead to the API throwing a different exception message in response to an error, so the CI type is 2."
165,"<android.app.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor)>",4,5,"<android.app.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor)>","<android.app.BackupAgent.BackupServiceBinder: void doRestore(ParcelFileDescriptor,int,ParcelFileDescriptor)>",0,"{
    // !!! TODO - real implementation; for now just invoke the callbacks directly
    Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    }
}","{
    // !!! TODO - real implementation; for now just invoke the callbacks directly
    if (DEBUG)
        Log.v(TAG, ""doRestore() invoked"");
    BackupDataInput input = new BackupDataInput(data.getFileDescriptor());
    try {
        BackupAgent.this.onRestore(input, appVersionCode, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onRestore ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The log emission statement has been wrapped into an 'if' block, whose condition checks for the DEBUG flag. This is classified as ""Other statement changed"".","The change doesn't affect any substantial workflow of the method; it only introduces a conditional check before log emission. Hence, it doesn't lead to any Compatibility Issue. The same happenings up the call stack do not affect the functionality."
166,"<android.text.format.Formatter: String formatFileSize(Context,long)>",4,5,"<android.text.format.Formatter: String formatFileSize(Context,long)>","<android.text.format.Formatter: String formatFileSize(Context,long)>",0,"{
    if (context == null) {
        return """";
    }
    float result = number;
    int suffix = com.android.internal.R.string.byteShort;
    if (result > 900) {
        suffix = com.android.internal.R.string.kilobyteShort;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.megabyteShort;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.gigabyteShort;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.terabyteShort;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.petabyteShort;
        result = result / 1024;
    }
    if (result < 100) {
        String value = String.format(""%.2f"", result);
        return context.getResources().getString(com.android.internal.R.string.fileSizeSuffix, value, context.getString(suffix));
    }
    String value = String.format(""%.0f"", result);
    return context.getResources().getString(com.android.internal.R.string.fileSizeSuffix, value, context.getString(suffix));
}","{
    return formatFileSize(context, number, false);
}",1,"/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc
 *
 * @param context Context to use to load the localized units
 * @param number size value to be formated
 * @return formated string with the number
 */
","/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc
 *
 * @param context Context to use to load the localized units
 * @param number size value to be formated
 * @return formated string with the number
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the early implementation, the method used direct computations and condition checks to calculate and format the file size. In contrast, in the late implementation, this computation is moved to another method formatFileSize(context, number, false), substantially changing the return statement. Thus, the change type is 1,5.","The change results in the method potentially returning a different value, leading to a difference in behavior. Therefore, the Compatibility Issue is of type 1, caused by potential different return values."
167,"<android.webkit.WebViewDatabase: void addCache(String,CacheResult)>",4,5,"<android.webkit.WebViewDatabase: void addCache(String,CacheResult)>","<android.webkit.WebViewDatabase: void addCache(String,CacheResult)>",0,"{
    if (url == null || mCacheDatabase == null) {
        return;
    }
    mCacheInserter.prepareForInsert();
    mCacheInserter.bind(mCacheUrlColIndex, url);
    mCacheInserter.bind(mCacheFilePathColIndex, c.localPath);
    mCacheInserter.bind(mCacheLastModifyColIndex, c.lastModified);
    mCacheInserter.bind(mCacheETagColIndex, c.etag);
    mCacheInserter.bind(mCacheExpiresColIndex, c.expires);
    mCacheInserter.bind(mCacheMimeTypeColIndex, c.mimeType);
    mCacheInserter.bind(mCacheEncodingColIndex, c.encoding);
    mCacheInserter.bind(mCacheHttpStatusColIndex, c.httpStatusCode);
    mCacheInserter.bind(mCacheLocationColIndex, c.location);
    mCacheInserter.bind(mCacheContentLengthColIndex, c.contentLength);
    mCacheInserter.execute();
}","{
    if (url == null || mCacheDatabase == null) {
        return;
    }
    mCacheInserter.prepareForInsert();
    mCacheInserter.bind(mCacheUrlColIndex, url);
    mCacheInserter.bind(mCacheFilePathColIndex, c.localPath);
    mCacheInserter.bind(mCacheLastModifyColIndex, c.lastModified);
    mCacheInserter.bind(mCacheETagColIndex, c.etag);
    mCacheInserter.bind(mCacheExpiresColIndex, c.expires);
    mCacheInserter.bind(mCacheExpiresStringColIndex, c.expiresString);
    mCacheInserter.bind(mCacheMimeTypeColIndex, c.mimeType);
    mCacheInserter.bind(mCacheEncodingColIndex, c.encoding);
    mCacheInserter.bind(mCacheHttpStatusColIndex, c.httpStatusCode);
    mCacheInserter.bind(mCacheLocationColIndex, c.location);
    mCacheInserter.bind(mCacheContentLengthColIndex, c.contentLength);
    mCacheInserter.bind(mCacheContentDispositionColIndex, c.contentdisposition);
    mCacheInserter.execute();
}",1,"/**
 * Add or update a cache. CACHE_URL_COL is unique in the table.
 *
 * @param url The url
 * @param c The CacheManager.CacheResult
 */
","/**
 * Add or update a cache. CACHE_URL_COL is unique in the table.
 *
 * @param url The url
 * @param c The CacheManager.CacheResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two extra bind statements were added between the early and late versions, which can be classified as other statement changes. Hence, the code change type is 4. ","Although the code has changed, these changes are not altering the API's behavior in a way that could cause a compatibility issue. Thus, there are no compatibility issue; hence compatibility issue type is 0."
169,"<android.webkit.CacheManager: CacheResult getCacheFile(String,Map<String, String>)>",4,5,"<android.webkit.CacheManager: CacheResult getCacheFile(String,Map<String, String>)>","<android.webkit.CacheManager: CacheResult getCacheFile(String,Map<String, String>)>",0,"{
    if (mDisabled) {
        return null;
    }
    CacheResult result = mDataBase.getCache(url);
    if (result != null) {
        if (result.contentLength == 0) {
            if (!checkCacheRedirect(result.httpStatusCode)) {
                // this should not happen. If it does, remove it.
                mDataBase.removeCache(url);
                return null;
            }
        } else {
            File src = new File(mBaseDir, result.localPath);
            try {
                // open here so that even the file is deleted, the content
                // is still readable by the caller until close() is called
                result.inStream = new FileInputStream(src);
            } catch (FileNotFoundException e) {
                // the files in the cache directory can be removed by the
                // system. If it is gone, clean up the database
                mDataBase.removeCache(url);
                return null;
            }
        }
    } else {
        return null;
    }
    // negative expires means time in the far future.
    if (headers != null && result.expires >= 0 && result.expires <= System.currentTimeMillis()) {
        if (result.lastModified == null && result.etag == null) {
            return null;
        }
        // for requesting validation
        if (result.etag != null) {
            headers.put(HEADER_KEY_IFNONEMATCH, result.etag);
        }
        if (result.lastModified != null) {
            headers.put(HEADER_KEY_IFMODIFIEDSINCE, result.lastModified);
        }
    }
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""getCacheFile for url "" + url);
    }
    return result;
}","{
    if (mDisabled) {
        return null;
    }
    CacheResult result = mDataBase.getCache(url);
    if (result != null) {
        if (result.contentLength == 0) {
            if (!checkCacheRedirect(result.httpStatusCode)) {
                // this should not happen. If it does, remove it.
                mDataBase.removeCache(url);
                return null;
            }
        } else {
            File src = new File(mBaseDir, result.localPath);
            try {
                // open here so that even the file is deleted, the content
                // is still readable by the caller until close() is called
                result.inStream = new FileInputStream(src);
            } catch (FileNotFoundException e) {
                // the files in the cache directory can be removed by the
                // system. If it is gone, clean up the database
                mDataBase.removeCache(url);
                return null;
            }
        }
    } else {
        return null;
    }
    // negative expires means time in the far future.
    if (headers != null && result.expires >= 0 && result.expires <= System.currentTimeMillis()) {
        if (result.lastModified == null && result.etag == null) {
            return null;
        }
        // for requesting validation
        if (result.etag != null) {
            headers.put(HEADER_KEY_IFNONEMATCH, result.etag);
        }
        if (result.lastModified != null) {
            headers.put(HEADER_KEY_IFMODIFIEDSINCE, result.lastModified);
        }
    }
    if (DebugFlags.CACHE_MANAGER) {
        Log.v(LOGTAG, ""getCacheFile for url "" + url);
    }
    return result;
}",1,"// only called from WebCore thread
","// only called from WebCore thread
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The logging condition statement has changed from ""WebView.LOGV_ENABLED"" to ""DebugFlags.CACHE_MANAGER"". Therefore, the code change type is 4.","The condition for logging information has changed, but it does not affect the return of the API or the exception handling. Hence, no compatibility issue has been detected."
170,"<com.google.android.mms.pdu.PduPersister: Uri persist(GenericPdu,Uri)>",4,5,"<com.google.android.mms.pdu.PduPersister: Uri persist(GenericPdu,Uri)>","<com.google.android.mms.pdu.PduPersister: Uri persist(GenericPdu,Uri)>",0,"{
    if (uri == null) {
        throw new MmsException(""Uri may not be null."");
    }
    Integer msgBox = MESSAGE_BOX_MAP.get(uri);
    if (msgBox == null) {
        throw new MmsException(""Bad destination, must be one of "" + ""content://mms/inbox, content://mms/sent, "" + ""content://mms/drafts, content://mms/outbox, "" + ""content://mms/temp."");
    }
    PduHeaders header = pdu.getPduHeaders();
    PduBody body = null;
    ContentValues values = new ContentValues();
    Set<Entry<Integer, String>> set;
    set = ENCODED_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int field = e.getKey();
        EncodedStringValue encodedString = header.getEncodedStringValue(field);
        if (encodedString != null) {
            String charsetColumn = CHARSET_COLUMN_NAME_MAP.get(field);
            values.put(e.getValue(), toIsoString(encodedString.getTextString()));
            values.put(charsetColumn, encodedString.getCharacterSet());
        }
    }
    set = TEXT_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        byte[] text = header.getTextString(e.getKey());
        if (text != null) {
            values.put(e.getValue(), toIsoString(text));
        }
    }
    set = OCTET_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int b = header.getOctet(e.getKey());
        if (b != 0) {
            values.put(e.getValue(), b);
        }
    }
    set = LONG_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        long l = header.getLongInteger(e.getKey());
        if (l != -1L) {
            values.put(e.getValue(), l);
        }
    }
    HashMap<Integer, EncodedStringValue[]> addressMap = new HashMap<Integer, EncodedStringValue[]>(ADDRESS_FIELDS.length);
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = null;
        if (addrType == PduHeaders.FROM) {
            EncodedStringValue v = header.getEncodedStringValue(addrType);
            if (v != null) {
                array = new EncodedStringValue[1];
                array[0] = v;
            }
        } else {
            array = header.getEncodedStringValues(addrType);
        }
        addressMap.put(addrType, array);
    }
    HashSet<String> recipients = new HashSet<String>();
    long threadId = DUMMY_THREAD_ID;
    int msgType = pdu.getMessageType();
    // this scope.
    if ((msgType == PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND) || (msgType == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) || (msgType == PduHeaders.MESSAGE_TYPE_SEND_REQ)) {
        EncodedStringValue[] array = null;
        switch(msgType) {
            case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
            case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
                array = addressMap.get(PduHeaders.FROM);
                break;
            case PduHeaders.MESSAGE_TYPE_SEND_REQ:
                array = addressMap.get(PduHeaders.TO);
                break;
        }
        if (array != null) {
            for (EncodedStringValue v : array) {
                if (v != null) {
                    recipients.add(v.getString());
                }
            }
        }
        threadId = Threads.getOrCreateThreadId(mContext, recipients);
    }
    values.put(Mms.THREAD_ID, threadId);
    // Save parts first to avoid inconsistent message is loaded
    // while saving the parts.
    // Dummy ID of the msg.
    long dummyId = System.currentTimeMillis();
    // Get body if the PDU is a RetrieveConf or SendReq.
    if (pdu instanceof MultimediaMessagePdu) {
        body = ((MultimediaMessagePdu) pdu).getBody();
        // Start saving parts if necessary.
        if (body != null) {
            int partsNum = body.getPartsNum();
            for (int i = 0; i < partsNum; i++) {
                PduPart part = body.getPart(i);
                persistPart(part, dummyId);
            }
        }
    }
    Uri res = SqliteWrapper.insert(mContext, mContentResolver, uri, values);
    if (res == null) {
        throw new MmsException(""persist() failed: return null."");
    }
    // Get the real ID of the PDU and update all parts which were
    // saved with the dummy ID.
    long msgId = ContentUris.parseId(res);
    values = new ContentValues(1);
    values.put(Part.MSG_ID, msgId);
    SqliteWrapper.update(mContext, mContentResolver, Uri.parse(""content://mms/"" + dummyId + ""/part""), values, null, null);
    // We should return the longest URI of the persisted PDU, for
    // example, if input URI is ""content://mms/inbox"" and the _ID of
    // persisted PDU is '8', we should return ""content://mms/inbox/8""
    // instead of ""content://mms/8"".
    // FIXME: Should the MmsProvider be responsible for this???
    res = Uri.parse(uri + ""/"" + msgId);
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = addressMap.get(addrType);
        if (array != null) {
            persistAddress(msgId, addrType, array);
        }
    }
    return res;
}","{
    if (uri == null) {
        throw new MmsException(""Uri may not be null."");
    }
    Integer msgBox = MESSAGE_BOX_MAP.get(uri);
    if (msgBox == null) {
        throw new MmsException(""Bad destination, must be one of "" + ""content://mms/inbox, content://mms/sent, "" + ""content://mms/drafts, content://mms/outbox, "" + ""content://mms/temp."");
    }
    PDU_CACHE_INSTANCE.purge(uri);
    PduHeaders header = pdu.getPduHeaders();
    PduBody body = null;
    ContentValues values = new ContentValues();
    Set<Entry<Integer, String>> set;
    set = ENCODED_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int field = e.getKey();
        EncodedStringValue encodedString = header.getEncodedStringValue(field);
        if (encodedString != null) {
            String charsetColumn = CHARSET_COLUMN_NAME_MAP.get(field);
            values.put(e.getValue(), toIsoString(encodedString.getTextString()));
            values.put(charsetColumn, encodedString.getCharacterSet());
        }
    }
    set = TEXT_STRING_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        byte[] text = header.getTextString(e.getKey());
        if (text != null) {
            values.put(e.getValue(), toIsoString(text));
        }
    }
    set = OCTET_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        int b = header.getOctet(e.getKey());
        if (b != 0) {
            values.put(e.getValue(), b);
        }
    }
    set = LONG_COLUMN_NAME_MAP.entrySet();
    for (Entry<Integer, String> e : set) {
        long l = header.getLongInteger(e.getKey());
        if (l != -1L) {
            values.put(e.getValue(), l);
        }
    }
    HashMap<Integer, EncodedStringValue[]> addressMap = new HashMap<Integer, EncodedStringValue[]>(ADDRESS_FIELDS.length);
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = null;
        if (addrType == PduHeaders.FROM) {
            EncodedStringValue v = header.getEncodedStringValue(addrType);
            if (v != null) {
                array = new EncodedStringValue[1];
                array[0] = v;
            }
        } else {
            array = header.getEncodedStringValues(addrType);
        }
        addressMap.put(addrType, array);
    }
    HashSet<String> recipients = new HashSet<String>();
    long threadId = DUMMY_THREAD_ID;
    int msgType = pdu.getMessageType();
    // this scope.
    if ((msgType == PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND) || (msgType == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) || (msgType == PduHeaders.MESSAGE_TYPE_SEND_REQ)) {
        EncodedStringValue[] array = null;
        switch(msgType) {
            case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
            case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
                array = addressMap.get(PduHeaders.FROM);
                break;
            case PduHeaders.MESSAGE_TYPE_SEND_REQ:
                array = addressMap.get(PduHeaders.TO);
                break;
        }
        if (array != null) {
            for (EncodedStringValue v : array) {
                if (v != null) {
                    recipients.add(v.getString());
                }
            }
        }
        threadId = Threads.getOrCreateThreadId(mContext, recipients);
    }
    values.put(Mms.THREAD_ID, threadId);
    // Save parts first to avoid inconsistent message is loaded
    // while saving the parts.
    // Dummy ID of the msg.
    long dummyId = System.currentTimeMillis();
    // Get body if the PDU is a RetrieveConf or SendReq.
    if (pdu instanceof MultimediaMessagePdu) {
        body = ((MultimediaMessagePdu) pdu).getBody();
        // Start saving parts if necessary.
        if (body != null) {
            int partsNum = body.getPartsNum();
            for (int i = 0; i < partsNum; i++) {
                PduPart part = body.getPart(i);
                persistPart(part, dummyId);
            }
        }
    }
    Uri res = SqliteWrapper.insert(mContext, mContentResolver, uri, values);
    if (res == null) {
        throw new MmsException(""persist() failed: return null."");
    }
    // Get the real ID of the PDU and update all parts which were
    // saved with the dummy ID.
    long msgId = ContentUris.parseId(res);
    values = new ContentValues(1);
    values.put(Part.MSG_ID, msgId);
    SqliteWrapper.update(mContext, mContentResolver, Uri.parse(""content://mms/"" + dummyId + ""/part""), values, null, null);
    // We should return the longest URI of the persisted PDU, for
    // example, if input URI is ""content://mms/inbox"" and the _ID of
    // persisted PDU is '8', we should return ""content://mms/inbox/8""
    // instead of ""content://mms/8"".
    // FIXME: Should the MmsProvider be responsible for this???
    res = Uri.parse(uri + ""/"" + msgId);
    // Save address information.
    for (int addrType : ADDRESS_FIELDS) {
        EncodedStringValue[] array = addressMap.get(addrType);
        if (array != null) {
            persistAddress(msgId, addrType, array);
        }
    }
    return res;
}",1,"/**
 * Persist a PDU object to specific location in the storage.
 *
 * @param pdu The PDU object to be stored.
 * @param uri Where to store the given PDU object.
 * @return A Uri which can be used to access the stored PDU.
 */
","/**
 * Persist a PDU object to specific location in the storage.
 *
 * @param pdu The PDU object to be stored.
 * @param uri Where to store the given PDU object.
 * @return A Uri which can be used to access the stored PDU.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement is introduced at the beginning: `PDU_CACHE_INSTANCE.purge(uri);`. So, the code change type is 4.","This new statement doesn't change the functionality of the method, nor affects its output or error handling. Thus, no compatibility issue."
171,<android.view.MotionEvent: long getHistoricalEventTime(int)>,4,5,<android.view.MotionEvent: long getHistoricalEventTime(int)>,<android.view.MotionEvent: long getHistoricalEventTime(int)>,0,"{
    return mHistoryTimes[pos];
}","{
    return mTimeSamples[pos + 1];
}",1,"/**
 * Returns the time that a historical movement occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getEventTime
 */
","/**
 * Returns the time that a historical movement occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getEventTime
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning 'mHistoryTimes[pos]' to 'mTimeSamples[pos + 1]' and the array variable referred in the return statement has changed, so the code change type is 1,5.","The change in the return variable will result in the return of a different value when the API is invoked, which could introduce a compatibility issue. So the CI type is 1."
174,<android.app.ApplicationContext: void clearWallpaper()>,4,5,<android.app.ApplicationContext: void clearWallpaper()>,<android.app.ApplicationContext: void clearWallpaper()>,0,"{
    try {
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = getWallpaperService().setWallpaper();
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(getResources().openRawResource(com.android.internal.R.drawable.default_wallpaper), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    }
}","{
    getWallpaperManager().clear();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire body of the method has been replaced in the late version, a simple invokation to the WallpaperManager's clear() method. Thus the code change type is 1,4,5.","Since the complete implementation of the method is changed, the return variables, exception handling and basically all executional statements have changed which potentially alters many behaviors including different return types or values. Therefore, compatibility issue type is 1."
177,<android.app.ApplicationContext: void setWallpaper(InputStream)>,4,5,<android.app.ApplicationContext: void setWallpaper(InputStream)>,<android.app.ApplicationContext: void setWallpaper(InputStream)>,0,"{
    try {
        ParcelFileDescriptor fd = getWallpaperService().setWallpaper();
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    }
}","{
    getWallpaperManager().setStream(data);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation logic has been changed with new statements introduced and old ones deleted. A new dependent API 'getWallpaperManager().setStream(data)' is used and the return type changed, so the code change type is 1, 4, 5.","The 'return' statement in 'if (fd == null)' has been removed, and the way of setting wallpaper has completely changed. This could lead to a different behaviour and even return value when calling setWallpaper in the late version. Hence, the CI type is 1."
178,<android.widget.VideoView: boolean isPlaying()>,4,5,<android.widget.VideoView: boolean isPlaying()>,<android.widget.VideoView: boolean isPlaying()>,0,"{
    if (mMediaPlayer != null && mIsPrepared) {
        return mMediaPlayer.isPlaying();
    }
    return false;
}","{
    return isInPlaybackState() && mMediaPlayer.isPlaying();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed from one that includes a compound condition (mMediaPlayer != null && mIsPrepared) to a simpler one (isInPlaybackState() && mMediaPlayer.isPlaying()). Also, the condition in the if statement has changed indicating a control dependency change, hence the change types are 1 and 3.","The changes could influence the return value of the method, leading to potential compatibility issues of returning different values. Therefore, the CI type is 1."
180,<android.widget.PopupWindow.PopupViewContainer: boolean dispatchKeyEvent(KeyEvent)>,4,5,<android.widget.PopupWindow.PopupViewContainer: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.PopupWindow.PopupViewContainer: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        dismiss();
        return true;
    } else {
        return super.dispatchKeyEvent(event);
    }
}","{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            getKeyDispatcherState().startTracking(event, this);
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
            dismiss();
            return true;
        }
        return super.dispatchKeyEvent(event);
    } else {
        return super.dispatchKeyEvent(event);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,The control dependency has changed. The logic under 'if (event.getKeyCode() == KeyEvent.KEYCODE_BACK)' has significantly changed and a new control statement 'if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0)' has been introduced. So the code change type is 3.,"The modification might potentially lead to different return values. Depending on the new added control statements, the late version API will or will not execute 'dismiss()' and return different boolean values. Therefore, the CI type is 1."
181,"<android.widget.AlphabetIndexer: int compare(String,String)>",4,5,"<android.widget.AlphabetIndexer: int compare(String,String)>","<android.widget.AlphabetIndexer: int compare(String,String)>",0,"{
    return mCollator.compare(word.substring(0, 1), letter);
}","{
    final String firstLetter;
    if (word.length() == 0) {
        firstLetter = "" "";
    } else {
        firstLetter = word.substring(0, 1);
    }
    return mCollator.compare(firstLetter, letter);
}",1,"/**
 * Default implementation compares the first character of word with letter.
 */
","/**
 * Default implementation compares the first character of word with letter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control statement 'if' is added in the late version, and also the return statement has changed, which introduces a new process to manage an empty string. Therefore, the change types are both 1 and 3.","Due to the new control dependencies, an empty string will be handled differently and the value passed to mCollator.compare() is different, which can potentially cause different return value. Therefore, the compatibility issue type is 1."
184,<android.view.MotionEvent: float getHistoricalSize(int)>,4,5,<android.view.MotionEvent: float getHistoricalSize(int)>,<android.view.MotionEvent: float getHistoricalSize(int)>,0,"{
    return mHistory[pos * 4 + 3];
}","{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_SIZE];
}",1,"/**
 * Returns a historical size coordinate that occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getSize
 */
","/**
 * {@link #getHistoricalSize(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement in the method implementation has changed from mHistory[pos * 4 + 3] to mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_SIZE], hence the code change type is 1.","Since the method now returns a value computed using a different formula, this can potentially lead to different return values for the same input, hence the CI type is 1."
185,"<android.database.DatabaseUtils: long queryNumEntries(SQLiteDatabase,String)>",4,5,"<android.database.DatabaseUtils: long queryNumEntries(SQLiteDatabase,String)>","<android.database.DatabaseUtils: long queryNumEntries(SQLiteDatabase,String)>",0,"{
    Cursor cursor = db.query(table, countProjection, null, null, null, null, null);
    cursor.moveToFirst();
    long count = cursor.getLong(0);
    cursor.deactivate();
    return count;
}","{
    Cursor cursor = db.query(table, countProjection, null, null, null, null, null);
    try {
        cursor.moveToFirst();
        return cursor.getLong(0);
    } finally {
        cursor.close();
    }
}",1,"/**
 * Query the table for the number of rows in the table.
 * @param db the database the table is in
 * @param table the name of the table to query
 * @return the number of rows in the table
 */
","/**
 * Query the table for the number of rows in the table.
 * @param db the database the table is in
 * @param table the name of the table to query
 * @return the number of rows in the table
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2",The return statement and the exception handling statement has been added resulting to changes in the control flow of the API. The value of control variable 'cursor' has been changed from 'deactive' to 'close'.,"The added return statement, and exception handling statement can cause the API to return different values or potentially throw different exceptions, so there is a compatibility issue."
186,<android.widget.VideoView: boolean onTouchEvent(MotionEvent)>,4,5,<android.widget.VideoView: boolean onTouchEvent(MotionEvent)>,<android.widget.VideoView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mIsPrepared && mMediaPlayer != null && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return false;
}","{
    if (isInPlaybackState() && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The condition statement has changed from `mIsPrepared && mMediaPlayer != null` to `isInPlaybackState()`, and it could be that the internal implementation of `isInPlaybackState()` has changed too, so the code change type is 3,5.","The code change potentially leads to a different behaviour of how `toggleMediaControlsVisiblity();` is called, therefore, the potential perceived behaviour of the function `onTouchEvent(MotionEvent)` is different between the two versions and can be regarded as a CI of type 1."
188,<android.webkit.WebView: int computeVerticalScrollRange()>,4,5,<android.webkit.WebView: int computeVerticalScrollRange()>,<android.webkit.WebView: int computeVerticalScrollRange()>,0,"{
    if (mDrawHistory) {
        return mHistoryHeight;
    } else {
        int height = contentToView(mContentHeight);
        if (mFindIsUp) {
            height += FIND_HEIGHT;
        }
        return height;
    }
}","{
    if (mDrawHistory) {
        return mHistoryHeight;
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentHeight * mActualScale);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 3",1,"The return statement in the late version has changed by replacing the previous calculation logic with a new one which uses Math.floor(). Additionally, the control logic for 'if' statement is changed because the condition 'mFindIsUp' is no longer checked. Hence, the code change type is 1, 3.","Since the calculation logic of the return result changed and the 'if' condition check was altered, the API potentially returns a different value. Therefore, the CI type is 1."
189,"<android.webkit.WebView: boolean requestFocus(int,Rect)>",4,5,"<android.webkit.WebView: boolean requestFocus(int,Rect)>","<android.webkit.WebView: boolean requestFocus(int,Rect)>",0,"{
    boolean result = false;
    if (inEditingMode()) {
        result = mTextEntry.requestFocus(direction, previouslyFocusedRect);
    } else {
        result = super.requestFocus(direction, previouslyFocusedRect);
        if (mWebViewCore.getSettings().getNeedInitialFocus()) {
            // For cases such as GMail, where we gain focus from a direction,
            // we want to move to the first available link.
            // FIXME: If there are no visible links, we may not want to
            int fakeKeyDirection = 0;
            switch(direction) {
                case View.FOCUS_UP:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                    break;
                case View.FOCUS_DOWN:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                    break;
                case View.FOCUS_LEFT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                    break;
                case View.FOCUS_RIGHT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                    break;
                default:
                    return result;
            }
            if (mNativeClass != 0 && !nativeUpdateFocusNode()) {
                navHandledKey(fakeKeyDirection, 1, true, 0);
            }
        }
    }
    return result;
}","{
    boolean result = false;
    if (inEditingMode()) {
        result = mWebTextView.requestFocus(direction, previouslyFocusedRect);
    } else {
        result = super.requestFocus(direction, previouslyFocusedRect);
        if (mWebViewCore.getSettings().getNeedInitialFocus()) {
            // For cases such as GMail, where we gain focus from a direction,
            // we want to move to the first available link.
            // FIXME: If there are no visible links, we may not want to
            int fakeKeyDirection = 0;
            switch(direction) {
                case View.FOCUS_UP:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                    break;
                case View.FOCUS_DOWN:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                    break;
                case View.FOCUS_LEFT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                    break;
                case View.FOCUS_RIGHT:
                    fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                    break;
                default:
                    return result;
            }
            if (mNativeClass != 0 && !nativeHasCursorNode()) {
                navHandledKey(fakeKeyDirection, 1, true, 0, true);
            }
        }
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 4, 5",1,"There are changes in the return statement as well as changes in the dependent API since mTextEntry.requestFocus() is replaced by mWebTextView.requestFocus(), and nativeUpdateFocusNode() is replaced with nativeHasCursorNode(). Also, the parameters of the navHandledKey method have changed, taking an additional parameter in the late version. Therefore, the code change types are 1, 4, and 5.","Due to changes in return statements and dependent APIs, these modifications could possibly lead to different return values. Hence, the Compatibility Issue type is 1."
191,<android.content.res.Configuration: int compareTo(Configuration)>,4,5,<android.content.res.Configuration: int compareTo(Configuration)>,<android.content.res.Configuration: int compareTo(Configuration)>,0,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    n = this.locale.getLanguage().compareTo(that.locale.getLanguage());
    if (n != 0)
        return n;
    n = this.locale.getCountry().compareTo(that.locale.getCountry());
    if (n != 0)
        return n;
    n = this.locale.getVariant().compareTo(that.locale.getVariant());
    if (n != 0)
        return n;
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    n = this.locale.getLanguage().compareTo(that.locale.getLanguage());
    if (n != 0)
        return n;
    n = this.locale.getCountry().compareTo(that.locale.getCountry());
    if (n != 0)
        return n;
    n = this.locale.getVariant().compareTo(that.locale.getVariant());
    if (n != 0)
        return n;
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    // if (n != 0) return n;
    return n;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statement 'n = this.navigationHidden - that.navigationHidden;' has been added in the late version, making the comparison additionally dependent on the 'navigationHidden' variable, so the change type is 4.","As the newly added statement could possibly determine a different return value, hence the CI type is 1."
192,<android.view.MotionEvent: void recycle()>,4,5,<android.view.MotionEvent: void recycle()>,<android.view.MotionEvent: void recycle()>,0,"{
    // Ensure recycle is only called once!
    if (TRACK_RECYCLED_LOCATION) {
        if (mRecycledLocation != null) {
            throw new RuntimeException(toString() + "" recycled twice!"", mRecycledLocation);
        }
        mRecycledLocation = new RuntimeException(""Last recycled here"");
    } else if (mRecycled) {
        throw new RuntimeException(toString() + "" recycled twice!"");
    }
    // Log.w(""MotionEvent"", ""Recycling event "" + this, mRecycledLocation);
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNumHistory = 0;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}","{
    // Ensure recycle is only called once!
    if (TRACK_RECYCLED_LOCATION) {
        if (mRecycledLocation != null) {
            throw new RuntimeException(toString() + "" recycled twice!"", mRecycledLocation);
        }
        mRecycledLocation = new RuntimeException(""Last recycled here"");
    } else if (mRecycled) {
        throw new RuntimeException(toString() + "" recycled twice!"");
    }
    // Log.w(""MotionEvent"", ""Recycling event "" + this, mRecycledLocation);
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNumSamples = 0;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}",1,"/**
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling
 * this function you must not ever touch the event again.
 */
","/**
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling
 * this function you must not ever touch the event again.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"Only the assignment statement has changed from 'mNumHistory = 0' to 'mNumSamples = 0', so the code change type is 4.","Though the 'recycle' method does not return any value, it modifies the value of the 'mNumSamples' variable, which can affect the object state and therefore lead to different behaviors of other methods that depend on this state. Thus, the Compatibility Issue situation is 1."
193,"<android.widget.TextView: boolean setFrame(int,int,int,int)>",4,5,"<android.widget.TextView: boolean setFrame(int,int,int,int)>","<android.widget.TextView: boolean setFrame(int,int,int,int)>",0,"{
    boolean result = super.setFrame(l, t, r, b);
    if (mPopup != null) {
        TextView tv = (TextView) mPopup.getContentView();
        chooseSize(mPopup, mError, tv);
        mPopup.update(this, getErrorX(), getErrorY(), -1, -1);
    }
    restartMarqueeIfNeeded();
    return result;
}","{
    boolean result = super.setFrame(l, t, r, b);
    if (mPopup != null) {
        TextView tv = (TextView) mPopup.getContentView();
        chooseSize(mPopup, mError, tv);
        mPopup.update(this, getErrorX(), getErrorY(), mPopup.getWidth(), mPopup.getHeight());
    }
    restartMarqueeIfNeeded();
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The parameter values of the mPopup.update() method have been changed, so the code change type is 4.","The change of parameters in mPopup.update() method will potentially affect its behavior and cause the API to return a different value, so the CI type is 1."
194,"<android.webkit.CallbackProxy: boolean onSavePassword(String,String,String,Message)>",4,5,"<android.webkit.CallbackProxy: boolean onSavePassword(String,String,String,Message)>","<android.webkit.CallbackProxy: boolean onSavePassword(String,String,String,Message)>",0,"{
    // within the CallbackProxy.
    if (WebView.DEBUG) {
        junit.framework.Assert.assertNull(resumeMsg);
    }
    resumeMsg = obtainMessage(NOTIFY);
    Message msg = obtainMessage(SAVE_PASSWORD, resumeMsg);
    Bundle bundle = msg.getData();
    bundle.putString(""host"", schemePlusHost);
    bundle.putString(""username"", username);
    bundle.putString(""password"", password);
    synchronized (this) {
        sendMessage(msg);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for onSavePassword"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    // Doesn't matter here
    return false;
}","{
    // within the CallbackProxy.
    if (DebugFlags.CALLBACK_PROXY) {
        junit.framework.Assert.assertNull(resumeMsg);
    }
    resumeMsg = obtainMessage(NOTIFY);
    Message msg = obtainMessage(SAVE_PASSWORD, resumeMsg);
    Bundle bundle = msg.getData();
    bundle.putString(""host"", schemePlusHost);
    bundle.putString(""username"", username);
    bundle.putString(""password"", password);
    synchronized (this) {
        sendMessage(msg);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for onSavePassword"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    // Doesn't matter here
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"Only the condition 'WebView.DEBUG' has changed to 'DebugFlags.CALLBACK_PROXY' in the if statement, so the code change category is 3.","Despite the change, it wouldn't result in the API returning different values or throwing different exceptions, hence, the CI type is 0."
196,"<android.text.format.DateUtils: String formatDateRange(Context,long,long,int)>",4,5,"<android.text.format.DateUtils: String formatDateRange(Context,long,long,int)>","<android.text.format.DateUtils: String formatDateRange(Context,long,long,int)>",0,"{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate = useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        endDate = useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    // adjust the date.
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum) {
        // Example: ""January, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        return startDateString;
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // The values that are used in a fullFormat string are specified
        // by position.
        dateRange = String.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
        return dateRange;
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // The values that are used in a fullFormat string are specified
        // by position.
        dateRange = String.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
        return dateRange;
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // The values that are used in a fullFormat string are specified
        // by position.
        dateRange = String.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
        return dateRange;
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return dateString;
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return startWeekDayString;
        }
    } else if (showTime) {
        return timeString;
    }
    // The values that are used in a fullFormat string are specified
    // by position.
    dateRange = String.format(fullFormat, timeString, startWeekDayString, dateString);
    return dateRange;
}","{
    Formatter f = new Formatter(new StringBuilder(50), Locale.getDefault());
    return formatDateRange(context, f, startMillis, endMillis, flags).toString();
}",1,"/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC timezone is used for the start
 * and end milliseconds.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * @param context the context is required only if the time is shown
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 *
 * @return a string containing the formatted date/time range.
 */
","/**
 * Formats a date or a time range according to the local conventions.
 * <p>
 * Note that this is a convenience method. Using it involves creating an
 * internal {@link java.util.Formatter} instance on-the-fly, which is
 * somewhat costly in terms of memory and time. This is probably acceptable
 * if you use the method only rarely, but if you rely on it for formatting a
 * large number of dates, consider creating and reusing your own
 * {@link java.util.Formatter} instance and use the version of
 * {@link #formatDateRange(Context, long, long, int) formatDateRange}
 * that takes a {@link java.util.Formatter}.
 *
 * @param context the context is required only if the time is shown
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options See
 * {@link #formatDateRange(Context, long, long, int) formatDateRange}
 * @return a string containing the formatted date/time range.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The entire method implementation has been replaced from a complex implementation to a single return statement with different function calls being used. This falls under the classification of both Return Statement Changed and Dependent API Changed.,"Since the entire implementation has been re-written, the changes made to the method could potentially cause the API to return a different type or value, falling under the category - Compatibility Issue caused by potential different return values or types."
197,"<android.webkit.LoadListener: boolean checkCache(Map<String, String>)>",4,5,"<android.webkit.LoadListener: boolean checkCache(Map<String, String>)>","<android.webkit.LoadListener: boolean checkCache(Map<String, String>)>",0,"{
    // Get the cache file name for the current URL
    CacheResult result = CacheManager.getCacheFile(url(), headers);
    // Go ahead and set the cache loader to null in case the result is
    // null.
    mCacheLoader = null;
    if (result != null) {
        // The contents of the cache may need to be revalidated so just
        // remember the cache loader in the case that the server responds
        // positively to the cached content. This is also used to detect if
        // a redirect came from the cache.
        mCacheLoader = new CacheLoader(this, result);
        // added, then the cached content valid, we should use it.
        if (!headers.containsKey(CacheManager.HEADER_KEY_IFNONEMATCH) && !headers.containsKey(CacheManager.HEADER_KEY_IFMODIFIEDSINCE)) {
            if (WebView.LOGV_ENABLED) {
                Log.v(LOGTAG, ""FrameLoader: HTTP URL in cache "" + ""and usable: "" + url());
            }
            // Load the cached file
            mCacheLoader.load();
            return true;
        }
    }
    return false;
}","{
    // Get the cache file name for the current URL
    CacheResult result = CacheManager.getCacheFile(url(), headers);
    // Go ahead and set the cache loader to null in case the result is
    // null.
    mCacheLoader = null;
    // reset the flag
    mFromCache = false;
    if (result != null) {
        // The contents of the cache may need to be revalidated so just
        // remember the cache loader in the case that the server responds
        // positively to the cached content. This is also used to detect if
        // a redirect came from the cache.
        mCacheLoader = new CacheLoader(this, result);
        // added, then the cached content valid, we should use it.
        if (!headers.containsKey(CacheManager.HEADER_KEY_IFNONEMATCH) && !headers.containsKey(CacheManager.HEADER_KEY_IFMODIFIEDSINCE)) {
            if (DebugFlags.LOAD_LISTENER) {
                Log.v(LOGTAG, ""FrameLoader: HTTP URL in cache "" + ""and usable: "" + url());
            }
            // Load the cached file
            mCacheLoader.load();
            mFromCache = true;
            return true;
        }
    }
    return false;
}",1,"/**
 * Check the cache for the current URL, and load it if it is valid.
 *
 * @param headers for the request
 * @return true if cached response is used.
 */
","/**
 * Check the cache for the current URL, and load it if it is valid.
 *
 * @param headers for the request
 * @return true if cached response is used.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There is a new assignment statement ""mFromCache = false;"" added and the log statement ""if (WebView.LOGV_ENABLED)"" has been replaced with ""if (DebugFlags.LOAD_LISTENER)"". Moreover a new return statement ""mFromCache = true;"" has been inserted before ""return true;"" in the second if statement block. Thus, the change is of type 1,4.","As a new return boolean variable mFromCache has been introduced and is changed within the method, it could change the state of the object, leading to different behaviors when other methods are called on the same object. As such, the compatibility issue type is 1."
198,<android.webkit.WebSettings: String getPluginsPath()>,4,5,<android.webkit.WebSettings: String getPluginsPath()>,<android.webkit.WebSettings: String getPluginsPath()>,0,"{
    return mPluginsPath;
}","{
    return """";
}",1,"/**
 * Return the current path used for plugins in the WebView.
 * @return The string path to the WebView plugins.
 */
","/**
 * TODO: need to add @Deprecated
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from return mPluginsPath; to return """", so the code change type is 1.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
202,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,4,5,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,<android.hardware.Camera.Parameters: void setPictureFormat(int)>,0,"{
    String s = cameraFormatForPixelFormat(pixel_format);
    if (s == null) {
        throw new IllegalArgumentException();
    }
    set(""picture-format"", s);
}","{
    String s = cameraFormatForPixelFormat(pixel_format);
    if (s == null) {
        throw new IllegalArgumentException(""Invalid pixel_format="" + pixel_format);
    }
    set(KEY_PICTURE_FORMAT, s);
}",1,"/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
","/**
 * Sets the image format for pictures.
 *
 * @param pixel_format the desired picture format
 * (<var>PixelFormat.YCbCr_420_SP (NV21)</var>,
 * <var>PixelFormat.RGB_565</var>, or
 * <var>PixelFormat.JPEG</var>)
 * @see android.graphics.PixelFormat
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2, 4, 5",2,"The exception handling statement changes as a more detailed error message is introduced in the IllegalArgumentException thrown. Also, the 'set' method changed from using a simple string ""picture-format"" to using the constant KEY_PICTURE_FORMAT. So, the code change type is 2, 4, and 5. ","The new error message in the exception thrown can lead to different behaviors when the exception handling is considered. Therefore, the CI Type is 2."
204,<android.webkit.WebSettings: void setUseDoubleTree(boolean)>,4,5,<android.webkit.WebSettings: void setUseDoubleTree(boolean)>,<android.webkit.WebSettings: void setUseDoubleTree(boolean)>,0,"{
    if (mUseDoubleTree != use) {
        mUseDoubleTree = use;
        postSync();
    }
}","{
    return;
}",1,"/**
 * Tell the WebView to use the double tree rendering algorithm.
 * @param use True if the WebView is to use double tree rendering, false
 * otherwise.
 */
","/**
 * @deprecated This setting controlled a rendering optimization
 * that is no longer present. Setting it now has no effect.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"All the statements in the method are changed and the return statement is introduced, so the code change type is 1,4.","The late version of the method won't affect the 'mUseDoubleTree' value, therefore, a different result will be expected comparing to the early version. Hence, the CI type is 1."
205,<android.inputmethodservice.InputMethodService: void startExtractingText(boolean)>,4,5,<android.inputmethodservice.InputMethodService: void startExtractingText(boolean)>,<android.inputmethodservice.InputMethodService: void startExtractingText(boolean)>,0,"{
    final ExtractEditText eet = mExtractEditText;
    if (eet != null && getCurrentInputStarted() && isFullscreenMode()) {
        mExtractedToken++;
        ExtractedTextRequest req = new ExtractedTextRequest();
        req.token = mExtractedToken;
        req.flags = InputConnection.GET_TEXT_WITH_STYLES;
        req.hintMaxLines = 10;
        req.hintMaxChars = 10000;
        mExtractedText = getCurrentInputConnection().getExtractedText(req, InputConnection.GET_EXTRACTED_TEXT_MONITOR);
        final EditorInfo ei = getCurrentInputEditorInfo();
        try {
            eet.startInternalChanges();
            onUpdateExtractingVisibility(ei);
            onUpdateExtractingViews(ei);
            int inputType = ei.inputType;
            if ((inputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
                if ((inputType & EditorInfo.TYPE_TEXT_FLAG_IME_MULTI_LINE) != 0) {
                    inputType |= EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
                }
            }
            eet.setInputType(inputType);
            eet.setHint(ei.hintText);
            if (mExtractedText != null) {
                eet.setEnabled(true);
                eet.setExtractedText(mExtractedText);
            } else {
                eet.setEnabled(false);
                eet.setText("""");
            }
        } finally {
            eet.finishInternalChanges();
        }
        if (inputChanged) {
            onExtractingInputChanged(ei);
        }
    }
}","{
    final ExtractEditText eet = mExtractEditText;
    if (eet != null && getCurrentInputStarted() && isFullscreenMode()) {
        mExtractedToken++;
        ExtractedTextRequest req = new ExtractedTextRequest();
        req.token = mExtractedToken;
        req.flags = InputConnection.GET_TEXT_WITH_STYLES;
        req.hintMaxLines = 10;
        req.hintMaxChars = 10000;
        InputConnection ic = getCurrentInputConnection();
        mExtractedText = ic == null ? null : ic.getExtractedText(req, InputConnection.GET_EXTRACTED_TEXT_MONITOR);
        final EditorInfo ei = getCurrentInputEditorInfo();
        try {
            eet.startInternalChanges();
            onUpdateExtractingVisibility(ei);
            onUpdateExtractingViews(ei);
            int inputType = ei.inputType;
            if ((inputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
                if ((inputType & EditorInfo.TYPE_TEXT_FLAG_IME_MULTI_LINE) != 0) {
                    inputType |= EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
                }
            }
            eet.setInputType(inputType);
            eet.setHint(ei.hintText);
            if (mExtractedText != null) {
                eet.setEnabled(true);
                eet.setExtractedText(mExtractedText);
            } else {
                eet.setEnabled(false);
                eet.setText("""");
            }
        } finally {
            eet.finishInternalChanges();
        }
        if (inputChanged) {
            onExtractingInputChanged(ei);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statement getCurrentInputConnection().getExtractedText(req, InputConnection.GET_EXTRACTED_TEXT_MONITOR) has been replaced with a conditional statement, so the change type is 4. ","The value of mExtractedText may be different between two versions as the statement assigning value to it has changed. Because this variable is eventually returned by getExtractedText() method, this change can result in different return values, so the CI type is 1."
207,<android.widget.MediaController: boolean dispatchKeyEvent(KeyEvent)>,4,5,<android.widget.MediaController: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.MediaController: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    int keyCode = event.getKeyCode();
    if (event.getRepeatCount() == 0 && event.isDown() && (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keyCode == KeyEvent.KEYCODE_SPACE)) {
        doPauseResume();
        show(sDefaultTimeout);
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP) {
        if (mPlayer.isPlaying()) {
            mPlayer.pause();
            updatePausePlay();
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
        // don't show the controls for volume adjustment
        return super.dispatchKeyEvent(event);
    } else if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) {
        hide();
        return true;
    } else {
        show(sDefaultTimeout);
    }
    return super.dispatchKeyEvent(event);
}","{
    int keyCode = event.getKeyCode();
    if (event.getRepeatCount() == 0 && event.isDown() && (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keyCode == KeyEvent.KEYCODE_SPACE)) {
        doPauseResume();
        show(sDefaultTimeout);
        if (mPauseButton != null) {
            mPauseButton.requestFocus();
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP) {
        if (mPlayer.isPlaying()) {
            mPlayer.pause();
            updatePausePlay();
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
        // don't show the controls for volume adjustment
        return super.dispatchKeyEvent(event);
    } else if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) {
        hide();
        return true;
    } else {
        show(sDefaultTimeout);
    }
    return super.dispatchKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a new statement which sets mPauseButton's focus. This is a ""side effect"" that does not affect the return value or exception, so the code change type is 4.","The additional statement of requesting focus for mPauseButton does not lead to a change in return value or a different exception being thrown, so no Compatibility Issue exists."
208,<android.app.ApplicationContext: int getWallpaperDesiredMinimumWidth()>,4,5,<android.app.ApplicationContext: int getWallpaperDesiredMinimumWidth()>,<android.app.ApplicationContext: int getWallpaperDesiredMinimumWidth()>,0,"{
    try {
        return getWallpaperService().getWidthHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}","{
    return getWallpaperManager().getDesiredMinimumWidth();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The try-catch block was removed and a new return statement was introduced (getWallpaperManager().getDesiredMinimumWidth()), and the dependent method getWidthHint() changed to getDesiredMinimumWidth(), so the change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
209,<android.view.MotionEvent: float getPressure()>,4,5,<android.view.MotionEvent: float getPressure()>,<android.view.MotionEvent: float getPressure()>,0,"{
    return mPressure;
}","{
    return mDataSamples[SAMPLE_PRESSURE];
}",1,"/**
 * Returns the current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 */
","/**
 * {@link #getPressure(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning 'mPressure' to returning 'mDataSamples[SAMPLE_PRESSURE]', and the dependent variables have also changed, so the code change type is 1,5.","The API may potentially return a different value because the returned value is changed from variable 'mPressure' to 'mDataSamples[SAMPLE_PRESSURE]', so the CI type is 1."
210,<android.app.Dialog: boolean dispatchKeyEvent(KeyEvent)>,4,5,<android.app.Dialog: boolean dispatchKeyEvent(KeyEvent)>,<android.app.Dialog: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    if ((mOnKeyListener != null) && (mOnKeyListener.onKey(this, event.getKeyCode(), event))) {
        return true;
    }
    if (mWindow.superDispatchKeyEvent(event)) {
        return true;
    }
    return event.dispatch(this);
}","{
    if ((mOnKeyListener != null) && (mOnKeyListener.onKey(this, event.getKeyCode(), event))) {
        return true;
    }
    if (mWindow.superDispatchKeyEvent(event)) {
        return true;
    }
    return event.dispatch(this, mDecor != null ? mDecor.getKeyDispatcherState() : null, this);
}",1,"/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
","/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from event.dispatch(this) to event.dispatch(this, mDecor != null ? mDecor.getKeyDispatcherState() : null, this) and the parameter type of dispatch() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
211,<android.app.ApplicationContext: Object getSystemService(String)>,4,5,<android.app.ApplicationContext: Object getSystemService(String)>,<android.app.ApplicationContext: Object getSystemService(String)>,0,"{
    if (WINDOW_SERVICE.equals(name)) {
        return WindowManagerImpl.getDefault();
    } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        synchronized (mSync) {
            LayoutInflater inflater = mLayoutInflater;
            if (inflater != null) {
                return inflater;
            }
            mLayoutInflater = inflater = PolicyManager.makeNewLayoutInflater(getOuterContext());
            return inflater;
        }
    } else if (ACTIVITY_SERVICE.equals(name)) {
        return getActivityManager();
    } else if (ALARM_SERVICE.equals(name)) {
        return getAlarmManager();
    } else if (POWER_SERVICE.equals(name)) {
        return getPowerManager();
    } else if (CONNECTIVITY_SERVICE.equals(name)) {
        return getConnectivityManager();
    } else if (WIFI_SERVICE.equals(name)) {
        return getWifiManager();
    } else if (NOTIFICATION_SERVICE.equals(name)) {
        return getNotificationManager();
    } else if (KEYGUARD_SERVICE.equals(name)) {
        return new KeyguardManager();
    } else if (ACCESSIBILITY_SERVICE.equals(name)) {
        return AccessibilityManager.getInstance(this);
    } else if (LOCATION_SERVICE.equals(name)) {
        return getLocationManager();
    } else if (SEARCH_SERVICE.equals(name)) {
        return getSearchManager();
    } else if (SENSOR_SERVICE.equals(name)) {
        return getSensorManager();
    } else if (BLUETOOTH_SERVICE.equals(name)) {
        return getBluetoothDevice();
    } else if (VIBRATOR_SERVICE.equals(name)) {
        return getVibrator();
    } else if (STATUS_BAR_SERVICE.equals(name)) {
        synchronized (mSync) {
            if (mStatusBarManager == null) {
                mStatusBarManager = new StatusBarManager(getOuterContext());
            }
            return mStatusBarManager;
        }
    } else if (AUDIO_SERVICE.equals(name)) {
        return getAudioManager();
    } else if (TELEPHONY_SERVICE.equals(name)) {
        return getTelephonyManager();
    } else if (CLIPBOARD_SERVICE.equals(name)) {
        return getClipboardManager();
    } else if (INPUT_METHOD_SERVICE.equals(name)) {
        return InputMethodManager.getInstance(this);
    }
    return null;
}","{
    if (WINDOW_SERVICE.equals(name)) {
        return WindowManagerImpl.getDefault();
    } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        synchronized (mSync) {
            LayoutInflater inflater = mLayoutInflater;
            if (inflater != null) {
                return inflater;
            }
            mLayoutInflater = inflater = PolicyManager.makeNewLayoutInflater(getOuterContext());
            return inflater;
        }
    } else if (ACTIVITY_SERVICE.equals(name)) {
        return getActivityManager();
    } else if (INPUT_METHOD_SERVICE.equals(name)) {
        return InputMethodManager.getInstance(this);
    } else if (ALARM_SERVICE.equals(name)) {
        return getAlarmManager();
    } else if (ACCOUNT_SERVICE.equals(name)) {
        return getAccountManager();
    } else if (POWER_SERVICE.equals(name)) {
        return getPowerManager();
    } else if (CONNECTIVITY_SERVICE.equals(name)) {
        return getConnectivityManager();
    } else if (WIFI_SERVICE.equals(name)) {
        return getWifiManager();
    } else if (NOTIFICATION_SERVICE.equals(name)) {
        return getNotificationManager();
    } else if (KEYGUARD_SERVICE.equals(name)) {
        return new KeyguardManager();
    } else if (ACCESSIBILITY_SERVICE.equals(name)) {
        return AccessibilityManager.getInstance(this);
    } else if (LOCATION_SERVICE.equals(name)) {
        return getLocationManager();
    } else if (SEARCH_SERVICE.equals(name)) {
        return getSearchManager();
    } else if (SENSOR_SERVICE.equals(name)) {
        return getSensorManager();
    } else if (VIBRATOR_SERVICE.equals(name)) {
        return getVibrator();
    } else if (STATUS_BAR_SERVICE.equals(name)) {
        synchronized (mSync) {
            if (mStatusBarManager == null) {
                mStatusBarManager = new StatusBarManager(getOuterContext());
            }
            return mStatusBarManager;
        }
    } else if (AUDIO_SERVICE.equals(name)) {
        return getAudioManager();
    } else if (TELEPHONY_SERVICE.equals(name)) {
        return getTelephonyManager();
    } else if (CLIPBOARD_SERVICE.equals(name)) {
        return getClipboardManager();
    } else if (WALLPAPER_SERVICE.equals(name)) {
        return getWallpaperManager();
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The change occurs in the various branches of the if-else clause, with several branches removed and new ones added. To be more specific, the following changes are observed:",    - else if (SENSOR_SERVICE.equals(name)) { return getSensorManager(); }
212,<android.app.ApplicationContext: int getWallpaperDesiredMinimumHeight()>,4,5,<android.app.ApplicationContext: int getWallpaperDesiredMinimumHeight()>,<android.app.ApplicationContext: int getWallpaperDesiredMinimumHeight()>,0,"{
    try {
        return getWallpaperService().getHeightHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}","{
    return getWallpaperManager().getDesiredMinimumHeight();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The old return statement getWallpaperService().getHeightHint() is replaced with a new return statement getWallpaperManager().getDesiredMinimumHeight(). The dependent API changes from getWallpaperService() to getWallpaperManager(). Therefore, the code change type is 1,5.","The return statement changes between the two versions. As a result, this could potentially lead to the API returning different values. Therefore, the CI type is 1."
214,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",4,5,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (LOGV_ENABLED) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event);
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when focus node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeUpdateFocusNode()) {
        FocusNode node = mFocusNode;
        String text = node.mText;
        if (!node.mIsTextField && !node.mIsTextArea && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // special handling in scroll_zoom state
    if (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM) {
        if (KeyEvent.KEYCODE_DPAD_CENTER == keyCode && mTouchMode != SCROLL_ZOOM_ANIMATION_IN) {
            setZoomScrollIn();
            mTouchMode = SCROLL_ZOOM_ANIMATION_IN;
            invalidate();
            return true;
        }
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (commitCopy()) {
            return true;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER || keyCode == KeyEvent.KEYCODE_ENTER) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_ENTER);
        mGotEnterDown = false;
        if (KeyEvent.KEYCODE_DPAD_CENTER == keyCode) {
            if (mShiftIsPressed) {
                return false;
            }
            if (getSettings().supportZoom()) {
                if (mTouchMode == TOUCH_DOUBLECLICK_MODE) {
                    zoomScrollOut();
                } else {
                    if (LOGV_ENABLED) {
                        Log.v(LOGTAG, ""TOUCH_DOUBLECLICK_MODE"");
                    }
                    mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(SWITCH_TO_ENTER), TAP_TIMEOUT);
                    mTouchMode = TOUCH_DOUBLECLICK_MODE;
                }
                return true;
            }
        }
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (nativeUpdateFocusNode()) {
            if (Rect.intersects(mFocusNode.mBounds, visibleRect)) {
                nativeSetFollowedLink(true);
                mWebViewCore.sendMessage(EventHub.SET_FINAL_FOCUS, EventHub.BLOCK_FOCUS_CHANGE_UNTIL_KEY_UP, 0, new WebViewCore.FocusData(mFocusData));
                playSoundEffect(SoundEffectConstants.CLICK);
                if (!mCallbackProxy.uiOverrideUrlLoading(mFocusNode.mText)) {
                    // use CLICK instead of KEY_DOWN/KEY_UP so that we can
                    // trigger mouse click events
                    mWebViewCore.sendMessage(EventHub.CLICK);
                }
            }
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeFocusNodeWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (commitCopy()) {
            return true;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mShiftIsPressed) {
            return false;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        nativeSetFollowedLink(true);
        nativeUpdatePluginReceivesEvents();
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        boolean isTextInput = nativeCursorIsTextInput();
        if (isTextInput || !mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
        }
        if (isTextInput) {
            rebuildWebTextView();
        }
        return true;
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","A lot of code has been changed in the late version including control conditions (control dependency change type 3), Log statements (other statement change type 4), the statements, function calls, variables and return statements ('LOGV_ENABLED' to 'DebugFlags.WEB_VIEW', 'nativeUpdateFocusNode()' to 'nativeHasCursorNode()', 'mFocusNode' to 'data.mFrame' and so on, the change types are 1 and 5).","These changes in condition checks, function calls and return statements potentially bring different variables or exceptions, so the CI type is 1,2."
215,<android.app.Service: void setForeground(boolean)>,4,5,<android.app.Service: void setForeground(boolean)>,<android.app.Service: void setForeground(boolean)>,0,"{
    if (mActivityManager == null) {
        return;
    }
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, isForeground);
    } catch (RemoteException ex) {
    }
}","{
    Log.w(TAG, ""setForeground: ignoring old API call on "" + getClass().getName());
}",1,"/**
 * Control whether this service is considered to be a foreground service.
 * By default services are background, meaning that if the system needs to
 * kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You can set this
 * flag if killing your service would be disruptive to the user: such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * @param isForeground Determines whether this service is considered to
 * be foreground (true) or background (false).
 */
","/**
 * @deprecated This is a now a no-op, use
 * {@link #startForeground(int, Notification)} instead.  This method
 * has been turned into a no-op rather than simply being deprecated
 * because analysis of numerous poorly behaving devices has shown that
 * increasingly often the trouble is being caused in part by applications
 * that are abusing it.  Thus, given a choice between introducing
 * problems in existing applications using this API (by allowing them to
 * be killed when they would like to avoid it), vs allowing the performance
 * of the entire system to be decreased, this method was deemed less
 * important.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The original implementation has been replaced by a logging statement and the original return statement is removed. Hence, the change types are 1 (Return statement changed) and 4 (Other statement changed).","The behavior of the API has changed drastically. In the early version, it was setting service to foreground whereas, in the late version, it just logs a message and doesn't perform any foreground setting. Hence, this could potentially result in different return behavior. The CI type is hence 1 (Compatibility Issue caused by potential different return values or types)."
217,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",4,5,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int initialScrollX = -1, initialScrollY = -1;
    if (event.getAction() == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (event.getAction() == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int x = (int) event.getX();
            int y = (int) event.getY();
            x -= widget.getTotalPaddingLeft();
            y -= widget.getTotalPaddingTop();
            // Clamp the position to inside of the view.
            if (x < 0) {
                x = 0;
            } else if (x >= (widget.getWidth() - widget.getTotalPaddingRight())) {
                x = widget.getWidth() - widget.getTotalPaddingRight() - 1;
            }
            if (y < 0) {
                y = 0;
            } else if (y >= (widget.getHeight() - widget.getTotalPaddingBottom())) {
                y = widget.getHeight() - widget.getTotalPaddingBottom() - 1;
            }
            x += widget.getScrollX();
            y += widget.getScrollY();
            Layout layout = widget.getLayout();
            int line = layout.getLineForVertical(y);
            int off = layout.getOffsetForHorizontal(line, x);
            // XXX should do the same adjust for x as we do for the line.
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            if (cap) {
                Selection.extendSelection(buffer, off);
            } else {
                Selection.setSelection(buffer, off);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1, initialScrollY = -1;
    if (event.getAction() == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (event.getAction() == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int x = (int) event.getX();
            int y = (int) event.getY();
            x -= widget.getTotalPaddingLeft();
            y -= widget.getTotalPaddingTop();
            // Clamp the position to inside of the view.
            if (x < 0) {
                x = 0;
            } else if (x >= (widget.getWidth() - widget.getTotalPaddingRight())) {
                x = widget.getWidth() - widget.getTotalPaddingRight() - 1;
            }
            if (y < 0) {
                y = 0;
            } else if (y >= (widget.getHeight() - widget.getTotalPaddingBottom())) {
                y = widget.getHeight() - widget.getTotalPaddingBottom() - 1;
            }
            x += widget.getScrollX();
            y += widget.getScrollY();
            Layout layout = widget.getLayout();
            int line = layout.getLineForVertical(y);
            int off = layout.getOffsetForHorizontal(line, x);
            // XXX should do the same adjust for x as we do for the line.
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            DoubleTapState[] tap = buffer.getSpans(0, buffer.length(), DoubleTapState.class);
            boolean doubletap = false;
            if (tap.length > 0) {
                if (event.getEventTime() - tap[0].mWhen <= ViewConfiguration.getDoubleTapTimeout()) {
                    if (sameWord(buffer, off, Selection.getSelectionEnd(buffer))) {
                        doubletap = true;
                    }
                }
                tap[0].mWhen = event.getEventTime();
            } else {
                DoubleTapState newtap = new DoubleTapState();
                newtap.mWhen = event.getEventTime();
                buffer.setSpan(newtap, 0, buffer.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
            }
            if (cap) {
                Selection.extendSelection(buffer, off);
            } else if (doubletap) {
                Selection.setSelection(buffer, findWordStart(buffer, off), findWordEnd(buffer, off));
            } else {
                Selection.setSelection(buffer, off);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are other statements added in the latest version to handle double tap and select word, so it is Code change type 4. The control 'if' statement for 'doubletap' has been added, so it is Code change type 3.","These new statements and added control 'if' statement can lead to 'return true' under different conditions, which is a change in its behavior, hence the Compatibility issue type is 1."
218,<android.accessibilityservice.AccessibilityService.IEventListenerWrapper: void executeMessage(Message)>,4,5,<android.accessibilityservice.AccessibilityService.IEventListenerWrapper: void executeMessage(Message)>,<android.accessibilityservice.AccessibilityService.IEventListenerWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ON_ACCESSIBILITY_EVENT:
            AccessibilityEvent event = (AccessibilityEvent) message.obj;
            mTarget.onAccessibilityEvent(event);
            event.recycle();
            return;
        case DO_ON_INTERRUPT:
            mTarget.onInterrupt();
            return;
        case DO_SET_SET_CONNECTION:
            mConnection = ((IAccessibilityServiceConnection) message.obj);
            mTarget.onServiceConnected();
            return;
        default:
            Log.w(LOG_TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ON_ACCESSIBILITY_EVENT:
            AccessibilityEvent event = (AccessibilityEvent) message.obj;
            if (event != null) {
                mTarget.onAccessibilityEvent(event);
                event.recycle();
            }
            return;
        case DO_ON_INTERRUPT:
            mTarget.onInterrupt();
            return;
        case DO_SET_SET_CONNECTION:
            mConnection = ((IAccessibilityServiceConnection) message.obj);
            mTarget.onServiceConnected();
            return;
        default:
            Log.w(LOG_TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The 'if (event != null)' condition check has been introduced in the late version inside the 'case DO_ON_ACCESSIBILITY_EVENT' of the switch statement, so the change type is 3.","As a new conditional check has been introduced, the implementation of this method in the later version may not execute the statements 'mTarget.onAccessibilityEvent(event); event.recycle();', which could previously always execute in early version. Therefore, the API could potentially yeild different behavior, the CI type is 1."
219,"<android.webkit.WebView: void onChildViewRemoved(View,View)>",4,5,"<android.webkit.WebView: void onChildViewRemoved(View,View)>","<android.webkit.WebView: void onChildViewRemoved(View,View)>",0,"{
    if (child == this) {
        if (inEditingMode()) {
            clearTextEntry();
            mNeedsUpdateTextEntry = true;
        }
    }
}","{
    if (child == this) {
        clearTextEntry();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control dependency in this method changed. More specifically, the condition 'inEditingMode()' was removed, hence the classification is 3.","Although the control condition was removed, it doesn't have an impact on the return value or the exceptions thrown by the method. Therefore, there is no Compatibility Issue."
220,<android.widget.VideoView: int getCurrentPosition()>,4,5,<android.widget.VideoView: int getCurrentPosition()>,<android.widget.VideoView: int getCurrentPosition()>,0,"{
    if (mMediaPlayer != null && mIsPrepared) {
        return mMediaPlayer.getCurrentPosition();
    }
    return 0;
}","{
    if (isInPlaybackState()) {
        return mMediaPlayer.getCurrentPosition();
    }
    return 0;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The condition in the 'if' statement has changed from 'mMediaPlayer != null && mIsPrepared' to 'isInPlaybackState()', and the dependent API isInPlaybackState() is introduced, so the change type is 3,5.","The condition of 'if' statement has changed, so the returned value of the API (either mMediaPlayer.getCurrentPosition() or 0) can be different under some instances. Therefore, this change can potentially lead to a Compatibility Issue, and the CI type is 1."
223,<android.widget.VideoView: boolean onTrackballEvent(MotionEvent)>,4,5,<android.widget.VideoView: boolean onTrackballEvent(MotionEvent)>,<android.widget.VideoView: boolean onTrackballEvent(MotionEvent)>,0,"{
    if (mIsPrepared && mMediaPlayer != null && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return false;
}","{
    if (isInPlaybackState() && mMediaController != null) {
        toggleMediaControlsVisiblity();
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"1. The method invoked in the control statement, i.e., mIsPrepared && mMediaPlayer != null, has been changed to isInPlaybackState().",
224,<android.content.SyncManager.SyncHandler: long insertStartSyncEvent(SyncOperation)>,4,5,<android.content.SyncManager.SyncHandler: long insertStartSyncEvent(SyncOperation)>,<android.content.SyncManager.SyncHandler: long insertStartSyncEvent(SyncOperation)>,0,"{
    final int source = syncOperation.syncSource;
    final long now = System.currentTimeMillis();
    EventLog.writeEvent(2720, syncOperation.authority, SyncStorageEngine.EVENT_START, source);
    return mSyncStorageEngine.insertStartSyncEvent(syncOperation.account, syncOperation.authority, now, source);
}","{
    final int source = syncOperation.syncSource;
    final long now = System.currentTimeMillis();
    EventLog.writeEvent(2720, syncOperation.authority, SyncStorageEngine.EVENT_START, source, syncOperation.account.name.hashCode());
    return mSyncStorageEngine.insertStartSyncEvent(syncOperation.account, syncOperation.authority, now, source);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change has occurred in the EventLog.writeEvent API, where a new parameter syncOperation.account.name.hashCode() has been added. So the code change type is 4.","The change doesn't result in any compatibility issue. Although a new parameter was added to the writeEvent method, it doesn't change what the insertStartSyncEvent API potentially returns or the exceptions it potentially throws. Thus, the CI type is 0."
225,"<android.webkit.WebView: void onFocusChanged(boolean,int,Rect)>",4,5,"<android.webkit.WebView: void onFocusChanged(boolean,int,Rect)>","<android.webkit.WebView: void onFocusChanged(boolean,int,Rect)>",0,"{
    if (LOGV_ENABLED) {
        Log.v(LOGTAG, ""MT focusChanged "" + focused + "", "" + direction);
    }
    if (focused) {
        // the focus ring, and add the TextView if necessary.
        if (hasWindowFocus()) {
            mDrawFocusRing = true;
            if (mNeedsUpdateTextEntry) {
                updateTextEntry();
                mNeedsUpdateTextEntry = false;
            }
            if (mNativeClass != 0) {
                nativeRecordButtons(true, false, true);
            }
        // } else {
        // The WebView has gained focus while we do not have
        // windowfocus.  When our window lost focus, we should have
        // called nativeRecordButtons(false...)
        }
    } else {
        // true if we are in editing mode), stop drawing the focus ring.
        if (!inEditingMode()) {
            mDrawFocusRing = false;
            if (mNativeClass != 0) {
                nativeRecordButtons(false, false, true);
            }
        }
        mGotKeyDown = false;
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""MT focusChanged "" + focused + "", "" + direction);
    }
    if (focused) {
        // the cursor ring
        if (hasWindowFocus()) {
            mDrawCursorRing = true;
            if (mNativeClass != 0) {
                nativeRecordButtons(true, false, true);
            }
        // } else {
        // The WebView has gained focus while we do not have
        // windowfocus.  When our window lost focus, we should have
        // called nativeRecordButtons(false...)
        }
    } else {
        // true if we are in editing mode), stop drawing the cursor ring.
        if (!inEditingMode()) {
            mDrawCursorRing = false;
            if (mNativeClass != 0) {
                nativeRecordButtons(false, false, true);
            }
            setFocusControllerInactive();
        }
        mGotKeyDown = false;
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The variable name 'mDrawFocusRing' in if statements under both if(focused) and else sections in the early version has been changed to 'mDrawCursorRing' in the late version, and a new function setFocusControllerInactive() is added in else section. Therefore, the code change type is 1,4.","Changing the variable from 'mDrawFocusRing' to 'mDrawCursorRing' and adding new function setFocusControllerInactive() can potentially change the behavior of this API, possibly leading to different return situations. Therefore, the CI type is 1."
226,<android.webkit.URLUtil: String guessUrl(String)>,4,5,<android.webkit.URLUtil: String guessUrl(String)>,<android.webkit.URLUtil: String guessUrl(String)>,0,"{
    String retVal = inUrl;
    WebAddress webAddress;
    Log.v(LOGTAG, ""guessURL before queueRequest: "" + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith(""about:""))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith(""data:""))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith(""file:""))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith(""javascript:""))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(""."") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (WebView.LOGV_ENABLED) {
            Log.v(LOGTAG, ""smartUrlFilter: failed to parse url = "" + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.mHost.indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.mHost = ""www."" + webAddress.mHost + "".com"";
    }
    return webAddress.toString();
}","{
    String retVal = inUrl;
    WebAddress webAddress;
    Log.v(LOGTAG, ""guessURL before queueRequest: "" + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith(""about:""))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith(""data:""))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith(""file:""))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith(""javascript:""))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(""."") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (DebugFlags.URL_UTIL) {
            Log.v(LOGTAG, ""smartUrlFilter: failed to parse url = "" + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.mHost.indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.mHost = ""www."" + webAddress.mHost + "".com"";
    }
    return webAddress.toString();
}",1,"/**
 * Cleans up (if possible) user-entered web addresses
 */
","/**
 * Cleans up (if possible) user-entered web addresses
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The conditional check for debug flag has been changed from ""WebView.LOGV_ENABLED"" to ""DebugFlags.URL_UTIL"" in Exception handling statement. So, the code change type is 4.","This change is just for debug logging and it could not affect the API behavior in terms of returning different value or throwing different exception. Thus, no compatibility issue exists, so the CI type is 0."
227,"<android.provider.Contacts.ContactMethods: CharSequence getDisplayLabel(Context,int,int,CharSequence)>",4,5,"<android.provider.Contacts.ContactMethods: CharSequence getDisplayLabel(Context,int,int,CharSequence)>","<android.provider.Contacts.ContactMethods: CharSequence getDisplayLabel(Context,int,int,CharSequence)>",0,"{
    CharSequence display = """";
    switch(kind) {
        case KIND_EMAIL:
            {
                if (type != People.ContactMethods.TYPE_CUSTOM) {
                    CharSequence[] labels = context.getResources().getTextArray(com.android.internal.R.array.emailAddressTypes);
                    try {
                        display = labels[type - 1];
                    } catch (ArrayIndexOutOfBoundsException e) {
                        display = labels[ContactMethods.TYPE_HOME - 1];
                    }
                } else {
                    if (!TextUtils.isEmpty(label)) {
                        if (label.toString().equals(MOBILE_EMAIL_TYPE_NAME)) {
                            display = context.getString(com.android.internal.R.string.mobileEmailTypeName);
                        } else {
                            display = label;
                        }
                    }
                }
                break;
            }
        case KIND_POSTAL:
            {
                if (type != People.ContactMethods.TYPE_CUSTOM) {
                    CharSequence[] labels = context.getResources().getTextArray(com.android.internal.R.array.postalAddressTypes);
                    try {
                        display = labels[type - 1];
                    } catch (ArrayIndexOutOfBoundsException e) {
                        display = labels[ContactMethods.TYPE_HOME - 1];
                    }
                } else {
                    if (!TextUtils.isEmpty(label)) {
                        display = label;
                    }
                }
                break;
            }
        default:
            display = context.getString(R.string.untitled);
    }
    return display;
}","{
    CharSequence display = """";
    switch(kind) {
        case KIND_EMAIL:
            {
                if (type != People.ContactMethods.TYPE_CUSTOM) {
                    CharSequence[] labels = context.getResources().getTextArray(com.android.internal.R.array.emailAddressTypes);
                    try {
                        display = labels[type - 1];
                    } catch (ArrayIndexOutOfBoundsException e) {
                        display = labels[ContactMethods.TYPE_HOME - 1];
                    }
                } else {
                    if (!TextUtils.isEmpty(label)) {
                        display = label;
                    }
                }
                break;
            }
        case KIND_POSTAL:
            {
                if (type != People.ContactMethods.TYPE_CUSTOM) {
                    CharSequence[] labels = context.getResources().getTextArray(com.android.internal.R.array.postalAddressTypes);
                    try {
                        display = labels[type - 1];
                    } catch (ArrayIndexOutOfBoundsException e) {
                        display = labels[ContactMethods.TYPE_HOME - 1];
                    }
                } else {
                    if (!TextUtils.isEmpty(label)) {
                        display = label;
                    }
                }
                break;
            }
        default:
            display = context.getString(R.string.untitled);
    }
    return display;
}",1,,"/**
 * @deprecated see {@link android.provider.ContactsContract}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,1,The condition checking for 'label.toString().equals(MOBILE_EMAIL_TYPE_NAME)' and corresponding action is removed from the implementation in the late version which is considered under 'Other statement changed'.,"The if statement changes the value of 'display' when 'label.toString().equals(MOBILE_EMAIL_TYPE_NAME)' is true. This statement is removed in the later version which will result a different behavior when 'label.toString().equals(MOBILE_EMAIL_TYPE_NAME)' is true. Therefore, there is a compatibility issue caused by potential different return values."
228,"<android.provider.Browser: void sendString(Context,String)>",4,5,"<android.provider.Browser: void sendString(Context,String)>","<android.provider.Browser: void sendString(Context,String)>",0,"{
    Intent send = new Intent(Intent.ACTION_SEND);
    send.setType(""text/plain"");
    send.putExtra(Intent.EXTRA_TEXT, s);
    try {
        c.startActivity(Intent.createChooser(send, c.getText(com.android.internal.R.string.sendText)));
    } catch (android.content.ActivityNotFoundException ex) {
    // if no app handles it, do nothing
    }
}","{
    sendString(c, s, c.getText(com.android.internal.R.string.sendText).toString());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation of the method has been changed. The initial implementation consists of creating an Intent and starting an activity. In the later version, this has been replaced by a call to the sendString method with three parameters. So, the code change type is (1) Return Statement Changed, (4) Other Statement Changed, and (5) Dependent API Changed.","The complete change in implementation may potentially lead to a different behavior, as the sendString method called in the later version could potentially have a different implementation than the initial version, hence the CI type is (1) Compatibility Issue caused by potential different return values or types."
229,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>",4,5,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>","<android.content.res.Configuration: void writeToParcel(Parcel,int)>",0,"{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
}","{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late implementation, there is only one extra 'dest.writeInt(navigationHidden);' statement, so the change type is 4.","The extra 'dest.writeInt(navigationHidden);' statement won't affect the potential behavior of the API, thus there is no Compatibility Issue."
230,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,4,5,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null)
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null)
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            if (mPreviewCallback != null) {
                mPreviewCallback.onPreviewFrame((byte[]) msg.obj, mCamera);
                if (mOneShot) {
                    mPreviewCallback = null;
                }
            }
            return;
        case CAMERA_MSG_FOCUS:
            if (mAutoFocusCallback != null)
                mAutoFocusCallback.onAutoFocus(msg.arg1 == 0 ? false : true, mCamera);
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null)
                mErrorCallback.onError(msg.arg1, mCamera);
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}","{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            if (mPreviewCallback != null) {
                PreviewCallback cb = mPreviewCallback;
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, true);
                }
                cb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            if (mAutoFocusCallback != null) {
                mAutoFocusCallback.onAutoFocus(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomCallback != null) {
                mZoomCallback.onZoomUpdate(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The switch clause has been modified to include two new case distinctions (CAMERA_MSG_POSTVIEW_FRAME and CAMERA_MSG_ZOOM). There are also more if-else conditions inside CAMERA_MSG_PREVIEW_FRAME, so the code change type is 3.","However, all these changes would not cause potential different return variables or potential different exceptions. There are no returns except the clause returns that do not return any value, and no thrown exceptions. Thus, there was no Compatibility Issue, the CI type is 0."
231,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,4,5,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,<android.webkit.WebViewDatabase: WebViewDatabase getInstance(Context)>,0,"{
    if (mInstance == null) {
        mInstance = new WebViewDatabase();
        mDatabase = context.openOrCreateDatabase(DATABASE_FILE, 0, null);
        // the only case is RequestAPI test has problem to create db
        if (mDatabase != null && mDatabase.getVersion() != DATABASE_VERSION) {
            mDatabase.beginTransaction();
            try {
                upgradeDatabase();
                mDatabase.setTransactionSuccessful();
            } finally {
                mDatabase.endTransaction();
            }
        }
        if (mDatabase != null) {
            // use per table Mutex lock, turn off database lock, this
            // improves performance as database's ReentrantLock is expansive
            mDatabase.setLockingEnabled(false);
        }
        mCacheDatabase = context.openOrCreateDatabase(CACHE_DATABASE_FILE, 0, null);
        // the only case is RequestAPI test has problem to create db
        if (mCacheDatabase != null && mCacheDatabase.getVersion() != CACHE_DATABASE_VERSION) {
            mCacheDatabase.beginTransaction();
            try {
                upgradeCacheDatabase();
                bootstrapCacheDatabase();
                mCacheDatabase.setTransactionSuccessful();
            } finally {
                mCacheDatabase.endTransaction();
            }
            // Erase the files from the file system in the
            // case that the database was updated and the
            // there were existing cache content
            CacheManager.removeAllCacheFiles();
        }
        if (mCacheDatabase != null) {
            // use InsertHelper for faster insertion
            mCacheInserter = new DatabaseUtils.InsertHelper(mCacheDatabase, ""cache"");
            mCacheUrlColIndex = mCacheInserter.getColumnIndex(CACHE_URL_COL);
            mCacheFilePathColIndex = mCacheInserter.getColumnIndex(CACHE_FILE_PATH_COL);
            mCacheLastModifyColIndex = mCacheInserter.getColumnIndex(CACHE_LAST_MODIFY_COL);
            mCacheETagColIndex = mCacheInserter.getColumnIndex(CACHE_ETAG_COL);
            mCacheExpiresColIndex = mCacheInserter.getColumnIndex(CACHE_EXPIRES_COL);
            mCacheMimeTypeColIndex = mCacheInserter.getColumnIndex(CACHE_MIMETYPE_COL);
            mCacheEncodingColIndex = mCacheInserter.getColumnIndex(CACHE_ENCODING_COL);
            mCacheHttpStatusColIndex = mCacheInserter.getColumnIndex(CACHE_HTTP_STATUS_COL);
            mCacheLocationColIndex = mCacheInserter.getColumnIndex(CACHE_LOCATION_COL);
            mCacheContentLengthColIndex = mCacheInserter.getColumnIndex(CACHE_CONTENTLENGTH_COL);
        }
    }
    return mInstance;
}","{
    if (mInstance == null) {
        mInstance = new WebViewDatabase();
        mDatabase = context.openOrCreateDatabase(DATABASE_FILE, 0, null);
        // the only case is RequestAPI test has problem to create db
        if (mDatabase != null && mDatabase.getVersion() != DATABASE_VERSION) {
            mDatabase.beginTransaction();
            try {
                upgradeDatabase();
                mDatabase.setTransactionSuccessful();
            } finally {
                mDatabase.endTransaction();
            }
        }
        if (mDatabase != null) {
            // use per table Mutex lock, turn off database lock, this
            // improves performance as database's ReentrantLock is expansive
            mDatabase.setLockingEnabled(false);
        }
        mCacheDatabase = context.openOrCreateDatabase(CACHE_DATABASE_FILE, 0, null);
        // the only case is RequestAPI test has problem to create db
        if (mCacheDatabase != null && mCacheDatabase.getVersion() != CACHE_DATABASE_VERSION) {
            mCacheDatabase.beginTransaction();
            try {
                upgradeCacheDatabase();
                bootstrapCacheDatabase();
                mCacheDatabase.setTransactionSuccessful();
            } finally {
                mCacheDatabase.endTransaction();
            }
            // Erase the files from the file system in the
            // case that the database was updated and the
            // there were existing cache content
            CacheManager.removeAllCacheFiles();
        }
        if (mCacheDatabase != null) {
            // use InsertHelper for faster insertion
            mCacheInserter = new DatabaseUtils.InsertHelper(mCacheDatabase, ""cache"");
            mCacheUrlColIndex = mCacheInserter.getColumnIndex(CACHE_URL_COL);
            mCacheFilePathColIndex = mCacheInserter.getColumnIndex(CACHE_FILE_PATH_COL);
            mCacheLastModifyColIndex = mCacheInserter.getColumnIndex(CACHE_LAST_MODIFY_COL);
            mCacheETagColIndex = mCacheInserter.getColumnIndex(CACHE_ETAG_COL);
            mCacheExpiresColIndex = mCacheInserter.getColumnIndex(CACHE_EXPIRES_COL);
            mCacheExpiresStringColIndex = mCacheInserter.getColumnIndex(CACHE_EXPIRES_STRING_COL);
            mCacheMimeTypeColIndex = mCacheInserter.getColumnIndex(CACHE_MIMETYPE_COL);
            mCacheEncodingColIndex = mCacheInserter.getColumnIndex(CACHE_ENCODING_COL);
            mCacheHttpStatusColIndex = mCacheInserter.getColumnIndex(CACHE_HTTP_STATUS_COL);
            mCacheLocationColIndex = mCacheInserter.getColumnIndex(CACHE_LOCATION_COL);
            mCacheContentLengthColIndex = mCacheInserter.getColumnIndex(CACHE_CONTENTLENGTH_COL);
            mCacheContentDispositionColIndex = mCacheInserter.getColumnIndex(CACHE_CONTENTDISPOSITION_COL);
        }
    }
    return mInstance;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"In the later version of the code, two new lines of statements are coded to acquire column indexes of the SQLite database. These two new lines cause a slight change in the execution track of the entire method but do not change the ultimate return of this method and do not present exception condition, so the change type is 1,4.","The return variable 'mInstance' remains the same in both the early and the later versions of the code despite the extra lines of codes in the later version. Therefore, no compatibility issues exist."
232,<android.webkit.WebView: void requestFocusNodeHref(Message)>,4,5,<android.webkit.WebView: void requestFocusNodeHref(Message)>,<android.webkit.WebView: void requestFocusNodeHref(Message)>,0,"{
    if (hrefMsg == null || mNativeClass == 0) {
        return;
    }
    if (nativeUpdateFocusNode()) {
        FocusNode node = mFocusNode;
        if (node.mIsAnchor) {
            // NOTE: We may already have the url of the anchor stored in
            // node.mText but it may be out of date or the caller may want
            // to know about javascript urls.
            mWebViewCore.sendMessage(EventHub.REQUEST_FOCUS_HREF, node.mFramePointer, node.mNodePointer, hrefMsg);
        }
    }
}","{
    if (hrefMsg == null || mNativeClass == 0) {
        return;
    }
    if (nativeCursorIsAnchor()) {
        mWebViewCore.sendMessage(EventHub.REQUEST_CURSOR_HREF, nativeCursorFramePointer(), nativeCursorNodePointer(), hrefMsg);
    }
}",1,"/**
 * Request the href of an anchor element due to getFocusNodePath returning
 * ""href."" If hrefMsg is null, this method returns immediately and does not
 * dispatch hrefMsg to its target.
 *
 * @param hrefMsg This message will be dispatched with the result of the
 * request as the data member with ""url"" as key. The result can
 * be null.
 */
","// getFocusNodePath?
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement is related to a different function (nativeUpdateFocusNode() -> nativeCursorIsAnchor()) in the if statement. The dependent API (nativeUpdateFocusNode(), mFocusNode, node.mIsAnchor, node.mFramePointer, node.mNodePointer) and the sendMessage API (REQUEST_FOCUS_HREF -> REQUEST_CURSOR_HREF, nativeCursorFramePointer(), nativeCursorNodePointer()) have also changed. Therefore, the code change type is 1,4,5.","As the method invocation and parameters of sendMessage() has changed along with the changes of the condition of execution. Therefore, the API may return differently in certain scenarios, so the CI type is 1."
234,<android.app.ApplicationContext: Drawable peekWallpaper()>,4,5,<android.app.ApplicationContext: Drawable peekWallpaper()>,<android.app.ApplicationContext: Drawable peekWallpaper()>,0,"{
    if (mWallpaper != null) {
        return mWallpaper;
    }
    mWallpaperCallback = new WallpaperCallback(this);
    mWallpaper = getCurrentWallpaperLocked();
    return mWallpaper;
}","{
    return getWallpaperManager().peekDrawable();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statements in the code have changed along with the dependent API (getCurrentWallpaperLocked() to getWallpaperManager().peekDrawable()). This makes a code change type of 1,5.","As the return statement and dependent API have both changed in the late version, it means the potential return values may also change. This causes a compatibility issue of type 1."
235,"<android.app.ApplicationErrorReport.CrashInfo: void dump(Printer,String)>",4,5,"<android.app.ApplicationErrorReport.CrashInfo: void dump(Printer,String)>","<android.app.ApplicationErrorReport.CrashInfo: void dump(Printer,String)>",0,"{
    pw.println(prefix + ""exceptionClassName: "" + exceptionClassName);
    pw.println(prefix + ""exceptionMessage: "" + exceptionMessage);
    pw.println(prefix + ""throwFileName: "" + throwFileName);
    pw.println(prefix + ""throwClassName: "" + throwClassName);
    pw.println(prefix + ""throwMethodName: "" + throwMethodName);
    pw.println(prefix + ""stackTrace: "" + stackTrace);
}","{
    pw.println(prefix + ""exceptionClassName: "" + exceptionClassName);
    pw.println(prefix + ""exceptionMessage: "" + exceptionMessage);
    pw.println(prefix + ""throwFileName: "" + throwFileName);
    pw.println(prefix + ""throwClassName: "" + throwClassName);
    pw.println(prefix + ""throwMethodName: "" + throwMethodName);
    pw.println(prefix + ""throwLineNumber: "" + throwLineNumber);
    pw.println(prefix + ""stackTrace: "" + stackTrace);
}",1,"/**
 * Dump a CrashInfo instance to a Printer.
 */
","/**
 * Dump a CrashInfo instance to a Printer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new function call (pw.println(prefix + ""throwLineNumber: "" + throwLineNumber);) is added in the Late_Version, hence the code change type is categorised as 4 (Other statement changed).","However, this added function call doesn't change the behaviour of the function dump. It just provides more details about the error but doesn't lead to a different return value or throw an exception. Thus, there is no Compatibility Issue (CI)."
238,<android.view.MotionEvent: float getX()>,4,5,<android.view.MotionEvent: float getX()>,<android.view.MotionEvent: float getX()>,0,"{
    return mX;
}","{
    return mDataSamples[SAMPLE_X];
}",1,"/**
 * Returns the X coordinate of this event.  Whole numbers are pixels; the
 * value may have a fraction for input devices that are sub-pixel precise.
 */
","/**
 * {@link #getX(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mX;' to 'return mDataSamples[SAMPLE_X];', so the code change type is 1.","The change in return statement could lead to potentially different return values, hence the CI type is 1."
240,"<android.webkit.CacheManager: CacheResult createCacheFile(String,int,Headers,String,boolean)>",4,5,"<android.webkit.CacheManager: CacheResult createCacheFile(String,int,Headers,String,boolean)>","<android.webkit.CacheManager: CacheResult createCacheFile(String,int,Headers,String,boolean)>",0,"{
    if (!forceCache && mDisabled) {
        return null;
    }
    // according to the rfc 2616, the 303 response MUST NOT be cached.
    if (statusCode == 303) {
        return null;
    }
    // header.
    if (checkCacheRedirect(statusCode) && !headers.getSetCookie().isEmpty()) {
        return null;
    }
    CacheResult ret = parseHeaders(statusCode, headers, mimeType);
    if (ret != null) {
        setupFiles(url, ret);
        try {
            ret.outStream = new FileOutputStream(ret.outFile);
        } catch (FileNotFoundException e) {
            // subdirectory has gone, so lets try to create it again
            if (createCacheDirectory()) {
                try {
                    ret.outStream = new FileOutputStream(ret.outFile);
                } catch (FileNotFoundException e2) {
                    // is something else wrong. Return null.
                    return null;
                }
            } else {
                // Failed to create cache directory
                return null;
            }
        }
        ret.mimeType = mimeType;
    }
    return ret;
}","{
    if (!forceCache && mDisabled) {
        return null;
    }
    // according to the rfc 2616, the 303 response MUST NOT be cached.
    if (statusCode == 303) {
        // remove the saved cache if there is any
        mDataBase.removeCache(url);
        return null;
    }
    // header.
    if (checkCacheRedirect(statusCode) && !headers.getSetCookie().isEmpty()) {
        // remove the saved cache if there is any
        mDataBase.removeCache(url);
        return null;
    }
    CacheResult ret = parseHeaders(statusCode, headers, mimeType);
    if (ret == null) {
        // this should only happen if the headers has ""no-store"" in the
        // cache-control. remove the saved cache if there is any
        mDataBase.removeCache(url);
    } else {
        setupFiles(url, ret);
        try {
            ret.outStream = new FileOutputStream(ret.outFile);
        } catch (FileNotFoundException e) {
            // subdirectory has gone, so lets try to create it again
            if (createCacheDirectory()) {
                try {
                    ret.outStream = new FileOutputStream(ret.outFile);
                } catch (FileNotFoundException e2) {
                    // is something else wrong. Return null.
                    return null;
                }
            } else {
                // Failed to create cache directory
                return null;
            }
        }
        ret.mimeType = mimeType;
    }
    return ret;
}",1,"// can be called from any thread
","// only called from WebCore thread
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, extra mDataBase.removeCache(url) statements are added in each if condition. Thus the change type is 4 (other statement changed).","Whilst there is a change in the method, none of the changes impact the returned values or thrown exceptions of the function. As such, there exist no compatibility issues."
242,<android.os.Vibrator: void vibrate(long)>,4,5,<android.os.Vibrator: void vibrate(long)>,<android.os.Vibrator: void vibrate(long)>,0,"{
    try {
        mService.vibrate(milliseconds);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.vibrate(milliseconds, mToken);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Turn the vibrator on.
 *
 * @param milliseconds How long to vibrate for.
 */
","/**
 * Turn the vibrator on.
 *
 * @param milliseconds How long to vibrate for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API 'mService.vibrate' method has changed, it now takes an additional parameter, mToken. Hence, the code change type is 5.","Although the dependent API 'mService.vibrate' method changed, it doesn't change the return value or exception handling of the method 'vibrate(long)', therefore no Compatibility Issue exists. The CI type is 0."
243,"<android.content.Intent: ActivityInfo resolveActivityInfo(PackageManager,int)>",4,5,"<android.content.Intent: ActivityInfo resolveActivityInfo(PackageManager,int)>","<android.content.Intent: ActivityInfo resolveActivityInfo(PackageManager,int)>",0,"{
    ActivityInfo ai = null;
    if (mComponent != null) {
        try {
            ai = pm.getActivityInfo(mComponent, flags);
        } catch (PackageManager.NameNotFoundException e) {
        // ignore
        }
    } else {
        ResolveInfo info = pm.resolveActivity(this, PackageManager.MATCH_DEFAULT_ONLY);
        if (info != null) {
            ai = info.activityInfo;
        }
    }
    return ai;
}","{
    ActivityInfo ai = null;
    if (mComponent != null) {
        try {
            ai = pm.getActivityInfo(mComponent, flags);
        } catch (PackageManager.NameNotFoundException e) {
        // ignore
        }
    } else {
        ResolveInfo info = pm.resolveActivity(this, PackageManager.MATCH_DEFAULT_ONLY | flags);
        if (info != null) {
            ai = info.activityInfo;
        }
    }
    return ai;
}",1,"/**
 * Resolve the Intent into an {@link ActivityInfo}
 * describing the activity that should execute the intent.  Resolution
 * follows the same rules as described for {@link #resolveActivity}, but
 * you get back the completely information about the resolved activity
 * instead of just its class name.
 *
 * @param pm The package manager with which to resolve the Intent.
 * @param flags Addition information to retrieve as per
 * {@link PackageManager#getActivityInfo(ComponentName, int)
 * PackageManager.getActivityInfo()}.
 *
 * @return PackageManager.ActivityInfo
 *
 * @see #resolveActivity
 */
","/**
 * Resolve the Intent into an {@link ActivityInfo}
 * describing the activity that should execute the intent.  Resolution
 * follows the same rules as described for {@link #resolveActivity}, but
 * you get back the completely information about the resolved activity
 * instead of just its class name.
 *
 * @param pm The package manager with which to resolve the Intent.
 * @param flags Addition information to retrieve as per
 * {@link PackageManager#getActivityInfo(ComponentName, int)
 * PackageManager.getActivityInfo()}.
 *
 * @return PackageManager.ActivityInfo
 *
 * @see #resolveActivity
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The change is that the flags were added as a parameter when calling the method pm.resolveActivity(this, PackageManager.MATCH_DEFAULT_ONLY | flags) in the late implementation. So, the code change type is 4.","This change might make the method pm.resolveActivity return different values, thereby changing the value and type of the returned by resolveActivityInfo method. So, the CI type is 1."
245,<android.hardware.Camera.Parameters: int getPreviewFrameRate()>,4,5,<android.hardware.Camera.Parameters: int getPreviewFrameRate()>,<android.hardware.Camera.Parameters: int getPreviewFrameRate()>,0,"{
    return getInt(""preview-frame-rate"");
}","{
    return getInt(KEY_PREVIEW_FRAME_RATE);
}",1,"/**
 * Returns the setting for the rate at which preview frames
 * are received.
 *
 * @return the frame rate setting (frames per second)
 */
","/**
 * Returns the setting for the rate at which preview frames
 * are received.
 *
 * @return the frame rate setting (frames per second)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getInt(""preview-frame-rate"") to getInt(KEY_PREVIEW_FRAME_RATE) and the parameter of getInt() also changed, so the code change types are 1,5.","The change of return statement will make the API potentially return a different value, hence the CI type is 1."
246,<android.webkit.WebView: void shortPressOnTextField()>,4,5,<android.webkit.WebView: void shortPressOnTextField()>,<android.webkit.WebView: void shortPressOnTextField()>,0,"{
    if (inEditingMode()) {
        View v = mTextEntry;
        int x = viewToContent((v.getLeft() + v.getRight()) >> 1);
        int y = viewToContent((v.getTop() + v.getBottom()) >> 1);
        nativeMotionUp(x, y, mNavSlop, true);
    }
}","{
    if (inEditingMode()) {
        View v = mWebTextView;
        int x = viewToContentX((v.getLeft() + v.getRight()) >> 1);
        int y = viewToContentY((v.getTop() + v.getBottom()) >> 1);
        nativeTextInputMotionUp(x, y);
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"There are several changes in the implementation of the method between the two versions. The variable 'mTextEntry' was replaced by 'mWebTextView', 'viewToContent' was replaced by 'viewToContentX' and 'viewToContentY', and 'nativeMotionUp(x, y, mNavSlop, true)' was replaced by 'nativeTextInputMotionUp(x, y)'. So the code change types are 1, 4, 5.","As the method 'nativeMotionUp' is replaced by 'nativeTextInputMotionUp', and they have different arguments, the return value or throw from these two methods can be different, so the CI type is 1."
247,<android.widget.GridView: boolean fullScroll(int)>,4,5,<android.widget.GridView: boolean fullScroll(int)>,<android.widget.GridView: boolean fullScroll(int)>,0,"{
    boolean moved = false;
    if (direction == FOCUS_UP) {
        mLayoutMode = LAYOUT_SET_SELECTION;
        setSelectionInt(0);
        invokeOnItemScrollListener();
        moved = true;
    } else if (direction == FOCUS_DOWN) {
        mLayoutMode = LAYOUT_SET_SELECTION;
        setSelectionInt(mItemCount - 1);
        invokeOnItemScrollListener();
        moved = true;
    }
    return moved;
}","{
    boolean moved = false;
    if (direction == FOCUS_UP) {
        mLayoutMode = LAYOUT_SET_SELECTION;
        setSelectionInt(0);
        invokeOnItemScrollListener();
        moved = true;
    } else if (direction == FOCUS_DOWN) {
        mLayoutMode = LAYOUT_SET_SELECTION;
        setSelectionInt(mItemCount - 1);
        invokeOnItemScrollListener();
        moved = true;
    }
    if (moved) {
        awakenScrollBars();
    }
    return moved;
}",1,"/**
 * Go to the last or first item if possible.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}.
 *
 * @return Whether selection was moved.
 */
","/**
 * Go to the last or first item if possible.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}.
 *
 * @return Whether selection was moved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement awakenScrollBars() is introduced in the late version, so the code change type is 4.","Despite the added statement, it will not influence the return value of the method and also it does not throw a new exception, so no compatibility issue exists. The CI type is 0."
248,<android.pim.ContactsAsyncHelper.ImageTracker: Uri getPhotoUri()>,4,5,<android.pim.ContactsAsyncHelper.ImageTracker: Uri getPhotoUri()>,<android.pim.ContactsAsyncHelper.ImageTracker: Uri getPhotoUri()>,0,"{
    if (mCurrentCallerInfo != null) {
        return ContentUris.withAppendedId(People.CONTENT_URI, mCurrentCallerInfo.person_id);
    }
    return null;
}","{
    if (mCurrentCallerInfo != null) {
        return ContentUris.withAppendedId(Contacts.CONTENT_URI, mCurrentCallerInfo.person_id);
    }
    return null;
}",1,"/**
 * Convenience method used to retrieve the URI
 * representing the Photo file recorded in the attached
 * CallerInfo Object.
 */
","/**
 * Convenience method used to retrieve the URI
 * representing the Photo file recorded in the attached
 * CallerInfo Object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The dependent API in the return statement is changed from `People.CONTENT_URI` to `Contacts.CONTENT_URI`. This represents a type 1 (Return statement changed) and a type 5 (Dependent API changed).,"The returned Uri in the late version would result in a different location due to change of dependent API, which has the potential to cause compatibility issues of type 1 (Compatibility Issue caused by different return values or types)."
251,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,4,5,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,0,"{
    boolean opaque = true;
    if ((mPrivateFlags & SKIP_DRAW) == 0) {
        // this view draws, remove it from the transparent region
        opaque = super.gatherTransparentRegion(region);
    } else if (region != null) {
        int w = getWidth();
        int h = getHeight();
        if (w > 0 && h > 0) {
            getLocationInWindow(mLocation);
            // otherwise, punch a hole in the whole hierarchy
            int l = mLocation[0];
            int t = mLocation[1];
            region.op(l, t, l + w, t + h, Region.Op.UNION);
        }
    }
    if (PixelFormat.formatHasAlpha(mRequestedFormat)) {
        opaque = false;
    }
    return opaque;
}","{
    if (mWindowType == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
        return super.gatherTransparentRegion(region);
    }
    boolean opaque = true;
    if ((mPrivateFlags & SKIP_DRAW) == 0) {
        // this view draws, remove it from the transparent region
        opaque = super.gatherTransparentRegion(region);
    } else if (region != null) {
        int w = getWidth();
        int h = getHeight();
        if (w > 0 && h > 0) {
            getLocationInWindow(mLocation);
            // otherwise, punch a hole in the whole hierarchy
            int l = mLocation[0];
            int t = mLocation[1];
            region.op(l, t, l + w, t + h, Region.Op.UNION);
        }
    }
    if (PixelFormat.formatHasAlpha(mRequestedFormat)) {
        opaque = false;
    }
    return opaque;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"In the early version of the implementation, there is no initial condition. However, in the late version of the implementation, there is an initial if condition at the beginning. Therefore, the code change can be categorized as 'Control dependency change' (type 3).","The new added condition potentially results in a different return value of the function, either the function returns the result from super.gatherTransparentRegion(region) or continues to execute the following code. Therefore, the Compatibility issue could be 'Compatibility Issue caused by potential different return values' (type 1)."
253,<android.appwidget.AppWidgetHostView: View getDefaultView()>,4,5,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContext(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED);
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            defaultView = inflater.inflate(mInfo.initialLayout, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null && LOGD) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo, exception);
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContext(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            defaultView = inflater.inflate(mInfo.initialLayout, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new line of code mRemoteContext = theirContext; is added, and the exceptions logging message is slightly changed in the Late_Implementation, categorizing the change type as 4 (Other statement changed).","The introduced changes do not impact the way the method behaves. It doesn't affect any potential return values or the exceptions being thrown. Therefore, no Compatibility Issue exists, thus the CI type is 0."
255,"<android.app.Dialog: boolean onKeyUp(int,KeyEvent)>",4,5,"<android.app.Dialog: boolean onKeyUp(int,KeyEvent)>","<android.app.Dialog: boolean onKeyUp(int,KeyEvent)>",0,"{
    return false;
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
        onBackPressed();
        return true;
    }
    return false;
}",1,"/**
 * A key was released.
 *
 * @see #onKeyDown
 * @see KeyEvent
 */
","/**
 * A key was released.
 *
 * <p>The default implementation handles KEYCODE_BACK to close the
 * dialog.
 *
 * @see #onKeyDown
 * @see KeyEvent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement and control dependencies (check on KeyEvent and response with onBackPressed() and return true) have been introduced in the late version, so the code change type is 1,3.","The new control statement checks for the keyCode and the status of event tracking and cancellation, and it potentially leads to different return values. Thus, the CI type is 1."
256,"<android.app.NotificationManager: void notify(int,Notification)>",4,5,"<android.app.NotificationManager: void notify(int,Notification)>","<android.app.NotificationManager: void notify(int,Notification)>",0,"{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotification(pkg, id, notification, idOut);
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}","{
    notify(null, id, notification);
}",1,"/**
 * Persistent notification on the status bar,
 *
 * @param id An identifier for this notification unique within your
 * application.
 * @param notification A {@link Notification} object describing how to
 * notify the user, other than the view you're providing. Must not be null.
 */
","/**
 * Persistent notification on the status bar,
 *
 * @param id An identifier for this notification unique within your
 * application.
 * @param notification A {@link Notification} object describing how to
 * notify the user, other than the view you're providing. Must not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",2,"The method is changed from invoking service.enqueueNotification to invoking notify. So, there are changes in the return statement and the dependent API, represented by change types 1,5.","The change in the late version will not allow exceptions to be thrown as it was in the early version, this results in a change in the exception handling and hence, the CI type is 2."
257,<android.webkit.LoadListener: boolean willLoadFromCache(String)>,4,5,<android.webkit.LoadListener: boolean willLoadFromCache(String)>,<android.webkit.LoadListener: boolean willLoadFromCache(String)>,0,"{
    boolean inCache = CacheManager.getCacheFile(url, null) != null;
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""willLoadFromCache: "" + url + "" in cache: "" + inCache);
    }
    return inCache;
}","{
    boolean inCache = CacheManager.getCacheFile(url, null) != null;
    if (DebugFlags.LOAD_LISTENER) {
        Log.v(LOGTAG, ""willLoadFromCache: "" + url + "" in cache: "" + inCache);
    }
    return inCache;
}",1,"/*
     * This function is called from native WebCore code to
     * find out if the given URL is in the cache, and if it can
     * be used. This is just for forward/back navigation to a POST
     * URL.
     */
","/*
     * This function is called from native WebCore code to
     * find out if the given URL is in the cache, and if it can
     * be used. This is just for forward/back navigation to a POST
     * URL.
     */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the if condition (change from WebView.LOGV_ENABLED to DebugFlags.LOAD_LISTENER) has changed, and this doesn't affect the outcome of the method. Therefore the change class is 4 (Other statement changed).","Despite the change, this does not lead to a compatibility issue, as the condition only governs a logging operation that does not interfere with the variable being returned by the API. Hence the CI class is 0 (No Compatibility Issue exist)."
258,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>",4,5,"<android.text.util.Linkify: boolean addLinks(Spannable,int)>","<android.text.util.Linkify: boolean addLinks(Spannable,int)>",0,"{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Regex.WEB_URL_PATTERN, new String[] { ""http://"", ""https://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Regex.EMAIL_ADDRESS_PATTERN, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherLinks(links, text, Regex.PHONE_PATTERN, new String[] { ""tel:"" }, sPhoneNumberMatchFilter, sPhoneNumberTransformFilter);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}","{
    if (mask == 0) {
        return false;
    }
    URLSpan[] old = text.getSpans(0, text.length(), URLSpan.class);
    for (int i = old.length - 1; i >= 0; i--) {
        text.removeSpan(old[i]);
    }
    ArrayList<LinkSpec> links = new ArrayList<LinkSpec>();
    if ((mask & WEB_URLS) != 0) {
        gatherLinks(links, text, Regex.WEB_URL_PATTERN, new String[] { ""http://"", ""https://"", ""rtsp://"" }, sUrlMatchFilter, null);
    }
    if ((mask & EMAIL_ADDRESSES) != 0) {
        gatherLinks(links, text, Regex.EMAIL_ADDRESS_PATTERN, new String[] { ""mailto:"" }, null, null);
    }
    if ((mask & PHONE_NUMBERS) != 0) {
        gatherLinks(links, text, Regex.PHONE_PATTERN, new String[] { ""tel:"" }, sPhoneNumberMatchFilter, sPhoneNumberTransformFilter);
    }
    if ((mask & MAP_ADDRESSES) != 0) {
        gatherMapLinks(links, text);
    }
    pruneOverlaps(links);
    if (links.size() == 0) {
        return false;
    }
    for (LinkSpec link : links) {
        applyLink(link.url, link.start, link.end, text);
    }
    return true;
}",1,"/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 */
","/**
 * Scans the text of the provided Spannable and turns all occurrences
 * of the link types indicated in the mask into clickable links.
 * If the mask is nonzero, it also removes any existing URLSpans
 * attached to the Spannable, to avoid problems if you call it
 * repeatedly on the same text.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"Only an array element has changed, the existing array { ""http://"", ""https://"" } is replaced by the new array { ""http://"", ""https://"", ""rtsp://"" } at calling gatherLinks() method, this is neither related with return nor exception statement, nor it is related with control dependency changes. Therefore, the code change type here is 4.","The change in the array that is used in gatherLinks() method can alter the behaviour of the method as it may gather different types or values of URLs leading to potential return of different values in the late version of the code. Therefore, the CI type is 1."
259,"<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>",4,5,"<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>","<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>",0,"{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
            if (mFiltered && mPopup != null && mPopup.isShowing() && event.getAction() == KeyEvent.ACTION_DOWN) {
                handled = true;
                mTextFilter.setText("""");
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered = true;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}","{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
            if (mFiltered && mPopup != null && mPopup.isShowing()) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                    getKeyDispatcherState().startTracking(event, this);
                    handled = true;
                } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
                    handled = true;
                    mTextFilter.setText("""");
                }
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered = true;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}",1,"/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
","/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency has changed (some conditions in 'if' statement under case KeyEvent.KEYCODE_BACK have been added), and also the statements within this dependency (getKeyDispatcherState().startTracking(event, this);) has been added. So, it is type 3 and 4.","The addition of new control statement and changes in the existing one may lead to a different return value ('handled' variable) in the late version, hence a compatibility issue of type 1 could exist."
260,<android.widget.AbsListView: void keyPressed()>,4,5,<android.widget.AbsListView: void keyPressed()>,<android.widget.AbsListView: void keyPressed()>,0,"{
    Drawable selector = mSelector;
    Rect selectorRect = mSelectorRect;
    if (selector != null && (isFocused() || touchModeDrawsInPressedState()) && selectorRect != null && !selectorRect.isEmpty()) {
        final View v = getChildAt(mSelectedPosition - mFirstPosition);
        if (v != null) {
            if (v.hasFocusable())
                return;
            v.setPressed(true);
        }
        setPressed(true);
        final boolean longClickable = isLongClickable();
        Drawable d = selector.getCurrent();
        if (d != null && d instanceof TransitionDrawable) {
            if (longClickable) {
                ((TransitionDrawable) d).startTransition(ViewConfiguration.getLongPressTimeout());
            } else {
                ((TransitionDrawable) d).resetTransition();
            }
        }
        if (longClickable && !mDataChanged) {
            if (mPendingCheckForKeyLongPress == null) {
                mPendingCheckForKeyLongPress = new CheckForKeyLongPress();
            }
            mPendingCheckForKeyLongPress.rememberWindowAttachCount();
            postDelayed(mPendingCheckForKeyLongPress, ViewConfiguration.getLongPressTimeout());
        }
    }
}","{
    if (!isEnabled() || !isClickable()) {
        return;
    }
    Drawable selector = mSelector;
    Rect selectorRect = mSelectorRect;
    if (selector != null && (isFocused() || touchModeDrawsInPressedState()) && selectorRect != null && !selectorRect.isEmpty()) {
        final View v = getChildAt(mSelectedPosition - mFirstPosition);
        if (v != null) {
            if (v.hasFocusable())
                return;
            v.setPressed(true);
        }
        setPressed(true);
        final boolean longClickable = isLongClickable();
        Drawable d = selector.getCurrent();
        if (d != null && d instanceof TransitionDrawable) {
            if (longClickable) {
                ((TransitionDrawable) d).startTransition(ViewConfiguration.getLongPressTimeout());
            } else {
                ((TransitionDrawable) d).resetTransition();
            }
        }
        if (longClickable && !mDataChanged) {
            if (mPendingCheckForKeyLongPress == null) {
                mPendingCheckForKeyLongPress = new CheckForKeyLongPress();
            }
            mPendingCheckForKeyLongPress.rememberWindowAttachCount();
            postDelayed(mPendingCheckForKeyLongPress, ViewConfiguration.getLongPressTimeout());
        }
    }
}",1,"/**
 * Sets the selector state to ""pressed"" and posts a CheckForKeyLongPress to see if
 * this is a long press.
 */
","/**
 * Sets the selector state to ""pressed"" and posts a CheckForKeyLongPress to see if
 * this is a long press.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Two new condition checks to return early if the view is not enabled or not clickable are added in the late implementation. Also, new return statements are introduced in the beginning of the method. Hence, the change types are 1 and 3.","The addition of new early return conditions in the code may potentially change the behavior of the API by changing the returned value of the method, i.e., it could return early in the later version while in the early version, it would perform the following operations. Hence, the CI type is 1."
261,"<android.app.Dialog: boolean onKeyDown(int,KeyEvent)>",4,5,"<android.app.Dialog: boolean onKeyDown(int,KeyEvent)>","<android.app.Dialog: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (mCancelable) {
            cancel();
        }
        return true;
    }
    return false;
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        event.startTracking();
        return true;
    }
    return false;
}",1,"/**
 * A key was pressed down.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation handles KEYCODE_BACK to close the
 * dialog.
 *
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
","/**
 * A key was pressed down.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation consumed the KEYCODE_BACK to later
 * handle it in {@link #onKeyUp}.
 *
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the 'if' statement of both implementations, the method behavior changes from 'cancel()' to 'startTracking()', which is within the control dependency. So the change type is 4.","The return types and exception handling of this method have not changed between versions even though the method behavior within the control dependency has changed. Therefore, there is no compatibility issue (type 0)."
262,<android.content.res.Configuration: int updateFrom(Configuration)>,4,5,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    return changed;
}",1,"/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
","/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,There was an addition of a new condition block for navigationHidden in the late implementation version. This is classed as other statement changed (4).,"This change could potentially return different values for variable 'changed', therefore decreasing backwards compatibility. So it is a compatibility issue caused by potential different return values or types (1)."
264,<android.view.KeyEvent: boolean dispatch(Callback)>,4,5,<android.view.KeyEvent: boolean dispatch(Callback)>,<android.view.KeyEvent: boolean dispatch(Callback)>,0,"{
    switch(mAction) {
        case ACTION_DOWN:
            return receiver.onKeyDown(mKeyCode, this);
        case ACTION_UP:
            return receiver.onKeyUp(mKeyCode, this);
        case ACTION_MULTIPLE:
            final int count = mRepeatCount;
            final int code = mKeyCode;
            if (receiver.onKeyMultiple(code, count, this)) {
                return true;
            }
            if (code != KeyEvent.KEYCODE_UNKNOWN) {
                mAction = ACTION_DOWN;
                mRepeatCount = 0;
                boolean handled = receiver.onKeyDown(code, this);
                if (handled) {
                    mAction = ACTION_UP;
                    receiver.onKeyUp(code, this);
                }
                mAction = ACTION_MULTIPLE;
                mRepeatCount = count;
                return handled;
            }
    }
    return false;
}","{
    return dispatch(receiver, null, null);
}",1,"/**
 * Deliver this key event to a {@link Callback} interface.  If this is
 * an ACTION_MULTIPLE event and it is not handled, then an attempt will
 * be made to deliver a single normal event.
 *
 * @param receiver The Callback that will be given the event.
 *
 * @return The return value from the Callback method that was called.
 */
","/**
 * @deprecated Use {@link #dispatch(Callback, DispatcherState, Object)} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation changes significantly in the late version. The switch statement and multiple API calls are removed and replaced by one call to dispatch() with different parameters. Also, the method dispatch() is an API that this method depends on, so change type is 1,4,5.","The removed switch statement and its inner return statements, together with the replaced API call (dispatch()), could lead to different returned values when the late version API is invoked, thus the CI type is 1."
265,<android.webkit.CookieManager: ArrayList<Cookie> deleteLRUDomain()>,4,5,<android.webkit.CookieManager: ArrayList<Cookie> deleteLRUDomain()>,<android.webkit.CookieManager: ArrayList<Cookie> deleteLRUDomain()>,0,"{
    int count = 0;
    int byteCount = 0;
    int mapSize = mCookieMap.size();
    if (mapSize < MAX_RAM_DOMAIN_COUNT) {
        Collection<ArrayList<Cookie>> cookieLists = mCookieMap.values();
        Iterator<ArrayList<Cookie>> listIter = cookieLists.iterator();
        while (listIter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
            ArrayList<Cookie> list = listIter.next();
            if (WebView.DEBUG) {
                Iterator<Cookie> iter = list.iterator();
                while (iter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
                    Cookie cookie = iter.next();
                    // 14 is 3 * sizeof(long) + sizeof(boolean)
                    // + sizeof(byte)
                    byteCount += cookie.domain.length() + cookie.path.length() + cookie.name.length() + cookie.value.length() + 14;
                    count++;
                }
            } else {
                count += list.size();
            }
        }
    }
    ArrayList<Cookie> retlist = new ArrayList<Cookie>();
    if (mapSize >= MAX_RAM_DOMAIN_COUNT || count >= MAX_RAM_COOKIES_COUNT) {
        if (WebView.DEBUG) {
            Log.v(LOGTAG, count + "" cookies used "" + byteCount + "" bytes with "" + mapSize + "" domains"");
        }
        Object[] domains = mCookieMap.keySet().toArray();
        int toGo = mapSize / 10 + 1;
        while (toGo-- > 0) {
            String domain = domains[toGo].toString();
            if (WebView.LOGV_ENABLED) {
                Log.v(LOGTAG, ""delete domain: "" + domain + "" from RAM cache"");
            }
            retlist.addAll(mCookieMap.get(domain));
            mCookieMap.remove(domain);
        }
    }
    return retlist;
}","{
    int count = 0;
    int byteCount = 0;
    int mapSize = mCookieMap.size();
    if (mapSize < MAX_RAM_DOMAIN_COUNT) {
        Collection<ArrayList<Cookie>> cookieLists = mCookieMap.values();
        Iterator<ArrayList<Cookie>> listIter = cookieLists.iterator();
        while (listIter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
            ArrayList<Cookie> list = listIter.next();
            if (DebugFlags.COOKIE_MANAGER) {
                Iterator<Cookie> iter = list.iterator();
                while (iter.hasNext() && count < MAX_RAM_COOKIES_COUNT) {
                    Cookie cookie = iter.next();
                    // 14 is 3 * sizeof(long) + sizeof(boolean)
                    // + sizeof(byte)
                    byteCount += cookie.domain.length() + cookie.path.length() + cookie.name.length() + cookie.value.length() + 14;
                    count++;
                }
            } else {
                count += list.size();
            }
        }
    }
    ArrayList<Cookie> retlist = new ArrayList<Cookie>();
    if (mapSize >= MAX_RAM_DOMAIN_COUNT || count >= MAX_RAM_COOKIES_COUNT) {
        if (DebugFlags.COOKIE_MANAGER) {
            Log.v(LOGTAG, count + "" cookies used "" + byteCount + "" bytes with "" + mapSize + "" domains"");
        }
        Object[] domains = mCookieMap.keySet().toArray();
        int toGo = mapSize / 10 + 1;
        while (toGo-- > 0) {
            String domain = domains[toGo].toString();
            if (DebugFlags.COOKIE_MANAGER) {
                Log.v(LOGTAG, ""delete domain: "" + domain + "" from RAM cache"");
            }
            retlist.addAll(mCookieMap.get(domain));
            mCookieMap.remove(domain);
        }
    }
    return retlist;
}",1,"/**
 * Package level api, called from CookieSyncManager
 *
 * Delete the least recent used domains if the total cookie count in RAM
 * exceeds the limit
 * @return A list of cookies which are removed from RAM
 */
","/**
 * Package level api, called from CookieSyncManager
 *
 * Delete the least recent used domains if the total cookie count in RAM
 * exceeds the limit
 * @return A list of cookies which are removed from RAM
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change only affects the condition 'if(WebView.DEBUG)' to 'if(DebugFlags.COOKIE_MANAGER)'. Thus, the code change type is 4.",There is no CI in this change as it doesn't affect what the method returns nor does it introduce or delete any exception handling. The Compatibility Issue type is 0.
266,"<android.widget.ListView: void setItemChecked(int,boolean)>",4,5,"<android.widget.ListView: void setItemChecked(int,boolean)>","<android.widget.ListView: void setItemChecked(int,boolean)>",0,"{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE) {
        mCheckStates.put(position, value);
    } else {
        // Clear the old value: if something was selected and value == false
        // then it is unselected
        mCheckStates.clear();
        // we don't have to first to a get(position)
        if (value) {
            mCheckStates.put(position, true);
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}","{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE) {
        mCheckStates.put(position, value);
    } else {
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}",1,"/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked sate for the item
 */
","/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked sate for the item
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition inside the second if block has an additional statement 'isItemChecked(position)', so the code change type is 3 ","The additional function 'isItemChecked(position)' may alter the behaviour of the 'mCheckStates.clear()' function, theoretically this could lead to a different return type or variable, and thus, the CI type is 1."
267,<android.preference.Preference: StringBuilder getFilterableStringBuilder()>,4,5,<android.preference.Preference: StringBuilder getFilterableStringBuilder()>,<android.preference.Preference: StringBuilder getFilterableStringBuilder()>,0,"{
    StringBuilder sb = new StringBuilder();
    CharSequence title = getTitle();
    if (!TextUtils.isEmpty(title)) {
        sb.append(title).append(' ');
    }
    CharSequence summary = getSummary();
    if (!TextUtils.isEmpty(summary)) {
        sb.append(summary).append(' ');
    }
    // Drop the last space
    sb.setLength(sb.length() - 1);
    return sb;
}","{
    StringBuilder sb = new StringBuilder();
    CharSequence title = getTitle();
    if (!TextUtils.isEmpty(title)) {
        sb.append(title).append(' ');
    }
    CharSequence summary = getSummary();
    if (!TextUtils.isEmpty(summary)) {
        sb.append(summary).append(' ');
    }
    if (sb.length() > 0) {
        // Drop the last space
        sb.setLength(sb.length() - 1);
    }
    return sb;
}",1,"/**
 * Returns the text that will be used to filter this Preference depending on
 * user input.
 * <p>
 * If overridding and calling through to the superclass, make sure to prepend
 * your additions with a space.
 *
 * @return Text as a {@link StringBuilder} that will be used to filter this
 * preference. By default, this is the title and summary
 * (concatenated with a space).
 */
","/**
 * Returns the text that will be used to filter this Preference depending on
 * user input.
 * <p>
 * If overridding and calling through to the superclass, make sure to prepend
 * your additions with a space.
 *
 * @return Text as a {@link StringBuilder} that will be used to filter this
 * preference. By default, this is the title and summary
 * (concatenated with a space).
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The addition of the 'if' statement in the late version is a control dependency change (type 3).,"Although there is a control dependency change, the final return value of the API remains as a StringBuilder object. The change just pads for the condition where the length of the StringBuilder is zero, in which case in the early version it will cause 'StringIndexOutOfBoundsException' but in the late version it will be handled gracefully, won't effect the expected functionality of the API. Hence, it does not cause any compatibility issue (type 0)."
268,"<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>",4,5,"<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>","<android.app.SearchManager: void startSearch(String,boolean,ComponentName,Bundle,boolean)>",0,"{
    if (mIdent == 0)
        throw new IllegalArgumentException(""Called from outside of an Activity context"");
    try {
        // activate the search manager and start it up!
        mService.startSearch(initialQuery, selectInitialQuery, launchActivity, appSearchData, globalSearch, mSearchManagerCallback, mIdent);
    } catch (RemoteException ex) {
        Log.e(TAG, ""startSearch() failed: "" + ex);
    }
}","{
    if (mIdent == 0)
        throw new IllegalArgumentException(""Called from outside of an Activity context"");
    if (!globalSearch && !mAssociatedPackage.equals(launchActivity.getPackageName())) {
        Log.w(TAG, ""invoking app search on a different package "" + ""not associated with this search manager"");
    }
    try {
        // activate the search manager and start it up!
        mService.startSearch(initialQuery, selectInitialQuery, launchActivity, appSearchData, globalSearch, mSearchManagerCallback, mIdent);
    } catch (RemoteException ex) {
        Log.e(TAG, ""startSearch() failed."", ex);
    }
}",1,"/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */
","/**
 * Launch search UI.
 *
 * <p>The search manager will open a search widget in an overlapping
 * window, and the underlying activity may be obscured.  The search
 * entry state will remain in effect until one of the following events:
 * <ul>
 * <li>The user completes the search.  In most cases this will launch
 * a search intent.</li>
 * <li>The user uses the back, home, or other keys to exit the search.</li>
 * <li>The application calls the {@link #stopSearch}
 * method, which will hide the search window and return focus to the
 * activity from which it was launched.</li>
 *
 * <p>Most applications will <i>not</i> use this interface to invoke search.
 * The primary method for invoking search is to call
 * {@link android.app.Activity#onSearchRequested Activity.onSearchRequested()} or
 * {@link android.app.Activity#startSearch Activity.startSearch()}.
 *
 * @param initialQuery A search string can be pre-entered here, but this
 * is typically null or empty.
 * @param selectInitialQuery If true, the intial query will be preselected, which means that
 * any further typing will replace it.  This is useful for cases where an entire pre-formed
 * query is being inserted.  If false, the selection point will be placed at the end of the
 * inserted query.  This is useful when the inserted query is text that the user entered,
 * and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
 * if initialQuery is a non-empty string.</i>
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 * @param globalSearch If false, this will only launch the search that has been specifically
 * defined by the application (which is usually defined as a local search).  If no default
 * search is defined in the current application or activity, global search will be launched.
 * If true, this will always launch a platform-global (e.g. web-based) search instead.
 *
 * @see android.app.Activity#onSearchRequested
 * @see #stopSearch
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,"In the later version, a condition statement is added to check if the package of the launcherActivity is different with the associated package when globalSearch is not true. Besides, the log statement in the catch block has changed where it includes the exception 'ex' in the log message. So, the change is related to control dependency and other statements, hence the change type is classified as 3,4.","Although there is some modification in the code, none of these changes would lead to a compatibility issue as they do not affect the potential return value or exception handling of the API. Therefore, there is no compatibility issue, and the CI type is 0."
270,<android.provider.Gmail.LabelMap: int getNumUnreadConversations(long)>,4,5,<android.provider.Gmail.LabelMap: int getNumUnreadConversations(long)>,<android.provider.Gmail.LabelMap: int getNumUnreadConversations(long)>,0,"{
    Integer unreadConversations = getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
    // state and lose state on a particular label.
    if (unreadConversations == null) {
        return 0;
    } else {
        return unreadConversations;
    }
}","{
    Integer unreadConversations = getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
    // There seems to be a race condition here that can get the label maps into a bad
    // state and lose state on a particular label.
    int result = 0;
    if (unreadConversations != null) {
        result = unreadConversations < 0 ? 0 : unreadConversations;
    }
    return result;
}",1,"/**
 * Returns the number of unread conversation with a given label.
 */
","/**
 * Returns the number of unread conversation with a given label.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The portion of the code where the actual result is determined - ""if (unreadConversations == null)"" vs ""if (unreadConversations != null)"" and ""return unreadConversations"" vs ""return result"" has changed, hence change type 1. Also, a new variable result was introduced, which can be considered a control dependency change, hence change type 3. ","The return statement change implies that the function can return different results under the same input conditions, this potentially causes a compatibility issue - the type of the CI is 1."
273,<android.webkit.WebSyncManager: void resetSync()>,4,5,<android.webkit.WebSyncManager: void resetSync()>,<android.webkit.WebSyncManager: void resetSync()>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""*** WebSyncManager resetSync ***"");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
}","{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, ""*** WebSyncManager resetSync ***"");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
}",1,"/**
 * resetSync() resets sync manager's timer
 */
","/**
 * resetSync() resets sync manager's timer
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is related to a Debug statement, where the condition of Debugging flag has been changed from WebView.LOGV_ENABLED to DebugFlags.WEB_SYNC_MANAGER, which doesn't affect the API behavior. Hence the change code type is 4.","There is no Compatibility Issue since the change doesn't affect the API behavior or output. The output is unaffected irrespective of the debug statement condition. Hence, CI type is 0."
275,<android.widget.GridView: boolean arrowScroll(int)>,4,5,<android.widget.GridView: boolean arrowScroll(int)>,<android.widget.GridView: boolean arrowScroll(int)>,0,"{
    final int selectedPosition = mSelectedPosition;
    final int numColumns = mNumColumns;
    int startOfRowPos;
    int endOfRowPos;
    boolean moved = false;
    if (!mStackFromBottom) {
        startOfRowPos = (selectedPosition / numColumns) * numColumns;
        endOfRowPos = Math.min(startOfRowPos + numColumns - 1, mItemCount - 1);
    } else {
        final int invertedSelection = mItemCount - 1 - selectedPosition;
        endOfRowPos = mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
        startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
    }
    switch(direction) {
        case FOCUS_UP:
            if (startOfRowPos > 0) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - numColumns));
                moved = true;
            }
            break;
        case FOCUS_DOWN:
            if (endOfRowPos < mItemCount - 1) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + numColumns, mItemCount - 1));
                moved = true;
            }
            break;
        case FOCUS_LEFT:
            if (selectedPosition > startOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - 1));
                moved = true;
            }
            break;
        case FOCUS_RIGHT:
            if (selectedPosition < endOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + 1, mItemCount - 1));
                moved = true;
            }
            break;
    }
    if (moved) {
        playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
        invokeOnItemScrollListener();
    }
    return moved;
}","{
    final int selectedPosition = mSelectedPosition;
    final int numColumns = mNumColumns;
    int startOfRowPos;
    int endOfRowPos;
    boolean moved = false;
    if (!mStackFromBottom) {
        startOfRowPos = (selectedPosition / numColumns) * numColumns;
        endOfRowPos = Math.min(startOfRowPos + numColumns - 1, mItemCount - 1);
    } else {
        final int invertedSelection = mItemCount - 1 - selectedPosition;
        endOfRowPos = mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
        startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
    }
    switch(direction) {
        case FOCUS_UP:
            if (startOfRowPos > 0) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - numColumns));
                moved = true;
            }
            break;
        case FOCUS_DOWN:
            if (endOfRowPos < mItemCount - 1) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + numColumns, mItemCount - 1));
                moved = true;
            }
            break;
        case FOCUS_LEFT:
            if (selectedPosition > startOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - 1));
                moved = true;
            }
            break;
        case FOCUS_RIGHT:
            if (selectedPosition < endOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + 1, mItemCount - 1));
                moved = true;
            }
            break;
    }
    if (moved) {
        playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
        invokeOnItemScrollListener();
    }
    if (moved) {
        awakenScrollBars();
    }
    return moved;
}",1,"/**
 * Scrolls to the next or previous item, horizontally or vertically.
 *
 * @param direction either {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
 * {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */
","/**
 * Scrolls to the next or previous item, horizontally or vertically.
 *
 * @param direction either {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
 * {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new function call, awakenScrollBars(), is added in late implementation, which is type of Other statement changed (4);","The added function awakenScrollBars() does not alter the return value or exception handling of the implemented method, so there is no Compatibility Issue existed (0)."
276,<android.webkit.WebView: boolean zoomOut()>,4,5,<android.webkit.WebView: boolean zoomOut()>,<android.webkit.WebView: boolean zoomOut()>,0,"{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    return zoomWithPreview(mActualScale * 0.8f);
}","{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    float scale = mActualScale * 0.8f;
    if (scale < (mMinZoomScale + 0.1f) && mWebViewCore.getSettings().getUseWideViewPort()) {
        // when zoom out to min scale, switch to overview mode
        doDoubleTap();
        return true;
    } else {
        // Center zooming to the center of the screen.
        mZoomCenterX = getViewWidth() * .5f;
        mZoomCenterY = getViewHeight() * .5f;
        return zoomWithPreview(scale);
    }
}",1,"/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The variable 'scale' and the logic of returning value with 'if' and 'else' statement have been added, and thus the type of code change is 1,3, including return statement change and control dependency change.","With the new control condition and return statement, it could lead to potentially different return values when invoked, incuding the true value type in the else condition and the return from doDoubleTap(), hence, the Compatibility Issue type is 1."
277,"<android.inputmethodservice.InputMethodService: boolean onKeyUp(int,KeyEvent)>",4,5,"<android.inputmethodservice.InputMethodService: boolean onKeyUp(int,KeyEvent)>","<android.inputmethodservice.InputMethodService: boolean onKeyUp(int,KeyEvent)>",0,"{
    return doMovementKey(keyCode, event, MOVEMENT_UP);
}","{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
        return handleBack(true);
    }
    return doMovementKey(keyCode, event, MOVEMENT_UP);
}",1,"/**
 * Override this to intercept key up events before they are processed by the
 * application.  If you return true, the application will not itself
 * process the event.  If you return true, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation always returns false, except when
 * in fullscreen mode, where it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
","/**
 * Override this to intercept key up events before they are processed by the
 * application.  If you return true, the application will not itself
 * process the event.  If you return true, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} to hide the current IME UI if it is shown.  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"The new if statement is added to the code that may change the return value, and consequently, the types of change are 3,1.","The returned value could potentially vary between versions due to the new 'if' statement in the late version, which causes a change in the execution logic. Thus, the Compatibility Issue type is 1."
278,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",4,5,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>","<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",0,"{
    long timeStart = 0;
    if (Config.LOGV) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(this, sql, editTable);
    try {
        return driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (Config.LOGV) {
            long duration = System.currentTimeMillis() - timeStart;
            Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>""));
        }
    }
}","{
    long timeStart = 0;
    if (Config.LOGV || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(this, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (Config.LOGV || mSlowQueryThreshold != -1) {
            // Force query execution
            if (cursor != null) {
                cursor.moveToFirst();
                cursor.moveToPosition(-1);
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (Config.LOGV || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>""));
            }
        }
    }
    return cursor;
}",1,"/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry
 */
","/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency condition (Config.LOGV) has been changed to Config.LOGV || mSlowQueryThreshold != -1 and the 'other statement' like cursor.moveToFirst() and cursor.moveToPosition(-1) have been added in the new version, so the code change type is 3, 4.","As the behaviour of the program has changed due to the addition of operations on the 'cursor' and modification in the condition of logs, these changes might lead the API to possibly return a different value, hence the CI type is 1."
279,<com.google.android.net.UrlRules: UrlRules getRules(ContentResolver)>,4,5,<com.google.android.net.UrlRules: UrlRules getRules(ContentResolver)>,<com.google.android.net.UrlRules: UrlRules getRules(ContentResolver)>,0,"{
    String digest = Settings.Gservices.getString(resolver, Settings.Gservices.PROVISIONING_DIGEST);
    if (sCachedDigest != null && sCachedDigest.equals(digest)) {
        // The digest is the same, so the rules are the same.
        return sCachedRules;
    }
    // Get all the Gservices settings with names starting with ""url:"".
    Cursor cursor = resolver.query(Settings.Gservices.CONTENT_URI, new String[] { Settings.Gservices.NAME, Settings.Gservices.VALUE }, Settings.Gservices.NAME + "" like \""url:%\"""", null, Settings.Gservices.NAME);
    try {
        ArrayList<Rule> rules = new ArrayList<Rule>();
        while (cursor.moveToNext()) {
            try {
                // ""url:X""
                String name = cursor.getString(0).substring(4);
                String value = cursor.getString(1);
                if (value == null || value.length() == 0)
                    continue;
                rules.add(new Rule(name, value));
            } catch (RuleFormatException e) {
                // Oops, Gservices has an invalid rule!  Skip it.
                Log.e(""UrlRules"", ""Invalid rule from Gservices"", e);
                Checkin.logEvent(resolver, Checkin.Events.Tag.GSERVICES_ERROR, e.toString());
            }
        }
        sCachedRules = new UrlRules(rules.toArray(new Rule[rules.size()]));
        sCachedDigest = digest;
    } finally {
        cursor.close();
    }
    return sCachedRules;
}","{
    String digest = Settings.Gservices.getString(resolver, Settings.Gservices.PROVISIONING_DIGEST);
    if (sCachedDigest != null && sCachedDigest.equals(digest)) {
        // The digest is the same, so the rules are the same.
        if (LOCAL_LOGV)
            Log.v(TAG, ""Using cached rules for digest: "" + digest);
        return sCachedRules;
    }
    if (LOCAL_LOGV)
        Log.v(TAG, ""Scanning for Gservices \""url:*\"" rules"");
    Cursor cursor = resolver.query(Settings.Gservices.CONTENT_URI, new String[] { Settings.Gservices.NAME, Settings.Gservices.VALUE }, Settings.Gservices.NAME + "" like \""url:%\"""", null, Settings.Gservices.NAME);
    try {
        ArrayList<Rule> rules = new ArrayList<Rule>();
        while (cursor.moveToNext()) {
            try {
                // ""url:X""
                String name = cursor.getString(0).substring(4);
                String value = cursor.getString(1);
                if (value == null || value.length() == 0)
                    continue;
                if (LOCAL_LOGV)
                    Log.v(TAG, ""  Rule "" + name + "": "" + value);
                rules.add(new Rule(name, value));
            } catch (RuleFormatException e) {
                // Oops, Gservices has an invalid rule!  Skip it.
                Log.e(TAG, ""Invalid rule from Gservices"", e);
                Checkin.logEvent(resolver, Checkin.Events.Tag.GSERVICES_ERROR, e.toString());
            }
        }
        sCachedRules = new UrlRules(rules.toArray(new Rule[rules.size()]));
        sCachedDigest = digest;
        if (LOCAL_LOGV)
            Log.v(TAG, ""New rules stored for digest: "" + digest);
    } finally {
        cursor.close();
    }
    return sCachedRules;
}",1,"/**
 * Get the (possibly cached) UrlRules based on the rules in Gservices.
 * @param resolver to use for accessing the Gservices database.
 * @return an updated UrlRules instance
 */
","/**
 * Get the (possibly cached) UrlRules based on the rules in Gservices.
 * @param resolver to use for accessing the Gservices database.
 * @return an updated UrlRules instance
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Introduction of new debug log statements, which doesn't alter the functionality of the program, only extends its logging capabilities. Hence the change type falls under 4 - Other statements changed.","The introduced changes don't alter the program execution flow, they don't affect the returned variables (always 'sCachedRules'), they don't generate new exceptions or modify existing ones, so no compatibility issues are introduced, hence the CI type is 0."
280,"<android.app.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor)>",4,5,"<android.app.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor)>","<android.app.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor)>",0,"{
    // !!! TODO - real implementation; for now just invoke the callbacks directly
    Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor());
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    }
}","{
    // !!! TODO - real implementation; for now just invoke the callbacks directly
    if (DEBUG)
        Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor());
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, a condition ""if (DEBUG)"" was added before a Log statement. This change applies to the execution of log statements, and doesn't impact the main functionality of the method. Therefore, the change type is classified as 4 (Other statement changed).","Despite the added condition ""if (DEBUG)"" in the late version, the fundamental behavior and output of the method remained unchanged. Both the early and late versions handle exceptions in the same manner and return nothing. As such, there's no compatibility issue involved, so the type of Compatibility Issue is 0."
281,<android.webkit.WebView: void reload()>,4,5,<android.webkit.WebView: void reload()>,<android.webkit.WebView: void reload()>,0,"{
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.RELOAD);
}","{
    clearTextEntry();
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.RELOAD);
}",1,"/**
 * Reload the current url.
 */
","/**
 * Reload the current url.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The execution method clearTextEntry() has been added at the start of the late version, which pertains to the ""Other statement changed"" category and thus, the code change is of type 4.","Despite the addition of clearTextEntry() in the code, this change doesn't affect the output of the method or result in different exception handling, therefore, no Compatibility Issue(CI) exists, and the CI is of type 0."
282,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>",4,5,"<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>","<android.database.sqlite.SQLiteDatabase: SQLiteDatabase openDatabase(String,CursorFactory,int)>",0,"{
    SQLiteDatabase db = null;
    try {
        // Open the database.
        return new SQLiteDatabase(path, factory, flags);
    } catch (SQLiteDatabaseCorruptException e) {
        // Try to recover from this, if we can.
        // TODO: should we do this for other open failures?
        Log.e(TAG, ""Deleting and re-creating corrupt database "" + path, e);
        new File(path).delete();
        return new SQLiteDatabase(path, factory, flags);
    }
}","{
    SQLiteDatabase db = null;
    try {
        // Open the database.
        return new SQLiteDatabase(path, factory, flags);
    } catch (SQLiteDatabaseCorruptException e) {
        // Try to recover from this, if we can.
        // TODO: should we do this for other open failures?
        Log.e(TAG, ""Deleting and re-creating corrupt database "" + path, e);
        EventLog.writeEvent(EVENT_DB_CORRUPT, path);
        new File(path).delete();
        return new SQLiteDatabase(path, factory, flags);
    }
}",1,"/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
","/**
 * Open the database according to the flags {@link #OPEN_READWRITE}
 * {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
 *
 * <p>Sets the locale of the database to the  the system's current locale.
 * Call {@link #setLocale} if you would like something else.</p>
 *
 * @param path to database file to open and/or create
 * @param factory an optional factory class that is called to instantiate a
 * cursor when query is called, or null for default
 * @param flags to control database access mode
 * @return the newly opened database
 * @throws SQLiteException if the database cannot be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only an EventLog statement is introduced which has no effects on the variables or values returned. Therefore, the code change type is 4.","No Compatibility Issue exists in this code change because it doesn't affect the return values or exception handlings. Hence, the CI type is 0."
283,<android.inputmethodservice.KeyboardView: boolean onTouchEvent(MotionEvent)>,4,5,<android.inputmethodservice.KeyboardView: boolean onTouchEvent(MotionEvent)>,<android.inputmethodservice.KeyboardView: boolean onTouchEvent(MotionEvent)>,0,"{
    int touchX = (int) me.getX() - mPaddingLeft;
    int touchY = (int) me.getY() + mVerticalCorrection - mPaddingTop;
    int action = me.getAction();
    long eventTime = me.getEventTime();
    int keyIndex = getKeyIndices(touchX, touchY, null);
    if (mGestureDetector.onTouchEvent(me)) {
        showPreview(NOT_A_KEY);
        mHandler.removeMessages(MSG_REPEAT);
        mHandler.removeMessages(MSG_LONGPRESS);
        return true;
    }
    // displayed the mini keyboard
    if (mMiniKeyboardOnScreen) {
        return true;
    }
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            mAbortKey = false;
            mStartX = touchX;
            mStartY = touchY;
            mLastCodeX = touchX;
            mLastCodeY = touchY;
            mLastKeyTime = 0;
            mCurrentKeyTime = 0;
            mLastKey = NOT_A_KEY;
            mCurrentKey = keyIndex;
            mDownTime = me.getEventTime();
            mLastMoveTime = mDownTime;
            checkMultiTap(eventTime, keyIndex);
            mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
            if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
                mRepeatKeyIndex = mCurrentKey;
                repeatKey();
                Message msg = mHandler.obtainMessage(MSG_REPEAT);
                mHandler.sendMessageDelayed(msg, REPEAT_START_DELAY);
            }
            if (mCurrentKey != NOT_A_KEY) {
                Message msg = mHandler.obtainMessage(MSG_LONGPRESS, me);
                mHandler.sendMessageDelayed(msg, LONGPRESS_TIMEOUT);
            }
            showPreview(keyIndex);
            break;
        case MotionEvent.ACTION_MOVE:
            boolean continueLongPress = false;
            if (keyIndex != NOT_A_KEY) {
                if (mCurrentKey == NOT_A_KEY) {
                    mCurrentKey = keyIndex;
                    mCurrentKeyTime = eventTime - mDownTime;
                } else {
                    if (keyIndex == mCurrentKey) {
                        mCurrentKeyTime += eventTime - mLastMoveTime;
                        continueLongPress = true;
                    } else {
                        resetMultiTap();
                        mLastKey = mCurrentKey;
                        mLastCodeX = mLastX;
                        mLastCodeY = mLastY;
                        mLastKeyTime = mCurrentKeyTime + eventTime - mLastMoveTime;
                        mCurrentKey = keyIndex;
                        mCurrentKeyTime = 0;
                    }
                }
                if (keyIndex != mRepeatKeyIndex) {
                    mHandler.removeMessages(MSG_REPEAT);
                    mRepeatKeyIndex = NOT_A_KEY;
                }
            }
            if (!continueLongPress) {
                // Cancel old longpress
                mHandler.removeMessages(MSG_LONGPRESS);
                // Start new longpress if key has changed
                if (keyIndex != NOT_A_KEY) {
                    Message msg = mHandler.obtainMessage(MSG_LONGPRESS, me);
                    mHandler.sendMessageDelayed(msg, LONGPRESS_TIMEOUT);
                }
            }
            showPreview(keyIndex);
            break;
        case MotionEvent.ACTION_UP:
            mHandler.removeMessages(MSG_SHOW_PREVIEW);
            mHandler.removeMessages(MSG_REPEAT);
            mHandler.removeMessages(MSG_LONGPRESS);
            if (keyIndex == mCurrentKey) {
                mCurrentKeyTime += eventTime - mLastMoveTime;
            } else {
                resetMultiTap();
                mLastKey = mCurrentKey;
                mLastKeyTime = mCurrentKeyTime + eventTime - mLastMoveTime;
                mCurrentKey = keyIndex;
                mCurrentKeyTime = 0;
            }
            if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
                mCurrentKey = mLastKey;
                touchX = mLastCodeX;
                touchY = mLastCodeY;
            }
            showPreview(NOT_A_KEY);
            Arrays.fill(mKeyIndices, NOT_A_KEY);
            // If we're not on a repeating key (which sends on a DOWN event)
            if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
                detectAndSendKey(touchX, touchY, eventTime);
            }
            invalidateKey(keyIndex);
            mRepeatKeyIndex = NOT_A_KEY;
            break;
    }
    mLastX = touchX;
    mLastY = touchY;
    return true;
}","{
    // Convert multi-pointer up/down events to single up/down events to
    // deal with the typical multi-pointer behavior of two-thumb typing
    int pointerCount = me.getPointerCount();
    boolean result = false;
    if (pointerCount != mOldPointerCount) {
        long now = me.getEventTime();
        if (pointerCount == 1) {
            // Send a down event for the latest pointer
            MotionEvent down = MotionEvent.obtain(now, now, MotionEvent.ACTION_DOWN, me.getX(), me.getY(), me.getMetaState());
            result = onModifiedTouchEvent(down);
            down.recycle();
            // If it's an up action, then deliver the up as well.
            if (me.getAction() == MotionEvent.ACTION_UP) {
                result = onModifiedTouchEvent(me);
            }
        } else {
            // Send an up event for the last pointer
            MotionEvent up = MotionEvent.obtain(now, now, MotionEvent.ACTION_UP, mOldPointerX, mOldPointerY, me.getMetaState());
            result = onModifiedTouchEvent(up);
            up.recycle();
        }
    } else {
        if (pointerCount == 1) {
            mOldPointerX = me.getX();
            mOldPointerY = me.getY();
            result = onModifiedTouchEvent(me);
        } else {
            // Don't do anything when 2 pointers are down and moving.
            result = true;
        }
    }
    mOldPointerCount = pointerCount;
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There is a complete refactoring of this method by changing from specific switch instructions to simplifed if-else statements, so the code change is categorized as both 3) Control dependency changed and 4) Other statement changed.","Due to the overall function alteration, the method might behave very differently and exhibit a distinct return value, thus there is a potential Compatibility Issue caused by potential different return values or types, which is marked as 1."
284,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",4,5,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (LOGV_ENABLED) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + "", "" + event);
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 3. webview is in scroll-zoom state;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event) || (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM)) {
        return false;
    }
    if (mShiftIsPressed == false && nativeFocusNodeWantsKeyEvents() == false && (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT)) {
        mExtendSelection = false;
        mShiftIsPressed = true;
        if (nativeUpdateFocusNode()) {
            FocusNode node = mFocusNode;
            mSelectX = contentToView(node.mBounds.left);
            mSelectY = contentToView(node.mBounds.top);
        } else {
            mSelectX = mScrollX + (int) mLastTouchX;
            mSelectY = mScrollY + (int) mLastTouchY;
        }
        int contentX = viewToContent((int) mLastTouchX + mScrollX);
        int contentY = viewToContent((int) mLastTouchY + mScrollY);
        nativeClearFocus(contentX, contentY);
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        // always handle the navigation keys in the UI thread
        switchOutDrawHistory();
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER || keyCode == KeyEvent.KEYCODE_ENTER) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            mGotEnterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_ENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                // ""/data/data/com.android.browser/displayTree.txt""
                nativeDumpDisplayTree(getUrl());
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                // 5: dump the dom tree to the file
                // ""/data/data/com.android.browser/domTree.txt""
                // 6: dump the dom tree to the adb log
                mWebViewCore.sendMessage(EventHub.DUMP_DOMTREE, (keyCode == KeyEvent.KEYCODE_5) ? 1 : 0, 0);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                // 7: dump the render tree to the file
                // ""/data/data/com.android.browser/renderTree.txt""
                // 8: dump the render tree to the adb log
                mWebViewCore.sendMessage(EventHub.DUMP_RENDERTREE, (keyCode == KeyEvent.KEYCODE_7) ? 1 : 0, 0);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeFocusNodeWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (mShiftIsPressed == false && nativeCursorWantsKeyEvents() == false && (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT)) {
        mExtendSelection = false;
        mShiftIsPressed = true;
        if (nativeHasCursorNode()) {
            Rect rect = nativeCursorNodeBounds();
            mSelectX = contentToViewX(rect.left);
            mSelectY = contentToViewY(rect.top);
        } else {
            mSelectX = mScrollX + (int) mLastTouchX;
            mSelectY = mScrollY + (int) mLastTouchY;
        }
        nativeHideCursor();
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        // always handle the navigation keys in the UI thread
        switchOutDrawHistory();
        if (navHandledKey(keyCode, 1, false, event.getEventTime(), false)) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode != KeyEvent.KEYCODE_SHIFT_LEFT && keyCode != KeyEvent.KEYCODE_SHIFT_RIGHT) {
        // turn off copy select if a shift-key combo is pressed
        mExtendSelection = mShiftIsPressed = false;
        if (mTouchMode == TOUCH_SELECT_MODE) {
            mTouchMode = TOUCH_INIT_MODE;
        }
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                // ""/data/data/com.android.browser/displayTree.txt""
                nativeDumpDisplayTree(getUrl());
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                // 5: dump the dom tree to the file
                // ""/data/data/com.android.browser/domTree.txt""
                // 6: dump the dom tree to the adb log
                mWebViewCore.sendMessage(EventHub.DUMP_DOMTREE, (keyCode == KeyEvent.KEYCODE_5) ? 1 : 0, 0);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                // 7: dump the render tree to the file
                // ""/data/data/com.android.browser/renderTree.txt""
                // 8: dump the render tree to the adb log
                mWebViewCore.sendMessage(EventHub.DUMP_RENDERTREE, (keyCode == KeyEvent.KEYCODE_7) ? 1 : 0, 0);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsPlugin()) {
        nativeUpdatePluginReceivesEvents();
        invalidate();
    } else if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus, and make the focuscontroller active
        mWebViewCore.sendMessage(EventHub.CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        return mWebTextView.onKeyDown(keyCode, event);
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            return mWebTextView.onKeyDown(keyCode, event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There were several changes made between the two different versions. These include modifications to method names, where ""nativeFocusNodeWantsKeyEvents()"" changes to ""nativeCursorWantsKeyEvents()"" and ""nativeFocusNode()"" changes to ""nativeHasCursorNode()"", indicating a dependent API change. Control dependency changes took place with the addition of new conditions in the logic. In addition, return statements have been modified as more logic got added in the late version to determine the return value.","Given the changes in the implementation, the API potential returns a different boolean value to the user and therefore, a Compatibility Issue exists where a different return type or value can be provided."
285,<android.content.ContentResolver: void cancelSync(Uri)>,4,5,<android.content.ContentResolver: void cancelSync(Uri)>,<android.content.ContentResolver: void cancelSync(Uri)>,0,"{
    try {
        getContentService().cancelSync(uri);
    } catch (RemoteException e) {
    }
}","{
    cancelSync(null, /* all accounts */
    uri != null ? uri.getAuthority() : null);
}",1,,"/**
 * Cancel any active or pending syncs that match the Uri. If the uri is null then
 * all syncs will be canceled.
 *
 * @param uri the uri of the provider to sync or null to sync all providers.
 * @deprecated instead use {@link #cancelSync(android.accounts.Account, String)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has dramatically changed with the previous version calling getContentService().cancelSync(uri) while the new implementation calls cancelSync(null, /* all accounts */ uri != null ? uri.getAuthority() : null). The dependent API has also been changed, thus the code change type is 1,5.","Due to the drastic change in how the method is implemented, it can potentially return different results, thus leading to a Compatibility Issue. The type of CI in this scenario is 1."
287,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>",4,5,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>","<android.webkit.WebView: boolean restorePicture(Bundle,File)>",0,"{
    if (src == null || b == null) {
        return false;
    }
    if (src.exists()) {
        Picture p = null;
        try {
            final FileInputStream in = new FileInputStream(src);
            p = Picture.createFromStream(in);
            in.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (p != null) {
            int sx = b.getInt(""scrollX"", 0);
            int sy = b.getInt(""scrollY"", 0);
            float scale = b.getFloat(""scale"", 1.0f);
            mDrawHistory = true;
            mHistoryPicture = p;
            mScrollX = sx;
            mScrollY = sy;
            mHistoryWidth = Math.round(p.getWidth() * scale);
            mHistoryHeight = Math.round(p.getHeight() * scale);
            // as getWidth() / getHeight() of the view are not
            // available yet, set up mActualScale, so that when
            // onSizeChanged() is called, the rest will be set
            // correctly
            mActualScale = scale;
            invalidate();
            return true;
        }
    }
    return false;
}","{
    if (src == null || b == null) {
        return false;
    }
    if (src.exists()) {
        Picture p = null;
        try {
            final FileInputStream in = new FileInputStream(src);
            p = Picture.createFromStream(in);
            in.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (p != null) {
            int sx = b.getInt(""scrollX"", 0);
            int sy = b.getInt(""scrollY"", 0);
            float scale = b.getFloat(""scale"", 1.0f);
            mDrawHistory = true;
            mHistoryPicture = p;
            mScrollX = sx;
            mScrollY = sy;
            mHistoryWidth = Math.round(p.getWidth() * scale);
            mHistoryHeight = Math.round(p.getHeight() * scale);
            // as getWidth() / getHeight() of the view are not
            // available yet, set up mActualScale, so that when
            // onSizeChanged() is called, the rest will be set
            // correctly
            mActualScale = scale;
            float lastScale = b.getFloat(""lastScale"", -1.0f);
            if (lastScale > 0) {
                mInZoomOverview = true;
                mLastScale = lastScale;
            } else {
                mInZoomOverview = false;
            }
            invalidate();
            return true;
        }
    }
    return false;
}",1,"/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
","/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition statement has been introduced after mActualScale = scale; in the late version. It checks for the value of lastScale can vary, if it's bigger than 0, it modifies the values of mInZoomOverview and mLastScale. Therefore the code change type is 3.","The additional code lines in the late version only affect some internal states of the object and do not affect the return value or the exception handling, thus there are no compatibility issues (CI type 0)."
288,"<android.database.DatabaseUtils: void writeExceptionToParcel(Parcel,Exception)>",4,5,"<android.database.DatabaseUtils: void writeExceptionToParcel(Parcel,Exception)>","<android.database.DatabaseUtils: void writeExceptionToParcel(Parcel,Exception)>",0,"{
    int code = 0;
    boolean logException = true;
    if (e instanceof FileNotFoundException) {
        code = 1;
        logException = false;
    } else if (e instanceof IllegalArgumentException) {
        code = 2;
    } else if (e instanceof UnsupportedOperationException) {
        code = 3;
    } else if (e instanceof SQLiteAbortException) {
        code = 4;
    } else if (e instanceof SQLiteConstraintException) {
        code = 5;
    } else if (e instanceof SQLiteDatabaseCorruptException) {
        code = 6;
    } else if (e instanceof SQLiteFullException) {
        code = 7;
    } else if (e instanceof SQLiteDiskIOException) {
        code = 8;
    } else if (e instanceof SQLiteException) {
        code = 9;
    } else {
        reply.writeException(e);
        Log.e(TAG, ""Writing exception to parcel"", e);
        return;
    }
    reply.writeInt(code);
    reply.writeString(e.getMessage());
    if (logException) {
        Log.e(TAG, ""Writing exception to parcel"", e);
    }
}","{
    int code = 0;
    boolean logException = true;
    if (e instanceof FileNotFoundException) {
        code = 1;
        logException = false;
    } else if (e instanceof IllegalArgumentException) {
        code = 2;
    } else if (e instanceof UnsupportedOperationException) {
        code = 3;
    } else if (e instanceof SQLiteAbortException) {
        code = 4;
    } else if (e instanceof SQLiteConstraintException) {
        code = 5;
    } else if (e instanceof SQLiteDatabaseCorruptException) {
        code = 6;
    } else if (e instanceof SQLiteFullException) {
        code = 7;
    } else if (e instanceof SQLiteDiskIOException) {
        code = 8;
    } else if (e instanceof SQLiteException) {
        code = 9;
    } else if (e instanceof OperationApplicationException) {
        code = 10;
    } else {
        reply.writeException(e);
        Log.e(TAG, ""Writing exception to parcel"", e);
        return;
    }
    reply.writeInt(code);
    reply.writeString(e.getMessage());
    if (logException) {
        Log.e(TAG, ""Writing exception to parcel"", e);
    }
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * exception will be re-thrown by the function in another process
 * @param reply Parcel to write to
 * @param e The Exception to be written.
 * @see Parcel#writeNoException
 * @see Parcel#writeException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * exception will be re-thrown by the function in another process
 * @param reply Parcel to write to
 * @param e The Exception to be written.
 * @see Parcel#writeNoException
 * @see Parcel#writeException
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,2,"In the late version, a new else-if branch has been added to handle a new type of exception, which is 'OperationApplicationException'. Therefore, the change type is 3 (Control dependency change).","This change creates a potential Compatibility Issue under specific situations. If an instance of 'OperationApplicationException' was passed to this method, in the early version it would have been treated as a generic Exception and resulted in calling to reply.writeException(e), whereas in the new version it has a specific handling now which changes the exception handling behaviour, hence CI type is 2 (Compatibility Issue caused by potential different exception handling)."
289,<android.widget.ListView: void layoutChildren()>,4,5,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread."");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
                if (ViewDebug.TRACE_RECYCLER) {
                    ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);
                }
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewRoot assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            mSelectedTop = 0;
            mSelectorRect.setEmpty();
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i));
                if (ViewDebug.TRACE_RECYCLER) {
                    ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);
                }
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewRoot assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        // removeAllViewsInLayout();
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code from line containing ""throw new IllegalStateException..."" to the end has been appended with more specific detail information about the view. And there are a few lines of codes added for the condition ""if (sel != null)"". Therefore, this change type is classified as 4 which is ""Other statement changed"".","However, these changes don't affect the return type/value or exception thrown, thus there will be no Compatibility Issue. So CI type is 0."
290,<android.view.MotionEvent: int getHistorySize()>,4,5,<android.view.MotionEvent: int getHistorySize()>,<android.view.MotionEvent: int getHistorySize()>,0,"{
    return mNumHistory;
}","{
    return mNumSamples - 1;
}",1,"/**
 * Returns the number of historical points in this event.  These are
 * movements that have occurred between this event and the previous event.
 * This only applies to ACTION_MOVE events -- all other actions will have
 * a size of 0.
 *
 * @return Returns the number of historical points in the event.
 */
","/**
 * Returns the number of historical points in this event.  These are
 * movements that have occurred between this event and the previous event.
 * This only applies to ACTION_MOVE events -- all other actions will have
 * a size of 0.
 *
 * @return Returns the number of historical points in the event.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return value of the API has changed from mNumHistory to mNumSamples - 1, so the code change type is 1. ","The return value of this API has changed which can potentially lead to different returned values in different versions of the API, so it's a compatibility issue of type 1."
292,"<android.webkit.WebView: void moveSelection(float,float)>",4,5,"<android.webkit.WebView: void moveSelection(float,float)>","<android.webkit.WebView: void moveSelection(float,float)>",0,"{
    if (mNativeClass == 0)
        return;
    int width = getViewWidth();
    int height = getViewHeight();
    mSelectX += scaleTrackballX(xRate, width);
    mSelectY += scaleTrackballY(yRate, height);
    int maxX = width + mScrollX;
    int maxY = height + mScrollY;
    mSelectX = Math.min(maxX, Math.max(mScrollX - SELECT_CURSOR_OFFSET, mSelectX));
    mSelectY = Math.min(maxY, Math.max(mScrollY - SELECT_CURSOR_OFFSET, mSelectY));
    if (LOGV_ENABLED) {
        Log.v(LOGTAG, ""moveSelection"" + "" mSelectX="" + mSelectX + "" mSelectY="" + mSelectY + "" mScrollX="" + mScrollX + "" mScrollY="" + mScrollY + "" xRate="" + xRate + "" yRate="" + yRate);
    }
    nativeMoveSelection(viewToContent(mSelectX), viewToContent(mSelectY), mExtendSelection);
    int scrollX = mSelectX < mScrollX ? -SELECT_CURSOR_OFFSET : mSelectX > maxX - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    int scrollY = mSelectY < mScrollY ? -SELECT_CURSOR_OFFSET : mSelectY > maxY - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    pinScrollBy(scrollX, scrollY, true, 0);
    Rect select = new Rect(mSelectX, mSelectY, mSelectX + 1, mSelectY + 1);
    requestRectangleOnScreen(select);
    invalidate();
}","{
    if (mNativeClass == 0)
        return;
    int width = getViewWidth();
    int height = getViewHeight();
    mSelectX += scaleTrackballX(xRate, width);
    mSelectY += scaleTrackballY(yRate, height);
    int maxX = width + mScrollX;
    int maxY = height + mScrollY;
    mSelectX = Math.min(maxX, Math.max(mScrollX - SELECT_CURSOR_OFFSET, mSelectX));
    mSelectY = Math.min(maxY, Math.max(mScrollY - SELECT_CURSOR_OFFSET, mSelectY));
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""moveSelection"" + "" mSelectX="" + mSelectX + "" mSelectY="" + mSelectY + "" mScrollX="" + mScrollX + "" mScrollY="" + mScrollY + "" xRate="" + xRate + "" yRate="" + yRate);
    }
    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), mExtendSelection);
    int scrollX = mSelectX < mScrollX ? -SELECT_CURSOR_OFFSET : mSelectX > maxX - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    int scrollY = mSelectY < mScrollY ? -SELECT_CURSOR_OFFSET : mSelectY > maxY - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    pinScrollBy(scrollX, scrollY, true, 0);
    Rect select = new Rect(mSelectX, mSelectY, mSelectX + 1, mSelectY + 1);
    requestRectangleOnScreen(select);
    invalidate();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The condition in the 'if' statement has changed from LOGV_ENABLED to DebugFlags.WEB_VIEW (type 3); two methods nativeMoveSelection and viewToContent have been changed to nativeMoveSelection and viewToContentX, viewToContentY (type 5); and no return statement has been introduced or deleted (type 1). So, the change type is 1,4,5.","The change of methods can potentially change the return variables/values, causing the behavior of the API to be different. Hence, the CI type is 1."
296,<android.hardware.Camera.Parameters: Size getPictureSize()>,4,5,<android.hardware.Camera.Parameters: Size getPictureSize()>,<android.hardware.Camera.Parameters: Size getPictureSize()>,0,"{
    String pair = get(""picture-size"");
    if (pair == null)
        return null;
    String[] dims = pair.split(""x"");
    if (dims.length != 2)
        return null;
    return new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1]));
}","{
    String pair = get(KEY_PICTURE_SIZE);
    return strToSize(pair);
}",1,"/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
","/**
 * Returns the dimension setting for pictures.
 *
 * @return a Size object with the height and width setting
 * for pictures
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The Late_Implementation has made several changes: 1) It removes multiple statements, and changes the return statement to return strToSize(pair) 2) Removes the 'if' control logic and brings in a new dependent method strToSize(). Hence the change type is 1,4,5.","The removed control logic and changed return statement introduces a potential variation in return values, thus leading to Compatibility Issue type 1."
297,<android.database.sqlite.SQLiteDatabase: boolean yieldIfContended()>,4,5,<android.database.sqlite.SQLiteDatabase: boolean yieldIfContended()>,<android.database.sqlite.SQLiteDatabase: boolean yieldIfContended()>,0,"{
    return yieldIfContendedHelper(false);
}","{
    return yieldIfContendedHelper(false, /* do not check yielding */
    -1);
}",1,"/**
 * Temporarily end the transaction to let other threads run. The transaction is assumed to be
 * successful so far. Do not call setTransactionSuccessful before calling this. When this
 * returns a new transaction will have been created but not marked as successful.
 * @return true if the transaction was yielded
 * @deprecated if the db is locked more than once (becuase of nested transactions) then the lock
 * will not be yielded. Use yieldIfContendedSafely instead.
 */
","/**
 * Temporarily end the transaction to let other threads run. The transaction is assumed to be
 * successful so far. Do not call setTransactionSuccessful before calling this. When this
 * returns a new transaction will have been created but not marked as successful.
 * @return true if the transaction was yielded
 * @deprecated if the db is locked more than once (becuase of nested transactions) then the lock
 * will not be yielded. Use yieldIfContendedSafely instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from return yieldIfContendedHelper(false); to return yieldIfContendedHelper(false, -1); in the late version, which results in pred_change 1.","The change in the return statement can potentially cause the method to return a different value, which leads to pred_CI 1."
305,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,4,5,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,<android.app.ActivityThread.PackageInfo.ReceiverDispatcher.Args: void run()>,0,"{
    BroadcastReceiver receiver = mReceiver;
    if (DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Dispathing broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
    }
    if (receiver == null) {
        return;
    }
    IActivityManager mgr = ActivityManagerNative.getDefault();
    Intent intent = mCurIntent;
    mCurIntent = null;
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        if (mCurMap != null) {
            mCurMap.setClassLoader(cl);
        }
        receiver.setOrderedHint(true);
        receiver.setResult(mCurCode, mCurData, mCurMap);
        receiver.clearAbortBroadcast();
        receiver.setOrderedHint(mCurOrdered);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && mCurOrdered) {
            try {
                mgr.finishReceiver(mIIntentReceiver, mCurCode, mCurData, mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (mRegistered && mCurOrdered) {
        try {
            mgr.finishReceiver(mIIntentReceiver, receiver.getResultCode(), receiver.getResultData(), receiver.getResultExtras(false), receiver.getAbortBroadcast());
        } catch (RemoteException ex) {
        }
    }
}","{
    BroadcastReceiver receiver = mReceiver;
    if (DEBUG_BROADCAST) {
        int seq = mCurIntent.getIntExtra(""seq"", -1);
        Log.i(TAG, ""Dispathing broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
    }
    if (receiver == null) {
        return;
    }
    IActivityManager mgr = ActivityManagerNative.getDefault();
    Intent intent = mCurIntent;
    mCurIntent = null;
    try {
        ClassLoader cl = mReceiver.getClass().getClassLoader();
        intent.setExtrasClassLoader(cl);
        if (mCurMap != null) {
            mCurMap.setClassLoader(cl);
        }
        receiver.setOrderedHint(true);
        receiver.setResult(mCurCode, mCurData, mCurMap);
        receiver.clearAbortBroadcast();
        receiver.setOrderedHint(mCurOrdered);
        receiver.setInitialStickyHint(mCurSticky);
        receiver.onReceive(mContext, intent);
    } catch (Exception e) {
        if (mRegistered && mCurOrdered) {
            try {
                mgr.finishReceiver(mIIntentReceiver, mCurCode, mCurData, mCurMap, false);
            } catch (RemoteException ex) {
            }
        }
        if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
            throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
        }
    }
    if (mRegistered && mCurOrdered) {
        try {
            mgr.finishReceiver(mIIntentReceiver, receiver.getResultCode(), receiver.getResultData(), receiver.getResultExtras(false), receiver.getAbortBroadcast());
        } catch (RemoteException ex) {
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method called 'setInitialStickyHint(mCurSticky)' is invoked on 'receiver', but other parts kept the same.","The invoked method 'setInitialStickyHint()' did not affect the returned result and the exception handling of the current method, so no compatibility issue exists."
306,"<android.widget.AutoCompleteTextView: boolean onKeyPreIme(int,KeyEvent)>",4,5,"<android.widget.AutoCompleteTextView: boolean onKeyPreIme(int,KeyEvent)>","<android.widget.AutoCompleteTextView: boolean onKeyPreIme(int,KeyEvent)>",0,"{
    if (isPopupShowing()) {
        // to the drop down list but instead, consume it immediately
        if (keyCode == KeyEvent.KEYCODE_BACK && !mDropDownAlwaysVisible) {
            dismissDropDown();
            return true;
        }
    }
    return super.onKeyPreIme(keyCode, event);
}","{
    if (keyCode == KeyEvent.KEYCODE_BACK && isPopupShowing() && !mDropDownAlwaysVisible) {
        // to the drop down list but instead, consume it immediately
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            getKeyDispatcherState().startTracking(event, this);
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            getKeyDispatcherState().handleUpEvent(event);
            if (event.isTracking() && !event.isCanceled()) {
                dismissDropDown();
                return true;
            }
        }
    }
    return super.onKeyPreIme(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The if block statements have been changed significantly in the Late_Implementation compared to the Early_Implementation. The Late_Implementation has additional / different control flow and return statements so the change type is 1,3.","The new implementation includes changes to return statements inside different control structures. These may result in a different returned value and thus cause a different behavior. So, the CI type is 1."
307,<android.webkit.LoadListener: void loadSynchronousMessages()>,4,5,<android.webkit.LoadListener: void loadSynchronousMessages()>,<android.webkit.LoadListener: void loadSynchronousMessages()>,0,"{
    if (WebView.DEBUG && !mSynchronous) {
        throw new AssertionError();
    }
    // don't set it to null.
    for (int size = mMessageQueue.size(); size > 0; size--) {
        handleMessage(mMessageQueue.remove(0));
    }
}","{
    if (DebugFlags.LOAD_LISTENER && !mSynchronous) {
        throw new AssertionError();
    }
    // don't set it to null.
    for (int size = mMessageQueue.size(); size > 0; size--) {
        handleMessage(mMessageQueue.remove(0));
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The conditional statement condition has changed from ""WebView.DEBUG"" to ""DebugFlags.LOAD_LISTENER"", so the code change type is 4.","The change of the condition won't make any difference to the value of the return statement or the exception thrown since the AssertionError is thrown when the WebView 'DEBUG' or 'LOAD_LISTENER' is true and 'mSynchronous' is false. Therefore, there are no compatibility issues (CI type 0)."
308,<android.content.res.Configuration: String toString()>,4,5,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{ scale="");
    sb.append(fontScale);
    sb.append("" imsi="");
    sb.append(mcc);
    sb.append(""/"");
    sb.append(mnc);
    sb.append("" loc="");
    sb.append(locale);
    sb.append("" touch="");
    sb.append(touchscreen);
    sb.append("" keys="");
    sb.append(keyboard);
    sb.append(""/"");
    sb.append(keyboardHidden);
    sb.append(""/"");
    sb.append(hardKeyboardHidden);
    sb.append("" nav="");
    sb.append(navigation);
    sb.append("" orien="");
    sb.append(orientation);
    sb.append("" layout="");
    sb.append(screenLayout);
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{ scale="");
    sb.append(fontScale);
    sb.append("" imsi="");
    sb.append(mcc);
    sb.append(""/"");
    sb.append(mnc);
    sb.append("" loc="");
    sb.append(locale);
    sb.append("" touch="");
    sb.append(touchscreen);
    sb.append("" keys="");
    sb.append(keyboard);
    sb.append(""/"");
    sb.append(keyboardHidden);
    sb.append(""/"");
    sb.append(hardKeyboardHidden);
    sb.append("" nav="");
    sb.append(navigation);
    sb.append(""/"");
    sb.append(navigationHidden);
    sb.append("" orien="");
    sb.append(orientation);
    sb.append("" layout="");
    sb.append(screenLayout);
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The attribute 'navigationHidden' has been added to the late implementation, which will modify the string built inside the 'toString' method. This corresponds to 'Return statement changed' and 'Other statement changed'. So the code change type is 1,4.","The additional attribute 'navigationHidden' can result in a different output from the toString method in the late version, causing a potential compatibility issue due to different return values, so the CI type is 1."
309,"<android.webkit.CallbackProxy: void onPageStarted(String,Bitmap)>",4,5,"<android.webkit.CallbackProxy: void onPageStarted(String,Bitmap)>","<android.webkit.CallbackProxy: void onPageStarted(String,Bitmap)>",0,"{
    // been set.
    if (mWebViewClient == null) {
        return;
    }
    // Performance probe
    if (false) {
        mWebCoreThreadTime = SystemClock.currentThreadTimeMillis();
        Network.getInstance(mContext).startTiming();
    }
    Message msg = obtainMessage(PAGE_STARTED);
    msg.obj = favicon;
    msg.getData().putString(""url"", url);
    sendMessage(msg);
}","{
    // been set.
    if (mWebViewClient == null) {
        return;
    }
    // Performance probe
    if (PERF_PROBE) {
        mWebCoreThreadTime = SystemClock.currentThreadTimeMillis();
        mWebCoreIdleTime = 0;
        Network.getInstance(mContext).startTiming();
    // un-comment this if PERF_PROBE is true
    // Looper.myQueue().setWaitCallback(mIdleCallback);
    }
    Message msg = obtainMessage(PAGE_STARTED);
    msg.obj = favicon;
    msg.getData().putString(""url"", url);
    sendMessage(msg);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition in the 'if' statement has changed from 'false' to 'PERF_PROBE'. Additionally, a new statement 'mWebCoreIdleTime = 0' has been introduced under this 'if' block. Thus, the change type contains 3 and 4.","Although there is a change in the 'if' condition, it has no impact on the return value of the method, or the exception throwing. Therefore, there is no compatibility issue and the CI type is 0."
311,<android.webkit.BrowserFrame: String getRawResFilename(int)>,4,5,<android.webkit.BrowserFrame: String getRawResFilename(int)>,<android.webkit.BrowserFrame: String getRawResFilename(int)>,0,"{
    int resid;
    switch(id) {
        case NODOMAIN:
            resid = com.android.internal.R.raw.nodomain;
            break;
        case LOADERROR:
            resid = com.android.internal.R.raw.loaderror;
            break;
        default:
            Log.e(LOGTAG, ""getRawResFilename got incompatible resource ID"");
            return new String();
    }
    TypedValue value = new TypedValue();
    mContext.getResources().getValue(resid, value, true);
    return value.string.toString();
}","{
    int resid;
    switch(id) {
        case NODOMAIN:
            resid = com.android.internal.R.raw.nodomain;
            break;
        case LOADERROR:
            resid = com.android.internal.R.raw.loaderror;
            break;
        case DRAWABLEDIR:
            // use one known resource to find the drawable directory
            resid = com.android.internal.R.drawable.btn_check_off;
            break;
        default:
            Log.e(LOGTAG, ""getRawResFilename got incompatible resource ID"");
            return """";
    }
    TypedValue value = new TypedValue();
    mContext.getResources().getValue(resid, value, true);
    if (id == DRAWABLEDIR) {
        String path = value.string.toString();
        int index = path.lastIndexOf('/');
        if (index < 0) {
            Log.e(LOGTAG, ""Can't find drawable directory."");
            return """";
        }
        return path.substring(0, index + 1);
    }
    return value.string.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new case (case DRAWABLEDIR) has been introduced in the switch statement (Control dependency change). During this case, 'resid' is assigned a different value and a new last return statement is added which returns a string that differs from the early version (Return statement changed). Therefore, the code change type is 1,3.","The addition of a new case in the switch statement and its associated return could result in the API returning a different value, which has the potential to cause a compatibility issue. Therefore, the CI type is 1."
312,<android.webkit.CallbackProxy: boolean shouldOverrideUrlLoading(String)>,4,5,<android.webkit.CallbackProxy: boolean shouldOverrideUrlLoading(String)>,<android.webkit.CallbackProxy: boolean shouldOverrideUrlLoading(String)>,0,"{
    // We have a default behavior if no client exists so always send the
    // message.
    ResultTransport<Boolean> res = new ResultTransport<Boolean>();
    Message msg = obtainMessage(OVERRIDE_URL);
    msg.getData().putString(""url"", url);
    msg.obj = res;
    synchronized (this) {
        sendMessage(msg);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for overrideUrl"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    return res.getResult().booleanValue();
}","{
    // We have a default behavior if no client exists so always send the
    // message.
    ResultTransport<Boolean> res = new ResultTransport<Boolean>(false);
    Message msg = obtainMessage(OVERRIDE_URL);
    msg.getData().putString(""url"", url);
    msg.obj = res;
    synchronized (this) {
        sendMessage(msg);
        try {
            wait();
        } catch (InterruptedException e) {
            Log.e(LOGTAG, ""Caught exception while waiting for overrideUrl"");
            Log.e(LOGTAG, Log.getStackTraceString(e));
        }
    }
    return res.getResult().booleanValue();
}",1,"/**
 * Called by the WebCore side
 */
","/**
 * Called by the WebCore side
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The constructor of 'res' object has added a new parameter 'false', so this change is classified into 'other statement changed' which is 4.","The 'res' has a 'false' initial value in the late version, and it is returned by the function. This means the function could return different values. Therefore, the CI type is 1."
313,<android.webkit.WebView: void clearFormData()>,4,5,<android.webkit.WebView: void clearFormData()>,<android.webkit.WebView: void clearFormData()>,0,"{
    if (inEditingMode()) {
        AutoCompleteAdapter adapter = null;
        mTextEntry.setAdapterCustom(adapter);
    }
}","{
    if (inEditingMode()) {
        AutoCompleteAdapter adapter = null;
        mWebTextView.setAdapterCustom(adapter);
    }
}",1,"/**
 * Make sure that clearing the form data removes the adapter from the
 * currently focused textfield if there is one.
 */
","/**
 * Make sure that clearing the form data removes the adapter from the
 * currently focused textfield if there is one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The name of the instance variable changed from mTextEntry to mWebTextView, so the code change type is 4.","The change in instance variable name does not affect the return value or exception handling. Thus, there is no compatibility issue. The CI type is 0."
316,<android.webkit.WebViewDatabase: CacheResult getCache(String)>,4,5,<android.webkit.WebViewDatabase: CacheResult getCache(String)>,<android.webkit.WebViewDatabase: CacheResult getCache(String)>,0,"{
    if (url == null || mCacheDatabase == null) {
        return null;
    }
    Cursor cursor = mCacheDatabase.rawQuery(""SELECT filepath, lastmodify, etag, expires, "" + ""mimetype, encoding, httpstatus, location, contentlength "" + ""FROM cache WHERE url = ?"", new String[] { url });
    try {
        if (cursor.moveToFirst()) {
            CacheResult ret = new CacheResult();
            ret.localPath = cursor.getString(0);
            ret.lastModified = cursor.getString(1);
            ret.etag = cursor.getString(2);
            ret.expires = cursor.getLong(3);
            ret.mimeType = cursor.getString(4);
            ret.encoding = cursor.getString(5);
            ret.httpStatusCode = cursor.getInt(6);
            ret.location = cursor.getString(7);
            ret.contentLength = cursor.getLong(8);
            return ret;
        }
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return null;
}","{
    if (url == null || mCacheDatabase == null) {
        return null;
    }
    Cursor cursor = mCacheDatabase.rawQuery(""SELECT filepath, lastmodify, etag, expires, "" + ""expiresstring, mimetype, encoding, httpstatus, location, contentlength, "" + ""contentdisposition FROM cache WHERE url = ?"", new String[] { url });
    try {
        if (cursor.moveToFirst()) {
            CacheResult ret = new CacheResult();
            ret.localPath = cursor.getString(0);
            ret.lastModified = cursor.getString(1);
            ret.etag = cursor.getString(2);
            ret.expires = cursor.getLong(3);
            ret.expiresString = cursor.getString(4);
            ret.mimeType = cursor.getString(5);
            ret.encoding = cursor.getString(6);
            ret.httpStatusCode = cursor.getInt(7);
            ret.location = cursor.getString(8);
            ret.contentLength = cursor.getLong(9);
            ret.contentdisposition = cursor.getString(10);
            return ret;
        }
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return null;
}",1,"/**
 * Get a cache item.
 *
 * @param url The url
 * @return CacheResult The CacheManager.CacheResult
 */
","/**
 * Get a cache item.
 *
 * @param url The url
 * @return CacheResult The CacheManager.CacheResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The query string inside 'rawQuery' and the attributes of 'CacheResult' object have been modified, so the change types are 1 (Return statement changed) and 4 (Other statement changed).","Due to the change in the query, the 'CacheResult' object being returned will have different attribute values. Hence, there is a compatibility issue because the potential return value of the API has changed. The CI type is 1."
317,<android.text.util.Rfc822Tokenizer: Rfc822Token[] tokenize(CharSequence)>,4,5,<android.text.util.Rfc822Tokenizer: Rfc822Token[] tokenize(CharSequence)>,<android.text.util.Rfc822Tokenizer: Rfc822Token[] tokenize(CharSequence)>,0,"{
    ArrayList<Rfc822Token> out = new ArrayList<Rfc822Token>();
    StringBuilder name = new StringBuilder();
    StringBuilder address = new StringBuilder();
    StringBuilder comment = new StringBuilder();
    int i = 0;
    int cursor = text.length();
    while (i < cursor) {
        char c = text.charAt(i);
        if (c == ',' || c == ';') {
            i++;
            while (i < cursor && text.charAt(i) == ' ') {
                i++;
            }
            crunch(name);
            if (address.length() > 0) {
                out.add(new Rfc822Token(name.toString(), address.toString(), comment.toString()));
            } else if (name.length() > 0) {
                out.add(new Rfc822Token(null, name.toString(), comment.toString()));
            }
            name.setLength(0);
            address.setLength(0);
            address.setLength(0);
        } else if (c == '""') {
            i++;
            while (i < cursor) {
                c = text.charAt(i);
                if (c == '""') {
                    i++;
                    break;
                } else if (c == '\\') {
                    name.append(text.charAt(i + 1));
                    i += 2;
                } else {
                    name.append(c);
                    i++;
                }
            }
        } else if (c == '(') {
            int level = 1;
            i++;
            while (i < cursor && level > 0) {
                c = text.charAt(i);
                if (c == ')') {
                    if (level > 1) {
                        comment.append(c);
                    }
                    level--;
                    i++;
                } else if (c == '(') {
                    comment.append(c);
                    level++;
                    i++;
                } else if (c == '\\') {
                    comment.append(text.charAt(i + 1));
                    i += 2;
                } else {
                    comment.append(c);
                    i++;
                }
            }
        } else if (c == '<') {
            i++;
            while (i < cursor) {
                c = text.charAt(i);
                if (c == '>') {
                    i++;
                    break;
                } else {
                    address.append(c);
                    i++;
                }
            }
        } else if (c == ' ') {
            name.append('\0');
            i++;
        } else {
            name.append(c);
            i++;
        }
    }
    crunch(name);
    if (address.length() > 0) {
        out.add(new Rfc822Token(name.toString(), address.toString(), comment.toString()));
    } else if (name.length() > 0) {
        out.add(new Rfc822Token(null, name.toString(), comment.toString()));
    }
    return out.toArray(new Rfc822Token[out.size()]);
}","{
    ArrayList<Rfc822Token> out = new ArrayList<Rfc822Token>();
    tokenize(text, out);
    return out.toArray(new Rfc822Token[out.size()]);
}",1,"/**
 * This constructor will try to take a string like
 * ""Foo Bar (something) &lt;foo\@google.com&gt;,
 * blah\@google.com (something)""
 * and convert it into one or more Rfc822Tokens.
 * It does *not* decode MIME encoded-words; charset conversion
 * must already have taken place if necessary.
 * It will try to be tolerant of broken syntax instead of
 * returning an error.
 */
","/**
 * This method will try to take a string like
 * ""Foo Bar (something) &lt;foo\@google.com&gt;,
 * blah\@google.com (something)""
 * and convert it into one or more Rfc822Tokens.
 * It does *not* decode MIME encoded-words; charset conversion
 * must already have taken place if necessary.
 * It will try to be tolerant of broken syntax instead of
 * returning an error.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The entire implementation has been changed from a direct tokenizing implementation to a call to the tokenize() method. The new implementation appears to perform the same tokenization task but in a different way. This change is categorized as a Dependent API change type.,"There is no Compatibility Issue because though the implementation has changed, the return value and Throws exception types have not changed. The return type is the same array of Rfc822Token objects and no exception handling has been added, removed, or altered. So it will likely not cause the API to return a different variable or throw different/binary exceptions when invoked by client applications; and hence, it is deemed as no Compatibility Issue."
318,<android.app.Dialog: boolean onSearchRequested()>,4,5,<android.app.Dialog: boolean onSearchRequested()>,<android.app.Dialog: boolean onSearchRequested()>,0,"{
    final SearchManager searchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
    // can't start search without an associated activity (e.g a system dialog)
    if (!searchManager.hasIdent()) {
        return false;
    }
    // associate search with owner activity if possible (otherwise it will default to
    // global search).
    final ComponentName appName = mOwnerActivity == null ? null : mOwnerActivity.getComponentName();
    final boolean globalSearch = (appName == null);
    searchManager.startSearch(null, false, appName, null, globalSearch);
    dismiss();
    return true;
}","{
    final SearchManager searchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
    // can't start search without an associated activity (e.g a system dialog)
    if (!searchManager.hasIdent()) {
        return false;
    }
    // associate search with owner activity if possible (otherwise it will default to
    // global search).
    final ComponentName appName = getAssociatedActivity();
    final boolean globalSearch = (appName == null);
    searchManager.startSearch(null, false, appName, null, globalSearch);
    dismiss();
    return true;
}",1,"/**
 * This hook is called when the user signals the desire to start a search.
 */
","/**
 * This hook is called when the user signals the desire to start a search.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement that is used to assign value to variable 'appName' has been changed from 'final ComponentName appName = mOwnerActivity == null ? null : mOwnerActivity.getComponentName();' to 'final ComponentName appName = getAssociatedActivity();'. This change is regarded as other statement change and dependent API change, so the code change type is 4,5.","The value of 'appName' might be different due to the change of how it gets the value, which will subsequently influence the behaviors of 'searchManager.startSearch(null, false, appName, null, globalSearch);' and the return value. Thus, the CI type is 1."
319,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",4,5,"<android.view.LayoutInflater: View createView(String,String,AttributeSet)>","<android.view.LayoutInflater: View createView(String,String,AttributeSet)>",0,"{
    Constructor constructor = sConstructorMap.get(name);
    try {
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            Class clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    Class clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        return (View) constructor.newInstance(args);
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (constructor == null ? ""<unknown>"" : constructor.getClass().getName()));
        ie.initCause(e);
        throw ie;
    }
}","{
    Constructor constructor = sConstructorMap.get(name);
    Class clazz = null;
    try {
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        return (View) constructor.newInstance(args);
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + "": Error inflating class "" + (clazz == null ? ""<unknown>"" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    }
}",1,"/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantied view, or null.
 */
","/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantied view, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes in the implementation. A new variable 'clazz' is introduced in the outside try block, and it's used in the Exception handling for the last Exception catch block in which it threw an InflateException. So the change type is detected as 3 and 4.","Despite the code changes, it's unlikely that they will lead to potential incompatible issues between the Android API versions. The changes all refer to internal code modifications and mainly affect how the InflateException message outputs the class name. As a result, the CI type is 0."
320,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",4,5,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = deviceId;
    ev.mEdgeFlags = edgeFlags;
    ev.mDownTime = downTime;
    ev.mEventTime = eventTime;
    ev.mAction = action;
    ev.mX = ev.mRawX = x;
    ev.mY = ev.mRawY = y;
    ev.mPressure = pressure;
    ev.mSize = size;
    ev.mMetaState = metaState;
    ev.mXPrecision = xPrecision;
    ev.mYPrecision = yPrecision;
    return ev;
}","{
    MotionEvent ev = obtain();
    ev.mDeviceId = deviceId;
    ev.mEdgeFlags = edgeFlags;
    ev.mDownTime = downTime;
    ev.mEventTimeNano = eventTime * 1000000;
    ev.mAction = action;
    ev.mMetaState = metaState;
    ev.mXPrecision = xPrecision;
    ev.mYPrecision = yPrecision;
    ev.mNumPointers = 1;
    ev.mNumSamples = 1;
    int[] pointerIds = ev.mPointerIdentifiers;
    pointerIds[0] = 0;
    float[] data = ev.mDataSamples;
    data[SAMPLE_X] = ev.mRawX = x;
    data[SAMPLE_Y] = ev.mRawY = y;
    data[SAMPLE_PRESSURE] = pressure;
    data[SAMPLE_SIZE] = size;
    ev.mTimeSamples[0] = eventTime;
    return ev;
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, where touched by this
 * MotionEvent.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, where touched by this
 * MotionEvent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement remains the same, but the calculation and assignments to the attributes of the returned object have changed. For example, the assignment of `mEventTimeNano` and `mNumPointers`, `mNumSamples` have been introduced in the later version. Therefore, the code change type is 1,4.","These attribute modifications could lead to alterations in the return results of this API across different versions. Therefore, the API will potentially return a different value, and the CI type is 1."
321,<android.webkit.WebView: HitTestResult getHitTestResult()>,4,5,<android.webkit.WebView: HitTestResult getHitTestResult()>,<android.webkit.WebView: HitTestResult getHitTestResult()>,0,"{
    if (mNativeClass == 0) {
        return null;
    }
    HitTestResult result = new HitTestResult();
    if (nativeUpdateFocusNode()) {
        FocusNode node = mFocusNode;
        if (node.mIsTextField || node.mIsTextArea) {
            result.setType(HitTestResult.EDIT_TEXT_TYPE);
        } else if (node.mText != null) {
            String text = node.mText;
            if (text.startsWith(SCHEME_TEL)) {
                result.setType(HitTestResult.PHONE_TYPE);
                result.setExtra(text.substring(SCHEME_TEL.length()));
            } else if (text.startsWith(SCHEME_MAILTO)) {
                result.setType(HitTestResult.EMAIL_TYPE);
                result.setExtra(text.substring(SCHEME_MAILTO.length()));
            } else if (text.startsWith(SCHEME_GEO)) {
                result.setType(HitTestResult.GEO_TYPE);
                result.setExtra(URLDecoder.decode(text.substring(SCHEME_GEO.length())));
            } else if (node.mIsAnchor) {
                result.setType(HitTestResult.SRC_ANCHOR_TYPE);
                result.setExtra(text);
            }
        }
    }
    int type = result.getType();
    if (type == HitTestResult.UNKNOWN_TYPE || type == HitTestResult.SRC_ANCHOR_TYPE) {
        // Now check to see if it is an image.
        int contentX = viewToContent((int) mLastTouchX + mScrollX);
        int contentY = viewToContent((int) mLastTouchY + mScrollY);
        String text = nativeImageURI(contentX, contentY);
        if (text != null) {
            result.setType(type == HitTestResult.UNKNOWN_TYPE ? HitTestResult.IMAGE_TYPE : HitTestResult.SRC_IMAGE_ANCHOR_TYPE);
            result.setExtra(text);
        }
    }
    return result;
}","{
    if (mNativeClass == 0) {
        return null;
    }
    HitTestResult result = new HitTestResult();
    if (nativeHasCursorNode()) {
        if (nativeCursorIsTextInput()) {
            result.setType(HitTestResult.EDIT_TEXT_TYPE);
        } else {
            String text = nativeCursorText();
            if (text != null) {
                if (text.startsWith(SCHEME_TEL)) {
                    result.setType(HitTestResult.PHONE_TYPE);
                    result.setExtra(text.substring(SCHEME_TEL.length()));
                } else if (text.startsWith(SCHEME_MAILTO)) {
                    result.setType(HitTestResult.EMAIL_TYPE);
                    result.setExtra(text.substring(SCHEME_MAILTO.length()));
                } else if (text.startsWith(SCHEME_GEO)) {
                    result.setType(HitTestResult.GEO_TYPE);
                    result.setExtra(URLDecoder.decode(text.substring(SCHEME_GEO.length())));
                } else if (nativeCursorIsAnchor()) {
                    result.setType(HitTestResult.SRC_ANCHOR_TYPE);
                    result.setExtra(text);
                }
            }
        }
    }
    int type = result.getType();
    if (type == HitTestResult.UNKNOWN_TYPE || type == HitTestResult.SRC_ANCHOR_TYPE) {
        // Now check to see if it is an image.
        int contentX = viewToContentX((int) mLastTouchX + mScrollX);
        int contentY = viewToContentY((int) mLastTouchY + mScrollY);
        String text = nativeImageURI(contentX, contentY);
        if (text != null) {
            result.setType(type == HitTestResult.UNKNOWN_TYPE ? HitTestResult.IMAGE_TYPE : HitTestResult.SRC_IMAGE_ANCHOR_TYPE);
            result.setExtra(text);
        }
    }
    return result;
}",1,"/**
 * Return a HitTestResult based on the current focus node. If a HTML::a tag
 * is found and the anchor has a non-javascript url, the HitTestResult type
 * is set to SRC_ANCHOR_TYPE and the url is set in the ""extra"" field. If the
 * anchor does not have a url or if it is a javascript url, the type will
 * be UNKNOWN_TYPE and the url has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the url is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a url that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
","/**
 * Return a HitTestResult based on the current cursor node. If a HTML::a tag
 * is found and the anchor has a non-javascript url, the HitTestResult type
 * is set to SRC_ANCHOR_TYPE and the url is set in the ""extra"" field. If the
 * anchor does not have a url or if it is a javascript url, the type will
 * be UNKNOWN_TYPE and the url has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the url is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a url that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"Variable and method calls are replaced (e.g., nativeUpdateFocusNode() vs nativeHasCursorNode()). Also, control statements (if condition) are modified. Some method calls are changed as well (e.g. viewToContent() vs viewToContentX() and viewToContentY()). Therefore, the code change types are 1,3,4,5.","Since variable assignment and method calls are altered, and the return type HitTestResult's properties are set based on these altered variables, the API potentially returns different values, hence the CI type is 1."
322,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,4,5,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,0,"{
    if (LOGV_ENABLED) {
        Log.v(LOGTAG, msg.what < REMEMBER_PASSWORD || msg.what > INVAL_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                if (mTouchMode == TOUCH_INIT_MODE) {
                    mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                    updateSelection();
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (!mPreventDrag) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    updateTextEntry();
                }
                break;
            }
        case SWITCH_TO_ENTER:
            if (LOGV_ENABLED)
                Log.v(LOGTAG, ""SWITCH_TO_ENTER"");
            mTouchMode = TOUCH_DONE_MODE;
            onKeyUp(KeyEvent.KEYCODE_ENTER, new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER));
            break;
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case NEW_PICTURE_MSG_ID:
            // called for new content
            final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
            final Point viewSize = draw.mViewPoint;
            if (mZoomScale > 0) {
                // can clear mZoomScale
                if (Math.round(getViewWidth() / mZoomScale) == viewSize.x) {
                    mZoomScale = 0;
                    mWebViewCore.sendMessage(EventHub.SET_SNAP_ANCHOR, 0, 0);
                }
            }
            if (!mMinZoomScaleFixed) {
                mMinZoomScale = (float) getViewWidth() / Math.max(ZOOM_OUT_WIDTH, draw.mWidthHeight.x);
            }
            // We update the layout (i.e. request a layout from the
            // view system) if the last view size that we sent to
            // WebCore matches the view size of the picture we just
            // received in the fixed dimension.
            final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
            recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y, updateLayout);
            if (LOGV_ENABLED) {
                Rect b = draw.mInvalRegion.getBounds();
                Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
            }
            invalidate(contentToView(draw.mInvalRegion.getBounds()));
            if (mPictureListener != null) {
                mPictureListener.onNewPicture(WebView.this, capturePicture());
            }
            break;
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mTextEntry.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mTextEntry.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mTextEntry.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mTextEntry.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mTextEntry.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case DID_FIRST_LAYOUT_MSG_ID:
            if (mNativeClass == 0) {
                break;
            }
            // Do not reset the focus or clear the text; the user may have already
            // navigated or entered text at this point. The focus should have gotten
            // reset, if need be, when the focus cache was built. Similarly, the text
            // view should already be torn down and rebuilt if needed.
            // nativeResetFocus();
            // clearTextEntry();
            HashMap scaleLimit = (HashMap) msg.obj;
            int minScale = (Integer) scaleLimit.get(""minScale"");
            if (minScale == 0) {
                mMinZoomScale = DEFAULT_MIN_ZOOM_SCALE;
                mMinZoomScaleFixed = false;
            } else {
                mMinZoomScale = (float) (minScale / 100.0);
                mMinZoomScaleFixed = true;
            }
            int maxScale = (Integer) scaleLimit.get(""maxScale"");
            if (maxScale == 0) {
                mMaxZoomScale = DEFAULT_MAX_ZOOM_SCALE;
            } else {
                mMaxZoomScale = (float) (maxScale / 100.0);
            }
            // If history Picture is drawn, don't update zoomWidth
            if (mDrawHistory) {
                break;
            }
            int width = getViewWidth();
            if (width == 0) {
                break;
            }
            int initialScale = msg.arg1;
            int viewportWidth = msg.arg2;
            // start a new page with DEFAULT_SCALE zoom scale.
            float scale = mDefaultScale;
            if (mInitialScale > 0) {
                scale = mInitialScale / 100.0f;
            } else {
                if (mWebViewCore.getSettings().getUseWideViewPort()) {
                    // force viewSizeChanged by setting mLastWidthSent
                    // to 0
                    mLastWidthSent = 0;
                }
                if (initialScale == 0) {
                    // than the view width, zoom in to fill the view
                    if (viewportWidth > 0 && viewportWidth < width) {
                        scale = (float) width / viewportWidth;
                    }
                } else {
                    scale = initialScale / 100.0f;
                }
            }
            setNewZoomScale(scale, false);
            break;
        case MARK_NODE_INVALID_ID:
            nativeMarkNodeInvalid(msg.arg1);
            break;
        case NOTIFY_FOCUS_SET_MSG_ID:
            if (mNativeClass != 0) {
                nativeNotifyFocusSet(inEditingMode());
            }
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // this is sent after finishing resize in WebViewCore. Make
            // sure the text edit box is still on the  screen.
            boolean alreadyThere = inEditingMode();
            if (alreadyThere && nativeUpdateFocusNode()) {
                FocusNode node = mFocusNode;
                if (node.mIsTextField || node.mIsTextArea) {
                    mTextEntry.bringIntoView();
                }
            }
            updateTextEntry();
            break;
        case RECOMPUTE_FOCUS_MSG_ID:
            if (mNativeClass != 0) {
                nativeRecomputeFocus();
            }
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case UPDATE_TEXT_ENTRY_ADAPTER:
            HashMap data = (HashMap) msg.obj;
            if (mTextEntry.isSameTextField(msg.arg1)) {
                AutoCompleteAdapter adapter = (AutoCompleteAdapter) data.get(""adapter"");
                mTextEntry.setAdapterCustom(adapter);
            }
            break;
        case UPDATE_CLIPBOARD:
            String str = (String) msg.obj;
            if (LOGV_ENABLED) {
                Log.v(LOGTAG, ""UPDATE_CLIPBOARD "" + str);
            }
            try {
                IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
                clip.setClipboardText(str);
            } catch (android.os.RemoteException e) {
                Log.e(LOGTAG, ""Clipboard failed"", e);
            }
            break;
        case RESUME_WEBCORE_UPDATE:
            WebViewCore.resumeUpdate(mWebViewCore);
            break;
        case LONG_PRESS_ENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotEnterDown = false;
            mTrackballDown = false;
            // do nothing.
            if (getParent() != null) {
                performLongClick();
            }
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (msg.arg1 == MotionEvent.ACTION_DOWN) {
                mPreventDrag = msg.arg2 == 1;
                if (mPreventDrag) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
            }
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, msg.what < REMEMBER_PASSWORD || msg.what > INVAL_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // it won't block panning the page.
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = PREVENT_DRAG_NO;
                }
                if (mTouchMode == TOUCH_INIT_MODE) {
                    mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                    updateSelection();
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    rebuildWebTextView();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                if (mPreventDrag == PREVENT_DRAG_NO) {
                    mTouchMode = TOUCH_DONE_MODE;
                    doShortPress();
                }
                break;
            }
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case NEW_PICTURE_MSG_ID:
            {
                WebSettings settings = mWebViewCore.getSettings();
                // called for new content
                final int viewWidth = getViewWidth();
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                final Point viewSize = draw.mViewPoint;
                boolean useWideViewport = settings.getUseWideViewPort();
                WebViewCore.RestoreState restoreState = draw.mRestoreState;
                if (restoreState != null) {
                    mInZoomOverview = false;
                    mLastScale = restoreState.mTextWrapScale;
                    if (restoreState.mMinScale == 0) {
                        if (restoreState.mMobileSite) {
                            if (draw.mMinPrefWidth > Math.max(0, draw.mViewPoint.x)) {
                                mMinZoomScale = (float) viewWidth / draw.mMinPrefWidth;
                                mMinZoomScaleFixed = false;
                            } else {
                                mMinZoomScale = restoreState.mDefaultScale;
                                mMinZoomScaleFixed = true;
                            }
                        } else {
                            mMinZoomScale = DEFAULT_MIN_ZOOM_SCALE;
                            mMinZoomScaleFixed = false;
                        }
                    } else {
                        mMinZoomScale = restoreState.mMinScale;
                        mMinZoomScaleFixed = true;
                    }
                    if (restoreState.mMaxScale == 0) {
                        mMaxZoomScale = DEFAULT_MAX_ZOOM_SCALE;
                    } else {
                        mMaxZoomScale = restoreState.mMaxScale;
                    }
                    setNewZoomScale(mLastScale, false);
                    setContentScrollTo(restoreState.mScrollX, restoreState.mScrollY);
                    if (useWideViewport && settings.getLoadWithOverviewMode()) {
                        if (restoreState.mViewScale == 0 || (restoreState.mMobileSite && mMinZoomScale < restoreState.mDefaultScale)) {
                            mInZoomOverview = true;
                        }
                    }
                    // As we are on a new page, remove the WebTextView. This
                    // is necessary for page loads driven by webkit, and in
                    // particular when the user was on a password field, so
                    // the WebTextView was visible.
                    clearTextEntry();
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0), updateLayout);
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                if (useWideViewport) {
                    mZoomOverviewWidth = Math.max(draw.mMinPrefWidth, draw.mViewPoint.x);
                }
                if (!mMinZoomScaleFixed) {
                    mMinZoomScale = (float) viewWidth / mZoomOverviewWidth;
                }
                if (!mDrawHistory && mInZoomOverview) {
                    // the rounding error case.
                    if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
                        setNewZoomScale((float) viewWidth / mZoomOverviewWidth, false);
                    }
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mWebTextView.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
                WebViewCore.TextSelectionData tData = (WebViewCore.TextSelectionData) msg.obj;
                mWebTextView.setSelectionFromWebKit(tData.mStart, tData.mEnd);
            }
            break;
        case MOVE_OUT_OF_PLUGIN:
            if (nativePluginEatsNavKey()) {
                navHandledKey(msg.arg1, 1, false, 0, true);
            }
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                mWebTextView.bringIntoView();
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case UPDATE_CLIPBOARD:
            String str = (String) msg.obj;
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""UPDATE_CLIPBOARD "" + str);
            }
            try {
                IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService(""clipboard""));
                clip.setClipboardText(str);
            } catch (android.os.RemoteException e) {
                Log.e(LOGTAG, ""Clipboard failed"", e);
            }
            break;
        case RESUME_WEBCORE_UPDATE:
            WebViewCore.resumeUpdate(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            // do nothing.
            if (getParent() != null) {
                performLongClick();
            }
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (msg.arg1 == MotionEvent.ACTION_DOWN) {
                // to time out
                if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
                    mPreventDrag = msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
                    if (mPreventDrag == PREVENT_DRAG_YES) {
                        mTouchMode = TOUCH_DONE_MODE;
                    }
                }
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Numerous statements have changed especially condition and switch-case statements, labels for the cases in the switch-case statement, and the ordering of statements which falls under Control Dependency change (3). There are different operations performed within the switch-case statements, assignments to variables, and methods called, which falls under Other statement changed (4).","The modifications in the API implementation code, with changes in control dependencies and other statements can potentially lead to a different functionality flow of the method, or return different results depending on the type of Message received, which means a Compatibility Issue caused by potential different return values/types (1)."
324,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,4,5,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,0,"{
    if (!mLock.isHeldByCurrentThread()) {
        throw new IllegalStateException(""no transaction pending"");
    }
    try {
        if (mInnerTransactionIsSuccessful) {
            mInnerTransactionIsSuccessful = false;
        } else {
            mTransactionIsSuccessful = false;
        }
        if (mLock.getHoldCount() != 1) {
            return;
        }
        if (mTransactionIsSuccessful) {
            execSQL(""COMMIT;"");
        } else {
            try {
                execSQL(""ROLLBACK;"");
            } catch (SQLException e) {
                if (Config.LOGD) {
                    Log.d(TAG, ""exception during rollback, maybe the DB previously "" + ""performed an auto-rollback"");
                }
            }
        }
    } finally {
        unlockForced();
        if (Config.LOGV) {
            Log.v(TAG, ""unlocked "" + Thread.currentThread() + "", holdCount is "" + mLock.getHoldCount());
        }
    }
}","{
    if (!mLock.isHeldByCurrentThread()) {
        throw new IllegalStateException(""no transaction pending"");
    }
    try {
        if (mInnerTransactionIsSuccessful) {
            mInnerTransactionIsSuccessful = false;
        } else {
            mTransactionIsSuccessful = false;
        }
        if (mLock.getHoldCount() != 1) {
            return;
        }
        RuntimeException savedException = null;
        if (mTransactionListener != null) {
            try {
                if (mTransactionIsSuccessful) {
                    mTransactionListener.onCommit();
                } else {
                    mTransactionListener.onRollback();
                }
            } catch (RuntimeException e) {
                savedException = e;
                mTransactionIsSuccessful = false;
            }
        }
        if (mTransactionIsSuccessful) {
            execSQL(""COMMIT;"");
        } else {
            try {
                execSQL(""ROLLBACK;"");
                if (savedException != null) {
                    throw savedException;
                }
            } catch (SQLException e) {
                if (Config.LOGD) {
                    Log.d(TAG, ""exception during rollback, maybe the DB previously "" + ""performed an auto-rollback"");
                }
            }
        }
    } finally {
        mTransactionListener = null;
        unlockForced();
        if (Config.LOGV) {
            Log.v(TAG, ""unlocked "" + Thread.currentThread() + "", holdCount is "" + mLock.getHoldCount());
        }
    }
}",1,"/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
","/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","In the late implementation, there are new control dependency and other statements introduced such as the creation of 'RuntimeException savedException' and the use of 'mTransactionListener'. Also, the return statement inside the 'if (mLock.getHoldCount() != 1)' block could be affected by these new statements, which accounts for the classification under 'return statement changed'. Therefore, the code change types are 1,3,4.","The newly added statements like the creation of 'RuntimeException savedException' and the use of 'mTransactionListener' could potentially alter the return value of the API and introduce a new exception 'savedException'. Therefore, the CI types are 1,2."
328,<android.database.sqlite.SQLiteDatabase: void beginTransaction()>,4,5,<android.database.sqlite.SQLiteDatabase: void beginTransaction()>,<android.database.sqlite.SQLiteDatabase: void beginTransaction()>,0,"{
    lockForced();
    boolean ok = false;
    try {
        // If this thread already had the lock then get out
        if (mLock.getHoldCount() > 1) {
            if (mInnerTransactionIsSuccessful) {
                String msg = ""Cannot call beginTransaction between "" + ""calling setTransactionSuccessful and endTransaction"";
                IllegalStateException e = new IllegalStateException(msg);
                Log.e(TAG, ""beginTransaction() failed"", e);
                throw e;
            }
            ok = true;
            return;
        }
        // This thread didn't already have the lock, so begin a database
        // transaction now.
        execSQL(""BEGIN EXCLUSIVE;"");
        mTransactionIsSuccessful = true;
        mInnerTransactionIsSuccessful = false;
        ok = true;
    } finally {
        if (!ok) {
            // beginTransaction is called before the try block so we must release the lock in
            // the case of failure.
            unlockForced();
        }
    }
}","{
    beginTransactionWithListener(null);
}",1,"/**
 * Begins a transaction. Transactions can be nested. When the outer transaction is ended all of
 * the work done in that transaction and all of the nested transactions will be committed or
 * rolled back. The changes will be rolled back if any transaction is ended without being
 * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
 *
 * <p>Here is the standard idiom for transactions:
 *
 * <pre>
 * db.beginTransaction();
 * try {
 * ...
 * db.setTransactionSuccessful();
 * } finally {
 * db.endTransaction();
 * }
 * </pre>
 */
","/**
 * Begins a transaction. Transactions can be nested. When the outer transaction is ended all of
 * the work done in that transaction and all of the nested transactions will be committed or
 * rolled back. The changes will be rolled back if any transaction is ended without being
 * marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
 *
 * <p>Here is the standard idiom for transactions:
 *
 * <pre>
 * db.beginTransaction();
 * try {
 * ...
 * db.setTransactionSuccessful();
 * } finally {
 * db.endTransaction();
 * }
 * </pre>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",2,"The entire early version code has been replaced by a single line of code in the late version (beginTransactionWithListener(null);). So the change types are return statement changed, other statement changed, and dependent API changed.","Given the complete replacement of the implementation, it's possible that the new dependent API could throw different exceptions, leading to a type 2 compatibility issue."
330,<android.view.ViewStub: void setVisibility(int)>,4,5,<android.view.ViewStub: void setVisibility(int)>,<android.view.ViewStub: void setVisibility(int)>,0,"{
    super.setVisibility(visibility);
    if (visibility == VISIBLE || visibility == INVISIBLE) {
        inflate();
    }
}","{
    if (mInflatedViewRef != null) {
        View view = mInflatedViewRef.get();
        if (view != null) {
            view.setVisibility(visibility);
        } else {
            throw new IllegalStateException(""setVisibility called on un-referenced view"");
        }
    } else if (visibility == VISIBLE || visibility == INVISIBLE) {
        super.setVisibility(visibility);
        inflate();
    }
}",1,"/**
 * When visibility is set to {@link #VISIBLE} or {@link #INVISIBLE},
 * {@link #inflate()} is invoked and this StubbedView is replaced in its parent
 * by the inflated layout resource.
 *
 * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
 *
 * @see #inflate()
 */
","/**
 * When visibility is set to {@link #VISIBLE} or {@link #INVISIBLE},
 * {@link #inflate()} is invoked and this StubbedView is replaced in its parent
 * by the inflated layout resource.
 *
 * @param visibility One of {@link #VISIBLE}, {@link #INVISIBLE}, or {@link #GONE}.
 *
 * @see #inflate()
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,1,2","1,2","The control statement (if-else) is introduced, the super.setVisibility(visibility) and inflate() statement are mutated, a new exception throwing statement is introduced, and the return point of the method could be different, so the code change type is 3,4,1,2.","Due to the changes in controlling statements and other statements, the method could potentially return at different points (return different value in different situations) and throw a new exception in the later version, therefore the CI type is 1,2."
332,"<android.content.ContentResolver: void startSync(Uri,Bundle)>",4,5,"<android.content.ContentResolver: void startSync(Uri,Bundle)>","<android.content.ContentResolver: void startSync(Uri,Bundle)>",0,"{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().startSync(uri, extras);
    } catch (RemoteException e) {
    }
}","{
    Account account = null;
    if (extras != null) {
        String accountName = extras.getString(SYNC_EXTRAS_ACCOUNT);
        if (!TextUtils.isEmpty(accountName)) {
            account = new Account(accountName, ""com.google"");
        }
        extras.remove(SYNC_EXTRAS_ACCOUNT);
    }
    requestSync(account, uri != null ? uri.getAuthority() : null, extras);
}",1,"/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * </ul>
 *
 * @param uri the uri of the provider to sync or null to sync all providers.
 * @param extras any extras to pass to the SyncAdapter.
 */
","/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * </ul>
 *
 * @param uri the uri of the provider to sync or null to sync all providers.
 * @param extras any extras to pass to the SyncAdapter.
 * @deprecated instead use
 * {@link #requestSync(android.accounts.Account, String, android.os.Bundle)}
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The code has undergone significant changes from the early version to the late version. Initially, it was simply running the startSync() method on the getContentService() object inside a try-catch block. However, in the latest version, several statements have been added, including some new variable declarations and the invocation of a different method: requestSync(). This change affects the return statement, the control dependency (as an ""if"" statement has been introduced), and other statements, thus the code change type is 1,3,4.","In the early version, even if something went wrong with the startSync() method, the exception would not propagate due to the empty catch block. However, in the late version, there is no exception handling for the new instructions, so any potential exception can be unhandled and thrown. Moreover, the new variable declaration and requestSync() method can potentially lead to a different behaviour of the API, considering the return types and the values. So, CI could be caused by potentially different return values or types and potentially different exception handlings, which are of type 1 and 2."
333,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",4,5,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    Drawable dr = getCachedDrawable(key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = mPreloadedDrawables.get(key);
    if (cs != null) {
        dr = cs.newDrawable();
    } else {
        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                sPreloadedDrawables.put(key, cs);
            } else {
                synchronized (mTmpValue) {
                    // Log.i(TAG, ""Saving cached drawable @ #"" +
                    // Integer.toHexString(key.intValue())
                    // + "" in "" + this + "": "" + cs);
                    mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                }
            }
        }
    }
    return dr;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    Drawable dr = getCachedDrawable(key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = sPreloadedDrawables.get(key);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                sPreloadedDrawables.put(key, cs);
            } else {
                synchronized (mTmpValue) {
                    // Log.i(TAG, ""Saving cached drawable @ #"" +
                    // Integer.toHexString(key.intValue())
                    // + "" in "" + this + "": "" + cs);
                    mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                }
            }
        }
    }
    return dr;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The method called 'mPreloadedDrawables.get(key)' changed to 'sPreloadedDrawables.get(key)' and the method called 'mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_BUFFER);' changed to 'mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);'. Since the changed calls are dependent APIs and they are used in return statements, the change types are 1 and 5.","The change of the method being invoked in the return statement as well as the parameters of another method could potentially cause the API to return a different value or type and can also throw a different exception, hence the CI types are 1 and 2."
334,<android.webkit.WebSyncManager: void startSync()>,4,5,<android.webkit.WebSyncManager: void startSync()>,<android.webkit.WebSyncManager: void startSync()>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""***  WebSyncManager startSync ***, Ref count:"" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (++mStartSyncRefCount == 1) {
        Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
        mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
    }
}","{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, ""***  WebSyncManager startSync ***, Ref count:"" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (++mStartSyncRefCount == 1) {
        Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
        mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
    }
}",1,"/**
 * startSync() requests sync manager to start sync
 */
","/**
 * startSync() requests sync manager to start sync
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The altered code is a conditional control statement that is log-related (from `WebView.LOGV_ENABLED` to `DebugFlags.WEB_SYNC_MANAGER`). This falls under the category 'Other statement change'.,"The change is only about logs, which will not affect the return value or introduce a different exception handling. Therefore, there's no Compatibility Issue here."
335,<android.webkit.ContentLoader: boolean setupStreamAndSendStatus()>,4,5,<android.webkit.ContentLoader: boolean setupStreamAndSendStatus()>,<android.webkit.ContentLoader: boolean setupStreamAndSendStatus()>,0,"{
    Uri uri = Uri.parse(mUrl);
    if (uri == null) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, mContext.getString(com.android.internal.R.string.httpErrorBadUrl) + "" "" + mUrl);
        return false;
    }
    try {
        mDataStream = mContext.getContentResolver().openInputStream(uri);
        mHandler.status(1, 1, 0, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, mContext.getString(com.android.internal.R.string.httpErrorFileNotFound) + "" "" + ex.getMessage());
        return false;
    } catch (java.io.IOException ex) {
        mHandler.error(EventHandler.FILE_ERROR, mContext.getString(com.android.internal.R.string.httpErrorFileNotFound) + "" "" + ex.getMessage());
        return false;
    } catch (RuntimeException ex) {
        // readExceptionWithFileNotFoundExceptionFromParcel in DatabaseUtils
        // can throw a serial of RuntimeException. Catch them all here.
        mHandler.error(EventHandler.FILE_ERROR, mContext.getString(com.android.internal.R.string.httpErrorFileNotFound) + "" "" + ex.getMessage());
        return false;
    }
    return true;
}","{
    Uri uri = Uri.parse(mUrl);
    if (uri == null) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, mContext.getString(com.android.internal.R.string.httpErrorBadUrl) + "" "" + mUrl);
        return false;
    }
    try {
        mDataStream = mContext.getContentResolver().openInputStream(uri);
        mHandler.status(1, 1, 0, ""OK"");
    } catch (java.io.FileNotFoundException ex) {
        mHandler.error(EventHandler.FILE_NOT_FOUND_ERROR, errString(ex));
        return false;
    } catch (java.io.IOException ex) {
        mHandler.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    } catch (RuntimeException ex) {
        // readExceptionWithFileNotFoundExceptionFromParcel in DatabaseUtils
        // can throw a serial of RuntimeException. Catch them all here.
        mHandler.error(EventHandler.FILE_ERROR, errString(ex));
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The handler error string in the catch blocks has changed from concatenation with ex.getMessage() to a call to the errString(ex) method, hence the type of code change is 4 (Other statement changed).","This change does not affect the return values or the exceptions thrown by the method; the error message that will be displayed is changed, but it will not impact the behaviour of the method. Hence, no compatibility issue is detected (type 0)."
336,<android.webkit.WebView: void loadUrl(String)>,4,5,<android.webkit.WebView: void loadUrl(String)>,<android.webkit.WebView: void loadUrl(String)>,0,"{
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.LOAD_URL, url);
    clearTextEntry();
}","{
    if (url == null) {
        return;
    }
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.LOAD_URL, url);
    clearTextEntry();
}",1,"/**
 * Load the given url.
 * @param url The url of the resource to load.
 */
","/**
 * Load the given url.
 * @param url The url of the resource to load.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new condition statement ""if (url == null) {return;}"" is introduced in the late version. So, the control dependency is changed.","Despite the change in control dependency, if the input (here - the url) is null, both the early and late versions will essentially do nothing. Therefore, the behaviors are same and there is no Compatibility Issue."
338,<android.webkit.WebView: boolean zoomIn()>,4,5,<android.webkit.WebView: boolean zoomIn()>,<android.webkit.WebView: boolean zoomIn()>,0,"{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    return zoomWithPreview(mActualScale * 1.25f);
}","{
    // TODO: alternatively we can disallow this during draw history mode
    switchOutDrawHistory();
    // Center zooming to the center of the screen.
    if (mInZoomOverview) {
        // if in overview mode, bring it back to normal mode
        mLastTouchX = getViewWidth() * .5f;
        mLastTouchY = getViewHeight() * .5f;
        doDoubleTap();
        return true;
    } else {
        mZoomCenterX = getViewWidth() * .5f;
        mZoomCenterY = getViewHeight() * .5f;
        return zoomWithPreview(mActualScale * 1.25f);
    }
}",1,"/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, a new if...else control structure and a return statement ""return true"" have been introduced, which brings both change in the control dependency and the return statement. So the code change type is 1,3.","The added branch of control structure and return statement bring a potential different return value when the mInZoomOverview is true, thus the CI type is 1."
339,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",4,5,"<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>","<android.widget.ExpandableListView: ContextMenuInfo createContextMenuInfo(View,int,long)>",0,"{
    PositionMetadata pm = mConnector.getUnflattenedPos(flatListPosition);
    ExpandableListPosition pos = pm.position;
    pm.recycle();
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pos.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}","{
    // Adjust for and handle for header views
    final int adjustedPosition = flatListPosition - getHeaderViewsCount();
    if (adjustedPosition < 0) {
        // Return normal info for header view context menus
        return new AdapterContextMenuInfo(view, flatListPosition, id);
    }
    PositionMetadata pm = mConnector.getUnflattenedPos(adjustedPosition);
    ExpandableListPosition pos = pm.position;
    pm.recycle();
    id = getChildOrGroupId(pos);
    long packedPosition = pos.getPackedPosition();
    pos.recycle();
    return new ExpandableListContextMenuInfo(view, packedPosition, id);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The Late Version introduces additional operations, including a new return statement (return new AdapterContextMenuInfo(view, flatListPosition, id);), an adjustment computation, and an additional condition check. Thus, the change type includes Return statement change (1), Control dependency change (3), and Other statement change (4).","Due to the change in the return statement (the new return AdapterContextMenuInfo), the API potentially returns a different type of object in the later version when the adjustedPosition < 0. Therefore, the CI type falls into category 1 (Compatibility Issue caused by potential different return values or types)."
343,<android.content.ContentResolver: void validateSyncExtrasBundle(Bundle)>,4,5,<android.content.ContentResolver: void validateSyncExtrasBundle(Bundle)>,<android.content.ContentResolver: void validateSyncExtrasBundle(Bundle)>,0,"{
    try {
        for (String key : extras.keySet()) {
            Object value = extras.get(key);
            if (value == null)
                continue;
            if (value instanceof Long)
                continue;
            if (value instanceof Integer)
                continue;
            if (value instanceof Boolean)
                continue;
            if (value instanceof Float)
                continue;
            if (value instanceof Double)
                continue;
            if (value instanceof String)
                continue;
            throw new IllegalArgumentException(""unexpected value type: "" + value.getClass().getName());
        }
    } catch (IllegalArgumentException e) {
        throw e;
    } catch (RuntimeException exc) {
        throw new IllegalArgumentException(""error unparceling Bundle"", exc);
    }
}","{
    try {
        for (String key : extras.keySet()) {
            Object value = extras.get(key);
            if (value == null)
                continue;
            if (value instanceof Long)
                continue;
            if (value instanceof Integer)
                continue;
            if (value instanceof Boolean)
                continue;
            if (value instanceof Float)
                continue;
            if (value instanceof Double)
                continue;
            if (value instanceof String)
                continue;
            if (value instanceof Account)
                continue;
            throw new IllegalArgumentException(""unexpected value type: "" + value.getClass().getName());
        }
    } catch (IllegalArgumentException e) {
        throw e;
    } catch (RuntimeException exc) {
        throw new IllegalArgumentException(""error unparceling Bundle"", exc);
    }
}",1,"/**
 * Check that only values of the following types are in the Bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>null</li>
 * </ul>
 * @param extras the Bundle to check
 */
","/**
 * Check that only values of the following types are in the Bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>Account</li>
 * <li>null</li>
 * </ul>
 * @param extras the Bundle to check
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An extra checking condition statement 'if (value instanceof Account) continue;' has been added in the loop, so the code change type is 4.","This code change will not cause an compatibility issue as it only adds another accepted class type which is checked within the API method. Therefore, the CI type is 0."
344,<android.view.inputmethod.InputMethodInfo: String toString()>,4,5,<android.view.inputmethod.InputMethodInfo: String toString()>,<android.view.inputmethod.InputMethodInfo: String toString()>,0,"{
    return ""InputMethodMetaInfo{"" + mId + "", settings: "" + mSettingsActivityName + ""}"";
}","{
    return ""InputMethodInfo{"" + mId + "", settings: "" + mSettingsActivityName + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The string literal in return statement has changed from ""InputMethodMetaInfo{"" to ""InputMethodInfo{"", so the code change type is 1.","This string change in the return statement will potentially cause the late version API to return a different string value. Thus, the CI type is 1."
345,"<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>",4,5,"<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>","<android.provider.Settings.NameValueCache: String getString(ContentResolver,String)>",0,"{
    long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
    if (mValuesVersion != newValuesVersion) {
        mValues.clear();
        mValuesVersion = newValuesVersion;
    }
    if (!mValues.containsKey(name)) {
        String value = null;
        Cursor c = null;
        try {
            c = cr.query(mUri, new String[] { Settings.NameValueTable.VALUE }, Settings.NameValueTable.NAME + ""=?"", new String[] { name }, null);
            if (c != null && c.moveToNext())
                value = c.getString(0);
            mValues.put(name, value);
        } catch (SQLException e) {
            // SQL error: return null, but don't cache it.
            Log.e(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        } finally {
            if (c != null)
                c.close();
        }
        return value;
    } else {
        return mValues.get(name);
    }
}","{
    long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
    if (mValuesVersion != newValuesVersion) {
        mValues.clear();
        mValuesVersion = newValuesVersion;
    }
    if (!mValues.containsKey(name)) {
        String value = null;
        Cursor c = null;
        try {
            c = cr.query(mUri, new String[] { Settings.NameValueTable.VALUE }, Settings.NameValueTable.NAME + ""=?"", new String[] { name }, null);
            if (c != null && c.moveToNext())
                value = c.getString(0);
            mValues.put(name, value);
        } catch (SQLException e) {
            // SQL error: return null, but don't cache it.
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        } finally {
            if (c != null)
                c.close();
        }
        return value;
    } else {
        return mValues.get(name);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the exception handling block, the severity of the log message has changed from an error (Log.e) to a warning (Log.w). Therefore, the code change type is 4. ","Although there is a change in the log severity, this doesn't alter the behavior of the API in any significant way. They neither change the value returned by the API method nor change the exception that this method might throw, hence no compatibility issue (CI type 0) exists."
347,<android.hardware.Camera.Parameters: Size getPreviewSize()>,4,5,<android.hardware.Camera.Parameters: Size getPreviewSize()>,<android.hardware.Camera.Parameters: Size getPreviewSize()>,0,"{
    String pair = get(""preview-size"");
    if (pair == null)
        return null;
    String[] dims = pair.split(""x"");
    if (dims.length != 2)
        return null;
    return new Size(Integer.parseInt(dims[0]), Integer.parseInt(dims[1]));
}","{
    String pair = get(KEY_PREVIEW_SIZE);
    return strToSize(pair);
}",1,"/**
 * Returns the dimensions setting for preview pictures.
 *
 * @return a Size object with the height and width setting
 * for the preview picture
 */
","/**
 * Returns the dimensions setting for preview pictures.
 *
 * @return a Size object with the height and width setting
 * for the preview picture
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The code changes are in the return statements and the dependent API. The 'return null' statements have been removed in the late version, and the method called in return statement has changed. Plus, the method 'get' now has a different string parameter, so the code change type is 1,4,5.","The return statement has been changed to meet different conditions, which means potentially different values may be returned, hence, the CI type is 1."
348,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,4,5,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,<android.webkit.LoadListener: boolean handleSslErrorRequest(SslError)>,0,"{
    if (WebView.LOGV_ENABLED) {
        Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate());
    }
    sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error));
    // to unblock the network thread.
    if (!mCancelled) {
        mSslErrorRequestHandle = mRequestHandle;
    }
    return !mCancelled;
}","{
    if (DebugFlags.LOAD_LISTENER) {
        Log.v(LOGTAG, ""LoadListener.handleSslErrorRequest(): url:"" + url() + "" primary error: "" + error.getPrimaryError() + "" certificate: "" + error.getCertificate());
    }
    // will prevent waiting for an already available answer.
    if (Network.getInstance(mContext).checkSslPrefTable(this, error)) {
        return true;
    }
    // deadlock. Just bail on the request.
    if (isSynchronous()) {
        mRequestHandle.handleSslErrorResponse(false);
        return true;
    }
    sendMessageInternal(obtainMessage(MSG_SSL_ERROR, error));
    // to unblock the network thread.
    if (!mCancelled) {
        mSslErrorRequestHandle = mRequestHandle;
    }
    return !mCancelled;
}",1,"/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
","/**
 * SSL certificate error callback. Handles SSL error(s) on the way up
 * to the user.
 * IMPORTANT: as this is called from network thread, can't call native
 * directly
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Here, some new conditions statements are introduced and thus additional return statements as well, hence the code change types are 3,4.","The added if conditions in the later version can potentially lead to returning a fixed true value irrespective of `mCancelled`'s state unlike in the previous version. Therefore, the predicate `return !mCancelled` behaviour can potentially change. Hence, the CI type is 1."
349,<android.view.View: boolean dispatchKeyEvent(KeyEvent)>,4,5,<android.view.View: boolean dispatchKeyEvent(KeyEvent)>,<android.view.View: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    if (android.util.Config.LOGV) {
        captureViewInfo(""captureViewKeyEvent"", this);
    }
    if (mOnKeyListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
        return true;
    }
    return event.dispatch(this);
}","{
    if (android.util.Config.LOGV) {
        captureViewInfo(""captureViewKeyEvent"", this);
    }
    if (mOnKeyListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
        return true;
    }
    return event.dispatch(this, mAttachInfo != null ? mAttachInfo.mKeyDispatchState : null, this);
}",1,"/**
 * Dispatch a key event to the next view on the focus path. This path runs
 * from the top of the view tree down to the currently focused view. If this
 * view has focus, it will dispatch to itself. Otherwise it will dispatch
 * the next node down the focus path. This method also fires any key
 * listeners.
 *
 * @param event The key event to be dispatched.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Dispatch a key event to the next view on the focus path. This path runs
 * from the top of the view tree down to the currently focused view. If this
 * view has focus, it will dispatch to itself. Otherwise it will dispatch
 * the next node down the focus path. This method also fires any key
 * listeners.
 *
 * @param event The key event to be dispatched.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed - specifically the parameters to the dispatch method of the event instance, which adds an additional parameter mAttachInfo.mKeyDispatchState - so the code change types are 1, 5.","Because of this change, the dispatch method may return a different value due to additional parameter passed in the late version implementation. So, this is a Compatibility issue type 1."
