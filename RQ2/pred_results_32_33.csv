Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_Change_Type,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,<android.os.PowerComponents.Builder: PowerComponents build()>,32,33,,,,"{
    return new PowerComponents(this);
}","{
    mData.putDouble(mData.layout.totalConsumedPowerColumnIndex, getTotalPower());
    for (BatteryConsumer.Key[] keys : mData.layout.keys) {
        for (BatteryConsumer.Key key : keys) {
            if (key.mPowerModelColumnIndex != -1) {
                if (mData.getInt(key.mPowerModelColumnIndex) == POWER_MODEL_UNINITIALIZED) {
                    mData.putInt(key.mPowerModelColumnIndex, BatteryConsumer.POWER_MODEL_UNDEFINED);
                }
            }
        }
    }
    return new PowerComponents(this);
}",1,"/**
 * Creates a read-only object out of the Builder values.
 */
","/**
 * Creates a read-only object out of the Builder values.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,4",0,"There are additional operations on 'mData' before returning the new 'PowerComponents' object in the late version, which includes accessing and modifying the data within 'mData', so the code change type is 1,4.","Although there are modifications to 'mData', they do not affect the return type or value because the return statement remains the same creating a 'new PowerComponents(this)'. This does not constitute a Compatibility Issue with respect to the returned value or thrown exception; hence, the result is 0 for no Compatibility Issue."
2,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void hideSoftInput(int,ResultReceiver)>",32,33,,,,"{
    if (DEBUG)
        Log.v(TAG, ""hideSoftInput()"");
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingHideSoftInput) {
        Log.e(TAG, ""IME shouldn't call hideSoftInput on itself."" + "" Use requestHideSelf(int) itself"");
        return;
    }
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#hideSoftInput"", InputMethodService.this, null);
    final boolean wasVisible = isInputViewShown();
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.hideSoftInput"");
    applyVisibilityInInsetsConsumerIfNecessary(false);
    mShowInputFlags = 0;
    mShowInputRequested = false;
    doHideWindow();
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_HIDDEN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}","{
    if (DEBUG)
        Log.v(TAG, ""hideSoftInput()"");
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingHideSoftInput) {
        Log.e(TAG, ""IME shouldn't call hideSoftInput on itself."" + "" Use requestHideSelf(int) itself"");
        return;
    }
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#hideSoftInput"", mDumper, null);
    final boolean wasVisible = isInputViewShown();
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.hideSoftInput"");
    mShowInputFlags = 0;
    mShowInputRequested = false;
    hideWindow();
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_HIDDEN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,"[@MainThread, @Override]","[@MainThread, @Override]",0,,,,,,,"4,5",0,"The change is from calling doHideWindow() to hideWindow() and also the parameter passed to triggerServiceDump(...) has changed from InputMethodService.this to mDumper. Hence, the code change types are 4,5.","The different method call (doHideWindow vs. hideWindow) does not indicate a different behavior because the method name alone does not provide enough context to claim a behavioral change. Additionally, the change in parameters of triggerServiceDump(...) does not automatically result in a different behavior since it's a logging/tracing function. Based on the information provided, we cannot assume a Compatibility Issue without further context on the behavior of hideWindow() and whether it differs from doHideWindow(). Therefore, there is no detected Compatibility Issue."
3,<android.view.contentcapture.ContentCaptureSession: void notifyViewDisappeared(AutofillId)>,32,33,,,,"{
    Preconditions.checkNotNull(id);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewDisappeared(id);
}","{
    Objects.requireNonNull(id);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewDisappeared(id);
}",1,"/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
","/**
 * Notifies the Content Capture Service that a node has been removed from the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for standard views.
 *
 * @param id id of the node that has been removed.
 */
",0,,,0,,,,,,,4,0,"The change is from using Preconditions.checkNotNull(id) to Objects.requireNonNull(id), which serves the same purpose of checking for a non-null object. So, the code change type is 4.","There is no Compatibility Issue because Objects.requireNonNull(id) serves the exact same purpose as Preconditions.checkNotNull(id); it throws a NullPointerException if the passed object is null. Thus, the functionality of the API remains unchanged, and the behavior would be the same when this method is invoked."
4,"<android.os.BinderProxy.ProxyMap: void set(long,BinderProxy)>",32,33,,,,"{
    int myHash = hash(key);
    ArrayList<WeakReference<BinderProxy>> valueArray = mMainIndexValues[myHash];
    if (valueArray == null) {
        valueArray = mMainIndexValues[myHash] = new ArrayList<>();
        mMainIndexKeys[myHash] = new Long[1];
    }
    int size = valueArray.size();
    WeakReference<BinderProxy> newWr = new WeakReference<>(value);
    // that bucket.
    for (int i = 0; i < size; ++i) {
        if (valueArray.get(i).get() == null) {
            valueArray.set(i, newWr);
            Long[] keyArray = mMainIndexKeys[myHash];
            keyArray[i] = key;
            if (i < size - 1) {
                // ""Randomly"" check one of the remaining entries in [i+1, size), so that
                // needlessly long buckets are eventually pruned.
                int rnd = Math.floorMod(++mRandom, size - (i + 1));
                if (valueArray.get(i + 1 + rnd).get() == null) {
                    remove(myHash, i + 1 + rnd);
                }
            }
            return;
        }
    }
    valueArray.add(size, newWr);
    Long[] keyArray = mMainIndexKeys[myHash];
    if (keyArray.length == size) {
        // size >= 1, since we initially allocated one element
        Long[] newArray = new Long[size + size / 2 + 2];
        System.arraycopy(keyArray, 0, newArray, 0, size);
        newArray[size] = key;
        mMainIndexKeys[myHash] = newArray;
    } else {
        keyArray[size] = key;
    }
    if (size >= mWarnBucketSize) {
        final int totalSize = size();
        Log.v(Binder.TAG, ""BinderProxy map growth! bucket size = "" + size + "" total = "" + totalSize);
        mWarnBucketSize += WARN_INCREMENT;
        if (Build.IS_DEBUGGABLE && totalSize >= CRASH_AT_SIZE) {
            // Use the number of uncleared entries to determine whether we should
            // really report a histogram and crash. We don't want to fundamentally
            // change behavior for a debuggable process, so we GC only if we are
            // about to crash.
            final int totalUnclearedSize = unclearedSize();
            if (totalUnclearedSize >= CRASH_AT_SIZE) {
                dumpProxyInterfaceCounts();
                dumpPerUidProxyCounts();
                Runtime.getRuntime().gc();
                throw new AssertionError(""Binder ProxyMap has too many entries: "" + totalSize + "" (total), "" + totalUnclearedSize + "" (uncleared), "" + unclearedSize() + "" (uncleared after GC). BinderProxy leak?"");
            } else if (totalSize > 3 * totalUnclearedSize / 2) {
                Log.v(Binder.TAG, ""BinderProxy map has many cleared entries: "" + (totalSize - totalUnclearedSize) + "" of "" + totalSize + "" are cleared"");
            }
        }
    }
}","{
    int myHash = hash(key);
    ArrayList<WeakReference<BinderProxy>> valueArray = mMainIndexValues[myHash];
    if (valueArray == null) {
        valueArray = mMainIndexValues[myHash] = new ArrayList<>();
        mMainIndexKeys[myHash] = new Long[1];
    }
    int size = valueArray.size();
    WeakReference<BinderProxy> newWr = new WeakReference<>(value);
    // that bucket.
    for (int i = 0; i < size; ++i) {
        if (valueArray.get(i).refersTo(null)) {
            valueArray.set(i, newWr);
            Long[] keyArray = mMainIndexKeys[myHash];
            keyArray[i] = key;
            if (i < size - 1) {
                // ""Randomly"" check one of the remaining entries in [i+1, size), so that
                // needlessly long buckets are eventually pruned.
                int rnd = Math.floorMod(++mRandom, size - (i + 1));
                if (valueArray.get(i + 1 + rnd).refersTo(null)) {
                    remove(myHash, i + 1 + rnd);
                }
            }
            return;
        }
    }
    valueArray.add(size, newWr);
    Long[] keyArray = mMainIndexKeys[myHash];
    if (keyArray.length == size) {
        // size >= 1, since we initially allocated one element
        Long[] newArray = new Long[size + size / 2 + 2];
        System.arraycopy(keyArray, 0, newArray, 0, size);
        newArray[size] = key;
        mMainIndexKeys[myHash] = newArray;
    } else {
        keyArray[size] = key;
    }
    if (size >= mWarnBucketSize) {
        final int totalSize = size();
        Log.v(Binder.TAG, ""BinderProxy map growth! bucket size = "" + size + "" total = "" + totalSize);
        mWarnBucketSize += WARN_INCREMENT;
        if (Build.IS_DEBUGGABLE && totalSize >= CRASH_AT_SIZE) {
            // Use the number of uncleared entries to determine whether we should
            // really report a histogram and crash. We don't want to fundamentally
            // change behavior for a debuggable process, so we GC only if we are
            // about to crash.
            final int totalUnclearedSize = unclearedSize();
            if (totalUnclearedSize >= CRASH_AT_SIZE) {
                dumpProxyInterfaceCounts();
                dumpPerUidProxyCounts();
                Runtime.getRuntime().gc();
                throw new BinderProxyMapSizeException(""Binder ProxyMap has too many entries: "" + totalSize + "" (total), "" + totalUnclearedSize + "" (uncleared), "" + unclearedSize() + "" (uncleared after GC). BinderProxy leak?"");
            } else if (totalSize > 3 * totalUnclearedSize / 2) {
                Log.v(Binder.TAG, ""BinderProxy map has many cleared entries: "" + (totalSize - totalUnclearedSize) + "" of "" + totalSize + "" are cleared"");
            }
        }
    }
}",1,"/**
 * Add the key-value pair to the map.
 * Requires that the indicated key is not already in the map.
 */
","/**
 * Add the key-value pair to the map.
 * Requires that the indicated key is not already in the map.
 */
",0,,,0,,,,,,,,,,
5,<android.view.Display: DisplayCutout getCutout()>,32,33,,,,"{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getDisplayCutout(mDisplayInfo.displayCutout) : mDisplayInfo.displayCutout;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (mResources == null)
            return mDisplayInfo.displayCutout;
        final DisplayCutout localCutout = mDisplayInfo.displayCutout;
        if (localCutout == null)
            return null;
        int rotation = getLocalRotation();
        if (rotation != mDisplayInfo.rotation) {
            return localCutout.getRotated(mDisplayInfo.logicalWidth, mDisplayInfo.logicalHeight, mDisplayInfo.rotation, rotation);
        }
        return localCutout;
    }
}",1,"/**
 * Returns the {@link DisplayCutout}, or {@code null} if there is none.
 *
 * @see DisplayCutout
 */
","/**
 * Returns the {@link DisplayCutout}, or {@code null} if there is none.
 *
 * @see DisplayCutout
 */
",0,[@Nullable],[@Nullable],0,,,,,,,"1,3",1,"The late version introduces new control statements like additional checks and variable assignments, which modify the conditions under which certain values are returned. So, the code change includes both a return statement change and a control dependency change, type 1,3.","Given the added conditions in the late version, there can be situations where the early version returns a different display cutout instance or null compared to the late version, and vice versa. Thus, the changes can lead to different return values or types, qualifying as a compatibility issue of type 1."
6,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern,RemoteViews)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null, new DatasetFieldFilter(filter));
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null, null, new DatasetFieldFilter(filter), null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"4,5",0,"The method setLifeTheUniverseAndEverything() call got an extra null argument, indicating the dependent API changed (5). Besides, the checking of a null condition for 'presentation' was shifted from using Preconditions.checkNotNull() to Objects.requireNonNull(), resulting in an other statement changed (4).","Even though there are changes to the method call and the null check, neither of these changes leads to a different return value or exception behavior. The Objects.requireNonNull() method serves the same purpose as Preconditions.checkNotNull() and will throw a NullPointerException if 'presentation' is null, and the addition of null arguments in the method call does not change the outward behavior of this method. Therefore, there is no Compatibility Issue; the method contract is unchanged."
7,<android.companion.CompanionDeviceManager: List<String> getAssociations()>,32,33,,,,"{
    if (!checkFeaturePresent()) {
        return Collections.emptyList();
    }
    try {
        return mService.getAssociations(getCallingPackage(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return CollectionUtils.mapNotNull(getMyAssociations(), a -> a.isSelfManaged() ? null : a.getDeviceMacAddressAsString());
}",1,"/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app. You can use these with {@link #disassociate}
 */
","/**
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @return a list of MAC addresses of devices that have been previously associated with the
 * current app are managed by CompanionDeviceManager (ie. does not include devices managed by
 * application itself even if they have a MAC address).
 *
 * @deprecated use {@link #getMyAssociations()}
 */
",1,[@NonNull],"[@Deprecated, @UserHandleAware, @NonNull]",1,,,,,,,"1,4,5",1,"The early implementation checks for a feature presence, invokes a service, and catches a RemoteException. The late implementation is drastically different; it uses a method `getMyAssociations()` and a lambda expression to filter and transform the list. The dependency on the service call has been removed and replaced with a direct transformation of a presumably cached/pre-fetched list. This constitutes a change in the return statement, other statements, and a dependent API change, leading to the code change types 1, 4, 5.","The change in logic, removal of service interaction, and direct transformation using `CollectionUtils.mapNotNull` can lead both to different values being returned and a change in exceptions possibly thrown (since the RemoteException catch has been removed), so there is a Compatibility Issue of type 1."
8,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,"[@Override, @Deprecated]","[@Override, @Deprecated]",0,,,,,,,"4,5",0,"The arguments passed to the method broadcastIntentWithFeature have changed order and potentially content, as the position that previously had AppOpsManager.OP_NONE now has null, and vice versa. This is therefore classified as an 'Other statement changed' and 'Dependent API changed', so the code change types are 4 and 5.","Despite the argument changes in the internal call to ActivityManager.getService().broadcastIntentWithFeature, these changes won't affect the behavior of sendStickyBroadcast from the perspective of the caller since it does not change the method's signature or its expected behavior as intended by the developer. The method still catches RemoteException and rethrows it using rethrowFromSystemServer. No other exceptions are thrown, and no return value is affected (the method is void). Therefore, there is no Compatibility Issue, hence CI type is 0."
9,"<android.view.autofill.AutofillManager: void notifyValueChanged(View,int,AutofillValue)>",32,33,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + "":"" + virtualId + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    synchronized (mLock) {
        if (!mEnabled || !isActiveLocked()) {
            if (sVerbose) {
                Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + "":"" + virtualId + ""): ignoring on state "" + getStateAsStringLocked());
            }
            return;
        }
        final AutofillId id = getAutofillId(view, virtualId);
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, getImeStateFlag(view));
    }
}",1,"/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
","/**
 * Called to indicate the value of an autofillable virtual view has changed.
 *
 * @param view the virtual view parent.
 * @param virtualId id identifying the virtual child inside the parent view.
 * @param value new value of the child.
 */
",0,,,0,,,,,,,4,0,"The only change is the last parameter in the updateSessionLocked() method call, from a hardcoded 0 to a method call getImeStateFlag(view), which does not affect the return type or the exceptions thrown, so the code change type is 4.","There is no Compatibility Issue as the signature, return type, and exception handling of the method have not changed; only an internal parameter value has changed, which doesnâ€™t affect how the method is called or how it behaves from the perspective of an API user."
10,<android.view.inputmethod.InputMethodManager.DelegateImpl: boolean hasActiveConnection(View)>,32,33,,,,"{
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentInputMethodSession == null) {
            return false;
        }
        return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.isActive() && mServedInputConnectionWrapper.getServedView() == view;
    }
}","{
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentInputMethodSession == null) {
            return false;
        }
        return mServedInputConnection != null && mServedInputConnection.isActive() && mServedInputConnection.getServedView() == view;
    }
}",1,"/**
 * Checks whether the active input connection (if any) is for the given view.
 *
 * TODO(b/182259171): Clean-up hasActiveConnection to simplify the logic.
 *
 * Note that this method is only intended for restarting input after focus gain
 * (e.g. b/160391516), DO NOT leverage this method to do another check.
 */
","/**
 * Checks whether the active input connection (if any) is for the given view.
 *
 * TODO(b/182259171): Clean-up hasActiveConnection to simplify the logic.
 *
 * Note that this method is only intended for restarting input after focus gain
 * (e.g. b/160391516), DO NOT leverage this method to do another check.
 */
",0,[@Override],[@Override],0,,,,,,,"4,5",1,"The API implementation has changed where mServedInputConnectionWrapper has been replaced with mServedInputConnection. The variable name change indicates that it's dependent on a different field or a different class that has a similar interface (isActive(), getServedView()). Since no control structures or return types have changed, the code change type is 4,5.","As the implementation changes the field from mServedInputConnectionWrapper to mServedInputConnection, it suggests a change in the object that is being interacted with. This could potentially lead to the API returning different boolean values as the state and behavior of mServedInputConnection could differ from mServedInputConnectionWrapper, thus the CI type is 1."
12,"<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void startSync(ISyncContext,String,Account,Bundle)>",32,33,,,,"{
    if (ENABLE_LOG) {
        if (extras != null) {
            // Unparcel so its toString() will show the contents.
            extras.size();
        }
        Log.d(TAG, ""startSync() start "" + authority + "" "" + account + "" "" + extras);
    }
    try {
        final SyncContext syncContextClient = new SyncContext(syncContext);
        boolean alreadyInProgress;
        // synchronize to make sure that mSyncThreads doesn't change between when we
        // check it and when we use it
        final Account threadsKey = toSyncKey(account);
        synchronized (mSyncThreadLock) {
            if (!mSyncThreads.containsKey(threadsKey)) {
                if (mAutoInitialize && extras != null && extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE, false)) {
                    try {
                        if (ContentResolver.getIsSyncable(account, authority) < 0) {
                            ContentResolver.setIsSyncable(account, authority, 1);
                        }
                    } finally {
                        syncContextClient.onFinished(new SyncResult());
                    }
                    return;
                }
                SyncThread syncThread = new SyncThread(""SyncAdapterThread-"" + mNumSyncStarts.incrementAndGet(), syncContextClient, authority, account, extras);
                mSyncThreads.put(threadsKey, syncThread);
                syncThread.start();
                alreadyInProgress = false;
            } else {
                if (ENABLE_LOG) {
                    Log.d(TAG, ""  alreadyInProgress"");
                }
                alreadyInProgress = true;
            }
        }
        // holding the synchronization lock
        if (alreadyInProgress) {
            syncContextClient.onFinished(SyncResult.ALREADY_IN_PROGRESS);
        }
    } catch (RuntimeException | Error th) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""startSync() caught exception"", th);
        }
        throw th;
    } finally {
        if (ENABLE_LOG) {
            Log.d(TAG, ""startSync() finishing"");
        }
    }
}","{
    if (!isCallerSystem()) {
        return;
    }
    if (ENABLE_LOG) {
        if (extras != null) {
            // Unparcel so its toString() will show the contents.
            extras.size();
        }
        Log.d(TAG, ""startSync() start "" + authority + "" "" + account + "" "" + extras);
    }
    try {
        final SyncContext syncContextClient = new SyncContext(syncContext);
        boolean alreadyInProgress;
        // synchronize to make sure that mSyncThreads doesn't change between when we
        // check it and when we use it
        final Account threadsKey = toSyncKey(account);
        synchronized (mSyncThreadLock) {
            if (!mSyncThreads.containsKey(threadsKey)) {
                if (mAutoInitialize && extras != null && extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE, false)) {
                    try {
                        if (ContentResolver.getIsSyncable(account, authority) < 0) {
                            ContentResolver.setIsSyncable(account, authority, 1);
                        }
                    } finally {
                        syncContextClient.onFinished(new SyncResult());
                    }
                    return;
                }
                SyncThread syncThread = new SyncThread(""SyncAdapterThread-"" + mNumSyncStarts.incrementAndGet(), syncContextClient, authority, account, extras);
                mSyncThreads.put(threadsKey, syncThread);
                syncThread.start();
                alreadyInProgress = false;
            } else {
                if (ENABLE_LOG) {
                    Log.d(TAG, ""  alreadyInProgress"");
                }
                alreadyInProgress = true;
            }
        }
        // holding the synchronization lock
        if (alreadyInProgress) {
            syncContextClient.onFinished(SyncResult.ALREADY_IN_PROGRESS);
        }
    } catch (RuntimeException | Error th) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""startSync() caught exception"", th);
        }
        throw th;
    } finally {
        if (ENABLE_LOG) {
            Log.d(TAG, ""startSync() finishing"");
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The late version of the implementation has introduced a new ""return"" early exit statement (return;) if the calling method 'isCallerSystem()' returns false. Because of this new control dependency, it changes when the method will exit, which corresponds to code change type 1 and 3.","Due to the newly added control dependency and return statement, the late version of the API may return without executing any of the functionality that was present in the early version if 'isCallerSystem()' returns false. Thus, this change could potentially lead to a different behavior, which is why the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
13,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, null, /*excludedPermissions=*/
        appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, null, /*excludedPermissions=*/
        null, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,,,0,,,,,,,4,0,"The only change is the removal of the comment `/*excludedPermissions=*/` which does not affect the actual logic or behavior of the code. Therefore, the change type is 4.","There are no changes to any execution paths, return values, or handled exceptions. The API's behavior remains unchanged, thus there is no Compatibility Issue present (type 0)."
15,<android.widget.TextView: boolean isFallbackLineSpacing()>,32,33,,,,"{
    return mUseFallbackLineSpacing;
}","{
    return mUseFallbackLineSpacing != FALLBACK_LINE_SPACING_NONE;
}",1,"/**
 * @return whether fallback line spacing is enabled, {@code true} by default
 *
 * @see #setFallbackLineSpacing(boolean)
 *
 * @attr ref android.R.styleable#TextView_fallbackLineSpacing
 */
","/**
 * @return whether fallback line spacing is enabled, {@code true} by default
 *
 * @see #setFallbackLineSpacing(boolean)
 *
 * @attr ref android.R.styleable#TextView_fallbackLineSpacing
 */
",0,[@InspectableProperty],[@InspectableProperty],0,,,,,,,1,1,"The return statement now includes a comparison operation: it checks if mUseFallbackLineSpacing is different from FALLBACK_LINE_SPACING_NONE, instead of directly returning the value of mUseFallbackLineSpacing like in the early version. This means a new condition has been introduced to the return statement, which is a change of type 1.","Since the value returned is now conditional on mUseFallbackLineSpacing not being equal to FALLBACK_LINE_SPACING_NONE, which is different from the direct return of the value in the early version, there is a potential for the method to return a different value in the later version. This is a compatibility issue of type 1."
16,<android.os.Bundle: Bundle deepCopy()>,32,33,,,,"{
    Bundle b = new Bundle(false);
    b.copyInternal(this, true);
    return b;
}","{
    return new Bundle(this, /* deep */
    true);
}",1,"/**
 * Make a deep copy of the given bundle.  Traverses into inner containers and copies
 * them as well, so they are not shared across bundles.  Will traverse in to
 * {@link Bundle}, {@link PersistableBundle}, {@link ArrayList}, and all types of
 * primitive arrays.  Other types of objects (such as Parcelable or Serializable)
 * are referenced as-is and not copied in any way.
 */
","/**
 * Make a deep copy of the given bundle.  Traverses into inner containers and copies
 * them as well, so they are not shared across bundles.  Will traverse in to
 * {@link Bundle}, {@link PersistableBundle}, {@link ArrayList}, and all types of
 * primitive arrays.  Other types of objects (such as Parcelable or Serializable)
 * are referenced as-is and not copied in any way.
 */
",0,,,0,,,,,,,4,0,"The implementation of the method changed from creating a new instance and then calling `copyInternal` to directly creating a new instance with different constructor parameters, which signifies an internal refactor without altering the external behavior. This change falls into 'Other statement changed'.",No Compatibility Issue is expected to arise from this code change because the method's purpose of returning a deep copy of the Bundle remains intact. The adjustments appear to only simplify the creation process without affecting the method's contract or the semantics of the returned value.
18,"<android.service.autofill.CharSequenceTransformation.Builder: Builder addField(AutofillId,Pattern,String)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(id);
    Preconditions.checkNotNull(regex);
    Preconditions.checkNotNull(subst);
    mFields.put(id, new Pair<>(regex, subst));
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(id);
    Objects.requireNonNull(regex);
    Objects.requireNonNull(subst);
    mFields.put(id, new Pair<>(regex, subst));
    return this;
}",1,"/**
 * Adds the transformed contents of a field to the overall result of this transformation.
 *
 * @param id id of the screen field.
 * @param regex regular expression with groups (delimited by {@code (} and {@code (}) that
 * are used to substitute parts of the value.
 * @param subst the string that substitutes the matched regex, using {@code $} for
 * group substitution ({@code $1} for 1st group match, {@code $2} for 2nd, etc).
 *
 * @return this builder.
 */
","/**
 * Adds the transformed contents of a field to the overall result of this transformation.
 *
 * @param id id of the screen field.
 * @param regex regular expression with groups (delimited by {@code (} and {@code (}) that
 * are used to substitute parts of the value.
 * @param subst the string that substitutes the matched regex, using {@code $} for
 * group substitution ({@code $1} for 1st group match, {@code $2} for 2nd, etc).
 *
 * @return this builder.
 */
",0,,,0,,,,,,,4,0,"The code change is in the null-check implementation: from using `Preconditions.checkNotNull()` to `Objects.requireNonNull()`. However, both methods serve the same purpose of ensuring that an object is not null and will throw a `NullPointerException`. Hence, the change is only in the method used for null checking, which is classified as 'Other statement changed'.","There is no compatibility issue since both methods are designed to perform a null-check and throw a `NullPointerException` if the condition is not met. The behavior of the API remains unchanged for clients calling this method with null or non-null values, making it safe in terms of backward compatibility."
20,"<android.text.StaticLayout: void generate(Builder,boolean,boolean)>",32,33,,,,"{
    final CharSequence source = b.mText;
    final int bufStart = b.mStart;
    final int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    final boolean fallbackLineSpacing = b.mFallbackLineSpacing;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    final boolean addLastLineSpacing = b.mAddLastLineLineSpacing;
    int lineBreakCapacity = 0;
    int[] breaks = null;
    float[] lineWidths = null;
    float[] ascents = null;
    float[] descents = null;
    boolean[] hasTabs = null;
    int[] hyphenEdits = null;
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    final int[] indents;
    if (mLeftIndents != null || mRightIndents != null) {
        final int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
        final int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
        final int indentsLen = Math.max(leftLen, rightLen);
        indents = new int[indentsLen];
        for (int i = 0; i < leftLen; i++) {
            indents[i] = mLeftIndents[i];
        }
        for (int i = 0; i < rightLen; i++) {
            indents[i] += mRightIndents[i];
        }
    } else {
        indents = null;
    }
    final LineBreaker lineBreaker = new LineBreaker.Builder().setBreakStrategy(b.mBreakStrategy).setHyphenationFrequency(b.mHyphenationFrequency).setJustificationMode(b.mJustificationMode).setIndents(indents).build();
    LineBreaker.ParagraphConstraints constraints = new LineBreaker.ParagraphConstraints();
    PrecomputedText.ParagraphInfo[] paragraphInfo = null;
    final Spanned spanned = (source instanceof Spanned) ? (Spanned) source : null;
    if (source instanceof PrecomputedText) {
        PrecomputedText precomputed = (PrecomputedText) source;
        @PrecomputedText.Params.CheckResultUsableResult final int checkResult = precomputed.checkResultUsable(bufStart, bufEnd, textDir, paint, b.mBreakStrategy, b.mHyphenationFrequency);
        switch(checkResult) {
            case PrecomputedText.Params.UNUSABLE:
                break;
            case PrecomputedText.Params.NEED_RECOMPUTE:
                final PrecomputedText.Params newParams = new PrecomputedText.Params.Builder(paint).setBreakStrategy(b.mBreakStrategy).setHyphenationFrequency(b.mHyphenationFrequency).setTextDirection(textDir).build();
                precomputed = PrecomputedText.create(precomputed, newParams);
                paragraphInfo = precomputed.getParagraphInfo();
                break;
            case PrecomputedText.Params.USABLE:
                // Some parameters are different from the ones when measured text is created.
                paragraphInfo = precomputed.getParagraphInfo();
                break;
        }
    }
    if (paragraphInfo == null) {
        final PrecomputedText.Params param = new PrecomputedText.Params(paint, textDir, b.mBreakStrategy, b.mHyphenationFrequency);
        paragraphInfo = PrecomputedText.createMeasuredParagraphs(source, param, bufStart, bufEnd, false);
    }
    for (int paraIndex = 0; paraIndex < paragraphInfo.length; paraIndex++) {
        final int paraStart = paraIndex == 0 ? bufStart : paragraphInfo[paraIndex - 1].paragraphEnd;
        final int paraEnd = paragraphInfo[paraIndex].paragraphEnd;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        // tab stop locations
        float[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                float[] stops = new float[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = (float) spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        final MeasuredParagraph measuredPara = paragraphInfo[paraIndex].measured;
        final char[] chs = measuredPara.getChars();
        final int[] spanEndCache = measuredPara.getSpanEndCache().getRawArray();
        final int[] fmCache = measuredPara.getFontMetrics().getRawArray();
        constraints.setWidth(restWidth);
        constraints.setIndent(firstWidth, firstWidthLineCount);
        constraints.setTabStops(variableTabStops, TAB_INCREMENT);
        LineBreaker.Result res = lineBreaker.computeLineBreaks(measuredPara.getMeasuredText(), constraints, mLineCount);
        int breakCount = res.getLineCount();
        if (lineBreakCapacity < breakCount) {
            lineBreakCapacity = breakCount;
            breaks = new int[lineBreakCapacity];
            lineWidths = new float[lineBreakCapacity];
            ascents = new float[lineBreakCapacity];
            descents = new float[lineBreakCapacity];
            hasTabs = new boolean[lineBreakCapacity];
            hyphenEdits = new int[lineBreakCapacity];
        }
        for (int i = 0; i < breakCount; ++i) {
            breaks[i] = res.getLineBreakOffset(i);
            lineWidths[i] = res.getLineWidth(i);
            ascents[i] = res.getLineAscent(i);
            descents[i] = res.getLineDescent(i);
            hasTabs[i] = res.hasLineTab(i);
            hyphenEdits[i] = packHyphenEdit(res.getStartLineHyphenEdit(i), res.getEndLineHyphenEdit(i));
        }
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (0 < remainingLineCount && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width
            float width = 0;
            // XXX May need to also have starting hyphen edit
            boolean hasTab = false;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += measuredPara.getCharWidthAt(j);
                    }
                }
                hasTab |= hasTabs[i];
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            hasTabs[remainingLineCount - 1] = hasTab;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently
        // measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                final int ascent = fallbackLineSpacing ? Math.min(fmAscent, Math.round(ascents[breakIndex])) : fmAscent;
                final int descent = fallbackLineSpacing ? Math.max(fmDescent, Math.round(descents[breakIndex])) : fmDescent;
                v = out(source, here, endPos, ascent, descent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabs[breakIndex], hyphenEdits[breakIndex], needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, chs, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd) {
            break;
        }
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        final MeasuredParagraph measuredPara = MeasuredParagraph.buildForBidi(source, bufEnd, bufEnd, textDir, null);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, 0, needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}","{
    final CharSequence source = b.mText;
    final int bufStart = b.mStart;
    final int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    final boolean addLastLineSpacing = b.mAddLastLineLineSpacing;
    int lineBreakCapacity = 0;
    int[] breaks = null;
    float[] lineWidths = null;
    float[] ascents = null;
    float[] descents = null;
    boolean[] hasTabs = null;
    int[] hyphenEdits = null;
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    mFallbackLineSpacing = b.mFallbackLineSpacing;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    final int[] indents;
    if (mLeftIndents != null || mRightIndents != null) {
        final int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
        final int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
        final int indentsLen = Math.max(leftLen, rightLen);
        indents = new int[indentsLen];
        for (int i = 0; i < leftLen; i++) {
            indents[i] = mLeftIndents[i];
        }
        for (int i = 0; i < rightLen; i++) {
            indents[i] += mRightIndents[i];
        }
    } else {
        indents = null;
    }
    final LineBreaker lineBreaker = new LineBreaker.Builder().setBreakStrategy(b.mBreakStrategy).setHyphenationFrequency(getBaseHyphenationFrequency(b.mHyphenationFrequency)).setJustificationMode(b.mJustificationMode).setIndents(indents).build();
    LineBreaker.ParagraphConstraints constraints = new LineBreaker.ParagraphConstraints();
    PrecomputedText.ParagraphInfo[] paragraphInfo = null;
    final Spanned spanned = (source instanceof Spanned) ? (Spanned) source : null;
    if (source instanceof PrecomputedText) {
        PrecomputedText precomputed = (PrecomputedText) source;
        @PrecomputedText.Params.CheckResultUsableResult final int checkResult = precomputed.checkResultUsable(bufStart, bufEnd, textDir, paint, b.mBreakStrategy, b.mHyphenationFrequency, b.mLineBreakConfig);
        switch(checkResult) {
            case PrecomputedText.Params.UNUSABLE:
                break;
            case PrecomputedText.Params.NEED_RECOMPUTE:
                final PrecomputedText.Params newParams = new PrecomputedText.Params.Builder(paint).setBreakStrategy(b.mBreakStrategy).setHyphenationFrequency(b.mHyphenationFrequency).setTextDirection(textDir).setLineBreakConfig(b.mLineBreakConfig).build();
                precomputed = PrecomputedText.create(precomputed, newParams);
                paragraphInfo = precomputed.getParagraphInfo();
                break;
            case PrecomputedText.Params.USABLE:
                // Some parameters are different from the ones when measured text is created.
                paragraphInfo = precomputed.getParagraphInfo();
                break;
        }
    }
    if (paragraphInfo == null) {
        final PrecomputedText.Params param = new PrecomputedText.Params(paint, b.mLineBreakConfig, textDir, b.mBreakStrategy, b.mHyphenationFrequency);
        paragraphInfo = PrecomputedText.createMeasuredParagraphs(source, param, bufStart, bufEnd, false);
    }
    for (int paraIndex = 0; paraIndex < paragraphInfo.length; paraIndex++) {
        final int paraStart = paraIndex == 0 ? bufStart : paragraphInfo[paraIndex - 1].paragraphEnd;
        final int paraEnd = paragraphInfo[paraIndex].paragraphEnd;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        // tab stop locations
        float[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                float[] stops = new float[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = (float) spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        final MeasuredParagraph measuredPara = paragraphInfo[paraIndex].measured;
        final char[] chs = measuredPara.getChars();
        final int[] spanEndCache = measuredPara.getSpanEndCache().getRawArray();
        final int[] fmCache = measuredPara.getFontMetrics().getRawArray();
        constraints.setWidth(restWidth);
        constraints.setIndent(firstWidth, firstWidthLineCount);
        constraints.setTabStops(variableTabStops, TAB_INCREMENT);
        LineBreaker.Result res = lineBreaker.computeLineBreaks(measuredPara.getMeasuredText(), constraints, mLineCount);
        int breakCount = res.getLineCount();
        if (lineBreakCapacity < breakCount) {
            lineBreakCapacity = breakCount;
            breaks = new int[lineBreakCapacity];
            lineWidths = new float[lineBreakCapacity];
            ascents = new float[lineBreakCapacity];
            descents = new float[lineBreakCapacity];
            hasTabs = new boolean[lineBreakCapacity];
            hyphenEdits = new int[lineBreakCapacity];
        }
        for (int i = 0; i < breakCount; ++i) {
            breaks[i] = res.getLineBreakOffset(i);
            lineWidths[i] = res.getLineWidth(i);
            ascents[i] = res.getLineAscent(i);
            descents[i] = res.getLineDescent(i);
            hasTabs[i] = res.hasLineTab(i);
            hyphenEdits[i] = packHyphenEdit(res.getStartLineHyphenEdit(i), res.getEndLineHyphenEdit(i));
        }
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (0 < remainingLineCount && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width
            float width = 0;
            // XXX May need to also have starting hyphen edit
            boolean hasTab = false;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += measuredPara.getCharWidthAt(j);
                    }
                }
                hasTab |= hasTabs[i];
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            hasTabs[remainingLineCount - 1] = hasTab;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently
        // measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                final int ascent = mFallbackLineSpacing ? Math.min(fmAscent, Math.round(ascents[breakIndex])) : fmAscent;
                final int descent = mFallbackLineSpacing ? Math.max(fmDescent, Math.round(descents[breakIndex])) : fmDescent;
                // clipping.
                if (mFallbackLineSpacing) {
                    if (ascent < fmTop) {
                        fmTop = ascent;
                    }
                    if (descent > fmBottom) {
                        fmBottom = descent;
                    }
                }
                v = out(source, here, endPos, ascent, descent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabs[breakIndex], hyphenEdits[breakIndex], needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, chs, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd) {
            break;
        }
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        final MeasuredParagraph measuredPara = MeasuredParagraph.buildForBidi(source, bufEnd, bufEnd, textDir, null);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, 0, needMultiply, measuredPara, bufEnd, includepad, trackpad, addLastLineSpacing, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,,,,
21,"<android.app.Activity: boolean onKeyUp(int,KeyEvent)>",32,33,,,,"{
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
            onBackPressed();
            return true;
        }
    }
    return false;
}","{
    int sdkVersion = getApplicationInfo().targetSdkVersion;
    if (sdkVersion >= Build.VERSION_CODES.ECLAIR) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled() && mDefaultBackCallback == null) {
            // Using legacy back handling.
            onBackPressed();
            return true;
        }
    }
    return false;
}",1,"/**
 * Called when a key was released and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>The default implementation handles KEYCODE_BACK to stop the activity
 * and go back.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyDown
 * @see KeyEvent
 */
","/**
 * Called when a key was released and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>The default implementation handles KEYCODE_BACK to stop the activity
 * and go back.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyDown
 * @see KeyEvent
 */
",0,,,0,,,,,,,3,0,"The change to the implementation involves adding an additional condition check in the if statement (`mDefaultBackCallback == null`) within the existing control flow, so the change type is 3.","The new condition `mDefaultBackCallback == null` must be true for the method to execute `onBackPressed()` and return true, which is an additional qualification compared to the early version. However, because this condition pertains to an internal callback that the method `onKeyUp` does not expose or modify the state or behavior of, it does not introduce a compatibility issue related to return values or exception handling. Existing code invoking this API would not have to be aware of or interact with `mDefaultBackCallback`. Therefore, it does not introduce a potential different return value or throw an exception differently, and the CI type is 0."
22,<android.os.UserManager: boolean isManagedProfile()>,32,33,,,,"{
    // Worst case we might end up calling the AIDL method multiple times but that's fine.
    if (mIsManagedProfileCached != null) {
        return mIsManagedProfileCached;
    }
    try {
        mIsManagedProfileCached = mService.isManagedProfile(UserHandle.myUserId());
        return mIsManagedProfileCached;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    return isManagedProfile(getContextUserIfAppropriate());
}",1,"/**
 * Checks if the calling app is running in a managed profile.
 *
 * @return whether the caller is in a managed profile.
 */
","/**
 * Checks if the context user is a managed profile.
 *
 * Note that this applies specifically to <em>managed</em> profiles. For profiles in general,
 * use {@link #isProfile()} instead.
 *
 * @return whether the context user is a managed profile.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCallerProfileGroup = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.QUERY_USERS, android.Manifest.permission.INTERACT_ACROSS_USERS })]",1,,,,,,,"1,5",1,"The entire implementation of the method has changed; It is now calling a different API: isManagedProfile(getContextUserIfAppropriate()). The late version no longer checks for the cached value or interacts with the service directly, so the code change type is 1,5.","As the implementation is now calling another method without caching logic and RemoteException handling, it's possible that the late version API may return different values compared to the early version, hence, the CI type is 1."
23,<android.os.UserManager: boolean isSystemUser()>,32,33,,,,"{
    return UserHandle.myUserId() == UserHandle.USER_SYSTEM;
}","{
    return getContextUserIfAppropriate() == UserHandle.USER_SYSTEM;
}",1,"/**
 * Used to check if this process is running under the system user. The system user
 * is the initial user that is implicitly created on first boot and hosts most of the
 * system services.
 *
 * @return whether this process is running under the system user.
 */
","/**
 * Used to check if the context user is the system user. The system user
 * is the initial user that is implicitly created on first boot and hosts most of the
 * system services.
 *
 * @return whether the context user is the system user.
 */
",1,,[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU)],1,,,,,,,"1,5",1,"The method called within the return statement has changed from `UserHandle.myUserId()` to `getContextUserIfAppropriate()`, which indicates a change in the dependent API, and hence the code change types are 1 for a potential different return value, and 5 for a dependent API changed.","Since a different method is now being used to determine the user ID, which is also compared to the constant `UserHandle.USER_SYSTEM`, it could potentially result in a different return value if `getContextUserIfAppropriate()` does not always return the same value as `UserHandle.myUserId()`. Therefore, there is a compatibility issue due to potential different return values, making the CI type 1."
24,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(int)>,32,33,,,,"{
    AccessibilityEvent event = AccessibilityEvent.obtain();
    event.setEventType(eventType);
    return event;
}","{
    AccessibilityEvent event = new AccessibilityEvent();
    event.setEventType(eventType);
    return event;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * instantiated with its type property set.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityEvent(int)} instead.
 *
 * @param eventType The event type.
 * @return An instance.
 */
","/**
 * Instantiates a new AccessibilityEvent instance with its type property set.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityEvent()} instead.
 * @param eventType The event type.
 * @return An instance.
 */
",1,,[@Deprecated],1,,,,,,,"4,5",1,"The way the `AccessibilityEvent` object is instantiated has changed from `AccessibilityEvent.obtain()` to `new AccessibilityEvent()`, and this is a change in the dependent API, so the code change type is 4,5.","Since the instantiation of the `AccessibilityEvent` object has changed, it may potentially return an object with different attributes or state that might affect the behavior of the API. Thus, the CI type is 1."
26,"<android.app.AppOpsManager: void setOnOpNotedCallback(Executor,OnOpNotedCallback)>",32,33,,,,"{
    Preconditions.checkState((callback == null) == (asyncExecutor == null));
    synchronized (sLock) {
        if (callback == null) {
            Preconditions.checkState(sOnOpNotedCallback != null, ""No callback is currently registered"");
            try {
                mService.stopWatchingAsyncNoted(mContext.getPackageName(), sOnOpNotedCallback.mAsyncCb);
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            sOnOpNotedCallback = null;
        } else {
            Preconditions.checkState(sOnOpNotedCallback == null, ""Another callback is already registered"");
            callback.mAsyncExecutor = asyncExecutor;
            sOnOpNotedCallback = callback;
            List<AsyncNotedAppOp> missedAsyncOps = null;
            try {
                mService.startWatchingAsyncNoted(mContext.getPackageName(), sOnOpNotedCallback.mAsyncCb);
                missedAsyncOps = mService.extractAsyncOps(mContext.getPackageName());
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            if (missedAsyncOps != null) {
                int numMissedAsyncOps = missedAsyncOps.size();
                for (int i = 0; i < numMissedAsyncOps; i++) {
                    final AsyncNotedAppOp asyncNotedAppOp = missedAsyncOps.get(i);
                    if (sOnOpNotedCallback != null) {
                        sOnOpNotedCallback.getAsyncNotedExecutor().execute(() -> sOnOpNotedCallback.onAsyncNoted(asyncNotedAppOp));
                    }
                }
            }
            synchronized (this) {
                int numMissedSyncOps = sUnforwardedOps.size();
                for (int i = 0; i < numMissedSyncOps; i++) {
                    final AsyncNotedAppOp syncNotedAppOp = sUnforwardedOps.get(i);
                    if (sOnOpNotedCallback != null) {
                        sOnOpNotedCallback.getAsyncNotedExecutor().execute(() -> sOnOpNotedCallback.onAsyncNoted(syncNotedAppOp));
                    }
                }
                sUnforwardedOps.clear();
            }
        }
    }
}","{
    Preconditions.checkState((callback == null) == (asyncExecutor == null));
    synchronized (sLock) {
        if (callback == null) {
            Preconditions.checkState(sOnOpNotedCallback != null, ""No callback is currently registered"");
            try {
                mService.stopWatchingAsyncNoted(mContext.getPackageName(), sOnOpNotedCallback.mAsyncCb);
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            sOnOpNotedCallback = null;
        } else {
            Preconditions.checkState(sOnOpNotedCallback == null, ""Another callback is already registered"");
            callback.mAsyncExecutor = asyncExecutor;
            sOnOpNotedCallback = callback;
            List<AsyncNotedAppOp> missedAsyncOps = null;
            try {
                mService.startWatchingAsyncNoted(mContext.getPackageName(), sOnOpNotedCallback.mAsyncCb);
                missedAsyncOps = mService.extractAsyncOps(mContext.getPackageName());
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            // Copy pointer so callback can be dispatched out of lock
            OnOpNotedCallback onOpNotedCallback = sOnOpNotedCallback;
            if (onOpNotedCallback != null && missedAsyncOps != null) {
                int numMissedAsyncOps = missedAsyncOps.size();
                for (int i = 0; i < numMissedAsyncOps; i++) {
                    final AsyncNotedAppOp asyncNotedAppOp = missedAsyncOps.get(i);
                    onOpNotedCallback.getAsyncNotedExecutor().execute(() -> onOpNotedCallback.onAsyncNoted(asyncNotedAppOp));
                }
            }
            synchronized (this) {
                int numMissedSyncOps = sUnforwardedOps.size();
                if (onOpNotedCallback != null) {
                    for (int i = 0; i < numMissedSyncOps; i++) {
                        final AsyncNotedAppOp syncNotedAppOp = sUnforwardedOps.get(i);
                        onOpNotedCallback.getAsyncNotedExecutor().execute(() -> onOpNotedCallback.onAsyncNoted(syncNotedAppOp));
                    }
                }
                sUnforwardedOps.clear();
            }
        }
    }
}",1,"/**
 * Set a new {@link OnOpNotedCallback}.
 *
 * <p>There can only ever be one collector per process. If there currently is another callback
 * set, this will fail.
 *
 * @param asyncExecutor executor to execute {@link OnOpNotedCallback#onAsyncNoted} on, {@code
 * null} to unset
 * @param callback listener to set, {@code null} to unset
 *
 * @throws IllegalStateException If another callback is already registered
 */
","/**
 * Set a new {@link OnOpNotedCallback}.
 *
 * <p>There can only ever be one collector per process. If there currently is another callback
 * set, this will fail.
 *
 * @param asyncExecutor executor to execute {@link OnOpNotedCallback#onAsyncNoted} on, {@code
 * null} to unset
 * @param callback listener to set, {@code null} to unset
 *
 * @throws IllegalStateException If another callback is already registered
 */
",0,,,0,,,,,,,"3,4",0,"The code change is a refactoring that does not alter existing control flow or functional behavior. Instead of directly using sOnOpNotedCallback inside the lambda, the method now assigns it to a local variable onOpNotedCallback and uses this local variable instead. There are also changes in the structure of the control dependency inside 'if (sOnOpNotedCallback != null)' which is now 'if (onOpNotedCallback != null)' in the late version but essentially, the logic remains the same. Therefore, the types of change are primarily refactoring falling under 3 (Control dependency change) and 4 (Other statement changed), where some of the structure and assignments have been revised.","No Compatibility Issue is detected because the changes do not affect the outward behavior of the API; they are merely internal improvements to the clarity of the code without altering the semantics. The behavior when calling this method before and after the change will remain the same from the caller's perspective, assuming no side effects or changes outside of the visible code snippets here."
28,<android.app.UiAutomation: void setServiceInfo(AccessibilityServiceInfo)>,32,33,,,,"{
    final IAccessibilityServiceConnection connection;
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        AccessibilityInteractionClient.getInstance().clearCache();
        connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    }
    // Calling out without a lock held.
    if (connection != null) {
        try {
            connection.setServiceInfo(info);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while setting AccessibilityServiceInfo"", re);
        }
    }
}","{
    final IAccessibilityServiceConnection connection;
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        AccessibilityInteractionClient.getInstance().clearCache(mConnectionId);
        connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    }
    // Calling out without a lock held.
    if (connection != null) {
        try {
            connection.setServiceInfo(info);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while setting AccessibilityServiceInfo"", re);
        }
    }
}",1,"/**
 * Sets the {@link AccessibilityServiceInfo} that describes how this
 * UiAutomation will be handled by the platform accessibility layer.
 *
 * @param info The info.
 *
 * @throws IllegalStateException If the connection to the accessibility subsystem is not
 * established.
 * @see AccessibilityServiceInfo
 */
","/**
 * Sets the {@link AccessibilityServiceInfo} that describes how this
 * UiAutomation will be handled by the platform accessibility layer.
 *
 * @param info The info.
 *
 * @throws IllegalStateException If the connection to the accessibility subsystem is not
 * established.
 * @see AccessibilityServiceInfo
 */
",0,,,0,,,,,,,"4,5",0,"The method `clearCache` of `AccessibilityInteractionClient` has an additional parameter in the late version (`mConnectionId` is passed as an argument), suggesting the method signature or behavior has changed. The change type is 4,5.",There is no Compatibility Issue because the change in the `clearCache` method signature does not affect the input/output or exception behavior directly seen by clients of `setServiceInfo` method.
31,"<android.service.voice.AbstractHotwordDetector: boolean startRecognition(ParcelFileDescriptor,AudioFormat,PersistableBundle)>",32,33,,,,"{
    if (DEBUG) {
        Slog.i(TAG, ""#recognizeHotword"");
    }
    try {
        mManagerService.startListeningFromExternalSource(audioStream, audioFormat, options, new BinderCallback(mHandler, mCallback));
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    return true;
}","{
    if (DEBUG) {
        Slog.i(TAG, ""#recognizeHotword"");
    }
    throwIfDetectorIsNoLongerActive();
    try {
        mManagerService.startListeningFromExternalSource(audioStream, audioFormat, options, new BinderCallback(mHandler, mCallback));
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    return true;
}",1,"/**
 * Detect hotword from an externally supplied stream of data.
 *
 * @return true if the request to start recognition succeeded
 */
","/**
 * Detect hotword from an externally supplied stream of data.
 *
 * @return true if the request to start recognition succeeded
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"An other statement 'throwIfDetectorIsNoLongerActive()' is added to the method body before the try block. The change type is 4 since this is neither a return statement, exception handling statement, nor a control dependency change.","The addition of this new method 'throwIfDetectorIsNoLongerActive()' does not constitute a change in the return type or exception handling directly; instead, it may raise a new exception before the previous code had a chance to run. However, because the method definition does not include any checked exceptions that must be declared, and because RemoteException is re-thrown with 'rethrowFromSystemServer()', there is no change in the API's contract regarding exceptions or return values. Therefore, there is no compatibility issue according to the given definitions."
32,"<android.text.PrecomputedText: PrecomputedText create(CharSequence,Params)>",32,33,,,,"{
    ParagraphInfo[] paraInfo = null;
    if (text instanceof PrecomputedText) {
        final PrecomputedText hintPct = (PrecomputedText) text;
        final PrecomputedText.Params hintParams = hintPct.getParams();
        @Params.CheckResultUsableResult final int checkResult = hintParams.checkResultUsable(params.mPaint, params.mTextDir, params.mBreakStrategy, params.mHyphenationFrequency);
        switch(checkResult) {
            case Params.USABLE:
                return hintPct;
            case Params.NEED_RECOMPUTE:
                // hyphenation frequency must be the same.
                if (params.getBreakStrategy() == hintParams.getBreakStrategy() && params.getHyphenationFrequency() == hintParams.getHyphenationFrequency()) {
                    paraInfo = createMeasuredParagraphsFromPrecomputedText(hintPct, params, true);
                }
                break;
            case Params.UNUSABLE:
        }
    }
    if (paraInfo == null) {
        paraInfo = createMeasuredParagraphs(text, params, 0, text.length(), true);
    }
    return new PrecomputedText(text, 0, text.length(), params, paraInfo);
}","{
    ParagraphInfo[] paraInfo = null;
    if (text instanceof PrecomputedText) {
        final PrecomputedText hintPct = (PrecomputedText) text;
        final PrecomputedText.Params hintParams = hintPct.getParams();
        @Params.CheckResultUsableResult final int checkResult = hintParams.checkResultUsable(params.mPaint, params.mTextDir, params.mBreakStrategy, params.mHyphenationFrequency, params.mLineBreakConfig);
        switch(checkResult) {
            case Params.USABLE:
                return hintPct;
            case Params.NEED_RECOMPUTE:
                // hyphenation frequency must be the same.
                if (params.getBreakStrategy() == hintParams.getBreakStrategy() && params.getHyphenationFrequency() == hintParams.getHyphenationFrequency()) {
                    paraInfo = createMeasuredParagraphsFromPrecomputedText(hintPct, params, true);
                }
                break;
            case Params.UNUSABLE:
        }
    }
    if (paraInfo == null) {
        paraInfo = createMeasuredParagraphs(text, params, 0, text.length(), true);
    }
    return new PrecomputedText(text, 0, text.length(), params, paraInfo);
}",1,"/**
 * Create a new {@link PrecomputedText} which will pre-compute text measurement and glyph
 * positioning information.
 * <p>
 * This can be expensive, so computing this on a background thread before your text will be
 * presented can save work on the UI thread.
 * </p>
 *
 * Note that any {@link android.text.NoCopySpan} attached to the text won't be passed to the
 * created PrecomputedText.
 *
 * @param text the text to be measured
 * @param params parameters that define how text will be precomputed
 * @return A {@link PrecomputedText}
 */
","/**
 * Create a new {@link PrecomputedText} which will pre-compute text measurement and glyph
 * positioning information.
 * <p>
 * This can be expensive, so computing this on a background thread before your text will be
 * presented can save work on the UI thread.
 * </p>
 *
 * Note that any {@link android.text.NoCopySpan} attached to the text won't be passed to the
 * created PrecomputedText.
 *
 * @param text the text to be measured
 * @param params parameters that define how text will be precomputed
 * @return A {@link PrecomputedText}
 */
",0,,,0,,,,,,,5,0,"The dependent API `checkResultUsable` call within `hintParams.checkResultUsable(...)` has an additional parameter `params.mLineBreakConfig` in the late version. This indicates that the signature of the dependent API has changed, hence the code change type is 5.","The change to the dependent API does not necessarily lead to a Compatibility Issue. Since the additional parameter does not affect the return value directly and there is no indication that the behavior of `checkResultUsable` has changed as a result of this additional parameter, there is no evidence that a different value or exception would arise from this change. Therefore, there is no CI."
34,<android.view.contentcapture.ContentCaptureManager: void removeData(DataRemovalRequest)>,32,33,,,,"{
    Preconditions.checkNotNull(request);
    try {
        mService.removeData(request);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(request);
    try {
        mService.removeData(request);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by the app to request the content capture service to remove content capture data
 * associated with some context.
 *
 * @param request object specifying what user data should be removed.
 */
","/**
 * Called by the app to request the content capture service to remove content capture data
 * associated with some context.
 *
 * @param request object specifying what user data should be removed.
 */
",0,,,0,,,,,,,4,0,"The only change is from Preconditions.checkNotNull(request) in the early version to Objects.requireNonNull(request) in the late version, which is a change from one null-check implementation to another. Both methods are used for the same purpose, so the change type is 4.","This is not a compatibility issue as both `Preconditions.checkNotNull` and `Objects.requireNonNull` serve the same purpose: to check if the object is not null. Hence, there is no change in the external behavior or contract of the API, and the CI type is 0."
36,"<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl: int setRepeatingRequest(CaptureRequest,Executor,ExtensionCaptureCallback)>",32,33,,,,"{
    int seqId = -1;
    synchronized (mInterfaceLock) {
        if (!mInitialized) {
            throw new IllegalStateException(""Uninitialized component"");
        }
        if (mClientRepeatingRequestSurface == null) {
            throw new IllegalArgumentException(""No registered preview surface"");
        }
        if (!request.containsTarget(mClientRepeatingRequestSurface) || (request.getTargets().size() != 1)) {
            throw new IllegalArgumentException(""Invalid repeating request output target!"");
        }
        try {
            seqId = mSessionProcessor.startRepeating(new RequestCallbackHandler(request, executor, listener));
        } catch (RemoteException e) {
            throw new CameraAccessException(CameraAccessException.CAMERA_ERROR, ""Failed to enable repeating request, extension service failed to respond!"");
        }
    }
    return seqId;
}","{
    int seqId = -1;
    synchronized (mInterfaceLock) {
        if (!mInitialized) {
            throw new IllegalStateException(""Uninitialized component"");
        }
        if (mClientRepeatingRequestSurface == null) {
            throw new IllegalArgumentException(""No registered preview surface"");
        }
        if (!request.containsTarget(mClientRepeatingRequestSurface) || (request.getTargets().size() != 1)) {
            throw new IllegalArgumentException(""Invalid repeating request output target!"");
        }
        try {
            mSessionProcessor.setParameters(request);
            seqId = mSessionProcessor.startRepeating(new RequestCallbackHandler(request, executor, listener));
        } catch (RemoteException e) {
            throw new CameraAccessException(CameraAccessException.CAMERA_ERROR, ""Failed to enable repeating request, extension service failed to respond!"");
        }
    }
    return seqId;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The code change includes an additional method call (mSessionProcessor.setParameters(request);) before the already existing call to mSessionProcessor.startRepeating(new RequestCallbackHandler(request, executor, listener)); hence the change type is 4.","There is no Compatibility Issue introduced by this change since the additional setParameters(request) method call does not affect the control flow or exception handling of the method, and the return statement remains the same. This change implies enhancing or configuring the session processor with parameters from the request before starting to repeat, which should not inherently cause a different value to be returned or an exception to be thrown."
37,<android.view.accessibility.AccessibilityNodeInfo: String toString()>,32,33,,,,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: 0x"").append(Long.toHexString(mSourceNodeId));
        builder.append(""; windowId: 0x"").append(Long.toHexString(mWindowId));
        builder.append(""; accessibilityViewId: 0x"").append(Long.toHexString(getAccessibilityViewId(mSourceNodeId)));
        builder.append(""; virtualDescendantId: 0x"").append(Long.toHexString(getVirtualDescendantId(mSourceNodeId)));
        builder.append(""; mParentNodeId: 0x"").append(Long.toHexString(mParentNodeId));
        builder.append(""; traversalBefore: 0x"").append(Long.toHexString(mTraversalBefore));
        builder.append(""; traversalAfter: 0x"").append(Long.toHexString(mTraversalAfter));
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(""0x"").append(Long.toHexString(childIds.get(i)));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "").append(mBoundsInParent);
    builder.append(""; boundsInScreen: "").append(mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; stateDescription: "").append(mStateDescription);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; tooltipText: "").append(mTooltipText);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; importantForAccessibility: "").append(isImportantForAccessibility());
    builder.append(""; visible: "").append(isVisibleToUser());
    builder.append(""; actions: "").append(mActions);
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""; sourceNodeId: 0x"").append(Long.toHexString(mSourceNodeId));
        builder.append(""; windowId: 0x"").append(Long.toHexString(mWindowId));
        builder.append(""; accessibilityViewId: 0x"").append(Long.toHexString(getAccessibilityViewId(mSourceNodeId)));
        builder.append(""; virtualDescendantId: 0x"").append(Long.toHexString(getVirtualDescendantId(mSourceNodeId)));
        builder.append(""; mParentNodeId: 0x"").append(Long.toHexString(mParentNodeId));
        builder.append(""; traversalBefore: 0x"").append(Long.toHexString(mTraversalBefore));
        builder.append(""; traversalAfter: 0x"").append(Long.toHexString(mTraversalAfter));
        int granularities = mMovementGranularities;
        builder.append(""; MovementGranularities: ["");
        while (granularities != 0) {
            final int granularity = 1 << Integer.numberOfTrailingZeros(granularities);
            granularities &= ~granularity;
            builder.append(getMovementGranularitySymbolicName(granularity));
            if (granularities != 0) {
                builder.append("", "");
            }
        }
        builder.append(""]"");
        builder.append(""; childAccessibilityIds: ["");
        final LongArray childIds = mChildNodeIds;
        if (childIds != null) {
            for (int i = 0, count = childIds.size(); i < count; i++) {
                builder.append(""0x"").append(Long.toHexString(childIds.get(i)));
                if (i < count - 1) {
                    builder.append("", "");
                }
            }
        }
        builder.append(""]"");
    }
    builder.append(""; boundsInParent: "").append(mBoundsInParent);
    builder.append(""; boundsInScreen: "").append(mBoundsInScreen);
    builder.append(""; packageName: "").append(mPackageName);
    builder.append(""; className: "").append(mClassName);
    builder.append(""; text: "").append(mText);
    builder.append(""; error: "").append(mError);
    builder.append(""; maxTextLength: "").append(mMaxTextLength);
    builder.append(""; stateDescription: "").append(mStateDescription);
    builder.append(""; contentDescription: "").append(mContentDescription);
    builder.append(""; tooltipText: "").append(mTooltipText);
    builder.append(""; viewIdResName: "").append(mViewIdResourceName);
    builder.append(""; uniqueId: "").append(mUniqueId);
    builder.append(""; checkable: "").append(isCheckable());
    builder.append(""; checked: "").append(isChecked());
    builder.append(""; focusable: "").append(isFocusable());
    builder.append(""; focused: "").append(isFocused());
    builder.append(""; selected: "").append(isSelected());
    builder.append(""; clickable: "").append(isClickable());
    builder.append(""; longClickable: "").append(isLongClickable());
    builder.append(""; contextClickable: "").append(isContextClickable());
    builder.append(""; enabled: "").append(isEnabled());
    builder.append(""; password: "").append(isPassword());
    builder.append(""; scrollable: "").append(isScrollable());
    builder.append(""; importantForAccessibility: "").append(isImportantForAccessibility());
    builder.append(""; visible: "").append(isVisibleToUser());
    builder.append(""; actions: "").append(mActions);
    builder.append(""; isTextSelectable: "").append(isTextSelectable());
    return builder.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
38,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,32,33,,,,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return ""FLAG_SERVICE_HANDLES_DOUBLE_TAP"";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return ""FLAG_REQUEST_MULTI_FINGER_GESTURES"";
        case FLAG_REQUEST_2_FINGER_PASSTHROUGH:
            return ""FLAG_REQUEST_2_FINGER_PASSTHROUGH"";
        case FLAG_SEND_MOTION_EVENTS:
            return ""FLAG_SEND_MOTION_EVENTS"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return ""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return ""FLAG_SERVICE_HANDLES_DOUBLE_TAP"";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return ""FLAG_REQUEST_MULTI_FINGER_GESTURES"";
        case FLAG_REQUEST_2_FINGER_PASSTHROUGH:
            return ""FLAG_REQUEST_2_FINGER_PASSTHROUGH"";
        case FLAG_SEND_MOTION_EVENTS:
            return ""FLAG_SEND_MOTION_EVENTS"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return ""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"";
        case FLAG_INPUT_METHOD_EDITOR:
            return ""FLAG_INPUT_METHOD_EDITOR"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",0,,,0,,,,,,,"1,4",1,"A new case 'FLAG_INPUT_METHOD_EDITOR' with a return statement has been added to the switch statement, this is categorized under ""Other statement changed"". Additionally, the addition of a new return statement as part of that new case means the return statement type has also changed.","The addition of a new case with a return statement can lead to a different value being returned for that new flag, if it is passed to the method, compared to returning 'null' by default previously. This is a Compatibility Issue as the behavior of the API has changed with new potential return values."
40,<android.app.admin.DevicePolicyManager: boolean isPreferentialNetworkServiceEnabled()>,32,33,,,,"{
    throwIfParentInstance(""isPreferentialNetworkServiceEnabled"");
    if (mService == null) {
        return false;
    }
    try {
        return mService.isPreferentialNetworkServiceEnabled(myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""isPreferentialNetworkServiceEnabled"");
    return getPreferentialNetworkServiceConfigs().stream().anyMatch(c -> c.isEnabled());
}",1,"/**
 * Indicates whether preferential network service is enabled.
 *
 * <p>This method can be called by the profile owner of a managed profile.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner.
 */
","/**
 * Indicates whether preferential network service is enabled.
 *
 * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile.
 * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile
 * or device owner.
 *
 * @return whether preferential network service is enabled.
 * @throws SecurityException if the caller is not the profile owner or device owner.
 */
",1,,,0,,,,,,,"1,5",1,"The early version includes an if statement checking if mService is null and a try-catch block calling mService.isPreferentialNetworkServiceEnabled(), whereas the late version introduces a new return statement with a different method getPreferentialNetworkServiceConfigs() and a Lambda expression. Thus, the code change type is 1,5 due to the complete change of the method implementation and the usage of a new method getPreferentialNetworkServiceConfigs().","There's a Compatibility Issue due to a different return value that is derived from a different source. In the early version, the return value relies on a direct service call - mService.isPreferentialNetworkServiceEnabled(). In the late version, the return is calculating based on getPreferentialNetworkServiceConfigs(), which changes the behavior significantly. Therefore, the change in return values or types leads to a Compatibility Issue of type 1."
43,<android.hardware.camera2.impl.CameraExtensionSessionImpl.CameraOutputImageCallback: void onImageAvailable(ImageReader)>,32,33,,,,"{
    Image img;
    try {
        img = reader.acquireNextImage();
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Failed to acquire image, too many images pending!"");
        mOutOfBuffers = true;
        return;
    }
    if (img == null) {
        Log.e(TAG, ""Invalid image!"");
        return;
    }
    Long timestamp = img.getTimestamp();
    if (mImageListenerMap.containsKey(timestamp)) {
        Pair<Image, OnImageAvailableListener> entry = mImageListenerMap.remove(timestamp);
        if (entry.second != null) {
            entry.second.onImageAvailable(reader, img);
        } else {
            Log.w(TAG, ""Invalid image listener, dropping frame!"");
            img.close();
        }
    } else {
        mImageListenerMap.put(img.getTimestamp(), new Pair<>(img, null));
    }
}","{
    Image img;
    try {
        img = reader.acquireNextImage();
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Failed to acquire image, too many images pending!"");
        mOutOfBuffers = true;
        return;
    }
    if (img == null) {
        Log.e(TAG, ""Invalid image!"");
        return;
    }
    Long timestamp = img.getTimestamp();
    if (mImageListenerMap.containsKey(timestamp)) {
        Pair<Image, OnImageAvailableListener> entry = mImageListenerMap.remove(timestamp);
        if (entry.second != null) {
            entry.second.onImageAvailable(reader, img);
        } else {
            Log.w(TAG, ""Invalid image listener, dropping frame!"");
            img.close();
        }
    } else {
        mImageListenerMap.put(img.getTimestamp(), new Pair<>(img, null));
    }
    notifyDroppedImages(timestamp);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There is the addition of a new method call `notifyDroppedImages(timestamp)` at the end of the implementation, which is an other statement changed, hence the code change type is 4.","The addition of the `notifyDroppedImages(timestamp)` does not alter the return value or the exception handling of the method; it seems to be a side-effect operation that notifies about dropped images outside of the existing method's flow. Therefore, this change does not introduce a Compatibility Issue, and the CI type is 0."
44,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",32,33,,,,"{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
    boolean drawingWithRenderNode = mAttachInfo != null && mAttachInfo.mHardwareAccelerated && hardwareAcceleratedCanvas;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
        if (layerType != LAYER_TYPE_NONE) {
            // If not drawing with RenderNode, treat HW layers as SW
            layerType = LAYER_TYPE_SOFTWARE;
            buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.hasDisplayList()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((RecordingCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    boolean drawingWithRenderNode = drawsWithRenderNode(canvas);
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;
    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    RenderNode renderNode = null;
    Bitmap cache = null;
    // TODO: signify cache state with just 'cache' local
    int layerType = getLayerType();
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
        if (layerType != LAYER_TYPE_NONE) {
            // If not drawing with RenderNode, treat HW layers as SW
            layerType = LAYER_TYPE_SOFTWARE;
            buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }
    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.hasDisplayList()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;
    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }
        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }
    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((RecordingCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 *
 * This is where the View specializes rendering behavior based on layer type,
 * and hardware acceleration.
 */
",0,,,0,,,,,,,,,,
45,<android.service.controls.Control.StatelessBuilder: Control build()>,32,33,,,,"{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, STATUS_UNKNOWN, ControlTemplate.NO_TEMPLATE, """");
}","{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, STATUS_UNKNOWN, ControlTemplate.NO_TEMPLATE, """", true);
}",1,"/**
 * @return a valid {@link Control}
 */
","/**
 * @return a valid {@link Control}
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The constructor for 'Control' in the return statement has an extra parameter 'true' added in the late version. This indicates that there's a change in the dependent API (the constructor for Control class), so the code change type is 1,5.","Since the constructor for 'Control' has an additional argument in the late version, this will lead to a new version of 'Control' object being created which could potentially have different behavior or state. This constitutes a change that could lead to different return values, so the CI type is 1."
46,<android.net.Ikev2VpnProfile: PrivateKey getRsaPrivateKey()>,32,33,,,,"{
    return mRsaPrivateKey;
}","{
    if (mIkeTunConnParams != null)
        return null;
    return mRsaPrivateKey;
}",1,"/**
 * Retrieves the RSA private key.
 *
 * <p>May be null if the profile is not using RSA Digital Signature authentication
 */
","/**
 * Retrieves the RSA private key.
 *
 * <p>May be null if the profile is not using RSA Digital Signature authentication, or the
 * profile is built from an {@link IkeTunnelConnectionParams}.
 */
",1,[@Nullable],[@Nullable],0,,,,,,,"1, 3",1,"In the late version, there's a new control dependency change (an if-statement) that changes the circumstances under which the method will return the private key: it now returns null if mIkeTunConnParams is not null, which is a change from the early version. Therefore, the code change types are 1 for the new return statement and 3 for the control dependency change.","The change to the return statement, due to the new control structure, could lead to a different returned value, so the CI type is 1."
47,<android.text.PrecomputedText.Params.Builder: Params build()>,32,33,,,,"{
    return new Params(mPaint, mTextDir, mBreakStrategy, mHyphenationFrequency);
}","{
    return new Params(mPaint, mLineBreakConfig, mTextDir, mBreakStrategy, mHyphenationFrequency);
}",1,"/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
","/**
 * Build the {@link Params}.
 *
 * @return the layout parameter
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The constructor for Params has an additional parameter in the late version which is mLineBreakConfig. The number of parameters for the constructor has changed, resulting in code change types 1,5.","The CI type is 1 because the additional parameter passed to the constructor means that a Params object with potentially different characteristics is being returned, which could cause different behavior in the late version of the API."
48,<android.content.pm.ShortcutManager: boolean setDynamicShortcuts(List<ShortcutInfo>)>,32,33,,,,"{
    try {
        return ((boolean) getFutureOrThrow(mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId())));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,[@WorkerThread],[@WorkerThread],0,,,,,,,4,0,"The change involves removing a cast to boolean. However, since the method 'setDynamicShortcuts' already returns a boolean, the cast is unnecessary and the removal does not affect the returned value. The code change type is 4 due to the modification of the expression.","There is no Compatibility Issue since the behavior of the API has not been altered; the method is expected to return the same value as before, and the exception handling has not changed. The cast was redundant because 'setDynamicShortcuts' already returns a boolean. Hence, the API consumers would not experience any different behavior."
49,<android.content.pm.ShortcutManager: void removeDynamicShortcuts(List<String>)>,32,33,,,,"{
    try {
        getFutureOrThrow(mService.removeDynamicShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.removeDynamicShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Delete dynamic shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Delete dynamic shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,,,0,,,,,,,4,0,"The invocation of ""getFutureOrThrow"" method is removed, but the core functionality which is the call to ""mService.removeDynamicShortcuts"" remains unchanged, which means the behavior intended by the API consumer is unaffected, so the change type is 4.","There is no compatibility issue because the change will not affect the behavior from the client's point of view. The API still performs the same action, which is removing dynamic shortcuts, and the exception handling has not changed either. The return type is void, and there is no alternative return path, so the API cannot return a different value."
50,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",32,33,,,,"{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mStorageManager.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce, getObbInfo(canonicalPath));
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkArgument(key == null, ""mounting encrypted OBBs is no longer supported"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mStorageManager.mountObb(rawPath, canonicalPath, mObbActionListener, nonce, getObbInfo(canonicalPath));
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
","/**
 * Mount an Opaque Binary Blob (OBB) file.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key must be <code>null</code>. Previously, some Android device
 * implementations accepted a non-<code>null</code> key to mount
 * an encrypted OBB file. However, this never worked reliably and
 * is no longer supported.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
",1,,,0,,,,,,,"2,4",2,"The change in the code is the introduction of a new precondition check: Preconditions.checkArgument(key == null, ""mounting encrypted OBBs is no longer supported""), which is a different exception handling statement that could potentially throw a new IllegalArgumentException, so the code change type is 2,4.","Due to the new precondition check for the 'key' parameter that throws IllegalArgumentException if 'key' is not null, the late version of the method could throw a new type of exception that the old version would not. Hence, the CI type is 2."
51,"<android.provider.Settings.Global: long getLong(ContentResolver,String,long)>",32,33,,,,"{
    String valString = getString(cr, name);
    long value;
    try {
        value = valString != null ? Long.parseLong(valString) : def;
    } catch (NumberFormatException e) {
        value = def;
    }
    return value;
}","{
    String v = getString(cr, name);
    return parseLongSettingWithDefault(v, def);
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
",0,,,0,,,,,,,"1,5",1,"The method has a changed return statement that now calls a different method, parseLongSettingWithDefault(v, def), which wasn't present in the early version. Furthermore, the local variable name was changed from 'valString' to 'v', but that doesn't affect the functionality. However, since the implementation has changed to use a new method for parsing the long value, the code change type is 1,5. ","Since the parsing logic for the long value has been refactored into a new method, this could potentially cause the return value to change, as the implementation of the new method parseLongSettingWithDefault(v, def) might be different from the inline code in the early version, thus the CI type is 1."
52,<android.service.autofill.FillResponse.Builder: Builder setFlags(int)>,32,33,,,,"{
    throwIfDestroyed();
    mFlags = Preconditions.checkFlagsArgument(flags, FLAG_TRACK_CONTEXT_COMMITED | FLAG_DISABLE_ACTIVITY_ONLY);
    return this;
}","{
    throwIfDestroyed();
    mFlags = Preconditions.checkFlagsArgument(flags, FLAG_TRACK_CONTEXT_COMMITED | FLAG_DISABLE_ACTIVITY_ONLY | FLAG_DELAY_FILL);
    return this;
}",1,"/**
 * Sets flags changing the response behavior.
 *
 * @param flags a combination of {@link #FLAG_TRACK_CONTEXT_COMMITED} and
 * {@link #FLAG_DISABLE_ACTIVITY_ONLY}, or {@code 0}.
 *
 * @return This builder.
 */
","/**
 * Sets flags changing the response behavior.
 *
 * @param flags a combination of {@link #FLAG_TRACK_CONTEXT_COMMITED} and
 * {@link #FLAG_DISABLE_ACTIVITY_ONLY}, or {@code 0}.
 *
 * @return This builder.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,"The only change is in the parameters of the Preconditions.checkFlagsArgument method where an additional flag (FLAG_DELAY_FILL) is included. This is an internal check and does not affect the return value or exception handling of the method, so the code change type is 4.",There is no Compatibility Issue because the method's behavior in terms of returned value or thrown exception has not been altered. The additional flag is just another valid option that can be passed without changing the methodâ€™s contract.
53,"<android.view.KeyEvent: KeyEvent changeTimeRepeat(KeyEvent,long,int,int)>",32,33,,,,"{
    KeyEvent ret = new KeyEvent(event);
    // Not an exact copy so assign a new ID.
    ret.mId = nativeNextId();
    ret.mEventTime = eventTime;
    ret.mRepeatCount = newRepeat;
    ret.mFlags = newFlags;
    return ret;
}","{
    KeyEvent ret = new KeyEvent(event);
    // Not an exact copy so assign a new ID.
    ret.mId = nativeNextId();
    ret.mEventTime = TimeUnit.NANOSECONDS.convert(eventTime, TimeUnit.MILLISECONDS);
    ret.mRepeatCount = newRepeat;
    ret.mFlags = newFlags;
    return ret;
}",1,"/**
 * Create a new key event that is the same as the given one, but whose
 * event time and repeat count are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param eventTime The new event time
 * (in {@link android.os.SystemClock#uptimeMillis}) of the event.
 * @param newRepeat The new repeat count of the event.
 * @param newFlags New flags for the event, replacing the entire value
 * in the original event.
 */
","/**
 * Create a new key event that is the same as the given one, but whose
 * event time and repeat count are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param eventTime The new event time
 * (in {@link android.os.SystemClock#uptimeMillis}) of the event.
 * @param newRepeat The new repeat count of the event.
 * @param newFlags New flags for the event, replacing the entire value
 * in the original event.
 */
",0,,,0,,,,,,,"4,5",1,"The statement 'ret.mEventTime = eventTime;' has changed to 'ret.mEventTime = TimeUnit.NANOSECONDS.convert(eventTime, TimeUnit.MILLISECONDS);'. This change involves a different implementation on how 'eventTime' is assigned to 'mEventTime', indicating a change in the conversion of time units which affects the assignment of 'ret.mEventTime'. Hence, this is classified as a change because the logic of how the value is computed has been altered, and this is an Other statement changed (4). This also represents a change in a dependent API as the TimeUnit conversion method is being used, which qualifies as a Dependent API changed (5).","Because the method of calculating 'eventTime' has changed, it could potentially lead to a different return value, which in this case is the 'eventTime' attribute in 'ret'. If developers have written code based on specific timing expectations coming from the event, this modification could result in a behavior change and therefore represents a Compatibility Issue due to potential different return values (1)."
57,<android.content.pm.SigningInfo: Signature[] getApkContentsSigners()>,32,33,,,,"{
    return mSigningDetails.signatures;
}","{
    return mSigningDetails.getSignatures();
}",1,"/**
 * Returns the signing certificates used to sign the APK contents of this application.  Not
 * including any past signing certificates the package proved it is authorized to use.
 * <note>
 * This method should not be used unless {@link #hasMultipleSigners()} returns true,
 * indicating that {@link #getSigningCertificateHistory()} cannot be used, otherwise {@link
 * #getSigningCertificateHistory()} should be preferred.
 * </note>
 */
","/**
 * Returns the signing certificates used to sign the APK contents of this application.  Not
 * including any past signing certificates the package proved it is authorized to use.
 * <note>
 * This method should not be used unless {@link #hasMultipleSigners()} returns true,
 * indicating that {@link #getSigningCertificateHistory()} cannot be used, otherwise {@link
 * #getSigningCertificateHistory()} should be preferred.
 * </note>
 */
",0,,,0,,,,,,,5,0,"The method call used to return the signatures has changed from direct field access (mSigningDetails.signatures) to invoking a getter method (mSigningDetails.getSignatures()), indicating the code change type is 5.","Despite the shift from a direct field access to a method call, if the getter method (getSignatures()) strictly returns the same field (signatures) without modifications, there would be no Compatibility Issue regarding return values or exceptions. Assuming getSignatures() is correctly implemented to return the unmodified signatures, the API will behave consistently, and thus the CI type is 0."
59,<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.ImageReaderHandler: void onImageAvailable(ImageReader)>,32,33,,,,"{
    if (mIImageProcessor == null) {
        return;
    }
    Image img;
    try {
        img = reader.acquireNextImage();
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Failed to acquire image, too many images pending!"");
        return;
    }
    if (img == null) {
        Log.e(TAG, ""Invalid image!"");
        return;
    }
    try {
        reader.detachImage(img);
    } catch (Exception e) {
        Log.e(TAG, ""Failed to detach image"");
        img.close();
        return;
    }
    ParcelImage parcelImage = new ParcelImage();
    parcelImage.buffer = img.getHardwareBuffer();
    if (img.getFenceFd() >= 0) {
        try {
            parcelImage.fence = ParcelFileDescriptor.fromFd(img.getFenceFd());
        } catch (IOException e) {
            Log.e(TAG, ""Failed to parcel buffer fence!"");
        }
    }
    parcelImage.width = img.getWidth();
    parcelImage.height = img.getHeight();
    parcelImage.format = img.getFormat();
    parcelImage.timestamp = img.getTimestamp();
    parcelImage.transform = img.getTransform();
    parcelImage.scalingMode = img.getScalingMode();
    parcelImage.planeCount = img.getPlaneCount();
    parcelImage.crop = img.getCropRect();
    try {
        mIImageProcessor.onNextImageAvailable(mOutputConfigId, parcelImage, mPhysicalCameraId);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to propagate image buffer on output surface id: "" + mOutputConfigId + "" extension service does not respond!"");
    } finally {
        parcelImage.buffer.close();
        img.close();
    }
}","{
    if (mIImageProcessor == null) {
        return;
    }
    Image img;
    try {
        img = reader.acquireNextImage();
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Failed to acquire image, too many images pending!"");
        return;
    }
    if (img == null) {
        Log.e(TAG, ""Invalid image!"");
        return;
    }
    try {
        reader.detachImage(img);
    } catch (Exception e) {
        Log.e(TAG, ""Failed to detach image"");
        img.close();
        return;
    }
    ParcelImage parcelImage = new ParcelImage();
    parcelImage.buffer = img.getHardwareBuffer();
    try {
        SyncFence fd = img.getFence();
        if (fd.isValid()) {
            parcelImage.fence = fd.getFdDup();
        }
    } catch (IOException e) {
        Log.e(TAG, ""Failed to parcel buffer fence!"");
    }
    parcelImage.width = img.getWidth();
    parcelImage.height = img.getHeight();
    parcelImage.format = img.getFormat();
    parcelImage.timestamp = img.getTimestamp();
    parcelImage.transform = img.getTransform();
    parcelImage.scalingMode = img.getScalingMode();
    parcelImage.planeCount = img.getPlaneCount();
    parcelImage.crop = img.getCropRect();
    try {
        mIImageProcessor.onNextImageAvailable(mOutputConfigId, parcelImage, mPhysicalCameraId);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to propagate image buffer on output surface id: "" + mOutputConfigId + "" extension service does not respond!"");
    } finally {
        parcelImage.buffer.close();
        img.close();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",1,"The method invocation img.getFenceFd() is replaced with img.getFence() and fd.getFdDup(), which are different methods, and the check `img.getFenceFd() >= 0` is replaced with `fd.isValid()`. Therefore, the dependent API has changed (5). Because of this change in how the image fence is handled, other statements have also changed accordingly (4).","The API's behavior has potentially changed by the fact that the new implementation may interact with the image's sync fence differently than before, which could lead to different outcomes (e.g., different exceptions being thrown, different handling of the image fence file descriptor). Therefore, there's a compatibility issue due to the potential for different return values or types (1)."
60,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,32,33,,,,"{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    final AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    if (mLeashedChild != null && childId == LEASHED_NODE_ID) {
        return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mLeashedChild, ROOT_NODE_ID, false, FLAG_PREFETCH_DESCENDANTS, null);
    }
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS, null);
}","{
    return getChild(index, FLAG_PREFETCH_DESCENDANTS_HYBRID);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",1,,,0,,,,,,,5,0,"The method implementation in the late version is calling a different method getChild(int, int), using 'index' and a constant FLAG_PREFETCH_DESCENDANTS_HYBRID as the parameters. Hence, it indicates that the early version's implementation has been replaced by delegating the call to a potentially new overloaded method in the same class. Thus the code change type is 5.","Since the implementation of the late version is an internal call to a method that presumably accomplishes equivalent functionality but is not shown here, we cannot assume or detect a difference in behavior based solely on this information. Without knowing the new behavior of getChild(int, int), this change might not lead to a compatibility issue as long as the new method correctly fulfills the contract of the original API. Therefore, there is no detected CI."
61,<android.content.pm.SigningInfo: boolean hasMultipleSigners()>,32,33,,,,"{
    return mSigningDetails.signatures != null && mSigningDetails.signatures.length > 1;
}","{
    return mSigningDetails.getSignatures() != null && mSigningDetails.getSignatures().length > 1;
}",1,"/**
 * Although relatively uncommon, packages may be signed by more than one signer, in which case
 * their identity is viewed as being the set of all signers, not just any one.
 */
","/**
 * Although relatively uncommon, packages may be signed by more than one signer, in which case
 * their identity is viewed as being the set of all signers, not just any one.
 */
",0,,,0,,,,,,,5,0,"The method used within the return statement has changed from a direct field access mSigningDetails.signatures to a method call mSigningDetails.getSignatures(), thus the change type is 5 (Dependent API changed).","Assuming the method mSigningDetails.getSignatures() is implemented to return the same value as the previously directly accessed field mSigningDetails.signatures, the overall behaviour of hasMultipleSigners() will not be affected. Therefore, there's no Compatibility Issue, so the CI type is 0."
62,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdListNoLazy()>,32,33,,,,"{
    if (sCameraServiceDisabled) {
        return new String[] {};
    }
    CameraStatus[] cameraStatuses;
    ICameraServiceListener.Stub testListener = new ICameraServiceListener.Stub() {

        @Override
        public void onStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onPhysicalCameraStatusChanged(int status, String id, String physicalId) throws RemoteException {
        }

        @Override
        public void onTorchStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onCameraAccessPrioritiesChanged() {
        }

        @Override
        public void onCameraOpened(String id, String clientPackageId) {
        }

        @Override
        public void onCameraClosed(String id) {
        }
    };
    String[] cameraIds = null;
    synchronized (mLock) {
        connectCameraServiceLocked();
        try {
            // The purpose of the addListener, removeListener pair here is to get a fresh
            // list of camera ids from cameraserver. We do this since for in test processes,
            // changes can happen w.r.t non-changeable permissions (eg: SYSTEM_CAMERA
            // permissions can be effectively changed by calling
            // adopt(drop)ShellPermissionIdentity()).
            // Camera devices, which have their discovery affected by these permission
            // changes, will not have clients get callbacks informing them about these
            // devices going offline (in real world scenarios, these permissions aren't
            // changeable). Future calls to getCameraIdList() will reflect the changes in
            // the camera id list after getCameraIdListNoLazy() is called.
            // We need to remove the torch ids which may have been associated with the
            // devices removed as well. This is the same situation.
            cameraStatuses = mCameraService.addListener(testListener);
            mCameraService.removeListener(testListener);
            for (CameraStatus c : cameraStatuses) {
                onStatusChangedLocked(c.status, c.cameraId);
            }
            Set<String> deviceCameraIds = mDeviceStatus.keySet();
            ArrayList<String> deviceIdsToRemove = new ArrayList<String>();
            for (String deviceCameraId : deviceCameraIds) {
                // adoptShellPermissionIdentity() and then dropShellPermissionIdentity().
                if (!cameraStatusesContains(cameraStatuses, deviceCameraId)) {
                    deviceIdsToRemove.add(deviceCameraId);
                }
            }
            for (String id : deviceIdsToRemove) {
                onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, id);
                mTorchStatus.remove(id);
            }
        } catch (ServiceSpecificException e) {
            // Unexpected failure
            throw new IllegalStateException(""Failed to register a camera service listener"", e);
        } catch (RemoteException e) {
        // Camera service is now down, leave mCameraService as null
        }
        cameraIds = extractCameraIdListLocked();
    }
    sortCameraIds(cameraIds);
    return cameraIds;
}","{
    if (sCameraServiceDisabled) {
        return new String[] {};
    }
    CameraStatus[] cameraStatuses;
    ICameraServiceListener.Stub testListener = new ICameraServiceListener.Stub() {

        @Override
        public void onStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onPhysicalCameraStatusChanged(int status, String id, String physicalId) throws RemoteException {
        }

        @Override
        public void onTorchStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onTorchStrengthLevelChanged(String id, int newStrengthLevel) throws RemoteException {
        }

        @Override
        public void onCameraAccessPrioritiesChanged() {
        }

        @Override
        public void onCameraOpened(String id, String clientPackageId) {
        }

        @Override
        public void onCameraClosed(String id) {
        }
    };
    String[] cameraIds = null;
    synchronized (mLock) {
        connectCameraServiceLocked();
        try {
            // The purpose of the addListener, removeListener pair here is to get a fresh
            // list of camera ids from cameraserver. We do this since for in test processes,
            // changes can happen w.r.t non-changeable permissions (eg: SYSTEM_CAMERA
            // permissions can be effectively changed by calling
            // adopt(drop)ShellPermissionIdentity()).
            // Camera devices, which have their discovery affected by these permission
            // changes, will not have clients get callbacks informing them about these
            // devices going offline (in real world scenarios, these permissions aren't
            // changeable). Future calls to getCameraIdList() will reflect the changes in
            // the camera id list after getCameraIdListNoLazy() is called.
            // We need to remove the torch ids which may have been associated with the
            // devices removed as well. This is the same situation.
            cameraStatuses = mCameraService.addListener(testListener);
            mCameraService.removeListener(testListener);
            for (CameraStatus c : cameraStatuses) {
                onStatusChangedLocked(c.status, c.cameraId);
            }
            Set<String> deviceCameraIds = mDeviceStatus.keySet();
            ArrayList<String> deviceIdsToRemove = new ArrayList<String>();
            for (String deviceCameraId : deviceCameraIds) {
                // adoptShellPermissionIdentity() and then dropShellPermissionIdentity().
                if (!cameraStatusesContains(cameraStatuses, deviceCameraId)) {
                    deviceIdsToRemove.add(deviceCameraId);
                }
            }
            for (String id : deviceIdsToRemove) {
                onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, id);
                mTorchStatus.remove(id);
            }
        } catch (ServiceSpecificException e) {
            // Unexpected failure
            throw new IllegalStateException(""Failed to register a camera service listener"", e);
        } catch (RemoteException e) {
        // Camera service is now down, leave mCameraService as null
        }
        cameraIds = extractCameraIdListLocked();
    }
    sortCameraIds(cameraIds);
    return cameraIds;
}",1,,,0,,,0,,,,,,,,,,
64,<android.content.pm.CrossProfileApps: CharSequence getProfileSwitchingLabel(UserHandle)>,32,33,,,,"{
    verifyCanAccessUser(userHandle);
    final int stringRes = mUserManager.isManagedProfile(userHandle.getIdentifier()) ? R.string.managed_profile_label : R.string.user_owner_label;
    return mResources.getString(stringRes);
}","{
    verifyCanAccessUser(userHandle);
    final boolean isManagedProfile = mUserManager.isManagedProfile(userHandle.getIdentifier());
    final DevicePolicyManager dpm = mContext.getSystemService(DevicePolicyManager.class);
    return dpm.getResources().getString(getUpdatableProfileSwitchingLabelId(isManagedProfile), () -> getDefaultProfileSwitchingLabel(isManagedProfile));
}",1,"/**
 * Return a label that calling app can show to user for the semantic of profile switching --
 * launching its own activity in specified user profile. For example, it may return
 * ""Switch to work"" if the given user handle is the managed profile one.
 *
 * @param userHandle The UserHandle of the target profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 * @return a label that calling app can show user for the semantic of launching its own
 * activity in the specified user profile.
 *
 * @see #startMainActivity(ComponentName, UserHandle)
 */
","/**
 * Return a label that calling app can show to user for the semantic of profile switching --
 * launching its own activity in specified user profile. For example, it may return
 * ""Switch to work"" if the given user handle is the managed profile one.
 *
 * @param userHandle The UserHandle of the target profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 * @return a label that calling app can show user for the semantic of launching its own
 * activity in the specified user profile.
 *
 * @see #startMainActivity(ComponentName, UserHandle)
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"3,4,5","1,5","The late version introduces a new variable `isManagedProfile`, changes the way the string resource is determined by introducing a new method `getUpdatableProfileSwitchingLabelId`, and a new way to resolve the string by calling `dpm.getResources().getString`. Additionally, it utilizes a lambda expression to provide a fallback via `getDefaultProfileSwitchingLabel`.  As these changes include adding new dependency methods (`getUpdatableProfileSwitchingLabelId` and `getDefaultProfileSwitchingLabel`) and how the resource string is fetched, the code change types are 3,4,5.","The CI could arise due to the different logic for obtaining the string resource, involving new methods that provide different behavior for determining the label ID and retrieving the resources. The compatibility issue arises from the potential different return values or types due to changes in the API the current method relies on (Dependent API changed), so the CI type is 1 and 5."
65,"<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>",32,33,,,,"{
    if (dest.maybeWriteSquashed(this)) {
        return;
    }
    super.writeToParcel(dest, parcelableFlags);
    dest.writeString8(taskAffinity);
    dest.writeString8(permission);
    dest.writeString8(processName);
    dest.writeString8(className);
    dest.writeInt(theme);
    dest.writeInt(flags);
    dest.writeInt(privateFlags);
    dest.writeInt(privateFlagsExt);
    dest.writeInt(requiresSmallestWidthDp);
    dest.writeInt(compatibleWidthLimitDp);
    dest.writeInt(largestWidthLimitDp);
    if (storageUuid != null) {
        dest.writeInt(1);
        dest.writeLong(storageUuid.getMostSignificantBits());
        dest.writeLong(storageUuid.getLeastSignificantBits());
    } else {
        dest.writeInt(0);
    }
    dest.writeString8(scanSourceDir);
    dest.writeString8(scanPublicSourceDir);
    dest.writeString8(sourceDir);
    dest.writeString8(publicSourceDir);
    dest.writeString8Array(splitNames);
    dest.writeString8Array(splitSourceDirs);
    dest.writeString8Array(splitPublicSourceDirs);
    dest.writeSparseArray((SparseArray) splitDependencies);
    dest.writeString8(nativeLibraryDir);
    dest.writeString8(secondaryNativeLibraryDir);
    dest.writeString8(nativeLibraryRootDir);
    dest.writeInt(nativeLibraryRootRequiresIsa ? 1 : 0);
    dest.writeString8(primaryCpuAbi);
    dest.writeString8(secondaryCpuAbi);
    dest.writeString8Array(resourceDirs);
    dest.writeString8Array(overlayPaths);
    dest.writeString8(seInfo);
    dest.writeString8(seInfoUser);
    dest.writeString8Array(sharedLibraryFiles);
    dest.writeTypedList(sharedLibraryInfos);
    dest.writeString8(dataDir);
    dest.writeString8(deviceProtectedDataDir);
    dest.writeString8(credentialProtectedDataDir);
    dest.writeInt(uid);
    dest.writeInt(minSdkVersion);
    dest.writeInt(targetSdkVersion);
    dest.writeLong(longVersionCode);
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(enabledSetting);
    dest.writeInt(installLocation);
    dest.writeString8(manageSpaceActivityName);
    dest.writeString8(backupAgentName);
    dest.writeInt(descriptionRes);
    dest.writeInt(uiOptions);
    dest.writeInt(fullBackupContent);
    dest.writeInt(dataExtractionRulesRes);
    dest.writeBoolean(crossProfile);
    dest.writeInt(networkSecurityConfigRes);
    dest.writeInt(category);
    dest.writeInt(targetSandboxVersion);
    dest.writeString8(classLoaderName);
    dest.writeString8Array(splitClassLoaderNames);
    dest.writeInt(compileSdkVersion);
    dest.writeString8(compileSdkVersionCodename);
    dest.writeString8(appComponentFactory);
    dest.writeInt(iconRes);
    dest.writeInt(roundIconRes);
    dest.writeInt(mHiddenApiPolicy);
    dest.writeInt(hiddenUntilInstalled ? 1 : 0);
    dest.writeString8(zygotePreloadName);
    dest.writeInt(gwpAsanMode);
    dest.writeInt(memtagMode);
    dest.writeInt(nativeHeapZeroInitialized);
    sForBoolean.parcel(requestRawExternalStorageAccess, dest, parcelableFlags);
}","{
    if (dest.maybeWriteSquashed(this)) {
        return;
    }
    super.writeToParcel(dest, parcelableFlags);
    dest.writeString8(taskAffinity);
    dest.writeString8(permission);
    dest.writeString8(processName);
    dest.writeString8(className);
    dest.writeInt(theme);
    dest.writeInt(flags);
    dest.writeInt(privateFlags);
    dest.writeInt(privateFlagsExt);
    dest.writeInt(requiresSmallestWidthDp);
    dest.writeInt(compatibleWidthLimitDp);
    dest.writeInt(largestWidthLimitDp);
    if (storageUuid != null) {
        dest.writeInt(1);
        dest.writeLong(storageUuid.getMostSignificantBits());
        dest.writeLong(storageUuid.getLeastSignificantBits());
    } else {
        dest.writeInt(0);
    }
    dest.writeString8(scanSourceDir);
    dest.writeString8(scanPublicSourceDir);
    dest.writeString8(sourceDir);
    dest.writeString8(publicSourceDir);
    dest.writeString8Array(splitNames);
    dest.writeString8Array(splitSourceDirs);
    dest.writeString8Array(splitPublicSourceDirs);
    dest.writeSparseArray((SparseArray) splitDependencies);
    dest.writeString8(nativeLibraryDir);
    dest.writeString8(secondaryNativeLibraryDir);
    dest.writeString8(nativeLibraryRootDir);
    dest.writeInt(nativeLibraryRootRequiresIsa ? 1 : 0);
    dest.writeString8(primaryCpuAbi);
    dest.writeString8(secondaryCpuAbi);
    dest.writeString8Array(resourceDirs);
    dest.writeString8Array(overlayPaths);
    dest.writeString8(seInfo);
    dest.writeString8(seInfoUser);
    dest.writeString8Array(sharedLibraryFiles);
    dest.writeTypedList(sharedLibraryInfos);
    dest.writeString8(dataDir);
    dest.writeString8(deviceProtectedDataDir);
    dest.writeString8(credentialProtectedDataDir);
    dest.writeInt(uid);
    dest.writeInt(minSdkVersion);
    dest.writeInt(targetSdkVersion);
    dest.writeLong(longVersionCode);
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(enabledSetting);
    dest.writeInt(installLocation);
    dest.writeString8(manageSpaceActivityName);
    dest.writeString8(backupAgentName);
    dest.writeInt(descriptionRes);
    dest.writeInt(uiOptions);
    dest.writeInt(fullBackupContent);
    dest.writeInt(dataExtractionRulesRes);
    dest.writeBoolean(crossProfile);
    dest.writeInt(networkSecurityConfigRes);
    dest.writeInt(category);
    dest.writeInt(targetSandboxVersion);
    dest.writeString8(classLoaderName);
    dest.writeString8Array(splitClassLoaderNames);
    dest.writeInt(compileSdkVersion);
    dest.writeString8(compileSdkVersionCodename);
    dest.writeString8(appComponentFactory);
    dest.writeInt(iconRes);
    dest.writeInt(roundIconRes);
    dest.writeInt(mHiddenApiPolicy);
    dest.writeInt(hiddenUntilInstalled ? 1 : 0);
    dest.writeString8(zygotePreloadName);
    dest.writeInt(gwpAsanMode);
    dest.writeInt(memtagMode);
    dest.writeInt(nativeHeapZeroInitialized);
    sForBoolean.parcel(requestRawExternalStorageAccess, dest, parcelableFlags);
    dest.writeLong(createTimestamp);
    if (mAppClassNamesByProcess == null) {
        dest.writeInt(0);
    } else {
        final int size = mAppClassNamesByProcess.size();
        dest.writeInt(size);
        for (int i = 0; i < size; i++) {
            dest.writeString(mAppClassNamesByProcess.keyAt(i));
            dest.writeString(mAppClassNamesByProcess.valueAt(i));
        }
    }
    dest.writeInt(localeConfigRes);
    sForStringSet.parcel(mKnownActivityEmbeddingCerts, dest, flags);
}",1,,,0,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",0,,,,,,,,,,
66,<android.os.Vibrator: int areAllEffectsSupported(int)>,32,33,,,,"{
    int support = VIBRATION_EFFECT_SUPPORT_YES;
    for (int supported : areEffectsSupported(effectIds)) {
        if (supported == VIBRATION_EFFECT_SUPPORT_NO) {
            return VIBRATION_EFFECT_SUPPORT_NO;
        } else if (supported == VIBRATION_EFFECT_SUPPORT_UNKNOWN) {
            support = VIBRATION_EFFECT_SUPPORT_UNKNOWN;
        }
    }
    return support;
}","{
    VibratorInfo info = getInfo();
    int allSupported = VIBRATION_EFFECT_SUPPORT_YES;
    for (int effectId : effectIds) {
        switch(info.isEffectSupported(effectId)) {
            case VIBRATION_EFFECT_SUPPORT_NO:
                return VIBRATION_EFFECT_SUPPORT_NO;
            case VIBRATION_EFFECT_SUPPORT_YES:
                continue;
            default:
                // VIBRATION_EFFECT_SUPPORT_UNKNOWN
                allSupported = VIBRATION_EFFECT_SUPPORT_UNKNOWN;
                break;
        }
    }
    return allSupported;
}",1,"/**
 * Query whether the vibrator supports all of the given effects.
 *
 * Not all hardware reports its effect capabilities, so the system may not necessarily know
 * whether an effect is supported or not.
 *
 * If the result is {@link #VIBRATION_EFFECT_SUPPORT_YES}, all effects in the query are
 * supported by the hardware.
 *
 * If the result is {@link #VIBRATION_EFFECT_SUPPORT_NO}, at least one of the effects in the
 * query is not supported.
 *
 * If the result is {@link #VIBRATION_EFFECT_SUPPORT_UNKNOWN}, the system doesn't know whether
 * all of the effects are supported. It may support any or all of the queried effects,
 * but there's no way to programmatically know whether a {@link #vibrate} call will successfully
 * cause a vibration. It's guaranteed, however, that none of the queried effects are
 * definitively unsupported by the hardware.
 *
 * @param effectIds Which effects to query for.
 * @return Whether all of the effects are supported.
 */
","/**
 * Query whether the vibrator supports all the given effects.
 *
 * <p>If an effect is not supported, the system may still automatically fall back to a simpler
 * vibration instead, which is not optimised for the specific device, however vibration isn't
 * guaranteed in this case.
 *
 * <p>If the result is {@link #VIBRATION_EFFECT_SUPPORT_YES}, all effects in the query are
 * supported by the hardware.
 *
 * <p>If the result is {@link #VIBRATION_EFFECT_SUPPORT_NO}, at least one of the effects in the
 * query is not supported, and using them may fall back to an un-optimized vibration or no
 * vibration.
 *
 * <p>If the result is {@link #VIBRATION_EFFECT_SUPPORT_UNKNOWN}, the system doesn't know
 * whether all the effects are supported. It may support any or all of the queried effects,
 * but there's no way to programmatically know whether a {@link #vibrate} call will successfully
 * cause a vibration. It's guaranteed, however, that none of the queried effects are
 * definitively unsupported by the hardware.
 *
 * <p>Use {@link #areEffectsSupported(int...)} to get individual results for each effect.
 *
 * @param effectIds Which effects to query for.
 * @return Whether all the effects are natively supported by the device.
 */
",1,[@VibrationEffectSupport],[@VibrationEffectSupport],0,,,,,,,"1,3,5",1,"The late version API introduces the dependency on a method 'getInfo()', includes a new control structure 'switch', utilizes a different method 'isEffectSupported()' within the control loop, and also slightly alters the way support levels are aggregated into 'allSupported'. Therefore, the code change types involve 1 (for the return statement changes), 3 (for the control dependency changes), and 5 (for the dependent API changes).","Because the method calls and the structure for checking support have been modified, it is possible that the late version of the API may return different values compared to the early version when the same set of effectIds is provided as input. This difference in potential return values indicates a type 1 Compatibility Issue."
67,<android.service.autofill.BatchUpdates.Builder: Builder updateTemplate(RemoteViews)>,32,33,,,,"{
    throwIfDestroyed();
    mUpdates = Preconditions.checkNotNull(updates);
    return this;
}","{
    throwIfDestroyed();
    mUpdates = Objects.requireNonNull(updates);
    return this;
}",1,"/**
 * Applies the {@code updates} in the underlying presentation template.
 *
 * <p><b>Note:</b> The updates are applied before the
 * {@link #transformChild(int, Transformation) transformations} are applied to the children
 * views.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param updates a {@link RemoteViews} with the updated actions to be applied in the
 * underlying presentation template.
 *
 * @return this builder
 * @throws IllegalArgumentException if {@code condition} is not a class provided
 * by the Android System.
 */
","/**
 * Applies the {@code updates} in the underlying presentation template.
 *
 * <p><b>Note:</b> The updates are applied before the
 * {@link #transformChild(int, Transformation) transformations} are applied to the children
 * views.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param updates a {@link RemoteViews} with the updated actions to be applied in the
 * underlying presentation template.
 *
 * @return this builder
 * @throws IllegalArgumentException if {@code condition} is not a class provided
 * by the Android System.
 */
",0,,,0,,,,,,,"4,5",0,"The method used to ensure 'updates' is not null has changed from Preconditions.checkNotNull(updates) to Objects.requireNonNull(updates), but they essentially perform the same null-check operation, so the code change is of type 4. Additionally, the change is related to the usage of API from 'Preconditions' to 'Objects', which is an external API change, marking type 5.","Even though the API for null checking is changed, the behavior of the method remains identical; it will throw a NullPointerException in case 'updates' is null in both versions. There is no change in the behavior related to exceptions being thrown or values returned by the API, therefore, there is no compatibility issue."
68,"<android.app.assist.AssistStructure.ViewNode: void initializeFromParcelWithoutChildren(Parcel,PooledStringReader,float[])>",32,33,,,,"{
    mClassName = readString(in, preader);
    mFlags = in.readInt();
    final int flags = mFlags;
    mAutofillFlags = in.readInt();
    final int autofillFlags = mAutofillFlags;
    if ((flags & FLAGS_HAS_ID) != 0) {
        mId = in.readInt();
        if (mId != View.NO_ID) {
            mIdEntry = readString(in, preader);
            if (mIdEntry != null) {
                mIdType = readString(in, preader);
                mIdPackage = readString(in, preader);
            }
        }
    }
    if (autofillFlags != 0) {
        mSanitized = in.readInt() == 1;
        mImportantForAutofill = in.readInt();
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID) != 0) {
            int autofillViewId = in.readInt();
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID) != 0) {
                mAutofillId = new AutofillId(autofillViewId, in.readInt());
            } else {
                mAutofillId = new AutofillId(autofillViewId);
            }
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID) != 0) {
                mAutofillId.setSessionId(in.readInt());
            }
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE) != 0) {
            mAutofillType = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS) != 0) {
            mAutofillHints = in.readStringArray();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE) != 0) {
            mAutofillValue = in.readParcelable(null);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS) != 0) {
            mAutofillOptions = in.readCharSequenceArray();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HTML_INFO) != 0) {
            mHtmlInfo = in.readParcelable(null);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS) != 0) {
            mMinEms = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS) != 0) {
            mMaxEms = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH) != 0) {
            mMaxLength = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY) != 0) {
            mTextIdEntry = readString(in, preader);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HINT_ID_ENTRY) != 0) {
            mHintIdEntry = readString(in, preader);
        }
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        mX = in.readInt();
        mY = in.readInt();
        mWidth = in.readInt();
        mHeight = in.readInt();
    } else {
        int val = in.readInt();
        mX = val & 0x7fff;
        mY = (val >> 16) & 0x7fff;
        val = in.readInt();
        mWidth = val & 0x7fff;
        mHeight = (val >> 16) & 0x7fff;
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        mScrollX = in.readInt();
        mScrollY = in.readInt();
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix = new Matrix();
        if (tmpMatrix == null) {
            tmpMatrix = new float[9];
        }
        in.readFloatArray(tmpMatrix);
        mMatrix.setValues(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        mElevation = in.readFloat();
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        mAlpha = in.readFloat();
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        mContentDescription = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText = new ViewNodeText(in, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        mInputType = in.readInt();
    }
    if ((flags & FLAGS_HAS_URL_SCHEME) != 0) {
        mWebScheme = in.readString();
    }
    if ((flags & FLAGS_HAS_URL_DOMAIN) != 0) {
        mWebDomain = in.readString();
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        mLocaleList = in.readParcelable(null);
    }
    if ((flags & FLAGS_HAS_MIME_TYPES) != 0) {
        mReceiveContentMimeTypes = in.readStringArray();
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        mExtras = in.readBundle();
    }
}","{
    mClassName = readString(in, preader);
    mFlags = in.readInt();
    final int flags = mFlags;
    mAutofillFlags = in.readInt();
    final int autofillFlags = mAutofillFlags;
    if ((flags & FLAGS_HAS_ID) != 0) {
        mId = in.readInt();
        if (mId != View.NO_ID) {
            mIdEntry = readString(in, preader);
            if (mIdEntry != null) {
                mIdType = readString(in, preader);
                mIdPackage = readString(in, preader);
            }
        }
    }
    if (autofillFlags != 0) {
        mSanitized = in.readInt() == 1;
        mImportantForAutofill = in.readInt();
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIEW_ID) != 0) {
            int autofillViewId = in.readInt();
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VIRTUAL_VIEW_ID) != 0) {
                mAutofillId = new AutofillId(autofillViewId, in.readInt());
            } else {
                mAutofillId = new AutofillId(autofillViewId);
            }
            if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_SESSION_ID) != 0) {
                mAutofillId.setSessionId(in.readInt());
            }
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_TYPE) != 0) {
            mAutofillType = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_HINTS) != 0) {
            mAutofillHints = in.readStringArray();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_VALUE) != 0) {
            mAutofillValue = in.readParcelable(null, android.view.autofill.AutofillValue.class);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_AUTOFILL_OPTIONS) != 0) {
            mAutofillOptions = in.readCharSequenceArray();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HTML_INFO) != 0) {
            mHtmlInfo = in.readParcelable(null, android.view.ViewStructure.HtmlInfo.class);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MIN_TEXT_EMS) != 0) {
            mMinEms = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_EMS) != 0) {
            mMaxEms = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_MAX_TEXT_LENGTH) != 0) {
            mMaxLength = in.readInt();
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_TEXT_ID_ENTRY) != 0) {
            mTextIdEntry = readString(in, preader);
        }
        if ((autofillFlags & AUTOFILL_FLAGS_HAS_HINT_ID_ENTRY) != 0) {
            mHintIdEntry = readString(in, preader);
        }
    }
    if ((flags & FLAGS_HAS_LARGE_COORDS) != 0) {
        mX = in.readInt();
        mY = in.readInt();
        mWidth = in.readInt();
        mHeight = in.readInt();
    } else {
        int val = in.readInt();
        mX = val & 0x7fff;
        mY = (val >> 16) & 0x7fff;
        val = in.readInt();
        mWidth = val & 0x7fff;
        mHeight = (val >> 16) & 0x7fff;
    }
    if ((flags & FLAGS_HAS_SCROLL) != 0) {
        mScrollX = in.readInt();
        mScrollY = in.readInt();
    }
    if ((flags & FLAGS_HAS_MATRIX) != 0) {
        mMatrix = new Matrix();
        if (tmpMatrix == null) {
            tmpMatrix = new float[9];
        }
        in.readFloatArray(tmpMatrix);
        mMatrix.setValues(tmpMatrix);
    }
    if ((flags & FLAGS_HAS_ELEVATION) != 0) {
        mElevation = in.readFloat();
    }
    if ((flags & FLAGS_HAS_ALPHA) != 0) {
        mAlpha = in.readFloat();
    }
    if ((flags & FLAGS_HAS_CONTENT_DESCRIPTION) != 0) {
        mContentDescription = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
    }
    if ((flags & FLAGS_HAS_TEXT) != 0) {
        mText = new ViewNodeText(in, (flags & FLAGS_HAS_COMPLEX_TEXT) == 0);
    }
    if ((flags & FLAGS_HAS_INPUT_TYPE) != 0) {
        mInputType = in.readInt();
    }
    if ((flags & FLAGS_HAS_URL_SCHEME) != 0) {
        mWebScheme = in.readString();
    }
    if ((flags & FLAGS_HAS_URL_DOMAIN) != 0) {
        mWebDomain = in.readString();
    }
    if ((flags & FLAGS_HAS_LOCALE_LIST) != 0) {
        mLocaleList = in.readParcelable(null, android.os.LocaleList.class);
    }
    if ((flags & FLAGS_HAS_MIME_TYPES) != 0) {
        mReceiveContentMimeTypes = in.readStringArray();
    }
    if ((flags & FLAGS_HAS_EXTRAS) != 0) {
        mExtras = in.readBundle();
    }
}",1,"// This does not read the child nodes.
","// This does not read the child nodes.
",0,,,0,,,,,,,,,,
69,<android.os.UserManager: boolean isUserUnlocked()>,32,33,,,,"{
    return isUserUnlocked(Process.myUserHandle());
}","{
    return isUserUnlocked(getContextUserIfAppropriate());
}",1,"/**
 * Return whether the calling user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 *
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
","/**
 * Return whether the context user is running in an ""unlocked"" state.
 * <p>
 * On devices with direct boot, a user is unlocked only after they've
 * entered their credentials (such as a lock pattern or PIN). On devices
 * without direct boot, a user is unlocked as soon as it starts.
 * <p>
 * When a user is locked, only device-protected data storage is available.
 * When a user is unlocked, both device-protected and credential-protected
 * private app data storage is available.
 *
 * @see Intent#ACTION_USER_UNLOCKED
 * @see Context#createDeviceProtectedStorageContext()
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCallerProfileGroup = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.INTERACT_ACROSS_USERS })]",1,,,,,,,5,1,"The method called within return statement has changed from isUserUnlocked(Process.myUserHandle()) to isUserUnlocked(getContextUserIfAppropriate()), which indicates a potential change in the dependent API, hence the change type is 5.","The change in the method call likely leads to a change in behavior because it is now fetching a different user handle context, which could result in different return values. The method isUserUnlocked() internally might perform checks for a different user, leading to different outcomes based on the user's lock state. Therefore, the CI type is 1."
70,"<android.hardware.usb.UsbRequest: boolean initialize(UsbDeviceConnection,UsbEndpoint)>",32,33,,,,"{
    mEndpoint = endpoint;
    mConnection = Objects.requireNonNull(connection, ""connection"");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open(""close"");
    }
    return wasInitialized;
}","{
    mEndpoint = endpoint;
    mConnection = Objects.requireNonNull(connection, ""connection"");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open(""UsbRequest.close"");
    }
    return wasInitialized;
}",1,"/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */
","/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */
",0,,,0,,,,,,,4,0,"Only a string literal within a method call was changed from ""close"" to ""UsbRequest.close"", which won't affect the behavior of the API, so the code change type is 4.","Since the method's signature, control flow, and return value are unaffected by this change, there is no Compatibility Issue. The change is purely cosmetic and does not impact the API's functionality."
72,<android.content.pm.ShortcutManager: boolean updateShortcuts(List<ShortcutInfo>)>,32,33,,,,"{
    try {
        return (boolean) getFutureOrThrow(mService.updateShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.updateShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or
 * dynamic, but they must not be immutable.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException If trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or
 * dynamic, but they must not be immutable.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException If trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,[@WorkerThread],[@WorkerThread],0,,,,,,,4,0,"The type casting to boolean in the early version has been removed since the mService.updateShortcuts method already returns a boolean. This change is an internal implementation detail that doesn't affect the API's external behavior, so the code change type is 4.","There is no Compatibility Issue since the return type and exception handling remain unchanged, thus the API behavior is the same in both versions. The method signature has not been altered and neither has the exception handling, so the type of CI is 0."
73,"<android.os.ServiceManagerProxy: void registerForNotifications(String,IServiceCallback)>",32,33,,,,"{
    throw new RemoteException();
}","{
    mServiceManager.registerForNotifications(name, cb);
}",1,,,0,,,0,,,,,,,"1,4,5",2,"The implementation of the method has changed from throwing an exception to executing a method call (mServiceManager.registerForNotifications(name, cb)). This introduces new statements and alters the behavior substantially, resulting in changes in control dependencies and dependent API calls. Therefore, the change types are 1 (a return statement is now present where there was none), 4 (other statements have changed), and 5 (dependent API call introduced).","The original implementation always threw a RemoteException, which would have been a consistent result for any invocation of the method. The modified implementation has removed this blanket exception and replaced it with an actual operation that registers for notifications, which would not throw an exception unless an error occurs during the operation. Because the exception handling behavior has changedâ€”going from always throwing an exception to potentially not throwing anyâ€”the type of compatibility issue is 2 (CI caused by potential different exception handlings)."
74,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,32,33,,,,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                InputMethodServiceInternal target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1, (boolean) args.arg3, msg.arg2);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) ((SomeArgs) args.arg2).arg1;
                final ImeOnBackInvokedDispatcher imeDispatcher = (ImeOnBackInvokedDispatcher) ((SomeArgs) args.arg2).arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                final boolean restarting = args.argi5 == 1;
                @InputMethodNavButtonFlags final int navButtonFlags = args.argi6;
                final InputConnection ic = inputContext != null ? new RemoteInputConnection(mTarget, inputContext, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, restarting, startInputToken, navButtonFlags, imeDispatcher);
                args.recycle();
                return;
            }
        case DO_ON_NAV_BUTTON_FLAGS_CHANGED:
            inputMethod.onNavButtonFlagsChanged(msg.arg1);
            return;
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
                args.recycle();
                return;
            }
        case DO_CAN_START_STYLUS_HANDWRITING:
            {
                inputMethod.canStartStylusHandwriting(msg.arg1);
                return;
            }
        case DO_START_STYLUS_HANDWRITING:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.startStylusHandwriting(msg.arg1, (InputChannel) args.arg1, (List<MotionEvent>) args.arg2);
                args.recycle();
                return;
            }
        case DO_INIT_INK_WINDOW:
            {
                inputMethod.initInkWindow();
                return;
            }
        case DO_FINISH_STYLUS_HANDWRITING:
            {
                inputMethod.finishStylusHandwriting();
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,0,"[@MainThread, @Override]","[@MainThread, @Override]",0,,,,,,,,,,
75,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,32,33,,,,"{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mViewsCreated="" + mViewsCreated + "" mDecorViewVisible="" + mDecorViewVisible + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService#showWindow"", this, null);
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showWindow"");
    mDecorViewWasVisible = mDecorViewVisible;
    mInShowWindow = true;
    final int previousImeWindowStatus = (mDecorViewVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? (!mWindowVisible ? IME_INVISIBLE : IME_VISIBLE) : 0);
    startViews(prepareWindow(showInput));
    final int nextImeWindowStatus = mapToImeWindowStatus();
    if (previousImeWindowStatus != nextImeWindowStatus) {
        setImeWindowStatus(nextImeWindowStatus, mBackDisposition);
    }
    // compute visibility
    onWindowShown();
    mWindowVisible = true;
    // When IME is not pre-rendered, this will actually show the IME.
    if ((previousImeWindowStatus & IME_ACTIVE) == 0) {
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
    }
    mDecorViewWasVisible = true;
    mInShowWindow = false;
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}","{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mViewsCreated="" + mViewsCreated + "" mDecorViewVisible="" + mDecorViewVisible + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService#showWindow"", mDumper, null);
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showWindow"");
    mDecorViewWasVisible = mDecorViewVisible;
    mInShowWindow = true;
    final int previousImeWindowStatus = (mDecorViewVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? (!mWindowVisible ? IME_INVISIBLE : IME_VISIBLE) : 0);
    startViews(prepareWindow(showInput));
    final int nextImeWindowStatus = mapToImeWindowStatus();
    if (previousImeWindowStatus != nextImeWindowStatus) {
        setImeWindowStatus(nextImeWindowStatus, mBackDisposition);
    }
    mNavigationBarController.onWindowShown();
    // compute visibility
    onWindowShown();
    mWindowVisible = true;
    // request draw for the IME surface.
    if (DEBUG)
        Log.v(TAG, ""showWindow: draw decorView!"");
    mWindow.show();
    mDecorViewWasVisible = true;
    applyVisibilityInInsetsConsumerIfNecessary(true);
    cancelImeSurfaceRemoval();
    mInShowWindow = false;
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    registerCompatOnBackInvokedCallback();
}",1,,,0,,,0,,,,,,,"3,4",0,"The early implementation has the statement ImeTracing.getInstance().triggerServiceDump(""InputMethodService#showWindow"", this, null); which passed 'this' as parameter, while the late implementation changes the parameter to mDumper in the corresponding statement. Additionally, in the late version, three new method calls are introduced: mNavigationBarController.onWindowShown(), applyVisibilityInInsetsConsumerIfNecessary(true), cancelImeSurfaceRemoval(), and registerCompatOnBackInvokedCallback(). Thus, the code changes include both control dependency (3) and other statement changes (4).","There are no new return statements introduced, nor is there any change in the type of returned value or exceptions thrown; the method's contract regarding its return type remains the same. The new calls and changes in method parameters alone are insufficient to classify as a potential Compatibility Issue unless these new method calls would lead to a change in the behavior that affects the return value or thrown exceptions. However, based on the given method implementation, it seems that these changes are internal to the method logic and their impact is only on the internal state management and UI handling which do not translate into a return value change or new exception being thrown as the method signature indicates a void return type. Therefore, the potential Compatibility Issue is 0 (No Compatibility Issue)."
76,"<android.view.accessibility.AccessibilityNodeInfo.CollectionInfo: CollectionInfo obtain(int,int,boolean,int)>",32,33,,,,"{
    final CollectionInfo info = sPool.acquire();
    if (info == null) {
        return new CollectionInfo(rowCount, columnCount, hierarchical, selectionMode);
    }
    info.mRowCount = rowCount;
    info.mColumnCount = columnCount;
    info.mHierarchical = hierarchical;
    info.mSelectionMode = selectionMode;
    return info;
}","{
    return new CollectionInfo(rowCount, columnCount, hierarchical, selectionMode);
}",1,"/**
 * Obtains a pooled instance.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionInfo#CollectionInfo(int, int,
 * boolean, int)} instead.
 *
 * @param rowCount The number of rows.
 * @param columnCount The number of columns.
 * @param hierarchical Whether the collection is hierarchical.
 * @param selectionMode The collection's selection mode, one of:
 * <ul>
 * <li>{@link #SELECTION_MODE_NONE}
 * <li>{@link #SELECTION_MODE_SINGLE}
 * <li>{@link #SELECTION_MODE_MULTIPLE}
 * </ul>
 */
","/**
 * Obtains a pooled instance.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionInfo#CollectionInfo(int, int,
 * boolean, int)} instead.
 *
 * @param rowCount The number of rows.
 * @param columnCount The number of columns.
 * @param hierarchical Whether the collection is hierarchical.
 * @param selectionMode The collection's selection mode, one of:
 * <ul>
 * <li>{@link #SELECTION_MODE_NONE}
 * <li>{@link #SELECTION_MODE_SINGLE}
 * <li>{@link #SELECTION_MODE_MULTIPLE}
 * </ul>
 */
",1,,,0,,,,,,,"1,4",1,"The code change includes deleting statements related to acquiring and reusing objects from a pool and always creating a new CollectionInfo object, so the change types are 1,4.","The change in the approach from reusing pooled objects to always creating a new object will change the return value because previously returned objects might have been reused, and now a freshly created object is returned every time. Therefore, the type of CI is 1."
77,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,32,33,,,,"{
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""%d: %s (%f,%f)"", event.getSequenceNumber(), MotionEvent.actionToString(event.getActionMasked()), event.getX(), event.getY());
    }
    final int action = event.getActionMasked();
    if (mEditor != null) {
        if (!isFromPrimePointer(event, false)) {
            return true;
        }
        mEditor.onTouchEvent(event);
        if (mEditor.mInsertionPointCursorController != null && mEditor.mInsertionPointCursorController.isCursorBeingModified()) {
            return true;
        }
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""superResult=%s"", superResult);
    }
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (DEBUG_CURSOR) {
            logCursor(""onTouchEvent"", ""release after long press detected"");
        }
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = getInputMethodManager();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""%d: %s (%f,%f)"", event.getSequenceNumber(), MotionEvent.actionToString(event.getActionMasked()), event.getX(), event.getY());
    }
    final int action = event.getActionMasked();
    if (mEditor != null) {
        if (!isFromPrimePointer(event, false)) {
            return true;
        }
        mEditor.onTouchEvent(event);
        if (mEditor.mInsertionPointCursorController != null && mEditor.mInsertionPointCursorController.isCursorBeingModified()) {
            return true;
        }
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""superResult=%s"", superResult);
    }
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (DEBUG_CURSOR) {
            logCursor(""onTouchEvent"", ""release after long press detected"");
        }
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = getInputMethodManager();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null && !showAutofillDialog()) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
79,"<android.os.PowerManager: void addThermalStatusListener(Executor,OnThermalStatusChangedListener)>",32,33,,,,"{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    Preconditions.checkNotNull(executor, ""executor cannot be null"");
    Preconditions.checkArgument(!mListenerMap.containsKey(listener), ""Listener already registered: %s"", listener);
    IThermalStatusListener internalListener = new IThermalStatusListener.Stub() {

        @Override
        public void onStatusChange(int status) {
            final long token = Binder.clearCallingIdentity();
            try {
                executor.execute(() -> {
                    listener.onThermalStatusChanged(status);
                });
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    };
    try {
        if (mThermalService.registerThermalStatusListener(internalListener)) {
            mListenerMap.put(listener, internalListener);
        } else {
            throw new RuntimeException(""Listener failed to set"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(listener, ""listener cannot be null"");
    Objects.requireNonNull(executor, ""executor cannot be null"");
    Preconditions.checkArgument(!mListenerMap.containsKey(listener), ""Listener already registered: %s"", listener);
    IThermalStatusListener internalListener = new IThermalStatusListener.Stub() {

        @Override
        public void onStatusChange(int status) {
            final long token = Binder.clearCallingIdentity();
            try {
                executor.execute(() -> listener.onThermalStatusChanged(status));
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    };
    try {
        if (mThermalService.registerThermalStatusListener(internalListener)) {
            mListenerMap.put(listener, internalListener);
        } else {
            throw new RuntimeException(""Listener failed to set"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * This function adds a listener for thermal status change.
 *
 * @param executor {@link Executor} to handle listener callback.
 * @param listener listener to be added.
 */
","/**
 * This function adds a listener for thermal status change.
 *
 * @param executor {@link Executor} to handle listener callback.
 * @param listener listener to be added.
 */
",0,,,0,,,,,,,4,0,"The code change consists of replacing `Preconditions.checkNotNull` with `Objects.requireNonNull`. Additionally, the lambda expression's brackets have been removed for a single statement, which does not affect the behavior.","There is no Compatibility Issue since both `Preconditions.checkNotNull` and `Objects.requireNonNull` serve the same purpose of checking for null and throwing a NullPointerException if null is encountered. The removal of brackets in the lambda expression does not alter the execution flow or behavior, so it does not lead to any change in return values or exceptions thrown."
80,"<android.util.apk.ZipUtils: Pair<ByteBuffer, Long> findZipEndOfCentralDirectoryRecord(RandomAccessFile)>",32,33,,,,"{
    // ZIP End of Central Directory (EOCD) record is located at the very end of the ZIP archive.
    // The record can be identified by its 4-byte signature/magic which is located at the very
    // beginning of the record. A complication is that the record is variable-length because of
    // the comment field.
    // The algorithm for locating the ZIP EOCD record is as follows. We search backwards from
    // end of the buffer for the EOCD record signature. Whenever we find a signature, we check
    // the candidate record's comment length is such that the remainder of the record takes up
    // exactly the remaining bytes in the buffer. The search is bounded because the maximum
    // size of the comment field is 65535 bytes because the field is an unsigned 16-bit number.
    long fileSize = zip.length();
    if (fileSize < ZIP_EOCD_REC_MIN_SIZE) {
        return null;
    }
    // Optimization: 99.99% of APKs have a zero-length comment field in the EoCD record and thus
    // the EoCD record offset is known in advance. Try that offset first to avoid unnecessarily
    // reading more data.
    Pair<ByteBuffer, Long> result = findZipEndOfCentralDirectoryRecord(zip, 0);
    if (result != null) {
        return result;
    }
    // the comment length field is an unsigned 16-bit number.
    return findZipEndOfCentralDirectoryRecord(zip, UINT16_MAX_VALUE);
}","{
    // ZIP End of Central Directory (EOCD) record is located at the very end of the ZIP archive.
    // The record can be identified by its 4-byte signature/magic which is located at the very
    // beginning of the record. A complication is that the record is variable-length because of
    // the comment field.
    // The algorithm for locating the ZIP EOCD record is as follows. We search backwards from
    // end of the buffer for the EOCD record signature. Whenever we find a signature, we check
    // the candidate record's comment length is such that the remainder of the record takes up
    // exactly the remaining bytes in the buffer. The search is bounded because the maximum
    // size of the comment field is 65535 bytes because the field is an unsigned 16-bit number.
    // TODO(b/193592496) RandomAccessFile#length
    long fileSize = zip.getChannel().size();
    if (fileSize < ZIP_EOCD_REC_MIN_SIZE) {
        return null;
    }
    // Optimization: 99.99% of APKs have a zero-length comment field in the EoCD record and thus
    // the EoCD record offset is known in advance. Try that offset first to avoid unnecessarily
    // reading more data.
    Pair<ByteBuffer, Long> result = findZipEndOfCentralDirectoryRecord(zip, 0);
    if (result != null) {
        return result;
    }
    // the comment length field is an unsigned 16-bit number.
    return findZipEndOfCentralDirectoryRecord(zip, UINT16_MAX_VALUE);
}",1,"/**
 * Returns the ZIP End of Central Directory record of the provided ZIP file.
 *
 * @return contents of the ZIP End of Central Directory record and the record's offset in the
 * file or {@code null} if the file does not contain the record.
 *
 * @throws IOException if an I/O error occurs while reading the file.
 */
","/**
 * Returns the ZIP End of Central Directory record of the provided ZIP file.
 *
 * @return contents of the ZIP End of Central Directory record and the record's offset in the
 * file or {@code null} if the file does not contain the record.
 *
 * @throws IOException if an I/O error occurs while reading the file.
 */
",0,,,0,,,,,,,5,0,"The method used to retrieve the file size has changed from `zip.length()` to `zip.getChannel().size()`. Since this is a change in the method being called to achieve the same outcome (file size), it falls under the category of a dependent API change.","The change should not introduce any compatibility issues, since it is an internal call to obtain the file size and the surrounding logic remains the same. The behavior of the API will remain consistent as long as the new method `zip.getChannel().size()` returns the correct file size, which is the expected behavior. Therefore, there is no compatibility issue."
81,<android.net.vcn.VcnGatewayConnectionConfig.Builder: VcnGatewayConnectionConfig build()>,32,33,,,,"{
    return new VcnGatewayConnectionConfig(mGatewayConnectionName, mTunnelConnectionParams, mExposedCapabilities, mRetryIntervalsMs, mMaxMtu);
}","{
    return new VcnGatewayConnectionConfig(mGatewayConnectionName, mTunnelConnectionParams, mExposedCapabilities, mUnderlyingNetworkTemplates, mRetryIntervalsMs, mMaxMtu);
}",1,"/**
 * Builds and validates the VcnGatewayConnectionConfig.
 *
 * @return an immutable VcnGatewayConnectionConfig instance
 */
","/**
 * Builds and validates the VcnGatewayConnectionConfig.
 *
 * @return an immutable VcnGatewayConnectionConfig instance
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The constructor for VcnGatewayConnectionConfig has an additional parameter in the late version (mUnderlyingNetworkTemplates), impacting the number of parameters passed to the constructor. So the code change type is 1,5.","Since a new parameter is added to the constructor, it could potentially lead to a different return value depending on the internal implementation of VcnGatewayConnectionConfig, thus the CI type is 1."
83,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",32,33,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The parameter order in the method call broadcastIntentWithFeature() has changed where excludedPermissions argument has been changed with null and the argument after that has been inserted as AppOpsManager.OP_NONE. This is a change in the argument list but the same values are used, so it's categorized as type 4 (Other statement changed).","No Compatibility Issue is noted because the reordered parameters are effectively passing the same values, implying that there is no change in behaviour or functionality of the API method, despite the change in the sequence of arguments. Thus, the method will behave identically in terms of exceptions thrown and return values."
84,<android.app.AppOpsManager.AttributedOpEntry.LongSparseArrayParceling: LongSparseArray<NoteOpEvent> unparcel(Parcel)>,32,33,,,,"{
    int numEntries = source.readInt();
    if (numEntries == -1) {
        return null;
    }
    LongSparseArray<NoteOpEvent> array = new LongSparseArray<>(numEntries);
    for (int i = 0; i < numEntries; i++) {
        array.put(source.readLong(), source.readParcelable(null));
    }
    return array;
}","{
    int numEntries = source.readInt();
    if (numEntries == -1) {
        return null;
    }
    LongSparseArray<NoteOpEvent> array = new LongSparseArray<>(numEntries);
    for (int i = 0; i < numEntries; i++) {
        array.put(source.readLong(), source.readParcelable(null, android.app.AppOpsManager.NoteOpEvent.class));
    }
    return array;
}",1,,,0,"[@Override, @Nullable]","[@Override, @Nullable]",0,,,,,,,5,0,"The change includes the addition of a specific class loader for the readParcelable method. The parameter within the readParcelable method has been modified from 'null' to 'android.app.AppOpsManager.NoteOpEvent.class', which is indicative of a dependent API change, coded as 5.","There is no Compatibility Issue here, as the added class loader in readParcelable does not alter the behavior of 'unparcel' in a way that would lead to a different return value or type or a different exception handling. The unparcel method is designed to read objects of type 'NoteOpEvent' from the Parcel, and the specificity introduced by providing the class loader just enforces the type safety of the operation. This change should not affect existing clients assuming they are correctly sending 'NoteOpEvent' objects for unparcelling. Thus, there is no change in the externally observable behavior of the API."
85,<android.content.pm.ShortcutManager: void removeLongLivedShortcuts(List<String>)>,32,33,,,,"{
    try {
        getFutureOrThrow(mService.removeLongLivedShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.removeLongLivedShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Delete long lived shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Delete long lived shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,,,0,,,,,,,4,0,"The early version wraps the call to `mService.removeLongLivedShortcuts` with `getFutureOrThrow`, while the late version makes a direct call to `mService.removeLongLivedShortcuts` without that wrapping. So the change is an Other statement changed, which is type 4.","There is no difference in behavior in terms of the API contract from an external perspective; the try block and the catch block have remained the same and will handle exceptions in the same way. It is an internal implementation detail that does not affect the method's external behavior. Therefore, there is No Compatibility Issue, which is 0."
86,<android.view.accessibility.AccessibilityRecord: AccessibilityRecord obtain()>,32,33,,,,"{
    synchronized (sPoolLock) {
        if (sPool != null) {
            AccessibilityRecord record = sPool;
            sPool = sPool.mNext;
            sPoolSize--;
            record.mNext = null;
            record.mIsInPool = false;
            return record;
        }
        return new AccessibilityRecord();
    }
}","{
    return new AccessibilityRecord();
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityRecord()} instead.
 *
 * @return An instance.
 */
","/**
 * Instantiates a new record.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityRecord()} instead.
 * @return An instance.
 */
",1,,"[@Deprecated, @NonNull]",1,,,,,,,"1,4",1,"The method body has been completely altered. The early version used a pool to manage instances, while the late version always creates a new instance of AccessibilityRecord. The synchronized block and all operations on 'sPool' have been removed. So, the change type is 1 (return statement changed) and 4 (other statement changed, specifically the removal of the synchronized block and instance pooling logic).","Since the late version of the method does not return a potentially reused object from a pool, but always returns a new instance, this is a fundamental change in the behavior. Clients expecting a possible pooled object might behave differently when they always receive a new instance. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
89,<android.net.Ikev2VpnProfile: int hashCode()>,32,33,,,,"{
    return Objects.hash(mType, mServerAddr, mUserIdentity, Arrays.hashCode(mPresharedKey), mServerRootCaCert, mUsername, mPassword, mRsaPrivateKey, mUserCert, mProxyInfo, mAllowedAlgorithms, mIsBypassable, mIsMetered, mMaxMtu, mIsRestrictedToTestNetworks);
}","{
    return Objects.hash(mType, mServerAddr, mUserIdentity, Arrays.hashCode(mPresharedKey), mServerRootCaCert, mUsername, mPassword, mRsaPrivateKey, mUserCert, mProxyInfo, mAllowedAlgorithms, mIsBypassable, mIsMetered, mMaxMtu, mIsRestrictedToTestNetworks, mExcludeLocalRoutes, mRequiresInternetValidation, mIkeTunConnParams);
}",1,,,0,[@Override],[@Override],0,,,,,,,1,1,"The hashCode method in the late version takes additional parameters (mExcludeLocalRoutes, mRequiresInternetValidation, mIkeTunConnParams) compared to the early version. Hence, the change type is 1.","The changed hashCode method will result in different hash codes for objects of this class, which may affect collections (like HashMap, HashSet, etc.) that rely on the hash code, thus potentially leading to different behavior. Therefore, the CI type is 1."
94,"<android.view.contentcapture.ContentCaptureSession: AutofillId newAutofillId(AutofillId,long)>",32,33,,,,"{
    Preconditions.checkNotNull(hostId);
    Preconditions.checkArgument(hostId.isNonVirtual(), ""hostId cannot be virtual: %s"", hostId);
    return new AutofillId(hostId, virtualChildId, mId);
}","{
    Objects.requireNonNull(hostId);
    Preconditions.checkArgument(hostId.isNonVirtual(), ""hostId cannot be virtual: %s"", hostId);
    return new AutofillId(hostId, virtualChildId, mId);
}",1,"/**
 * Creates a new {@link AutofillId} for a virtual child, so it can be used to uniquely identify
 * the children in the session.
 *
 * @param hostId id of the non-virtual view hosting the virtual view hierarchy (it can be
 * obtained by calling {@link ViewStructure#getAutofillId()}).
 * @param virtualChildId id of the virtual child, relative to the parent.
 *
 * @return if for the virtual child
 *
 * @throws IllegalArgumentException if the {@code parentId} is a virtual child id.
 */
","/**
 * Creates a new {@link AutofillId} for a virtual child, so it can be used to uniquely identify
 * the children in the session.
 *
 * @param hostId id of the non-virtual view hosting the virtual view hierarchy (it can be
 * obtained by calling {@link ViewStructure#getAutofillId()}).
 * @param virtualChildId id of the virtual child, relative to the parent.
 *
 * @return if for the virtual child
 *
 * @throws IllegalArgumentException if the {@code parentId} is a virtual child id.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,"The change happened in the non-virtual check of the 'hostId' parameter, where 'Preconditions.checkNotNull(hostId)' has been replaced with 'Objects.requireNonNull(hostId)'. This is a change in the dependent API used to check the precondition, thus the code change type is 5.","There is no Compatibility Issue, as the behavior of 'Preconditions.checkNotNull' and 'Objects.requireNonNull' is functionally equivalent in terms of throwing a NullPointerException when 'hostId' is null. This change does not alter the API's intended behavior and does not affect the value or type returned or throw a new exception, so the CI type is 0."
95,<android.net.Ikev2VpnProfile: String getUserIdentity()>,32,33,,,,"{
    return mUserIdentity;
}","{
    if (mIkeTunConnParams == null)
        return mUserIdentity;
    final IkeSessionParams ikeSessionParams = mIkeTunConnParams.getIkeSessionParams();
    return getUserIdentityFromIkeSession(ikeSessionParams);
}",1,"/**
 * Retrieves the user identity.
 */
","/**
 * Retrieves the user identity.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,3,5",1,"The late implementation checks for mIkeTunConnParams being null and includes a call to a new method (getUserIdentityFromIkeSession()) based on the result of mIkeTunConnParams.getIkeSessionParams(). Since the flow of execution is altered and different methods are now involved in obtaining the user identity which can potentially have a return value different from the earlier version, the changes classify as 1 (Return statement changed), 3 (Control dependency change), and 5 (Dependent API changed).","The introduction of a new dependent API (mIkeTunConnParams.getIkeSessionParams() and getUserIdentityFromIkeSession()) can result in the method returning a different value compared to the previous implementation which directly returned mUserIdentity. Therefore, there is a Compatibility Issue due to potentially different return values, and the CI type is 1."
96,<android.os.UidBatteryConsumer.Builder: UidBatteryConsumer build()>,32,33,,,,"{
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = null;
    }
    return new UidBatteryConsumer(this);
}","{
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = null;
    }
    if (mPackageWithHighestDrain != null) {
        mData.putString(COLUMN_INDEX_PACKAGE_WITH_HIGHEST_DRAIN, mPackageWithHighestDrain);
    }
    return new UidBatteryConsumer(this);
}",1,"/**
 * Creates a read-only object out of the Builder values.
 */
","/**
 * Creates a read-only object out of the Builder values.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"3,4",0,"A new if condition and a new statement inside this condition have been introduced in the late implementation. There is a change in the control dependency because of the newly added if block, and this is also another statement change inside the if blockâ€”hence the changes are categorized as 3,4.","The additional if statement and the statement within only affects a field in the UidBatteryConsumer.Builder ('mPackageWithHighestDrain'), not the outcome of the 'build()' method. The end result is still the creation of a new UidBatteryConsumer instance based on the state of 'this' UidBatteryConsumer.Builder; thus, it does not cause any Compatibility Issue as the returned object type and construction process remain unchanged. Thus, the CI type is 0."
97,<android.view.View: void setSystemGestureExclusionRects(List<Rect>)>,32,33,,,,"{
    if (rects.isEmpty() && mListenerInfo == null)
        return;
    final ListenerInfo info = getListenerInfo();
    if (info.mSystemGestureExclusionRects != null) {
        info.mSystemGestureExclusionRects.clear();
        info.mSystemGestureExclusionRects.addAll(rects);
    } else {
        info.mSystemGestureExclusionRects = new ArrayList<>(rects);
    }
    if (rects.isEmpty()) {
        if (info.mPositionUpdateListener != null) {
            mRenderNode.removePositionUpdateListener(info.mPositionUpdateListener);
        }
    } else {
        if (info.mPositionUpdateListener == null) {
            info.mPositionUpdateListener = new RenderNode.PositionUpdateListener() {

                @Override
                public void positionChanged(long n, int l, int t, int r, int b) {
                    postUpdateSystemGestureExclusionRects();
                }

                @Override
                public void positionLost(long frameNumber) {
                    postUpdateSystemGestureExclusionRects();
                }
            };
            mRenderNode.addPositionUpdateListener(info.mPositionUpdateListener);
        }
    }
    postUpdateSystemGestureExclusionRects();
}","{
    if (rects.isEmpty() && mListenerInfo == null)
        return;
    final ListenerInfo info = getListenerInfo();
    if (info.mSystemGestureExclusionRects != null) {
        info.mSystemGestureExclusionRects.clear();
        info.mSystemGestureExclusionRects.addAll(rects);
    } else {
        info.mSystemGestureExclusionRects = new ArrayList<>(rects);
    }
    updatePositionUpdateListener();
    postUpdate(this::updateSystemGestureExclusionRects);
}",1,"/**
 * Sets a list of areas within this view's post-layout coordinate space where the system
 * should not intercept touch or other pointing device gestures. <em>This method should
 * be called by {@link #onLayout(boolean, int, int, int, int)} or {@link #onDraw(Canvas)}.</em>
 *
 * <p>Use this to tell the system which specific sub-areas of a view need to receive gesture
 * input in order to function correctly in the presence of global system gestures that may
 * conflict. For example, if the system wishes to capture swipe-in-from-screen-edge gestures
 * to provide system-level navigation functionality, a view such as a navigation drawer
 * container can mark the left (or starting) edge of itself as requiring gesture capture
 * priority using this API. The system may then choose to relax its own gesture recognition
 * to allow the app to consume the user's gesture. It is not necessary for an app to register
 * exclusion rects for broadly spanning regions such as the entirety of a
 * <code>ScrollView</code> or for simple press and release click targets such as
 * <code>Button</code>. Mark an exclusion rect when interacting with a view requires
 * a precision touch gesture in a small area in either the X or Y dimension, such as
 * an edge swipe or dragging a <code>SeekBar</code> thumb.</p>
 *
 * <p>Note: the system will put a limit of <code>200dp</code> on the vertical extent of the
 * exclusions it takes into account. The limit does not apply while the navigation
 * bar is {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY stickily} hidden, nor to the
 * {@link android.inputmethodservice.InputMethodService input method} and
 * {@link Intent#CATEGORY_HOME home activity}.
 * </p>
 *
 * @param rects A list of precision gesture regions that this view needs to function correctly
 */
","/**
 * Sets a list of areas within this view's post-layout coordinate space where the system
 * should not intercept touch or other pointing device gestures. <em>This method should
 * be called by {@link #onLayout(boolean, int, int, int, int)} or {@link #onDraw(Canvas)}.</em>
 *
 * <p>Use this to tell the system which specific sub-areas of a view need to receive gesture
 * input in order to function correctly in the presence of global system gestures that may
 * conflict. For example, if the system wishes to capture swipe-in-from-screen-edge gestures
 * to provide system-level navigation functionality, a view such as a navigation drawer
 * container can mark the left (or starting) edge of itself as requiring gesture capture
 * priority using this API. The system may then choose to relax its own gesture recognition
 * to allow the app to consume the user's gesture. It is not necessary for an app to register
 * exclusion rects for broadly spanning regions such as the entirety of a
 * <code>ScrollView</code> or for simple press and release click targets such as
 * <code>Button</code>. Mark an exclusion rect when interacting with a view requires
 * a precision touch gesture in a small area in either the X or Y dimension, such as
 * an edge swipe or dragging a <code>SeekBar</code> thumb.</p>
 *
 * <p>Note: the system will put a limit of <code>200dp</code> on the vertical extent of the
 * exclusions it takes into account. The limit does not apply while the navigation
 * bar is {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY stickily} hidden, nor to the
 * {@link android.inputmethodservice.InputMethodService input method} and
 * {@link Intent#CATEGORY_HOME home activity}.
 * </p>
 *
 * @param rects A list of precision gesture regions that this view needs to function correctly
 */
",0,,,0,,,,,,,"3,4",0,"The handling of position update listener and the postUpdateSystemGestureExclusionRects() call have been replaced with updatePositionUpdateListener() and postUpdate(this::updateSystemGestureExclusionRects); changes in method calls and the structure of control dependency, so the change types are 3,4.","Even though there are changes in the method implementation, they seem to be refactoring changes intended to improve code structure or readability. The functionality and the public contract of the method seem to be preserved since the logic for when to update the system gesture exclusion rects is maintained. Therefore, no compatibility issue is detected; the pred_CI is 0."
98,<android.app.ActivityThread.H: void handleMessage(Message)>,32,33,,,,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            }
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            }
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            mConfigurationController.handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case DUMP_GFXINFO:
            handleDumpGfxInfo((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String message = (String) args.arg1;
                Bundle extras = (Bundle) args.arg2;
                args.recycle();
                throwRemoteServiceException(message, msg.arg1, extras);
                break;
            }
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
        case ATTACH_STARTUP_AGENTS:
            handleAttachStartupAgents((String) msg.obj);
            break;
        case UPDATE_UI_TRANSLATION_STATE:
            final SomeArgs args = (SomeArgs) msg.obj;
            updateUiTranslationState((IBinder) args.arg1, (int) args.arg2, (TranslationSpec) args.arg3, (TranslationSpec) args.arg4, (List<AutofillId>) args.arg5, (UiTranslationSpec) args.arg6);
            break;
        case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
            handleSetContentCaptureOptionsCallback((String) msg.obj);
            break;
        case INSTRUMENT_WITHOUT_RESTART:
            handleInstrumentWithoutRestart((AppBindData) msg.obj);
            break;
        case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
            handleFinishInstrumentationWithoutRestart();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                ReceiverData rec = (ReceiverData) msg.obj;
                if (rec.intent != null) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp: "" + rec.intent.getAction());
                } else {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
                }
            }
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            }
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            }
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            mConfigurationController.handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case DUMP_GFXINFO:
            handleDumpGfxInfo((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String message = (String) args.arg1;
                Bundle extras = (Bundle) args.arg2;
                args.recycle();
                throwRemoteServiceException(message, msg.arg1, extras);
                break;
            }
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_RESOURCES:
            handleDumpResources((DumpResourcesData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
        case ATTACH_STARTUP_AGENTS:
            handleAttachStartupAgents((String) msg.obj);
            break;
        case UPDATE_UI_TRANSLATION_STATE:
            final SomeArgs args = (SomeArgs) msg.obj;
            updateUiTranslationState((IBinder) args.arg1, (int) args.arg2, (TranslationSpec) args.arg3, (TranslationSpec) args.arg4, (List<AutofillId>) args.arg5, (UiTranslationSpec) args.arg6);
            break;
        case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
            handleSetContentCaptureOptionsCallback((String) msg.obj);
            break;
        case INSTRUMENT_WITHOUT_RESTART:
            handleInstrumentWithoutRestart((AppBindData) msg.obj);
            break;
        case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
            handleFinishInstrumentationWithoutRestart();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,0,,,0,,,,,,,,,,
99,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,32,33,,,,"{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (getResources().getConfiguration().orientation == ORIENTATION_PORTRAIT) {
            outAttrs.internalImeOptions |= EditorInfo.IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT;
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        outAttrs.targetInputMethodUser = mTextOperationUser;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            outAttrs.setInitialSurroundingText(mText);
            outAttrs.contentMimeTypes = getReceiveContentMimeTypes();
            return ic;
        }
    }
    return null;
}","{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (hasEditorInFocusSearchDirection(FOCUS_DOWN)) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (hasEditorInFocusSearchDirection(FOCUS_UP)) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (getResources().getConfiguration().orientation == ORIENTATION_PORTRAIT) {
            outAttrs.internalImeOptions |= EditorInfo.IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT;
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        outAttrs.targetInputMethodUser = mTextOperationUser;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            outAttrs.setInitialSurroundingText(mText);
            outAttrs.contentMimeTypes = getReceiveContentMimeTypes();
            return ic;
        }
    }
    return null;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
100,<android.widget.EditText: Editable getText()>,32,33,,,,"{
    CharSequence text = super.getText();
    // This can only happen during construction.
    if (text == null) {
        return null;
    }
    if (text instanceof Editable) {
        return (Editable) super.getText();
    }
    super.setText(text, BufferType.EDITABLE);
    return (Editable) super.getText();
}","{
    CharSequence text = super.getText();
    // This can only happen during construction.
    if (text == null) {
        return null;
    }
    if (text instanceof Editable) {
        return (Editable) text;
    }
    super.setText(text, BufferType.EDITABLE);
    return (Editable) super.getText();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only code change is within the conditional check `if (text instanceof Editable)`; it changed from returning `(Editable) super.getText()` to returning `(Editable) text`. This change avoids an additional method call but ultimately does not alter the return value because `text` is already the result of `super.getText()`. Therefore, the change type is 4.","There's no Compatibility Issue because the return value remains the same. It is still an instance of `Editable`, sourced from the variable `text` which holds the value of `super.getText()`. Thus, even though the method call to `super.getText()` is avoided in the late version, the overall behavior of the method and the returned value have not changed."
101,"<android.view.contentcapture.ContentCaptureSession: void notifyViewTextChanged(AutofillId,CharSequence)>",32,33,,,,"{
    Preconditions.checkNotNull(id);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewTextChanged(id, text);
}","{
    Objects.requireNonNull(id);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewTextChanged(id, text);
}",1,"/**
 * Notifies the Intelligence Service that the value of a text node has been changed.
 *
 * @param id of the node.
 * @param text new text.
 */
","/**
 * Notifies the Intelligence Service that the value of a text node has been changed.
 *
 * @param id of the node.
 * @param text new text.
 */
",0,,,0,,,,,,,4,0,"The only change in the code is the method used for null checking of the 'id' parameter: from Preconditions.checkNotNull(id) to Objects.requireNonNull(id). This is a simple substitution of one null check implementation for another and should not affect behavior, thus it is classified under other statements changed.","Since both methods essentially perform the same function and the change in null checking mechanism would not lead to the API behaving differently, there is no compatibility issue in this case."
102,"<android.app.Dialog: boolean onKeyUp(int,KeyEvent)>",32,33,,,,"{
    if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE) && event.isTracking() && !event.isCanceled()) {
        onBackPressed();
        return true;
    }
    return false;
}","{
    if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE) && event.isTracking() && !event.isCanceled() && !WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {
        onBackPressed();
        return true;
    }
    return false;
}",1,"/**
 * A key was released.
 * <p>
 * Default implementation consumes {@link KeyEvent#KEYCODE_BACK KEYCODE_BACK}
 * and, as of {@link android.os.Build.VERSION_CODES#P P}, {@link KeyEvent#KEYCODE_ESCAPE
 * KEYCODE_ESCAPE} to close the dialog.
 *
 * @see #onKeyDown
 * @see android.view.KeyEvent
 */
","/**
 * A key was released.
 * <p>
 * Default implementation consumes {@link KeyEvent#KEYCODE_BACK KEYCODE_BACK}
 * and, as of {@link android.os.Build.VERSION_CODES#P P}, {@link KeyEvent#KEYCODE_ESCAPE
 * KEYCODE_ESCAPE} to close the dialog.
 *
 * @see #onKeyDown
 * @see android.view.KeyEvent
 */
",0,[@Override],[@Override],0,,,,,,,3,0,"The change is in the control dependency where a new condition `!WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)` is added to the `if` statement, so the code change type is 3.","The addition of the new condition to the existing `if` statement does not lead to a CI, because it is a more restrictive check and the return values remain the same (either `true` or `false`). The new condition is a preventive check that does not influence the returned value or introduce a new one, nor does it throw an exception. Therefore, it should not cause CI, so the CI type is 0."
103,"<android.view.accessibility.AccessibilityNodeInfo.CollectionInfo: CollectionInfo obtain(int,int,boolean)>",32,33,,,,"{
    return obtain(rowCount, columnCount, hierarchical, SELECTION_MODE_NONE);
}","{
    return new CollectionInfo(rowCount, columnCount, hierarchical, SELECTION_MODE_NONE);
}",1,"/**
 * Obtains a pooled instance.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionInfo#CollectionInfo(int, int,
 * boolean)} instead.
 *
 * @param rowCount The number of rows, or -1 if count is unknown.
 * @param columnCount The number of columns, or -1 if count is unknown.
 * @param hierarchical Whether the collection is hierarchical.
 */
","/**
 * Obtains a pooled instance.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionInfo#CollectionInfo(int, int,
 * boolean)} instead.
 *
 * @param rowCount The number of rows, or -1 if count is unknown.
 * @param columnCount The number of columns, or -1 if count is unknown.
 * @param hierarchical Whether the collection is hierarchical.
 */
",1,,,0,,,,,,,"1,5",1,"The method changed from calling obtain() with parameters to directly constructing a new CollectionInfo object. Because the implementation is calling a different method (a constructor instead of the obtain method), it's classified as 1,5.","The change in the method of creating the CollectionInfo object can lead to different return values. Even though the parameters passed are the same, the behavior might differ, for example, if the obtain method did additional processing before returning the object, which is not seen in the direct instantiation through 'new'. Therefore, this change could potentially cause the API to return a different value, which is a type 1 compatibility issue."
104,<android.view.contentcapture.ContentCaptureContext.Builder: Builder setExtras(Bundle)>,32,33,,,,"{
    mExtras = Preconditions.checkNotNull(extras);
    throwIfDestroyed();
    return this;
}","{
    mExtras = Objects.requireNonNull(extras);
    throwIfDestroyed();
    return this;
}",1,"/**
 * Sets extra options associated with this context.
 *
 * <p>It can be used to provide vendor-specific data that can be modified and examined.
 *
 * @param extras extra options.
 * @return this builder.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 */
","/**
 * Sets extra options associated with this context.
 *
 * <p>It can be used to provide vendor-specific data that can be modified and examined.
 *
 * @param extras extra options.
 * @return this builder.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,"The change is from using Preconditions.checkNotNull(extras) to Objects.requireNonNull(extras) which are both used to check for null objects and throw a NullPointerException if necessary. This is a change in a dependent API, so the code change type is 5.","There is no Compatibility Issue here because even though the method of null checking has changed, both will throw a NullPointerException for a null 'extras' argument and function the same from an API consumer's perspective. Hence, the behavior of the API remains consistent, and there are no changes that would affect the return type, value, or exception handling which could lead to a Compatibility Issue."
105,<android.net.Ikev2VpnProfile: String getUsername()>,32,33,,,,"{
    return mUsername;
}","{
    if (mIkeTunConnParams != null)
        return null;
    return mUsername;
}",1,"/**
 * Retrieves the username.
 *
 * <p>May be null if the profile is not using Username/Password authentication
 */
","/**
 * Retrieves the username.
 *
 * <p>May be null if the profile is not using Username/Password authentication, or the profile
 * is built from an {@link IkeTunnelConnectionParams}.
 */
",1,[@Nullable],[@Nullable],0,,,,,,,"1,3",1,"A new control dependency 'if' statement has been introduced which could lead to a different return value (null instead of mUsername), so the code change type is 1,3.","Due to the introduction of the 'if' statement, the method may return null in a scenario where it previously would not have, leading to a potential different return value. Therefore, the CI type is 1."
106,<android.view.ViewRootImpl.NativePreImeInputStage: int onProcess(QueuedInputEvent)>,32,33,,,,"{
    if (mInputQueue != null && q.mEvent instanceof KeyEvent) {
        mInputQueue.sendInputEvent(q.mEvent, q, true, this);
        return DEFER;
    }
    return FORWARD;
}","{
    if (q.mEvent instanceof KeyEvent) {
        final KeyEvent event = (KeyEvent) q.mEvent;
        // view tree or IME, and invoke the appropriate {@link OnBackInvokedCallback}.
        if (isBack(event) && mContext != null && WindowOnBackInvokedDispatcher.isOnBackInvokedCallbackEnabled(mContext)) {
            OnBackInvokedCallback topCallback = getOnBackInvokedDispatcher().getTopCallback();
            if (event.getAction() == KeyEvent.ACTION_UP) {
                if (topCallback != null) {
                    topCallback.onBackInvoked();
                    return FINISH_HANDLED;
                }
            } else {
                // Drop other actions such as {@link KeyEvent.ACTION_DOWN}.
                return FINISH_NOT_HANDLED;
            }
        }
    }
    if (mInputQueue != null && q.mEvent instanceof KeyEvent) {
        mInputQueue.sendInputEvent(q.mEvent, q, true, this);
        return DEFER;
    }
    return FORWARD;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"Control dependency has changed with the introduction of additional 'if' statements to check for conditions related to KeyEvent actions. The return statement has also changed, adding new return values 'FINISH_HANDLED' and 'FINISH_NOT_HANDLED', so the code change type is 1,3.","The changes in control structures and return statements will make the API potentially return different values ('FINISH_HANDLED', 'FINISH_NOT_HANDLED', or 'DEFER') than it would before (only 'DEFER' or 'FORWARD'), so the CI type is 1."
108,<android.os.Parcel: Serializable readSerializable()>,32,33,,,,"{
    return readSerializable(null);
}","{
    return readSerializableInternal(/* loader */
    null, /* clazz */
    null);
}",1,"/**
 * Read and return a new Serializable object from the parcel.
 * @return the Serializable object, or null if the Serializable name
 * wasn't found in the parcel.
 */
","/**
 * Read and return a new Serializable object from the parcel.
 * @return the Serializable object, or null if the Serializable name
 * wasn't found in the parcel.
 *
 * Unlike {@link #readSerializable(ClassLoader, Class)}, it uses the nearest valid class loader
 * up the execution stack to instantiate the Serializable object.
 *
 * @deprecated Use the type-safer version {@link #readSerializable(ClassLoader, Class)} starting
 * from Android {@link Build.VERSION_CODES#TIRAMISU}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,5,0,"The change is that the method readSerializable() is now calling a new overloaded version readSerializableInternal() with additional null parameters. This indicates a dependent API change, hence the code change type is 5. ","There is no Compatibility Issue caused by this change because the method signature for readSerializable() hasn't been altered and it's still returning a Serializable object. The internal implementation details have changed but if the new overloaded method readSerializableInternal() is supposed to function consistently with the previous behavior of readSerializable(), then there should be no change in behavior as seen by the client code. The annotation change to add @Deprecated would not cause a behavioral Compatibility Issue, it is more an indication of API lifecycle status."
109,<android.content.pm.ShortcutManager: void enableShortcuts(List<String>)>,32,33,,,,"{
    try {
        getFutureOrThrow(mService.enableShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.enableShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Re-enable pinned shortcuts that were previously disabled.  If the target shortcuts
 * are already enabled, this method does nothing.
 *
 * @throws IllegalArgumentException If trying to enable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Re-enable pinned shortcuts that were previously disabled.  If the target shortcuts
 * are already enabled, this method does nothing.
 *
 * @throws IllegalArgumentException If trying to enable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,,,0,,,,,,,4,0,"The method getFutureOrThrow is removed from the try block, meaning there's only a direct call to the mService.enableShortcuts method without wrapping the result, so the code change type is 4.","This change does not lead to a Compatibility Issue as the behavior exposed to the caller has not changed. The method is still throwing a RemoteException wrapped by rethrowFromSystemServer if it occurs, and there is no return statement in either version that can result in different values. Therefore, the change does not cause potential different return values or exception handlings. The method signature and its exception handling remain the same, just the internal call to the service is no longer wrapped by getFutureOrThrow, which doesn't affect the external behavior of the method."
110,<android.os.Parcel: HashMap readHashMap(ClassLoader)>,32,33,,,,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    HashMap m = new HashMap(N);
    readMapInternal(m, N, loader);
    return m;
}","{
    return readHashMapInternal(loader, /* clazzKey */
    null, /* clazzValue */
    null);
}",1,"/**
 * Please use {@link #readBundle(ClassLoader)} instead (whose data must have
 * been written with {@link #writeBundle}.  Read and return a new HashMap
 * object from the parcel at the current dataPosition(), using the given
 * class loader to load any enclosed Parcelables.  Returns null if
 * the previously written map object was null.
 */
","/**
 * Please use {@link #readBundle(ClassLoader)} instead (whose data must have
 * been written with {@link #writeBundle}.  Read and return a new HashMap
 * object from the parcel at the current dataPosition(), using the given
 * class loader to load any enclosed Parcelables.  Returns null if
 * the previously written map object was null.
 *
 * @deprecated Consider using {@link #readBundle(ClassLoader)} as stated above, in case this
 * method is still preferred use the type-safer version {@link #readHashMap(ClassLoader,
 * Class, Class)} starting from Android {@link Build.VERSION_CODES#TIRAMISU}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"1,5",1,"The implementation of the method has been completely changed to readHashMapInternal(loader, null, null) and a new method is being called, which indicates a change in the dependent API, so the change types are 1,5.","The method now calls a different internal method, which could potentially return a different value, hence there is a possibility for different return values or types and the CI type is 1."
111,<android.content.pm.PackageInstaller.SessionInfo: String getStagedSessionErrorMessage()>,32,33,,,,"{
    checkSessionIsStaged();
    return mStagedSessionErrorMessage;
}","{
    checkSessionIsStaged();
    return mSessionErrorMessage;
}",1,"/**
 * Text description of the error code returned by {@code getStagedSessionErrorCode}, or
 * empty string if no error was encountered.
 */
","/**
 * Text description of the error code returned by {@code getStagedSessionErrorCode}, or
 * empty string if no error was encountered.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The return value has changed from using the variable mStagedSessionErrorMessage to mSessionErrorMessage. We can also infer that the underlying data member that is being returned has changed, which reflects a change in the dependent API (the field accessed has been changed), so the change type is 1,5.","Since the returned member variable has been changed from mStagedSessionErrorMessage to mSessionErrorMessage, there is a potential for different string data being returned. This constitutes a change in the potential return value of the API, so the CI type is 1."
114,<android.service.dreams.DreamService: boolean dispatchTouchEvent(MotionEvent)>,32,33,,,,"{
    // but finish()es on any other kind of activity
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on touchEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}","{
    // but finish()es on any other kind of activity
    if (!mInteractive && event.getActionMasked() == MotionEvent.ACTION_UP) {
        if (mDebug)
            Slog.v(mTag, ""Waking up on touchEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,3,1,"The condition in the if statement has been extended with an additional check for the action type (event.getActionMasked() == MotionEvent.ACTION_UP), causing a control dependency change, so the code change type is 3.","With the added check for MotionEvent.ACTION_UP, the condition under which 'wakeUp()' is called and 'true' is returned has been narrowed down. This could potentially lead to a different behavior when the user interacts with the dream service. Thus, there is a possibility that the API will return different values in different cases compared to the previous version, which constitutes a CI type 1."
115,<android.os.UserManager: List<UserHandle> getUserProfiles()>,32,33,,,,"{
    int[] userIds = getProfileIds(UserHandle.myUserId(), true);
    List<UserHandle> result = new ArrayList<>(userIds.length);
    for (int userId : userIds) {
        result.add(UserHandle.of(userId));
    }
    return result;
}","{
    int[] userIds = getProfileIds(getContextUserIfAppropriate(), true);
    return convertUserIdsToUserHandles(userIds);
}",1,"/**
 * Returns a list of UserHandles for profiles associated with the user that the calling process
 * is running on, including the user itself.
 * <p>Note that this includes all profile types (not including Restricted profiles).
 *
 * @return A non-empty list of UserHandles associated with the calling user.
 */
","/**
 * Returns a list of UserHandles for profiles associated with the context user, including the
 * user itself.
 * <p>Note that this includes all profile types (not including Restricted profiles).
 *
 * @return A non-empty list of UserHandles associated with the context user.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCaller = { Manifest.permission.MANAGE_USERS, Manifest.permission.CREATE_USERS, Manifest.permission.QUERY_USERS })]",1,,,,,,,"1,5",0,"The way how the userIds are retrieved and the user handles are created has been changed. In the early implementation, the method `getProfileIds` with `UserHandle.myUserId()` is replaced with `getContextUserIfAppropriate()` in the late version, and also the loop to create the `UserHandle` objects is replaced by a method call to `convertUserIdsToUserHandles`. The code change type is 1,5 since the return value creation logic and a dependent API `getProfileIds` parameter have changed.","The changes should not result in a Compatibility Issue regarding return values because the method still returns a list of `UserHandle` objects that represent the same user profiles. The changed methods are internal methods used to acquire the necessary user profiles and handle conversion. The outcome is expected to be equivalent, i.e., a list of relevant user profiles as `UserHandle` objects, even though the process to obtain these has been altered. Therefore, there is no Compatibility Issue here, and the pred_CI is 0."
116,"<android.os.BatteryConsumer.BaseBuilder: T setConsumedPower(int,double,int)>",32,33,,,,"{
    mPowerComponentsBuilder.setConsumedPower(componentId, componentPower, powerModel);
    return (T) this;
}","{
    mPowerComponentsBuilder.setConsumedPower(getKey(componentId, PROCESS_STATE_UNSPECIFIED), componentPower, powerModel);
    return (T) this;
}",1,"/**
 * Sets the amount of drain attributed to the specified drain type, e.g. CPU, WiFi etc.
 *
 * @param componentId    The ID of the power component, e.g.
 * {@link BatteryConsumer#POWER_COMPONENT_CPU}.
 * @param componentPower Amount of consumed power in mAh.
 */
","/**
 * Sets the amount of drain attributed to the specified drain type, e.g. CPU, WiFi etc.
 *
 * @param componentId    The ID of the power component, e.g.
 * {@link BatteryConsumer#POWER_COMPONENT_CPU}.
 * @param componentPower Amount of consumed power in mAh.
 */
",0,"[@SuppressWarnings(""unchecked""), @NonNull]","[@SuppressWarnings(""unchecked""), @NonNull]",0,,,,,,,"4,5",0,"The implementation of setConsumedPower() has changed by including getKey(componentId, PROCESS_STATE_UNSPECIFIED) instead of just componentId, and this represents a change in the argument passed to the setConsumedPower method. Therefore, the code change type is 5 (Dependent API changed). Additionally, since this is just a change in how the argument is constructed and the structure and behaviour of the method itself remains the same, type 4 (Other statement changed) is also applicable.","No Compatibility Issue detected because the change in the dependent API does not alter the behaviour of the setConsumedPower method's expected outcome. The method still sets the consumed power for the given component ID with the provided power and power model, and returns the current instance. The modification is internal to how the component ID argument is determined, but does not affect the output of the method or its contract. Therefore, the CI type is 0."
117,<android.hardware.camera2.impl.CameraDeviceImpl: void createExtensionSession(ExtensionSessionConfiguration)>,32,33,,,,"{
    try {
        if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()) {
            mCurrentAdvancedExtensionSession = CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration);
        } else {
            mCurrentExtensionSession = CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration);
        }
    } catch (RemoteException e) {
        throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
    }
}","{
    try {
        if (CameraExtensionCharacteristics.areAdvancedExtensionsSupported()) {
            mCurrentAdvancedExtensionSession = CameraAdvancedExtensionSessionImpl.createCameraAdvancedExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++);
        } else {
            mCurrentExtensionSession = CameraExtensionSessionImpl.createCameraExtensionSession(this, mContext, extensionConfiguration, mNextSessionId++);
        }
    } catch (RemoteException e) {
        throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,5,0,"The method createCameraAdvancedExtensionSession and createCameraExtensionSession now include an additional parameter, namely mNextSessionId++. Hence, the code change type is 5 because there's a change in a Dependent API due to the new parameter.","Since the change involves passing an additional incrementing session ID which doesn't affect the value returned by the API (mCurrentAdvancedExtensionSession and mCurrentExtensionSession) and doesn't modify the exception handling, this change does not lead to a Compatibility Issue."
118,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[],Bundle)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, /*excludedPackages*/
        AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,5,0,"The change is in the arguments passed to the method ActivityManager.getService().broadcastIntentWithFeature(), where a null value replaces AppOpsManager.OP_NONE for the parameter ""excludedPermissions"". As this is a change in the arguments list of the dependent API call, the code change type is 5.","There is no compatibility issue here since the method signature has not changed, no exception handling has changed, and no control flow has been altered. The change in a parameter value passed to an internal method does not affect the behavior of the sendBroadcastMultiplePermissions method itself from the caller's point of view, assuming that the internal method handles the parameter properly in both versions."
119,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,32,33,,,,"{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                Engine engine = onCreateEngine();
                mEngine = engine;
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    engine.detach();
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_ZOOM:
            mEngine.setZoom(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_SCALE_PREVIEW:
            mEngine.scalePreview((Rect) message.obj);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
                mEngine.scaleAndCropScreenshot();
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    WallpaperColors colors = mEngine.onComputeColors();
                    mEngine.setPrimaryWallpaperColors(colors);
                    mConnection.onWallpaperColorsChanged(colors, mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        case MSG_REPORT_SHOWN:
            {
                reportShown();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                Engine engine = onCreateEngine();
                mEngine = engine;
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    engine.detach();
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_ZOOM:
            mEngine.setZoom(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_UPDATE_DIMMING:
            mEngine.updateWallpaperDimming(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_SCALE_PREVIEW:
            mEngine.scalePreview((Rect) message.obj);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateConfiguration(((MergedConfiguration) message.obj));
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
                mEngine.scaleAndCropScreenshot();
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    WallpaperColors colors = mEngine.onComputeColors();
                    mEngine.setPrimaryWallpaperColors(colors);
                    mConnection.onWallpaperColorsChanged(colors, mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        case MSG_REPORT_SHOWN:
            {
                reportShown();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
120,<android.app.admin.ManagedProfileProvisioningParams.Builder: ManagedProfileProvisioningParams build()>,32,33,,,,"{
    return new ManagedProfileProvisioningParams(mProfileAdminComponentName, mOwnerName, mProfileName, mAccountToMigrate, mLeaveAllSystemAppsEnabled, mOrganizationOwnedProvisioning, mKeepAccountMigrated);
}","{
    return new ManagedProfileProvisioningParams(mProfileAdminComponentName, mOwnerName, mProfileName, mAccountToMigrate, mLeaveAllSystemAppsEnabled, mOrganizationOwnedProvisioning, mKeepingAccountOnMigration, mAdminExtras != null ? mAdminExtras : new PersistableBundle());
}",1,"/**
 * Combines all of the attributes that have been set on this {@code Builder}.
 *
 * @return a new {@link ManagedProfileProvisioningParams} object.
 */
","/**
 * Combines all of the attributes that have been set on this {@code Builder}.
 *
 * @return a new {@link ManagedProfileProvisioningParams} object.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The constructor of ManagedProfileProvisioningParams in the late version has two changes: first, the last parameter of the constructor is no longer mKeepAccountMigrated, but mKeepingAccountOnMigration and second, a new parameter (mAdminExtras != null ? mAdminExtras : new PersistableBundle()) is added, showing that the signature of the dependent API has changed, so the code change type is 1,5.","The constructor of ManagedProfileProvisioningParams with the added parameter and the changed parameter could potentially lead to a different return value for the build() method, so the CI type is 1."
121,"<android.hardware.camera2.CaptureRequest: void writeToParcel(Parcel,int)>",32,33,,,,"{
    int physicalCameraCount = mPhysicalCameraSettings.size();
    dest.writeInt(physicalCameraCount);
    // Logical camera id and settings always come first.
    dest.writeString(mLogicalCameraId);
    mLogicalCameraSettings.writeToParcel(dest, flags);
    for (Map.Entry<String, CameraMetadataNative> entry : mPhysicalCameraSettings.entrySet()) {
        if (entry.getKey().equals(mLogicalCameraId)) {
            continue;
        }
        dest.writeString(entry.getKey());
        entry.getValue().writeToParcel(dest, flags);
    }
    dest.writeInt(mIsReprocess ? 1 : 0);
    synchronized (mSurfacesLock) {
        final ArraySet<Surface> surfaces = mSurfaceConverted ? mEmptySurfaceSet : mSurfaceSet;
        dest.writeParcelableArray(surfaces.toArray(new Surface[surfaces.size()]), flags);
        if (mSurfaceConverted) {
            dest.writeInt(mStreamIdxArray.length);
            for (int i = 0; i < mStreamIdxArray.length; i++) {
                dest.writeInt(mStreamIdxArray[i]);
                dest.writeInt(mSurfaceIdxArray[i]);
            }
        } else {
            dest.writeInt(0);
        }
    }
}","{
    if (!mPhysicalCameraSettings.containsKey(mLogicalCameraId)) {
        throw new IllegalStateException(""Physical camera settings map must contain a key for "" + ""the logical camera id."");
    }
    int physicalCameraCount = mPhysicalCameraSettings.size();
    dest.writeInt(physicalCameraCount);
    // Logical camera id and settings always come first.
    dest.writeString(mLogicalCameraId);
    mLogicalCameraSettings.writeToParcel(dest, flags);
    for (Map.Entry<String, CameraMetadataNative> entry : mPhysicalCameraSettings.entrySet()) {
        if (entry.getKey().equals(mLogicalCameraId)) {
            continue;
        }
        dest.writeString(entry.getKey());
        entry.getValue().writeToParcel(dest, flags);
    }
    dest.writeInt(mIsReprocess ? 1 : 0);
    synchronized (mSurfacesLock) {
        final ArraySet<Surface> surfaces = mSurfaceConverted ? mEmptySurfaceSet : mSurfaceSet;
        dest.writeParcelableArray(surfaces.toArray(new Surface[surfaces.size()]), flags);
        if (mSurfaceConverted) {
            dest.writeInt(mStreamIdxArray.length);
            for (int i = 0; i < mStreamIdxArray.length; i++) {
                dest.writeInt(mStreamIdxArray[i]);
                dest.writeInt(mSurfaceIdxArray[i]);
            }
        } else {
            dest.writeInt(0);
        }
    }
    // Write string for user tag if set to something in the same namespace
    if (mUserTag != null) {
        String userTagStr = mUserTag.toString();
        if (userTagStr != null && userTagStr.startsWith(SET_TAG_STRING_PREFIX)) {
            dest.writeInt(1);
            dest.writeString(userTagStr.substring(SET_TAG_STRING_PREFIX.length()));
        } else {
            dest.writeInt(0);
        }
    } else {
        dest.writeInt(0);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,3,4","1,2","An exception handling statement (throw new IllegalStateException(...)) and a new control statement (if condition checking for mPhysicalCameraSettings.containsKey(mLogicalCameraId)) have been introduced, followed by the addition of other statements writing extra data to the Parcel. This classifies as changes in exception handling statement (2), control dependency (3), and other statement (4).","The added exception will cause a Compatibility Issue if the condition is met since it could throw an exception that wasn't present in the early version, which is a CI caused by potential different exception handlings (2). Furthermore, the addition of writing the `userTag` could lead to a different size or content of the Parcel being written, which could result in a CI caused by potential different return values (1)."
123,<android.view.translation.TranslationSpec: ULocale unparcelLocale(Parcel)>,32,33,,,,"{
    return (ULocale) in.readSerializable();
}","{
    return (ULocale) in.readSerializable(android.icu.util.ULocale.class.getClassLoader(), android.icu.util.ULocale.class);
}",1,,,0,,,0,,,,,,,"1,5",1,The late implementation of the 'unparcelLocale' method changes the way how the `ULocale` object is deserialized by specifying the class loader and the class. This constitutes a change in both the return statement since the method invoked is different (overloaded method with additional parameters) and a dependent API changed since it now relies on a more specific deserialization method.,"The introduction of class loader specificity in the deserialization process can affect the `ULocale` object that is returned. Different class loaders could potentially lead to different deserialized objects, especially in scenarios involving multiple class loaders with different class paths. Therefore, this change may lead to a potential Compatibility Issue due to the possibility of the API returning a different value or type."
124,"<android.view.textclassifier.TextLanguage.Builder: Builder putLocale(ULocale,float)>",32,33,,,,"{
    Preconditions.checkNotNull(locale);
    mEntityConfidenceMap.put(locale.toLanguageTag(), confidenceScore);
    return this;
}","{
    Objects.requireNonNull(locale);
    mEntityConfidenceMap.put(locale.toLanguageTag(), confidenceScore);
    return this;
}",1,"/**
 * Sets a language locale for the processed text and assigns a confidence score. If the
 * locale has already been set, this updates it.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the locale does not exist for the processed text.
 * Values greater than 1 are clamped to 1.
 */
","/**
 * Sets a language locale for the processed text and assigns a confidence score. If the
 * locale has already been set, this updates it.
 *
 * @param confidenceScore a value from 0 (low confidence) to 1 (high confidence).
 * 0 implies the locale does not exist for the processed text.
 * Values greater than 1 are clamped to 1.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,"There has been a change in the method used to check for nullity from Preconditions.checkNotNull(locale) to Objects.requireNonNull(locale), so the code change type is 4.","There is no Compatibility Issue here because both methods Preconditions.checkNotNull() and Objects.requireNonNull() serve the same purpose of throwing a NullPointerException when the passed argument is null. The change does not affect the method's behavior, return value or exception handling from the perspective of the API consumer, so the CI type is 0."
125,<android.widget.TextView.TextAppearanceAttributes: String toString()>,32,33,,,,"{
    return ""TextAppearanceAttributes {\n"" + ""    mTextColorHighlight:"" + mTextColorHighlight + ""\n"" + ""    mTextColor:"" + mTextColor + ""\n"" + ""    mTextColorHint:"" + mTextColorHint + ""\n"" + ""    mTextColorLink:"" + mTextColorLink + ""\n"" + ""    mTextSize:"" + mTextSize + ""\n"" + ""    mTextSizeUnit:"" + mTextSizeUnit + ""\n"" + ""    mTextLocales:"" + mTextLocales + ""\n"" + ""    mFontFamily:"" + mFontFamily + ""\n"" + ""    mFontTypeface:"" + mFontTypeface + ""\n"" + ""    mFontFamilyExplicit:"" + mFontFamilyExplicit + ""\n"" + ""    mTypefaceIndex:"" + mTypefaceIndex + ""\n"" + ""    mTextStyle:"" + mTextStyle + ""\n"" + ""    mFontWeight:"" + mFontWeight + ""\n"" + ""    mAllCaps:"" + mAllCaps + ""\n"" + ""    mShadowColor:"" + mShadowColor + ""\n"" + ""    mShadowDx:"" + mShadowDx + ""\n"" + ""    mShadowDy:"" + mShadowDy + ""\n"" + ""    mShadowRadius:"" + mShadowRadius + ""\n"" + ""    mHasElegant:"" + mHasElegant + ""\n"" + ""    mElegant:"" + mElegant + ""\n"" + ""    mHasFallbackLineSpacing:"" + mHasFallbackLineSpacing + ""\n"" + ""    mFallbackLineSpacing:"" + mFallbackLineSpacing + ""\n"" + ""    mHasLetterSpacing:"" + mHasLetterSpacing + ""\n"" + ""    mLetterSpacing:"" + mLetterSpacing + ""\n"" + ""    mFontFeatureSettings:"" + mFontFeatureSettings + ""\n"" + ""    mFontVariationSettings:"" + mFontVariationSettings + ""\n"" + ""}"";
}","{
    return ""TextAppearanceAttributes {\n"" + ""    mTextColorHighlight:"" + mTextColorHighlight + ""\n"" + ""    mTextColor:"" + mTextColor + ""\n"" + ""    mTextColorHint:"" + mTextColorHint + ""\n"" + ""    mTextColorLink:"" + mTextColorLink + ""\n"" + ""    mTextSize:"" + mTextSize + ""\n"" + ""    mTextSizeUnit:"" + mTextSizeUnit + ""\n"" + ""    mTextLocales:"" + mTextLocales + ""\n"" + ""    mFontFamily:"" + mFontFamily + ""\n"" + ""    mFontTypeface:"" + mFontTypeface + ""\n"" + ""    mFontFamilyExplicit:"" + mFontFamilyExplicit + ""\n"" + ""    mTypefaceIndex:"" + mTypefaceIndex + ""\n"" + ""    mTextStyle:"" + mTextStyle + ""\n"" + ""    mFontWeight:"" + mFontWeight + ""\n"" + ""    mAllCaps:"" + mAllCaps + ""\n"" + ""    mShadowColor:"" + mShadowColor + ""\n"" + ""    mShadowDx:"" + mShadowDx + ""\n"" + ""    mShadowDy:"" + mShadowDy + ""\n"" + ""    mShadowRadius:"" + mShadowRadius + ""\n"" + ""    mHasElegant:"" + mHasElegant + ""\n"" + ""    mElegant:"" + mElegant + ""\n"" + ""    mHasFallbackLineSpacing:"" + mHasFallbackLineSpacing + ""\n"" + ""    mFallbackLineSpacing:"" + mFallbackLineSpacing + ""\n"" + ""    mHasLetterSpacing:"" + mHasLetterSpacing + ""\n"" + ""    mLetterSpacing:"" + mLetterSpacing + ""\n"" + ""    mFontFeatureSettings:"" + mFontFeatureSettings + ""\n"" + ""    mFontVariationSettings:"" + mFontVariationSettings + ""\n"" + ""    mHasLineBreakStyle:"" + mHasLineBreakStyle + ""\n"" + ""    mHasLineBreakWordStyle:"" + mHasLineBreakWordStyle + ""\n"" + ""    mLineBreakStyle:"" + mLineBreakStyle + ""\n"" + ""    mLineBreakWordStyle:"" + mLineBreakWordStyle + ""\n"" + ""}"";
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The method implementation in the late version has additional string concatenations that include new fields: mHasLineBreakStyle, mHasLineBreakWordStyle, mLineBreakStyle, and mLineBreakWordStyle. These are not present in the early version, so the change types are 1 (Return statement changed) and 4 (Other statement changed).","The toString() method in the late version will return a string representation that includes additional information compared to the early version. Hence, a Compatibility Issue could arise due to the return of different values, and the CI type is 1."
127,"<android.app.ActivityOptions: ActivityOptions makeCustomAnimation(Context,int,int)>",32,33,,,,"{
    return makeCustomAnimation(context, enterResId, exitResId, null, null, null);
}","{
    return makeCustomAnimation(context, enterResId, exitResId, 0, null, null);
}",1,"/**
 * Create an ActivityOptions specifying a custom animation to run when
 * the activity is displayed.
 *
 * @param context Who is defining this.  This is the application that the
 * animation resources will be loaded from.
 * @param enterResId A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitResId A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 */
","/**
 * Create an ActivityOptions specifying a custom animation to run when
 * the activity is displayed.
 *
 * @param context Who is defining this.  This is the application that the
 * animation resources will be loaded from.
 * @param enterResId A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitResId A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 */
",0,,,0,,,,,,,5,0,"The invocation of makeCustomAnimation method within the implementation of makeCustomAnimation(Context, int, int) has altered its parameters: from passing null to passing 0. Hence, there's a change in the dependent API, classifying it as code change type 5.","There is no compatibility issue because the change is internal API change that doesn't affect the return type or the exceptions thrown by the public API method makeCustomAnimation(Context, int, int). The public method signature remains the same and there is no difference in the expected behavior or contract of the method as seen by the caller. Hence, there is no CI."
128,<android.os.UidBatteryConsumer.Builder: Builder add(UidBatteryConsumer)>,32,33,,,,"{
    mPowerComponentsBuilder.addPowerAndDuration(consumer.mPowerComponents);
    mTimeInBackgroundMs += consumer.mTimeInBackgroundMs;
    mTimeInForegroundMs += consumer.mTimeInForegroundMs;
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = consumer.mPackageWithHighestDrain;
    } else if (!TextUtils.equals(mPackageWithHighestDrain, consumer.mPackageWithHighestDrain)) {
        // Consider combining two UidBatteryConsumers with this distribution
        // of power drain between packages:
        // (package1=100, package2=10) and (package1=100, package2=101).
        // Since we don't know the actual power distribution between packages at this
        // point, we have no way to correctly declare package1 as the winner.
        // The naive logic of picking the consumer with the higher total consumed
        // power would produce an incorrect result.
        mPackageWithHighestDrain = null;
    }
    return this;
}","{
    mPowerComponentsBuilder.addPowerAndDuration(consumer.mPowerComponents);
    setTimeInStateMs(STATE_FOREGROUND, mData.getLong(COLUMN_INDEX_TIME_IN_FOREGROUND) + consumer.getTimeInStateMs(STATE_FOREGROUND));
    setTimeInStateMs(STATE_BACKGROUND, mData.getLong(COLUMN_INDEX_TIME_IN_BACKGROUND) + consumer.getTimeInStateMs(STATE_BACKGROUND));
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = consumer.getPackageWithHighestDrain();
    } else if (!TextUtils.equals(mPackageWithHighestDrain, consumer.getPackageWithHighestDrain())) {
        // Consider combining two UidBatteryConsumers with this distribution
        // of power drain between packages:
        // (package1=100, package2=10) and (package1=100, package2=101).
        // Since we don't know the actual power distribution between packages at this
        // point, we have no way to correctly declare package1 as the winner.
        // The naive logic of picking the consumer with the higher total consumed
        // power would produce an incorrect result.
        mPackageWithHighestDrain = null;
    }
    return this;
}",1,"/**
 * Adds power and usage duration from the supplied UidBatteryConsumer.
 */
","/**
 * Adds power and usage duration from the supplied UidBatteryConsumer.
 */
",0,,,0,,,,,,,"4,5",0,"The statements ""mTimeInBackgroundMs += consumer.mTimeInBackgroundMs"" and ""mTimeInForegroundMs += consumer.mTimeInForegroundMs"" have been replaced with calls to ""setTimeInStateMs"" method using different parameters. Also, strings such as ""mTimeInBackgroundMs"" and ""mTimeInForegroundMs"" have been replaced with method calls and constants like ""COLUMN_INDEX_TIME_IN_BACKGROUND"" and ""COLUMN_INDEX_TIME_IN_FOREGROUND"". The ""getPackageWithHighestDrain"" method is now used instead of directly accessing the ""mPackageWithHighestDrain"" field. This indicates changes in other statement (type 4) and a dependent API (type 5).","Although there are changes to how internal state is updated (with new method calls), these changes do not affect what is returned by the ""add"" method; the method at both versions ends by returning ""this"", indicating no behavior change in terms of return value or thrown exceptions. Moreover, without additional information about the modified dependent APIs' behavior, we cannot conclude from the information given that there is a compatibility issue arising from these changes."
129,<android.widget.MediaController: void hide()>,32,33,,,,"{
    if (mAnchor == null)
        return;
    if (mShowing) {
        try {
            removeCallbacks(mShowProgress);
            mWindowManager.removeView(mDecor);
        } catch (IllegalArgumentException ex) {
            Log.w(""MediaController"", ""already removed"");
        }
        mShowing = false;
    }
}","{
    if (mAnchor == null)
        return;
    if (mShowing) {
        try {
            removeCallbacks(mShowProgress);
            mWindowManager.removeView(mDecor);
        } catch (IllegalArgumentException ex) {
            Log.w(""MediaController"", ""already removed"");
        }
        mShowing = false;
        unregisterOnBackInvokedCallback();
    }
}",1,"/**
 * Remove the controller from the screen.
 */
","/**
 * Remove the controller from the screen.
 */
",0,,,0,,,,,,,4,0,"An additional method call (unregisterOnBackInvokedCallback()) is added in the late implementation within the 'if' block. Therefore, the change type is 4.","The newly added method call does not affect the return value of the 'hide()' method as it has no return statement that depends on the result of the method call, nor does it introduce new or modified exceptions. Thus, there is no Compatibility Issue."
131,"<android.view.contentcapture.ContentCaptureManager: void shareData(DataShareRequest,Executor,DataShareWriteAdapter)>",32,33,,,,"{
    Preconditions.checkNotNull(request);
    Preconditions.checkNotNull(dataShareWriteAdapter);
    Preconditions.checkNotNull(executor);
    try {
        mService.shareData(request, new DataShareAdapterDelegate(executor, dataShareWriteAdapter, mDataShareAdapterResourceManager));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(request);
    Objects.requireNonNull(dataShareWriteAdapter);
    Objects.requireNonNull(executor);
    try {
        mService.shareData(request, new DataShareAdapterDelegate(executor, dataShareWriteAdapter, mDataShareAdapterResourceManager));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by the app to request data sharing via writing to a file.
 *
 * <p>The ContentCaptureService app will receive a read-only file descriptor pointing to the
 * same file and will be able to read data being shared from it.
 *
 * <p>Note: using this API doesn't guarantee the app staying alive and is ""best-effort"".
 * Starting a foreground service would minimize the chances of the app getting killed during the
 * file sharing session.
 *
 * @param request object specifying details of the data being shared.
 */
","/**
 * Called by the app to request data sharing via writing to a file.
 *
 * <p>The ContentCaptureService app will receive a read-only file descriptor pointing to the
 * same file and will be able to read data being shared from it.
 *
 * <p>Note: using this API doesn't guarantee the app staying alive and is ""best-effort"".
 * Starting a foreground service would minimize the chances of the app getting killed during the
 * file sharing session.
 *
 * @param request object specifying details of the data being shared.
 */
",0,,,0,,,,,,,4,0,"The change is from using Preconditions.checkNotNull() to Objects.requireNonNull() for checking if arguments are not null. This is classified as ""Other statement changed"" since both methods effectively do the same thing, which is to throw a NullPointerException if the passed argument is null.","This change does not lead to a Compatibility Issue since both methods would throw a NullPointerException if any of the arguments are null. The behavior of the API has not changed between versions in terms of return values, exceptions, or control flow."
132,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue)>",32,33,,,,"{
    throwIfDestroyed();
    setLifeTheUniverseAndEverything(id, value, null, null, null);
    return this;
}","{
    throwIfDestroyed();
    setLifeTheUniverseAndEverything(id, value, null, null, null, null, null);
    return this;
}",1,"/**
 * Sets the value of a field.
 *
 * <b>Note:</b> Prior to Android {@link android.os.Build.VERSION_CODES#P}, this method would
 * throw an {@link IllegalStateException} if this builder was constructed without a
 * {@link RemoteViews presentation}. Android {@link android.os.Build.VERSION_CODES#P} and
 * higher removed this restriction because datasets used as an
 * {@link android.view.autofill.AutofillManager#EXTRA_AUTHENTICATION_RESULT
 * authentication result} do not need a presentation. But if you don't set the presentation
 * in the constructor in a dataset that is meant to be shown to the user, the autofill UI
 * for this field will not be displayed.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the {@code value} parameter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field.
 *
 * <b>Note:</b> Prior to Android {@link android.os.Build.VERSION_CODES#P}, this method would
 * throw an {@link IllegalStateException} if this builder was constructed without a
 * {@link RemoteViews presentation}. Android {@link android.os.Build.VERSION_CODES#P} and
 * higher removed this restriction because datasets used as an
 * {@link android.view.autofill.AutofillManager#EXTRA_AUTHENTICATION_RESULT
 * authentication result} do not need a presentation. But if you don't set the presentation
 * in the constructor in a dataset that is meant to be shown to the user, the autofill UI
 * for this field will not be displayed.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the {@code value} parameter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,5,0,"The method setLifeTheUniverseAndEverything() has two more 'null' parameters in the late version, and this change implies that the signature of the dependent API setLifeTheUniverseAndEverything() has changed, so the code change type is 5.","The added annotations do not affect the return value or exception handling of the method. Since only additional parameters are passed as 'null' to the dependent API method, and this would not change the behavior for the client code if the method is properly overloaded to handle these additional parameters, there is no Compatibility Issue. Thus, the CI type is 0."
133,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,Bundle)>",32,33,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, options, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There has been a reordering of the parameters inside the method call for `broadcastIntentWithFeature()`. Specifically, 'excludedPermissions' parameter was `AppOpsManager.OP_NONE` which is now moved after `null`, so this is an 'Other statement changed' which is code change type 4.",No Compatibility Issue has been detected because it seems like the `AppOpsManager.OP_NONE` was intended to be the excludedPermissions parameter initially but was incorrectly placed before 'null'. The correction doesn't change the logic of the method execution hence no CI.
134,<android.view.textclassifier.TextLanguage.Request.Builder: Builder setExtras(Bundle)>,32,33,,,,"{
    mBundle = Preconditions.checkNotNull(bundle);
    return this;
}","{
    mBundle = Objects.requireNonNull(bundle);
    return this;
}",1,"/**
 * Sets a bundle containing non-structured extra information about the request.
 */
","/**
 * Sets a bundle containing non-structured extra information about the request.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,The method used to check for a null reference has been changed from Preconditions.checkNotNull() to Objects.requireNonNull(). This is a change in a dependent API.,"There is no Compatibility Issue here because both Preconditions.checkNotNull() and Objects.requireNonNull() serve the same purpose of throwing a NullPointerException if the passed argument is null. Therefore, the behavior of the API does not change from the user's perspective."
135,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",32,33,,,,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateSelection(view, selStart, selEnd, candidatesStart, candidatesEnd);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            if (DEBUG) {
                Log.v(TAG, ""SELECTION CHANGE: "" + mCurrentInputMethodSession);
            }
            final int oldSelStart = mCursorSelStart;
            final int oldSelEnd = mCursorSelEnd;
            // Update internal values before sending updateSelection to the IME, because
            // if it changes the text within its onUpdateSelection handler in a way that
            // does not move the cursor we don't want to call it again with the same values.
            mCursorSelStart = selStart;
            mCursorSelEnd = selEnd;
            mCursorCandStart = candidatesStart;
            mCursorCandEnd = candidatesEnd;
            mCurrentInputMethodSession.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateSelection(view, selStart, selEnd, candidatesStart, candidatesEnd);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        if (mServedInputConnection != null && mServedInputConnection.hasPendingInvalidation()) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            if (DEBUG) {
                Log.v(TAG, ""SELECTION CHANGE: "" + mCurrentInputMethodSession);
            }
            final int oldSelStart = mCursorSelStart;
            final int oldSelEnd = mCursorSelEnd;
            // Update internal values before sending updateSelection to the IME, because
            // if it changes the text within its onUpdateSelection handler in a way that
            // does not move the cursor we don't want to call it again with the same values.
            mCursorSelStart = selStart;
            mCursorSelEnd = selEnd;
            mCursorCandStart = candidatesStart;
            mCursorCandEnd = candidatesEnd;
            mCurrentInputMethodSession.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
            forAccessibilitySessionsLocked(wrapper -> wrapper.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd));
        }
    }
}",1,"/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
","/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
",0,,,0,,,,,,,"3,4",0,"An additional control dependency on `mServedInputConnection != null && mServedInputConnection.hasPendingInvalidation()` has been added, and there's a new method call `forAccessibilitySessionsLocked(...)`, which represents a change in the control dependency and other statements, so the code change type is 3,4.","Since the new control check `mServedInputConnection != null && mServedInputConnection.hasPendingInvalidation()` could prevent the execution of subsequent code, return types, or thrown exceptions are not changed within the same conditions. The new method call is internal and does not change the API's return type or exception throwing behavior; instead, it enhances functionality without impacting the existing behavior. Therefore, there is no Compatibility Issue, and the CI type is 0."
137,"<android.view.accessibility.AccessibilityNodeInfo.RangeInfo: RangeInfo obtain(int,float,float,float)>",32,33,,,,"{
    RangeInfo info = sPool.acquire();
    if (info == null) {
        return new RangeInfo(type, min, max, current);
    }
    info.mType = type;
    info.mMin = min;
    info.mMax = max;
    info.mCurrent = current;
    return info;
}","{
    return new RangeInfo(type, min, max, current);
}",1,"/**
 * Obtains a pooled instance.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link AccessibilityNodeInfo.RangeInfo#RangeInfo(int,
 * float, float, float)} instead.
 *
 * @param type The type of the range.
 * @param min The minimum value. Use {@code Float.NEGATIVE_INFINITY} if the range has no
 * minimum.
 * @param max The maximum value. Use {@code Float.POSITIVE_INFINITY} if the range has no
 * maximum.
 * @param current The current value.
 */
","/**
 * Instantiates a new RangeInfo.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link AccessibilityNodeInfo.RangeInfo#RangeInfo(int, float, float,
 * float)} instead.
 *
 * @param type The type of the range.
 * @param min The minimum value. Use {@code Float.NEGATIVE_INFINITY} if the range has no
 * minimum.
 * @param max The maximum value. Use {@code Float.POSITIVE_INFINITY} if the range has no
 * maximum.
 * @param current The current value.
 */
",1,,[@Deprecated],1,,,,,,,1,1,"The entire pooling mechanism has been removed and replaced with simply creating a new RangeInfo object every time the method is called. This includes the deletion of statements acquiring from the pool (sPool.acquire()) and conditional object reuse for population of the returned object. Now, a new object is created and returned every time, without reusing an existing object potentially acquired from the pool.","As the API no longer uses an object pool and now always creates a new RangeInfo object, clients that rely on the API's previous object reuse behavior may experience a compatibility issue due to different memory characteristics or new object identities each call. Hence, the CI type is 1."
138,<android.hardware.camera2.impl.CameraExtensionSessionImpl.InitializeSessionHandler: void onSuccess()>,32,33,,,,"{
    boolean status = true;
    ArrayList<CaptureStageImpl> initialRequestList = compileInitialRequestList();
    if (!initialRequestList.isEmpty()) {
        try {
            setInitialCaptureRequest(initialRequestList, new InitialRequestHandler(mRepeatingRequestImageCallback));
        } catch (CameraAccessException e) {
            Log.e(TAG, ""Failed to initialize the initial capture "" + ""request!"");
            status = false;
        }
    } else {
        try {
            setRepeatingRequest(mPreviewExtender.getCaptureStage(), new RepeatingRequestHandler(null, null, null, mRepeatingRequestImageCallback));
        } catch (CameraAccessException | RemoteException e) {
            Log.e(TAG, ""Failed to initialize internal repeating "" + ""request!"");
            status = false;
        }
    }
    if (!status) {
        notifyConfigurationFailure();
    }
}","{
    boolean status = true;
    ArrayList<CaptureStageImpl> initialRequestList = compileInitialRequestList();
    if (!initialRequestList.isEmpty()) {
        try {
            setInitialCaptureRequest(initialRequestList, new InitialRequestHandler(mRepeatingRequestImageCallback));
        } catch (CameraAccessException e) {
            Log.e(TAG, ""Failed to initialize the initial capture "" + ""request!"");
            status = false;
        }
    } else {
        try {
            setRepeatingRequest(mPreviewExtender.getCaptureStage(), new PreviewRequestHandler(null, null, null, mRepeatingRequestImageCallback));
        } catch (CameraAccessException | RemoteException e) {
            Log.e(TAG, ""Failed to initialize internal repeating "" + ""request!"");
            status = false;
        }
    }
    if (!status) {
        notifyConfigurationFailure();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,"The code change is in the instantiation of a new object, where `new RepeatingRequestHandler` is replaced with `new PreviewRequestHandler`. Furthermore, `RepeatingRequestHandler` and `PreviewRequestHandler` classes are possibly part of the camera2 API, indicating they are dependent APIs that could have different implementations or behaviors. Therefore, the change type is 4,5.","There is no compatibility issue because the control flow and the exceptions that could be thrown remain the same. The method retains identical behavior in terms of what it returns and what exceptions it may throw, so CI type is 0."
139,"<android.content.pm.ShortcutManager: void disableShortcuts(List<String>,CharSequence)>",32,33,,,,"{
    try {
        getFutureOrThrow(mService.disableShortcuts(mContext.getPackageName(), shortcutIds, disabledMessage, /* disabledMessageResId =*/
        0, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.disableShortcuts(mContext.getPackageName(), shortcutIds, disabledMessage, /* disabledMessageResId =*/
        0, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Disable pinned shortcuts, showing the user a custom error message when they try to select
 * the disabled shortcuts.
 * For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Disable pinned shortcuts, showing the user a custom error message when they try to select
 * the disabled shortcuts.
 * For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,,,0,,,,,,,4,0,"The method call `getFutureOrThrow(mService.disableShortcuts(...))` has been removed, and now the method simply calls `mService.disableShortcuts(...)`. This is an internal change not affecting the method's signature or the exceptions thrown -- the control flow remains unchanged. Hence, the change type is 4 (Other statement changed).","Since the removal of the `getFutureOrThrow` method call doesn't affect the behavior observed by the method's callers (i.e., the method's return type is void, and it still throws the same exception), there is no Compatibility Issue introduced by this change."
140,<android.content.res.ColorStateList: ColorStateList valueOf(int)>,32,33,,,,"{
    synchronized (sCache) {
        final int index = sCache.indexOfKey(color);
        if (index >= 0) {
            final ColorStateList cached = sCache.valueAt(index).get();
            if (cached != null) {
                return cached;
            }
            // Prune missing entry.
            sCache.removeAt(index);
        }
        // Prune the cache before adding new items.
        final int N = sCache.size();
        for (int i = N - 1; i >= 0; i--) {
            if (sCache.valueAt(i).get() == null) {
                sCache.removeAt(i);
            }
        }
        final ColorStateList csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<>(csl));
        return csl;
    }
}","{
    synchronized (sCache) {
        final int index = sCache.indexOfKey(color);
        if (index >= 0) {
            final ColorStateList cached = sCache.valueAt(index).get();
            if (cached != null) {
                return cached;
            }
            // Prune missing entry.
            sCache.removeAt(index);
        }
        // Prune the cache before adding new items.
        final int N = sCache.size();
        for (int i = N - 1; i >= 0; i--) {
            if (sCache.valueAt(i).refersTo(null)) {
                sCache.removeAt(i);
            }
        }
        final ColorStateList csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<>(csl));
        return csl;
    }
}",1,"/**
 * @return A ColorStateList containing a single color.
 */
","/**
 * @return A ColorStateList containing a single color.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The implementation changed the method called on a WeakReference from 'get' to 'refersTo', which is a change in a dependent API. The call 'sCache.valueAt(i).get() == null' was replaced by 'sCache.valueAt(i).refersTo(null)', so the code change type is 4,5.","As the use of 'refersTo(null)' instead of 'get() == null' doesn't alter the behavior of whether the WeakReference holds a non-null object or not, there should be no compatibility issue because the overall logic and contract of the API haven't changed. It's just an internal improvement or change in the way the API checks if the reference has been cleared. The return values would remain consistent therefore, there is no compatibility issue, hence CI type is 0."
141,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,The only difference between the early and the late version of the implementation is the position of a parameter in the method call broadcastIntentWithFeature(...). The parameter has been moved but not changed in value or type. This type of change is classified under 4) Other statement changed.,"There's no Compatibility Issue here because the relative positions of the parameters have been altered without affecting the semantic behavior of the method or the type and value returned. The method's contract and functionality remain the same, and it does not change the behavior as seen by a caller of the method."
143,"<android.widget.Editor.CursorAnchorInfoNotifier: void updatePosition(int,int,boolean,boolean)>",32,33,,,,"{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = getInputMethodManager();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
    final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
    final CharSequence text = mTextView.getText();
    if (text instanceof Spannable) {
        final Spannable sp = (Spannable) text;
        int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
        int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
        if (composingTextEnd < composingTextStart) {
            final int temp = composingTextEnd;
            composingTextEnd = composingTextStart;
            composingTextStart = temp;
        }
        final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
        if (hasComposingText) {
            final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
            builder.setComposingText(composingTextStart, composingText);
            mTextView.populateCharacterBounds(builder, composingTextStart, composingTextEnd, viewportToContentHorizontalOffset, viewportToContentVerticalOffset);
        }
    }
    // Treat selectionStart as the insertion point.
    if (0 <= selectionStart) {
        final int offset = selectionStart;
        final int line = layout.getLineForOffset(offset);
        final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
        final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
        final float insertionMarkerBottom = layout.getLineBottomWithoutSpacing(line) + viewportToContentVerticalOffset;
        final boolean isTopVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerTop);
        final boolean isBottomVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerBottom);
        int insertionMarkerFlags = 0;
        if (isTopVisible || isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
        }
        if (!isTopVisible || !isBottomVisible) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
        }
        if (layout.isRtlCharAt(offset)) {
            insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
        }
        builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}","{
    final InputMethodState ims = mInputMethodState;
    if (ims == null || ims.mBatchEditNesting > 0) {
        return;
    }
    final InputMethodManager imm = getInputMethodManager();
    if (null == imm) {
        return;
    }
    if (!imm.isActive(mTextView)) {
        return;
    }
    // Skip if the IME has not requested the cursor/anchor position.
    if (!imm.isCursorAnchorInfoEnabled()) {
        return;
    }
    Layout layout = mTextView.getLayout();
    if (layout == null) {
        return;
    }
    int mode = imm.getUpdateCursorAnchorInfoMode();
    boolean includeEditorBounds = (mode & InputConnection.CURSOR_UPDATE_FILTER_EDITOR_BOUNDS) != 0;
    boolean includeCharacterBounds = (mode & InputConnection.CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS) != 0;
    boolean includeInsertionMarker = (mode & InputConnection.CURSOR_UPDATE_FILTER_INSERTION_MARKER) != 0;
    boolean includeAll = (!includeEditorBounds && !includeCharacterBounds && !includeInsertionMarker);
    includeEditorBounds |= includeAll;
    includeCharacterBounds |= includeAll;
    includeInsertionMarker |= includeAll;
    final CursorAnchorInfo.Builder builder = mSelectionInfoBuilder;
    builder.reset();
    final int selectionStart = mTextView.getSelectionStart();
    builder.setSelectionRange(selectionStart, mTextView.getSelectionEnd());
    // Construct transformation matrix from view local coordinates to screen coordinates.
    mViewToScreenMatrix.set(mTextView.getMatrix());
    mTextView.getLocationOnScreen(mTmpIntOffset);
    mViewToScreenMatrix.postTranslate(mTmpIntOffset[0], mTmpIntOffset[1]);
    builder.setMatrix(mViewToScreenMatrix);
    if (includeEditorBounds) {
        final RectF bounds = new RectF();
        bounds.set(0, /* left */
        0, /* top */
        mTextView.getWidth(), mTextView.getHeight());
        EditorBoundsInfo.Builder boundsBuilder = new EditorBoundsInfo.Builder();
        // TODO(b/210039666): add Handwriting bounds once they're available.
        builder.setEditorBoundsInfo(boundsBuilder.setEditorBounds(bounds).build());
    }
    if (includeCharacterBounds || includeInsertionMarker) {
        final float viewportToContentHorizontalOffset = mTextView.viewportToContentHorizontalOffset();
        final float viewportToContentVerticalOffset = mTextView.viewportToContentVerticalOffset();
        if (includeCharacterBounds) {
            final CharSequence text = mTextView.getText();
            if (text instanceof Spannable) {
                final Spannable sp = (Spannable) text;
                int composingTextStart = EditableInputConnection.getComposingSpanStart(sp);
                int composingTextEnd = EditableInputConnection.getComposingSpanEnd(sp);
                if (composingTextEnd < composingTextStart) {
                    final int temp = composingTextEnd;
                    composingTextEnd = composingTextStart;
                    composingTextStart = temp;
                }
                final boolean hasComposingText = (0 <= composingTextStart) && (composingTextStart < composingTextEnd);
                if (hasComposingText) {
                    final CharSequence composingText = text.subSequence(composingTextStart, composingTextEnd);
                    builder.setComposingText(composingTextStart, composingText);
                    mTextView.populateCharacterBounds(builder, composingTextStart, composingTextEnd, viewportToContentHorizontalOffset, viewportToContentVerticalOffset);
                }
            }
        }
        if (includeInsertionMarker) {
            // Treat selectionStart as the insertion point.
            if (0 <= selectionStart) {
                final int offset = selectionStart;
                final int line = layout.getLineForOffset(offset);
                final float insertionMarkerX = layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
                final float insertionMarkerTop = layout.getLineTop(line) + viewportToContentVerticalOffset;
                final float insertionMarkerBaseline = layout.getLineBaseline(line) + viewportToContentVerticalOffset;
                final float insertionMarkerBottom = layout.getLineBottomWithoutSpacing(line) + viewportToContentVerticalOffset;
                final boolean isTopVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerTop);
                final boolean isBottomVisible = mTextView.isPositionVisible(insertionMarkerX, insertionMarkerBottom);
                int insertionMarkerFlags = 0;
                if (isTopVisible || isBottomVisible) {
                    insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_VISIBLE_REGION;
                }
                if (!isTopVisible || !isBottomVisible) {
                    insertionMarkerFlags |= CursorAnchorInfo.FLAG_HAS_INVISIBLE_REGION;
                }
                if (layout.isRtlCharAt(offset)) {
                    insertionMarkerFlags |= CursorAnchorInfo.FLAG_IS_RTL;
                }
                builder.setInsertionMarkerLocation(insertionMarkerX, insertionMarkerTop, insertionMarkerBaseline, insertionMarkerBottom, insertionMarkerFlags);
            }
        }
    }
    imm.updateCursorAnchorInfo(mTextView, builder.build());
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
146,<android.app.admin.SecurityLog.SecurityEvent: int getLogLevel()>,32,33,,,,"{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
        case TAG_PASSWORD_COMPLEXITY_REQUIRED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}","{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
        case TAG_PASSWORD_COMPLEXITY_REQUIRED:
        case TAG_PASSWORD_CHANGED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}",1,"/**
 * Returns severity level for the event.
 */
","/**
 * Returns severity level for the event.
 */
",0,[@SecurityLogLevel],[@SecurityLogLevel],0,,,,,,,3,0,The control dependency 'switch' has an additional case TAG_PASSWORD_CHANGED in the late version. This does not introduce a new control path different from the default LEVEL_INFO. Thus the change is categorized as 3.,"Since the newly added case TAG_PASSWORD_CHANGED falls through to return LEVEL_INFO, which is the same as the default case, there's no change in behavior that would lead to a Compatibility Issue. All other cases and their associated log level returns remain unchanged. Therefore, CI type is 0."
147,<android.service.dreams.DreamService: boolean dispatchGenericMotionEvent(MotionEvent)>,32,33,,,,"{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on genericMotionEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}","{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(mTag, ""Waking up on genericMotionEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The only change is the log tag parameter from 'TAG' to 'mTag', which affects a logging statement and does not impact the API's behavior, so the code change type is 4.","Since the change is only in a logging statement and it does not affect the API's return values or how exceptions are handled, there is no Compatibility Issue, hence the CI type is 0."
148,<android.view.Display: RoundedCorner getRoundedCorner(int)>,32,33,,,,"{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        RoundedCorners roundedCorners;
        if (mMayAdjustByFixedRotation) {
            roundedCorners = getDisplayAdjustments().adjustRoundedCorner(mDisplayInfo.roundedCorners, mDisplayInfo.rotation, mDisplayInfo.logicalWidth, mDisplayInfo.logicalHeight);
        } else {
            roundedCorners = mDisplayInfo.roundedCorners;
        }
        return roundedCorners == null ? null : roundedCorners.getRoundedCorner(position);
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        final RoundedCorners roundedCorners = mDisplayInfo.roundedCorners;
        @Surface.Rotation final int rotation = getLocalRotation();
        if (roundedCorners != null && rotation != mDisplayInfo.rotation) {
            roundedCorners.rotate(rotation, mDisplayInfo.logicalWidth, mDisplayInfo.logicalHeight);
        }
        return roundedCorners == null ? null : roundedCorners.getRoundedCorner(position);
    }
}",1,"/**
 * Returns the {@link RoundedCorner} of the given position if there is one.
 *
 * @param position the position of the rounded corner on the display.
 *
 * @return the rounded corner of the given position. Returns {@code null} if there is none.
 */
","/**
 * Returns the {@link RoundedCorner} of the given position if there is one.
 *
 * @param position the position of the rounded corner on the display.
 *
 * @return the rounded corner of the given position. Returns {@code null} if there is none.
 */
",0,"[@SuppressLint(""VisiblySynchronized""), @Nullable]","[@SuppressLint(""VisiblySynchronized""), @Nullable]",0,,,,,,,"3,4,5",1,"The handling of `roundedCorners` has changed, including the conditional checks and the actions performed on the `roundedCorners` object. Additionally, the dependent API `adjustRoundedCorner` is not called anymore, and instead `rotate` is called on the `roundedCorners` object, indicating a change in the dependent API. Control dependency has also changed since the condition `if (mMayAdjustByFixedRotation)` was replaced with `if (roundedCorners != null && rotation != mDisplayInfo.rotation)`. Also, the variable 'rotation' is obtained from a new method `getLocalRotation()` rather than `mDisplayInfo.rotation`. So, code change types are 3,4,5.","The change in the handling of the RoundedCorner (including rotation and condition checks) and the different treatment of the rotation logic can lead to a different return value, thus indicating a potential different behavior between the two versions. The change in logic introduces a potential Compatibility Issue of type 1, where the API can return a different value due to the changes in the rounding and rotation logic."
149,<android.os.BaseBundle: ArrayList<Integer> getIntegerArrayList(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<Integer>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList<Integer>"", e);
        return null;
    }
}","{
    return getArrayList(key, Integer.class);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
",0,[@Nullable],[@Nullable],0,,,,,,,5,0,"The late implementation is using a different method `getArrayList(key, Integer.class)` compared to the early implementation, so the code change type is 5 (Dependent API changed).","Although a different method is used in the late implementation, this change will not cause a compatibility issue concerning the return type or value since the method signature specifies that an `ArrayList<Integer>` should be the return type, which implies that `getArrayList` should provide the correct typed list. Additionally, no new exceptions are being thrown, and the nullability contract has not changed as indicated by the unchanged `@Nullable` annotation. Therefore, there is no compatibility issue; thus, the CI type is 0."
150,"<android.net.Ikev2VpnProfile.Builder: Builder setAuthDigitalSignature(X509Certificate,PrivateKey,X509Certificate)>",32,33,,,,"{
    checkNotNull(userCert, MISSING_PARAM_MSG_TMPL, ""userCert"");
    checkNotNull(key, MISSING_PARAM_MSG_TMPL, ""key"");
    // Test to make sure all auth params can be encoded safely.
    checkCert(userCert);
    if (serverRootCa != null)
        checkCert(serverRootCa);
    resetAuthParams();
    mUserCert = userCert;
    mRsaPrivateKey = key;
    mServerRootCaCert = serverRootCa;
    mType = VpnProfile.TYPE_IKEV2_IPSEC_RSA;
    return this;
}","{
    checkNotNull(userCert, MISSING_PARAM_MSG_TMPL, ""userCert"");
    checkNotNull(key, MISSING_PARAM_MSG_TMPL, ""key"");
    checkBuilderSetter(mIkeTunConnParams != null, ""authDigitalSignature"");
    // Test to make sure all auth params can be encoded safely.
    checkCert(userCert);
    if (serverRootCa != null)
        checkCert(serverRootCa);
    resetAuthParams();
    mUserCert = userCert;
    mRsaPrivateKey = key;
    mServerRootCaCert = serverRootCa;
    mType = VpnProfile.TYPE_IKEV2_IPSEC_RSA;
    return this;
}",1,"/**
 * Set the IKEv2 authentication to use Digital Signature Authentication with the given key.
 *
 * <p>Setting this will configure IKEv2 authentication using a Digital Signature scheme.
 * Only one authentication method may be set. This method will overwrite any previously set
 * authentication method.
 *
 * @param userCert the username to be used for RSA Digital signiture authentication
 * @param key the PrivateKey instance associated with the user ceritificate, used for
 * constructing the signature
 * @param serverRootCa the root certificate to be used for verifying the identity of the
 * server
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @throws IllegalArgumentException if any of the certificates were invalid or of an
 * unrecognized format
 */
","/**
 * Set the IKEv2 authentication to use Digital Signature Authentication with the given key.
 *
 * <p>Setting this will configure IKEv2 authentication using a Digital Signature scheme.
 * Only one authentication method may be set. This method will overwrite any previously set
 * authentication method.
 *
 * <p>If this {@link Builder} is constructed with an {@link IkeTunnelConnectionParams},
 * authentication details should be configured there, and calling this method will result in
 * an exception being thrown.
 *
 * @param userCert the username to be used for RSA Digital signiture authentication
 * @param key the PrivateKey instance associated with the user ceritificate, used for
 * constructing the signature
 * @param serverRootCa the root certificate to be used for verifying the identity of the
 * server
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @throws IllegalArgumentException if any of the certificates were invalid or of an
 * unrecognized format
 */
",1,"[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]","[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]",0,,,,,,,4,0,"The change in the method implementation consists of the addition of a new check with the checkBuilderSetter() method, which does not affect return values or exception handling; therefore, the code change type is 4.","The new check does not influence the method's return value or the exceptions it throws, as long as the conditions for the check are met (which are presumed to be met since it's a part of the builder setter validation). Thus, there is no Compatibility Issue, hence the CI type is 0."
151,<android.os.PersistableBundle: PersistableBundle deepCopy()>,32,33,,,,"{
    PersistableBundle b = new PersistableBundle(false);
    b.copyInternal(this, true);
    return b;
}","{
    return new PersistableBundle(this, /* deep */
    true);
}",1,"/**
 * Make a deep copy of the given bundle.  Traverses into inner containers and copies
 * them as well, so they are not shared across bundles.  Will traverse in to
 * {@link Bundle}, {@link PersistableBundle}, {@link ArrayList}, and all types of
 * primitive arrays.  Other types of objects (such as Parcelable or Serializable)
 * are referenced as-is and not copied in any way.
 */
","/**
 * Make a deep copy of the given bundle.  Traverses into inner containers and copies
 * them as well, so they are not shared across bundles.  Will traverse in to
 * {@link Bundle}, {@link PersistableBundle}, {@link ArrayList}, and all types of
 * primitive arrays.  Other types of objects (such as Parcelable or Serializable)
 * are referenced as-is and not copied in any way.
 */
",0,,,0,,,,,,,"4,5",0,"The implementation of the method has changed, where initially it was creating a new instance and then explicitly calling copyInternal, and in the late version it is calling a different constructor which presumably handles the deep copy internally. So, the change type is 4 for the different statement(s) usage, and 5 because it's likely that the constructor of PersistableBundle has changed to accommodate the new usage.","There is no Compatibility Issue here, since the end result of calling 'deepCopy()' is supposed to be a deep copy of the PersistableBundle regardless of the internal implementation differences, and the change does not affect the return type or the possibility of throwing different exceptions. The behavior, from an API user's standpoint, remains consistent â€“ they receive a deep copy of the original PersistableBundle. Hence, CI type is 0."
152,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",32,33,,,,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,"[@Override, @Deprecated]","[@Override, @Deprecated]",0,,,,,,,4,0,"There is a change in the arguments being passed to the method `ActivityManager.getService().broadcastIntentWithFeature()`. The value `AppOpsManager.OP_NONE` has changed positions, and `null` is added before it. This is an ""Other statement changed"" since it involves a change in the arguments of a method call, but it's not a control dependency, return statement, or exception handling statement change.","There is no Compatibility Issue in this change. While the arguments to the method call have shifted, this appears to be a refinement in parameter passing and does not imply a change in behavior that would lead to a different return value or an exception to be thrown because of these parameter changes. The actual handling of parameters within `broadcastIntentWithFeature()` would determine the effect, but based on the information available here, it does not suggest a change in the API's contract or how it's fundamentally used."
153,"<android.view.inputmethod.InputMethodManager: void doDump(FileDescriptor,PrintWriter,String[])>",32,33,,,,"{
    if (processDump(fd, args)) {
        return;
    }
    final Printer p = new PrintWriterPrinter(fout);
    p.println(""Input method client state for "" + this + "":"");
    p.println(""  mService="" + mService);
    p.println(""  mMainLooper="" + mMainLooper);
    p.println(""  mIInputContext="" + mIInputContext);
    p.println(""  mActive="" + mActive + "" mRestartOnNextWindowFocus="" + mRestartOnNextWindowFocus + "" mBindSequence="" + mBindSequence + "" mCurId="" + mCurId);
    p.println(""  mFullscreenMode="" + mFullscreenMode);
    if (mCurrentInputMethodSession != null) {
        p.println(""  mCurMethod="" + mCurrentInputMethodSession);
    } else {
        p.println(""  mCurMethod= null"");
    }
    p.println(""  mCurRootView="" + mCurRootView);
    p.println(""  mServedView="" + getServedViewLocked());
    p.println(""  mNextServedView="" + getNextServedViewLocked());
    p.println(""  mServedConnecting="" + mServedConnecting);
    if (mCurrentTextBoxAttribute != null) {
        p.println(""  mCurrentTextBoxAttribute:"");
        mCurrentTextBoxAttribute.dump(p, ""    "");
    } else {
        p.println(""  mCurrentTextBoxAttribute: null"");
    }
    p.println(""  mServedInputConnectionWrapper="" + mServedInputConnectionWrapper);
    p.println(""  mCompletions="" + Arrays.toString(mCompletions));
    p.println(""  mCursorRect="" + mCursorRect);
    p.println(""  mCursorSelStart="" + mCursorSelStart + "" mCursorSelEnd="" + mCursorSelEnd + "" mCursorCandStart="" + mCursorCandStart + "" mCursorCandEnd="" + mCursorCandEnd);
}","{
    if (processDump(fd, args)) {
        return;
    }
    final Printer p = new PrintWriterPrinter(fout);
    p.println(""Input method client state for "" + this + "":"");
    p.println(""  mService="" + mService);
    p.println(""  mMainLooper="" + mMainLooper);
    p.println(""  mFallbackInputConnection="" + mFallbackInputConnection);
    p.println(""  mActive="" + mActive + "" mRestartOnNextWindowFocus="" + mRestartOnNextWindowFocus + "" mBindSequence="" + mBindSequence + "" mCurId="" + mCurId);
    p.println(""  mFullscreenMode="" + mFullscreenMode);
    if (mCurrentInputMethodSession != null) {
        p.println(""  mCurMethod="" + mCurrentInputMethodSession);
    } else {
        p.println(""  mCurMethod= null"");
    }
    for (int i = 0; i < mAccessibilityInputMethodSession.size(); i++) {
        p.println(""  mAccessibilityInputMethodSession("" + mAccessibilityInputMethodSession.keyAt(i) + "")="" + mAccessibilityInputMethodSession.valueAt(i));
    }
    p.println(""  mCurRootView="" + mCurRootView);
    p.println(""  mServedView="" + getServedViewLocked());
    p.println(""  mNextServedView="" + getNextServedViewLocked());
    p.println(""  mServedConnecting="" + mServedConnecting);
    if (mCurrentTextBoxAttribute != null) {
        p.println(""  mCurrentTextBoxAttribute:"");
        mCurrentTextBoxAttribute.dump(p, ""    "");
    } else {
        p.println(""  mCurrentTextBoxAttribute: null"");
    }
    p.println(""  mServedInputConnection="" + mServedInputConnection);
    p.println(""  mServedInputConnectionHandler="" + mServedInputConnectionHandler);
    p.println(""  mCompletions="" + Arrays.toString(mCompletions));
    p.println(""  mCursorRect="" + mCursorRect);
    p.println(""  mCursorSelStart="" + mCursorSelStart + "" mCursorSelEnd="" + mCursorSelEnd + "" mCursorCandStart="" + mCursorCandStart + "" mCursorCandEnd="" + mCursorCandEnd);
}",1,,,0,,,0,,,,,,,"3,4",0,"The code has undergone some changes with the addition of new lines for printing properties that did not exist in the early version, such as 'mFallbackInputConnection', and the loop for 'mAccessibilityInputMethodSession'. A couple of print statements have been modified: 'mServedInputConnectionWrapper' has been replaced with two separate print statements 'mServedInputConnection' and 'mServedInputConnectionHandler'. These changes are categorized under type 4 as other statement changed and type 3 as they are under the same block scope but not directly related to control flow. ","All the changes are related to the debug information printed out to the `PrintWriter`. No actual logic of the method's operation has been altered, and there are no changes in the return type, thrown exceptions, or control flow that would affect the method's behavior during typical usage. The changes are relevant only when the method is used for dumping internal state for debugging purposes, which would not cause a compatibility issue in the conventional sense. Hence, no Compatibility Issue is predicted: 0."
155,<android.net.vcn.VcnGatewayConnectionConfig: int hashCode()>,32,33,,,,"{
    return Objects.hash(mGatewayConnectionName, mTunnelConnectionParams, mExposedCapabilities, Arrays.hashCode(mRetryIntervalsMs), mMaxMtu);
}","{
    return Objects.hash(mGatewayConnectionName, mTunnelConnectionParams, mExposedCapabilities, mUnderlyingNetworkTemplates, Arrays.hashCode(mRetryIntervalsMs), mMaxMtu);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The hashCode method now includes mUnderlyingNetworkTemplates in the Objects.hash calculation, which is an additional field. This constitutes a change to a statement that is not related to return, exception handling, or control flow, so the code change type is 4.","Since the hashCode method is expected to produce a different output when any part of the input changes, and since there's no difference in exception handling or control flow, adding a field to the Objects.hash call does not create compatibility issues; it's a change internal to the functionality of the hashCode method itself. Therefore, there's no compatibility issue, and the CI type is 0."
156,<android.hardware.SensorManager: Sensor getDefaultSensor(int)>,32,33,,,,"{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE || type == Sensor.TYPE_WRIST_TILT_GESTURE || type == Sensor.TYPE_DYNAMIC_SENSOR_META || type == Sensor.TYPE_HINGE_ANGLE) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}","{
    // TODO: need to be smarter, for now, just return the 1st sensor
    List<Sensor> l = getSensorList(type);
    boolean wakeUpSensor = false;
    // non_wake-up version.
    if (type == Sensor.TYPE_PROXIMITY || type == Sensor.TYPE_SIGNIFICANT_MOTION || type == Sensor.TYPE_TILT_DETECTOR || type == Sensor.TYPE_WAKE_GESTURE || type == Sensor.TYPE_GLANCE_GESTURE || type == Sensor.TYPE_PICK_UP_GESTURE || type == Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT || type == Sensor.TYPE_WRIST_TILT_GESTURE || type == Sensor.TYPE_DYNAMIC_SENSOR_META || type == Sensor.TYPE_HINGE_ANGLE) {
        wakeUpSensor = true;
    }
    for (Sensor sensor : l) {
        if (sensor.isWakeUpSensor() == wakeUpSensor)
            return sensor;
    }
    return null;
}",1,"/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
","/**
 * Use this method to get the default sensor for a given type. Note that the
 * returned sensor could be a composite sensor, and its data could be
 * averaged or filtered. If you need to access the raw sensors use
 * {@link SensorManager#getSensorList(int) getSensorList}.
 *
 * @param type
 * of sensors requested
 *
 * @return the default sensor matching the requested type if one exists and the application
 * has the necessary permissions, or null otherwise.
 *
 * @see #getSensorList(int)
 * @see Sensor
 */
",0,,,0,,,,,,,5,0,"The change involves an update to the condition within an if statement where a new constant is added (Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT) to the list of conditions that determine the value of wakeUpSensor. Therefore, the code change class is 5.","The change does not lead to a Compatibility Issue because the adjustment only affects the internal logic by adding one more condition to set the value of wakeUpSensor. This modification does not alter the function's signature, exception handling, control flow, or return type, and any new or removed return statements. It expands the number of sensor types that can affect the wakeUpSensor status, but for existing sensor types and functionality, behavior remains unchanged. Thus, no CI is introduced by this change."
157,<android.service.autofill.FillResponse.Builder: Builder setUserData(UserData)>,32,33,,,,"{
    throwIfDestroyed();
    throwIfAuthenticationCalled();
    mUserData = Preconditions.checkNotNull(userData);
    return this;
}","{
    throwIfDestroyed();
    throwIfAuthenticationCalled();
    mUserData = Objects.requireNonNull(userData);
    return this;
}",1,"/**
 * Sets a specific {@link UserData} for field classification for this request only.
 *
 * <p>Any fields in this UserData will override corresponding fields in the generic
 * UserData object
 *
 * @return this builder
 * @throws IllegalStateException if the FillResponse
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews)
 * requires authentication}.
 */
","/**
 * Sets a specific {@link UserData} for field classification for this request only.
 *
 * <p>Any fields in this UserData will override corresponding fields in the generic
 * UserData object
 *
 * @return this builder
 * @throws IllegalStateException if the FillResponse
 * {@link #setAuthentication(AutofillId[], IntentSender, Presentations)
 * requires authentication}.
 */
",1,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The assignment `mUserData = Preconditions.checkNotNull(userData);` has been changed to `mUserData = Objects.requireNonNull(userData);` which are functionally equivalent as both are used to check non-null conditions for an object. However, since this is a change in the method being used to perform the check, the code change type is 4. Furthermore, since `Preconditions.checkNotNull` and `Objects.requireNonNull` are other APIs that `setUserData` depends on, and we are seeing a switch from one to the other, type 5 also applies.","There is no Compatibility Issue because the replacement of `Preconditions.checkNotNull(userData)` with `Objects.requireNonNull(userData)` doesn't affect the behaviour of the `setUserData()` method. Both serve the same purpose, which is to ensure that the `userData` parameter is not null, and if it is, to throw a `NullPointerException`. There are no changes to the types of exceptions thrown or the value returned by this method, so the behaviour remains consistent."
159,<android.app.NotificationChannel: int hashCode()>,32,33,,,,"{
    int result = Objects.hash(getId(), getName(), mDesc, getImportance(), mBypassDnd, getLockscreenVisibility(), getSound(), mLights, getLightColor(), getUserLockedFields(), isFgServiceShown(), mVibrationEnabled, mShowBadge, isDeleted(), getDeletedTimeMs(), getGroup(), getAudioAttributes(), isBlockable(), mAllowBubbles, mImportanceLockedByOEM, mImportanceLockedDefaultApp, mOriginalImportance, mParentId, mConversationId, mDemoted, mImportantConvo);
    result = 31 * result + Arrays.hashCode(mVibration);
    return result;
}","{
    int result = Objects.hash(getId(), getName(), mDesc, getImportance(), mBypassDnd, getLockscreenVisibility(), getSound(), mLights, getLightColor(), getUserLockedFields(), isFgServiceShown(), mVibrationEnabled, mShowBadge, isDeleted(), getDeletedTimeMs(), getGroup(), getAudioAttributes(), isBlockable(), mAllowBubbles, mImportanceLockedDefaultApp, mOriginalImportance, mParentId, mConversationId, mDemoted, mImportantConvo);
    result = 31 * result + Arrays.hashCode(mVibration);
    return result;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The code change is related to the removal of the field mImportanceLockedByOEM from the Objects.hash() method call. This is classified as Other statement changed (code change type 4) since the expressions inside Objects.hash() method are altered, but it doesn't fall under return statement, exception handling, or control dependency change categories.","Although there is a change in the computation of the hashCode, it isn't a compatibility issue per se, as hashCode is not expected to stay the same across different versions of a class. It is inherent to the nature of the hashCode() method that different implementations may yield different hash codes. Therefore, there is no Compatibility Issue (CI type 0)."
160,<android.view.SurfaceView: void onDetachedFromWindow()>,32,33,,,,"{
    ViewRootImpl viewRoot = getViewRootImpl();
    // the SurfaceHolder forward, most live wallpapers do it.
    if (viewRoot != null) {
        viewRoot.removeSurfaceChangedCallback(this);
    }
    mAttachedToWindow = false;
    if (mGlobalListenersAdded) {
        ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnScrollChangedListener(mScrollChangedListener);
        observer.removeOnPreDrawListener(mDrawListener);
        mGlobalListenersAdded = false;
    }
    while (mPendingReportDraws > 0) {
        notifyDrawFinished();
    }
    mRequestedVisible = false;
    updateSurface();
    tryReleaseSurfaces();
    // detached.
    if (mSurfacePackage != null) {
        final SurfaceControl sc = mSurfacePackage.getSurfaceControl();
        if (sc != null && sc.isValid()) {
            mTmpTransaction.reparent(sc, null).apply();
        }
        mSurfacePackage.release();
        mSurfacePackage = null;
    }
    mHaveFrame = false;
    super.onDetachedFromWindow();
}","{
    ViewRootImpl viewRoot = getViewRootImpl();
    // the SurfaceHolder forward, most live wallpapers do it.
    if (viewRoot != null) {
        viewRoot.removeSurfaceChangedCallback(this);
    }
    mAttachedToWindow = false;
    if (mGlobalListenersAdded) {
        ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnScrollChangedListener(mScrollChangedListener);
        observer.removeOnPreDrawListener(mDrawListener);
        mGlobalListenersAdded = false;
    }
    mRequestedVisible = false;
    updateSurface();
    releaseSurfaces(true);
    mHaveFrame = false;
    super.onDetachedFromWindow();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The while loop checking `mPendingReportDraws` and the call to `tryReleaseSurfaces();` have been removed, and `releaseSurfaces(true);` has been added. This is a change in 'Other statements,' so the change type is 4.","Since no return or exception handling statements have been introduced or modified, there's no impact on the output value or exception raised by the API, and hence, no CI has been identified, which is type 0."
161,"<android.view.Choreographer.FrameDisplayEventReceiver: void onVsync(long,long,int,VsyncEventData)>",32,33,,,,"{
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#onVsync "" + vsyncEventData.id);
        }
        // Post the vsync event to the Handler.
        // The idea is to prevent incoming vsync events from completely starving
        // the message queue.  If there are no messages in the queue with timestamps
        // earlier than the frame time, then the vsync event will be processed immediately.
        // Otherwise, messages that predate the vsync event will be handled first.
        long now = System.nanoTime();
        if (timestampNanos > now) {
            Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
            timestampNanos = now;
        }
        if (mHavePendingVsync) {
            Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
        } else {
            mHavePendingVsync = true;
        }
        mTimestampNanos = timestampNanos;
        mFrame = frame;
        mLastVsyncEventData = vsyncEventData;
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}","{
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#onVsync "" + vsyncEventData.preferredFrameTimeline().vsyncId);
        }
        // Post the vsync event to the Handler.
        // The idea is to prevent incoming vsync events from completely starving
        // the message queue.  If there are no messages in the queue with timestamps
        // earlier than the frame time, then the vsync event will be processed immediately.
        // Otherwise, messages that predate the vsync event will be handled first.
        long now = System.nanoTime();
        if (timestampNanos > now) {
            Log.w(TAG, ""Frame time is "" + ((timestampNanos - now) * 0.000001f) + "" ms in the future!  Check that graphics HAL is generating vsync "" + ""timestamps using the correct timebase."");
            timestampNanos = now;
        }
        if (mHavePendingVsync) {
            Log.w(TAG, ""Already have a pending vsync event.  There should only be "" + ""one at a time."");
        } else {
            mHavePendingVsync = true;
        }
        mTimestampNanos = timestampNanos;
        mFrame = frame;
        mLastVsyncEventData = vsyncEventData;
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,"// for the internal display implicitly.
","// for the internal display implicitly.
",0,[@Override],[@Override],0,,,,,,,4,0,"The only change is within the Trace.traceBegin method argument from ""Choreographer#onVsync "" + vsyncEventData.id to ""Choreographer#onVsync "" + vsyncEventData.preferredFrameTimeline().vsyncId. This does not affect the control flow or the behavior of the method as it pertains to logging, so the change type is 4.",There is no Compatibility Issue as the change does not affect the output value or the exceptions that could be thrown by the method. The value of vsyncEventData.id and vsyncEventData.preferredFrameTimeline().vsyncId is mere detail for logging and does not alter the methodâ€™s functional behavior.
162,<android.view.KeyEvent: long getDownTime()>,32,33,,,,"{
    return mDownTime;
}","{
    return TimeUnit.MILLISECONDS.convert(mDownTime, TimeUnit.NANOSECONDS);
}",1,"/**
 * Retrieve the time of the most recent key down event,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.  If this
 * is a down event, this will be the same as {@link #getEventTime()}.
 * Note that when chording keys, this value is the down time of the
 * most recently pressed key, which may <em>not</em> be the same physical
 * key of this event.
 *
 * @return Returns the most recent key down time, in the
 * {@link android.os.SystemClock#uptimeMillis} time base
 */
","/**
 * Retrieve the time of the most recent key down event,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.  If this
 * is a down event, this will be the same as {@link #getEventTime()}.
 * Note that when chording keys, this value is the down time of the
 * most recently pressed key, which may <em>not</em> be the same physical
 * key of this event.
 *
 * @return Returns the most recent key down time, in the
 * {@link android.os.SystemClock#uptimeMillis} time base
 */
",0,,,0,,,,,,,"1,5",1,"The return statement has changed from returning the value of `mDownTime` directly to converting `mDownTime` from nanoseconds to milliseconds, involving a dependent API (TimeUnit.MILLISECONDS.convert), so the code change type is 1,5.","The change in the return statement, which now includes a unit conversion, means that the API could potentially return a different value (conversion of time units) if this method is called, leading to a change in behavior. As a result, the type of CI is 1."
163,<android.service.dreams.DreamService: boolean dispatchKeyShortcutEvent(KeyEvent)>,32,33,,,,"{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on keyShortcutEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}","{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(mTag, ""Waking up on keyShortcutEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The change is in the logging tag from `TAG` to `mTag`, which does not affect the behavior of the method regarding the returning values or exceptions. Therefore, this type of change is classified under 4: Other statement changed.","There is no Compatibility Issue regarding this change because it does not alter the returned value from the method or change the way exceptions are handled. The change only affects a logging statement, which is purely informational and has no impact on the method's behavior. The API will continue to interact with calling code the same way as before."
164,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",32,33,,,,"{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if (event.getRepeatCount() == 0) {
            // Long clickable items don't necessarily have to be clickable.
            final boolean clickable = (mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE;
            if (clickable || (mViewFlags & TOOLTIP) == TOOLTIP) {
                // For the purposes of menu anchoring and drawable hotspots,
                // key events are considered to be at the center of the view.
                final float x = getWidth() / 2f;
                final float y = getHeight() / 2f;
                if (clickable) {
                    setPressed(true, x, y);
                }
                checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, // This is not a touch gesture -- do not classify it as one.
                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__UNKNOWN_CLASSIFICATION);
                return true;
            }
        }
    }
    return false;
}","{
    if (KeyEvent.isConfirmKey(keyCode) && event.hasNoModifiers()) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if (event.getRepeatCount() == 0) {
            // Long clickable items don't necessarily have to be clickable.
            final boolean clickable = (mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE;
            if (clickable || (mViewFlags & TOOLTIP) == TOOLTIP) {
                // For the purposes of menu anchoring and drawable hotspots,
                // key events are considered to be at the center of the view.
                final float x = getWidth() / 2f;
                final float y = getHeight() / 2f;
                if (clickable) {
                    setPressed(true, x, y);
                }
                checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, // This is not a touch gesture -- do not classify it as one.
                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__UNKNOWN_CLASSIFICATION);
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 * <p>
 * Key presses in software keyboards will generally NOT trigger this
 * listener, although some may elect to do so in some situations. Do not
 * rely on this to catch software key presses.
 *
 * @param keyCode a key code that represents the button pressed, from
 * {@link android.view.KeyEvent}
 * @param event the KeyEvent object that defines the button action
 */
",0,,,0,,,,,,,3,1,An additional condition `event.hasNoModifiers()` has been added to the 'if' statement which adds a control dependency change type 3.,"Adding the condition `event.hasNoModifiers()` could potentially lead to a different return value, meaning the API could return false in cases where it previously would have returned true. Thus, the CI type is 1 due to the change in the return value."
165,"<android.app.Activity: void performResume(boolean,String)>",32,33,,,,"{
    if (Trace.isTagEnabled(Trace.TRACE_TAG_WINDOW_MANAGER)) {
        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, ""performResume:"" + mComponent.getClassName());
    }
    dispatchActivityPreResumed();
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    if (mAutoFillResetNeeded) {
        // When Activity is destroyed in paused state, and relaunch activity, there will be
        // extra onResume and onPause event,  ignore the first onResume and onPause.
        // see ActivityThread.handleRelaunchActivity()
        mAutoFillIgnoreFirstResumePause = followedByPause;
        if (mAutoFillIgnoreFirstResumePause && DEBUG_LIFECYCLE) {
            Slog.v(TAG, ""autofill will ignore first pause when relaunching "" + this);
        }
    }
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    EventLogTags.writeWmOnResumeCalled(mIdent, getComponentName().getClassName(), reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
    dispatchActivityPostResumed();
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
}","{
    if (Trace.isTagEnabled(Trace.TRACE_TAG_WINDOW_MANAGER)) {
        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, ""performResume:"" + mComponent.getClassName());
    }
    dispatchActivityPreResumed();
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    getAutofillClientController().onActivityPerformResume(followedByPause);
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    EventLogTags.writeWmOnResumeCalled(mIdent, getComponentName().getClassName(), reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume) completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
    dispatchActivityPostResumed();
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
}",1,,,0,,,0,,,,,,,4,0,"The only change in the code is the replacement of the block that handles autoFillResetNeeded with a single method call to getAutofillClientController().onActivityPerformResume(followedByPause). This change does not alter control flow, return values, or exception handling; it's a refactoring that replaces several lines with a single method call to potentially modularize the code better. So, the change type is 4.","There are no changes affecting return values or exception handling behavior. The method still performs the same overall function, with internal refactoring that should not affect external behavior. Thus, there is no Compatibility Issue; the code change does not inherently lead to a difference in the outward behavior of the method."
166,"<android.content.ContentProvider: boolean checkUser(int,int,Context)>",32,33,,,,"{
    if (UserHandle.getUserId(uid) == context.getUserId() || mSingleUser) {
        return true;
    }
    return context.checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PackageManager.PERMISSION_GRANTED || context.checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PackageManager.PERMISSION_GRANTED;
}","{
    final int callingUserId = UserHandle.getUserId(uid);
    if (callingUserId == context.getUserId() || mSingleUser) {
        return true;
    }
    if (context.checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PackageManager.PERMISSION_GRANTED || context.checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PackageManager.PERMISSION_GRANTED) {
        return true;
    }
    if (isAuthorityRedirectedForCloneProfile(mAuthority)) {
        if (mUsersRedirectedToOwner.indexOfKey(callingUserId) >= 0) {
            return mUsersRedirectedToOwner.get(callingUserId);
        }
        // Haven't seen this user yet, look it up
        try {
            UserHandle callingUser = UserHandle.getUserHandleForUid(uid);
            Context callingUserContext = mContext.createPackageContextAsUser(""system"", 0, callingUser);
            UserManager um = callingUserContext.getSystemService(UserManager.class);
            if (um != null && um.isCloneProfile()) {
                UserHandle parent = um.getProfileParent(callingUser);
                if (parent != null && parent.equals(myUserHandle())) {
                    mUsersRedirectedToOwner.put(callingUserId, true);
                    return true;
                }
            }
        } catch (PackageManager.NameNotFoundException e) {
        // ignore
        }
        mUsersRedirectedToOwner.put(callingUserId, false);
        return false;
    }
    return false;
}",1,,,0,,,0,,,,,,,"1,3,4,5","1,2","Changes between the versions include assigning the result of UserHandle.getUserId(uid) to a local variable callingUserId and restructuring of the control flow with new if conditions instead of returning the result of complex logical expressions directly. Additional logic is introduced to handle cases with isAuthorityRedirectedForCloneProfile(mAuthority) and user profile checks. These alterations involve control statement changes, new logic blocks (especially new if conditions and assignments), and additional exception handling. The dependent API UserManager is accessed and its method isCloneProfile() is used in the new code. Thus, we have multiple changes: 1, 3, 4, and 5.",The new implementation introduces multiple changes that could affect the return value and the exception handling path:
169,<android.content.pm.PackageInstaller.SessionInfo: boolean isStagedSessionFailed()>,32,33,,,,"{
    checkSessionIsStaged();
    return isStagedSessionFailed;
}","{
    checkSessionIsStaged();
    return isSessionFailed;
}",1,"/**
 * Whether something went wrong and the staged session is declared as failed, meaning that
 * it will be ignored at next reboot. Only meaningful if {@code isStaged} is true.
 */
","/**
 * Whether something went wrong and the staged session is declared as failed, meaning that
 * it will be ignored at next reboot. Only meaningful if {@code isStaged} is true.
 */
",0,,,0,,,,,,,"1,5",1,"The return statement has been changed from returning the value of `isStagedSessionFailed` to `isSessionFailed`, which are different fields. This can affect the API behavior and potentially reflects a change in the dependent API if the meaning or the conditions under which these fields are set have changed. So the code change type is 1,5.","Changing the returned field from `isStagedSessionFailed` to `isSessionFailed` could potentially lead to the API returning a different value than before, if the semantics of these fields are different. Thus, there is a potential compatibility issue due to a different return value, and the CI type is 1."
171,<android.view.Display: void getRealSize(Point)>,32,33,,,,"{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (shouldReportMaxBounds()) {
            final Rect bounds = mResources.getConfiguration().windowConfiguration.getMaxBounds();
            outSize.x = bounds.width();
            outSize.y = bounds.height();
            if (DEBUG) {
                Log.d(TAG, ""getRealSize determined from max bounds: "" + outSize);
            }
            // should already reflect the expected rotation.
            return;
        }
        outSize.x = mDisplayInfo.logicalWidth;
        outSize.y = mDisplayInfo.logicalHeight;
        if (mMayAdjustByFixedRotation) {
            getDisplayAdjustments().adjustSize(outSize, mDisplayInfo.rotation);
        }
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (shouldReportMaxBounds()) {
            final Rect bounds = mResources.getConfiguration().windowConfiguration.getMaxBounds();
            outSize.x = bounds.width();
            outSize.y = bounds.height();
            if (DEBUG) {
                Log.d(TAG, ""getRealSize determined from max bounds: "" + outSize);
            }
            // should already reflect the expected rotation.
            return;
        }
        outSize.x = mDisplayInfo.logicalWidth;
        outSize.y = mDisplayInfo.logicalHeight;
        @Surface.Rotation final int rotation = getLocalRotation();
        if (rotation != mDisplayInfo.rotation) {
            adjustSize(outSize, mDisplayInfo.rotation, rotation);
        }
    }
}",1,"/**
 * Gets the size of the largest region of the display accessible to an app in the current system
 * state, without subtracting any window decor or applying scaling factors.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * <p></p>
 * The returned size will fall into one of these scenarios:
 * <ol>
 * <li>The device has no partitions on the display. The returned value is the largest region
 * of the display accessible to an app in the current system state, regardless of windowing
 * mode.</li>
 * <li>The device divides a single display into multiple partitions. An application is
 * restricted to a portion of the display. This is common in devices where the display changes
 * size, such as foldables or large screens. The returned size will match the portion of
 * the display the application is restricted to.</li>
 * <li>The window manager is emulating a different display size, using {@code adb shell wm
 * size}. The returned size will match the emulated display size.</li>
 * </ol>
 * </p><p>
 * The returned value is <b>unsuitable to use when sizing and placing UI elements</b>, since it
 * does not reflect the application window size in any of these scenarios.
 * {@link WindowManager#getCurrentWindowMetrics()} is an alternative that returns the size
 * of the current application window, even if the window is on a device with a partitioned
 * display. This helps prevent UI bugs where UI elements are misaligned or placed beyond the
 * bounds of the window.
 * <p></p>
 * Handling multi-window mode correctly is necessary since applications are not always
 * fullscreen. A user on a large screen device, such as a tablet or Chrome OS devices, is more
 * likely to use multi-window modes.
 * <p></p>
 * For example, consider a device with a display partitioned into two halves. The user may have
 * a fullscreen application open on the first partition. They may have two applications open in
 * split screen (an example of multi-window mode) on the second partition, with each application
 * consuming half of the partition. In this case,
 * {@link WindowManager#getCurrentWindowMetrics()} reports the fullscreen window is half of the
 * screen in size, and each split screen window is a quarter of the screen in size. On the other
 * hand, {@link #getRealSize} reports half of the screen size for all windows, since the
 * application windows are all restricted to their respective partitions.
 * </p>
 *
 * @param outSize Set to the real size of the display.
 * @deprecated Use {@link WindowManager#getCurrentWindowMetrics()} to identify the current size
 * of the activity window. UI-related work, such as choosing UI layouts, should rely
 * upon {@link WindowMetrics#getBounds()}.
 */
","/**
 * Gets the size of the largest region of the display accessible to an app in the current system
 * state, without subtracting any window decor or applying scaling factors.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * <p></p>
 * The returned size will fall into one of these scenarios:
 * <ol>
 * <li>The device has no partitions on the display. The returned value is the largest region
 * of the display accessible to an app in the current system state, regardless of windowing
 * mode.</li>
 * <li>The device divides a single display into multiple partitions. An application is
 * restricted to a portion of the display. This is common in devices where the display changes
 * size, such as foldables or large screens. The returned size will match the portion of
 * the display the application is restricted to.</li>
 * <li>The window manager is emulating a different display size, using {@code adb shell wm
 * size}. The returned size will match the emulated display size.</li>
 * </ol>
 * </p><p>
 * The returned value is <b>unsuitable to use when sizing and placing UI elements</b>, since it
 * does not reflect the application window size in any of these scenarios.
 * {@link WindowManager#getCurrentWindowMetrics()} is an alternative that returns the size
 * of the current application window, even if the window is on a device with a partitioned
 * display. This helps prevent UI bugs where UI elements are misaligned or placed beyond the
 * bounds of the window.
 * <p></p>
 * Handling multi-window mode correctly is necessary since applications are not always
 * fullscreen. A user on a large screen device, such as a tablet or Chrome OS devices, is more
 * likely to use multi-window modes.
 * <p></p>
 * For example, consider a device with a display partitioned into two halves. The user may have
 * a fullscreen application open on the first partition. They may have two applications open in
 * split screen (an example of multi-window mode) on the second partition, with each application
 * consuming half of the partition. In this case,
 * {@link WindowManager#getCurrentWindowMetrics()} reports the fullscreen window is half of the
 * screen in size, and each split screen window is a quarter of the screen in size. On the other
 * hand, {@link #getRealSize} reports half of the screen size for all windows, since the
 * application windows are all restricted to their respective partitions.
 * </p>
 *
 * @param outSize Set to the real size of the display.
 * @deprecated Use {@link WindowManager#getCurrentWindowMetrics()} to identify the current size
 * of the activity window. UI-related work, such as choosing UI layouts, should rely
 * upon {@link WindowMetrics#getBounds()}.
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,"3,5",0,"The control dependency within the 'if' block has changed with the addition of a new local variable 'rotation' and an ""if"" statement to check for a change in rotation. Also, the call to 'getDisplayAdjustments().adjustSize()' was replaced with a direct call to 'adjustSize()', which indicates a change within the dependent API, so the code change type is 3,5.","Though the implementation has changed, these changes do not alter the behavior that would affect the API's contract in terms of returning different values or throwing different exceptions. The logic within the 'if' block only adjusts the size if the rotation has changed. If no rotation change occurred, it would behave as it did previously. The update is an internal enhancement for handling rotation changes. Since behavior and exceptions thrown remain consistent with the previous version, there is no Compatibility Issue; hence the CI type is 0."
173,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",32,33,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,"[@Override, @Deprecated]","[@Override, @Deprecated]",0,,,,,,,4,0,"The order of the parameters in the call to broadcastIntentWithFeature has changed, specifically the position of the 'excludedPermissions' parameter, but it appears that the proper values are still being passed to the same parameters, so no change in functionality should arise from this alteration. Therefore, the code change type is 4.","There is no change to the API that would lead to a different value being returned, or a different exception being thrown, hence no compatibility issue should arise from this change, so the CI type is 0."
176,<android.os.UserManager: Bundle getApplicationRestrictions(String)>,32,33,,,,"{
    try {
        return mService.getApplicationRestrictions(packageName);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getApplicationRestrictionsForUser(packageName, getContextUserIfAppropriate());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns a {@link Bundle} containing any saved application restrictions for this user, for the
 * given package name. Only an application with this package name can call this method.
 *
 * <p>The returned {@link Bundle} consists of key-value pairs, as defined by the application,
 * where the types of values may be:
 * <ul>
 * <li>{@code boolean}
 * <li>{@code int}
 * <li>{@code String} or {@code String[]}
 * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 * </ul>
 *
 * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread
 *
 * @param packageName the package name of the calling application
 * @return a {@link Bundle} with the restrictions for that package, or an empty {@link Bundle}
 * if there are no saved restrictions.
 *
 * @see #KEY_RESTRICTIONS_PENDING
 */
","/**
 * Returns a {@link Bundle} containing any saved application restrictions for the context user,
 * for the given package name. Only an application with this package name can call this method.
 *
 * <p>The returned {@link Bundle} consists of key-value pairs, as defined by the application,
 * where the types of values may be:
 * <ul>
 * <li>{@code boolean}
 * <li>{@code int}
 * <li>{@code String} or {@code String[]}
 * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}
 * </ul>
 *
 * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread
 *
 * @param packageName the package name of the calling application
 * @return a {@link Bundle} with the restrictions for that package, or an empty {@link Bundle}
 * if there are no saved restrictions.
 *
 * @see #KEY_RESTRICTIONS_PENDING
 */
",1,[@WorkerThread],"[@WorkerThread, @UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU)]",1,,,,,,,5,0,"The method `mService.getApplicationRestrictions()` has been changed to `mService.getApplicationRestrictionsForUser()` with an additional parameter `getContextUserIfAppropriate()`. Hence, there is a change in the dependent API which is classified as type 5.","Although the dependent API has changed, since it's an addition of a method that possibly retrieves a context-sensitive user, and assuming `getContextUserIfAppropriate()` effectively returns the correct user context that aligns with the one implicitly used in the earlier API, it won't result in a different return value or type from the `getApplicationRestrictions()` method as seen from the caller's perspective. Thus, there's no compatibility issue with respect to potential different return values or types (0). The exception handling logic remains unchanged as well, hence no compatibility issue with respect to potential different exception handlings (0)."
177,<android.content.pm.ShortcutManager: boolean addDynamicShortcuts(List<ShortcutInfo>)>,32,33,,,,"{
    try {
        return (boolean) getFutureOrThrow(mService.addDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.addDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with
 * the same IDs, each mutable shortcut is updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with
 * the same IDs, each mutable shortcut is updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,[@WorkerThread],[@WorkerThread],0,,,,,,,4,0,"The change consists of removing an explicit cast to boolean, which is redundant considering that the method 'addDynamicShortcuts' already returns a boolean. This is why the code change type is 4.","There is no Compatibility Issue since the return type remains the same and an unnecessary explicit cast does not affect the API's behavior. Hence, the behavior remains unchanged for the client."
178,<android.view.accessibility.AccessibilityRecord: void recycle()>,32,33,,,,"{
    if (mIsInPool) {
        throw new IllegalStateException(""Record already recycled!"");
    }
    clear();
    synchronized (sPoolLock) {
        if (sPoolSize <= MAX_POOL_SIZE) {
            mNext = sPool;
            sPool = this;
            mIsInPool = true;
            sPoolSize++;
        }
    }
}","{
}",1,"/**
 * Return an instance back to be reused.
 * <p>
 * <strong>Note:</strong> You must not touch the object after calling this function.
 *
 * <p>In most situations object pooling is not beneficial, and recycling is not necessary.
 *
 * @throws IllegalStateException If the record is already recycled.
 */
","/**
 * Would previously return an instance back to be reused.
 *
 * @deprecated Object pooling has been discontinued. Calling this function now will have
 * no effect.
 */
",1,,[@Deprecated],1,,,,,,,4,0,"The entire implementation of the method 'recycle()' has been removed, which falls under 'Other statement changed' because it's neither a return statement change, exception handling statement change, control dependency change, nor a dependent API change.","There is no Compatibility Issue because the method has been deprecated, and its functionality has been removed. Any existing calls to this method will now do nothing instead of performing the recycling logic, which is well-communicated to the developers by the deprecation annotation. Thus, no unexpected behavior is introduced; if developers respond correctly to the deprecation notice, there are no compatibility concerns."
180,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",32,33,,,,"{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    Bundle extras = (cookie != null) ? (Bundle) cookie : new Bundle();
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && mContactUri != null) {
        // Found contact, so trigger QuickContact
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, mExcludeMimes, mPrioritizedMimeType);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        if (extras != null) {
            extras.remove(EXTRA_URI_CONTENT);
            intent.putExtras(extras);
        }
        getContext().startActivity(intent);
    }
}","{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    Bundle extras = (cookie != null) ? (Bundle) cookie : new Bundle();
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", extras.getString(EXTRA_URI_CONTENT), null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && mContactUri != null) {
        // Found contact, so trigger QuickContact
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, mExcludeMimes, mPrioritizedMimeType);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        if (extras != null) {
            Bundle bundle = new Bundle(extras);
            bundle.remove(EXTRA_URI_CONTENT);
            intent.putExtras(bundle);
        }
        getContext().startActivity(intent);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change in the late implementation involves the creation of a new Bundle from 'extras' before removing 'EXTRA_URI_CONTENT', instead of removing 'EXTRA_URI_CONTENT' directly from 'extras'. So, the code change type is 4.","There is no Compatibility Issue detected because both, the behavior to end users and the outcome of the method, remain unchanged. The alteration only affects the internal handling of the Bundle, not the external API behavior or the data returned by it."
181,"<android.os.SystemVibrator.AllVibratorsStateListener: void onVibrating(int,boolean)>",32,33,,,,"{
    mExecutor.execute(() -> {
        boolean anyVibrating;
        synchronized (mLock) {
            int allInitializedMask = 1 << mVibratorListeners.size() - 1;
            int vibratorMask = 1 << vibratorIdx;
            if ((mInitializedMask & vibratorMask) == 0) {
                // First state report for this vibrator, set vibrating initial value.
                mInitializedMask |= vibratorMask;
                mVibratingMask |= vibrating ? vibratorMask : 0;
            } else {
                // Flip vibrating value, if changed.
                boolean prevVibrating = (mVibratingMask & vibratorMask) != 0;
                if (prevVibrating != vibrating) {
                    mVibratingMask ^= vibratorMask;
                }
            }
            if (mInitializedMask != allInitializedMask) {
                // Wait for all vibrators initial state to be reported before delegating.
                return;
            }
            anyVibrating = mVibratingMask != 0;
        }
        mDelegate.onVibratorStateChanged(anyVibrating);
    });
}","{
    mExecutor.execute(() -> {
        boolean anyVibrating;
        synchronized (mLock) {
            int allInitializedMask = (1 << mVibratorListeners.size()) - 1;
            int vibratorMask = 1 << vibratorIdx;
            if ((mInitializedMask & vibratorMask) == 0) {
                // First state report for this vibrator, set vibrating initial value.
                mInitializedMask |= vibratorMask;
                mVibratingMask |= vibrating ? vibratorMask : 0;
            } else {
                // Flip vibrating value, if changed.
                boolean prevVibrating = (mVibratingMask & vibratorMask) != 0;
                if (prevVibrating != vibrating) {
                    mVibratingMask ^= vibratorMask;
                }
            }
            if (mInitializedMask != allInitializedMask) {
                // Wait for all vibrators initial state to be reported before delegating.
                return;
            }
            anyVibrating = mVibratingMask != 0;
        }
        mDelegate.onVibratorStateChanged(anyVibrating);
    });
}",1,,,0,,,0,,,,,,,4,0,"The only code change is a tweak of arithmetic operation precedence in the expression `1 << mVibratorListeners.size() - 1` which is changed to `(1 << mVibratorListeners.size()) - 1`, which corrects the mask calculation. This change doesn't lead to a different behavior because it is fixing an apparent bug, since originally the `- 1` would be applied before the left shift, resulting in an incorrect initialization mask. The `1 << mVibratorListeners.size()` should be completely shifted before subtracting 1 to set all bits to 1 for the intended size. It's categorized as 4, Other statement changed.","This bug fix does not introduce a compatibility issue but rather corrects prior incorrect behavior. Therefore, there is no compatibility issue; hence the CI type is 0."
182,<android.net.Ikev2VpnProfile: String getPassword()>,32,33,,,,"{
    return mPassword;
}","{
    if (mIkeTunConnParams != null)
        return null;
    return mPassword;
}",1,"/**
 * Retrieves the password.
 *
 * <p>May be null if the profile is not using Username/Password authentication
 */
","/**
 * Retrieves the password.
 *
 * <p>May be null if the profile is not using Username/Password authentication, or the profile
 * is built from an {@link IkeTunnelConnectionParams}.
 */
",1,[@Nullable],[@Nullable],0,,,,,,,"1,3",1,"There is an introduction of a control dependency (an 'if' statement) and a new return statement that potentially returns a different value (null), so the change type is 1,3.","The new 'if' statement introduces a scenario where 'null' can be returned before returning 'mPassword', which is a behavior change that can potentially lead to a different return value. Therefore, the CI type is 1."
183,<android.database.sqlite.SQLiteDatabase: void disableWriteAheadLogging()>,32,33,,,,"{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        final int oldFlags = mConfigurationLocked.openFlags;
        final boolean walEnabled = (oldFlags & ENABLE_WRITE_AHEAD_LOGGING) != 0;
        final boolean compatibilityWalEnabled = (oldFlags & ENABLE_LEGACY_COMPATIBILITY_WAL) != 0;
        // WAL was never enabled for this database, so there's nothing left to do.
        if (!walEnabled && !compatibilityWalEnabled) {
            return;
        }
        // If an app explicitly disables WAL, it takes priority over any directive
        // to use the legacy ""compatibility WAL"" mode.
        mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
        mConfigurationLocked.openFlags &= ~ENABLE_LEGACY_COMPATIBILITY_WAL;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags = oldFlags;
            throw ex;
        }
    }
}","{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        final int oldFlags = mConfigurationLocked.openFlags;
        // WAL was never enabled for this database, so there's nothing left to do.
        if (!mConfigurationLocked.resolveJournalMode().equalsIgnoreCase(SQLiteDatabase.JOURNAL_MODE_WAL)) {
            return;
        }
        // If an app explicitly disables WAL, it takes priority over any directive
        // to use the legacy ""compatibility WAL"" mode.
        mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
        mConfigurationLocked.openFlags &= ~ENABLE_LEGACY_COMPATIBILITY_WAL;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags = oldFlags;
            throw ex;
        }
    }
}",1,"/**
 * This method disables the features enabled by {@link #enableWriteAheadLogging()}.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #enableWriteAheadLogging
 */
","/**
 * This method disables the features enabled by {@link #enableWriteAheadLogging()}.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #enableWriteAheadLogging
 */
",0,,,0,,,,,,,"3,4,5",0,"There is a deletion of two boolean variables 'walEnabled' and 'compatibilityWalEnabled', and the condition check for disabling write-ahead logging (WAL) has been changed to a single condition that uses the resolveJournalMode().equalsIgnoreCase() method to determine if WAL is enabled. The dependent method resolveJournalMode() is used instead of directly checking the openFlags, which implies a change to Dependent API. This together constitutes a change of control dependency, other statement change since variables have been removed, and dependent API changed. Therefore, the code change types are 3, 4, and 5.","There is no Compatibility Issue as there is no change in the API's overall behavior; all changes are internal, and the outcome remains the sameâ€”to disable write-ahead logging if it is enabled. The way the check is performed has been modified, but it doesn't affect the final behavior of this method from the caller's perspective. Hence, the CI type is 0."
184,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,32,33,,,,"{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        case DO_NOTIFY_IME_HIDDEN:
            {
                mInputMethodSession.notifyImeHidden();
                return;
            }
        case DO_REMOVE_IME_SURFACE:
            {
                mInputMethodSession.removeImeSurface();
                return;
            }
        case DO_FINISH_INPUT:
            {
                mInputMethodSession.finishInput();
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        case DO_REMOVE_IME_SURFACE:
            {
                mInputMethodSession.removeImeSurface();
                return;
            }
        case DO_FINISH_INPUT:
            {
                mInputMethodSession.finishInput();
                return;
            }
        case DO_INVALIDATE_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                try {
                    mInputMethodSession.invalidateInputInternal((EditorInfo) args.arg1, (IInputContext) args.arg2, msg.arg1);
                } finally {
                    args.recycle();
                }
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"A new case (DO_INVALIDATE_INPUT) has been added to the switch statement, and that includes new method calls with parameters that may cause a change in behavior. Additionally, the new case handles the recycling of SomeArgs, which is an internal change that is not exposed in the return type or exception throws, and there is a change in the log message. Hence, the code change type is 1,3,4.","Added code within the switch-case block can cause a change in behavior as it introduces a new feature or method call that was not present in the earlier version. This change could lead to the API returning a different value or type when the DO_INVALIDATE_INPUT case is encountered, exemplifying a CI type of 1."
185,"<android.service.autofill.CustomDescription.Builder: Builder batchUpdate(Validator,BatchUpdates)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkArgument((condition instanceof InternalValidator), ""not provided by Android System: %s"", condition);
    Preconditions.checkNotNull(updates);
    if (mUpdates == null) {
        mUpdates = new ArrayList<>();
    }
    mUpdates.add(new Pair<>((InternalValidator) condition, updates));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument((condition instanceof InternalValidator), ""not provided by Android System: %s"", condition);
    Objects.requireNonNull(updates);
    if (mUpdates == null) {
        mUpdates = new ArrayList<>();
    }
    mUpdates.add(new Pair<>((InternalValidator) condition, updates));
    return this;
}",1,"/**
 * Updates the {@link RemoteViews presentation template} when a condition is satisfied by
 * applying a series of remote view operations. This allows dynamic customization of the
 * portion of the save UI that is controlled by the autofill service. Such dynamic
 * customization is based on the content of target views.
 *
 * <p>The updates are applied in the sequence they are added, after the
 * {@link #addChild(int, Transformation) transformations} are applied to the children
 * views.
 *
 * <p>For example, to make children views visible when fields are not empty:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_full_template);
 *
 * Pattern notEmptyPattern = Pattern.compile("".+"");
 * Validator hasAddress = new RegexValidator(addressAutofillId, notEmptyPattern);
 * Validator hasCcNumber = new RegexValidator(ccNumberAutofillId, notEmptyPattern);
 *
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * addressUpdates.setViewVisibility(R.id.address, View.VISIBLE);
 *
 * // Make address visible
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * ccUpdates.setViewVisibility(R.id.cc_number, View.VISIBLE);
 *
 * // Mask credit card number (as .....LAST_4_DIGITS) and make it visible
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * <p>Another approach is to add a child first, then apply the transformations. Example:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_base_template);
 *
 * RemoteViews addressPresentation = new RemoteViews(pgkName, R.layout.address)
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * addressUpdates.addView(R.id.parentId, addressPresentation);
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccPresentation = new RemoteViews(pgkName, R.layout.cc)
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * ccUpdates.addView(R.id.parentId, ccPresentation);
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * @param condition condition used to trigger the updates.
 * @param updates actions to be applied to the
 * {@link #Builder(RemoteViews) template presentation} when the condition
 * is satisfied.
 *
 * @return this builder
 *
 * @throws IllegalArgumentException if {@code condition} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
","/**
 * Updates the {@link RemoteViews presentation template} when a condition is satisfied by
 * applying a series of remote view operations. This allows dynamic customization of the
 * portion of the save UI that is controlled by the autofill service. Such dynamic
 * customization is based on the content of target views.
 *
 * <p>The updates are applied in the sequence they are added, after the
 * {@link #addChild(int, Transformation) transformations} are applied to the children
 * views.
 *
 * <p>For example, to make children views visible when fields are not empty:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_full_template);
 *
 * Pattern notEmptyPattern = Pattern.compile("".+"");
 * Validator hasAddress = new RegexValidator(addressAutofillId, notEmptyPattern);
 * Validator hasCcNumber = new RegexValidator(ccNumberAutofillId, notEmptyPattern);
 *
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * addressUpdates.setViewVisibility(R.id.address, View.VISIBLE);
 *
 * // Make address visible
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * ccUpdates.setViewVisibility(R.id.cc_number, View.VISIBLE);
 *
 * // Mask credit card number (as .....LAST_4_DIGITS) and make it visible
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * <p>Another approach is to add a child first, then apply the transformations. Example:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_base_template);
 *
 * RemoteViews addressPresentation = new RemoteViews(pgkName, R.layout.address)
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * addressUpdates.addView(R.id.parentId, addressPresentation);
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccPresentation = new RemoteViews(pgkName, R.layout.cc)
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * ccUpdates.addView(R.id.parentId, ccPresentation);
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * @param condition condition used to trigger the updates.
 * @param updates actions to be applied to the
 * {@link #Builder(RemoteViews) template presentation} when the condition
 * is satisfied.
 *
 * @return this builder
 *
 * @throws IllegalArgumentException if {@code condition} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,The code change is that `Preconditions.checkNotNull(updates)` has been replaced with `Objects.requireNonNull(updates)`. This is an example of code change type 4 since this modification is an API change that does not affect control flow or exception handling.,"There's no Compatibility Issue here because `Preconditions.checkNotNull(updates)` and `Objects.requireNonNull(updates)` do essentially the same thing â€“ they both throw a `NullPointerException` if the `updates` object is null. Thus, there is no change in the API's behavior in terms of exception throwing or return values."
186,"<android.hardware.camera2.impl.CameraExtensionSessionImpl: int capture(CaptureRequest,Executor,ExtensionCaptureCallback)>",32,33,,,,"{
    if (!mInitialized) {
        throw new IllegalStateException(""Uninitialized component"");
    }
    if (mClientCaptureSurface == null) {
        throw new IllegalArgumentException(""No output surface registered for single requests!"");
    }
    if (!request.containsTarget(mClientCaptureSurface) || (request.getTargets().size() != 1)) {
        throw new IllegalArgumentException(""Invalid single capture output target!"");
    }
    HashMap<CaptureRequest, Integer> requestMap = new HashMap<>();
    List<CaptureRequest> burstRequest;
    try {
        burstRequest = createBurstRequest(mCameraDevice, mImageExtender.getCaptureStages(), request, mCameraBurstSurface, CameraDevice.TEMPLATE_STILL_CAPTURE, requestMap);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to initialize internal burst request! Extension service does"" + "" not respond!"");
        throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
    }
    if (burstRequest == null) {
        throw new UnsupportedOperationException(""Failed to create still capture burst request"");
    }
    return mCaptureSession.captureBurstRequests(burstRequest, new CameraExtensionUtils.HandlerExecutor(mHandler), new BurstRequestHandler(request, executor, listener, requestMap, mBurstCaptureImageCallback));
}","{
    if (!mInitialized) {
        throw new IllegalStateException(""Uninitialized component"");
    }
    if (request.getTargets().size() != 1) {
        throw new IllegalArgumentException(""Single capture to both preview & still capture "" + ""outputs target is not supported!"");
    }
    int seqId = -1;
    if ((mClientCaptureSurface != null) && request.containsTarget(mClientCaptureSurface)) {
        HashMap<CaptureRequest, Integer> requestMap = new HashMap<>();
        List<CaptureRequest> burstRequest;
        try {
            burstRequest = createBurstRequest(mCameraDevice, mImageExtender.getCaptureStages(), request, mCameraBurstSurface, CameraDevice.TEMPLATE_STILL_CAPTURE, requestMap);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to initialize internal burst request! Extension service does"" + "" not respond!"");
            throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
        }
        if (burstRequest == null) {
            throw new UnsupportedOperationException(""Failed to create still capture burst request"");
        }
        seqId = mCaptureSession.captureBurstRequests(burstRequest, new CameraExtensionUtils.HandlerExecutor(mHandler), new BurstRequestHandler(request, executor, listener, requestMap, mBurstCaptureImageCallback));
    } else if ((mClientRepeatingRequestSurface != null) && request.containsTarget(mClientRepeatingRequestSurface)) {
        CaptureRequest captureRequest = null;
        try {
            ArrayList<CaptureStageImpl> captureStageList = new ArrayList<>();
            captureStageList.add(mPreviewExtender.getCaptureStage());
            captureRequest = createRequest(mCameraDevice, captureStageList, mCameraRepeatingSurface, CameraDevice.TEMPLATE_PREVIEW, request);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to initialize capture request! Extension service does"" + "" not respond!"");
            throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
        }
        seqId = mCaptureSession.capture(captureRequest, new PreviewRequestHandler(request, executor, listener, mRepeatingRequestImageCallback, true), mHandler);
    } else {
        throw new IllegalArgumentException(""Capture request to unknown output surface!"");
    }
    return seqId;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"The changes include modifications to the exception messages thrown, an additional condition check for request.getTargets(), restructuring of the control logic with the introduction of an 'else if' clause, and changing the logic to handle two different types of capture requests. These changes include altering the return value, introducing a new variable 'seqId', and altering the flow of the method. Therefore, the change type is 1,3,4.","The restructuring of the method can lead to a different return value, as well as a potential different control flow depending on the conditions of the input parameters. As a result, the behavior of the method may change, which means that the CI type is 1."
187,<android.widget.RemoteViews.BitmapCache: int getBitmapId(Bitmap)>,32,33,,,,"{
    if (b == null) {
        return -1;
    } else {
        if (mBitmaps.contains(b)) {
            return mBitmaps.indexOf(b);
        } else {
            mBitmaps.add(b);
            mBitmapMemory = -1;
            return (mBitmaps.size() - 1);
        }
    }
}","{
    if (b == null) {
        return -1;
    } else {
        int hash = b.hashCode();
        int hashId = mBitmapHashes.get(hash, -1);
        if (hashId != -1) {
            return hashId;
        } else {
            if (b.isMutable()) {
                b = b.asShared();
            }
            mBitmaps.add(b);
            mBitmapHashes.put(mBitmaps.size() - 1, hash);
            mBitmapMemory = -1;
            return (mBitmaps.size() - 1);
        }
    }
}",1,,,0,,,0,,,,,,,"1,3,4,5",1,"There are several changes between the early and late versions. New statements have been introduced, which include a different approach to checking for the bitmap's presence in the cache using its hash code (`int hash = b.hashCode(); int hashId = mBitmapHashes.get(hash, -1);`), modifying the logic to when to add a bitmap to mBitmaps (check `b.isMutable()` and potentially create a shared copy of the bitmap via `b = b.asShared();`), and updating `mBitmapHashes` with the hash of the bitmap. These changes involve modifications in control dependency (checking `b.isMutable()`), return statement (because now the value being returned can be different due to the new logic), an alteration in the behavior with other statements, and dependent API changes since `b.asShared()` and `mBitmapHashes.put` are new method calls. Therefore, the change types are 1,3,4,5.","The implementation change leads to a potential different return value. In the early version, the return value is solely based on the `mBitmaps` list, but in the late version, it also considers the `mBitmapHashes` map, which introduces new logic to determine the return value. The b.isMutable() check and subsequent call to b.asShared() can alter the instance being added to mBitmaps, affecting the return value. Therefore, the compatibility issue is due to potentially different return values, and the CI type is 1."
188,"<android.os.BatteryConsumer.BaseBuilder: T setUsageDurationMillis(int,long)>",32,33,,,,"{
    mPowerComponentsBuilder.setUsageDurationMillis(componentId, componentUsageTimeMillis);
    return (T) this;
}","{
    mPowerComponentsBuilder.setUsageDurationMillis(getKey(componentId, PROCESS_STATE_UNSPECIFIED), componentUsageTimeMillis);
    return (T) this;
}",1,"/**
 * Sets the amount of time used by the specified component, e.g. CPU, WiFi etc.
 *
 * @param componentId              The ID of the power component, e.g.
 * {@link UidBatteryConsumer#POWER_COMPONENT_CPU}.
 * @param componentUsageTimeMillis Amount of time in microseconds.
 */
","/**
 * Sets the amount of time used by the specified component, e.g. CPU, WiFi etc.
 *
 * @param componentId              The ID of the power component, e.g.
 * {@link UidBatteryConsumer#POWER_COMPONENT_CPU}.
 * @param componentUsageTimeMillis Amount of time in microseconds.
 */
",0,"[@SuppressWarnings(""unchecked""), @NonNull]","[@SuppressWarnings(""unchecked""), @NonNull]",0,,,,,,,"4,5",0,"The code change involves a modification where `getKey(componentId, PROCESS_STATE_UNSPECIFIED)` is used instead of the direct usage of `componentId`, which implies that there is a change in how the `componentId` is being processed or retrieved inside the method. This change type is classified as an ""Other statement changed"" as well as ""Dependent API changed"" because it's involving a change in the method implementation that doesn't fit in the other categories, but the overall contract of the method is preserved by returning the same type and presumably for the same purpose, and it relies on the behavior of the `getKey` method.","Despite the internal implementation of `setUsageDurationMillis` changing by adding `getKey`, the method's contract remains the same: it still accepts two parameters and returns the builder object of type `T`. As the change doesn't seem to affect the returned variable type or the exception handling (assuming `getKey` does not throw an unchecked exception that wasn't previously documented anyway), it can be inferred that it wouldn't cause a compatibility issue since the callers of `setUsageDurationMillis` should observe the same behavior in terms of API usage and the method's output. Thus, the CI type is 0."
190,"<android.hardware.camera2.impl.CameraExtensionSessionImpl: int setRepeatingRequest(CaptureRequest,Executor,ExtensionCaptureCallback)>",32,33,,,,"{
    synchronized (mInterfaceLock) {
        if (!mInitialized) {
            throw new IllegalStateException(""Uninitialized component"");
        }
        if (mClientRepeatingRequestSurface == null) {
            throw new IllegalArgumentException(""No registered preview surface"");
        }
        if (!request.containsTarget(mClientRepeatingRequestSurface) || (request.getTargets().size() != 1)) {
            throw new IllegalArgumentException(""Invalid repeating request output target!"");
        }
        mInternalRepeatingRequestEnabled = false;
        try {
            return setRepeatingRequest(mPreviewExtender.getCaptureStage(), new RepeatingRequestHandler(request, executor, listener, mRepeatingRequestImageCallback));
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to set repeating request! Extension service does not "" + ""respond"");
            throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
        }
    }
}","{
    synchronized (mInterfaceLock) {
        if (!mInitialized) {
            throw new IllegalStateException(""Uninitialized component"");
        }
        if (mClientRepeatingRequestSurface == null) {
            throw new IllegalArgumentException(""No registered preview surface"");
        }
        if (!request.containsTarget(mClientRepeatingRequestSurface) || (request.getTargets().size() != 1)) {
            throw new IllegalArgumentException(""Invalid repeating request output target!"");
        }
        mInternalRepeatingRequestEnabled = false;
        try {
            return setRepeatingRequest(mPreviewExtender.getCaptureStage(), new PreviewRequestHandler(request, executor, listener, mRepeatingRequestImageCallback), request);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to set repeating request! Extension service does not "" + ""respond"");
            throw new CameraAccessException(CameraAccessException.CAMERA_ERROR);
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,The implementation has changed where the instantiation of `RepeatingRequestHandler` is replaced with `PreviewRequestHandler` and an extra argument `request` is passed to the `setRepeatingRequest` method. This is a change in a method call with different arguments (1) and instantiation of a different class (4).,"Since the type of handler passed to `setRepeatingRequest` has been changed, and there is an additional argument passed to the method, this could lead to a change in behavior of the `setRepeatingRequest` method, which ultimately affects the return value. Therefore, this could potentially cause the API to return different values depending on the implementation of `PreviewRequestHandler` versus `RepeatingRequestHandler`. Hence, the CI type is 1."
191,<android.service.dreams.DreamService: boolean dispatchKeyEvent(KeyEvent)>,32,33,,,,"{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on keyEvent"");
        wakeUp();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on back key"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}","{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(mTag, ""Waking up on keyEvent"");
        wakeUp();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(mTag, ""Waking up on back key"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"There is a slight change in the logging tag used from `TAG` to `mTag`, but the core logic and return statements remain untouched, so the change type is 4.","This is a non-functional change that does not affect the returned value or the exceptions thrown, hence there is no compatibility issue. The change in the logging tag simply affects the output to the log, not the behavior of the method."
192,<android.service.voice.VoiceInteractionSession: void ensureWindowCreated()>,32,33,,,,"{
    if (mInitialized) {
        return;
    }
    if (!mUiEnabled) {
        throw new IllegalStateException(""setUiEnabled is false"");
    }
    mInitialized = true;
    mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mWindow = new SoftInputWindow(mContext, ""VoiceInteractionSession"", mTheme, mCallbacks, this, mDispatcherState, WindowManager.LayoutParams.TYPE_VOICE_INTERACTION, Gravity.BOTTOM, true);
    mWindow.getWindow().getAttributes().setFitInsetsTypes(0);
    mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
    mThemeAttrs = mContext.obtainStyledAttributes(android.R.styleable.VoiceInteractionSession);
    mRootView = mInflater.inflate(com.android.internal.R.layout.voice_interaction_session, null);
    mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
    mWindow.setContentView(mRootView);
    mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
    mContentFrame = (FrameLayout) mRootView.findViewById(android.R.id.content);
    mWindow.getWindow().setLayout(MATCH_PARENT, MATCH_PARENT);
    mWindow.setToken(mToken);
}","{
    if (mInitialized) {
        return;
    }
    if (!mUiEnabled) {
        throw new IllegalStateException(""setUiEnabled is false"");
    }
    mInitialized = true;
    mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mWindow = new VoiceInteractionWindow(mContext, ""VoiceInteractionSession"", mTheme, mCallbacks, this, mDispatcherState, WindowManager.LayoutParams.TYPE_VOICE_INTERACTION, Gravity.BOTTOM, true);
    mWindow.getWindow().getAttributes().setFitInsetsTypes(0);
    mWindow.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR);
    mThemeAttrs = mContext.obtainStyledAttributes(android.R.styleable.VoiceInteractionSession);
    mRootView = mInflater.inflate(com.android.internal.R.layout.voice_interaction_session, null);
    mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
    mWindow.setContentView(mRootView);
    mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
    mContentFrame = (FrameLayout) mRootView.findViewById(android.R.id.content);
    mWindow.getWindow().setLayout(MATCH_PARENT, MATCH_PARENT);
    mWindow.setToken(mToken);
}",1,,,0,,,0,,,,,,,"4,5",1,"The constructor of the window object has changed from `new SoftInputWindow(...)` to `new VoiceInteractionWindow(...)`. This is not a control dependency change, exception handling change or return statement change, but it's a change in the instantiation of an object which suggests a change in the dependent API, so the code change type is 4,5. ","Although the code change is not in the return statement, exception handling, or control flow, it can still cause a compatibility issue due to the change in the type of the window object created. This change in the window object could lead to different behaviors in the UI, as the two window types may have different properties or behaviors. Therefore, the CI type is 1."
193,<android.app.ActivityOptions: Bundle toBundle()>,32,33,,,,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the HardwareBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.getHardwareBuffer());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchRootTask != null) {
        b.putParcelable(KEY_LAUNCH_ROOT_TASK_TOKEN, mLaunchRootTask);
    }
    if (mLaunchTaskFragmentToken != null) {
        b.putBinder(KEY_LAUNCH_TASK_FRAGMENT_TOKEN, mLaunchTaskFragmentToken);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mSourceInfo != null) {
        b.putParcelable(KEY_SOURCE_INFO, mSourceInfo);
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    if (mLaunchCookie != null) {
        b.putBinder(KEY_LAUNCH_COOKIE, mLaunchCookie);
    }
    if (mRemoteTransition != null) {
        b.putParcelable(KEY_REMOTE_TRANSITION, mRemoteTransition);
    }
    if (mOverrideTaskTransition) {
        b.putBoolean(KEY_OVERRIDE_TASK_TRANSITION, mOverrideTaskTransition);
    }
    if (mSplashScreenThemeResName != null && !mSplashScreenThemeResName.isEmpty()) {
        b.putString(KEY_SPLASH_SCREEN_THEME, mSplashScreenThemeResName);
    }
    if (mRemoveWithTaskOrganizer) {
        b.putBoolean(KEY_REMOVE_WITH_TASK_ORGANIZER, mRemoveWithTaskOrganizer);
    }
    if (mLaunchedFromBubble) {
        b.putBoolean(KEY_LAUNCHED_FROM_BUBBLE, mLaunchedFromBubble);
    }
    if (mTransientLaunch) {
        b.putBoolean(KEY_TRANSIENT_LAUNCH, mTransientLaunch);
    }
    if (mSplashScreenStyle != 0) {
        b.putInt(KEY_SPLASH_SCREEN_STYLE, mSplashScreenStyle);
    }
    return b;
}","{
    Bundle b = super.toBundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putInt(KEY_ANIM_BACKGROUND_COLOR, mCustomBackgroundColor);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the HardwareBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.getHardwareBuffer());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchRootTask != null) {
        b.putParcelable(KEY_LAUNCH_ROOT_TASK_TOKEN, mLaunchRootTask);
    }
    if (mLaunchTaskFragmentToken != null) {
        b.putBinder(KEY_LAUNCH_TASK_FRAGMENT_TOKEN, mLaunchTaskFragmentToken);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mSourceInfo != null) {
        b.putParcelable(KEY_SOURCE_INFO, mSourceInfo);
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    if (mLaunchCookie != null) {
        b.putBinder(KEY_LAUNCH_COOKIE, mLaunchCookie);
    }
    if (mRemoteTransition != null) {
        b.putParcelable(KEY_REMOTE_TRANSITION, mRemoteTransition);
    }
    if (mOverrideTaskTransition) {
        b.putBoolean(KEY_OVERRIDE_TASK_TRANSITION, mOverrideTaskTransition);
    }
    if (mSplashScreenThemeResName != null && !mSplashScreenThemeResName.isEmpty()) {
        b.putString(KEY_SPLASH_SCREEN_THEME, mSplashScreenThemeResName);
    }
    if (mRemoveWithTaskOrganizer) {
        b.putBoolean(KEY_REMOVE_WITH_TASK_ORGANIZER, mRemoveWithTaskOrganizer);
    }
    if (mLaunchedFromBubble) {
        b.putBoolean(KEY_LAUNCHED_FROM_BUBBLE, mLaunchedFromBubble);
    }
    if (mTransientLaunch) {
        b.putBoolean(KEY_TRANSIENT_LAUNCH, mTransientLaunch);
    }
    if (mSplashScreenStyle != 0) {
        b.putInt(KEY_SPLASH_SCREEN_STYLE, mSplashScreenStyle);
    }
    if (mLaunchIntoPipParams != null) {
        b.putParcelable(KEY_LAUNCH_INTO_PIP_PARAMS, mLaunchIntoPipParams);
    }
    if (mIsEligibleForLegacyPermissionPrompt) {
        b.putBoolean(KEY_LEGACY_PERMISSION_PROMPT_ELIGIBLE, mIsEligibleForLegacyPermissionPrompt);
    }
    if (mDismissKeyguardIfInsecure) {
        b.putBoolean(KEY_DISMISS_KEYGUARD_IF_INSECURE, mDismissKeyguardIfInsecure);
    }
    if (mIgnorePendingIntentCreatorForegroundState) {
        b.putBoolean(KEY_IGNORE_PENDING_INTENT_CREATOR_FOREGROUND_STATE, mIgnorePendingIntentCreatorForegroundState);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",0,,[@Override],1,,,,,,,,,,
194,<android.content.pm.ShortcutManager: void reportShortcutUsed(String)>,32,33,,,,"{
    try {
        getFutureOrThrow(mService.reportShortcutUsed(mContext.getPackageName(), shortcutId, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.reportShortcutUsed(mContext.getPackageName(), shortcutId, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Apps that publish shortcuts should call this method whenever the user
 * selects the shortcut containing the given ID or when the user completes
 * an action in the app that is equivalent to selecting the shortcut.
 * For more details, read about
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#track-usage"">
 * tracking shortcut usage</a>.
 *
 * <p>The information is accessible via {@link UsageStatsManager#queryEvents}
 * Typically, launcher apps use this information to build a prediction model
 * so that they can promote the shortcuts that are likely to be used at the moment.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Apps that publish shortcuts should call this method whenever the user
 * selects the shortcut containing the given ID or when the user completes
 * an action in the app that is equivalent to selecting the shortcut.
 * For more details, read about
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#track-usage"">
 * tracking shortcut usage</a>.
 *
 * <p>The information is accessible via {@link UsageStatsManager#queryEvents}
 * Typically, launcher apps use this information to build a prediction model
 * so that they can promote the shortcuts that are likely to be used at the moment.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,,,0,,,,,,,4,0,"The method call within the 'try' block has changed from including getFutureOrThrow(...) wrapper to a direct call on mService.reportShortcutUsed(...). While the API surface and exception handling have not changed, the internal call mechanism has seen a minor alteration, which is qualified as an 'other statement changed'.","There is no Compatibility Issue here because the actual outcome of the method call has not changed; it still calls the same service method with the same arguments and handles exceptions in the same way. The change does not affect the API's behavior from an external point of view, meaning that the caller of this method would not experience any difference in the method's response."
195,<android.window.TransitionInfo.Change: String toString()>,32,33,,,,"{
    return ""{"" + mContainer + ""("" + mParent + "") leash="" + mLeash + "" m="" + modeToString(mMode) + "" f="" + flagsToString(mFlags) + "" sb="" + mStartAbsBounds + "" eb="" + mEndAbsBounds + "" eo="" + mEndRelOffset + "" r="" + mStartRotation + ""->"" + mEndRotation + "":"" + mRotationAnimation + ""}"";
}","{
    return ""{"" + mContainer + ""("" + mParent + "") leash="" + mLeash + "" m="" + modeToString(mMode) + "" f="" + flagsToString(mFlags) + "" sb="" + mStartAbsBounds + "" eb="" + mEndAbsBounds + "" eo="" + mEndRelOffset + "" r="" + mStartRotation + ""->"" + mEndRotation + "":"" + mRotationAnimation + "" endFixedRotation="" + mEndFixedRotation + ""}"";
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change is the addition of "" endFixedRotation="" + mEndFixedRotation to the string in the return statement, which is an addition to what the method outputs, and no control flow or method invocation is affected. So, the change type is 4.","There is no Compatibility Issue since the method only returns additional information and this won't affect the execution of existing client code that relies on the `toString()` representation; clients not expecting the additional ""endFixedRotation"" value in the string won't be affected by its presence. Hence, the CI type is 0."
196,"<android.app.usage.UsageEvents: void writeToParcel(Parcel,int)>",32,33,,,,"{
    Parcel data = Parcel.obtain();
    data.writeInt(mEventCount);
    data.writeInt(mIndex);
    if (mEventCount > 0) {
        data.writeStringArray(mStringPool);
        if (mEventsToWrite != null) {
            // Write out the events
            Parcel p = Parcel.obtain();
            try {
                p.setDataPosition(0);
                for (int i = 0; i < mEventCount; i++) {
                    final Event event = mEventsToWrite.get(i);
                    writeEventToParcel(event, p, flags);
                }
                final int listByteLength = p.dataPosition();
                // Write the total length of the data.
                data.writeInt(listByteLength);
                // Write our current position into the data.
                data.writeInt(0);
                // Write the data.
                data.appendFrom(p, 0, listByteLength);
            } finally {
                p.recycle();
            }
        } else if (mParcel != null) {
            // Write the total length of the data.
            data.writeInt(mParcel.dataSize());
            // Write out current position into the data.
            data.writeInt(mParcel.dataPosition());
            // Write the data.
            data.appendFrom(mParcel, 0, mParcel.dataSize());
        } else {
            throw new IllegalStateException(""Either mParcel or mEventsToWrite must not be null"");
        }
    }
    // Data can be too large for a transact. Write the data as a Blob, which will be written to
    // ashmem if too large.
    dest.writeBlob(data.marshall());
}","{
    Parcel data = Parcel.obtain();
    data.writeInt(mEventCount);
    data.writeInt(mIndex);
    if (mEventCount > 0) {
        data.writeStringArray(mStringPool);
        if (mEventsToWrite != null) {
            // Write out the events
            Parcel p = Parcel.obtain();
            try {
                p.setDataPosition(0);
                for (int i = 0; i < mEventCount; i++) {
                    final Event event = mEventsToWrite.get(i);
                    writeEventToParcel(event, p, flags);
                }
                final int listByteLength = p.dataPosition();
                // Write the total length of the data.
                data.writeInt(listByteLength);
                // Write our current position into the data.
                data.writeInt(0);
                // Write the data.
                data.appendFrom(p, 0, listByteLength);
            } finally {
                p.recycle();
            }
        } else if (mParcel != null) {
            // Write the total length of the data.
            data.writeInt(mParcel.dataSize());
            // Write out current position into the data.
            data.writeInt(mParcel.dataPosition());
            // Write the data.
            data.appendFrom(mParcel, 0, mParcel.dataSize());
        } else {
            throw new IllegalStateException(""Either mParcel or mEventsToWrite must not be null"");
        }
    }
    // Data can be too large for a transact. Write the data as a Blob, which will be written to
    // ashmem if too large.
    dest.writeBlob(data.marshall());
    data.recycle();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change between the two versions is the addition of `data.recycle();` at the end of the Late_Implementation, so the change type is 4.","The addition of `data.recycle();` does not alter the behavior of the method in regards to the output written to `dest`, as it is a cleanup operation performed after the data has already been marshaled and written to the `dest` parcel. Therefore, there is no Compatibility Issue."
197,"<android.content.res.TypedArray: int getColor(int,int)>",32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to color: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value + "", theme="" + mTheme);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to color: type=0x"" + Integer.toHexString(type) + "", theme="" + mTheme);
}",1,"/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",0,[@ColorInt],[@ColorInt],0,,,,,,,4,0,"The changes between the two implementations are only in the text strings provided to the `UnsupportedOperationException` exceptions. These changes do not affect the execution flow or the return values; therefore, the code change type is 4.","Since the changes in exception messages do not cause the method to behave differently regarding its return value or the exceptions it throws (it still throws the same type of exception), there is no Compatibility Issue; thus, the CI type is 0."
198,<android.app.admin.DevicePolicyManager: boolean isNetworkLoggingEnabled(ComponentName)>,32,33,,,,"{
    throwIfParentInstance(""isNetworkLoggingEnabled"");
    try {
        return mService.isNetworkLoggingEnabled(admin, mContext.getPackageName());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""isNetworkLoggingEnabled"");
    return mIsNetworkLoggingEnabledCache.query(admin);
}",1,"/**
 * Return whether network logging is enabled by a device owner or profile owner of
 * a managed profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Can only
 * be {@code null} if the caller is a delegated app with {@link #DELEGATION_NETWORK_LOGGING}
 * or has MANAGE_USERS permission.
 * @return {@code true} if network logging is enabled by device owner or profile owner,
 * {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner or profile owner and
 * caller has no MANAGE_USERS permission
 */
","/**
 * Return whether network logging is enabled by a device owner or profile owner of
 * a managed profile.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with. Can only
 * be {@code null} if the caller is a delegated app with {@link #DELEGATION_NETWORK_LOGGING}
 * or has MANAGE_USERS permission.
 * @return {@code true} if network logging is enabled by device owner or profile owner,
 * {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not a device owner or profile owner and
 * caller has no MANAGE_USERS permission
 */
",0,,,0,,,,,,,"1,4,5",1,"The method body has changed with a different implementation using mIsNetworkLoggingEnabledCache.query(admin) instead of mService.isNetworkLoggingEnabled(admin, mContext.getPackageName()). Additionally, dependent API isNetworkLoggingEnabled is no longer called, and a new dependent API query is introduced, so the change type is 1,4,5.","The late version uses a cache for querying which may return different values compared to the direct service call used in early version, which introduces potential for different return values. Thus, the CI type is 1."
199,"<android.service.voice.VoiceInteractionSession: void doShow(Bundle,int,IVoiceInteractionSessionShowCallback)>",32,33,,,,"{
    if (DEBUG)
        Log.v(TAG, ""Showing window: mWindowAdded="" + mWindowAdded + "" mWindowVisible="" + mWindowVisible);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mInShowWindow = true;
        onPrepareShow(args, flags);
        if (!mWindowVisible) {
            ensureWindowAdded();
        }
        onShow(args, flags);
        if (!mWindowVisible) {
            mWindowVisible = true;
            if (mUiEnabled) {
                mWindow.show();
            }
        }
        if (showCallback != null) {
            if (mUiEnabled) {
                mRootView.invalidate();
                mRootView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        mRootView.getViewTreeObserver().removeOnPreDrawListener(this);
                        try {
                            showCallback.onShown();
                        } catch (RemoteException e) {
                            Log.w(TAG, ""Error calling onShown"", e);
                        }
                        return true;
                    }
                });
            } else {
                try {
                    showCallback.onShown();
                } catch (RemoteException e) {
                    Log.w(TAG, ""Error calling onShown"", e);
                }
            }
        }
    } finally {
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""Showing window: mWindowAdded="" + mWindowAdded + "" mWindowVisible="" + mWindowVisible);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    try {
        mInShowWindow = true;
        onPrepareShow(args, flags);
        if (!mWindowVisible) {
            ensureWindowAdded();
        }
        onShow(args, flags);
        if (!mWindowVisible) {
            mWindowVisible = true;
            if (mUiEnabled) {
                showWindow();
            }
        }
        if (showCallback != null) {
            if (mUiEnabled) {
                mRootView.invalidate();
                mRootView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

                    @Override
                    public boolean onPreDraw() {
                        mRootView.getViewTreeObserver().removeOnPreDrawListener(this);
                        try {
                            showCallback.onShown();
                        } catch (RemoteException e) {
                            Log.w(TAG, ""Error calling onShown"", e);
                        }
                        return true;
                    }
                });
            } else {
                try {
                    showCallback.onShown();
                } catch (RemoteException e) {
                    Log.w(TAG, ""Error calling onShown"", e);
                }
            }
        }
    } finally {
        mWindowWasVisible = true;
        mInShowWindow = false;
    }
}",1,,,0,,,0,,,,,,,0,0,"There are no changes in the API implementation between the two versions, so there is no change.","Since there is no change, no compatibility issue could arise. Hence, the CI is classified as 0."
200,<android.net.Ikev2VpnProfile.Builder: Builder setAllowedAlgorithms(List<String>)>,32,33,,,,"{
    checkNotNull(algorithmNames, MISSING_PARAM_MSG_TMPL, ""algorithmNames"");
    validateAllowedAlgorithms(algorithmNames);
    mAllowedAlgorithms = algorithmNames;
    return this;
}","{
    checkNotNull(algorithmNames, MISSING_PARAM_MSG_TMPL, ""algorithmNames"");
    checkBuilderSetter(mIkeTunConnParams != null, ""algorithmNames"");
    validateAllowedAlgorithms(algorithmNames);
    mAllowedAlgorithms = algorithmNames;
    return this;
}",1,"/**
 * Sets the allowable set of IPsec algorithms
 *
 * <p>If set, this will constrain the set of algorithms that the IPsec tunnel will use for
 * integrity verification and encryption to the provided list.
 *
 * <p>The set of allowed IPsec algorithms is defined in {@link IpSecAlgorithm}. Adding of
 * algorithms that are considered insecure (such as AUTH_HMAC_MD5 and AUTH_HMAC_SHA1) is not
 * permitted, and will result in an IllegalArgumentException being thrown.
 *
 * <p>The provided algorithm list must contain at least one algorithm that provides
 * Authentication, and one that provides Encryption. Authenticated Encryption with
 * Associated Data (AEAD) algorithms provide both Authentication and Encryption.
 *
 * <p>By default, this profile will use any algorithm defined in {@link IpSecAlgorithm},
 * with the exception of those considered insecure (as described above).
 *
 * @param algorithmNames the list of supported IPsec algorithms
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @see IpSecAlgorithm
 */
","/**
 * Sets the allowable set of IPsec algorithms
 *
 * <p>If set, this will constrain the set of algorithms that the IPsec tunnel will use for
 * integrity verification and encryption to the provided list.
 *
 * <p>The set of allowed IPsec algorithms is defined in {@link IpSecAlgorithm}. Adding of
 * algorithms that are considered insecure (such as AUTH_HMAC_MD5 and AUTH_HMAC_SHA1) is not
 * permitted, and will result in an IllegalArgumentException being thrown.
 *
 * <p>The provided algorithm list must contain at least one algorithm that provides
 * Authentication, and one that provides Encryption. Authenticated Encryption with
 * Associated Data (AEAD) algorithms provide both Authentication and Encryption.
 *
 * <p>If this {@link Builder} is constructed with an {@link IkeTunnelConnectionParams},
 * authentication details should be configured there, and calling this method will result in
 * an exception being thrown.
 *
 * <p>By default, this profile will use any algorithm defined in {@link IpSecAlgorithm},
 * with the exception of those considered insecure (as described above).
 *
 * @param algorithmNames the list of supported IPsec algorithms
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @see IpSecAlgorithm
 */
",1,"[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]","[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]",0,,,,,,,"3,4",0,"An additional method call checkBuilderSetter(mIkeTunConnParams != null, ""algorithmNames"") is introduced, so the change includes ""Other statement changed"" (4) and ""Control dependency change"" (3), since there's a new precondition check that wasn't present in the earlier version.","In terms of causing a compatibility issue, the newly added precondition check does not lead to a different return value or the method throwing a different exception that it didn't before. The caller must meet the precondition regardless of the API version - the additional check in the new version does not change the execution flow significant enough to cause a compatibility issue. Thus, the result is 0 for ""No Compatibility Issue""."
201,"<android.service.autofill.Dataset.Builder: Builder setInlinePresentation(InlinePresentation,InlinePresentation)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation must be non-null"");
    Preconditions.checkNotNull(inlineTooltipPresentation, ""inlineTooltipPresentation must be non-null"");
    mInlinePresentation = inlinePresentation;
    mInlineTooltipPresentation = inlineTooltipPresentation;
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(inlinePresentation, ""inlinePresentation must be non-null"");
    Objects.requireNonNull(inlineTooltipPresentation, ""inlineTooltipPresentation must be non-null"");
    mInlinePresentation = inlinePresentation;
    mInlineTooltipPresentation = inlineTooltipPresentation;
    return this;
}",1,"/**
 * Visualizes this dataset as inline suggestions.
 *
 * @param inlinePresentation the {@link InlinePresentation} used to visualize this
 * dataset as inline suggestions. If the dataset supports inline suggestions this
 * should not be null.
 * @param inlineTooltipPresentation the {@link InlinePresentation} used to show
 * the tooltip for the {@code inlinePresentation}.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Visualizes this dataset as inline suggestions.
 *
 * @param inlinePresentation the {@link InlinePresentation} used to visualize this
 * dataset as inline suggestions. If the dataset supports inline suggestions this
 * should not be null.
 * @param inlineTooltipPresentation the {@link InlinePresentation} used to show
 * the tooltip for the {@code inlinePresentation}.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #Builder(Presentations)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,4,0,"The change is in the validation check, where `Preconditions.checkNotNull` has been replaced with `Objects.requireNonNull`. Both methods serve the same purpose, so the behavior should remain unchanged. Therefore, the code change type is 4 (Other statement changed).",There is no Compatibility Issue as the replacement of the null check mechanism does not affect the return value or exception handling of the API. The API behavior remains consistent between the two versions.
202,<android.view.inputmethod.InputConnectionWrapper: void setTarget(InputConnection)>,32,33,,,,"{
    if (mTarget != null && !mMutable) {
        throw new SecurityException(""not mutable"");
    }
    mTarget = target;
    mMissingMethodFlags = InputConnectionInspector.getMissingMethodFlags(target);
}","{
    if (mTarget != null && !mMutable) {
        throw new SecurityException(""not mutable"");
    }
    mTarget = target;
}",1,"/**
 * Change the target of the input connection.
 *
 * <p><b>Caveat:</b> Although the system can accept {@code (InputConnection) null} in some
 * places, you cannot emulate such a behavior by non-null {@link InputConnectionWrapper} that
 * has {@code null} in {@code target}.</p>
 * @param target the {@link InputConnection} to be proxied.
 * @throws SecurityException when this wrapper has non-null target and is immutable.
 */
","/**
 * Change the target of the input connection.
 *
 * <p><b>Caveat:</b> Although the system can accept {@code (InputConnection) null} in some
 * places, you cannot emulate such a behavior by non-null {@link InputConnectionWrapper} that
 * has {@code null} in {@code target}.</p>
 * @param target the {@link InputConnection} to be proxied.
 * @throws SecurityException when this wrapper has non-null target and is immutable.
 */
",0,,,0,,,,,,,4,0,"The line `mMissingMethodFlags = InputConnectionInspector.getMissingMethodFlags(target);` has been deleted in the Late Version, which is an Other statement changed (4).","The deletion of the line of code does not lead to a different variable being returned or a different exception being thrown. The modification is internal to the class's state and does not affect the method's output or exception behavior, so there is No Compatibility Issue (0)."
203,<android.hardware.camera2.CameraCharacteristics: RecommendedStreamConfigurationMap getRecommendedStreamConfigurationMap(int)>,32,33,,,,"{
    if (((usecase >= RecommendedStreamConfigurationMap.USECASE_PREVIEW) && (usecase <= RecommendedStreamConfigurationMap.USECASE_LOW_LATENCY_SNAPSHOT)) || ((usecase >= RecommendedStreamConfigurationMap.USECASE_VENDOR_START) && (usecase < RecommendedStreamConfigurationMap.MAX_USECASE_COUNT))) {
        if (mRecommendedConfigurations == null) {
            mRecommendedConfigurations = mProperties.getRecommendedStreamConfigurations();
            if (mRecommendedConfigurations == null) {
                return null;
            }
        }
        return mRecommendedConfigurations.get(usecase);
    }
    throw new IllegalArgumentException(String.format(""Invalid use case: %d"", usecase));
}","{
    if (((usecase >= RecommendedStreamConfigurationMap.USECASE_PREVIEW) && (usecase <= RecommendedStreamConfigurationMap.USECASE_10BIT_OUTPUT)) || ((usecase >= RecommendedStreamConfigurationMap.USECASE_VENDOR_START) && (usecase < RecommendedStreamConfigurationMap.MAX_USECASE_COUNT))) {
        if (mRecommendedConfigurations == null) {
            mRecommendedConfigurations = mProperties.getRecommendedStreamConfigurations();
            if (mRecommendedConfigurations == null) {
                return null;
            }
        }
        return mRecommendedConfigurations.get(usecase);
    }
    throw new IllegalArgumentException(String.format(""Invalid use case: %d"", usecase));
}",1,"/**
 * <p>Retrieve camera device recommended stream configuration map
 * {@link RecommendedStreamConfigurationMap} for a given use case.</p>
 *
 * <p>The stream configurations advertised here are efficient in terms of power and performance
 * for common use cases like preview, video, snapshot, etc. The recommended maps are usually
 * only small subsets of the exhaustive list provided in
 * {@link #SCALER_STREAM_CONFIGURATION_MAP} and suggested for a particular use case by the
 * camera device implementation. For further information about the expected configurations in
 * various scenarios please refer to:
 * <ul>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_PREVIEW}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_RECORD}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_VIDEO_SNAPSHOT}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_SNAPSHOT}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_RAW}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_ZSL}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_LOW_LATENCY_SNAPSHOT}</li>
 * </ul>
 * </p>
 *
 * <p>For example on how this can be used by camera clients to find out the maximum recommended
 * preview and snapshot resolution, consider the following pseudo-code:
 * </p>
 * <pre><code>
 * public static Size getMaxSize(Size... sizes) {
 * if (sizes == null || sizes.length == 0) {
 * throw new IllegalArgumentException(""sizes was empty"");
 * }
 *
 * Size sz = sizes[0];
 * for (Size size : sizes) {
 * if (size.getWidth() * size.getHeight() &gt; sz.getWidth() * sz.getHeight()) {
 * sz = size;
 * }
 * }
 *
 * return sz;
 * }
 *
 * CameraCharacteristics characteristics =
 * cameraManager.getCameraCharacteristics(cameraId);
 * RecommendedStreamConfigurationMap previewConfig =
 * characteristics.getRecommendedStreamConfigurationMap(
 * RecommendedStreamConfigurationMap.USECASE_PREVIEW);
 * RecommendedStreamConfigurationMap snapshotConfig =
 * characteristics.getRecommendedStreamConfigurationMap(
 * RecommendedStreamConfigurationMap.USECASE_SNAPSHOT);
 *
 * if ((previewConfig != null) &amp;&amp; (snapshotConfig != null)) {
 *
 * Set<Size> snapshotSizeSet = snapshotConfig.getOutputSizes(
 * ImageFormat.JPEG);
 * Size[] snapshotSizes = new Size[snapshotSizeSet.size()];
 * snapshotSizes = snapshotSizeSet.toArray(snapshotSizes);
 * Size suggestedMaxJpegSize = getMaxSize(snapshotSizes);
 *
 * Set<Size> previewSizeSet = snapshotConfig.getOutputSizes(
 * ImageFormat.PRIVATE);
 * Size[] previewSizes = new Size[previewSizeSet.size()];
 * previewSizes = previewSizeSet.toArray(previewSizes);
 * Size suggestedMaxPreviewSize = getMaxSize(previewSizes);
 * }
 *
 * </code></pre>
 *
 * <p>Similar logic can be used for other use cases as well.</p>
 *
 * <p>Support for recommended stream configurations is optional. In case there a no
 * suggested configurations for the particular use case, please refer to
 * {@link #SCALER_STREAM_CONFIGURATION_MAP} for the exhaustive available list.</p>
 *
 * @param usecase Use case id.
 *
 * @throws IllegalArgumentException In case the use case argument is invalid.
 * @return Valid {@link RecommendedStreamConfigurationMap} or null in case the camera device
 * doesn't have any recommendation for this use case or the recommended configurations
 * are invalid.
 */
","/**
 * <p>Retrieve camera device recommended stream configuration map
 * {@link RecommendedStreamConfigurationMap} for a given use case.</p>
 *
 * <p>The stream configurations advertised here are efficient in terms of power and performance
 * for common use cases like preview, video, snapshot, etc. The recommended maps are usually
 * only small subsets of the exhaustive list provided in
 * {@link #SCALER_STREAM_CONFIGURATION_MAP} and suggested for a particular use case by the
 * camera device implementation. For further information about the expected configurations in
 * various scenarios please refer to:
 * <ul>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_PREVIEW}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_RECORD}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_VIDEO_SNAPSHOT}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_SNAPSHOT}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_RAW}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_ZSL}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_LOW_LATENCY_SNAPSHOT}</li>
 * </ul>
 * </p>
 *
 * <p>For example on how this can be used by camera clients to find out the maximum recommended
 * preview and snapshot resolution, consider the following pseudo-code:
 * </p>
 * <pre><code>
 * public static Size getMaxSize(Size... sizes) {
 * if (sizes == null || sizes.length == 0) {
 * throw new IllegalArgumentException(""sizes was empty"");
 * }
 *
 * Size sz = sizes[0];
 * for (Size size : sizes) {
 * if (size.getWidth() * size.getHeight() &gt; sz.getWidth() * sz.getHeight()) {
 * sz = size;
 * }
 * }
 *
 * return sz;
 * }
 *
 * CameraCharacteristics characteristics =
 * cameraManager.getCameraCharacteristics(cameraId);
 * RecommendedStreamConfigurationMap previewConfig =
 * characteristics.getRecommendedStreamConfigurationMap(
 * RecommendedStreamConfigurationMap.USECASE_PREVIEW);
 * RecommendedStreamConfigurationMap snapshotConfig =
 * characteristics.getRecommendedStreamConfigurationMap(
 * RecommendedStreamConfigurationMap.USECASE_SNAPSHOT);
 *
 * if ((previewConfig != null) &amp;&amp; (snapshotConfig != null)) {
 *
 * Set<Size> snapshotSizeSet = snapshotConfig.getOutputSizes(
 * ImageFormat.JPEG);
 * Size[] snapshotSizes = new Size[snapshotSizeSet.size()];
 * snapshotSizes = snapshotSizeSet.toArray(snapshotSizes);
 * Size suggestedMaxJpegSize = getMaxSize(snapshotSizes);
 *
 * Set<Size> previewSizeSet = snapshotConfig.getOutputSizes(
 * ImageFormat.PRIVATE);
 * Size[] previewSizes = new Size[previewSizeSet.size()];
 * previewSizes = previewSizeSet.toArray(previewSizes);
 * Size suggestedMaxPreviewSize = getMaxSize(previewSizes);
 * }
 *
 * </code></pre>
 *
 * <p>Similar logic can be used for other use cases as well.</p>
 *
 * <p>Support for recommended stream configurations is optional. In case there a no
 * suggested configurations for the particular use case, please refer to
 * {@link #SCALER_STREAM_CONFIGURATION_MAP} for the exhaustive available list.</p>
 *
 * @param usecase Use case id.
 *
 * @throws IllegalArgumentException In case the use case argument is invalid.
 * @return Valid {@link RecommendedStreamConfigurationMap} or null in case the camera device
 * doesn't have any recommendation for this use case or the recommended configurations
 * are invalid.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,"3,5",0,"The condition check value for USECASE_10BIT_OUTPUT in the if statement has been changed, and it appears that an enum value has been renamed or renumbered, so the code change type is 3,5.","Given that the range check has changed but the overall structure of the method remains the same, this reflects an update in use case constants rather than a change in the method execution logic. Since the rest of the method's logic, including error handling and return values, remains consistent, and we can assume that the method is still handling the use cases correctly within their revised definitions, there's no compatibility issue arising from this change."
204,"<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl: int capture(CaptureRequest,Executor,ExtensionCaptureCallback)>",32,33,,,,"{
    int seqId = -1;
    synchronized (mInterfaceLock) {
        if (!mInitialized) {
            throw new IllegalStateException(""Uninitialized component"");
        }
        if (mClientCaptureSurface == null) {
            throw new IllegalArgumentException(""No output surface registered for single"" + "" requests!"");
        }
        if (!request.containsTarget(mClientCaptureSurface) || (request.getTargets().size() != 1)) {
            throw new IllegalArgumentException(""Invalid single capture output target!"");
        }
        try {
            // This will override the extension capture stage jpeg parameters with the user set
            // jpeg quality and rotation. This will guarantee that client configured jpeg
            // parameters always have highest priority.
            Integer jpegRotation = request.get(CaptureRequest.JPEG_ORIENTATION);
            if (jpegRotation == null) {
                jpegRotation = CameraExtensionUtils.JPEG_DEFAULT_ROTATION;
            }
            Byte jpegQuality = request.get(CaptureRequest.JPEG_QUALITY);
            if (jpegQuality == null) {
                jpegQuality = CameraExtensionUtils.JPEG_DEFAULT_QUALITY;
            }
            seqId = mSessionProcessor.startCapture(new RequestCallbackHandler(request, executor, listener), jpegRotation, jpegQuality);
        } catch (RemoteException e) {
            throw new CameraAccessException(CameraAccessException.CAMERA_ERROR, ""Failed to submit capture request, extension service failed to respond!"");
        }
    }
    return seqId;
}","{
    int seqId = -1;
    synchronized (mInterfaceLock) {
        if (!mInitialized) {
            throw new IllegalStateException(""Uninitialized component"");
        }
        if (request.getTargets().size() != 1) {
            throw new IllegalArgumentException(""Single capture to both preview & still"" + "" capture outputs target is not supported!"");
        }
        if ((mClientCaptureSurface != null) && request.containsTarget(mClientCaptureSurface)) {
            try {
                mSessionProcessor.setParameters(request);
                seqId = mSessionProcessor.startCapture(new RequestCallbackHandler(request, executor, listener));
            } catch (RemoteException e) {
                throw new CameraAccessException(CameraAccessException.CAMERA_ERROR, ""Failed "" + "" to submit capture request, extension service failed to respond!"");
            }
        } else if ((mClientRepeatingRequestSurface != null) && request.containsTarget(mClientRepeatingRequestSurface)) {
            try {
                seqId = mSessionProcessor.startTrigger(request, new RequestCallbackHandler(request, executor, listener));
            } catch (RemoteException e) {
                throw new CameraAccessException(CameraAccessException.CAMERA_ERROR, ""Failed "" + "" to submit trigger request, extension service failed to respond!"");
            }
        } else {
            throw new IllegalArgumentException(""Invalid single capture output target!"");
        }
    }
    return seqId;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,2,3,5","1,2","The changes include removal of code that sets jpegRotation and jpegQuality; altering exception messages and condition checks for mClientCaptureSurface and mClientRepeatingRequestSurface; introducing a new method call mSessionProcessor.setParameters(request), and a new conditional block for mClientRepeatingRequestSurface with a call to mSessionProcessor.startTrigger(). Therefore, the change types are 1,2,3,5.","There are both Return statement changes and Exception handling statement changes. The change in how jpegRotation and jpegQuality are set (or no longer set) could affect the returned value, leading to potential different values. The exception messages and conditions have also changed, which could affect what exceptions are thrown and when they are thrown. Thus, the CI types are 1 and 2."
206,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    String[] excludedPermissions = null;
    if (options != null) {
        String[] receiverPermissionsBundle = options.getStringArray(BroadcastOptions.KEY_REQUIRE_ALL_OF_PERMISSIONS);
        if (receiverPermissionsBundle != null) {
            receiverPermissions = receiverPermissionsBundle;
        }
        excludedPermissions = options.getStringArray(BroadcastOptions.KEY_REQUIRE_NONE_OF_PERMISSIONS);
    }
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, excludedPermissions, null, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"Control dependency and other statement changes occurred as a result of the introduction of new 'if' condition checking and modifying 'receiverPermissions' and 'excludedPermissions'. Thus, the code change types are 3 and 4.","There's no compatibility issue because the changes do not affect the functionality exposed by the method. The method does not return a value (void) nor does it change exception handling, meaning that the behavior from an API consumer perspective remains consistent regardless of the internal changes concerning the options handling. The new conditional logic introduced relates to internal implementation and does not cause the method to exhibit different behavior from an external perspective."
207,"<android.view.animation.Animation: boolean getTransformation(long,Transformation)>",32,33,,,,"{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f || isCanceled();
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            fireAnimationStart();
            mStarted = true;
            if (NoImagePreloadHolder.USE_CLOSEGUARD) {
                guard.open(""cancel or detach or getTransformation"");
            }
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        applyTransformation(interpolatedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated || isCanceled()) {
            if (!mEnded) {
                mEnded = true;
                guard.close();
                fireAnimationEnd();
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            fireAnimationRepeat();
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}","{
    if (mStartTime == -1) {
        mStartTime = currentTime;
    }
    final long startOffset = getStartOffset();
    final long duration = mDuration;
    float normalizedTime;
    if (duration != 0) {
        normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration;
    } else {
        // time is a step-change with a zero duration
        normalizedTime = currentTime < mStartTime ? 0.0f : 1.0f;
    }
    final boolean expired = normalizedTime >= 1.0f || isCanceled();
    mMore = !expired;
    if (!mFillEnabled)
        normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
    if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
        if (!mStarted) {
            fireAnimationStart();
            mStarted = true;
            if (NoImagePreloadHolder.USE_CLOSEGUARD) {
                guard.open(""cancel or detach or getTransformation"");
            }
        }
        if (mFillEnabled)
            normalizedTime = Math.max(Math.min(normalizedTime, 1.0f), 0.0f);
        if (mCycleFlip) {
            normalizedTime = 1.0f - normalizedTime;
        }
        getTransformationAt(normalizedTime, outTransformation);
    }
    if (expired) {
        if (mRepeatCount == mRepeated || isCanceled()) {
            if (!mEnded) {
                mEnded = true;
                guard.close();
                fireAnimationEnd();
            }
        } else {
            if (mRepeatCount > 0) {
                mRepeated++;
            }
            if (mRepeatMode == REVERSE) {
                mCycleFlip = !mCycleFlip;
            }
            mStartTime = -1;
            mMore = true;
            fireAnimationRepeat();
        }
    }
    if (!mMore && mOneMoreTime) {
        mOneMoreTime = false;
        return true;
    }
    return mMore;
}",1,"/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
","/**
 * Gets the transformation to apply at a specified point in time. Implementations of this
 * method should always replace the specified Transformation or document they are doing
 * otherwise.
 *
 * @param currentTime Where we are in the animation. This is wall clock time.
 * @param outTransformation A transformation object that is provided by the
 * caller and will be filled in by the animation.
 * @return True if the animation is still running
 */
",0,,,0,,,,,,,"4,5",1,"The method call within the if block changed from applyTransformation(interpolatedTime, outTransformation) to getTransformationAt(normalizedTime, outTransformation). So this is an Other statement changed, and also a Dependent API changed since the method called is different which potentially leads to a different behavior.","The change in the method call within the if block implies that the transformation being applied might be different in the late version of the API, which could potentially return a different value, causing a Compatibility Issue as a result of a different return value."
208,<android.window.PictureInPictureSurfaceTransaction.Builder: PictureInPictureSurfaceTransaction build()>,32,33,,,,"{
    return new PictureInPictureSurfaceTransaction(mAlpha, mPosition, mFloat9, mRotation, mCornerRadius, mWindowCrop);
}","{
    return new PictureInPictureSurfaceTransaction(mAlpha, mPosition, mFloat9, mRotation, mCornerRadius, mShadowRadius, mWindowCrop);
}",1,,,0,,,0,,,,,,,"1,5",1,"The constructor for PictureInPictureSurfaceTransaction has a new parameter (mShadowRadius) in the late version, which suggests that the constructor signature has also changed. Thus, the code change types are 1 (return statement changed), and 5 (dependent API changed).","Adding a new parameter to the constructor call means that the instances being returned by the build() method could have a different state because they might include additional information (shadow radius in this case). Therefore, a CI might occur with type 1 (returning a different variable/instance with potentially new or altered state)."
209,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",32,33,,,,"{
    throw new UnsupportedOperationException(""getPackageArchiveInfo() not implemented in subclass"");
}","{
    return getPackageArchiveInfo(archiveFilePath, PackageInfoFlags.of(flags));
}",1,"/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
","/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 * @deprecated Use {@link #getPackageArchiveInfo(String, PackageInfoFlags)} instead.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"1,5",1,"The implementation of the method has changed from throwing an UnsupportedOperationException to actually returning a result from another method (getPackageArchiveInfo(String, PackageInfoFlags)) with different logic, so the code change type is 1,5.","Since the early version of the API always throws an exception and the late version can potentially return a value instead, the behavior of the API can lead to a different return type or value, hence the CI type is 1."
210,<android.app.admin.FullyManagedDeviceProvisioningParams.Builder: FullyManagedDeviceProvisioningParams build()>,32,33,,,,"{
    return new FullyManagedDeviceProvisioningParams(mDeviceAdminComponentName, mOwnerName, mLeaveAllSystemAppsEnabled, mTimeZone, mLocalTime, mLocale, mDeviceOwnerCanGrantSensorsPermissions);
}","{
    return new FullyManagedDeviceProvisioningParams(mDeviceAdminComponentName, mOwnerName, mLeaveAllSystemAppsEnabled, mTimeZone, mLocalTime, mLocale, mDeviceOwnerCanGrantSensorsPermissions, mAdminExtras != null ? mAdminExtras : new PersistableBundle(), mDemoDevice);
}",1,"/**
 * Combines all of the attributes that have been set on this {@code Builder}
 *
 * @return a new {@link FullyManagedDeviceProvisioningParams} object.
 */
","/**
 * Combines all of the attributes that have been set on this {@code Builder}
 *
 * @return a new {@link FullyManagedDeviceProvisioningParams} object.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The constructor call for FullyManagedDeviceProvisioningParams in the return statement now includes two additional parameters, one for 'mAdminExtras' and another for 'mDemoDevice', so the code change type is 1,5.","The additional parameters in the constructor call can result in the creation of an object with different internal states as compared to the early version. Thus, the method potentially returns a different value which leads to the CI type 1."
211,<android.service.autofill.SaveInfo.Builder: Builder setTriggerId(AutofillId)>,32,33,,,,"{
    throwIfDestroyed();
    mTriggerId = Preconditions.checkNotNull(id);
    return this;
}","{
    throwIfDestroyed();
    mTriggerId = Objects.requireNonNull(id);
    return this;
}",1,"/**
 * Explicitly defines the view that should commit the autofill context when clicked.
 *
 * <p>Usually, the save request is only automatically
 * <a href=""#TriggeringSaveRequest"">triggered</a> after the activity is
 * finished or all relevant views become invisible, but there are scenarios where the
 * autofill context is automatically commited too late
 * &mdash;for example, when the activity manually clears the autofillable views when a
 * button is tapped. This method can be used to trigger the autofill save UI earlier in
 * these scenarios.
 *
 * <p><b>Note:</b> This method should only be used in scenarios where the automatic workflow
 * is not enough, otherwise it could trigger the autofill save UI when it should not&mdash;
 * for example, when the user entered invalid credentials for the autofillable views.
 */
","/**
 * Explicitly defines the view that should commit the autofill context when clicked.
 *
 * <p>Usually, the save request is only automatically
 * <a href=""#TriggeringSaveRequest"">triggered</a> after the activity is
 * finished or all relevant views become invisible, but there are scenarios where the
 * autofill context is automatically commited too late
 * &mdash;for example, when the activity manually clears the autofillable views when a
 * button is tapped. This method can be used to trigger the autofill save UI earlier in
 * these scenarios.
 *
 * <p><b>Note:</b> This method should only be used in scenarios where the automatic workflow
 * is not enough, otherwise it could trigger the autofill save UI when it should not&mdash;
 * for example, when the user entered invalid credentials for the autofillable views.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,"The implementation of validation (`Preconditions.checkNotNull(id)` to `Objects.requireNonNull(id)`) has changed; however, the logic of checking for `null` remains the same, and will therefore not lead to any different behavior for the API users. Since `Preconditions.checkNotNull` and `Objects.requireNonNull` accomplish the same task, this change affects only the method used to verify the input parameter's non-nullity, which is identified as dependent API change type 5.","There is no Compatibility Issue because the changes in the validation of 'id' do not affect the API's behavior from the callers' perspective. Both methods throw a NullPointerException when 'id' is null, and the return value or exception type remains unchanged."
212,<android.net.Ikev2VpnProfile.Builder: Builder setAuthPsk(byte[])>,32,33,,,,"{
    checkNotNull(psk, MISSING_PARAM_MSG_TMPL, ""psk"");
    resetAuthParams();
    mPresharedKey = psk;
    mType = VpnProfile.TYPE_IKEV2_IPSEC_PSK;
    return this;
}","{
    checkNotNull(psk, MISSING_PARAM_MSG_TMPL, ""psk"");
    checkBuilderSetter(mIkeTunConnParams != null, ""authPsk"");
    resetAuthParams();
    mPresharedKey = psk;
    mType = VpnProfile.TYPE_IKEV2_IPSEC_PSK;
    return this;
}",1,"/**
 * Set the IKEv2 authentication to use Preshared keys.
 *
 * <p>Setting this will configure IKEv2 authentication using a Preshared Key. Only one
 * authentication method may be set. This method will overwrite any previously set
 * authentication method.
 *
 * @param psk the key to be used for Pre-Shared Key authentication
 * @return this {@link Builder} object to facilitate chaining of method calls
 */
","/**
 * Set the IKEv2 authentication to use Preshared keys.
 *
 * <p>Setting this will configure IKEv2 authentication using a Preshared Key. Only one
 * authentication method may be set. This method will overwrite any previously set
 * authentication method.
 *
 * <p>If this {@link Builder} is constructed with an {@link IkeTunnelConnectionParams},
 * authentication details should be configured there, and calling this method will result in
 * an exception being thrown.
 *
 * @param psk the key to be used for Pre-Shared Key authentication
 * @return this {@link Builder} object to facilitate chaining of method calls
 */
",1,"[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]","[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]",0,,,,,,,"3,4",0,"The code change is the addition of a new statement checkBuilderSetter(mIkeTunConnParams != null, ""authPsk""); this change is not related to return or exception handling statements, but it adds a condition which can throw an exception. However, this is an additional check for a precondition to set the PSK (pre-shared key), it checks if mIkeTunConnParams is not null before allowing the setter to proceed. Since this specific change does not alter the existing control flow or affect the API's return values directly (it only asserts a new precondition), it is classified as a control dependency change (3) and an other statement changed (4).","There is no potential compatibility issue caused by this change as it doesn't affect existing return values or exception handlings under normal API usage. It simply adds a precondition check which should be transparent to the API user assuming the API is used correctly, that is, only after mIkeTunConnParams has been set. Therefore, the CI type is 0."
213,<android.os.BatteryUsageStats.Builder: Builder add(BatteryUsageStats)>,32,33,,,,"{
    if (!Arrays.equals(mCustomPowerComponentNames, stats.mCustomPowerComponentNames)) {
        throw new IllegalArgumentException(""BatteryUsageStats have different custom power components"");
    }
    if (mUserBatteryConsumerBuilders.size() != 0 || !stats.getUserBatteryConsumers().isEmpty()) {
        throw new UnsupportedOperationException(""Combining UserBatteryConsumers is not supported"");
    }
    mDischargedPowerLowerBoundMah += stats.mDischargedPowerLowerBound;
    mDischargedPowerUpperBoundMah += stats.mDischargedPowerUpperBound;
    mDischargePercentage += stats.mDischargePercentage;
    mStatsDurationMs = getStatsDuration() + stats.getStatsDuration();
    if (mStatsStartTimestampMs == 0 || stats.mStatsStartTimestampMs < mStatsStartTimestampMs) {
        mStatsStartTimestampMs = stats.mStatsStartTimestampMs;
    }
    final boolean addingLaterSnapshot = stats.mStatsEndTimestampMs > mStatsEndTimestampMs;
    if (addingLaterSnapshot) {
        mStatsEndTimestampMs = stats.mStatsEndTimestampMs;
    }
    for (int scope = 0; scope < AGGREGATE_BATTERY_CONSUMER_SCOPE_COUNT; scope++) {
        getAggregateBatteryConsumerBuilder(scope).add(stats.mAggregateBatteryConsumers[scope]);
    }
    for (UidBatteryConsumer consumer : stats.getUidBatteryConsumers()) {
        getOrCreateUidBatteryConsumerBuilder(consumer.getUid()).add(consumer);
    }
    if (addingLaterSnapshot) {
        mBatteryCapacityMah = stats.mBatteryCapacityMah;
        mBatteryTimeRemainingMs = stats.mBatteryTimeRemainingMs;
        mChargeTimeRemainingMs = stats.mChargeTimeRemainingMs;
    }
    return this;
}","{
    if (!Arrays.equals(mCustomPowerComponentNames, stats.mCustomPowerComponentNames)) {
        throw new IllegalArgumentException(""BatteryUsageStats have different custom power components"");
    }
    if (mIncludesProcessStateData && !stats.mIncludesProcessStateData) {
        throw new IllegalArgumentException(""Added BatteryUsageStats does not include process state data"");
    }
    if (mUserBatteryConsumerBuilders.size() != 0 || !stats.getUserBatteryConsumers().isEmpty()) {
        throw new UnsupportedOperationException(""Combining UserBatteryConsumers is not supported"");
    }
    mDischargedPowerLowerBoundMah += stats.mDischargedPowerLowerBound;
    mDischargedPowerUpperBoundMah += stats.mDischargedPowerUpperBound;
    mDischargePercentage += stats.mDischargePercentage;
    mDischargeDurationMs += stats.mDischargeDurationMs;
    mStatsDurationMs = getStatsDuration() + stats.getStatsDuration();
    if (mStatsStartTimestampMs == 0 || stats.mStatsStartTimestampMs < mStatsStartTimestampMs) {
        mStatsStartTimestampMs = stats.mStatsStartTimestampMs;
    }
    final boolean addingLaterSnapshot = stats.mStatsEndTimestampMs > mStatsEndTimestampMs;
    if (addingLaterSnapshot) {
        mStatsEndTimestampMs = stats.mStatsEndTimestampMs;
    }
    for (int scope = 0; scope < AGGREGATE_BATTERY_CONSUMER_SCOPE_COUNT; scope++) {
        getAggregateBatteryConsumerBuilder(scope).add(stats.mAggregateBatteryConsumers[scope]);
    }
    for (UidBatteryConsumer consumer : stats.getUidBatteryConsumers()) {
        getOrCreateUidBatteryConsumerBuilder(consumer.getUid()).add(consumer);
    }
    if (addingLaterSnapshot) {
        mBatteryCapacityMah = stats.mBatteryCapacityMah;
        mBatteryTimeRemainingMs = stats.mBatteryTimeRemainingMs;
        mChargeTimeRemainingMs = stats.mChargeTimeRemainingMs;
    }
    return this;
}",1,"/**
 * Adds battery usage stats from another snapshots. The two snapshots are assumed to be
 * non-overlapping, meaning that the power consumption estimates and session durations
 * can be simply summed across the two snapshots.  This remains true even if the timestamps
 * seem to indicate that the sessions are in fact overlapping: timestamps may be off as a
 * result of realtime clock adjustments by the user or the system.
 */
","/**
 * Adds battery usage stats from another snapshots. The two snapshots are assumed to be
 * non-overlapping, meaning that the power consumption estimates and session durations
 * can be simply summed across the two snapshots.  This remains true even if the timestamps
 * seem to indicate that the sessions are in fact overlapping: timestamps may be off as a
 * result of realtime clock adjustments by the user or the system.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"2,3,4","1,2",The method implementation has multiple changes: ,"- Moreover, the logic of one exception handling (mIncludesProcessStateData) is altered (the condition checked by the if statement has changed)."
215,<android.hardware.camera2.impl.CameraExtensionJpegProcessor.YuvCallback: void onImageAvailable(ImageReader)>,32,33,,,,"{
    Image yuvImage = null;
    Image jpegImage = null;
    try {
        yuvImage = mYuvReader.acquireNextImage();
        jpegImage = mOutputWriter.dequeueInputImage();
    } catch (IllegalStateException e) {
        if (yuvImage != null) {
            yuvImage.close();
        }
        if (jpegImage != null) {
            jpegImage.close();
        }
        Log.e(TAG, ""Failed to acquire processed yuv image or jpeg image!"");
        return;
    }
    ByteBuffer jpegBuffer = jpegImage.getPlanes()[0].getBuffer();
    jpegBuffer.clear();
    // Jpeg/blobs are expected to be configured with (w*h)x1
    int jpegCapacity = jpegImage.getWidth();
    Plane lumaPlane = yuvImage.getPlanes()[0];
    Plane crPlane = yuvImage.getPlanes()[1];
    Plane cbPlane = yuvImage.getPlanes()[2];
    Iterator<JpegParameters> jpegIter = mJpegParameters.iterator();
    JpegParameters jpegParams = null;
    while (jpegIter.hasNext()) {
        JpegParameters currentParams = jpegIter.next();
        if (currentParams.mTimeStamps.contains(yuvImage.getTimestamp())) {
            jpegParams = currentParams;
            jpegIter.remove();
            break;
        }
    }
    if (jpegParams == null) {
        if (mJpegParameters.isEmpty()) {
            Log.w(TAG, ""Empty jpeg settings queue! Using default jpeg orientation"" + "" and quality!"");
            jpegParams = new JpegParameters();
            jpegParams.mRotation = JPEG_DEFAULT_ROTATION;
            jpegParams.mQuality = JPEG_DEFAULT_QUALITY;
        } else {
            Log.w(TAG, ""No jpeg settings found with matching timestamp for current"" + "" processed input!"");
            Log.w(TAG, ""Using values from the top of the queue!"");
            jpegParams = mJpegParameters.poll();
        }
    }
    compressJpegFromYUV420pNative(yuvImage.getWidth(), yuvImage.getHeight(), lumaPlane.getBuffer(), lumaPlane.getPixelStride(), lumaPlane.getRowStride(), crPlane.getBuffer(), crPlane.getPixelStride(), crPlane.getRowStride(), cbPlane.getBuffer(), cbPlane.getPixelStride(), cbPlane.getRowStride(), jpegBuffer, jpegCapacity, jpegParams.mQuality, 0, 0, yuvImage.getWidth(), yuvImage.getHeight(), jpegParams.mRotation);
    yuvImage.close();
    try {
        mOutputWriter.queueInputImage(jpegImage);
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Failed to queue encoded result!"");
    } finally {
        jpegImage.close();
    }
}","{
    Image yuvImage = null;
    Image jpegImage = null;
    try {
        yuvImage = mYuvReader.acquireNextImage();
        jpegImage = mOutputWriter.dequeueInputImage();
    } catch (IllegalStateException e) {
        if (yuvImage != null) {
            yuvImage.close();
        }
        if (jpegImage != null) {
            jpegImage.close();
        }
        Log.e(TAG, ""Failed to acquire processed yuv image or jpeg image!"");
        return;
    }
    ByteBuffer jpegBuffer = jpegImage.getPlanes()[0].getBuffer();
    jpegBuffer.clear();
    // Jpeg/blobs are expected to be configured with (w*h)x1
    int jpegCapacity = jpegImage.getWidth();
    Plane lumaPlane = yuvImage.getPlanes()[0];
    Plane crPlane = yuvImage.getPlanes()[1];
    Plane cbPlane = yuvImage.getPlanes()[2];
    Iterator<JpegParameters> jpegIter = mJpegParameters.iterator();
    JpegParameters jpegParams = null;
    while (jpegIter.hasNext()) {
        JpegParameters currentParams = jpegIter.next();
        if (currentParams.mTimeStamps.contains(yuvImage.getTimestamp())) {
            jpegParams = currentParams;
            jpegIter.remove();
            break;
        }
    }
    if (jpegParams == null) {
        if (mJpegParameters.isEmpty()) {
            Log.w(TAG, ""Empty jpeg settings queue! Using default jpeg orientation"" + "" and quality!"");
            jpegParams = new JpegParameters();
            jpegParams.mRotation = JPEG_DEFAULT_ROTATION;
            jpegParams.mQuality = JPEG_DEFAULT_QUALITY;
        } else {
            Log.w(TAG, ""No jpeg settings found with matching timestamp for current"" + "" processed input!"");
            Log.w(TAG, ""Using values from the top of the queue!"");
            jpegParams = mJpegParameters.poll();
        }
    }
    compressJpegFromYUV420pNative(yuvImage.getWidth(), yuvImage.getHeight(), lumaPlane.getBuffer(), lumaPlane.getPixelStride(), lumaPlane.getRowStride(), crPlane.getBuffer(), crPlane.getPixelStride(), crPlane.getRowStride(), cbPlane.getBuffer(), cbPlane.getPixelStride(), cbPlane.getRowStride(), jpegBuffer, jpegCapacity, jpegParams.mQuality, 0, 0, yuvImage.getWidth(), yuvImage.getHeight(), jpegParams.mRotation);
    jpegImage.setTimestamp(yuvImage.getTimestamp());
    yuvImage.close();
    try {
        mOutputWriter.queueInputImage(jpegImage);
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Failed to queue encoded result!"");
    } finally {
        jpegImage.close();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
216,"<android.app.ContextImpl: void sendStickyBroadcast(Intent,Bundle)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, options, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * <p>Perform a {@link #sendBroadcast(Intent)} that is ""sticky,"" meaning the
 * Intent you are sending stays around after the broadcast is complete,
 * so that others can quickly retrieve that data through the return
 * value of {@link #registerReceiver(BroadcastReceiver, IntentFilter)}.  In
 * all other ways, this behaves the same as
 * {@link #sendBroadcast(Intent)}.
 *
 * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
 * can access them), no protection (anyone can modify them), and many other problems.
 * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
 * has changed, with another mechanism for apps to retrieve the current value whenever
 * desired.
 *
 * @param intent The Intent to broadcast; all receivers matching this
 * Intent will receive the broadcast, and the Intent will be held to
 * be re-broadcast to future receivers.
 * @param options (optional) Additional sending options, generated from a
 * {@link android.app.BroadcastOptions}.
 *
 * @see #sendBroadcast(Intent)
 * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
 */
","/**
 * <p>Perform a {@link #sendBroadcast(Intent)} that is ""sticky,"" meaning the
 * Intent you are sending stays around after the broadcast is complete,
 * so that others can quickly retrieve that data through the return
 * value of {@link #registerReceiver(BroadcastReceiver, IntentFilter)}.  In
 * all other ways, this behaves the same as
 * {@link #sendBroadcast(Intent)}.
 *
 * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
 * can access them), no protection (anyone can modify them), and many other problems.
 * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
 * has changed, with another mechanism for apps to retrieve the current value whenever
 * desired.
 *
 * @param intent The Intent to broadcast; all receivers matching this
 * Intent will receive the broadcast, and the Intent will be held to
 * be re-broadcast to future receivers.
 * @param options (optional) Additional sending options, generated from a
 * {@link android.app.BroadcastOptions}.
 *
 * @see #sendBroadcast(Intent)
 * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
 */
",0,"[@Override, @Deprecated]","[@Override, @Deprecated]",0,,,,,,,4,0,"The change in the code is related to the parameter order and content sent to the method `broadcastIntentWithFeature`; a null value has been moved in the parameters list, and now it's unclear what it represents, but the number and the type of parameters for the method call remain the same, meaning no new method is being called and no existing method's signature has been changed - the change type is 4.","The reordering and content shift within the parameters of the method call to `broadcastIntentWithFeature` does not introduce a difference in return values or exception handlings because the method signature for `broadcastIntentWithFeature` accepts both the null parameter and `AppOpsManager.OP_NONE` in varying positions for different overloads. Therefore, there's no Compatibility Issue - 0."
219,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,32,33,,,,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // update the default token on whatever manager we gave them.
            if (mWindowManager != null) {
                final WindowManagerImpl wm = (WindowManagerImpl) mWindowManager;
                wm.setDefaultToken(mWindowToken);
            }
        }

        @Override
        public boolean onGesture(AccessibilityGestureEvent gestureEvent) {
            return AccessibilityService.this.onGesture(gestureEvent);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(int displayId, @NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(displayId, region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked(int displayId) {
            AccessibilityService.this.onAccessibilityButtonClicked(displayId);
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }

        @Override
        public void onSystemActionsChanged() {
            AccessibilityService.this.onSystemActionsChanged();
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // update the default token on whatever manager we gave them.
            if (mWindowManager != null) {
                final WindowManagerImpl wm = (WindowManagerImpl) mWindowManager;
                wm.setDefaultToken(mWindowToken);
            }
        }

        @Override
        public boolean onGesture(AccessibilityGestureEvent gestureEvent) {
            return AccessibilityService.this.onGesture(gestureEvent);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(int displayId, @NonNull Region region, MagnificationConfig config) {
            AccessibilityService.this.onMagnificationChanged(displayId, region, config);
        }

        @Override
        public void onMotionEvent(MotionEvent event) {
            AccessibilityService.this.onMotionEvent(event);
        }

        @Override
        public void onTouchStateChanged(int displayId, int state) {
            AccessibilityService.this.onTouchStateChanged(displayId, state);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked(int displayId) {
            AccessibilityService.this.onAccessibilityButtonClicked(displayId);
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }

        @Override
        public void onSystemActionsChanged() {
            AccessibilityService.this.onSystemActionsChanged();
        }

        @Override
        public void createImeSession(IAccessibilityInputMethodSessionCallback callback) {
            if (mInputMethod != null) {
                mInputMethod.createImeSession(callback);
            }
        }

        @Override
        public void startInput(@Nullable RemoteAccessibilityInputConnection connection, @NonNull EditorInfo editorInfo, boolean restarting) {
            if (mInputMethod != null) {
                if (restarting) {
                    mInputMethod.restartInput(connection, editorInfo);
                } else {
                    mInputMethod.startInput(connection, editorInfo);
                }
            }
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",0,[@Override],[@Override],0,,,,,,,,,,
221,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean,TruncateAt,int)>",32,33,,,,"{
    boolean trust;
    if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
        replaceWith(source, paint, outerWidth, align, spacingMult, spacingAdd);
        mEllipsizedWidth = outerWidth;
        mEllipsizedStart = 0;
        mEllipsizedCount = 0;
        trust = true;
    } else {
        replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerWidth, align, spacingMult, spacingAdd);
        mEllipsizedWidth = ellipsizedWidth;
        trust = false;
    }
    init(getText(), paint, align, metrics, includePad, trust);
    return this;
}","{
    return replaceOrMake(source, paint, outerWidth, align, metrics, includePad, ellipsize, ellipsizedWidth, false);
}",1,"/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerwidth} is used instead
 */
","/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerWidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 * @param ellipsize whether to ellipsize the text if width of the text is longer than the
 * requested width
 * @param ellipsizedWidth the width to which this Layout is ellipsizing. If {@code ellipsize} is
 * {@code null}, or is {@link TextUtils.TruncateAt#MARQUEE} this value is
 * not used, {@code outerWidth} is used instead
 */
",1,,,0,,,,,,,"1,4",1,"The structure of the code has changed as the late version is now calling another method, replaceOrMake, directly with a new set of parameters than executing the logic within the method itself as in the early version. Additionally, variables related to ellipsizing have been removed, and the variable passed for trust is now 'false' instead of being conditionally set. The code change types are 1 and 4 because return statement has changed and other statements also changed.","Since the late version of the code delegates the work to another overload of replaceOrMake and also changes the conditions for setting trust and ellipsizing options, there is the potential for the API to return a different `BoringLayout` object under the same conditions; hence, the CI type is 1."
222,"<android.content.res.TypedArray: int getDimensionPixelSize(int,int)>",32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value + "", theme="" + mTheme);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type) + "", theme="" + mTheme);
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */
",0,,,0,,,,,,,4,0,"The only changes are in the string messages within the `throw new UnsupportedOperationException()` statements, adding additional context information: `"" + "", theme="" + mTheme`. These changes do not affect the behavior of the method regarding return values or exceptions thrown because they only alter the message provided by the exception but do not change the circumstances under which the exception is thrown.","There is no Compatibility Issue because the changes do not affect the type of exceptions thrown, the conditions under which exceptions are thrown, or the values returned by the method. The functional behavior remains the same despite the changes in exception messages."
224,<android.view.WindowInsets: String toString()>,32,33,,,,"{
    StringBuilder result = new StringBuilder(""WindowInsets{\n    "");
    for (int i = 0; i < SIZE; i++) {
        Insets insets = mTypeInsetsMap[i];
        Insets maxInsets = mTypeMaxInsetsMap[i];
        boolean visible = mTypeVisibilityMap[i];
        if (!Insets.NONE.equals(insets) || !Insets.NONE.equals(maxInsets) || visible) {
            result.append(Type.toString(1 << i)).append(""="").append(insets).append("" max="").append(maxInsets).append("" vis="").append(visible).append(""\n    "");
        }
    }
    result.append(mDisplayCutout != null ? ""cutout="" + mDisplayCutout : """");
    result.append(""\n    "");
    result.append(mRoundedCorners != null ? ""roundedCorners="" + mRoundedCorners : """");
    result.append(""\n    "");
    result.append(mPrivacyIndicatorBounds != null ? ""privacyIndicatorBounds="" + mPrivacyIndicatorBounds : """");
    result.append(""\n    "");
    result.append(isRound() ? ""round"" : """");
    result.append(""}"");
    return result.toString();
}","{
    StringBuilder result = new StringBuilder(""WindowInsets{\n    "");
    for (int i = 0; i < SIZE; i++) {
        Insets insets = mTypeInsetsMap[i];
        Insets maxInsets = mTypeMaxInsetsMap[i];
        boolean visible = mTypeVisibilityMap[i];
        if (!Insets.NONE.equals(insets) || !Insets.NONE.equals(maxInsets) || visible) {
            result.append(Type.toString(1 << i)).append(""="").append(insets).append("" max="").append(maxInsets).append("" vis="").append(visible).append(""\n    "");
        }
    }
    result.append(mDisplayCutout != null ? ""cutout="" + mDisplayCutout : """");
    result.append(""\n    "");
    result.append(mRoundedCorners != null ? ""roundedCorners="" + mRoundedCorners : """");
    result.append(""\n    "");
    result.append(mPrivacyIndicatorBounds != null ? ""privacyIndicatorBounds="" + mPrivacyIndicatorBounds : """");
    result.append(""\n    "");
    result.append(""compatInsetsTypes="" + mCompatInsetsTypes);
    result.append(""\n    "");
    result.append(""compatIgnoreVisibility="" + mCompatIgnoreVisibility);
    result.append(""\n    "");
    result.append(""systemWindowInsetsConsumed="" + mSystemWindowInsetsConsumed);
    result.append(""\n    "");
    result.append(""stableInsetsConsumed="" + mStableInsetsConsumed);
    result.append(""\n    "");
    result.append(""displayCutoutConsumed="" + mDisplayCutoutConsumed);
    result.append(""\n    "");
    result.append(isRound() ? ""round"" : """");
    result.append(""}"");
    return result.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"New string concatenations are added to the StringBuilder 'result' in the late version. These concatenations add new fields to the output string, so the code changes include both return statement change and other statement changes (specifically string concatenation changes) â€“ type 1 and 4 respectively.","These changes in the return statement will lead the method to return a different value or string content, therefore, the CI type is 1."
225,<android.content.pm.PackageInstaller.SessionInfo: boolean isStagedSessionActive()>,32,33,,,,"{
    return isStaged && isCommitted && !isStagedSessionApplied && !isStagedSessionFailed && !hasParentSessionId();
}","{
    return isStaged && isCommitted && !isSessionApplied && !isSessionFailed && !hasParentSessionId();
}",1,"/**
 * Returns {@code true} if this session is an active staged session.
 *
 * We consider a session active if it has been committed and it is either pending
 * verification, or will be applied at next reboot.
 *
 * <p>Staged session is active iff:
 * <ul>
 * <li>It is committed, i.e. {@link SessionInfo#isCommitted()} is {@code true}, and
 * <li>it is not applied, i.e. {@link SessionInfo#isStagedSessionApplied()} is {@code
 * false}, and
 * <li>it is not failed, i.e. {@link SessionInfo#isStagedSessionFailed()} is
 * {@code false}.
 * </ul>
 *
 * <p>In case of a multi-package session, reasoning above is applied to the parent session,
 * since that is the one that should have been {@link Session#commit committed}.
 */
","/**
 * Returns {@code true} if this session is an active staged session.
 *
 * We consider a session active if it has been committed and it is either pending
 * verification, or will be applied at next reboot.
 *
 * <p>Staged session is active iff:
 * <ul>
 * <li>It is committed, i.e. {@link SessionInfo#isCommitted()} is {@code true}, and
 * <li>it is not applied, i.e. {@link SessionInfo#isStagedSessionApplied()} is {@code
 * false}, and
 * <li>it is not failed, i.e. {@link SessionInfo#isStagedSessionFailed()} is
 * {@code false}.
 * </ul>
 *
 * <p>In case of a multi-package session, reasoning above is applied to the parent session,
 * since that is the one that should have been {@link Session#commit committed}.
 */
",0,,,0,,,,,,,4,0,"The change is reflected in the replacement of the condition variable 'isStagedSessionApplied' with 'isSessionApplied', and 'isStagedSessionFailed' with 'isSessionFailed', without altering the control structure or the method signature, so the code change type is 4.","Since only variable names (which are referencing to field variables of the object) are changed without any structural modification affecting the method's control flow or signature, and assuming the semantic meaning of the new fields are equivalent to the old ones within the context of the class, there should be no Compatibility Issue for the API method returning different values or throwing different exceptions. Therefore, CI type is 0."
227,"<android.os.UserManager: void setUserRestriction(String,boolean)>",32,33,,,,"{
    setUserRestriction(key, value, Process.myUserHandle());
}","{
    try {
        mService.setUserRestriction(key, value, getContextUserIfAppropriate());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the value of a specific restriction.
 * Requires the MANAGE_USERS permission.
 * @param key the key of the restriction
 * @param value the value for the restriction
 * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(
 * android.content.ComponentName, String)} or
 * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(
 * android.content.ComponentName, String)} instead.
 */
","/**
 * Sets the value of a specific restriction on the context user.
 * Requires the MANAGE_USERS permission.
 * @param key the key of the restriction
 * @param value the value for the restriction
 * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(
 * android.content.ComponentName, String)} or
 * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(
 * android.content.ComponentName, String)} instead.
 */
",1,"[@Deprecated, @RequiresPermission(Manifest.permission.MANAGE_USERS)]","[@Deprecated, @RequiresPermission(Manifest.permission.MANAGE_USERS), @UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU)]",1,,,,,,,5,0,The method setUserRestriction is changed from a simple call to another method to including try-catch structure and calling mService.setUserRestriction with different parameters (getContextUserIfAppropriate() instead of Process.myUserHandle()). The change is of type 5 because the dependent API (mService.setUserRestriction) call has changed in terms of parameters.,"There is no Compatibility Issue because both versions of the method don't return any value (the method is void) and the exception handling change (introduction of try-catch with rethrowFromSystemServer()) doesn't introduce a new kind of exception that could be thrown to the caller, it merely rethrows the caught RemoteException as a more general RuntimeException which is the usual way of handling RemoteException in Android system services."
229,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain()>,32,33,,,,"{
    AccessibilityNodeInfo info = sPool.acquire();
    if (sNumInstancesInUse != null) {
        sNumInstancesInUse.incrementAndGet();
    }
    return (info != null) ? info : new AccessibilityNodeInfo();
}","{
    return new AccessibilityNodeInfo();
}",1,"/**
 * Returns a cached instance if such is available otherwise a new one.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo()} instead.
 *
 * @return An instance.
 */
","/**
 * Instantiates a new AccessibilityNodeInfo.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo()} instead.
 * @return An instance.
 */
",1,,[@Deprecated],1,,,,,,,"1,4",1,"The early implementation has logic to obtain an AccessibilityNodeInfo instance from a pool (sPool.acquire()) or create a new one if the pool is empty, and it changes a static counter (sNumInstancesInUse.incrementAndGet()) if it's not null before returning the instance. The late implementation simply creates a new AccessibilityNodeInfo instance every time without acquiring from a pool or changing the static counter before returning it. Since the statements related to 'sPool.acquire()', 'sNumInstancesInUse.incrementAndGet()', and the ternary operation have been removed, this is classified as 'Other statement changed'. Additionally, because it affects the returned object (either fetched from the pool or a new instance), it is also 'Return statement changed'.","Previously, the objects returned could be recycled instances from a pool or a newly created one, depending on the pool status. With the changes, the method always returns a new instance, which is a fundamental change in behavior. Therefore, it is a CI caused by potential different return values or types."
230,<android.widget.ScrollView: boolean executeKeyEvent(KeyEvent)>,32,33,,,,"{
    mTempRect.setEmpty();
    if (!canScroll()) {
        if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
            View currentFocused = findFocus();
            if (currentFocused == this)
                currentFocused = null;
            View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);
            return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
        }
        return false;
    }
    boolean handled = false;
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(event.getKeyCode()) {
            case KeyEvent.KEYCODE_DPAD_UP:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_UP);
                } else {
                    handled = fullScroll(View.FOCUS_UP);
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_DOWN);
                } else {
                    handled = fullScroll(View.FOCUS_DOWN);
                }
                break;
            case KeyEvent.KEYCODE_SPACE:
                pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                break;
        }
    }
    return handled;
}","{
    mTempRect.setEmpty();
    if (!canScroll()) {
        if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK && event.getKeyCode() != KeyEvent.KEYCODE_ESCAPE) {
            View currentFocused = findFocus();
            if (currentFocused == this)
                currentFocused = null;
            View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);
            return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
        }
        return false;
    }
    boolean handled = false;
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(event.getKeyCode()) {
            case KeyEvent.KEYCODE_DPAD_UP:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_UP);
                } else {
                    handled = fullScroll(View.FOCUS_UP);
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_DOWN);
                } else {
                    handled = fullScroll(View.FOCUS_DOWN);
                }
                break;
            case KeyEvent.KEYCODE_SPACE:
                pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                break;
        }
    }
    return handled;
}",1,"/**
 * You can call this function yourself to have the scroll view perform
 * scrolling from a key event, just as if the event had been dispatched to
 * it by the view hierarchy.
 *
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
","/**
 * You can call this function yourself to have the scroll view perform
 * scrolling from a key event, just as if the event had been dispatched to
 * it by the view hierarchy.
 *
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */
",0,,,0,,,,,,,3,0,"A condition in an 'if' statement has been added (event.getKeyCode() != KeyEvent.KEYCODE_ESCAPE), so the change type is 3.","The additional condition checks if the KeyEvent is not the escape key before proceeding to find the next focusable view. However, if the KeyEvent was an escape key, the early version would process it, potentially focusing another view. While this could appear as a behavior change, escape keys are generally not used for navigation purposes within a ScrollView, so we assume that this change does not lead to a behavior that differs in a significant way from the original implementation. Thus, in the context of how this method is expected to be used, it does not lead to a Compatibility Issue. Hence, the CI type is 0."
231,<android.view.contentcapture.ContentCaptureSession: void setContentCaptureContext(ContentCaptureContext)>,32,33,,,,"{
    mClientContext = context;
    updateContentCaptureContext(context);
}","{
    if (!isContentCaptureEnabled())
        return;
    mClientContext = context;
    updateContentCaptureContext(context);
}",1,"/**
 * Sets the {@link ContentCaptureContext} associated with the session.
 *
 * <p>Typically used to change the context associated with the default session from an activity.
 */
","/**
 * Sets the {@link ContentCaptureContext} associated with the session.
 *
 * <p>Typically used to change the context associated with the default session from an activity.
 */
",0,,,0,,,,,,,3,0,"An 'if' control statement is added which checks if content capture is enabled before setting the content capture context and calling 'updateContentCaptureContext(context)'. This change is of type 3, control dependency change.","The newly added 'if' statement only skips the method's functionality if content capture is not enabled. This does not lead to a Compatibility Issue because it does not change the behavior when content capture is enabled; it only prevents any operations when it's not enabled, aligning with the expected behavior. Therefore, there is no Compatibility Issue here."
232,<android.os.Bundle: SparseArray<T> getSparseParcelableArray(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (SparseArray<T>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""SparseArray"", e);
        return null;
    }
}","{
    unparcel();
    Object o = getValue(key);
    if (o == null) {
        return null;
    }
    try {
        return (SparseArray<T>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""SparseArray"", e);
        return null;
    }
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 *
 * @return a SparseArray of T values, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a SparseArray of T values, or null
 *
 * @deprecated Use the type-safer {@link #getSparseParcelableArray(String, Class)} starting from
 * Android {@link Build.VERSION_CODES#TIRAMISU}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"4,5",0,"The method mMap.get(key) is replaced with getValue(key), which is a change in the way the value is retrieved. This indicates a dependent API change. Moreover, since getValue is likely to encapsulate mMap.get(key) or similar logic to retrieve the value, and the associated try-catch block and return behavior remain the same, the classification is 4,5.","Since there is no change in the control flow, exception handling, or the returned type/value from the method (assuming getValue(key) is a simple refactor without changing the behavior of getting the value from the map), there is no potential compatibility issue with the change in how the value is retrieved. Therefore, the CI type is 0."
233,<android.view.SurfaceView: void setClipBounds(Rect)>,32,33,,,,"{
    super.setClipBounds(clipBounds);
    if (!mClipSurfaceToBounds) {
        return;
    }
    // the viewport (rounding the corners of the clipBounds).
    if (mCornerRadius > 0f && !isAboveParent()) {
        invalidate();
    }
    if (mSurfaceControl != null) {
        if (mClipBounds != null) {
            mTmpRect.set(mClipBounds);
        } else {
            mTmpRect.set(0, 0, mSurfaceWidth, mSurfaceHeight);
        }
        SyncRtSurfaceTransactionApplier applier = new SyncRtSurfaceTransactionApplier(this);
        applier.scheduleApply(new SyncRtSurfaceTransactionApplier.SurfaceParams.Builder(mSurfaceControl).withWindowCrop(mTmpRect).build());
    }
}","{
    super.setClipBounds(clipBounds);
    if (!mClipSurfaceToBounds || mSurfaceControl == null) {
        return;
    }
    // the viewport (rounding the corners of the clipBounds).
    if (mCornerRadius > 0f && !isAboveParent()) {
        invalidate();
    }
    if (mClipBounds != null) {
        mTmpRect.set(mClipBounds);
    } else {
        mTmpRect.set(0, 0, mSurfaceWidth, mSurfaceHeight);
    }
    final Transaction transaction = new Transaction();
    transaction.setWindowCrop(mSurfaceControl, mTmpRect);
    applyTransactionOnVriDraw(transaction);
    invalidate();
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",0,"The changes include introduction of an early return if `mSurfaceControl` is `null` and changing the way transactions are applied by using `Transaction`, and `applyTransactionOnVriDraw`. These changes modify the control flow of the method and how the transactions are applied, so the code change type is 1,3.","Despite these changes, they do not alter what the method returns, because it is a void method, nor do they change the exception handling, so thereâ€™s no compatibility issue arising here. The additional return for the case `mSurfaceControl == null` does not represent a change in behavior for existing external calls because either way there would be no operation applied without `mSurfaceControl`. The change in how transactions are applied does not impact the public contract of the method. Hence the CI type is 0."
235,<android.app.ContextImpl: void sendBroadcast(Intent)>,32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There is a change in the order and the values of parameters passed to the method broadcastIntentWithFeature(); however, the implementation of the method itself and the flow of execution within sendBroadcast do not seem to be affected in a manner that changes the behavior or output of this API. The change is specifically to the parameters related to permissions exclusions and appears to be a refactoring where the position of `AppOpsManager.OP_NONE` and `null` have been swapped, so the code change type is 4.","Since the change is related to the internal parameters passed to another API method, and does not affect the output nor does it introduce new exceptions or alter control flow, it does not lead to a Compatibility Issue. Hence, the CI type is 0."
236,<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void onUnsyncableAccount(ISyncAdapterUnsyncableAccountCallback)>,32,33,,,,"{
    Handler.getMain().sendMessage(obtainMessage(AbstractThreadedSyncAdapter::handleOnUnsyncableAccount, AbstractThreadedSyncAdapter.this, cb));
}","{
    if (!isCallerSystem()) {
        return;
    }
    Handler.getMain().sendMessage(obtainMessage(AbstractThreadedSyncAdapter::handleOnUnsyncableAccount, AbstractThreadedSyncAdapter.this, cb));
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"An 'if' control block including a return statement has been introduced before the sendMessage method call, so the code change type is 3.","The introduction of the 'if' condition and the corresponding return statement creates the possibility that the code will return early without executing the sendMessage method. This potential early return is a change that may alter the behavior of the API and can cause it to return differently, leading to CI type 1."
237,"<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>",32,33,,,,"{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.add(new LinkAddress(address, prefixLength));
    mConfig.updateAllowedFamilies(address);
    return this;
}","{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.add(new LinkAddress(address, prefixLength));
    return this;
}",1,"/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * Adding an address implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
","/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * Adding an address implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The statement ""mConfig.updateAllowedFamilies(address);"" is removed in the late version, which belongs to the Other statement changed (4). Additionally, since 'mConfig' is likely a different API, its usage being removed indicates a change in a dependent API, hence change type 5.","The removal of the ""mConfig.updateAllowedFamilies(address);"" does not directly affect the return statement or exception handling, so there's no Compatibility Issue according to the previous definition. Therefore, CI type is 0."
238,<android.service.autofill.FillRequest: String singleRequestFlagsToString(int)>,32,33,,,,"{
    switch(value) {
        case FLAG_MANUAL_REQUEST:
            return ""FLAG_MANUAL_REQUEST"";
        case FLAG_COMPATIBILITY_MODE_REQUEST:
            return ""FLAG_COMPATIBILITY_MODE_REQUEST"";
        case FLAG_PASSWORD_INPUT_TYPE:
            return ""FLAG_PASSWORD_INPUT_TYPE"";
        case FLAG_VIEW_NOT_FOCUSED:
            return ""FLAG_VIEW_NOT_FOCUSED"";
        default:
            return Integer.toHexString(value);
    }
}","{
    switch(value) {
        case FLAG_MANUAL_REQUEST:
            return ""FLAG_MANUAL_REQUEST"";
        case FLAG_COMPATIBILITY_MODE_REQUEST:
            return ""FLAG_COMPATIBILITY_MODE_REQUEST"";
        case FLAG_PASSWORD_INPUT_TYPE:
            return ""FLAG_PASSWORD_INPUT_TYPE"";
        case FLAG_VIEW_NOT_FOCUSED:
            return ""FLAG_VIEW_NOT_FOCUSED"";
        case FLAG_SUPPORTS_FILL_DIALOG:
            return ""FLAG_SUPPORTS_FILL_DIALOG"";
        case FLAG_IME_SHOWING:
            return ""FLAG_IME_SHOWING"";
        default:
            return Integer.toHexString(value);
    }
}",1,,,0,[@DataClass.Generated.Member],[@DataClass.Generated.Member],0,,,,,,,"3,4",1,"Two new cases (FLAG_SUPPORTS_FILL_DIALOG and FLAG_IME_SHOWING) have been added to the switch statement, which is a control dependency change. Additionally, two new return statements are introduced for the new cases. So, the code change types are 3 for the control dependency change and 4 for the return statement additions.","The addition of new cases in the switch statement will potentially lead to different return values when either of the newly introduced values are passed to the method, which is a different behavior from the early version. Thus, there's a CI for potential different return values, classified as type 1."
239,<android.service.autofill.FillResponse.Builder: Builder setHeader(RemoteViews)>,32,33,,,,"{
    throwIfDestroyed();
    throwIfAuthenticationCalled();
    mHeader = Preconditions.checkNotNull(header);
    return this;
}","{
    throwIfDestroyed();
    throwIfAuthenticationCalled();
    mHeader = Objects.requireNonNull(header);
    return this;
}",1,"// TODO(b/69796626): make it sticky / update javadoc
","// TODO(b/69796626): make it sticky / update javadoc
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The method used to check for null has changed from `Preconditions.checkNotNull(header)` to `Objects.requireNonNull(header)`, so the code change type is 4,5 because a dependent API changed.","Both methods `Preconditions.checkNotNull(header)` and `Objects.requireNonNull(header)` perform the same operation, i.e., they throw a NullPointerException if the `header` argument is null. Given that they are semantically the same and that the annotations have not changed, there is no compatibility issue."
240,"<android.content.pm.CrossProfileApps: void startMainActivity(ComponentName,UserHandle)>",32,33,,,,"{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), mContext.getAttributionTag(), component, targetUser.getIdentifier(), true);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}","{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), mContext.getAttributionTag(), component, targetUser.getIdentifier(), true, null, null);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}",1,"/**
 * Starts the specified main activity of the caller package in the specified profile.
 *
 * @param component The ComponentName of the activity to launch, it must be exported and has
 * action {@link android.content.Intent#ACTION_MAIN}, category
 * {@link android.content.Intent#CATEGORY_LAUNCHER}. Otherwise, SecurityException will
 * be thrown.
 * @param targetUser The UserHandle of the profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 */
","/**
 * Starts the specified main activity of the caller package in the specified profile.
 *
 * @param component The ComponentName of the activity to launch, it must be exported and has
 * action {@link android.content.Intent#ACTION_MAIN}, category
 * {@link android.content.Intent#CATEGORY_LAUNCHER}. Otherwise, SecurityException will
 * be thrown.
 * @param targetUser The UserHandle of the profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 */
",0,,,0,,,,,,,5,0,"The call to 'startActivityAsUser' in the late implementation includes two additional null parameters when compared with the early version. This indicates a change in a dependent API, as the method signature for 'startActivityAsUser' seems to have been updated to include more parameters; thus, the code change type is 5.","There is no Compatibility Issue because the additional parameters are simply passed as 'null', and therefore they should not alter the behavior of the 'startActivityAsUser' method in a way that would affect how 'startMainActivity' operates assuming the 'startActivityAsUser' API is designed to handle null values for the newly added parameters appropriately."
241,<android.app.Activity: void onBackPressed()>,32,33,,,,"{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (!fragmentManager.isStateSaved() && fragmentManager.popBackStackImmediate()) {
        return;
    }
    if (!isTaskRoot()) {
        // If the activity is not the root of the task, allow finish to proceed normally.
        finishAfterTransition();
        return;
    }
    // Inform activity task manager that the activity received a back press while at the
    // root of the task. This call allows ActivityTaskManager to intercept or move the task
    // to the back.
    ActivityClient.getInstance().onBackPressedOnTaskRoot(mToken, new RequestFinishCallback(new WeakReference<>(this)));
    // be restored now.
    if (mIntent != null && mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) {
        restoreAutofillSaveUi();
    }
}","{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (!fragmentManager.isStateSaved() && fragmentManager.popBackStackImmediate()) {
        return;
    }
    navigateBack();
}",1,"/**
 * Called when the activity has detected the user's press of the back key. The default
 * implementation depends on the platform version:
 *
 * <ul>
 * <li>On platform versions prior to {@link android.os.Build.VERSION_CODES#S}, it
 * finishes the current activity, but you can override this to do whatever you want.
 *
 * <li><p>Starting with platform version {@link android.os.Build.VERSION_CODES#S}, for
 * activities that are the root activity of the task and also declare an
 * {@link android.content.IntentFilter} with {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER} in the manifest, the current activity and its
 * task will be moved to the back of the activity stack instead of being finished.
 * Other activities will simply be finished.
 *
 * <p>If you target version {@link android.os.Build.VERSION_CODES#S} or later and
 * override this method, it is strongly recommended to call through to the superclass
 * implementation after you finish handling navigation within the app.
 * </ul>
 *
 * @see #moveTaskToBack(boolean)
 */
","/**
 * Called when the activity has detected the user's press of the back key. The default
 * implementation depends on the platform version:
 *
 * <ul>
 * <li>On platform versions prior to {@link android.os.Build.VERSION_CODES#S}, it
 * finishes the current activity, but you can override this to do whatever you want.
 *
 * <li><p>Starting with platform version {@link android.os.Build.VERSION_CODES#S}, for
 * activities that are the root activity of the task and also declare an
 * {@link android.content.IntentFilter} with {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER} in the manifest, the current activity and its
 * task will be moved to the back of the activity stack instead of being finished.
 * Other activities will simply be finished.
 *
 * <li><p>If you target version {@link android.os.Build.VERSION_CODES#S} and
 * override this method, we strongly recommend to call through to the superclass
 * implementation after you finish handling navigation within the app.
 *
 * <li><p>If you target version {@link android.os.Build.VERSION_CODES#TIRAMISU} or later,
 * you should not use this method but register an {@link OnBackInvokedCallback} on an
 * {@link OnBackInvokedDispatcher} that you can retrieve using
 * {@link #getOnBackInvokedDispatcher()}. You should also set
 * {@code android:enableOnBackInvokedCallback=""true""} in the application manifest.
 * <p>Alternatively, you can use
 * {@code  androidx.activity.ComponentActivity#getOnBackPressedDispatcher()}
 * for backward compatibility.
 * </ul>
 *
 * @see #moveTaskToBack(boolean)
 *
 * @deprecated Use {@link OnBackInvokedCallback} or
 * {@code androidx.activity.OnBackPressedCallback} to handle back navigation instead.
 * <p>
 * Starting from Android 13 (API level 33), back event handling is
 * moving to an ahead-of-time model and {@link Activity#onBackPressed()} and
 * {@link KeyEvent#KEYCODE_BACK} should not be used to handle back events (back gesture or
 * back button click). Instead, an {@link OnBackInvokedCallback} should be registered using
 * {@link Activity#getOnBackInvokedDispatcher()}
 * {@link OnBackInvokedDispatcher#registerOnBackInvokedCallback(int, OnBackInvokedCallback)
 * .registerOnBackInvokedCallback(priority, callback)}.
 */
",1,,[@Deprecated],1,,,,,,,"1,4",1,There are several significant changes in the implementation: ,- The conditions and the code for restoring autofill UI have been entirely removed.
242,"<android.inputmethodservice.IInputMethodWrapper: void dump(FileDescriptor,PrintWriter,String[])>",32,33,,,,"{
    AbstractInputMethodService target = mTarget.get();
    if (target == null) {
        return;
    }
    if (target.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        fout.println(""Permission Denial: can't dump InputMethodManager from from pid="" + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid());
        return;
    }
    CountDownLatch latch = new CountDownLatch(1);
    mCaller.getHandler().sendMessageAtFrontOfQueue(mCaller.obtainMessageOOOO(DO_DUMP, fd, fout, args, latch));
    try {
        if (!latch.await(5, TimeUnit.SECONDS)) {
            fout.println(""Timeout waiting for dump"");
        }
    } catch (InterruptedException e) {
        fout.println(""Interrupted waiting for dump"");
    }
}","{
    InputMethodServiceInternal target = mTarget.get();
    if (target == null) {
        return;
    }
    if (target.getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        fout.println(""Permission Denial: can't dump InputMethodManager from from pid="" + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid());
        return;
    }
    CountDownLatch latch = new CountDownLatch(1);
    mCaller.getHandler().sendMessageAtFrontOfQueue(mCaller.obtainMessageOOOO(DO_DUMP, fd, fout, args, latch));
    try {
        if (!latch.await(5, TimeUnit.SECONDS)) {
            fout.println(""Timeout waiting for dump"");
        }
    } catch (InterruptedException e) {
        fout.println(""Interrupted waiting for dump"");
    }
}",1,,,0,"[@BinderThread, @Override]","[@BinderThread, @Override]",0,,,,,,,5,0,"The type of target has changed from AbstractInputMethodService to InputMethodServiceInternal, and the permission check is now performed on the context of the target (`target.getContext().checkCallingOrSelfPermission`) instead of directly on the target, so the change type is 5.","No Compatibility Issue should arise from these changes as they do not affect the behavior of the API from the caller's perspective. The permission check is still performed and the handling of the dump operation (including the timeout mechanism) remains the same. Therefore, there should be no different returns or exceptions directly visible to the caller due to this change."
243,<android.widget.TextView.Marquee: void tick()>,32,33,,,,"{
    if (mStatus != MARQUEE_RUNNING) {
        return;
    }
    mChoreographer.removeFrameCallback(mTickCallback);
    final TextView textView = mView.get();
    if (textView != null && (textView.isFocused() || textView.isSelected())) {
        long currentMs = mChoreographer.getFrameTime();
        long deltaMs = currentMs - mLastAnimationMs;
        mLastAnimationMs = currentMs;
        float deltaPx = deltaMs * mPixelsPerMs;
        mScroll += deltaPx;
        if (mScroll > mMaxScroll) {
            mScroll = mMaxScroll;
            mChoreographer.postFrameCallbackDelayed(mRestartCallback, MARQUEE_DELAY);
        } else {
            mChoreographer.postFrameCallback(mTickCallback);
        }
        textView.invalidate();
    }
}","{
    if (mStatus != MARQUEE_RUNNING) {
        return;
    }
    mChoreographer.removeFrameCallback(mTickCallback);
    final TextView textView = mView.get();
    if (textView != null && textView.isAggregatedVisible() && (textView.isFocused() || textView.isSelected())) {
        long currentMs = mChoreographer.getFrameTime();
        long deltaMs = currentMs - mLastAnimationMs;
        mLastAnimationMs = currentMs;
        float deltaPx = deltaMs * mPixelsPerMs;
        mScroll += deltaPx;
        if (mScroll > mMaxScroll) {
            mScroll = mMaxScroll;
            mChoreographer.postFrameCallbackDelayed(mRestartCallback, MARQUEE_DELAY);
        } else {
            mChoreographer.postFrameCallback(mTickCallback);
        }
        textView.invalidate();
    }
}",1,,,0,,,0,,,,,,,3,0,"The additional condition `textView.isAggregatedVisible()` has been added to the existing `if` statement's condition, which is a control dependency change, so the code change type is 3.","Despite the added condition, there is no change in the API's possible return types or values because the `void tick()` method does not return any value; it only performs actions if certain conditions are met. Additionally, no new exceptions are thrown, and none are handled differently. Therefore, the change does not cause a Compatibility Issue, as it only refines when the action within the if condition is executed, without affecting the external behavior of the method in a way that can introduce incompatibilities with existing valid client code. Thus, the CI type is 0."
244,<android.hardware.SensorPrivacyManager: boolean supportsSensorToggle(int)>,32,33,,,,"{
    try {
        Boolean val = mToggleSupportCache.get(sensor);
        if (val == null) {
            val = mService.supportsSensorToggle(sensor);
            mToggleSupportCache.put(sensor, val);
        }
        return val;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return supportsSensorToggle(TOGGLE_TYPE_SOFTWARE, sensor);
}",1,"/**
 * Checks if the given toggle is supported on this device
 * @param sensor The sensor to check
 * @return whether the toggle for the sensor is supported on this device.
 */
","/**
 * Checks if the given toggle is supported on this device
 * @param sensor The sensor to check
 * @return whether the toggle for the sensor is supported on this device.
 */
",0,,,0,,,,,,,"1,4,5",1,"The logic of the method has significantly changed; the late version solely returns the result of the call to `supportsSensorToggle(TOGGLE_TYPE_SOFTWARE, sensor)`. This method itself might have different logic to what was previously executed in the early version, which involved a cache check and a separate direct call to `mService.supportsSensorToggle(sensor)`. There's also a change in how the method handles the potential RemoteException (now implicitly within `supportsSensorToggle` call). The fact that the late version is now calling another method implies a dependent API has changed as well. The code change types are 1 for the return statement changed, 4 for other statement changed, and 5 for dependent API changed.","The change in the return statement means that the method no longer checks the cache which could lead to a return value different from what was previously cached in the early version. Also, a RemoteException would now be handled differently since it's wrapped within the new `supportsSensorToggle` method. If this new called method handles the exception differently or doesn't throw it at all (let's say, it returns a default value instead), that would constitute a difference in exception handling. However, the RemoteException handling within the new method isn't visible to us, so we can only assume based on the available code that the potential for a CI due to different return values is there, which is CI type 1."
245,"<android.content.res.TypedArray: float getDimension(int,float)>",32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value + "", theme="" + mTheme);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type) + "", theme="" + mTheme);
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */
",0,,,0,,,,,,,4,0,"The change is strictly a message in the exception being thrown, adding "", theme="" + mTheme to the message text in both UnsupportedOperationException throws. This does not affect the actual logic or behavior of the method, only the content of the message in the thrown exception, so the code change type is 4.","The functionality of the method has not been altered, and it is still throwing the same exceptions under the same conditions, so there is no CI. The only thing that's different is the error message provided to the developer, which is not a behavioral change regarding the return values or exception handling. Hence, no Compatibility Issue arises."
246,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",32,33,,,,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    // Activity.attach expects a non-null Application Object.
    if (application == null) {
        application = new Application();
    }
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null, /* activityConfigCallback */
    null, /*assistToken*/
    null);
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    // Activity.attach expects a non-null Application Object.
    if (application == null) {
        application = new Application();
    }
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null, /* activityCallback */
    null, /*assistToken*/
    null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",0,,,0,,,,,,,4,0,"Only a comment change is observed from /* activityConfigCallback */ to /* activityCallback */, which does not alter the execution of the code, so the code change type is 4.","Since the actual implementation code did not change (only comments changed), there should be no difference in the API behavior. Therefore, no Compatibility Issue should arise, and the CI type is 0."
248,<android.os.Environment: boolean isExternalStorageLegacy(File)>,32,33,,,,"{
    final Context context = AppGlobals.getInitialApplication();
    final int uid = context.getApplicationInfo().uid;
    // Isolated processes and Instant apps are never allowed to be in scoped storage
    if (Process.isIsolated(uid)) {
        return false;
    }
    final PackageManager packageManager = context.getPackageManager();
    if (packageManager.isInstantApp()) {
        return false;
    }
    boolean defaultScopedStorage = Compatibility.isChangeEnabled(DEFAULT_SCOPED_STORAGE);
    boolean forceEnableScopedStorage = Compatibility.isChangeEnabled(FORCE_ENABLE_SCOPED_STORAGE);
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageEnforced(defaultScopedStorage, forceEnableScopedStorage)) {
        return false;
    }
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageDisabled(defaultScopedStorage, forceEnableScopedStorage)) {
        return true;
    }
    final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
    final String opPackageName = context.getOpPackageName();
    if (appOps.noteOpNoThrow(AppOpsManager.OP_LEGACY_STORAGE, uid, opPackageName) == AppOpsManager.MODE_ALLOWED) {
        return true;
    }
    // ""--no-isolated-storage"" flag.
    return appOps.noteOpNoThrow(AppOpsManager.OP_NO_ISOLATED_STORAGE, uid, opPackageName) == AppOpsManager.MODE_ALLOWED;
}","{
    final Context context = AppGlobals.getInitialApplication();
    final int uid = context.getApplicationInfo().uid;
    // Isolated processes and Instant apps are never allowed to be in scoped storage
    if (Process.isIsolated(uid) || Process.isSdkSandboxUid(uid)) {
        return false;
    }
    final PackageManager packageManager = context.getPackageManager();
    if (packageManager.isInstantApp()) {
        return false;
    }
    // Apps with PROPERTY_NO_APP_DATA_STORAGE should not be allowed in scoped storage
    final String packageName = AppGlobals.getInitialPackage();
    try {
        final PackageManager.Property noAppStorageProp = packageManager.getProperty(PackageManager.PROPERTY_NO_APP_DATA_STORAGE, packageName);
        if (noAppStorageProp != null && noAppStorageProp.getBoolean()) {
            return false;
        }
    } catch (PackageManager.NameNotFoundException ignore) {
    // Property not defined for the package
    }
    boolean defaultScopedStorage = Compatibility.isChangeEnabled(DEFAULT_SCOPED_STORAGE);
    boolean forceEnableScopedStorage = Compatibility.isChangeEnabled(FORCE_ENABLE_SCOPED_STORAGE);
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageEnforced(defaultScopedStorage, forceEnableScopedStorage)) {
        return false;
    }
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageDisabled(defaultScopedStorage, forceEnableScopedStorage)) {
        return true;
    }
    final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
    final String opPackageName = context.getOpPackageName();
    if (appOps.noteOpNoThrow(AppOpsManager.OP_LEGACY_STORAGE, uid, opPackageName) == AppOpsManager.MODE_ALLOWED) {
        return true;
    }
    // ""--no-isolated-storage"" flag.
    return appOps.noteOpNoThrow(AppOpsManager.OP_NO_ISOLATED_STORAGE, uid, opPackageName) == AppOpsManager.MODE_ALLOWED;
}",1,"/**
 * Returns whether the shared/external storage media is a
 * legacy view that includes files not owned by the app.
 * <p>
 * This value may be different from the value requested by
 * {@code requestLegacyExternalStorage} in the app's manifest, since an app
 * may inherit its legacy state based on when it was first installed, target sdk and other
 * factors.
 * <p>
 * Non-legacy apps can continue to discover and read media belonging to
 * other apps via {@link android.provider.MediaStore}.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
","/**
 * Returns whether the shared/external storage media is a
 * legacy view that includes files not owned by the app.
 * <p>
 * This value may be different from the value requested by
 * {@code requestLegacyExternalStorage} in the app's manifest, since an app
 * may inherit its legacy state based on when it was first installed, target sdk and other
 * factors.
 * <p>
 * Non-legacy apps can continue to discover and read media belonging to
 * other apps via {@link android.provider.MediaStore}.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
",0,,,0,,,,,,,"3,4","1,2","The new API implementation introduces an additional conditional check `Process.isSdkSandboxUid(uid)` combined with `Process.isIsolated(uid)` in an `if` statement, and new exception handling for `PackageManager.NameNotFoundException`. This results in both a control dependency change under type 3 and other statement changes for the exception handling under type 4.","These changes could potentially lead to a Compatibility Issue since an additional condition might change the return value (`return false;` might be executed in the late version where it wouldn't in the earlier version). Additionally, in the late version, a `PackageManager.NameNotFoundException` will lead to different behavior as it is caught and ignored, while in the early version, there is no such exception handling. Therefore, the potential Compatibility Issue can be classified under types 1 for the different return values and 2 for the different exception handling."
249,"<android.os.Bundle: void writeToParcel(Parcel,int)>",32,33,,,,"{
    final boolean oldAllowFds = parcel.pushAllowFds((mFlags & FLAG_ALLOW_FDS) != 0);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}","{
    final boolean oldAllowFds = parcel.pushAllowFds((mFlags & FLAG_ALLOW_FDS) != 0);
    try {
        writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",0,[@Override],[@Override],0,,,,,,,"4,5",0,"The only change is the method called inside the try block: `super.writeToParcelInner(parcel, flags)` is replaced by `writeToParcelInner(parcel, flags)`. This indicates a change in the dependency on the method being called (superclass method vs. current class method or a different method with the same name), but the behavior related to exception handling or returning a value does not change fundamentally. Therefore, the change type is 4,5.","The method `writeToParcelInner` might be an overridden method in the class or a different implementation. However, since the fundamental behavior of `writeToParcel` (in terms of what exceptions it throws and what it returns, which is nothing since the return type is void) remains the same, it is unlikely to cause a compatibility issue. The only potential issue could come from the behavior of the new `writeToParcelInner` method, but without further evidence, we can assume that the replacement method adheres to a similar contract as the original method. Therefore, there is no compatibility issue."
250,<android.app.slice.SliceManager: Collection<Uri> getSliceDescendants(Uri)>,32,33,,,,"{
    ContentResolver resolver = mContext.getContentResolver();
    try (ContentProviderClient provider = resolver.acquireUnstableContentProviderClient(uri)) {
        Bundle extras = new Bundle();
        extras.putParcelable(SliceProvider.EXTRA_BIND_URI, uri);
        final Bundle res = provider.call(SliceProvider.METHOD_GET_DESCENDANTS, null, extras);
        return res.getParcelableArrayList(SliceProvider.EXTRA_SLICE_DESCENDANTS);
    } catch (RemoteException e) {
        Log.e(TAG, ""Unable to get slice descendants"", e);
    }
    return Collections.emptyList();
}","{
    ContentResolver resolver = mContext.getContentResolver();
    try (ContentProviderClient provider = resolver.acquireUnstableContentProviderClient(uri)) {
        if (provider == null) {
            Log.w(TAG, TextUtils.formatSimple(""Unknown URI: %s"", uri));
        } else {
            Bundle extras = new Bundle();
            extras.putParcelable(SliceProvider.EXTRA_BIND_URI, uri);
            final Bundle res = provider.call(SliceProvider.METHOD_GET_DESCENDANTS, null, extras);
            return res.getParcelableArrayList(SliceProvider.EXTRA_SLICE_DESCENDANTS);
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""Unable to get slice descendants"", e);
    }
    return Collections.emptyList();
}",1,"/**
 * Obtains a list of slices that are descendants of the specified Uri.
 * <p>
 * Not all slice providers will implement this functionality, in which case,
 * an empty collection will be returned.
 *
 * @param uri The uri to look for descendants under.
 * @return All slices within the space.
 * @see SliceProvider#onGetSliceDescendants(Uri)
 */
","/**
 * Obtains a list of slices that are descendants of the specified Uri.
 * <p>
 * Not all slice providers will implement this functionality, in which case,
 * an empty collection will be returned.
 *
 * @param uri The uri to look for descendants under.
 * @return All slices within the space.
 * @see SliceProvider#onGetSliceDescendants(Uri)
 */
",0,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",0,,,,,,,3,0,"The late version introduces a new control dependency: an 'if' statement checking if ""provider == null"". This change falls under the category of a control dependency change (3).","The newly introduced if-statement adds logging when the provider is null and continues without executing the rest of the try block. However, since whether the provider is null or not, it still results in Collections.emptyList() being returned if an exception is not thrown. As there is no change to the control flow that would affect the value or type returned by the method, or the exceptions thrown by the method, under normal operation where the provider is not null, there is no Compatibility Issue (0)."
251,"<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain(View,int)>",32,33,,,,"{
    AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
    info.setSource(root, virtualDescendantId);
    return info;
}","{
    return new AccessibilityNodeInfo(root, virtualDescendantId);
}",1,"/**
 * Returns a cached instance if such is available otherwise a new one
 * and sets the source.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo(View, int)} instead.
 *
 * @param root The root of the virtual subtree.
 * @param virtualDescendantId The id of the virtual descendant.
 * @return An instance.
 *
 * @see #setSource(View, int)
 */
","/**
 * Returns a cached instance if such is available otherwise a new one
 * and sets the source.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo(View, int)} instead.
 *
 * @param root The root of the virtual subtree.
 * @param virtualDescendantId The id of the virtual descendant.
 * @return An instance.
 *
 * @see #setSource(View, int)
 */
",1,,[@Deprecated],1,,,,,,,4,0,"The implementation of how an `AccessibilityNodeInfo` object is obtained and initialized has been changed to instantiation via a new constructor. The method still returns an `AccessibilityNodeInfo` object, but the process of its creation is different. This is, therefore, classified as 'Other statement changed' or type 4.","Despite the change in the object creation process, the method signature remains the same, and it returns the same type of object (`AccessibilityNodeInfo`). Therefore, there's no compatibility issue regarding return types or values as the change does not affect the method signature or return type; hence, it is type 0, 'No Compatibility Issue'. The annotation change (@Deprecated) does not affect the runtime behavior of the method, so it also does not introduce a compatibility issue."
253,<android.content.pm.CrossProfileApps: Drawable getProfileSwitchingIconDrawable(UserHandle)>,32,33,,,,"{
    verifyCanAccessUser(userHandle);
    final boolean isManagedProfile = mUserManager.isManagedProfile(userHandle.getIdentifier());
    if (isManagedProfile) {
        return mResources.getDrawable(R.drawable.ic_corp_badge, null);
    } else {
        return UserIcons.getDefaultUserIcon(mResources, UserHandle.USER_SYSTEM, true);
    }
}","{
    verifyCanAccessUser(userHandle);
    final boolean isManagedProfile = mUserManager.isManagedProfile(userHandle.getIdentifier());
    if (isManagedProfile) {
        return mContext.getPackageManager().getUserBadgeForDensityNoBackground(userHandle, /* density= */
        0);
    } else {
        return UserIcons.getDefaultUserIcon(mResources, UserHandle.USER_SYSTEM, true);
    }
}",1,"/**
 * Return a drawable that calling app can show to user for the semantic of profile switching --
 * launching its own activity in specified user profile. For example, it may return a briefcase
 * icon if the given user handle is the managed profile one.
 *
 * @param userHandle The UserHandle of the target profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 * @return an icon that calling app can show user for the semantic of launching its own
 * activity in specified user profile.
 *
 * @see #startMainActivity(ComponentName, UserHandle)
 */
","/**
 * Return a drawable that calling app can show to user for the semantic of profile switching --
 * launching its own activity in specified user profile. For example, it may return a briefcase
 * icon if the given user handle is the managed profile one.
 *
 * @param userHandle The UserHandle of the target profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 * @return an icon that calling app can show user for the semantic of launching its own
 * activity in specified user profile.
 *
 * @see #startMainActivity(ComponentName, UserHandle)
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The dependent API `getDrawable(int, Theme)` has been replaced with `getUserBadgeForDensityNoBackground(UserHandle, int)` when `isManagedProfile` is true. Additionally, the type of icon returned for managed profiles has changed. Consequently, the code change type includes a return statement change (1) as well as a dependent API change (5).","The change in the method used to retrieve the drawable for managed profiles implies that the return value for those profiles will potentially be different, leading to a Compatibility Issue due to a potential different return value (1)."
254,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,32,33,,,,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mLayout.packageName = getPackageName();
    mIWallpaperEngine.mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mIWallpaperEngine.mDisplay;
    // Use window context of TYPE_WALLPAPER so client can access UI resources correctly.
    mDisplayContext = createDisplayContext(mDisplay).createWindowContext(TYPE_WALLPAPER, null);
    mWallpaperDimAmount = mDisplayContext.getResources().getFloat(com.android.internal.R.dimen.config_wallpaperDimAmount);
    mDisplayState = mDisplay.getState();
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mLayout.packageName = getPackageName();
    mIWallpaperEngine.mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mIWallpaperEngine.mDisplay;
    // Use window context of TYPE_WALLPAPER so client can access UI resources correctly.
    mDisplayContext = createDisplayContext(mDisplay).createWindowContext(TYPE_WALLPAPER, null);
    mDefaultDimAmount = mDisplayContext.getResources().getFloat(com.android.internal.R.dimen.config_wallpaperDimAmount);
    mWallpaperDimAmount = mDefaultDimAmount;
    mPreviousWallpaperDimAmount = mWallpaperDimAmount;
    mDisplayState = mDisplay.getState();
    mDisplayInstallOrientation = mDisplay.getInstallOrientation();
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,0,,,0,,,,,,,4,0,"The changes are in the introduction of new member variables such as 'mDefaultDimAmount' and 'mPreviousWallpaperDimAmount', and the assignment of 'mWallpaperDimAmount = mDefaultDimAmount;' instead of directly from the resources. Additionally, 'mDisplayInstallOrientation' is retrieved and stored from 'mDisplay'. These changes fall under 'Other statement changed', so the code change type is 4.","There is no change that would directly affect return values or exception throwing since these lines are adding new fields, and storing information. The overarching behavior of the method is not altered from an external perspective; therefore, these changes should not result in a Compatibility Issue. Hence, CI type is 0."
255,"<android.app.Notification.Builder: Builder recoverBuilder(Context,Notification)>",32,33,,,,"{
    // Re-create notification context so we can access app resources.
    ApplicationInfo applicationInfo = n.extras.getParcelable(EXTRA_BUILDER_APPLICATION_INFO);
    Context builderContext;
    if (applicationInfo != null) {
        try {
            builderContext = context.createApplicationContext(applicationInfo, Context.CONTEXT_RESTRICTED);
        } catch (NameNotFoundException e) {
            Log.e(TAG, ""ApplicationInfo "" + applicationInfo + "" not found"");
            // try with our context
            builderContext = context;
        }
    } else {
        // try with given context
        builderContext = context;
    }
    return new Builder(builderContext, n);
}","{
    // Re-create notification context so we can access app resources.
    ApplicationInfo applicationInfo = n.extras.getParcelable(EXTRA_BUILDER_APPLICATION_INFO, ApplicationInfo.class);
    Context builderContext;
    if (applicationInfo != null) {
        try {
            builderContext = context.createApplicationContext(applicationInfo, Context.CONTEXT_RESTRICTED);
        } catch (NameNotFoundException e) {
            Log.e(TAG, ""ApplicationInfo "" + applicationInfo + "" not found"");
            // try with our context
            builderContext = context;
        }
    } else {
        // try with given context
        builderContext = context;
    }
    return new Builder(builderContext, n);
}",1,"/**
 * Creates a Builder from an existing notification so further changes can be made.
 * @param context The context for your application / activity.
 * @param n The notification to create a Builder from.
 */
","/**
 * Creates a Builder from an existing notification so further changes can be made.
 * @param context The context for your application / activity.
 * @param n The notification to create a Builder from.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,"The method getParcelable from the `n.extras` object has been changed to include the class `ApplicationInfo.class` as a parameter, which corresponds to a change in a Dependent API. Therefore, the change type is 5.","Since this change only affects how the `ApplicationInfo` object is obtained, and does not affect the behavior of the `recoverBuilder` method (as both versions lead to the construction of a new `Builder` object with the same parameters), no Compatibility Issue arises from this change. Thus, there is no CI."
257,"<android.service.quicksettings.TileService: void requestListeningState(Context,ComponentName)>",32,33,,,,"{
    final ComponentName sysuiComponent = ComponentName.unflattenFromString(context.getResources().getString(com.android.internal.R.string.config_systemUIServiceComponent));
    Intent intent = new Intent(ACTION_REQUEST_LISTENING);
    intent.putExtra(Intent.EXTRA_COMPONENT_NAME, component);
    intent.setPackage(sysuiComponent.getPackageName());
    context.sendBroadcast(intent, Manifest.permission.BIND_QUICK_SETTINGS_TILE);
}","{
    StatusBarManager sbm = context.getSystemService(StatusBarManager.class);
    if (sbm == null) {
        Log.e(TAG, ""No StatusBarManager service found"");
        return;
    }
    sbm.requestTileServiceListeningState(component);
}",1,"/**
 * Requests that a tile be put in the listening state so it can send an update.
 *
 * This method is only applicable to tiles that have {@link #META_DATA_ACTIVE_TILE} defined
 * as true on their TileService Manifest declaration, and will do nothing otherwise.
 */
","/**
 * Requests that a tile be put in the listening state so it can send an update.
 *
 * This method is only applicable to tiles that have {@link #META_DATA_ACTIVE_TILE} defined
 * as true on their TileService Manifest declaration, and will do nothing otherwise.
 *
 * For apps targeting {@link Build.VERSION_CODES#TIRAMISU} or later, this call may throw
 * the following exceptions if the request is not valid:
 * <ul>
 * <li> {@link NullPointerException} if {@code component} is {@code null}.</li>
 * <li> {@link SecurityException} if the package of {@code component} does not match
 * the calling package or if the calling user cannot act on behalf of the user from the
 * {@code context}.</li>
 * <li> {@link IllegalArgumentException} if the user of the {@code context} is not the
 * current user.</li>
 * </ul>
 */
",1,,,0,,,,,,,"1,4,5",1,"The entire implementation has been overhauled, with the early version using an Intent to request listening state which is sent via sendBroadcast, whereas the late version invokes a direct method call on the StatusBarManager class. Plus, the dependent APIs used in the method implementation have changed (sendBroadcast vs. requestTileServiceListeningState), so the code change types are 1,4,5.","The method implementation has changed significantly, which potentially leads to a different return value or type. In the early version, there is no return type but an implicit return at the end of the method. In the late version, there is an actual return statement in a new control flow path. Hence, this could cause a compatibility issue of type 1."
258,<android.app.Activity: Uri getReferrer()>,32,33,,,,"{
    Intent intent = getIntent();
    try {
        Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
        if (referrer != null) {
            return referrer;
        }
        String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
        if (referrerName != null) {
            return Uri.parse(referrerName);
        }
    } catch (BadParcelableException e) {
        Log.w(TAG, ""Cannot read referrer from intent;"" + "" intent extras contain unknown custom Parcelable objects"");
    }
    if (mReferrer != null) {
        return new Uri.Builder().scheme(""android-app"").authority(mReferrer).build();
    }
    return null;
}","{
    Intent intent = getIntent();
    if (intent != null) {
        try {
            Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
            if (referrer != null) {
                return referrer;
            }
            String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
            if (referrerName != null) {
                return Uri.parse(referrerName);
            }
        } catch (BadParcelableException e) {
            Log.w(TAG, ""Cannot read referrer from intent;"" + "" intent extras contain unknown custom Parcelable objects"");
        }
    }
    if (mReferrer != null) {
        return new Uri.Builder().scheme(""android-app"").authority(mReferrer).build();
    }
    return null;
}",1,"/**
 * Return information about who launched this activity.  If the launching Intent
 * contains an {@link android.content.Intent#EXTRA_REFERRER Intent.EXTRA_REFERRER},
 * that will be returned as-is; otherwise, if known, an
 * {@link Intent#URI_ANDROID_APP_SCHEME android-app:} referrer URI containing the
 * package name that started the Intent will be returned.  This may return null if no
 * referrer can be identified -- it is neither explicitly specified, nor is it known which
 * application package was involved.
 *
 * <p>If called while inside the handling of {@link #onNewIntent}, this function will
 * return the referrer that submitted that new intent to the activity.  Otherwise, it
 * always returns the referrer of the original Intent.</p>
 *
 * <p>Note that this is <em>not</em> a security feature -- you can not trust the
 * referrer information, applications can spoof it.</p>
 */
","/**
 * Return information about who launched this activity.  If the launching Intent
 * contains an {@link android.content.Intent#EXTRA_REFERRER Intent.EXTRA_REFERRER},
 * that will be returned as-is; otherwise, if known, an
 * {@link Intent#URI_ANDROID_APP_SCHEME android-app:} referrer URI containing the
 * package name that started the Intent will be returned.  This may return null if no
 * referrer can be identified -- it is neither explicitly specified, nor is it known which
 * application package was involved.
 *
 * <p>If called while inside the handling of {@link #onNewIntent}, this function will
 * return the referrer that submitted that new intent to the activity.  Otherwise, it
 * always returns the referrer of the original Intent.</p>
 *
 * <p>Note that this is <em>not</em> a security feature -- you can not trust the
 * referrer information, applications can spoof it.</p>
 */
",0,[@Nullable],[@Nullable],0,,,,,,,3,0,"The change involves adding a null check for the 'intent' variable before attempting to use it. Therefore, the code change type is 3 (Control dependency changed).","This additional null check for 'intent' variable does not result in any new behaviors in terms of return values or exceptions thrown because if 'intent' was null in the early version, it would have caused a NullPointerException, resulting in the method returning null (which is the same behavior as when the if condition is not met in the late version). Thus, there's no Compatibility Issue; the CI type is 0."
259,<android.os.Parcel: void writeSerializable(Serializable)>,32,33,,,,"{
    if (s == null) {
        writeString(null);
        return;
    }
    String name = s.getClass().getName();
    writeString(name);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try {
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(s);
        oos.close();
        writeByteArray(baos.toByteArray());
    } catch (IOException ioe) {
        throw new RuntimeException(""Parcelable encountered "" + ""IOException writing serializable object (name = "" + name + "")"", ioe);
    }
}","{
    if (s == null) {
        writeString(null);
        return;
    }
    String name = s.getClass().getName();
    writeString(name);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try {
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(s);
        oos.close();
        writeByteArray(baos.toByteArray());
    } catch (IOException ioe) {
        throw new BadParcelableException(""Parcelable encountered "" + ""IOException writing serializable object (name = "" + name + "")"", ioe);
    }
}",1,"/**
 * Write a generic serializable object in to a Parcel.  It is strongly
 * recommended that this method be avoided, since the serialization
 * overhead is extremely large, and this approach will be much slower than
 * using the other approaches to writing data in to a Parcel.
 */
","/**
 * Write a generic serializable object in to a Parcel.  It is strongly
 * recommended that this method be avoided, since the serialization
 * overhead is extremely large, and this approach will be much slower than
 * using the other approaches to writing data in to a Parcel.
 */
",0,,,0,,,,,,,2,2,"The exception that is thrown has changed from RuntimeException to BadParcelableException, so the code change type is 2.","The thrown exception type has changed, which leads to a Compatibility Issue caused by potentially different exception handlings. So, the CI type is 2."
260,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The position of one of the null arguments within the method call to `ActivityManager.getService().broadcastIntentWithFeature()` has shifted, with `excludedPermissions` now explicitly set to null and `AppOpsManager.OP_NONE` passed in the next parameter.","The reordering of `null` and the explicit parameter `AppOpsManager.OP_NONE` does not affect the behavior of the method, as passing explicit `null` for a parameter where `null` was implicitly passed before will not change the method's behavior. Therefore, there is no potential Compatibility Issue."
262,"<android.hardware.camera2.impl.CameraExtensionSessionImpl.InitialRequestHandler: void onCaptureSequenceCompleted(CameraCaptureSession,int,long)>",32,33,,,,"{
    boolean status = true;
    synchronized (mInterfaceLock) {
        /**
         * Initialize and set the initial repeating request which will execute in the
         * absence of client repeating requests.
         */
        try {
            setRepeatingRequest(mPreviewExtender.getCaptureStage(), new RepeatingRequestHandler(null, null, null, mImageCallback));
        } catch (CameraAccessException | RemoteException e) {
            Log.e(TAG, ""Failed to start the internal repeating request!"");
            status = false;
        }
    }
    if (!status) {
        notifyConfigurationFailure();
    }
}","{
    boolean status = true;
    synchronized (mInterfaceLock) {
        /**
         * Initialize and set the initial repeating request which will execute in the
         * absence of client repeating requests.
         */
        try {
            setRepeatingRequest(mPreviewExtender.getCaptureStage(), new PreviewRequestHandler(null, null, null, mImageCallback));
        } catch (CameraAccessException | RemoteException e) {
            Log.e(TAG, ""Failed to start the internal repeating request!"");
            status = false;
        }
    }
    if (!status) {
        notifyConfigurationFailure();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change in the code is the instance creation of a different class as a parameter to the method setRepeatingRequest â€“ from new RepeatingRequestHandler(null, null, null, mImageCallback) to new PreviewRequestHandler(null, null, null, mImageCallback). This is a change in the instantiation of an object, so the code change type is 4.","There is no compatibility issue introduced by this change assuming that PreviewRequestHandler is functionally equivalent to RepeatingRequestHandler in the context of setRepeatingRequest calls. The flow of the program and the behavior of the method remain the same, as well as exception handling and return values. Therefore, the CI type is 0."
263,<android.service.autofill.UserData: String getFieldClassificationAlgorithmForCategory(String)>,32,33,,,,"{
    Preconditions.checkNotNull(categoryId);
    if (mCategoryAlgorithms == null || !mCategoryAlgorithms.containsKey(categoryId)) {
        return null;
    }
    return mCategoryAlgorithms.get(categoryId);
}","{
    Objects.requireNonNull(categoryId);
    if (mCategoryAlgorithms == null || !mCategoryAlgorithms.containsKey(categoryId)) {
        return null;
    }
    return mCategoryAlgorithms.get(categoryId);
}",1,"/**
 * Gets the name of the algorithm corresponding to the specific autofill category
 * that is used to calculate {@link Match#getScore() match scores}
 *
 * @param categoryId autofill field category
 *
 * @return String name of algorithm, null if none found.
 */
","/**
 * Gets the name of the algorithm corresponding to the specific autofill category
 * that is used to calculate {@link Match#getScore() match scores}
 *
 * @param categoryId autofill field category
 *
 * @return String name of algorithm, null if none found.
 */
",0,"[@Nullable, @Override]","[@Nullable, @Override]",0,,,,,,,4,0,"The only change between versions is replacing `Preconditions.checkNotNull(categoryId)` with `Objects.requireNonNull(categoryId)`. Both methods serve the same purpose of null-checking the input parameter. There is no change to control flow, return values, or exception throwing behavior. The code change is type 4, which is Other statement changed.",There is no Compatibility Issue because the method `Preconditions.checkNotNull()` and `Objects.requireNonNull()` are effectively interchangeable for the purposes of null-checking without altering the behavior of the method.
265,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,32,33,,,,"{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    CameraCharacteristics.Key<StreamConfigurationMap> ck = CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP;
    Integer sensorPixelMode = request.get(CaptureRequest.SENSOR_PIXEL_MODE);
    if (sensorPixelMode != null && sensorPixelMode == CameraMetadata.SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION) {
        ck = CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION;
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(ck);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Request list size: to limit the preview to 30fps, need use maxFps/30; to maximize
    // the preview frame rate, should use maxBatch size for that high speed stream
    // configuration. We choose the former for now.
    int requestListSize = fpsRange.getUpper() / 30;
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
    null);
    // Carry over userTag, as native metadata doesn't have this field.
    singleTargetRequestBuilder.setTag(request.getTag());
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
        null);
        doubleTargetRequestBuilder.setTag(request.getTag());
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}","{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    CameraCharacteristics.Key<StreamConfigurationMap> ck = CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP;
    Integer sensorPixelMode = request.get(CaptureRequest.SENSOR_PIXEL_MODE);
    if (sensorPixelMode != null && sensorPixelMode == CameraMetadata.SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION) {
        ck = CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION;
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(ck);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Check the high speed video fps ranges for video size and find the min value from the list
    // and assign it to previewFps which will be used to calculate the requestList size.
    Range<Integer>[] highSpeedFpsRanges = config.getHighSpeedVideoFpsRangesFor(SurfaceUtils.getSurfaceSize(outputSurfaces.iterator().next()));
    Log.v(TAG, ""High speed fps ranges: "" + Arrays.toString(highSpeedFpsRanges));
    int previewFps = Integer.MAX_VALUE;
    for (Range<Integer> range : highSpeedFpsRanges) {
        int rangeMin = range.getLower();
        if (previewFps > rangeMin) {
            previewFps = rangeMin;
        }
    }
    // then continue to calculate the requestList size using value 30.
    if (previewFps != 60 && previewFps != 30) {
        Log.w(TAG, ""previewFps is neither 60 nor 30."");
        previewFps = 30;
    }
    Log.v(TAG, ""previewFps: "" + previewFps);
    int requestListSize = fpsRange.getUpper() / previewFps;
    // If it's a preview, keep requestList size fixed = 1.
    if (fpsRange.getUpper() > fpsRange.getLower()) {
        requestListSize = 1;
    }
    Log.v(TAG, ""Request list size is: "" + requestListSize);
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
    null);
    // Carry over userTag, as native metadata doesn't have this field.
    singleTargetRequestBuilder.setTag(request.getTag());
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
        null);
        doubleTargetRequestBuilder.setTag(request.getTag());
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
266,<android.service.controls.Control.StatefulBuilder: Control build()>,32,33,,,,"{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, mStatus, mControlTemplate, mStatusText);
}","{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, mStatus, mControlTemplate, mStatusText, mAuthRequired);
}",1,"/**
 * @return a valid {@link Control}
 */
","/**
 * @return a valid {@link Control}
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,"The constructor for the 'Control' object in the return statement is modified to include an additional parameter 'mAuthRequired', which indicates a change in the dependent object's constructor signature, but it is not a change in a method call of an existing API, so the change type is Other statement changed (4).","While there is a change in the signature of the constructor for the 'Control' class, this does not necessarily indicate a compatibility issue because it is an internal change to the building of the 'Control' object. Assuming that the 'Control' object can handle the new parameter correctly and does not affect existing behavior when the 'mAuthRequired' is used within its intended use-case, there would be no compatibility issue causing different return values or exceptions, so the CI type is No Compatibility Issue (0). It's also important to consider that callers of 'build()' are not affected by this change as they do not provide the additional argument â€“ it is internal to the implementation of how 'Control.StatefulBuilder' constructs a 'Control' object."
267,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: int getFormat()>,32,33,,,,"{
    return mFormat;
}","{
    // P010 YUV streams must be supported along with SDR 8-bit YUV streams
    if ((mIs10BitCapable) && (mFormat == ImageFormat.YCBCR_P010)) {
        return ImageFormat.YUV_420_888;
    }
    return mFormat;
}",1,"/**
 * Retrieve the mandatory stream {@code format}.
 *
 * @return integer format.
 */
","/**
 * Retrieve the mandatory stream {@code format}.
 *
 * @return integer format.
 */
",0,[@Format],[@Format],0,,,,,,,"1,3",1,"The code has a new control dependency (if statement) added which checks the value of 'mIs10BitCapable', and if true, potentially changes the returned format for YCBCR_P010. The return statement can be different due to this newly introduced condition, therefore change types 1 and 3 are involved.","The newly introduced 'if' condition could result in this method returning a different value (ImageFormat.YUV_420_888 instead of ImageFormat.YCBCR_P010 when 'mIs10BitCapable' is true and 'mFormat' is ImageFormat.YCBCR_P010), hence the CI type is 1."
268,<android.service.dreams.DreamService: boolean dispatchTrackballEvent(MotionEvent)>,32,33,,,,"{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, ""Waking up on trackballEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}","{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(mTag, ""Waking up on trackballEvent"");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The only change in the code is the replacement of the field `TAG` with `mTag` in the logging statement. This is a change in an other statement (not related to return, exception handling, or control structures), which does not affect the return value or exception throwing behavior of the method, so the change type is 4.","Since the modification does not change the program flow or any kind of operational logic, and merely alters a log tag, it does not introduce a compatibility issue. It neither alters what the method returns nor does it affect exception handling; thus, there is no compatibility issue, CI type is 0."
269,<android.content.res.TypedArray: Typeface getFont(int)>,32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme="" + mTheme);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}",1,"/**
 * Retrieve the Typeface for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a font.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Typeface for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a font resource.
 */
","/**
 * Retrieve the Typeface for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a font.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Typeface for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a font resource.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,4,0,"The only change is in the exception message text within the UnsupportedOperationException that gets thrown, which does not affect the behavior of the method nor the exceptions it may throw.","Since the change does not affect the method's return value or the exceptions it throws, there is no Compatibility Issue."
270,"<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>",32,33,,,,"{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        mCurrentInputMethodSession.updateCursorAnchorInfo(cursorAnchorInfo);
        mCursorAnchorInfo = cursorAnchorInfo;
        // Clear immediate bit (if any).
        mRequestUpdateCursorAnchorInfoMonitorMode &= ~InputConnection.CURSOR_UPDATE_IMMEDIATE;
    }
}","{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        if (mVirtualDisplayToScreenMatrix != null) {
            mCurrentInputMethodSession.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(cursorAnchorInfo, mVirtualDisplayToScreenMatrix));
        } else {
            mCurrentInputMethodSession.updateCursorAnchorInfo(cursorAnchorInfo);
        }
        mCursorAnchorInfo = cursorAnchorInfo;
        // Clear immediate bit (if any).
        mRequestUpdateCursorAnchorInfoMonitorMode &= ~CURSOR_UPDATE_IMMEDIATE;
    }
}",1,"/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
","/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
",0,,,0,,,,,,,"3,4",1,"The code has changed in the controlled statement inside the 'synchronized' block, which includes an additional condition and the update of 'mCurrentInputMethodSession.updateCursorAnchorInfo' with a different parameter when 'mVirtualDisplayToScreenMatrix' is not null. The change type is 3,4.","Given that there's an added check for 'mVirtualDisplayToScreenMatrix' and the potential execution of a different method 'CursorAnchorInfo.createForAdditionalParentMatrix', the API could return different behavior for the late version. The presence of 'mVirtualDisplayToScreenMatrix' could result in modifying the 'cursorAnchorInfo' passed to 'updateCursorAnchorInfo', leading to a different result from the method calls and, therefore, a different outcome of the API call. This constitutes a CI type 1 as it may lead to different return values or types."
271,<android.os.BaseBundle: Serializable getSerializable(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Serializable"", e);
        return null;
    }
}","{
    unparcel();
    Object o = getValue(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Serializable"", e);
        return null;
    }
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 *
 * @deprecated Use {@link #getSerializable(String, Class)}. This method should only be used in
 * other deprecated APIs.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,5,0,"The method implementation has changed the way it retrieves the object associated with the specified key: it switched from directly accessing mMap to using the getValue(String) method, so the code change type is 5.","The behavior provided by the changed method (getValue) is assumed to be consistent with the original direct access (mMap.get). Hence, there is no indication that the return value or the type has changed, which means no compatibility issue is detected; CI type is 0."
272,"<android.os.UidBatteryConsumer.Builder: Builder setTimeInStateMs(int,long)>",32,33,,,,"{
    switch(state) {
        case STATE_FOREGROUND:
            mTimeInForegroundMs = timeInStateMs;
            break;
        case STATE_BACKGROUND:
            mTimeInBackgroundMs = timeInStateMs;
            break;
        default:
            throw new IllegalArgumentException(""Unsupported state: "" + state);
    }
    return this;
}","{
    switch(state) {
        case STATE_FOREGROUND:
            mData.putLong(COLUMN_INDEX_TIME_IN_FOREGROUND, timeInStateMs);
            break;
        case STATE_BACKGROUND:
            mData.putLong(COLUMN_INDEX_TIME_IN_BACKGROUND, timeInStateMs);
            break;
        default:
            throw new IllegalArgumentException(""Unsupported state: "" + state);
    }
    return this;
}",1,"/**
 * Sets the duration, in milliseconds, that this UID was active in a particular state,
 * such as foreground or background.
 */
","/**
 * Sets the duration, in milliseconds, that this UID was active in a particular state,
 * such as foreground or background.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The switch-case statements changed the way they save the 'timeInStateMs' by using a putLong method on a data structure instead of assigning it to member variables. Additionally, the constants used within the putLong method call imply that the structure or the method of storing this information has changed. Therefore, the change types are 4 (Other statement changed), and 5 (Dependent API changed).","Though the implementation for how the state times are stored internally has been modified, the external behavior of the API from the client's perspective, which is the setting of internal states, should remain the same. Both the early and late version preserves the same thrown exception and also they return 'this', which is the Builder instance itself; thus, no Compatibility Issue is expected to arise from these changes."
273,<android.os.UserManager: boolean isDemoUser()>,32,33,,,,"{
    try {
        return mService.isDemoUser(UserHandle.myUserId());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.isDemoUser(getContextUserIfAppropriate());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Checks if the calling app is running in a demo user. When running in a demo user,
 * apps can be more helpful to the user, or explain their features in more detail.
 *
 * @return whether the caller is a demo user.
 */
","/**
 * Checks if the context user is a demo user. When running in a demo user,
 * apps can be more helpful to the user, or explain their features in more detail.
 *
 * @return whether the context user is a demo user.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresPermissionIfNotCaller = android.Manifest.permission.MANAGE_USERS)]",1,,,,,,,5,0,"The dependent API used as the parameter within mService.isDemoUser() has been changed from UserHandle.myUserId() to getContextUserIfAppropriate(), indicating a change in the dependent API used, so the code change type is 5.","As long as the new getContextUserIfAppropriate() method is designed to provide a user ID compatible with the original UserHandle.myUserId() in similar contexts, and since the surrounding code and the exception handling have not changed, there would be no Compatibility Issue arising from this change. Hence, the CI type is 0."
274,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setCenter(float,float,boolean)>",32,33,,,,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, Float.NaN, centerX, centerY, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set center"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            final MagnificationConfig config = new MagnificationConfig.Builder().setMode(MAGNIFICATION_MODE_FULLSCREEN).setCenterX(centerX).setCenterY(centerY).build();
            return connection.setMagnificationConfig(mDisplayId, config, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set center"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Sets the center of the magnified viewport.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param centerX the unscaled screen-relative X coordinate on which to
 * center the viewport
 * @param centerY the unscaled screen-relative Y coordinate on which to
 * center the viewport
 * @param animate {@code true} to animate from the current viewport
 * center or {@code false} to set the center immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Sets the center of the magnified viewport.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 * </p>
 * <p>
 * <strong>Note:</strong> This legacy API sets the center of full-screen
 * magnification. To set the center of the specified magnifier,
 * use {@link #setMagnificationConfig} instead.
 * </p>
 *
 * @param centerX the unscaled screen-relative X coordinate on which to
 * center the viewport
 * @param centerY the unscaled screen-relative Y coordinate on which to
 * center the viewport
 * @param animate {@code true} to animate from the current viewport
 * center or {@code false} to set the center immediately
 * @return {@code true} on success, {@code false} on failure
 * @deprecated Use {@link #setMagnificationConfig(MagnificationConfig, boolean)} instead
 */
",1,,[@Deprecated],1,,,,,,,"1,4,5",1,"The method setMagnificationScaleAndCenter has been changed to setMagnificationConfig with different parameters passed to it which indicates a creation of a new object for MagnificationConfig, and there's a building of a MagnificationConfig object with a different method (Builder pattern is used in the late version), so the code change types are 1, 4, and 5.","The API introduces a new way to build the MagnificationConfig that affects the result returned by the method. The return value depends on the successful execution of the new method, which may behave differently from the old one. This change will lead to a Compatibility Issue since it can return different values, hence the CI type is 1."
276,<android.view.inputmethod.CursorAnchorInfo: boolean equals(Object)>,32,33,,,,"{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof CursorAnchorInfo)) {
        return false;
    }
    final CursorAnchorInfo that = (CursorAnchorInfo) obj;
    if (hashCode() != that.hashCode()) {
        return false;
    }
    if (mSelectionStart != that.mSelectionStart || mSelectionEnd != that.mSelectionEnd) {
        return false;
    }
    if (mInsertionMarkerFlags != that.mInsertionMarkerFlags || !areSameFloatImpl(mInsertionMarkerHorizontal, that.mInsertionMarkerHorizontal) || !areSameFloatImpl(mInsertionMarkerTop, that.mInsertionMarkerTop) || !areSameFloatImpl(mInsertionMarkerBaseline, that.mInsertionMarkerBaseline) || !areSameFloatImpl(mInsertionMarkerBottom, that.mInsertionMarkerBottom)) {
        return false;
    }
    if (!Objects.equals(mCharacterBoundsArray, that.mCharacterBoundsArray)) {
        return false;
    }
    if (mComposingTextStart != that.mComposingTextStart || !Objects.equals(mComposingText, that.mComposingText)) {
        return false;
    }
    // NaN, 0.0f, and -0.0f.
    if (mMatrixValues.length != that.mMatrixValues.length) {
        return false;
    }
    for (int i = 0; i < mMatrixValues.length; ++i) {
        if (mMatrixValues[i] != that.mMatrixValues[i]) {
            return false;
        }
    }
    return true;
}","{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof CursorAnchorInfo)) {
        return false;
    }
    final CursorAnchorInfo that = (CursorAnchorInfo) obj;
    if (hashCode() != that.hashCode()) {
        return false;
    }
    if (mSelectionStart != that.mSelectionStart || mSelectionEnd != that.mSelectionEnd) {
        return false;
    }
    if (mInsertionMarkerFlags != that.mInsertionMarkerFlags || !areSameFloatImpl(mInsertionMarkerHorizontal, that.mInsertionMarkerHorizontal) || !areSameFloatImpl(mInsertionMarkerTop, that.mInsertionMarkerTop) || !areSameFloatImpl(mInsertionMarkerBaseline, that.mInsertionMarkerBaseline) || !areSameFloatImpl(mInsertionMarkerBottom, that.mInsertionMarkerBottom)) {
        return false;
    }
    if (!Objects.equals(mCharacterBoundsArray, that.mCharacterBoundsArray)) {
        return false;
    }
    if (!Objects.equals(mEditorBoundsInfo, that.mEditorBoundsInfo)) {
        return false;
    }
    if (mComposingTextStart != that.mComposingTextStart || !Objects.equals(mComposingText, that.mComposingText)) {
        return false;
    }
    // NaN, 0.0f, and -0.0f.
    if (mMatrixValues.length != that.mMatrixValues.length) {
        return false;
    }
    for (int i = 0; i < mMatrixValues.length; ++i) {
        if (mMatrixValues[i] != that.mMatrixValues[i]) {
            return false;
        }
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The code change involves adding a new equality check for `mEditorBoundsInfo` in the late version implementation, making it an ""Other statement changed"" type of change (4).","The change does not affect the method's return type or exception handling; it only adds a check for additional equality on a new field. It won't cause compatibility issues since for any given input object, the method is still expected to return true if the objects are equal, and false otherwise. Adding a new check for equality is internal to the logical flow of the method and maintains its general contract of the equals method â€“ to return true for equal objects and false for unequal objects. Thus, there is No Compatibility Issue (0)."
280,<android.content.pm.ShortcutManager: List<ShortcutInfo> getShortcuts(int)>,32,33,,,,"{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), matchFlags, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getShortcuts(mContext.getPackageName(), matchFlags, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ShortcutInfo}s that match {@code matchFlags}.
 *
 * @param matchFlags result includes shortcuts matching this flags. Any combination of:
 * <ul>
 * <li>{@link #FLAG_MATCH_MANIFEST}
 * <li>{@link #FLAG_MATCH_DYNAMIC}
 * <li>{@link #FLAG_MATCH_PINNED}
 * <li>{@link #FLAG_MATCH_CACHED}
 * </ul>
 *
 * @return list of {@link ShortcutInfo}s that match the flag.
 *
 * <p>At least one of the {@code MATCH} flags should be set. Otherwise no shortcuts will be
 * returned.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Returns {@link ShortcutInfo}s that match {@code matchFlags}.
 *
 * @param matchFlags result includes shortcuts matching this flags. Any combination of:
 * <ul>
 * <li>{@link #FLAG_MATCH_MANIFEST}
 * <li>{@link #FLAG_MATCH_DYNAMIC}
 * <li>{@link #FLAG_MATCH_PINNED}
 * <li>{@link #FLAG_MATCH_CACHED}
 * </ul>
 *
 * @return list of {@link ShortcutInfo}s that match the flag.
 *
 * <p>At least one of the {@code MATCH} flags should be set. Otherwise no shortcuts will be
 * returned.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",0,,,,,,,"4,5",0,"The implementation change is regarding the removal of ""getFutureOrThrow()"" wrapper around the ""mService.getShortcuts()"" call. This change is an example of the dependent API changed category (5). While the method's behavior seems to involve different API calls, it effectively simplifies the future handling of the result without altering the actual logic for retrieving shortcuts, qualifying it also for ""Other statement changed"" (4).","No Compatibility Issue is detected since the removal of ""getFutureOrThrow()"" does not affect the behavior observed by the calling code. The method still performs the same operation and throws the same exception, ""RemoteException"", which is handled in the same way. Therefore, the method's contract - its return type and exception handling - remains unchanged. This is why there's no Compatibility Issue (0)."
282,<android.os.Build: List<Partition> getFingerprintedPartitions()>,32,33,,,,"{
    ArrayList<Partition> partitions = new ArrayList();
    String[] names = new String[] { ""bootimage"", ""odm"", ""product"", ""system_ext"", Partition.PARTITION_NAME_SYSTEM, ""vendor"" };
    for (String name : names) {
        String fingerprint = SystemProperties.get(""ro."" + name + "".build.fingerprint"");
        if (TextUtils.isEmpty(fingerprint)) {
            continue;
        }
        long time = getLong(""ro."" + name + "".build.date.utc"") * 1000;
        partitions.add(new Partition(name, fingerprint, time));
    }
    return partitions;
}","{
    ArrayList<Partition> partitions = new ArrayList();
    String[] names = new String[] { Partition.PARTITION_NAME_BOOTIMAGE, Partition.PARTITION_NAME_ODM, Partition.PARTITION_NAME_PRODUCT, Partition.PARTITION_NAME_SYSTEM_EXT, Partition.PARTITION_NAME_SYSTEM, Partition.PARTITION_NAME_VENDOR };
    for (String name : names) {
        String fingerprint = SystemProperties.get(""ro."" + name + "".build.fingerprint"");
        if (TextUtils.isEmpty(fingerprint)) {
            continue;
        }
        long time = getLong(""ro."" + name + "".build.date.utc"") * 1000;
        partitions.add(new Partition(name, fingerprint, time));
    }
    return partitions;
}",1,"/**
 * Get build information about partitions that have a separate fingerprint defined.
 *
 * The list includes partitions that are suitable candidates for over-the-air updates. This is
 * not an exhaustive list of partitions on the device.
 */
","/**
 * Get build information about partitions that have a separate fingerprint defined.
 *
 * The list includes partitions that are suitable candidates for over-the-air updates. This is
 * not an exhaustive list of partitions on the device.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,"The array of strings representing the partition names has been replaced by constants from the 'Partition' class. The method 'getFingerprintedPartitions' relies on these constants, which represent dependent APIs changes, so the change type is 5.","Despite the change in how partition names are represented in the array, there's no indication that the underlying values of these constants have changed. The same operations are performed, and the behavior of the method should remain consistent. As a result, there's no Compatibility Issue associated with this change."
283,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",32,33,,,,"{
    dest.writeInt(mUserId);
    dest.writeString8(mId);
    dest.writeString8(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString8(mBitmapPath);
    dest.writeString8(mIconResName);
    dest.writeString8(mTitleResName);
    dest.writeString8(mTextResName);
    dest.writeString8(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString8(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelableArray(mPersons, flags);
    dest.writeParcelable(mLocusId, flags);
    dest.writeString8(mIconUri);
    dest.writeString8(mStartingThemeResName);
}","{
    dest.writeInt(mUserId);
    dest.writeString8(mId);
    dest.writeString8(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString8(mBitmapPath);
    dest.writeString8(mIconResName);
    dest.writeString8(mTitleResName);
    dest.writeString8(mTextResName);
    dest.writeString8(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString8(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelableArray(mPersons, flags);
    dest.writeParcelable(mLocusId, flags);
    dest.writeString8(mIconUri);
    dest.writeString8(mStartingThemeResName);
    dest.writeInt(mExcludedSurfaces);
    dest.writeMap(mCapabilityBindings);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"New fields mExcludedSurfaces and mCapabilityBindings are written to the Parcel at the end of the method, so the code change type is 4.","There's no Compatibility Issue because the new fields added to the writeToParcel method don't affect how existing data is written to the Parcel nor do they alter the behavior of the API for existing client code. The method's existing behavior and contract remains the same regardless of additional data being written, hence there's no Compatibility Issue for the existing code. However, old versions of the code that read from the Parcel may not recognize the new data, but this is an issue of forward-compatibility, not backward-compatibility."
284,<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void cancelSync(ISyncContext)>,32,33,,,,"{
    try {
        // synchronize to make sure that mSyncThreads doesn't change between when we
        // check it and when we use it
        SyncThread info = null;
        synchronized (mSyncThreadLock) {
            for (SyncThread current : mSyncThreads.values()) {
                if (current.mSyncContext.getSyncContextBinder() == syncContext.asBinder()) {
                    info = current;
                    break;
                }
            }
        }
        if (info != null) {
            if (ENABLE_LOG) {
                Log.d(TAG, ""cancelSync() "" + info.mAuthority + "" "" + info.mAccount);
            }
            if (mAllowParallelSyncs) {
                onSyncCanceled(info);
            } else {
                onSyncCanceled();
            }
        } else {
            if (ENABLE_LOG) {
                Log.w(TAG, ""cancelSync() unknown context"");
            }
        }
    } catch (RuntimeException | Error th) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""cancelSync() caught exception"", th);
        }
        throw th;
    } finally {
        if (ENABLE_LOG) {
            Log.d(TAG, ""cancelSync() finishing"");
        }
    }
}","{
    if (!isCallerSystem()) {
        return;
    }
    try {
        // synchronize to make sure that mSyncThreads doesn't change between when we
        // check it and when we use it
        SyncThread info = null;
        synchronized (mSyncThreadLock) {
            for (SyncThread current : mSyncThreads.values()) {
                if (current.mSyncContext.getSyncContextBinder() == syncContext.asBinder()) {
                    info = current;
                    break;
                }
            }
        }
        if (info != null) {
            if (ENABLE_LOG) {
                Log.d(TAG, ""cancelSync() "" + info.mAuthority + "" "" + info.mAccount);
            }
            if (mAllowParallelSyncs) {
                onSyncCanceled(info);
            } else {
                onSyncCanceled();
            }
        } else {
            if (ENABLE_LOG) {
                Log.w(TAG, ""cancelSync() unknown context"");
            }
        }
    } catch (RuntimeException | Error th) {
        if (ENABLE_LOG) {
            Log.d(TAG, ""cancelSync() caught exception"", th);
        }
        throw th;
    } finally {
        if (ENABLE_LOG) {
            Log.d(TAG, ""cancelSync() finishing"");
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"A new control dependency is introduced by an 'if' check, and a 'return' statement within the introduced 'if' check is added. So the code change type is 3,4.","Despite the change where a condition and a return statement introduced at the beginning of the method, these changes do not lead to a CI because the new check only returns early for a non-system caller which should not affect compatibility for existing valid system callers."
285,"<android.service.voice.AbstractHotwordDetector: void updateState(PersistableBundle,SharedMemory)>",32,33,,,,"{
    if (DEBUG) {
        Slog.d(TAG, ""updateState()"");
    }
    synchronized (mLock) {
        updateStateLocked(options, sharedMemory, null);
    }
}","{
    if (DEBUG) {
        Slog.d(TAG, ""updateState()"");
    }
    throwIfDetectorIsNoLongerActive();
    synchronized (mLock) {
        updateStateLocked(options, sharedMemory, null, /* callback */
        mDetectorType);
    }
}",1,"/**
 * Set configuration and pass read-only data to hotword detection service.
 *
 * @param options Application configuration data to provide to the
 * {@link HotwordDetectionService}. PersistableBundle does not allow any remotable objects or
 * other contents that can be used to communicate with other processes.
 * @param sharedMemory The unrestricted data blob to provide to the
 * {@link HotwordDetectionService}. Use this to provide the hotword models data or other
 * such data to the trusted process.
 *
 * @throws IllegalStateException if this AlwaysOnHotwordDetector wasn't specified to use a
 * {@link HotwordDetectionService} when it was created. In addition, if this
 * AlwaysOnHotwordDetector is in an invalid or error state.
 */
","/**
 * Set configuration and pass read-only data to hotword detection service.
 *
 * @param options Application configuration data to provide to the
 * {@link HotwordDetectionService}. PersistableBundle does not allow any remotable objects or
 * other contents that can be used to communicate with other processes.
 * @param sharedMemory The unrestricted data blob to provide to the
 * {@link HotwordDetectionService}. Use this to provide the hotword models data or other
 * such data to the trusted process.
 *
 * @throws IllegalStateException if this AlwaysOnHotwordDetector wasn't specified to use a
 * {@link HotwordDetectionService} when it was created. In addition, if this
 * AlwaysOnHotwordDetector is in an invalid or error state.
 */
",0,[@Override],[@Override],0,,,,,,,"4,5",2,"A new method call throwIfDetectorIsNoLongerActive() has been added and the call to updateStateLocked() has a new parameter passed to it; therefore, the code change type is 4,5.","The introduction of the new method call throwIfDetectorIsNoLongerActive(), which could potentially throw an exception, could lead to different exception handling, so the CI type is 2."
286,<android.text.PrecomputedText.Params: String toString()>,32,33,,,,"{
    return ""{"" + ""textSize="" + mPaint.getTextSize() + "", textScaleX="" + mPaint.getTextScaleX() + "", textSkewX="" + mPaint.getTextSkewX() + "", letterSpacing="" + mPaint.getLetterSpacing() + "", textLocale="" + mPaint.getTextLocales() + "", typeface="" + mPaint.getTypeface() + "", variationSettings="" + mPaint.getFontVariationSettings() + "", elegantTextHeight="" + mPaint.isElegantTextHeight() + "", textDir="" + mTextDir + "", breakStrategy="" + mBreakStrategy + "", hyphenationFrequency="" + mHyphenationFrequency + ""}"";
}","{
    int lineBreakStyle = (mLineBreakConfig != null) ? mLineBreakConfig.getLineBreakStyle() : LineBreakConfig.LINE_BREAK_STYLE_NONE;
    int lineBreakWordStyle = (mLineBreakConfig != null) ? mLineBreakConfig.getLineBreakWordStyle() : LineBreakConfig.LINE_BREAK_WORD_STYLE_NONE;
    return ""{"" + ""textSize="" + mPaint.getTextSize() + "", textScaleX="" + mPaint.getTextScaleX() + "", textSkewX="" + mPaint.getTextSkewX() + "", letterSpacing="" + mPaint.getLetterSpacing() + "", textLocale="" + mPaint.getTextLocales() + "", typeface="" + mPaint.getTypeface() + "", variationSettings="" + mPaint.getFontVariationSettings() + "", elegantTextHeight="" + mPaint.isElegantTextHeight() + "", textDir="" + mTextDir + "", breakStrategy="" + mBreakStrategy + "", hyphenationFrequency="" + mHyphenationFrequency + "", lineBreakStyle="" + lineBreakStyle + "", lineBreakWordStyle="" + lineBreakWordStyle + ""}"";
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The late implementation has added local variables and extended the returned string to include the 'lineBreakStyle' and 'lineBreakWordStyle', both of which are mentioned in the string concatenation process; thus, both the return statement and other statements have changed, making the change types 1 and 4.","The API returns a string that has additional information in the late version, which alters the method's behavior as the returned string is different. Therefore, the executable code potentially returns a different variable, leading to a Compatibility Issue of type 1."
288,<android.view.translation.TranslationContext: String toString()>,32,33,,,,"{
    return ""TranslationContext { "" + ""sourceSpec = "" + mSourceSpec + "", "" + ""targetSpec = "" + mTargetSpec + "", "" + ""translationFlags = "" + translationFlagToString(mTranslationFlags) + "" }"";
}","{
    return ""TranslationContext { "" + ""sourceSpec = "" + mSourceSpec + "", "" + ""targetSpec = "" + mTargetSpec + "", "" + ""translationFlags = "" + translationFlagToString(mTranslationFlags) + "", "" + ""activityId = "" + mActivityId + "" }"";
}",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,,,,"1,4",1,"The return statement has changed with the inclusion of "", "" + ""activityId = "" + mActivityId in the string concatenation. Additionally, another member variable `mActivityId` is involved in generating the return string. This is both a change in the return statement and another statement change, so the code change types are 1,4.","The change in the return statement will cause the late version of API to return a different value by including the ""activityId"" information. This means the API potentially returns different value, and thus the CI type is 1."
289,<android.view.inputmethod.CursorAnchorInfo.Builder: CursorAnchorInfo build()>,32,33,,,,"{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException(""Coordinate transformation matrix is "" + ""required when positional parameters are specified."");
        }
    }
    return new CursorAnchorInfo(this);
}","{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException(""Coordinate transformation matrix is "" + ""required when positional parameters are specified."");
        }
    }
    return CursorAnchorInfo.create(this);
}",1,"/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */
","/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */
",0,,,0,,,,,,,"4,5",1,"The change consists of using CursorAnchorInfo.create(this) instead of new CursorAnchorInfo(this) to build the CursorAnchorInfo object, which involves a change in a dependent API, so the code change type is 4,5.","The change would lead to a potential Compatibility Issue of returning different values since the construction of the CursorAnchorInfo object has been altered and may result in different behavior, hence the CI type is 1."
290,<android.companion.AssociationRequest: boolean equals(Object)>,32,33,,,,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") AssociationRequest that = (AssociationRequest) o;
    // noinspection PointlessBooleanExpression
    return true && mSingleDevice == that.mSingleDevice && Objects.equals(mDeviceFilters, that.mDeviceFilters) && Objects.equals(mDeviceProfile, that.mDeviceProfile) && Objects.equals(mCallingPackage, that.mCallingPackage) && Objects.equals(mDeviceProfilePrivilegesDescription, that.mDeviceProfilePrivilegesDescription) && mCreationTime == that.mCreationTime && mSkipPrompt == that.mSkipPrompt;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") AssociationRequest that = (AssociationRequest) o;
    // noinspection PointlessBooleanExpression
    return true && mSingleDevice == that.mSingleDevice && Objects.equals(mDeviceFilters, that.mDeviceFilters) && Objects.equals(mDeviceProfile, that.mDeviceProfile) && Objects.equals(mDisplayName, that.mDisplayName) && mSelfManaged == that.mSelfManaged && mForceConfirmation == that.mForceConfirmation && Objects.equals(mPackageName, that.mPackageName) && mUserId == that.mUserId && Objects.equals(mDeviceProfilePrivilegesDescription, that.mDeviceProfilePrivilegesDescription) && mCreationTime == that.mCreationTime && mSkipPrompt == that.mSkipPrompt;
}",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,,,,4,0,"The boolean expression in return statement has changed, with some fields being compared in the late version that were not present in the early version. However, this change doesn't cause a different return type nor introduction of new exceptions. The fields which are compared are different. As equals method should also satisfy the contract for the early version, this doesn't introduce a CI by having a different behaviour. Therefore, the code change type is 4 (as there are other statement changes).","There is no compatibility issue since the change in the boolean expression merely reflects the comparison of newly introduced fields with their counterparts in the object being compared. The updated fields in the 'equals' method ensure continued adherence to the equality contract. The result of the 'equals' call will still be based on the logical comparison of relevant fields between the two objects, in accordance with the contract for 'equals'. If the new fields added in the updated API do not exist in a passed object of an older class version, the 'getClass() != o.getClass()' check will result in 'false', preventing any equality check that includes the new fields and thereby averting a possible ClassCastException or incompatible logical comparison. Thus, no CI."
291,"<android.os.PowerComponents.Builder: Builder setConsumedPowerForCustomComponent(int,double)>",32,33,,,,"{
    if (componentId >= BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID && componentId < BatteryConsumer.LAST_CUSTOM_POWER_COMPONENT_ID) {
        try {
            mPowerComponentsMah[CUSTOM_POWER_COMPONENT_OFFSET + componentId] = componentPower;
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException(""Unsupported custom power component ID: "" + componentId);
        }
    } else {
        throw new IllegalArgumentException(""Unsupported custom power component ID: "" + componentId);
    }
    return this;
}","{
    final int index = componentId - BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID;
    if (index < 0 || index >= mData.layout.customPowerComponentCount) {
        throw new IllegalArgumentException(""Unsupported custom power component ID: "" + componentId);
    }
    mData.putDouble(mData.layout.firstCustomConsumedPowerColumn + index, componentPower);
    return this;
}",1,"/**
 * Sets the amount of drain attributed to the specified custom drain type.
 *
 * @param componentId    The ID of the custom power component.
 * @param componentPower Amount of consumed power in mAh.
 */
","/**
 * Sets the amount of drain attributed to the specified custom drain type.
 *
 * @param componentId    The ID of the custom power component.
 * @param componentPower Amount of consumed power in mAh.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,3,5",1,"The control dependency has changed, the exception handling statement has changed, and there is a change in the dependent API: mData.putDouble() replaces direct array access. These modifications mean that the code change types are 1, 3, and 5.","Due to the control dependency change and the change in the way the value is set (from a direct array access to using a putDouble method on mData), the API could return a different 'this' reference in the case of an exception, and the inputData to the API could be treated differently because of the changed index calculation and storage method, which leads to CI type 1."
292,"<android.widget.ListPopupWindow: boolean onKeyPreIme(int,KeyEvent)>",32,33,,,,"{
    if (keyCode == KeyEvent.KEYCODE_BACK && isShowing()) {
        // special case for the back key, we do not even try to send it
        // to the drop down list but instead, consume it immediately
        final View anchorView = mDropDownAnchorView;
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.handleUpEvent(event);
            }
            if (event.isTracking() && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
    }
    return false;
}","{
    if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE) && isShowing()) {
        // special case for the back key, we do not even try to send it
        // to the drop down list but instead, consume it immediately
        final View anchorView = mDropDownAnchorView;
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.handleUpEvent(event);
            }
            if (event.isTracking() && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Filter pre-IME key events. By forwarding {@link View#onKeyPreIme(int, KeyEvent)}
 * events to this function, views using ListPopupWindow can have it dismiss the popup
 * when the back key is pressed.
 *
 * @param keyCode keyCode param passed to the host view's onKeyPreIme
 * @param event event param passed to the host view's onKeyPreIme
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */
","/**
 * Filter pre-IME key events. By forwarding {@link View#onKeyPreIme(int, KeyEvent)}
 * events to this function, views using ListPopupWindow can have it dismiss the popup
 * when the back key is pressed.
 *
 * @param keyCode keyCode param passed to the host view's onKeyPreIme
 * @param event event param passed to the host view's onKeyPreIme
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */
",0,,,0,,,,,,,3,0,"The control dependency condition has changed by adding an extra check for KeyEvent.KEYCODE_ESCAPE, so the code change type is 3.","There is no Compatibility Issue since the behavior is expected to stay consistent when the back key is pressed, and the additional handling for the escape key simply extends the functionality without altering the existing behavior. Thus, there won't be any change in return values or exception handlings for existing scenarios that involve the back key."
293,"<android.content.pm.LauncherApps: PendingIntent getShortcutIntent(String,String,Bundle,UserHandle)>",32,33,,,,"{
    logErrorForInvalidProfileAccess(user);
    if (DEBUG) {
        Log.i(TAG, ""GetShortcutIntent "" + packageName + ""/"" + shortcutId + "" "" + user);
    }
    try {
        return mService.getShortcutIntent(mContext.getPackageName(), packageName, shortcutId, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    if (DEBUG) {
        Log.i(TAG, ""GetShortcutIntent "" + packageName + ""/"" + shortcutId + "" "" + user);
    }
    try {
        // due to b/209607104, opts will be ignored
        return mService.getShortcutIntent(mContext.getPackageName(), packageName, shortcutId, null, /* opts */
        user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns PendingIntent associated with specified shortcut.
 *
 * @param packageName The packageName of the shortcut
 * @param shortcutId The id of the shortcut
 * @param opts Options to pass to the PendingIntent
 * @param user The UserHandle of the profile
 */
","/**
 * Returns PendingIntent associated with specified shortcut.
 *
 * @param packageName The packageName of the shortcut
 * @param shortcutId The id of the shortcut
 * @param opts This parameter is no longer supported
 * @param user The UserHandle of the profile
 */
",1,[@Nullable],[@Nullable],0,,,,,,,"1,4",1,"There is a change in the implementation where the value 'opts' is replaced with 'null' in the call to mService.getShortcutIntent method, and a comment has been added, which is categorized as a change in other statements. So, the code change types are 1,4.","The change to use 'null' instead of 'opts' could potentially lead the method to return different PendingIntent, or behave differently by ignoring the provided 'opts'. Therefore, the type of CI is 1 (Compatibility Issue caused by potential different return values)."
294,<android.content.res.Resources: Theme newTheme()>,32,33,,,,"{
    Theme theme = new Theme();
    theme.setImpl(mResourcesImpl.newThemeImpl());
    synchronized (mThemeRefs) {
        mThemeRefs.add(new WeakReference<>(theme));
        // Clean up references to garbage collected themes
        if (mThemeRefs.size() > mThemeRefsNextFlushSize) {
            mThemeRefs.removeIf(ref -> ref.get() == null);
            mThemeRefsNextFlushSize = Math.max(MIN_THEME_REFS_FLUSH_SIZE, 2 * mThemeRefs.size());
        }
    }
    return theme;
}","{
    Theme theme = new Theme();
    theme.setImpl(mResourcesImpl.newThemeImpl());
    synchronized (mThemeRefs) {
        mThemeRefs.add(new WeakReference<>(theme));
        // Clean up references to garbage collected themes
        if (mThemeRefs.size() > mThemeRefsNextFlushSize) {
            mThemeRefs.removeIf(ref -> ref.refersTo(null));
            mThemeRefsNextFlushSize = Math.max(MIN_THEME_REFS_FLUSH_SIZE, 2 * mThemeRefs.size());
        }
    }
    return theme;
}",1,"/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
","/**
 * Generate a new Theme object for this set of Resources.  It initially
 * starts out empty.
 *
 * @return Theme The newly created Theme container.
 */
",0,,,0,,,,,,,4,0,"The code change occurs within a control statement where the lambda expression passed to `removeIf` changes from `ref -> ref.get() == null` to `ref -> ref.refersTo(null)`. This is considered a change in the method called on the reference object to check for nullity, not a control dependency change, return statement change, or exception handling change. Thus, the code change is categorized as 4, an ""Other statement changed"".","The code change doesn't affect the control flow or the possible return values of the method. The modification only changes the method used to clean up garbage collected theme references. This internal change won't result in different behavior from the perspective of the method's caller, as the returned `Theme` object remains unaffected. Therefore, there is no Compatibility Issue."
295,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,32,33,,,,"{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId) || mIsMultiResolution != other.mIsMultiResolution)
            return false;
        if (mSensorPixelModesUsed.size() != other.mSensorPixelModesUsed.size()) {
            return false;
        }
        for (int j = 0; j < mSensorPixelModesUsed.size(); j++) {
            if (mSensorPixelModesUsed.get(j) != other.mSensorPixelModesUsed.get(j)) {
                return false;
            }
        }
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}","{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId) || mIsMultiResolution != other.mIsMultiResolution || mStreamUseCase != other.mStreamUseCase || mTimestampBase != other.mTimestampBase || mMirrorMode != other.mMirrorMode)
            return false;
        if (mSensorPixelModesUsed.size() != other.mSensorPixelModesUsed.size()) {
            return false;
        }
        for (int j = 0; j < mSensorPixelModesUsed.size(); j++) {
            if (mSensorPixelModesUsed.get(j) != other.mSensorPixelModesUsed.get(j)) {
                return false;
            }
        }
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        if (mDynamicRangeProfile != other.mDynamicRangeProfile) {
            return false;
        }
        return true;
    }
    return false;
}",1,"/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",0,[@Override],[@Override],0,,,,,,,"1,4",1,"The conditional check within the 'equals' method has been extended to include new fields: mStreamUseCase, mTimestampBase, mMirrorMode, and mDynamicRangeProfile. This extension is considered as modification in the ""other statement changed"" category because there are new conditions in the if statement which involve member variables that are not directly related to control flow. Furthermore, since these checks could lead to a different outcome of the equals comparison (e.g., the method returning false when it previously would have returned true due to the additional checks), the change type is also 1.","Due to the changes in the additional equality checks for mStreamUseCase, mTimestampBase, mMirrorMode, and mDynamicRangeProfile, the method may return different results (true or false) when comparing two OutputConfiguration objects. Specifically, objects that were considered equal in the early version may not be equal in the late version if these new fields differ. This qualifies for a Compatibility Issue caused by potential different return values (type 1)."
296,<android.service.voice.VoiceInteractionSession: void ensureWindowHidden()>,32,33,,,,"{
    if (mWindow != null) {
        mWindow.hide();
    }
}","{
    if (mWindow != null) {
        mWindow.hide();
        try {
            mSystemService.setSessionWindowVisible(mToken, false);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed to notify session window hidden"", e);
        }
    }
}",1,,,0,,,0,,,,,,,4,0,"An attempt to communicate with a system service using `mSystemService.setSessionWindowVisible(mToken, false)` is introduced in the late implementation wrapped in a try-catch block. The catch block logs a message if a RemoteException occurs. The added code does not change the control flow related to the return value of the method (`void` type), nor does it introduce a new exception that is propagated out of the method, so the change type is 4.","There is no compatibility issue as the method's signature, return type, and exception handling remain unchanged. The additional call and error handling are for internal state management and do not affect how the method is externally perceived. It does not alter the method's expected behavior from the caller's perspective; thus, the CI type is 0."
297,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The method call to `broadcastIntentWithFeature` has a change in the parameter ordering, specifically the `appOp` argument has been repositioned from after `excludedPermissions` to before `excludedPermissions`. However, both `excludedPermissions` and `appOp` are null, hence there's no actual change in behavior. This change is classified as 4 (Other statement changed).",There is no Compatibility Issue here since the repositioning of the null `appOp` parameter does not affect the method's behavior or the values it returns. The execution and semantics are the same for the late version compared to the early version. Therefore the CI type is 0 (No Compatibility Issue).
299,"<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionChanged(long,int,int,int,int)>",32,33,,,,"{
    synchronized (mSurfaceControlLock) {
        if (mSurfaceControl == null) {
            return;
        }
        if (mRTLastReportedPosition.left == left && mRTLastReportedPosition.top == top && mRTLastReportedPosition.right == right && mRTLastReportedPosition.bottom == bottom && mRTLastReportedSurfaceSize.x == mRtSurfaceWidth && mRTLastReportedSurfaceSize.y == mRtSurfaceHeight && !mPendingTransaction) {
            return;
        }
        try {
            if (DEBUG_POSITION) {
                Log.d(TAG, String.format(""%d updateSurfacePosition RenderWorker, frameNr = %d, "" + ""position = [%d, %d, %d, %d] surfaceSize = %dx%d"", System.identityHashCode(SurfaceView.this), frameNumber, left, top, right, bottom, mRtSurfaceWidth, mRtSurfaceHeight));
            }
            mRTLastReportedPosition.set(left, top, right, bottom);
            mRTLastReportedSurfaceSize.set(mRtSurfaceWidth, mRtSurfaceHeight);
            onSetSurfacePositionAndScaleRT(mPositionChangedTransaction, mSurfaceControl, mRTLastReportedPosition.left, /*positionLeft*/
            mRTLastReportedPosition.top, /*positionTop*/
            mRTLastReportedPosition.width() / (float) mRtSurfaceWidth, /*postScaleX*/
            mRTLastReportedPosition.height() / (float) mRtSurfaceHeight);
            if (mViewVisibility) {
                mPositionChangedTransaction.show(mSurfaceControl);
            }
            final ViewRootImpl viewRoot = getViewRootImpl();
            if (viewRoot != null) {
                applyChildSurfaceTransaction_renderWorker(mPositionChangedTransaction, viewRoot.mSurface, frameNumber);
            }
            applyOrMergeTransaction(mPositionChangedTransaction, frameNumber);
            mPendingTransaction = false;
        } catch (Exception ex) {
            Log.e(TAG, ""Exception from repositionChild"", ex);
        }
    }
}","{
    if (!mRtFirst && (mRTLastReportedPosition.left == left && mRTLastReportedPosition.top == top && mRTLastReportedPosition.right == right && mRTLastReportedPosition.bottom == bottom && mRTLastReportedSurfaceSize.x == mRtSurfaceWidth && mRTLastReportedSurfaceSize.y == mRtSurfaceHeight)) {
        return;
    }
    mRtFirst = false;
    try {
        if (DEBUG_POSITION) {
            Log.d(TAG, String.format(""%d updateSurfacePosition RenderWorker, frameNr = %d, "" + ""position = [%d, %d, %d, %d] surfaceSize = %dx%d"", System.identityHashCode(SurfaceView.this), frameNumber, left, top, right, bottom, mRtSurfaceWidth, mRtSurfaceHeight));
        }
        synchronized (mSurfaceControlLock) {
            if (mSurfaceControl == null)
                return;
            mRTLastReportedPosition.set(left, top, right, bottom);
            mRTLastReportedSurfaceSize.set(mRtSurfaceWidth, mRtSurfaceHeight);
            onSetSurfacePositionAndScale(mPositionChangedTransaction, mSurfaceControl, mRTLastReportedPosition.left, /*positionLeft*/
            mRTLastReportedPosition.top, /*positionTop*/
            mRTLastReportedPosition.width() / (float) mRtSurfaceWidth, /*postScaleX*/
            mRTLastReportedPosition.height() / (float) mRtSurfaceHeight);
            if (mViewVisibility) {
                // b/131239825
                mPositionChangedTransaction.show(mSurfaceControl);
            }
        }
        applyOrMergeTransaction(mPositionChangedTransaction, frameNumber);
    } catch (Exception ex) {
        Log.e(TAG, ""Exception from repositionChild"", ex);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",1,"A synchronized block was modified by adding a condition check outside of it and changing the method call from onSetSurfacePositionAndScaleRT to onSetSurfacePositionAndScale. The variable ""mRtFirst"" has been introduced and is used as part of the new condition check, along with the removal of ""mPendingTransaction"" condition and its associated logic. The change in the control logic, the modification to the synchronized block, and the change in the method call classify this code change under types 3 and 4.","The introduction of the ""mRtFirst"" variable and its use in a condition check may affect the flow of the method, potentially bypassing the synchronized block under different conditions than before. Additionally, the change from onSetSurfacePositionAndScaleRT to onSetSurfacePositionAndScale may have different side effects or behaviors because the actual implementation behind these methods could differ. The deletion of conditions involving ""mPendingTransaction"" can also change the behavior. As a result, these modifications introduce a potential Compatibility Issue due to a potential different return value or path, classified as type 1."
300,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,32,33,,,,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    // for @UnsupportedAppUsage
                    mCurMethod = res.method;
                    mCurrentInputMethodSession = InputMethodSessionWrapper.createOrNull(res.method);
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                    mIsInputMethodSuppressingSpellChecker = res.isInputMethodSuppressingSpellChecker;
                }
                startInputInner(StartInputReason.BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodDebug.unbindReasonToString(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // If we were actively using the last input method, then
                    // we would like to re-connect to the next input method.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && servedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(StartInputReason.UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                final boolean reportToImeController = msg.obj != null && (boolean) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    // Report active state to ImeFocusController to handle IME input
                    // connection lifecycle callback when it allowed.
                    final ImeFocusController controller = getFocusController();
                    final View rootView = mCurRootView != null ? mCurRootView.getView() : null;
                    if (controller != null && rootView != null && reportToImeController) {
                        rootView.post(() -> controller.onInteractiveChanged(active));
                        return;
                    }
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // Check focus again in case that ""onWindowFocus"" is called before
                    // handling this message.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && canStartInput(servedView)) {
                        if (mCurRootView != null && mCurRootView.getImeFocusController().checkFocus(mRestartOnNextWindowFocus, false)) {
                            final int reason = active ? StartInputReason.ACTIVATED_BY_IMMS : StartInputReason.DEACTIVATED_BY_IMMS;
                            mDelegate.startInput(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    // for @UnsupportedAppUsage
                    mCurMethod = res.method;
                    mCurrentInputMethodSession = InputMethodSessionWrapper.createOrNull(res.method);
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                    mVirtualDisplayToScreenMatrix = res.getVirtualDisplayToScreenMatrix();
                    mIsInputMethodSuppressingSpellChecker = res.isInputMethodSuppressingSpellChecker;
                }
                startInputInner(StartInputReason.BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodDebug.unbindReasonToString(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearAllAccessibilityBindingLocked();
                    clearBindingLocked();
                    // If we were actively using the last input method, then
                    // we would like to re-connect to the next input method.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && servedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(StartInputReason.UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_BIND_ACCESSIBILITY_SERVICE:
            {
                final int id = msg.arg1;
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND_ACCESSIBILITY "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    // registered and update the a11y service with the current cursor positions.
                    if (res.accessibilitySessions != null) {
                        IAccessibilityInputMethodSessionInvoker invoker = IAccessibilityInputMethodSessionInvoker.createOrNull(res.accessibilitySessions.get(id));
                        if (invoker != null) {
                            mAccessibilityInputMethodSession.put(id, invoker);
                            if (mServedInputConnection != null) {
                                invoker.updateSelection(mInitialSelStart, mInitialSelEnd, mCursorSelStart, mCursorSelEnd, mCursorCandStart, mCursorCandEnd);
                            } else {
                                // If an a11y service binds before input starts, we should still
                                // send a notification because the a11y service doesn't know it
                                // binds before or after input starts, it may wonder if it binds
                                // after input starts, why it doesn't receive a notification of
                                // the current cursor positions.
                                invoker.updateSelection(-1, -1, -1, -1, -1, -1);
                            }
                        }
                    }
                    mBindSequence = res.sequence;
                }
                startInputInner(StartInputReason.BOUND_ACCESSIBILITY_SESSION_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND_ACCESSIBILITY_SERVICE:
            {
                final int sequence = msg.arg1;
                final int id = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND_ACCESSIBILITY_SERVICE "" + sequence + "" id="" + id);
                }
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        if (DEBUG) {
                            Log.i(TAG, ""mBindSequence ="" + mBindSequence + "" sequence ="" + sequence + "" id="" + id);
                        }
                        return;
                    }
                    clearAccessibilityBindingLocked(id);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                final boolean reportToImeController = msg.obj != null && (boolean) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    // Report active state to ImeFocusController to handle IME input
                    // connection lifecycle callback when it allowed.
                    final ImeFocusController controller = getFocusController();
                    final View rootView = mCurRootView != null ? mCurRootView.getView() : null;
                    if (controller != null && rootView != null && reportToImeController) {
                        rootView.post(() -> controller.onInteractiveChanged(active));
                        return;
                    }
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        // Note that finishComposingText() is allowed to run
                        // even when we are not active.
                        mFallbackInputConnection.finishComposingTextFromImm();
                    }
                    // Check focus again in case that ""onWindowFocus"" is called before
                    // handling this message.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && canStartInput(servedView)) {
                        if (mCurRootView != null && mCurRootView.getImeFocusController().checkFocus(mRestartOnNextWindowFocus, false)) {
                            final int reason = active ? StartInputReason.ACTIVATED_BY_IMMS : StartInputReason.DEACTIVATED_BY_IMMS;
                            mDelegate.startInput(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                RemoteInputConnectionImpl ic = null;
                synchronized (mH) {
                    if (mFullscreenMode != fullscreen && mServedInputConnection != null) {
                        ic = mServedInputConnection;
                        mFullscreenMode = fullscreen;
                    }
                }
                if (ic != null) {
                    ic.dispatchReportFullscreenMode(fullscreen);
                }
                return;
            }
        case MSG_UPDATE_VIRTUAL_DISPLAY_TO_SCREEN_MATRIX:
            {
                final float[] matrixValues = (float[]) msg.obj;
                final int bindSequence = msg.arg1;
                synchronized (mH) {
                    if (mBindSequence != bindSequence) {
                        return;
                    }
                    if (matrixValues == null || mVirtualDisplayToScreenMatrix == null) {
                        // Either InputBoundResult#mVirtualDisplayToScreenMatrixValues is null
                        // OR this app is unbound from the parent VirtualDisplay. In this case,
                        // calling updateCursorAnchorInfo() isn't safe. Only clear the matrix.
                        mVirtualDisplayToScreenMatrix = null;
                        return;
                    }
                    final float[] currentValues = new float[9];
                    mVirtualDisplayToScreenMatrix.getValues(currentValues);
                    if (Arrays.equals(currentValues, matrixValues)) {
                        return;
                    }
                    mVirtualDisplayToScreenMatrix.setValues(matrixValues);
                    if (mCursorAnchorInfo == null || mCurrentInputMethodSession == null || mServedInputConnection == null) {
                        return;
                    }
                    final boolean isMonitoring = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_MONITOR) != 0;
                    if (!isMonitoring) {
                        return;
                    }
                    // Since the host VirtualDisplay is moved, we need to issue
                    // IMS#updateCursorAnchorInfo() again.
                    mCurrentInputMethodSession.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(mCursorAnchorInfo, mVirtualDisplayToScreenMatrix));
                }
                return;
            }
        case MSG_ON_SHOW_REQUESTED:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.onShowRequested();
                    }
                }
                return;
            }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
301,<android.app.PictureInPictureParams: boolean equals(Object)>,32,33,,,,"{
    if (this == o)
        return true;
    if (!(o instanceof PictureInPictureParams))
        return false;
    PictureInPictureParams that = (PictureInPictureParams) o;
    return Objects.equals(mAutoEnterEnabled, that.mAutoEnterEnabled) && Objects.equals(mSeamlessResizeEnabled, that.mSeamlessResizeEnabled) && Objects.equals(mAspectRatio, that.mAspectRatio) && Objects.equals(mUserActions, that.mUserActions) && Objects.equals(mSourceRectHint, that.mSourceRectHint);
}","{
    if (this == o)
        return true;
    if (!(o instanceof PictureInPictureParams))
        return false;
    PictureInPictureParams that = (PictureInPictureParams) o;
    return Objects.equals(mAutoEnterEnabled, that.mAutoEnterEnabled) && Objects.equals(mSeamlessResizeEnabled, that.mSeamlessResizeEnabled) && Objects.equals(mAspectRatio, that.mAspectRatio) && Objects.equals(mExpandedAspectRatio, that.mExpandedAspectRatio) && Objects.equals(mUserActions, that.mUserActions) && Objects.equals(mCloseAction, that.mCloseAction) && Objects.equals(mSourceRectHint, that.mSourceRectHint) && Objects.equals(mTitle, that.mTitle) && Objects.equals(mSubtitle, that.mSubtitle) && Objects.equals(mIsLaunchIntoPip, that.mIsLaunchIntoPip);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The implementation within the `equals` method has been changed by adding more conditions for object comparison, particularly new fields such as mExpandedAspectRatio, mCloseAction, mTitle, mSubtitle, and mIsLaunchIntoPip. However, this adjustment adheres to the contract of the equals method, so the change type is 4.","The alterations are consistent with the standard definition of an `equals` method, ensuring it continues to meet the contract by testing for equality of the new fields in addition to the existing ones. Consequently, there should be no compatibility issue, as the method is behaving as expected for an `equals` implementation when new fields are added to the class. Hence, the CI type is 0."
302,<android.content.pm.ShortcutManager: void disableShortcuts(List<String>)>,32,33,,,,"{
    try {
        getFutureOrThrow(mService.disableShortcuts(mContext.getPackageName(), shortcutIds, /* disabledMessage =*/
        null, /* disabledMessageResId =*/
        0, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.disableShortcuts(mContext.getPackageName(), shortcutIds, /* disabledMessage =*/
        null, /* disabledMessageResId =*/
        0, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Disable pinned shortcuts.  For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Disable pinned shortcuts.  For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,,,0,,,,,,,4,0,"The only change is the removal of the call to getFutureOrThrow() wrapper and instead directly invoking the mService.disableShortcuts() method. Since getFutureOrThrow() is usually a utility method for handling asynchronous calls or future results and does not affect the behavior of disabling shortcuts, the change type is 4 (Other statement changed).","No Compatibility Issue arises because the behavior and signature of the method disableShortcuts() haven't been altered. The end effect of the method is the same: it still attempts to disable shortcuts and throws a RemoteException that is rethrown as a SystemException. The actual process of disabling shortcuts is not directly affected by the use or omission of getFutureOrThrow(), as no changes to the return value or exception handling have been made in this context. Therefore, the CI type is 0 (No Compatibility Issue)."
303,<android.nfc.cardemulation.CardEmulation: boolean categoryAllowsForegroundPreference(String)>,32,33,,,,"{
    if (CATEGORY_PAYMENT.equals(category)) {
        boolean preferForeground = false;
        try {
            preferForeground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.NFC_PAYMENT_FOREGROUND) != 0;
        } catch (SettingNotFoundException e) {
        }
        return preferForeground;
    } else {
        // Allowed for all other categories
        return true;
    }
}","{
    if (CATEGORY_PAYMENT.equals(category)) {
        boolean preferForeground = false;
        try {
            preferForeground = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.NFC_PAYMENT_FOREGROUND, UserHandle.myUserId()) != 0;
        } catch (SettingNotFoundException e) {
        }
        return preferForeground;
    } else {
        // Allowed for all other categories
        return true;
    }
}",1,"/**
 * Returns whether the user has allowed AIDs registered in the
 * specified category to be handled by a service that is preferred
 * by the foreground application, instead of by a pre-configured default.
 *
 * Foreground applications can set such preferences using the
 * {@link #setPreferredService(Activity, ComponentName)} method.
 *
 * @param category The category, e.g. {@link #CATEGORY_PAYMENT}
 * @return whether AIDs in the category can be handled by a service
 * specified by the foreground app.
 */
","/**
 * Returns whether the user has allowed AIDs registered in the
 * specified category to be handled by a service that is preferred
 * by the foreground application, instead of by a pre-configured default.
 *
 * Foreground applications can set such preferences using the
 * {@link #setPreferredService(Activity, ComponentName)} method.
 *
 * @param category The category, e.g. {@link #CATEGORY_PAYMENT}
 * @return whether AIDs in the category can be handled by a service
 * specified by the foreground app.
 */
",0,,,0,,,,,,,5,0,"The implementation switched from using Settings.Secure.getInt to Settings.Secure.getIntForUser with an additional UserHandle.myUserId() parameter. There are no return statement changes or exception handling changes, so the change type is 5.","This change is not a Compatibility Issue, it is simply an update to use a more specific version of the API that considers the user ID. There's no change in the method's behavior from the perspective of how it handles the data it returns or the exceptions it may throw. It still returns true for non-payment categories and the result of the preferForeground check for the payment category. Therefore, there is no compatibility issue, which is 0."
304,<android.os.PowerManager: void removeThermalStatusListener(OnThermalStatusChangedListener)>,32,33,,,,"{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    IThermalStatusListener internalListener = mListenerMap.get(listener);
    Preconditions.checkArgument(internalListener != null, ""Listener was not added"");
    try {
        if (mThermalService.unregisterThermalStatusListener(internalListener)) {
            mListenerMap.remove(listener);
        } else {
            throw new RuntimeException(""Listener failed to remove"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(listener, ""listener cannot be null"");
    IThermalStatusListener internalListener = mListenerMap.get(listener);
    Preconditions.checkArgument(internalListener != null, ""Listener was not added"");
    try {
        if (mThermalService.unregisterThermalStatusListener(internalListener)) {
            mListenerMap.remove(listener);
        } else {
            throw new RuntimeException(""Listener failed to remove"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * This function removes a listener for thermal status change
 *
 * @param listener listener to be removed
 */
","/**
 * This function removes a listener for thermal status change
 *
 * @param listener listener to be removed
 */
",0,,,0,,,,,,,4,0,The change in the code is the replacement of `Preconditions.checkNotNull` with `Objects.requireNonNull`. This does not affect the behaviour of the method since both methods serve the same purpose of checking for nullability and throwing a NullPointerException if the condition is not met.,"There is no Compatibility Issue as the change does not affect the API's return value(s) or type(s), nor does it throw a new/different exception. It is merely a change in the internal implementation detail with equivalent functionality."
305,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setScale(float,boolean)>",32,33,,,,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, scale, Float.NaN, Float.NaN, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            final MagnificationConfig config = new MagnificationConfig.Builder().setMode(MAGNIFICATION_MODE_FULLSCREEN).setScale(scale).build();
            return connection.setMagnificationConfig(mDisplayId, config, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Sets the magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param scale the magnification scale to set, must be >= 1 and <= 8
 * @param animate {@code true} to animate from the current scale or
 * {@code false} to set the scale immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Sets the magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 * <p>
 * <strong>Note:</strong> This legacy API sets the scale of full-screen
 * magnification. To set the scale of the specified magnifier,
 * use {@link #setMagnificationConfig} instead.
 * </p>
 *
 * @param scale the magnification scale to set, must be >= 1 and <= 8
 * @param animate {@code true} to animate from the current scale or
 * {@code false} to set the scale immediately
 * @return {@code true} on success, {@code false} on failure
 * @deprecated Use {@link #setMagnificationConfig(MagnificationConfig, boolean)} instead
 */
",1,,[@Deprecated],1,,,,,,,"1,4,5",1,"The implementation has changed, including constructing a new object (MagnificationConfig) and invoking a different method on the 'connection' object. The previous implementation called connection.setMagnificationScaleAndCenter(), while the new version calls connection.setMagnificationConfig(). Moreover, there were changes in parameters that are passed to the dependent method within the 'try' block. These changes represent a return statement change, other statement change, and a dependent API change, hence the code change type is 1,4,5.","The changes in the API implementation lead to the invocation of a different method on the 'connection' object, which might lead to a different return value or behavior. Given that the invocation of a different method can cause the API to behave differently when setting the magnification scale, there is a potential for returning a different value, and thus the CI type is 1."
307,<android.content.pm.SigningInfo: Signature[] getSigningCertificateHistory()>,32,33,,,,"{
    if (hasMultipleSigners()) {
        return null;
    } else if (!hasPastSigningCertificates()) {
        // this package is only signed by one signer with no history, return it
        return mSigningDetails.signatures;
    } else {
        // this package has provided proof of past signing certificates, include them
        return mSigningDetails.pastSigningCertificates;
    }
}","{
    if (hasMultipleSigners()) {
        return null;
    } else if (!hasPastSigningCertificates()) {
        // this package is only signed by one signer with no history, return it
        return mSigningDetails.getSignatures();
    } else {
        // this package has provided proof of past signing certificates, include them
        return mSigningDetails.getPastSigningCertificates();
    }
}",1,"/**
 * Returns the signing certificates this package has proven it is authorized to use. This
 * includes both the signing certificate associated with the signer of the package and the past
 * signing certificates it included as its proof of signing certificate rotation.  This method
 * is the preferred replacement for the {@code GET_SIGNATURES} flag used with {@link
 * PackageManager#getPackageInfo(String, int)}.  When determining if a package is signed by a
 * desired certificate, the returned array should be checked to determine if it is one of the
 * entries.
 *
 * <note>
 * This method returns null if the package is signed by multiple signing certificates, as
 * opposed to being signed by one current signer and also providing the history of past
 * signing certificates.  {@link #hasMultipleSigners()} may be used to determine if this
 * package is signed by multiple signers.  Packages which are signed by multiple signers
 * cannot change their signing certificates and their {@code Signature} array should be
 * checked to make sure that every entry matches the looked-for signing certificates.
 * </note>
 */
","/**
 * Returns the signing certificates this package has proven it is authorized to use. This
 * includes both the signing certificate associated with the signer of the package and the past
 * signing certificates it included as its proof of signing certificate rotation.  Signing
 * certificates are returned in the order of rotation with the original signing certificate at
 * index 0, and the current signing certificate at the last index. This method is the preferred
 * replacement for the {@code GET_SIGNATURES} flag used with {@link
 * PackageManager#getPackageInfo(String, int)}. When determining if a package is signed by a
 * desired certificate, the returned array should be checked to determine if it is one of the
 * entries.
 *
 * <note>
 * This method returns null if the package is signed by multiple signing certificates, as
 * opposed to being signed by one current signer and also providing the history of past
 * signing certificates.  {@link #hasMultipleSigners()} may be used to determine if this
 * package is signed by multiple signers.  Packages which are signed by multiple signers
 * cannot change their signing certificates and their {@code Signature} array should be
 * checked to make sure that every entry matches the looked-for signing certificates.
 * </note>
 */
",1,,,0,,,,,,,"4,5",1,"The method calls within the return statements have changed from accessing the field directly (mSigningDetails.signatures) to calling methods (mSigningDetails.getSignatures() and mSigningDetails.getPastSigningCertificates()), so the code change type is 4,5. ","The changes to the returned values are coming from methods that might not just be simple field accessors. They can involve more complex logic or even different values. This could potentially lead to the API returning different value(s), therefore the CI type is 1."
308,<android.companion.AssociationRequest: int hashCode()>,32,33,,,,"{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + Boolean.hashCode(mSingleDevice);
    _hash = 31 * _hash + Objects.hashCode(mDeviceFilters);
    _hash = 31 * _hash + Objects.hashCode(mDeviceProfile);
    _hash = 31 * _hash + Objects.hashCode(mCallingPackage);
    _hash = 31 * _hash + Objects.hashCode(mDeviceProfilePrivilegesDescription);
    _hash = 31 * _hash + Long.hashCode(mCreationTime);
    _hash = 31 * _hash + Boolean.hashCode(mSkipPrompt);
    return _hash;
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + Boolean.hashCode(mSingleDevice);
    _hash = 31 * _hash + Objects.hashCode(mDeviceFilters);
    _hash = 31 * _hash + Objects.hashCode(mDeviceProfile);
    _hash = 31 * _hash + Objects.hashCode(mDisplayName);
    _hash = 31 * _hash + Boolean.hashCode(mSelfManaged);
    _hash = 31 * _hash + Boolean.hashCode(mForceConfirmation);
    _hash = 31 * _hash + Objects.hashCode(mPackageName);
    _hash = 31 * _hash + mUserId;
    _hash = 31 * _hash + Objects.hashCode(mDeviceProfilePrivilegesDescription);
    _hash = 31 * _hash + Long.hashCode(mCreationTime);
    _hash = 31 * _hash + Boolean.hashCode(mSkipPrompt);
    return _hash;
}",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,,,,"1,4",1,"The method for calculating the hash code has been modified, with different fields involved in the two versions, which indicates that the overall hash calculation logic has been changed. Specifically, calling Objects.hashCode(mCallingPackage) has been replaced with Objects.hashCode(mPackageName) and Objects.hashCode(mDisplayName), and two new lines of Boolean.hashCode(mSelfManaged) and Boolean.hashCode(mForceConfirmation) have been added, as well as a new line _hash = 31 * _hash + mUserId, while removing one line that was hashing `mCallingPackage`. These changes are classified as 'other statement changed.'","The hashCode() method will now return a different hash value because the fields it depends on for its calculation have changed, as well as the process of how these fields are being hashed. This means a Compatibility Issue of type 1 could arise, potentially causing different hash values for objects that would have been equal in the previous version."
309,<android.content.Intent: String resolveTypeIfNeeded(ContentResolver)>,32,33,,,,"{
    if (mComponent != null) {
        return mType;
    }
    return resolveType(resolver);
}","{
    // Match logic in PackageManagerService#applyEnforceIntentFilterMatching(...)
    if (mComponent != null && (Process.myUid() == Process.ROOT_UID || Process.myUid() == Process.SYSTEM_UID || mComponent.getPackageName().equals(ActivityThread.currentPackageName()))) {
        return mType;
    }
    return resolveType(resolver);
}",1,"/**
 * Return the MIME data type of this intent, only if it will be needed for
 * intent resolution.  This is not generally useful for application code;
 * it is used by the frameworks for communicating with back-end system
 * services.
 *
 * @param resolver A ContentResolver that can be used to determine the MIME
 * type of the intent's data.
 *
 * @return The MIME type of this intent, or null if it is unknown or not
 * needed.
 */
","/**
 * Return the MIME data type of this intent, only if it will be needed for
 * intent resolution.  This is not generally useful for application code;
 * it is used by the frameworks for communicating with back-end system
 * services.
 *
 * @param resolver A ContentResolver that can be used to determine the MIME
 * type of the intent's data.
 *
 * @return The MIME type of this intent, or null if it is unknown or not
 * needed.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,3,0,"The change involves adding extra conditions for an if statement to check additional criteria such as the UID of the process and the package name. This is a control dependency change, classified as 3.","Although there is a control dependency change, this does not introduce different behavior that would lead to a CI regarding return statements or exception handling. If the new conditions are not met, the code proceeds to call the same resolveType(resolver) method as in the early version. Therefore, there is no change in the potential return value or type, nor in the exception handling, so the CI type is 0."
312,<android.os.BaseBundle: ArrayList<String> getStringArrayList(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<String>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList<String>"", e);
        return null;
    }
}","{
    return getArrayList(key, String.class);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */
",0,[@Nullable],[@Nullable],0,,,,,,,5,0,"The late implementation delegates the call to a different method (getArrayList(key, String.class)) compared to directly operating on the bundle map in the early version, so the code change type is 5.","Even though the implementation has changed, the same result (an ArrayList<String> or null) is expected to be returned assuming the getArrayList is correctly implemented to fetch the ArrayList<String> with the given key. Since there is no change in exception handling or return values in the method itself, there is no Compatibility Issue, meaning CI type is 0."
313,"<android.app.ContextImpl: int[] checkUriPermissions(List<Uri>,int,int,int)>",32,33,,,,"{
    try {
        return ActivityManager.getService().checkUriPermissions(uris, pid, uid, modeFlags, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return ActivityManager.getService().checkUriPermissions(uris, pid, uid, modeFlags, getUserId(), null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,"[@NonNull, @Override]","[@NonNull, @Override]",0,,,,,,,5,0,"The dependent API ActivityManager.getService().checkUriPermissions() has had a change in the type and number of parameters by adding getUserId() in the late version, so the code change type is 5.","Although there is a change in the parameters of the dependent API, this does not necessarily result in a Compatibility Issue. The method's signature remains the same, and it's expected to handle the additional parameter internally. Therefore, there is no CI caused by potentially different values or exception handling in this case."
315,<android.content.pm.PackageInstaller.SessionInfo: int getStagedSessionErrorCode()>,32,33,,,,"{
    checkSessionIsStaged();
    return mStagedSessionErrorCode;
}","{
    checkSessionIsStaged();
    return mSessionErrorCode;
}",1,"/**
 * If something went wrong with a staged session, clients can check this error code to
 * understand which kind of failure happened. Only meaningful if {@code isStaged} is true.
 */
","/**
 * If something went wrong with a staged session, clients can check this error code to
 * understand which kind of failure happened. Only meaningful if {@code isStaged} is true.
 */
",0,[@StagedSessionErrorCode],,1,,,,,,,"1,5",1,"The field from which the return value is obtained has changed from 'mStagedSessionErrorCode' to 'mSessionErrorCode'. Additionally, there is no annotation associated with the late version API, so the code change type is 1,5.","Since the field from which the error code is returned has changed, it could potentially return a different value, leading to a different behavior. Therefore, the CI type is 1."
317,<android.hardware.soundtrigger.SoundTrigger.RecognitionEvent: String toString()>,32,33,,,,"{
    return ""RecognitionEvent [status="" + status + "", soundModelHandle="" + soundModelHandle + "", captureAvailable="" + captureAvailable + "", captureSession="" + captureSession + "", captureDelayMs="" + captureDelayMs + "", capturePreambleMs="" + capturePreambleMs + "", triggerInData="" + triggerInData + ((captureFormat == null) ? """" : ("", sampleRate="" + captureFormat.getSampleRate())) + ((captureFormat == null) ? """" : ("", encoding="" + captureFormat.getEncoding())) + ((captureFormat == null) ? """" : ("", channelMask="" + captureFormat.getChannelMask())) + "", data="" + (data == null ? 0 : data.length) + ""]"";
}","{
    return ""RecognitionEvent [status="" + status + "", soundModelHandle="" + soundModelHandle + "", captureAvailable="" + captureAvailable + "", captureSession="" + captureSession + "", captureDelayMs="" + captureDelayMs + "", capturePreambleMs="" + capturePreambleMs + "", triggerInData="" + triggerInData + ((captureFormat == null) ? """" : ("", sampleRate="" + captureFormat.getSampleRate())) + ((captureFormat == null) ? """" : ("", encoding="" + captureFormat.getEncoding())) + ((captureFormat == null) ? """" : ("", channelMask="" + captureFormat.getChannelMask())) + "", data="" + (data == null ? 0 : data.length) + "", recognitionStillActive="" + recognitionStillActive + ""]"";
}",1,,,0,"[@NonNull, @Override]","[@NonNull, @Override]",0,,,,,,,"1,4",1,"The return statement has been augmented with an additional string concatenation including the value of `recognitionStillActive`, which is a change outside of the control structures. The code change types are 1 for the return statement changed and 4 for other statement changed.","The API now returns a different string value due to the addition of `recognitionStillActive` in the returned string. This constitutes a potential Compatibility Issue as the return value has changed, so the CI type is 1."
318,<android.view.DisplayCutout: Path getCutoutPath()>,32,33,,,,"{
    if (!mCutoutPathParserInfo.hasCutout()) {
        return null;
    }
    synchronized (CACHE_LOCK) {
        if (mCutoutPathParserInfo.equals(sCachedCutoutPathParserInfo)) {
            return sCachedCutoutPath;
        }
    }
    final CutoutSpecification cutoutSpec = new CutoutSpecification.Parser(mCutoutPathParserInfo.getDensity(), mCutoutPathParserInfo.getDisplayWidth(), mCutoutPathParserInfo.getDisplayHeight()).parse(mCutoutPathParserInfo.getCutoutSpec());
    final Path cutoutPath = cutoutSpec.getPath();
    if (cutoutPath == null || cutoutPath.isEmpty()) {
        return null;
    }
    final Matrix matrix = new Matrix();
    if (mCutoutPathParserInfo.getRotation() != ROTATION_0) {
        RotationUtils.transformPhysicalToLogicalCoordinates(mCutoutPathParserInfo.getRotation(), mCutoutPathParserInfo.getDisplayWidth(), mCutoutPathParserInfo.getDisplayHeight(), matrix);
    }
    matrix.postScale(mCutoutPathParserInfo.getScale(), mCutoutPathParserInfo.getScale());
    cutoutPath.transform(matrix);
    synchronized (CACHE_LOCK) {
        sCachedCutoutPathParserInfo = new CutoutPathParserInfo(mCutoutPathParserInfo);
        sCachedCutoutPath = cutoutPath;
    }
    return cutoutPath;
}","{
    if (!mCutoutPathParserInfo.hasCutout()) {
        return null;
    }
    synchronized (CACHE_LOCK) {
        if (mCutoutPathParserInfo.equals(sCachedCutoutPathParserInfo)) {
            return sCachedCutoutPath;
        }
    }
    final CutoutSpecification cutoutSpec = new CutoutSpecification.Parser(mCutoutPathParserInfo.getDensity(), mCutoutPathParserInfo.getPhysicalDisplayWidth(), mCutoutPathParserInfo.getPhysicalDisplayHeight(), mCutoutPathParserInfo.getPhysicalPixelDisplaySizeRatio()).parse(mCutoutPathParserInfo.getCutoutSpec());
    final Path cutoutPath = cutoutSpec.getPath();
    if (cutoutPath == null || cutoutPath.isEmpty()) {
        return null;
    }
    final Matrix matrix = new Matrix();
    if (mCutoutPathParserInfo.getRotation() != ROTATION_0) {
        RotationUtils.transformPhysicalToLogicalCoordinates(mCutoutPathParserInfo.getRotation(), mCutoutPathParserInfo.getDisplayWidth(), mCutoutPathParserInfo.getDisplayHeight(), matrix);
    }
    matrix.postScale(mCutoutPathParserInfo.getScale(), mCutoutPathParserInfo.getScale());
    cutoutPath.transform(matrix);
    synchronized (CACHE_LOCK) {
        sCachedCutoutPathParserInfo = new CutoutPathParserInfo(mCutoutPathParserInfo);
        sCachedCutoutPath = cutoutPath;
    }
    return cutoutPath;
}",1,"/**
 * Returns a {@link Path} that contains the cutout paths of all sides on the display.
 *
 * To get a cutout path for one specific side, apps can intersect the {@link Path} with the
 * {@link Rect} obtained from {@link #getBoundingRectLeft()}, {@link #getBoundingRectTop()},
 * {@link #getBoundingRectRight()} or {@link #getBoundingRectBottom()}.
 *
 * @return a {@link Path} contains all the cutout paths based on display coordinate. Returns
 * null if there is no cutout on the display.
 */
","/**
 * Returns a {@link Path} that contains the cutout paths of all sides on the display.
 *
 * To get a cutout path for one specific side, apps can intersect the {@link Path} with the
 * {@link Rect} obtained from {@link #getBoundingRectLeft()}, {@link #getBoundingRectTop()},
 * {@link #getBoundingRectRight()} or {@link #getBoundingRectBottom()}.
 *
 * @return a {@link Path} contains all the cutout paths based on display coordinate. Returns
 * null if there is no cutout on the display.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,"4,5",0,"The method signature for the `CutoutSpecification.Parser` constructor has changed, it now includes an additional parameter, `mCutoutPathParserInfo.getPhysicalPixelDisplaySizeRatio()`. Therefore, we have two changes: other statement changed (4) because of the extra parameter in the constructor call, and dependent API changed (5) due to alteration in the constructor or method signature it depends on.","There is no CI present, since the Path object returned by the method `getCutoutPath()` is not influenced by the extra parameter in the constructor from a use-case perspective. The method still produces a Path or returns null based on the presence of a cutout, and the behavior related to the Cache and the associated logic remains the same. The additional parameter impacts the internal processing but does not change the semantic contract of the `getCutoutPath()` method itself."
320,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,32,33,,,,"{
    enforceSealed();
    if (mLeashedParent != null && mLeashedParentNodeId != UNDEFINED_NODE_ID) {
        return getNodeForAccessibilityId(mConnectionId, mLeashedParent, mLeashedParentNodeId);
    }
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mParentNodeId);
}","{
    enforceSealed();
    if (mLeashedParent != null && mLeashedParentNodeId != UNDEFINED_NODE_ID) {
        return getNodeForAccessibilityId(mConnectionId, mLeashedParent, mLeashedParentNodeId, FLAG_PREFETCH_ANCESTORS | FLAG_PREFETCH_SIBLINGS);
    }
    return getNodeForAccessibilityId(mConnectionId, mWindowId, mParentNodeId);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 *
 * @return The parent.
 */
",1,,,0,,,,,,,5,1,"The only code change that occurred is an additional argument passed to the method 'getNodeForAccessibilityId' within the if statement, which suggests the addition of flags (FLAG_PREFETCH_ANCESTORS | FLAG_PREFETCH_SIBLINGS). Therefore, the code change type is 5.","The added flags to the method 'getNodeForAccessibilityId' indicate that the method behavior could potentially change, potentially leading to different values being returned. Because these flags suggest prefetching behavior that could modify the data being returned (such as additional information about ancestors or siblings), this qualifies as a CI type 1 due to potential different return values or types."
321,<android.content.pm.ShortcutManager: void removeAllDynamicShortcuts()>,32,33,,,,"{
    try {
        getFutureOrThrow(mService.removeAllDynamicShortcuts(mContext.getPackageName(), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.removeAllDynamicShortcuts(mContext.getPackageName(), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Delete all dynamic shortcuts from the caller app.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Delete all dynamic shortcuts from the caller app.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,,,0,,,,,,,4,0,"The only change is the removal of the `getFutureOrThrow()` method call around the `mService.removeAllDynamicShortcuts()` call, which indicates a change in how the value is handled, but since the containing method's return type is void, the final behavior of the method would remain unchanged. Therefore, the code change type is 4 (Other statement changed).","The change does not affect the return type or the exceptions that could be thrown by the API; it only affects an internal detail of the implementation which does not lead to a compatibility issue. The method's contract as seen by the callers remains the same, and therefore there is no compatibility issue, meaning the CI type is 0 (No Compatibility Issue)."
322,<android.hardware.display.VirtualDisplayConfig.Builder: VirtualDisplayConfig build()>,32,33,,,,"{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x200;
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mFlags = 0;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mSurface = null;
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mUniqueId = null;
    }
    if ((mBuilderFieldsSet & 0x80) == 0) {
        mDisplayIdToMirror = DEFAULT_DISPLAY;
    }
    if ((mBuilderFieldsSet & 0x100) == 0) {
        mWindowTokenClientToMirror = null;
    }
    VirtualDisplayConfig o = new VirtualDisplayConfig(mName, mWidth, mHeight, mDensityDpi, mFlags, mSurface, mUniqueId, mDisplayIdToMirror, mWindowTokenClientToMirror);
    return o;
}","{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x200;
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mFlags = 0;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mSurface = null;
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mUniqueId = null;
    }
    if ((mBuilderFieldsSet & 0x80) == 0) {
        mDisplayIdToMirror = DEFAULT_DISPLAY;
    }
    if ((mBuilderFieldsSet & 0x100) == 0) {
        mWindowManagerMirroring = false;
    }
    VirtualDisplayConfig o = new VirtualDisplayConfig(mName, mWidth, mHeight, mDensityDpi, mFlags, mSurface, mUniqueId, mDisplayIdToMirror, mWindowManagerMirroring);
    return o;
}",1,"/**
 * Builds the instance. This builder should not be touched after calling this!
 */
","/**
 * Builds the instance. This builder should not be touched after calling this!
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,4,5",1,"There is a change in a field assignment statement: from `mWindowTokenClientToMirror = null;` to `mWindowManagerMirroring = false;`, and the constructor signature for `VirtualDisplayConfig` changed: the last parameter changed from `mWindowTokenClientToMirror` to `mWindowManagerMirroring`. Such transitions can affect the return values, so the change types are 1,4,5.","The change causes the method to return a different instance of `VirtualDisplayConfig` with different fields set, which could result in a different behavior when this object is used, hence the CI type is 1."
326,<android.content.pm.SigningInfo: boolean hasPastSigningCertificates()>,32,33,,,,"{
    return mSigningDetails.signatures != null && mSigningDetails.pastSigningCertificates != null;
}","{
    return mSigningDetails.getPastSigningCertificates() != null && mSigningDetails.getPastSigningCertificates().length > 0;
}",1,"/**
 * APK Signature Scheme v3 enables packages to provide a proof-of-rotation record that the
 * platform verifies, and uses, to allow the use of new signing certificates.  This is only
 * available to packages that are not signed by multiple signers.  In the event of a change to a
 * new signing certificate, the package's past signing certificates are presented as well.  Any
 * check of a package's signing certificate should also include a search through its entire
 * signing history, since it could change to a new signing certificate at any time.
 */
","/**
 * APK Signature Scheme v3 enables packages to provide a proof-of-rotation record that the
 * platform verifies, and uses, to allow the use of new signing certificates.  This is only
 * available to packages that are not signed by multiple signers.  In the event of a change to a
 * new signing certificate, the package's past signing certificates are presented as well.  Any
 * check of a package's signing certificate should also include a search through its entire
 * signing history, since it could change to a new signing certificate at any time.
 */
",0,,,0,,,,,,,"1,5",1,"The method `getPastSigningCertificates()` is called instead of directly accessing the `pastSigningCertificates` field, and an additional check for the length of the array is introduced. Therefore, the code change types are 1,5.","The condition on which the API's return value is based has changed. Previously, it was enough for the array to be non-null; now, it additionally requires the array to have a length greater than zero, potentially leading to a different return value. Therefore, the CI type is 1."
327,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,32,33,,,,"{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // entries from the ArrayMap.
        for (int i = mDeviceStatus.size() - 1; i >= 0; i--) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        mConcurrentCameraIdCombinations.clear();
        scheduleCameraServiceReconnectionLocked();
    }
}","{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // entries from the ArrayMap.
        for (int i = mDeviceStatus.size() - 1; i >= 0; i--) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId);
            if (mHasOpenCloseListenerPermission) {
                onCameraClosedLocked(cameraId);
            }
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        mConcurrentCameraIdCombinations.clear();
        scheduleCameraServiceReconnectionLocked();
    }
}",1,"/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
","/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
",0,,,0,,,,,,,"3,4",0,A new conditional check for mHasOpenCloseListenerPermission and a consequent invocation to onCameraClosedLocked(cameraId) have been introduced in a control dependency. This corresponds to types 3 and 4 since it's a control structure (if condition) and a new method invocation that doesn't change the control flow from earlier versions.,There is no Compatibility Issue because the modifications do not change the method's return type or thrown exceptions. The method still doesn't return anything (void type) and does not throw exceptions based on the changes.
328,<android.companion.CompanionDeviceService: IBinder onBind(Intent)>,32,33,,,,"{
    if (Objects.equals(intent.getAction(), SERVICE_INTERFACE)) {
        return mRemote;
    }
    Log.w(LOG_TAG, ""Tried to bind to wrong intent (should be "" + SERVICE_INTERFACE + ""): "" + intent);
    return null;
}","{
    if (Objects.equals(intent.getAction(), SERVICE_INTERFACE)) {
        onBindCompanionDeviceService(intent);
        return mRemote;
    }
    Log.w(LOG_TAG, ""Tried to bind to wrong intent (should be "" + SERVICE_INTERFACE + ""): "" + intent);
    return null;
}",1,,,0,"[@Nullable, @Override]","[@Nullable, @Override]",0,,,,,,,4,0,"The method 'onBindCompanionDeviceService(intent)' has been added right before the return statement when the condition is true. This addition is an other statement change, so the code change type is 4.","The added invocation does not change the function's return value nor modify its exception handling. Assuming the new method 'onBindCompanionDeviceService(intent)' does not throw an unchecked exception, there should not be a Compatibility Issue, so the CI type is 0."
329,"<android.provider.Settings.Global: float getFloat(ContentResolver,String,float)>",32,33,,,,"{
    String v = getString(cr, name);
    try {
        return v != null ? Float.parseFloat(v) : def;
    } catch (NumberFormatException e) {
        return def;
    }
}","{
    String v = getString(cr, name);
    return parseFloatSettingWithDefault(v, def);
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
",0,,,0,,,,,,,5,0,"The changes between the early and late versions involve moving the logic of parsing the float and handling the NumberFormatException into a separate method parseFloatSettingWithDefault. Since the underlying logic does not seem to be changed, just refactored into another method, the code change type is 5 (Dependent API changed).","There is no Compatibility Issue detected because the behavior of the API has not changed; it still returns the same value based on the same conditions, and the exception handling has not been altered in terms of the behavior visible to the caller. It is only an internal refactoring, moving the logic to another method."
330,"<android.content.pm.PackageManager: Resources getResourcesForApplication(ApplicationInfo,Configuration)>",32,33,,,,"{
    throw new UnsupportedOperationException();
}","{
    return getResourcesForApplication(app);
}",1,"/**
 * Retrieve the resources for an application for the provided configuration.
 *
 * @param app Information about the desired application.
 * @param configuration Overridden configuration when loading the Resources
 *
 * @return Returns the application's Resources.
 * @throws NameNotFoundException Thrown if the resources for the given
 * application could not be loaded (most likely because it was uninstalled).
 */
","/**
 * Retrieve the resources for an application for the provided configuration.
 *
 * @param app Information about the desired application.
 * @param configuration Overridden configuration when loading the Resources
 *
 * @return Returns the application's Resources.
 * @throws NameNotFoundException Thrown if the resources for the given
 * application could not be loaded (most likely because it was uninstalled).
 */
",0,[@NonNull],[@NonNull],0,,,,,,,1,1,"The `UnsupportedOperationException` is removed, and in the late version, it returns the result from getResourcesForApplication(app), leading to a change in the return statement, so the code change type is 1.","The early version of the method always raises an `UnsupportedOperationException`, while the late version may return a valid `Resources` object. This results in a change in the behavior that could cause a Compatibility Issue for code depending on the exception being thrown. Therefore, the CI type is 1."
331,<android.net.Ikev2VpnProfile: X509Certificate getUserCert()>,32,33,,,,"{
    return mUserCert;
}","{
    if (mIkeTunConnParams != null)
        return null;
    return mUserCert;
}",1,"/**
 * Retrieves the user certificate, if any was set.
 */
","/**
 * Retrieves the user certificate, if any was set.
 *
 * <p>May be null if the profile is built from an {@link IkeTunnelConnectionParams}.
 */
",1,[@Nullable],[@Nullable],0,,,,,,,"1,3",1,"A control dependency has been introduced (if statement with condition mIkeTunConnParams != null) along with a new return statement that can potentially return null, which indicates that there is a change in return statement (type 1) as well as a control dependency change (type 3).",This new control statement can cause the method to return a different value (null instead of mUserCert) based on the condition of mIkeTunConnParams. This constitutes a potential compatibility issue due to a possible different return value (CI type 1).
333,<android.widget.PopupWindow: void dismiss()>,32,33,,,,"{
    if (!isShowing() || isTransitioningToDismiss()) {
        return;
    }
    final PopupDecorView decorView = mDecorView;
    final View contentView = mContentView;
    final ViewGroup contentHolder;
    final ViewParent contentParent = contentView.getParent();
    if (contentParent instanceof ViewGroup) {
        contentHolder = ((ViewGroup) contentParent);
    } else {
        contentHolder = null;
    }
    // Ensure any ongoing or pending transitions are canceled.
    decorView.cancelTransitions();
    mIsShowing = false;
    mIsTransitioningToDismiss = true;
    // This method may be called as part of window detachment, in which
    // case the anchor view (and its root) will still return true from
    // isAttachedToWindow() during execution of this method; however, we
    // can expect the OnAttachStateChangeListener to have been called prior
    // to executing this method, so we can rely on that instead.
    final Transition exitTransition = mExitTransition;
    if (exitTransition != null && decorView.isLaidOut() && (mIsAnchorRootAttached || mAnchorRoot == null)) {
        // The decor view is non-interactive and non-IME-focusable during exit transitions.
        final LayoutParams p = (LayoutParams) decorView.getLayoutParams();
        p.flags |= LayoutParams.FLAG_NOT_TOUCHABLE;
        p.flags |= LayoutParams.FLAG_NOT_FOCUSABLE;
        p.flags &= ~LayoutParams.FLAG_ALT_FOCUSABLE_IM;
        mWindowManager.updateViewLayout(decorView, p);
        final View anchorRoot = mAnchorRoot != null ? mAnchorRoot.get() : null;
        final Rect epicenter = getTransitionEpicenter();
        // Once we start dismissing the decor view, all state (including
        // the anchor root) needs to be moved to the decor view since we
        // may open another popup while it's busy exiting.
        decorView.startExitTransition(exitTransition, anchorRoot, epicenter, new TransitionListenerAdapter() {

            @Override
            public void onTransitionEnd(Transition transition) {
                dismissImmediate(decorView, contentHolder, contentView);
            }
        });
    } else {
        dismissImmediate(decorView, contentHolder, contentView);
    }
    // Clears the anchor view.
    detachFromAnchor();
    if (mOnDismissListener != null) {
        mOnDismissListener.onDismiss();
    }
}","{
    if (!isShowing() || isTransitioningToDismiss()) {
        return;
    }
    final PopupDecorView decorView = mDecorView;
    final View contentView = mContentView;
    unregisterBackCallback(decorView.findOnBackInvokedDispatcher());
    final ViewGroup contentHolder;
    final ViewParent contentParent = contentView.getParent();
    if (contentParent instanceof ViewGroup) {
        contentHolder = ((ViewGroup) contentParent);
    } else {
        contentHolder = null;
    }
    // Ensure any ongoing or pending transitions are canceled.
    decorView.cancelTransitions();
    mIsShowing = false;
    mIsTransitioningToDismiss = true;
    // This method may be called as part of window detachment, in which
    // case the anchor view (and its root) will still return true from
    // isAttachedToWindow() during execution of this method; however, we
    // can expect the OnAttachStateChangeListener to have been called prior
    // to executing this method, so we can rely on that instead.
    final Transition exitTransition = mExitTransition;
    if (exitTransition != null && decorView.isLaidOut() && (mIsAnchorRootAttached || mAnchorRoot == null)) {
        // The decor view is non-interactive and non-IME-focusable during exit transitions.
        final LayoutParams p = (LayoutParams) decorView.getLayoutParams();
        p.flags |= LayoutParams.FLAG_NOT_TOUCHABLE;
        p.flags |= LayoutParams.FLAG_NOT_FOCUSABLE;
        p.flags &= ~LayoutParams.FLAG_ALT_FOCUSABLE_IM;
        mWindowManager.updateViewLayout(decorView, p);
        final View anchorRoot = mAnchorRoot != null ? mAnchorRoot.get() : null;
        final Rect epicenter = getTransitionEpicenter();
        // Once we start dismissing the decor view, all state (including
        // the anchor root) needs to be moved to the decor view since we
        // may open another popup while it's busy exiting.
        decorView.startExitTransition(exitTransition, anchorRoot, epicenter, new TransitionListenerAdapter() {

            @Override
            public void onTransitionEnd(Transition transition) {
                dismissImmediate(decorView, contentHolder, contentView);
            }
        });
    } else {
        dismissImmediate(decorView, contentHolder, contentView);
    }
    // Clears the anchor view.
    detachFromAnchor();
    if (mOnDismissListener != null) {
        mOnDismissListener.onDismiss();
    }
}",1,"/**
 * Disposes of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing
 * that, calling this method will have no effect.
 *
 * @see #showAsDropDown(android.view.View)
 */
","/**
 * Disposes of the popup window. This method can be invoked only after
 * {@link #showAsDropDown(android.view.View)} has been executed. Failing
 * that, calling this method will have no effect.
 *
 * @see #showAsDropDown(android.view.View)
 */
",0,,,0,,,,,,,4,0,"The only change in the code is the addition of one new method call to 'unregisterBackCallback(decorView.findOnBackInvokedDispatcher())'. Since this new method call does not affect any return statements or exception handling, the code change type is 4.","There is no Compatibility Issue because the new method call does not change the APIâ€™s contract regarding its inputs, outputs, or exception handling. The API will behave identically with respect to user-defined behavior, and thus it does not introduce potential compatibility issues."
334,"<android.os.VibrationEffect: VibrationEffect createWaveform(long[],int[],int)>",32,33,,,,"{
    if (timings.length != amplitudes.length) {
        throw new IllegalArgumentException(""timing and amplitude arrays must be of equal length"" + "" (timings.length="" + timings.length + "", amplitudes.length="" + amplitudes.length + "")"");
    }
    List<StepSegment> segments = new ArrayList<>();
    for (int i = 0; i < timings.length; i++) {
        float parsedAmplitude = amplitudes[i] == DEFAULT_AMPLITUDE ? DEFAULT_AMPLITUDE : (float) amplitudes[i] / MAX_AMPLITUDE;
        segments.add(new StepSegment(parsedAmplitude, /* frequency= */
        0, (int) timings[i]));
    }
    VibrationEffect effect = new Composed(segments, repeat);
    effect.validate();
    return effect;
}","{
    if (timings.length != amplitudes.length) {
        throw new IllegalArgumentException(""timing and amplitude arrays must be of equal length"" + "" (timings.length="" + timings.length + "", amplitudes.length="" + amplitudes.length + "")"");
    }
    List<StepSegment> segments = new ArrayList<>();
    for (int i = 0; i < timings.length; i++) {
        float parsedAmplitude = amplitudes[i] == DEFAULT_AMPLITUDE ? DEFAULT_AMPLITUDE : (float) amplitudes[i] / MAX_AMPLITUDE;
        segments.add(new StepSegment(parsedAmplitude, /* frequencyHz= */
        0, (int) timings[i]));
    }
    VibrationEffect effect = new Composed(segments, repeat);
    effect.validate();
    return effect;
}",1,"/**
 * Create a waveform vibration.
 *
 * Waveform vibrations are a potentially repeating series of timing and amplitude pairs. For
 * each pair, the value in the amplitude array determines the strength of the vibration and the
 * value in the timing array determines how long it vibrates for, in milliseconds. Amplitude
 * values must be between 0 and 255, and an amplitude of 0 implies no vibration (i.e. off). Any
 * pairs with a timing value of 0 will be ignored.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the timings array at which to start the
 * repetition, or -1 to disable repeating.
 * </p>
 *
 * @param timings The timing values, in milliseconds, of the timing / amplitude pairs. Timing
 * values of 0 will cause the pair to be ignored.
 * @param amplitudes The amplitude values of the timing / amplitude pairs. Amplitude values
 * must be between 0 and 255, or equal to {@link #DEFAULT_AMPLITUDE}. An
 * amplitude value of 0 implies the motor is off.
 * @param repeat The index into the timings array at which to repeat, or -1 if you you don't
 * want to repeat.
 *
 * @return The desired effect.
 */
","/**
 * Create a waveform vibration.
 *
 * <p>Waveform vibrations are a potentially repeating series of timing and amplitude pairs,
 * provided in separate arrays. For each pair, the value in the amplitude array determines
 * the strength of the vibration and the value in the timing array determines how long it
 * vibrates for, in milliseconds.
 *
 * <p>To cause the pattern to repeat, pass the index into the timings array at which to start
 * the repetition, or -1 to disable repeating. Repeating effects will be played indefinitely
 * and should be cancelled via {@link Vibrator#cancel()}.
 *
 * @param timings The timing values, in milliseconds, of the timing / amplitude pairs. Timing
 * values of 0 will cause the pair to be ignored.
 * @param amplitudes The amplitude values of the timing / amplitude pairs. Amplitude values
 * must be between 0 and 255, or equal to {@link #DEFAULT_AMPLITUDE}. An
 * amplitude value of 0 implies the motor is off.
 * @param repeat The index into the timings array at which to repeat, or -1 if you don't
 * want to repeat indefinitely.
 *
 * @return The desired effect.
 */
",1,,,0,,,,,,,0,0,"There is no difference in the actual code implementation between the early and late versions, only a comment change within the code where ""frequency="" was changed to ""frequencyHz="". As comments do not affect the execution of the code, there is no change.","Since the code has not changed with respect to the functioning of the method, there is no compatibility issue introduced between the versions."
335,<android.inputmethodservice.InputMethodService.InputMethodImpl: void attachToken(IBinder)>,32,33,,,,"{
    if (mToken != null) {
        throw new IllegalStateException(""attachToken() must be called at most once. token="" + token);
    }
    attachToWindowToken(token);
    mToken = token;
    mWindow.setToken(token);
}","{
    if (mToken != null) {
        throw new IllegalStateException(""attachToken() must be called at most once. token="" + token);
    }
    attachToWindowToken(token);
    mToken = token;
    mWindow.setToken(token);
    if (mInkWindow != null) {
        mInkWindow.setToken(token);
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,"[@MainThread, @Override]","[@MainThread, @Override]",0,,,,,,,4,0,"The state change is the addition of a control dependency and a method call to setToken on mInkWindow, which is outside the control flow that could lead to return or throw statements. The code change type is 4.","Since the added statements only extend the behaviour of the method in a specific branch where `mInkWindow` is not null, without affecting the return value or exception handling of the method, there is no Compatibility Issue. The added code does not result in a different outcome in terms of exception thrown or the value returned by the method; it just affects state change that is invisible to the caller of `attachToken()`. Therefore, the CI type is 0."
337,<android.os.UserManager: boolean isUserAGoat()>,32,33,,,,"{
    if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R) {
        return false;
    }
    return mContext.getPackageManager().isPackageAvailable(""com.coffeestainstudios.goatsimulator"");
}","{
    if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R) {
        return false;
    }
    // can hold a different userId), but for R+ it returns false, so it doesn't matter anyway.
    return mContext.getPackageManager().isPackageAvailable(""com.coffeestainstudios.goatsimulator"");
}",1,"/**
 * Used to determine whether the user making this call is subject to
 * teleportations.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method can
 * now automatically identify goats using advanced goat recognition technology.</p>
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#R}, this method always returns
 * {@code false} in order to protect goat privacy.</p>
 *
 * @return Returns whether the user making this call is a goat.
 */
","/**
 * Used to determine whether the user making this call is subject to
 * teleportations.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method can
 * now automatically identify goats using advanced goat recognition technology.</p>
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#R}, this method always returns
 * {@code false} in order to protect goat privacy.</p>
 *
 * @return Returns whether the user making this call is a goat.
 */
",0,,[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU)],1,,,,,,,4,0,"A comment was added but the functional code remains the same, so the only code change type is 4 (Other statement changed).","The added comment does not affect the functionality or behavior of the method; hence, there is no Compatibility Issue."
338,<android.service.autofill.FillEventHistory.Event: String toString()>,32,33,,,,"{
    return ""FillEvent [datasetId="" + mDatasetId + "", type="" + mEventType + "", selectedDatasets="" + mSelectedDatasetIds + "", ignoredDatasetIds="" + mIgnoredDatasetIds + "", changedFieldIds="" + mChangedFieldIds + "", changedDatasetsIds="" + mChangedDatasetIds + "", manuallyFilledFieldIds="" + mManuallyFilledFieldIds + "", manuallyFilledDatasetIds="" + mManuallyFilledDatasetIds + "", detectedFieldIds="" + Arrays.toString(mDetectedFieldIds) + "", detectedFieldClassifications ="" + Arrays.toString(mDetectedFieldClassifications) + "", saveDialogNotShowReason="" + mSaveDialogNotShowReason + ""]"";
}","{
    return ""FillEvent [datasetId="" + mDatasetId + "", type="" + eventToString(mEventType) + "", uiType="" + uiTypeToString(mUiType) + "", selectedDatasets="" + mSelectedDatasetIds + "", ignoredDatasetIds="" + mIgnoredDatasetIds + "", changedFieldIds="" + mChangedFieldIds + "", changedDatasetsIds="" + mChangedDatasetIds + "", manuallyFilledFieldIds="" + mManuallyFilledFieldIds + "", manuallyFilledDatasetIds="" + mManuallyFilledDatasetIds + "", detectedFieldIds="" + Arrays.toString(mDetectedFieldIds) + "", detectedFieldClassifications ="" + Arrays.toString(mDetectedFieldClassifications) + "", saveDialogNotShowReason="" + mSaveDialogNotShowReason + ""]"";
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There are changes in the implementation where it shows that the method `eventToString(mEventType)` and `uiTypeToString(mUiType)` are now used for the `type` and `uiType` fields instead of directly appending `mEventType` and a new field `uiType`. There's no structural change that affects control flow, exception handling, or return statements; only changes in the string concatenation are notable. Hence, the code change type is 4.","There is no compatibility issue because the method still returns a `String` representation of the `FillEvent` object. The differences are purely in the details of the string, without affecting the ability to receive the string or causing exceptions. Thus, the result is 0 for no compatibility issue."
339,"<android.text.BoringLayout: BoringLayout replaceOrMake(CharSequence,TextPaint,int,Alignment,float,float,Metrics,boolean)>",32,33,,,,"{
    replaceWith(source, paint, outerwidth, align, spacingMult, spacingAdd);
    mEllipsizedWidth = outerwidth;
    mEllipsizedStart = 0;
    mEllipsizedCount = 0;
    init(source, paint, align, metrics, includePad, true);
    return this;
}","{
    replaceWith(source, paint, outerwidth, align, spacingMult, spacingAdd);
    mEllipsizedWidth = outerwidth;
    mEllipsizedStart = 0;
    mEllipsizedCount = 0;
    mUseFallbackLineSpacing = false;
    init(source, paint, align, metrics, includePad, true, false);
    return this;
}",1,"/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerwidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 */
","/**
 * Returns a BoringLayout for the specified text, potentially reusing
 * this one if it is already suitable.  The caller must make sure that
 * no one is still using this Layout.
 *
 * @param source the text to render
 * @param paint the default paint for the layout
 * @param outerwidth the wrapping width for the text
 * @param align whether to left, right, or center the text
 * @param spacingMult this value is no longer used by BoringLayout
 * @param spacingAdd this value is no longer used by BoringLayout
 * @param metrics {@code #Metrics} instance that contains information about FontMetrics and
 * line width
 * @param includePad set whether to include extra space beyond font ascent and descent which is
 * needed to avoid clipping in some scripts
 */
",0,,,0,,,,,,,"4,5",0,"The code change includes the addition of the line `mUseFallbackLineSpacing = false;` and an extra boolean parameter `false` passed to the `init()` method, which indicates changes that are neither control dependencies, return statements, nor exception handling, so the code change type is 4. The method signature for `init()` has also changed as it now includes an extra boolean parameter, which is a dependent API change, therefore, the change type is 5.","These changes do not seem to introduce a different return variable or change the exception handling behavior since they are internal state assignments and the initialization call is updated to match the new method signature of `init()`. The API continues returning `this` which is not affected by the change, hence, no Compatibility Issue (CI) is expected, hence the CI type is 0."
341,"<android.os.UserManager: CharSequence getBadgedLabelForUser(CharSequence,UserHandle)>",32,33,,,,"{
    final int userId = user.getIdentifier();
    if (!hasBadge(userId)) {
        return label;
    }
    try {
        final int resourceId = mService.getUserBadgeLabelResId(userId);
        return Resources.getSystem().getString(resourceId, label);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    final int userId = user.getIdentifier();
    if (!hasBadge(userId)) {
        return label;
    }
    DevicePolicyManager dpm = mContext.getSystemService(DevicePolicyManager.class);
    return dpm.getResources().getString(getUpdatableUserBadgedLabelId(userId), () -> getDefaultUserBadgedLabel(label, userId), /* formatArgs= */
    label);
}",1,"/**
 * If the target user is a profile of the calling user or the caller
 * is itself a profile, then this returns a copy of the label with
 * badging for accessibility services like talkback. E.g. passing in ""Email""
 * and it might return ""Work Email"" for Email in the work profile.
 *
 * <p>Requires {@link android.Manifest.permission#MANAGE_USERS} or
 * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission, otherwise the caller
 * must be in the same profile group of specified user.
 *
 * @param label The label to change.
 * @param user The target user.
 * @return A label that combines the original label and a badge as
 * determined by the system.
 * @removed
 */
","/**
 * If the target user is a profile of the calling user or the caller
 * is itself a profile, then this returns a copy of the label with
 * badging for accessibility services like talkback. E.g. passing in ""Email""
 * and it might return ""Work Email"" for Email in the work profile.
 *
 * <p>Requires {@link android.Manifest.permission#MANAGE_USERS} or
 * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission, otherwise the caller
 * must be in the same profile group of specified user.
 *
 * @param label The label to change.
 * @param user The target user.
 * @return A label that combines the original label and a badge as
 * determined by the system.
 * @removed
 */
",0,,,0,,,,,,,"1,3,4,5",1,"The implementation of getting the resource ID followed by obtaining the string has changed to using a DevicePolicyManager to get the resources and string directly with additional logic, involving lambda expression, so the change type is 1,3,4,5 because of new methods, removal of try-catch block, and the use of a lambda.","Since the way the badged label is created has fundamentally changed between versions, which includes new API calls and removal of a try-catch block for RemoteException handling, this will potentially lead to the method returning a different CharSequence object even for the same input parameters. Therefore, the CI type is 1."
342,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",32,33,,,,"{
    final View view;
    synchronized (mH) {
        view = getServedViewLocked();
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodDebug.startInputReasonToString(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    if (windowGainingFocus == null) {
        windowGainingFocus = view.getWindowToken();
        if (windowGainingFocus == null) {
            Log.e(TAG, ""ABORT input: ServedView must be attached to a Window"");
            return false;
        }
        startInputFlags = getStartInputFlags(view, startInputFlags);
        softInputMode = view.getViewRootImpl().mWindowAttributes.softInputMode;
        windowFlags = view.getViewRootImpl().mWindowAttributes.flags;
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> mDelegate.startInput(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.autofillId = view.getAutofillId();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    final Handler icHandler;
    InputBindResult res = null;
    synchronized (mH) {
        // Now that we are locked again, validate that our state hasn't
        // changed.
        final View servedView = getServedViewLocked();
        if (servedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" servedView="" + dumpViewInfo(servedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            startInputFlags |= StartInputFlags.INITIAL_CONNECTION;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        IInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new IInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this, view);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
            icHandler = null;
        }
        mServedInputConnectionWrapper = servedContext;
        if (DEBUG) {
            Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
        }
        try {
            res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, startInputFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        if (DEBUG)
            Log.v(TAG, ""Starting input: Bind result="" + res);
        if (res == null) {
            Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodDebug.startInputReasonToString(startInputReason) + "" editorInfo="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
            return false;
        }
        mIsInputMethodSuppressingSpellChecker = res.isInputMethodSuppressingSpellChecker;
        if (res.id != null) {
            setInputChannelLocked(res.channel);
            mBindSequence = res.sequence;
            // for @UnsupportedAppUsage
            mCurMethod = res.method;
            mCurrentInputMethodSession = InputMethodSessionWrapper.createOrNull(res.method);
            mCurId = res.id;
        } else if (res.channel != null && res.channel != mCurChannel) {
            res.channel.dispose();
        }
        switch(res.result) {
            case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                mRestartOnNextWindowFocus = true;
                break;
        }
        if (mCurrentInputMethodSession != null && mCompletions != null) {
            mCurrentInputMethodSession.displayCompletions(mCompletions);
        }
    }
    // Notify the app that the InputConnection is initialized and ready for use.
    if (ic != null && res != null && res.method != null) {
        if (DEBUG) {
            Log.v(TAG, ""Calling View.onInputConnectionOpened: view= "" + view + "", ic="" + ic + "", tba="" + tba + "", handler="" + icHandler);
        }
        view.onInputConnectionOpenedInternal(ic, tba, icHandler);
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = getServedViewLocked();
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodDebug.startInputReasonToString(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    if (windowGainingFocus == null) {
        windowGainingFocus = view.getWindowToken();
        if (windowGainingFocus == null) {
            Log.e(TAG, ""ABORT input: ServedView must be attached to a Window"");
            return false;
        }
        startInputFlags = getStartInputFlags(view, startInputFlags);
        softInputMode = view.getViewRootImpl().mWindowAttributes.softInputMode;
        windowFlags = view.getViewRootImpl().mWindowAttributes.flags;
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> mDelegate.startInput(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.autofillId = view.getAutofillId();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    final Handler icHandler;
    InputBindResult res = null;
    synchronized (mH) {
        // Now that we are locked again, validate that our state hasn't
        // changed.
        final View servedView = getServedViewLocked();
        if (servedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" servedView="" + dumpViewInfo(servedView) + "" mServedConnecting="" + mServedConnecting);
            if (mServedInputConnection != null && startInputReason == BOUND_TO_IMMS) {
                // This is not an error. Once IME binds (MSG_BIND), InputConnection is fully
                // established. So we report this to interested recipients.
                reportInputConnectionOpened(mServedInputConnection.getInputConnection(), mCurrentTextBoxAttribute, mServedInputConnectionHandler, view);
            }
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            startInputFlags |= StartInputFlags.INITIAL_CONNECTION;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba.createCopyInternal();
        mServedConnecting = false;
        if (mServedInputConnection != null) {
            mServedInputConnection.deactivate();
            mServedInputConnection = null;
            mServedInputConnectionHandler = null;
        }
        RemoteInputConnectionImpl servedInputConnection;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mInitialSelStart = mCursorSelStart;
            mInitialSelEnd = mCursorSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            Handler handler = null;
            try {
                handler = ic.getHandler();
            } catch (AbstractMethodError ignored) {
            // TODO(b/199934664): See if we can remove this by providing a default impl.
            }
            icHandler = handler;
            mServedInputConnectionHandler = icHandler;
            servedInputConnection = new RemoteInputConnectionImpl(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this, view);
        } else {
            servedInputConnection = null;
            icHandler = null;
            mServedInputConnectionHandler = null;
        }
        mServedInputConnection = servedInputConnection;
        if (DEBUG) {
            Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
        }
        try {
            res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, startInputFlags, softInputMode, windowFlags, tba, servedInputConnection, servedInputConnection == null ? null : servedInputConnection.asIRemoteAccessibilityInputConnection(), view.getContext().getApplicationInfo().targetSdkVersion, mImeDispatcher);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        if (DEBUG)
            Log.v(TAG, ""Starting input: Bind result="" + res);
        if (res == null) {
            Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodDebug.startInputReasonToString(startInputReason) + "" editorInfo="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
            return false;
        }
        mVirtualDisplayToScreenMatrix = res.getVirtualDisplayToScreenMatrix();
        mIsInputMethodSuppressingSpellChecker = res.isInputMethodSuppressingSpellChecker;
        if (res.id != null) {
            setInputChannelLocked(res.channel);
            mBindSequence = res.sequence;
            // for @UnsupportedAppUsage
            mCurMethod = res.method;
            mCurrentInputMethodSession = InputMethodSessionWrapper.createOrNull(res.method);
            mAccessibilityInputMethodSession.clear();
            if (res.accessibilitySessions != null) {
                for (int i = 0; i < res.accessibilitySessions.size(); i++) {
                    IAccessibilityInputMethodSessionInvoker wrapper = IAccessibilityInputMethodSessionInvoker.createOrNull(res.accessibilitySessions.valueAt(i));
                    if (wrapper != null) {
                        mAccessibilityInputMethodSession.append(res.accessibilitySessions.keyAt(i), wrapper);
                    }
                }
            }
            mCurId = res.id;
        } else if (res.channel != null && res.channel != mCurChannel) {
            res.channel.dispose();
        }
        switch(res.result) {
            case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                mRestartOnNextWindowFocus = true;
                break;
        }
        if (mCompletions != null) {
            if (mCurrentInputMethodSession != null) {
                mCurrentInputMethodSession.displayCompletions(mCompletions);
            }
        }
    }
    // Notify the app that the InputConnection is initialized and ready for use.
    if (ic != null && res != null && res.method != null) {
        if (DEBUG) {
            Log.v(TAG, ""Calling View.onInputConnectionOpened: view= "" + view + "", ic="" + ic + "", tba="" + tba + "", handler="" + icHandler);
        }
        reportInputConnectionOpened(ic, tba, icHandler, view);
    }
    return true;
}",1,"/**
 * Called when {@link DelegateImpl#startInput}, {@link #restartInput(View)},
 * {@link #MSG_BIND} or {@link #MSG_UNBIND}.
 * Note that this method should *NOT* be called inside of {@code mH} lock to prevent start input
 * background thread may blocked by other methods which already inside {@code mH} lock.
 */
","/**
 * Called when {@link DelegateImpl#startInput}, {@link #restartInput(View)},
 * {@link #MSG_BIND} or {@link #MSG_UNBIND}.
 * Note that this method should *NOT* be called inside of {@code mH} lock to prevent start input
 * background thread may blocked by other methods which already inside {@code mH} lock.
 */
",0,,,0,,,,,,,,,,
343,<android.content.pm.PackageInstaller.SessionInfo: boolean isStagedSessionReady()>,32,33,,,,"{
    checkSessionIsStaged();
    return isStagedSessionReady;
}","{
    checkSessionIsStaged();
    return isSessionReady;
}",1,"/**
 * Whether the staged session is ready to be applied at next reboot. Only meaningful if
 * {@code isStaged} is true.
 */
","/**
 * Whether the staged session is ready to be applied at next reboot. Only meaningful if
 * {@code isStaged} is true.
 */
",0,,,0,,,,,,,"1,5",1,"The return statement has changed from returning the boolean value isStagedSessionReady to returning the boolean value isSessionReady, which indicates a name change of a variable that affects the returned value, indicating a Dependent API changed as well. Therefore, the code change types are 1 and 5.","Because the return statement now yields a potentially different boolean value due to the variable name change, there is a potential Compatibility Issue due to a change in the returned value, which corresponds to CI type 1."
344,"<android.net.Ikev2VpnProfile.Builder: Builder setAuthUsernamePassword(String,String,X509Certificate)>",32,33,,,,"{
    checkNotNull(user, MISSING_PARAM_MSG_TMPL, ""user"");
    checkNotNull(pass, MISSING_PARAM_MSG_TMPL, ""pass"");
    // Test to make sure all auth params can be encoded safely.
    if (serverRootCa != null)
        checkCert(serverRootCa);
    resetAuthParams();
    mUsername = user;
    mPassword = pass;
    mServerRootCaCert = serverRootCa;
    mType = VpnProfile.TYPE_IKEV2_IPSEC_USER_PASS;
    return this;
}","{
    checkNotNull(user, MISSING_PARAM_MSG_TMPL, ""user"");
    checkNotNull(pass, MISSING_PARAM_MSG_TMPL, ""pass"");
    checkBuilderSetter(mIkeTunConnParams != null, ""authUsernamePassword"");
    // Test to make sure all auth params can be encoded safely.
    if (serverRootCa != null)
        checkCert(serverRootCa);
    resetAuthParams();
    mUsername = user;
    mPassword = pass;
    mServerRootCaCert = serverRootCa;
    mType = VpnProfile.TYPE_IKEV2_IPSEC_USER_PASS;
    return this;
}",1,"/**
 * Set the IKEv2 authentication to use the provided username/password.
 *
 * <p>Setting this will configure IKEv2 authentication using EAP-MSCHAPv2. Only one
 * authentication method may be set. This method will overwrite any previously set
 * authentication method.
 *
 * @param user the username to be used for EAP-MSCHAPv2 authentication
 * @param pass the password to be used for EAP-MSCHAPv2 authentication
 * @param serverRootCa the root certificate to be used for verifying the identity of the
 * server
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @throws IllegalArgumentException if any of the certificates were invalid or of an
 * unrecognized format
 */
","/**
 * Set the IKEv2 authentication to use the provided username/password.
 *
 * <p>Setting this will configure IKEv2 authentication using EAP-MSCHAPv2. Only one
 * authentication method may be set. This method will overwrite any previously set
 * authentication method.
 *
 * <p>If this {@link Builder} is constructed with an {@link IkeTunnelConnectionParams},
 * authentication details should be configured there, and calling this method will result
 * in an exception being thrown.
 *
 * @param user the username to be used for EAP-MSCHAPv2 authentication
 * @param pass the password to be used for EAP-MSCHAPv2 authentication
 * @param serverRootCa the root certificate to be used for verifying the identity of the
 * server
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @throws IllegalArgumentException if any of the certificates were invalid or of an
 * unrecognized format
 */
",1,"[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]","[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]",0,,,,,,,4,0,"An additional validation method 'checkBuilderSetter' is called with the conditions to check if 'mIkeTunConnParams' is not null. This is neither a change in the return statement, exception handling, control dependency, nor a dependent API change. It is an additional check introduced, hence classified as 'Other statement changed'.","The introduced check 'checkBuilderSetter(mIkeTunConnParams != null, ""authUsernamePassword"")' does not affect the return value or exceptions thrown under the precondition that 'mIkeTunConnParams' is correctly initialized before this method is called. Therefore, it is unlikely to lead to a Compatibility Issue and classified as 'No Compatibility Issue'."
345,<android.os.Parcel: T readParcelable(ClassLoader)>,32,33,,,,"{
    Parcelable.Creator<?> creator = readParcelableCreator(loader);
    if (creator == null) {
        return null;
    }
    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {
        Parcelable.ClassLoaderCreator<?> classLoaderCreator = (Parcelable.ClassLoaderCreator<?>) creator;
        return (T) classLoaderCreator.createFromParcel(this, loader);
    }
    return (T) creator.createFromParcel(this);
}","{
    return readParcelableInternal(loader, /* clazz */
    null);
}",1,"/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
","/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 *
 * @deprecated Use the type-safer version {@link #readParcelable(ClassLoader, Class)} starting
 * from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the format to
 * use {@link Parcelable.Creator#createFromParcel(Parcel)} if possible since this is also
 * more performant. Note that changing to the latter also requires changing the writes.
 */
",1,"[@SuppressWarnings(""unchecked""), @Nullable]","[@Deprecated, @Nullable]",1,,,,,,,"1,5",1,"The return statement has changed, with the new version using the function `readParcelableInternal` with different parameters, replacing all the previous logic. A dependent API change is also observed as the implementation now depends on this new `readParcelableInternal` method. The code change type is 1,5.","Since the logic to create a `Parcelable` object has been modified, it could potentially return different objects for the same input, leading to a different return value or type. Hence, the CI type is 1."
346,<android.app.Notification.CarExtender.UnreadConversation: UnreadConversation getUnreadConversationFromBundle(Bundle)>,32,33,,,,"{
    if (b == null) {
        return null;
    }
    Parcelable[] parcelableMessages = b.getParcelableArray(KEY_MESSAGES);
    String[] messages = null;
    if (parcelableMessages != null) {
        String[] tmp = new String[parcelableMessages.length];
        boolean success = true;
        for (int i = 0; i < tmp.length; i++) {
            if (!(parcelableMessages[i] instanceof Bundle)) {
                success = false;
                break;
            }
            tmp[i] = ((Bundle) parcelableMessages[i]).getString(KEY_TEXT);
            if (tmp[i] == null) {
                success = false;
                break;
            }
        }
        if (success) {
            messages = tmp;
        } else {
            return null;
        }
    }
    PendingIntent onRead = b.getParcelable(KEY_ON_READ);
    PendingIntent onReply = b.getParcelable(KEY_ON_REPLY);
    RemoteInput remoteInput = b.getParcelable(KEY_REMOTE_INPUT);
    String[] participants = b.getStringArray(KEY_PARTICIPANTS);
    if (participants == null || participants.length != 1) {
        return null;
    }
    return new UnreadConversation(messages, remoteInput, onReply, onRead, participants, b.getLong(KEY_TIMESTAMP));
}","{
    if (b == null) {
        return null;
    }
    Parcelable[] parcelableMessages = b.getParcelableArray(KEY_MESSAGES);
    String[] messages = null;
    if (parcelableMessages != null) {
        String[] tmp = new String[parcelableMessages.length];
        boolean success = true;
        for (int i = 0; i < tmp.length; i++) {
            if (!(parcelableMessages[i] instanceof Bundle)) {
                success = false;
                break;
            }
            tmp[i] = ((Bundle) parcelableMessages[i]).getString(KEY_TEXT);
            if (tmp[i] == null) {
                success = false;
                break;
            }
        }
        if (success) {
            messages = tmp;
        } else {
            return null;
        }
    }
    PendingIntent onRead = b.getParcelable(KEY_ON_READ, PendingIntent.class);
    PendingIntent onReply = b.getParcelable(KEY_ON_REPLY, PendingIntent.class);
    RemoteInput remoteInput = b.getParcelable(KEY_REMOTE_INPUT, RemoteInput.class);
    String[] participants = b.getStringArray(KEY_PARTICIPANTS);
    if (participants == null || participants.length != 1) {
        return null;
    }
    return new UnreadConversation(messages, remoteInput, onReply, onRead, participants, b.getLong(KEY_TIMESTAMP));
}",1,,,0,,,0,,,,,,,5,0,"The methods `getParcelable`, `getParcelableArray`, and `getLong` used in the early version are not altered in terms of their functionality but have an additional parameter for the class token added in the late version. So the code change type is 5, indicating a change in the dependent API.","Since the changes in the `getParcelable` method signatures include the addition of class tokens which merely enforce type safety and do not affect the behavior of the method, no difference in behavior is expected, thus there is no Compatibility Issue."
347,<android.os.storage.StorageVolume.Builder: StorageVolume build()>,32,33,,,,"{
    return new StorageVolume(mId, mPath, /* internalPath= */
    mPath, mDescription, mPrimary, mRemovable, mEmulated, /* allowMassStorage= */
    false, /* maxFileSize= */
    0, mOwner, mStorageUuid, mUuid, mState);
}","{
    return new StorageVolume(mId, mPath, /* internalPath= */
    mPath, mDescription, mPrimary, mRemovable, mEmulated, /* externallyManaged= */
    false, /* allowMassStorage= */
    false, /* maxFileSize= */
    0, mOwner, mStorageUuid, mUuid, mState);
}",1,,,0,[@NonNull],[@NonNull],0,,,,,,,4,0,"The implementation has added an extra parameter to the constructor of StorageVolume without changing the logic of build() method, also added parameter does not affect the behavior of the method as it is set to a constant value false, which won't lead to any different behaviors from this API, so the code change type is 4.","No Compatibility Issue arises since the new parameter (externallyManaged) is introduced with a fixed value of false, which does not alter the behavior for clients of the build() method that were compatible with the prior version. Hence, the values that are returned would remain consistent with previous expectations, not leading to a CI."
348,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",32,33,,,,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    // TODO(b/148086656): Disallow IME developers from calling InputMethodImpl methods.
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingShowSoftInput) {
        Log.e(TAG, "" IME shouldn't call showSoftInput on itself."" + "" Use requestShowSelf(int) itself"");
        return;
    }
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showSoftInput"");
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#showSoftInput"", InputMethodService.this, null);
    final boolean wasVisible = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        showWindow(true);
        applyVisibilityInInsetsConsumerIfNecessary(true);
    }
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    // TODO(b/148086656): Disallow IME developers from calling InputMethodImpl methods.
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingShowSoftInput) {
        Log.e(TAG, "" IME shouldn't call showSoftInput on itself."" + "" Use requestShowSelf(int) itself"");
        return;
    }
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showSoftInput"");
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#showSoftInput"", mDumper, null);
    final boolean wasVisible = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        showWindow(true);
    }
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,"[@MainThread, @Override]","[@MainThread, @Override]",0,,,,,,,4,0,"The method ImeTracing.getInstance().triggerServiceDump has changed its parameter from `InputMethodService.this` to `mDumper`, so there's a change in an ""other statement"", making the change type 4.","This change does not impact the control flow or result of the method, and it does not introduce or remove any exceptions. It's an internal change for tracing purposes, likely for debugging and logging. As such, it does not constitute a compatibility issue, so the CI type is 0."
349,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",32,33,,,,"{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    if (sensor == null) {
        // sensor disconnected
        return;
    }
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}","{
    final Sensor sensor = mManager.mHandleToSensor.get(handle);
    if (sensor == null) {
        // sensor disconnected
        return;
    }
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if (t.accuracy >= 0 && accuracy != t.accuracy) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    // Indicate if the discontinuity count changed
    if (t.sensor.getType() == Sensor.TYPE_HEAD_TRACKER) {
        final int lastCount = mSensorDiscontinuityCounts.get(handle);
        final int curCount = Float.floatToIntBits(values[6]);
        if (lastCount >= 0 && lastCount != curCount) {
            mSensorDiscontinuityCounts.put(handle, curCount);
            t.firstEventAfterDiscontinuity = true;
        }
    }
    mListener.onSensorChanged(t);
}",1,"// Called from native code.
","// Called from native code.
",0,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",0,,,,,,,"3,4",1,"There is a new if block added that checks for a specific sensor type and potentially modifies discontinuity counts, as well as setting a flag on the event. These changes are considered both a control dependency change (3) and other statement change (4), because they introduce new behavior based on the new conditions.","This new if block can change the behavior of the method by setting `t.firstEventAfterDiscontinuity` to true, which wasn't possible before, hence this change may lead to a different return value (actually a different event being returned), and the CI type is 1."
350,<android.service.autofill.FillRequest: String toString()>,32,33,,,,"{
    return ""FillRequest { "" + ""id = "" + mId + "", "" + ""fillContexts = "" + mFillContexts + "", "" + ""clientState = "" + mClientState + "", "" + ""flags = "" + requestFlagsToString(mFlags) + "", "" + ""inlineSuggestionsRequest = "" + mInlineSuggestionsRequest + "" }"";
}","{
    return ""FillRequest { "" + ""id = "" + mId + "", "" + ""fillContexts = "" + mFillContexts + "", "" + ""clientState = "" + mClientState + "", "" + ""flags = "" + requestFlagsToString(mFlags) + "", "" + ""inlineSuggestionsRequest = "" + mInlineSuggestionsRequest + "", "" + ""delayedFillIntentSender = "" + mDelayedFillIntentSender + "" }"";
}",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,,,,1,0,"The toString method's return value has been altered to include an additional field ""delayedFillIntentSender"", representing a change in the composition of the String returned by the method. This constitutes a change type of 1.","The change is adding additional information to the toString representation of the object, which doesn't alter the object's behavior or state. Thus, it doesn't introduce a Compatibility Issue, so the CI type is 0."
351,<android.app.ActivityThread.Idler: boolean queueIdle()>,32,33,,,,"{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        final ActivityClient ac = ActivityClient.getInstance();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                ac.activityIdle(a.token, a.createdConfig, stopProfiling);
                a.createdConfig = null;
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    applyPendingProcessState();
    return false;
}","{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        final ActivityClient ac = ActivityClient.getInstance();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                ac.activityIdle(a.token, a.createdConfig, stopProfiling);
                a.createdConfig = null;
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,0,0,There are no changes in the implementation between the early and late versions.,"Since no implementation changes were made, no Compatibility Issue could arise for the API."
352,<android.view.contentcapture.ContentCaptureSession: void notifyViewInsetsChanged(Insets)>,32,33,,,,"{
    Preconditions.checkNotNull(viewInsets);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewInsetsChanged(viewInsets);
}","{
    Objects.requireNonNull(viewInsets);
    if (!isContentCaptureEnabled())
        return;
    internalNotifyViewInsetsChanged(viewInsets);
}",1,"/**
 * Notifies the Intelligence Service that the insets of a view have changed.
 */
","/**
 * Notifies the Intelligence Service that the insets of a view have changed.
 */
",0,,,0,,,,,,,4,0,The only change in the code is the replacement of Preconditions.checkNotNull(viewInsets) with Objects.requireNonNull(viewInsets). This change does not affect the API's behavior since both methods serve the same purpose of checking for null pointers.,There is no Compatibility Issue since the functionality of the API remains the same before and after the change. Both methods throw a NullPointerException if the 'viewInsets' is null.
353,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: int hashCode()>,32,33,,,,"{
    return HashCodeHelpers.hashCode(mFormat, Boolean.hashCode(mIsInput), Boolean.hashCode(mIsUltraHighResolution), mAvailableSizes.hashCode());
}","{
    return HashCodeHelpers.hashCode(mFormat, Boolean.hashCode(mIsInput), Boolean.hashCode(mIsUltraHighResolution), mAvailableSizes.hashCode(), mStreamUseCase);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"There is an additional parameter included in the hashCode() method call (mStreamUseCase), so the code change type is 4 since it's a change in the implementation that is not related to return statement, exception handling, control dependency, or dependent API.","The change to an internal implementation detail of hashCode() does not result in a Compatibility Issue as per the definitions since the hashCode() method's contract only guarantees that the same object must return the same hash code within a single execution but does not guarantee any specific value. Thus, adding an additional parameter to the calculation does not inherently lead to a different behavior externally; it simply provides a potentially different hash code. The object's identity as itâ€™s conceived from a hash code perspective remains compliant with the general contract of hashCode(), so there is no CI."
355,<android.os.Bundle: ArrayList<T> getParcelableArrayList(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<T>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList"", e);
        return null;
    }
}","{
    unparcel();
    Object o = getValue(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<T>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList"", e);
        return null;
    }
}",1,"/**
 * Returns the value associated with the given key, or {@code null} if
 * no mapping of the desired type exists for the given key or a {@code null}
 * value is explicitly associated with the key.
 *
 * <p><b>Note: </b> if the expected value is not a class provided by the Android platform,
 * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.
 * Otherwise, this method might throw an exception or return {@code null}.
 *
 * @param key a String, or {@code null}
 * @return an ArrayList<T> value, or {@code null}
 */
","/**
 * Returns the value associated with the given key, or {@code null} if
 * no mapping of the desired type exists for the given key or a {@code null}
 * value is explicitly associated with the key.
 *
 * <p><b>Note: </b> if the expected value is not a class provided by the Android platform,
 * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.
 * Otherwise, this method might throw an exception or return {@code null}.
 *
 * @param key a String, or {@code null}
 * @return an ArrayList<T> value, or {@code null}
 *
 * @deprecated Use the type-safer {@link #getParcelable(String, Class)} starting from Android
 * {@link Build.VERSION_CODES#TIRAMISU}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"4,5",0,"The early implementation directly uses mMap.get(key) to retrieve the object, whereas the late implementation uses getValue(key), which is a change in how the value is obtained (method invocation change). Therefore, the changes are 4 (other statement changed) and 5 (dependent API changed, assuming getValue is a new or modified API within Bundle).","Although there is a change in the method used to retrieve the value associated with the key, as long as the semantic contract of getValue is to return the associated value in the same manner as mMap.get(key) would have, this change should not introduce any compatibility issue with respect to return values or exception handling behavior; the try-catch block remains the same and the condition checking for null is unchanged. Therefore, there is no compatibility issue, so the CI type is 0."
356,<android.content.pm.PackageInstaller.SessionInfo: boolean isStagedSessionApplied()>,32,33,,,,"{
    checkSessionIsStaged();
    return isStagedSessionApplied;
}","{
    checkSessionIsStaged();
    return isSessionApplied;
}",1,"/**
 * Whether the staged session has been applied successfully, meaning that all of its
 * packages have been activated and no further action is required.
 * Only meaningful if {@code isStaged} is true.
 */
","/**
 * Whether the staged session has been applied successfully, meaning that all of its
 * packages have been activated and no further action is required.
 * Only meaningful if {@code isStaged} is true.
 */
",0,,,0,,,,,,,"1,4",1,"The return statement has changed from using the variable isStagedSessionApplied to isSessionApplied, and the variable name used in the return statement has changed without any control dependency change, so the change type is 1,4.","This change in the return statement will potentially result in a different value being returned. Because the variable name has changed, it is likely that the underlying value it represents could also have changed, causing the API to behave differently, thus a CI type of 1 is detected."
357,"<android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo: CollectionItemInfo obtain(int,int,int,int,boolean,boolean)>",32,33,,,,"{
    final CollectionItemInfo info = sPool.acquire();
    if (info == null) {
        return new CollectionItemInfo(rowIndex, rowSpan, columnIndex, columnSpan, heading, selected);
    }
    info.mRowIndex = rowIndex;
    info.mRowSpan = rowSpan;
    info.mColumnIndex = columnIndex;
    info.mColumnSpan = columnSpan;
    info.mHeading = heading;
    info.mSelected = selected;
    return info;
}","{
    return new CollectionItemInfo(rowIndex, rowSpan, columnIndex, columnSpan, heading, selected);
}",1,"/**
 * Obtains a pooled instance.
 *
 * <p>In most situations object pooling is not beneficial. Creates a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionItemInfo#CollectionItemInfo(int,
 * int, int, int, boolean, boolean)} instead.
 *
 * @param rowIndex The row index at which the item is located.
 * @param rowSpan The number of rows the item spans.
 * @param columnIndex The column index at which the item is located.
 * @param columnSpan The number of columns the item spans.
 * @param heading Whether the item is a heading. (Prefer
 * {@link AccessibilityNodeInfo#setHeading(boolean)})
 * @param selected Whether the item is selected.
 */
","/**
 * Instantiates a new CollectionItemInfo.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionItemInfo#CollectionItemInfo(int,
 * int, int, int, boolean)} instead.
 * @param rowIndex The row index at which the item is located.
 * @param rowSpan The number of rows the item spans.
 * @param columnIndex The column index at which the item is located.
 * @param columnSpan The number of columns the item spans.
 * @param heading Whether the item is a heading. (Prefer
 * {@link AccessibilityNodeInfo#setHeading(boolean)}).
 * @param selected Whether the item is selected.
 */
",1,,[@Deprecated],1,,,,,,,"1,4",1,"There's a substantial restructuring of the method implementation where the early version acquires an object from a pool and mutates it if it's not null, or creates a new object if it is null, while the late version directly returns a new object. Object pool logic entirely removed. Also, the mutated instance return statement changed to a new instance return statement, so the change types are 1 and 4.","The change removes the reuse of pooled objects, which will change the return type from potentially a reused object to always a new instance. Thus, the API will now always return a newly created object, which is different from potentially returning a reused object in the early version. Hence, there is a compatibility issue caused by the potential difference in return values, which is of type 1."
358,<android.app.ActivityThread.H: String codeToString(int)>,32,33,,,,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PURGE_RESOURCES:
                return ""PURGE_RESOURCES"";
            case ATTACH_STARTUP_AGENTS:
                return ""ATTACH_STARTUP_AGENTS"";
            case UPDATE_UI_TRANSLATION_STATE:
                return ""UPDATE_UI_TRANSLATION_STATE"";
            case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
                return ""SET_CONTENT_CAPTURE_OPTIONS_CALLBACK"";
            case DUMP_GFXINFO:
                return ""DUMP GFXINFO"";
            case INSTRUMENT_WITHOUT_RESTART:
                return ""INSTRUMENT_WITHOUT_RESTART"";
            case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
                return ""FINISH_INSTRUMENTATION_WITHOUT_RESTART"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PURGE_RESOURCES:
                return ""PURGE_RESOURCES"";
            case ATTACH_STARTUP_AGENTS:
                return ""ATTACH_STARTUP_AGENTS"";
            case UPDATE_UI_TRANSLATION_STATE:
                return ""UPDATE_UI_TRANSLATION_STATE"";
            case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
                return ""SET_CONTENT_CAPTURE_OPTIONS_CALLBACK"";
            case DUMP_GFXINFO:
                return ""DUMP GFXINFO"";
            case INSTRUMENT_WITHOUT_RESTART:
                return ""INSTRUMENT_WITHOUT_RESTART"";
            case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
                return ""FINISH_INSTRUMENTATION_WITHOUT_RESTART"";
            case DUMP_RESOURCES:
                return ""DUMP_RESOURCES"";
        }
    }
    return Integer.toString(code);
}",1,,,0,,,0,,,,,,,,,,
359,<android.net.Ikev2VpnProfile: byte[] getPresharedKey()>,32,33,,,,"{
    return mPresharedKey == null ? null : Arrays.copyOf(mPresharedKey, mPresharedKey.length);
}","{
    if (mIkeTunConnParams != null)
        return null;
    return mPresharedKey == null ? null : Arrays.copyOf(mPresharedKey, mPresharedKey.length);
}",1,"/**
 * Retrieves the pre-shared key.
 *
 * <p>May be null if the profile is not using Pre-shared key authentication.
 */
","/**
 * Retrieves the pre-shared key.
 *
 * <p>May be null if the profile is not using Pre-shared key authentication, or the profile is
 * built from an {@link IkeTunnelConnectionParams}.
 */
",1,[@Nullable],[@Nullable],0,,,,,,,3,1,"An 'if' control structure is added to the code which could potentially change the flow and return a different result, so the code change type is 3.","The new 'if' statement that returns null if `mIkeTunConnParams` is not null introduces a change in behavior. The API may return null in a situation where previously it would have returned a copy of `mPresharedKey`, so the CI type is 1."
360,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain(AccessibilityEvent)>,32,33,,,,"{
    AccessibilityEvent eventClone = AccessibilityEvent.obtain();
    eventClone.init(event);
    return eventClone;
}","{
    AccessibilityEvent eventClone = new AccessibilityEvent();
    eventClone.init(event);
    return eventClone;
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * created. The returned instance is initialized from the given
 * <code>event</code>.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityEvent(AccessibilityEvent)} instead.
 *
 * @param event The other event.
 * @return An instance.
 */
","/**
 * Instantiates a new AccessibilityEvent instance.
 * The returned instance is initialized from the given
 * <code>event</code>.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityEvent()} instead.
 * @param event The other event.
 * @return An instance.
 */
",1,,[@Deprecated],1,,,,,,,"4,5",0,"The method used to create an `AccessibilityEvent` instance has changed from `AccessibilityEvent.obtain()` to `new AccessibilityEvent()`. Moreover, `AccessibilityEvent.obtain(AccessibilityEvent)` is now annotated as `@Deprecated`, which denotes a change in the dependent API used to obtain an `AccessibilityEvent` instance. The change type is 4 for other statement changed and 5 for dependent API changed.","The change from using `AccessibilityEvent.obtain()` to `new AccessibilityEvent()` is typically expected to return an identical `AccessibilityEvent` object in terms of behavior with `init(event)` properly initializing the object in the same manner for both methods. Also, the deprecation of an API does not affect the behavior of existing calls to that API, so this change does not lead to a compatibility issue, which is why the CI type is 0."
361,"<android.content.res.TypedArray: int getLayoutDimension(int,String)>",32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(getPositionDescription() + "": You must supply a "" + name + "" attribute."");
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value + "", theme="" + mTheme);
    }
    throw new UnsupportedOperationException(getPositionDescription() + "": You must supply a "" + name + "" attribute."" + "", theme="" + mTheme);
}",1,"/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */
","/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */
",0,,,0,,,,,,,4,0,"The code change involves appending additional context information to the message of the `UnsupportedOperationException` in different branches. This is an informational change rather than a functional one, so the code change type is 4.","There is no change in the returned value or exception handling in terms of logic that would affect the execution flow or outcomes of the method. The method's behavior remains consistent between versions despite the updated exception messages, so there is no compatibility issue, which corresponds to 0."
363,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,"[@Override, @Deprecated]","[@Override, @Deprecated]",0,,,,,,,4,0,"The change is in the parameter list of the method call to ActivityManager.getService().broadcastIntentWithFeature(), where the literal `AppOpsManager.OP_NONE` has been moved to a different position in the parameter list, and `null` is introduced in the place of `/*excludedPermissions=*/`. This change affects the method call but not the behavior of the method `sendStickyOrderedBroadcast()` itself, so the code change type is 4.","Since the changes in the parameters do not alter the control flow of the API or how it handles exceptions and it does not introduce changes in the value returned (which is void), no compatibility issue arises from this change. Hence, the CI type is 0."
364,<android.net.Ikev2VpnProfile.Builder: Ikev2VpnProfile build()>,32,33,,,,"{
    return new Ikev2VpnProfile(mType, mServerAddr, mUserIdentity, mPresharedKey, mServerRootCaCert, mUsername, mPassword, mRsaPrivateKey, mUserCert, mProxyInfo, mAllowedAlgorithms, mIsBypassable, mIsMetered, mMaxMtu, mIsRestrictedToTestNetworks);
}","{
    return new Ikev2VpnProfile(mType, mServerAddr, mUserIdentity, mPresharedKey, mServerRootCaCert, mUsername, mPassword, mRsaPrivateKey, mUserCert, mProxyInfo, mAllowedAlgorithms, mIsBypassable, mIsMetered, mMaxMtu, mIsRestrictedToTestNetworks, mExcludeLocalRoutes, mRequiresInternetValidation, mIkeTunConnParams);
}",1,"/**
 * Validates, builds and provisions the VpnProfile.
 *
 * @throws IllegalArgumentException if any of the required keys or values were invalid
 */
","/**
 * Validates, builds and provisions the VpnProfile.
 *
 * @throws IllegalArgumentException if any of the required keys or values were invalid
 */
",0,"[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]","[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]",0,,,,,,,"1,5",1,"The constructor call for Ikev2VpnProfile has added additional parameters (mExcludeLocalRoutes, mRequiresInternetValidation, mIkeTunConnParams) in the late version, indicating that there is a change in the dependent API (the constructor) with more parameters now being passed. This is an instance of both the return statement changing and the dependent API changing, therefore, the code change type is 1,5.","The addition of new parameters in the constructor call potentially changes the return value of the build() method because it is constructing an Ikev2VpnProfile with a different configuration. As a result, clients expecting the object returned by the previous configuration might experience issues, and hence the change raises a compatibility issue of type 1."
365,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",32,33,,,,"{
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel();
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // placeholder, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}","{
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel(/* itemwise */
        true);
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // placeholder, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",0,,,0,,,,,,,4,0,"There is a change in the parameter passed to the unparcel() method from no arguments to 'true'. This is considered as an Other statement changed, so the code change type is 4.","The change to pass 'true' as an argument does not alter the control flow or the outcome of the writeToParcelInner() therefore, it is unlikely to lead to a compatibility issue based on the information given. The behavior related to exceptions or return statements remain the same, and there is no indication that the dependent APIs behavior changed with regard to the parameters passed to them. Therefore, there is no compatibility issue."
368,<android.content.pm.ShortcutManager: Intent createShortcutResultIntent(ShortcutInfo)>,32,33,,,,"{
    try {
        return getFutureOrThrow(mService.createShortcutResultIntent(mContext.getPackageName(), shortcut, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    final AndroidFuture<Intent> ret = new AndroidFuture<>();
    try {
        mService.createShortcutResultIntent(mContext.getPackageName(), shortcut, injectMyUserId(), ret);
        return getFutureOrThrow(ret);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns an Intent which can be used by the default launcher to pin a shortcut containing the
 * given {@link ShortcutInfo}. This method should be used by an Activity to set a result in
 * response to {@link Intent#ACTION_CREATE_SHORTCUT}.
 *
 * @param shortcut New shortcut to pin.  If an app wants to pin an existing (either dynamic
 * or manifest) shortcut, then it only needs to have an ID, and other fields don't have to
 * be set, in which case, the target shortcut must be enabled.
 * If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @return The intent that should be set as the result for the calling activity, or
 * <code>null</code> if the current launcher doesn't support shortcuts.
 *
 * @see Intent#ACTION_CREATE_SHORTCUT
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 */
","/**
 * Returns an Intent which can be used by the default launcher to pin a shortcut containing the
 * given {@link ShortcutInfo}. This method should be used by an Activity to set a result in
 * response to {@link Intent#ACTION_CREATE_SHORTCUT}.
 *
 * @param shortcut New shortcut to pin.  If an app wants to pin an existing (either dynamic
 * or manifest) shortcut, then it only needs to have an ID, and other fields don't have to
 * be set, in which case, the target shortcut must be enabled.
 * If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @return The intent that should be set as the result for the calling activity, or
 * <code>null</code> if the current launcher doesn't support shortcuts.
 *
 * @see Intent#ACTION_CREATE_SHORTCUT
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 */
",0,[@WorkerThread],[@WorkerThread],0,,,,,,,"4,5",0,"The method invocation for creating the shortcut result intent within the try block has changed, it now involves using an AndroidFuture and an additional parameter in the method call, which is a change in the dependent API, so the code change type is 4,5.","Although the way the result is obtained has been altered (the method now uses an AndroidFuture object), the external behavior and the return type remains the same - an Intent. This change does not affect the return value of the method or the exceptions it may throw, so there is no Compatibility Issue."
370,<android.companion.CompanionDeviceManager: void requestNotificationAccess(ComponentName)>,32,33,,,,"{
    if (!checkFeaturePresent()) {
        return;
    }
    try {
        IntentSender intentSender = mService.requestNotificationAccess(component).getIntentSender();
        mContext.startIntentSender(intentSender, null, 0, 0, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (IntentSender.SendIntentException e) {
        throw new RuntimeException(e);
    }
}","{
    if (!checkFeaturePresent()) {
        return;
    }
    try {
        IntentSender intentSender = mService.requestNotificationAccess(component, mContext.getUserId()).getIntentSender();
        mContext.startIntentSender(intentSender, null, 0, 0, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (IntentSender.SendIntentException e) {
        throw new RuntimeException(e);
    }
}",1,"/**
 * Request notification access for the given component.
 *
 * The given component must follow the protocol specified in {@link NotificationListenerService}
 *
 * Only components from the same {@link ComponentName#getPackageName package} as the calling app
 * are allowed.
 *
 * Your app must have an association with a device before calling this API
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 */
","/**
 * Request notification access for the given component.
 *
 * The given component must follow the protocol specified in {@link NotificationListenerService}
 *
 * Only components from the same {@link ComponentName#getPackageName package} as the calling app
 * are allowed.
 *
 * Your app must have an association with a device before calling this API
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 */
",0,,[@UserHandleAware],1,,,,,,,5,0,"The dependent API call, `mService.requestNotificationAccess(component)`, has been changed to `mService.requestNotificationAccess(component, mContext.getUserId())` with an additional parameter. This is a change in the dependent API, hence the change type is 5.","The change in the dependent API call does not necessarily lead to a compatibility issue because the method's signature, return type, and exception handling have not been altered. The behavior of the API would change only if the additional parameter (`mContext.getUserId()`) affects the outcome, but this is an internal change and should not affect existing code that calls `requestNotificationAccess`. Thus, there is no compatibility issue; the CI type is 0."
371,<android.view.Display: void getRealMetrics(DisplayMetrics)>,32,33,,,,"{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (shouldReportMaxBounds()) {
            mDisplayInfo.getMaxBoundsMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, mResources.getConfiguration());
            if (DEBUG) {
                Log.d(TAG, ""getRealMetrics determined from max bounds: "" + outMetrics);
            }
            // should already reflect the expected rotation.
            return;
        }
        mDisplayInfo.getLogicalMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, null);
        if (mMayAdjustByFixedRotation) {
            getDisplayAdjustments().adjustMetrics(outMetrics, mDisplayInfo.rotation);
        }
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (shouldReportMaxBounds()) {
            mDisplayInfo.getMaxBoundsMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, mResources.getConfiguration());
            if (DEBUG) {
                Log.d(TAG, ""getRealMetrics determined from max bounds: "" + outMetrics);
            }
            // should already reflect the expected rotation.
            return;
        }
        mDisplayInfo.getLogicalMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, null);
        @Surface.Rotation final int rotation = getLocalRotation();
        if (rotation != mDisplayInfo.rotation) {
            adjustMetrics(outMetrics, mDisplayInfo.rotation, rotation);
        }
    }
}",1,"/**
 * Gets the size of the largest region of the display accessible to an app in the current system
 * state, without subtracting any window decor or applying scaling factors.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * <p></p>
 * The returned size will fall into one of these scenarios:
 * <ol>
 * <li>The device has no partitions on the display. The returned value is the largest region
 * of the display accessible to an app in the current system state, regardless of windowing
 * mode.</li>
 * <li>The device divides a single display into multiple partitions. An application is
 * restricted to a portion of the display. This is common in devices where the display changes
 * size, such as foldables or large screens. The returned size will match the portion of
 * the display the application is restricted to.</li>
 * <li>The window manager is emulating a different display size, using {@code adb shell wm
 * size}. The returned size will match the emulated display size.</li>
 * </ol>
 * </p><p>
 * The returned value is <b>unsuitable to use when sizing and placing UI elements</b>, since it
 * does not reflect the application window size in any of these scenarios.
 * {@link WindowManager#getCurrentWindowMetrics()} is an alternative that returns the size
 * of the current application window, even if the window is on a device with a partitioned
 * display. This helps prevent UI bugs where UI elements are misaligned or placed beyond the
 * bounds of the window.
 * <p></p>
 * Handling multi-window mode correctly is necessary since applications are not always
 * fullscreen. A user on a large screen device, such as a tablet or Chrome OS devices, is more
 * likely to use multi-window modes.
 * <p></p>
 * For example, consider a device with a display partitioned into two halves. The user may have
 * a fullscreen application open on the first partition. They may have two applications open in
 * split screen (an example of multi-window mode) on the second partition, with each application
 * consuming half of the partition. In this case,
 * {@link WindowManager#getCurrentWindowMetrics()} reports the fullscreen window is half of the
 * screen in size, and each split screen window is a quarter of the screen in size. On the other
 * hand, {@link #getRealMetrics} reports half of the screen size for all windows, since the
 * application windows are all restricted to their respective partitions.
 * </p>
 *
 * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.
 * @deprecated Use {@link WindowManager#getCurrentWindowMetrics()} to identify the current size
 * of the activity window. UI-related work, such as choosing UI layouts, should rely
 * upon {@link WindowMetrics#getBounds()}. Use {@link Configuration#densityDpi} to
 * get the current density.
 */
","/**
 * Gets the size of the largest region of the display accessible to an app in the current system
 * state, without subtracting any window decor or applying scaling factors.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * <p></p>
 * The returned size will fall into one of these scenarios:
 * <ol>
 * <li>The device has no partitions on the display. The returned value is the largest region
 * of the display accessible to an app in the current system state, regardless of windowing
 * mode.</li>
 * <li>The device divides a single display into multiple partitions. An application is
 * restricted to a portion of the display. This is common in devices where the display changes
 * size, such as foldables or large screens. The returned size will match the portion of
 * the display the application is restricted to.</li>
 * <li>The window manager is emulating a different display size, using {@code adb shell wm
 * size}. The returned size will match the emulated display size.</li>
 * </ol>
 * </p><p>
 * The returned value is <b>unsuitable to use when sizing and placing UI elements</b>, since it
 * does not reflect the application window size in any of these scenarios.
 * {@link WindowManager#getCurrentWindowMetrics()} is an alternative that returns the size
 * of the current application window, even if the window is on a device with a partitioned
 * display. This helps prevent UI bugs where UI elements are misaligned or placed beyond the
 * bounds of the window.
 * <p></p>
 * Handling multi-window mode correctly is necessary since applications are not always
 * fullscreen. A user on a large screen device, such as a tablet or Chrome OS devices, is more
 * likely to use multi-window modes.
 * <p></p>
 * For example, consider a device with a display partitioned into two halves. The user may have
 * a fullscreen application open on the first partition. They may have two applications open in
 * split screen (an example of multi-window mode) on the second partition, with each application
 * consuming half of the partition. In this case,
 * {@link WindowManager#getCurrentWindowMetrics()} reports the fullscreen window is half of the
 * screen in size, and each split screen window is a quarter of the screen in size. On the other
 * hand, {@link #getRealMetrics} reports half of the screen size for all windows, since the
 * application windows are all restricted to their respective partitions.
 * </p>
 *
 * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.
 * @deprecated Use {@link WindowManager#getCurrentWindowMetrics()} to identify the current size
 * of the activity window. UI-related work, such as choosing UI layouts, should rely
 * upon {@link WindowMetrics#getBounds()}. Use {@link Configuration#densityDpi} to
 * get the current density.
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,"3,4",0,"The code has been modified to retrieve the local rotation value using `getLocalRotation()` and it introduces new logic to compare `rotation` against `mDisplayInfo.rotation`. The adjustment is now made based on this comparison rather than `mMayAdjustByFixedRotation`. Therefore, the code change types are 3 for the control dependency change and 4 for other statement change (addition of a new variable declaration and updated logic in the if condition).","Although there is a change in the control dependency and other statements, this change does not introduce a Compatibility Issue. The method previously adjusted metrics only if `mMayAdjustByFixedRotation` was true, implying a situation that requires correction. In the late version, the adjustment is made based on an actual difference between the local rotation and `mDisplayInfo.rotation`, implying the same underlying condition for correction. The overall behavior of adjusting metrics only under certain conditions remains unchanged, so there is no change in the method's potential behavior regarding return values or exceptions, thus no Compatibility Issue."
372,<android.view.autofill.AutofillManager: void commit()>,32,33,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    if (sVerbose)
        Log.v(TAG, ""commit() called by app"");
    synchronized (mLock) {
        commitLocked();
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    if (sVerbose)
        Log.v(TAG, ""commit() called by app"");
    synchronized (mLock) {
        commitLocked(/* commitReason= */
        COMMIT_REASON_VIEW_COMMITTED);
    }
}",1,"/**
 * Called to indicate the current autofill context should be commited.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method after the form is submitted and
 * another page is rendered.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
","/**
 * Called to indicate the current autofill context should be commited.
 *
 * <p>This method is typically called by {@link View Views} that manage virtual views; for
 * example, when the view is rendering an {@code HTML} page with a form and virtual views
 * that represent the HTML elements, it should call this method after the form is submitted and
 * another page is rendered.
 *
 * <p><b>Note:</b> This method does not need to be called on regular application lifecycle
 * methods such as {@link android.app.Activity#finish()}.
 */
",0,,,0,,,,,,,"4,5",0,"There is an additional argument `COMMIT_REASON_VIEW_COMMITTED` provided to the `commitLocked` method call, but no other code has been changed, so the code change type is 4,5.","The addition of an argument to the `commitLocked` method implies that the method may use it for further processing, however, based on the information provided about the autofill manager's public API, this change does not indicate any compatibility issue because it does not change the return type, value, or exception handling from the perspective of the API's users; so, the CI type is 0."
373,"<android.service.wallpaper.WallpaperService.Engine: void updatePage(EngineWindowPage,int,int,float)>",32,33,,,,"{
    // to save creating a runnable, check twice
    long current = System.currentTimeMillis();
    long lapsed = current - currentPage.getLastUpdateTime();
    // This is important especially when the device first boots
    if (lapsed < DEFAULT_UPDATE_SCREENSHOT_DURATION && currentPage.getLastUpdateTime() > 0) {
        return;
    }
    Surface surface = mSurfaceHolder.getSurface();
    boolean widthIsLarger = mSurfaceSize.x > mSurfaceSize.y;
    int smaller = widthIsLarger ? mSurfaceSize.x : mSurfaceSize.y;
    float ratio = (float) MIN_BITMAP_SCREENSHOT_WIDTH / (float) smaller;
    int width = (int) (ratio * mSurfaceSize.x);
    int height = (int) (ratio * mSurfaceSize.y);
    if (width <= 0 || height <= 0) {
        Log.e(TAG, ""wrong width and height values of bitmap "" + width + "" "" + height);
        return;
    }
    Bitmap screenShot = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    final Bitmap finalScreenShot = screenShot;
    Trace.beginSection(""WallpaperService#pixelCopy"");
    PixelCopy.request(surface, screenShot, (res) -> {
        Trace.endSection();
        if (DEBUG)
            Log.d(TAG, ""result of pixel copy is "" + res);
        if (res != PixelCopy.SUCCESS) {
            Bitmap lastBitmap = currentPage.getBitmap();
            // assign the last bitmap taken for now
            currentPage.setBitmap(mLastScreenshot);
            Bitmap lastScreenshot = mLastScreenshot;
            if (lastScreenshot != null && !lastScreenshot.isRecycled() && !Objects.equals(lastBitmap, lastScreenshot)) {
                updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
            }
        } else {
            mLastScreenshot = finalScreenShot;
            // going to hold this lock for a while
            currentPage.setBitmap(finalScreenShot);
            currentPage.setLastUpdateTime(current);
            updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
        }
    }, mHandler);
}","{
    // in case the clock is zero, we start with negative time
    long current = SystemClock.elapsedRealtime() - DEFAULT_UPDATE_SCREENSHOT_DURATION;
    long lapsed = current - currentPage.getLastUpdateTime();
    // This is important especially when the device first boots
    if (lapsed < DEFAULT_UPDATE_SCREENSHOT_DURATION) {
        return;
    }
    Surface surface = mSurfaceHolder.getSurface();
    if (!surface.isValid())
        return;
    boolean widthIsLarger = mSurfaceSize.x > mSurfaceSize.y;
    int smaller = widthIsLarger ? mSurfaceSize.x : mSurfaceSize.y;
    float ratio = (float) MIN_BITMAP_SCREENSHOT_WIDTH / (float) smaller;
    int width = (int) (ratio * mSurfaceSize.x);
    int height = (int) (ratio * mSurfaceSize.y);
    if (width <= 0 || height <= 0) {
        Log.e(TAG, ""wrong width and height values of bitmap "" + width + "" "" + height);
        return;
    }
    Bitmap screenShot = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    final Bitmap finalScreenShot = screenShot;
    Trace.beginSection(""WallpaperService#pixelCopy"");
    PixelCopy.request(surface, screenShot, (res) -> {
        Trace.endSection();
        if (DEBUG)
            Log.d(TAG, ""result of pixel copy is "" + res);
        if (res != PixelCopy.SUCCESS) {
            Bitmap lastBitmap = currentPage.getBitmap();
            // assign the last bitmap taken for now
            currentPage.setBitmap(mLastScreenshot);
            Bitmap lastScreenshot = mLastScreenshot;
            if (lastScreenshot != null && !lastScreenshot.isRecycled() && !Objects.equals(lastBitmap, lastScreenshot)) {
                updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
            }
        } else {
            mLastScreenshot = finalScreenShot;
            // going to hold this lock for a while
            currentPage.setBitmap(finalScreenShot);
            currentPage.setLastUpdateTime(current);
            updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
        }
    }, mHandler);
}",1,,,0,,,0,,,,,,,"1,3,4",1,"The method to get the current time has changed from `System.currentTimeMillis()` to `SystemClock.elapsedRealtime() - DEFAULT_UPDATE_SCREENSHOT_DURATION`, and there is a new check `if (lapsed < DEFAULT_UPDATE_SCREENSHOT_DURATION)` in the Late_Version, also with addition of surface validity check `if (!surface.isValid())`. Moreover, the removal of the condition `currentPage.getLastUpdateTime() > 0` in the lapsed time check results in an ""Other statement changed"". These changes are types 1, 3, and 4.","There are potential Compatibility Issues caused by different return values due to the changes in time calculation and extra surface validity check. The modified elapsed time calculation and the removed check for last update time being more than zero might lead to different behavior under certain conditions. The introduction of a surface validity check might also lead to an early return in cases where this condition wouldn't be captured in the early_version. Thus, the CI type is 1."
374,<android.os.UserManager: boolean hasUserRestriction(String)>,32,33,,,,"{
    return hasUserRestrictionForUser(restrictionKey, Process.myUserHandle());
}","{
    return hasUserRestrictionForUser(restrictionKey, getContextUserIfAppropriate());
}",1,"/**
 * Returns whether the current user has been disallowed from performing certain actions
 * or setting certain settings.
 *
 * @param restrictionKey The string key representing the restriction.
 * @return {@code true} if the current user has the given restriction, {@code false} otherwise.
 */
","/**
 * Returns whether the context user has been disallowed from performing certain actions
 * or setting certain settings.
 *
 * @param restrictionKey The string key representing the restriction.
 * @return {@code true} if the context user has the given restriction, {@code false} otherwise.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCallerProfileGroup = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.INTERACT_ACROSS_USERS })]",1,,,,,,,5,0,"The change is in the parameter of the method 'hasUserRestrictionForUser'. In the latest version, it is calling 'getContextUserIfAppropriate()' instead of 'Process.myUserHandle()', which indicates that a dependent API has changed, hence the code change type is 5.","There is no Compatibility Issue because 'hasUserRestriction' is an API that should return consistent results based on user restrictions that apply to the current context (user). Either 'Process.myUserHandle()' or 'getContextUserIfAppropriate()' should both refer to the user context relevant for the API call, and the actual behavior of checking a user restriction should not change, so the CI type is 0."
375,<android.service.quicksettings.TileService: IBinder onBind(Intent)>,32,33,,,,"{
    mService = IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
    mTileToken = intent.getIBinderExtra(EXTRA_TOKEN);
    try {
        mTile = mService.getTile(mTileToken);
    } catch (RemoteException e) {
        throw new RuntimeException(""Unable to reach IQSService"", e);
    }
    if (mTile != null) {
        mTile.setService(mService, mTileToken);
        mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
    }
    return new IQSTileService.Stub() {

        @Override
        public void onTileRemoved() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
        }

        @Override
        public void onTileAdded() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
        }

        @Override
        public void onStopListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
        }

        @Override
        public void onStartListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
        }

        @Override
        public void onClick(IBinder wtoken) throws RemoteException {
            mHandler.obtainMessage(H.MSG_TILE_CLICKED, wtoken).sendToTarget();
        }

        @Override
        public void onUnlockComplete() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
        }
    };
}","{
    mService = IQSService.Stub.asInterface(intent.getIBinderExtra(EXTRA_SERVICE));
    mTileToken = intent.getIBinderExtra(EXTRA_TOKEN);
    try {
        mTile = mService.getTile(mTileToken);
    } catch (RemoteException e) {
        String name = TileService.this.getClass().getSimpleName();
        Log.w(TAG, name + "" - Couldn't get tile from IQSService."", e);
        // right after binding and therefore `mService` is outdated.
        return null;
    }
    if (mTile != null) {
        mTile.setService(mService, mTileToken);
        mHandler.sendEmptyMessage(H.MSG_START_SUCCESS);
    }
    return new IQSTileService.Stub() {

        @Override
        public void onTileRemoved() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_REMOVED);
        }

        @Override
        public void onTileAdded() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_TILE_ADDED);
        }

        @Override
        public void onStopListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_STOP_LISTENING);
        }

        @Override
        public void onStartListening() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_START_LISTENING);
        }

        @Override
        public void onClick(IBinder wtoken) throws RemoteException {
            mHandler.obtainMessage(H.MSG_TILE_CLICKED, wtoken).sendToTarget();
        }

        @Override
        public void onUnlockComplete() throws RemoteException {
            mHandler.sendEmptyMessage(H.MSG_UNLOCK_COMPLETE);
        }
    };
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,4",2,"The exception handling statement for RemoteException has changed. Instead of throwing a new RuntimeException, the late version logs the error and returns null. Another part of the code logs additional details about the exception, which is an 'Other statement changed' (change type 4).","As the change in exception handling potentially causes the late version of the API to return null instead of throwing an exception when a RemoteException occurs, this creates a CI because the method now has different exception handling behavior (CI type 2)."
377,"<android.hardware.camera2.CameraManager: void registerAvailabilityCallback(Executor,AvailabilityCallback)>",32,33,,,,"{
    if (executor == null) {
        throw new IllegalArgumentException(""executor was null"");
    }
    CameraManagerGlobal.get().registerAvailabilityCallback(callback, executor);
}","{
    if (executor == null) {
        throw new IllegalArgumentException(""executor was null"");
    }
    CameraManagerGlobal.get().registerAvailabilityCallback(callback, executor, mHasOpenCloseListenerPermission);
}",1,"/**
 * Register a callback to be notified about camera device availability.
 *
 * <p>The behavior of this method matches that of
 * {@link #registerAvailabilityCallback(AvailabilityCallback, Handler)},
 * except that it uses {@link java.util.concurrent.Executor} as an argument
 * instead of {@link android.os.Handler}.</p>
 *
 * @param executor The executor which will be used to invoke the callback.
 * @param callback the new callback to send camera availability notices to
 *
 * @throws IllegalArgumentException if the executor is {@code null}.
 */
","/**
 * Register a callback to be notified about camera device availability.
 *
 * <p>The behavior of this method matches that of
 * {@link #registerAvailabilityCallback(AvailabilityCallback, Handler)},
 * except that it uses {@link java.util.concurrent.Executor} as an argument
 * instead of {@link android.os.Handler}.</p>
 *
 * @param executor The executor which will be used to invoke the callback.
 * @param callback the new callback to send camera availability notices to
 *
 * @throws IllegalArgumentException if the executor is {@code null}.
 */
",0,,,0,,,,,,,5,0,"The implementation of 'registerAvailabilityCallback' now includes an additional parameter, mHasOpenCloseListenerPermission, which means that the dependent API 'registerAvailabilityCallback' of 'CameraManagerGlobal' has changed. Hence, the code change type is 5.","There is no compatibility issue because the change does not affect the values returned by the method (since it is a void method) nor the exceptions that are thrown. The method signature remains the same, thus external code invoking this method would not break due to this change. Hence, the CI type is 0."
378,<android.os.Parcel: IBinder readStrongBinder()>,32,33,,,,"{
    return nativeReadStrongBinder(mNativePtr);
}","{
    final IBinder result = nativeReadStrongBinder(mNativePtr);
    // from the object that returned it.
    if (result != null && hasFlags(FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT | FLAG_PROPAGATE_ALLOW_BLOCKING)) {
        Binder.allowBlocking(result);
    }
    return result;
}",1,"/**
 * Read an object from the parcel at the current dataPosition().
 */
","/**
 * Read an object from the parcel at the current dataPosition().
 */
",0,,,0,,,,,,,"1,3,4",1,"There is a new variable declaration introduced for holding the result of `nativeReadStrongBinder`, additional logic to invoke `Binder.allowBlocking(result)` if certain conditions are met, and a return statement now returns the newly introduced variable. Thus the changes include a return statement change, a control dependency change, and other statement changes, which correspond to codes 1, 3, and 4.","Due to the additional if statement with the call to `Binder.allowBlocking(result)`, it's possible that the `IBinder` returned has different behavior compared to the earlier version (since it may be marked to allow blocking). Thus, this change could lead to compatibility issues due to potentially different return values or types, which corresponds to CI type 1."
382,<android.service.autofill.FillResponse: String toString()>,32,33,,,,"{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mInlineTooltipPresentation != null) {
        builder.append("", hasInlineTooltipPresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    if (mUserData != null) {
        builder.append("", userData="").append(mUserData);
    }
    if (mCancelIds != null) {
        builder.append("", mCancelIds="").append(mCancelIds.length);
    }
    builder.append("", mSupportInlinePresentations="").append(mSupportsInlineSuggestions);
    return builder.append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mInlineTooltipPresentation != null) {
        builder.append("", hasInlineTooltipPresentation"");
    }
    if (mDialogPresentation != null) {
        builder.append("", hasDialogPresentation"");
    }
    if (mDialogHeader != null) {
        builder.append("", hasDialogHeader"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    if (mFillDialogTriggerIds != null) {
        builder.append("", fillDialogTriggerIds="").append(Arrays.toString(mFillDialogTriggerIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    if (mUserData != null) {
        builder.append("", userData="").append(mUserData);
    }
    if (mCancelIds != null) {
        builder.append("", mCancelIds="").append(mCancelIds.length);
    }
    builder.append("", mSupportInlinePresentations="").append(mSupportsInlineSuggestions);
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",0,[@Override],[@Override],0,,,,,,,4,0,"The late implementation introduces new fields to the string builder (mDialogPresentation, mDialogHeader, mFillDialogTriggerIds) and removes fields (mHeader, mFooter). This constitutes an ""Other statement changed"" because it's an addition and removal of some string parts in the toString method but it does not affect the behavior or control flow of the method.","There is no Compatibility Issue as the toString method is meant to provide a string representation of the object for debugging or logging. The changes in the fields that are included in the string do not alter the fundamental behavior, semantics, or contract of the method. Clients calling this method should expect that the output can change between versions as it is for human-readable output and not for programmatic checks."
383,<android.hardware.camera2.utils.SurfaceUtils: boolean isSurfaceForHwVideoEncoder(Surface)>,32,33,,,,"{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | USAGE_HW_COMPOSER | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE;
    boolean videoEncoderConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return videoEncoderConsumer;
}","{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = USAGE_HW_COMPOSER | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE;
    boolean videoEncoderConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return videoEncoderConsumer;
}",1,"/**
 * Check if the surface is for hardware video encoder consumer based on consumer end point
 * Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for hardware video encoder consumer, false otherwise.
 */
","/**
 * Check if the surface is for hardware video encoder consumer based on consumer end point
 * Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for hardware video encoder consumer, false otherwise.
 */
",0,,,0,,,,,,,4,0,"The variable `disallowedFlags` has been altered by the removal of `HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE`. The modification does not involve control dependency changes, return statements, exception handling changes, or dependent APIs, so the change type is 4.","Despite the change in the `disallowedFlags`, which effectively modifies the flags that are considered disallowed for the purpose of this method, this alteration does not lead to a different behavior in terms of what this API returns or the exceptions that it might throw. The boolean result `videoEncoderConsumer` will still be the result of the same logical condition, albeit with one less flag to consider in the disallowed category. This does not inherently create a compatibility issue because the same logical process for determining `videoEncoderConsumer` is used and no new code paths or outcomes are introduced. Consequently, the CI type is 0."
384,<android.content.pm.ShortcutManager: void pushDynamicShortcut(ShortcutInfo)>,32,33,,,,"{
    try {
        getFutureOrThrow(mService.pushDynamicShortcut(mContext.getPackageName(), shortcut, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        mService.pushDynamicShortcut(mContext.getPackageName(), shortcut, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Publish a single dynamic shortcut. If there are already dynamic or pinned shortcuts with the
 * same ID, each mutable shortcut is updated.
 *
 * <p>This method is useful when posting notifications which are tagged with shortcut IDs; In
 * order to make sure shortcuts exist and are up-to-date, without the need to explicitly handle
 * the shortcut count limit.
 * @see android.app.NotificationManager#notify(int, Notification)
 * @see Notification.Builder#setShortcutId(String)
 *
 * <p>If {@link #getMaxShortcutCountPerActivity()} is already reached, an existing shortcut with
 * the lowest rank will be removed to add space for the new shortcut.
 *
 * <p>If the rank of the shortcut is not explicitly set, it will be set to zero, and shortcut
 * will be added to the top of the list.
 *
 * @throws IllegalArgumentException if trying to update an immutable shortcut.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish a single dynamic shortcut. If there are already dynamic or pinned shortcuts with the
 * same ID, each mutable shortcut is updated.
 *
 * <p>This method is useful when posting notifications which are tagged with shortcut IDs; In
 * order to make sure shortcuts exist and are up-to-date, without the need to explicitly handle
 * the shortcut count limit.
 * @see android.app.NotificationManager#notify(int, Notification)
 * @see android.app.Notification.Builder#setShortcutId(String)
 *
 * <p>If {@link #getMaxShortcutCountPerActivity()} is already reached, an existing shortcut with
 * the lowest rank will be removed to add space for the new shortcut.
 *
 * <p>If the rank of the shortcut is not explicitly set, it will be set to zero, and shortcut
 * will be added to the top of the list.
 *
 * @throws IllegalArgumentException if trying to update an immutable shortcut.
 *
 * @throws IllegalStateException when the user is locked.
 */
",1,,,0,,,,,,,4,0,"The method call in the early version has ""getFutureOrThrow()"" wrapped around the ""mService.pushDynamicShortcut()"" which is removed in the late version. This indicates the removal of a wrapper that potentially dealt with asynchronous execution and exception handling, so there is an ""Other statement changed"", which corresponds to a change of type 4.","The removal of ""getFutureOrThrow()"" does not inherently suggest that the return behavior or exceptions thrown by the method directly affected by ""pushDynamicShortcut()"" has changed, given that the external behavior of the API should remain the same (it still throws a RemoteException that is rethrown as a system server error). Assuming ""getFutureOrThrow()"" does not change the semantics of the call itself, there does not appear to be a Compatibility Issue, hence, it is coded as 0."
385,"<android.content.pm.LauncherApps: List<ShortcutInfo> getShortcuts(ShortcutQuery,UserHandle)>",32,33,,,,"{
    logErrorForInvalidProfileAccess(user);
    try {
        // that won't return disabled message.
        return maybeUpdateDisabledMessage(mService.getShortcuts(mContext.getPackageName(), new ShortcutQueryWrapper(query), user).getList());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        if ((query.mQueryFlags & ShortcutQuery.FLAG_GET_PERSISTED_DATA) != 0) {
            return getShortcutsBlocked(query, user);
        }
        // that won't return disabled message.
        return maybeUpdateDisabledMessage(mService.getShortcuts(mContext.getPackageName(), new ShortcutQueryWrapper(query), user).getList());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
","/**
 * Returns {@link ShortcutInfo}s that match {@code query}.
 *
 * <p>Callers must be allowed to access the shortcut information, as defined in {@link
 * #hasShortcutHostPermission()}.
 *
 * @param query result includes shortcuts matching this query.
 * @param user The UserHandle of the profile.
 *
 * @return the IDs of {@link ShortcutInfo}s that match the query.
 * @throws IllegalStateException when the user is locked, or when the {@code user} user
 * is locked or not running.
 *
 * @see ShortcutManager
 */
",0,[@Nullable],[@Nullable],0,,,,,,,3,1,"The late version introduces a new control dependency (`if` statement) that changes the flow of code by introducing a new path (`return getShortcutsBlocked(query, user)`), so the code change type is 3.","Since there is a new condition introduced that potentially returns a different list of shortcuts based on a new criterion (checking for the FLAG_GET_PERSISTED_DATA flag), this could lead to the API returning different values. Therefore, the CI type is 1."
386,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,32,33,,,,"{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + (mRunCalled ? "", run() has already been called"" : """"));
        }
        mCurIntent = null;
        mDispatched = true;
        mRunCalled = true;
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            // TODO: determine at registration time if caller is
            // protecting themselves with signature permission
            intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource());
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}","{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + (mRunCalled ? "", run() has already been called"" : """"));
        }
        mCurIntent = null;
        mDispatched = true;
        mRunCalled = true;
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg: "" + intent.getAction());
        }
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            // TODO: determine at registration time if caller is
            // protecting themselves with signature permission
            intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource());
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}",1,,,0,,,0,,,,,,,,,,
389,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",32,33,,,,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
    dest.writeString(mPhysicalCameraId);
    dest.writeInt(mIsMultiResolution ? 1 : 0);
    // writeList doesn't seem to work well with Integer list.
    dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed));
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
    dest.writeString(mPhysicalCameraId);
    dest.writeInt(mIsMultiResolution ? 1 : 0);
    // writeList doesn't seem to work well with Integer list.
    dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed));
    dest.writeLong(mDynamicRangeProfile);
    dest.writeLong(mStreamUseCase);
    dest.writeInt(mTimestampBase);
    dest.writeInt(mMirrorMode);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,1,"New lines of code have been added that write additional data to the Parcel, so the change type is 4.","Since new data fields are written to the Parcel that were not written in the earlier version, the parcelled data structure will now be different when the method is called, which may affect the behavior if the receiving end is expecting a different parcel structure. Therefore, this constitutes a CI of type 1."
390,<android.os.DropBoxManager.Entry: InputStream getInputStream()>,32,33,,,,"{
    InputStream is;
    if (mData != null) {
        is = new ByteArrayInputStream(mData);
    } else if (mFileDescriptor != null) {
        is = new ParcelFileDescriptor.AutoCloseInputStream(mFileDescriptor);
    } else {
        return null;
    }
    return (mFlags & IS_GZIPPED) != 0 ? new GZIPInputStream(is) : is;
}","{
    InputStream is;
    if (mData != null) {
        is = new ByteArrayInputStream(mData);
    } else if (mFileDescriptor != null) {
        is = new ParcelFileDescriptor.AutoCloseInputStream(mFileDescriptor);
    } else {
        return null;
    }
    return (mFlags & IS_GZIPPED) != 0 ? new GZIPInputStream(new BufferedInputStream(is)) : is;
}",1,"/**
 * @return the uncompressed contents of the entry, or null if the contents were lost
 */
","/**
 * @return the uncompressed contents of the entry, or null if the contents were lost
 */
",0,[@Nullable],[@Nullable],0,,,,,,,4,0,"The only change in the implementation is the addition of a new `BufferedInputStream(is)` wrapper around the `InputStream` object in case the `IS_GZIPPED` flag is set. Since this is neither a return statement change, an exception handling statement change, nor a control dependency change, this falls under the category of 'Other statement changed'.","The change does not lead to a Compatibility Issue since the return type (`InputStream`) remains the same, and no new exceptions are thrown or handled differently. The behavior of the method is functionally consistent. Wrapping the `InputStream` with a `BufferedInputStream` should not affect existing clients assuming they handle `InputStream` correctly. The addition of the buffered layer is an internal detail and should not affect the API contract specified by the `@Nullable` annotation. Therefore, there is no Compatibility Issue."
391,<android.provider.CallLog.AddCallParams.AddCallParametersBuilder: AddCallParams build()>,32,33,,,,"{
    return new AddCallParams(mCallerInfo, mNumber, mPostDialDigits, mViaNumber, mPresentation, mCallType, mFeatures, mAccountHandle, mStart, mDuration, mDataUsage, mAddForAllUsers, mUserToBeInsertedTo, mIsRead, mCallBlockReason, mCallScreeningAppName, mCallScreeningComponentName, mMissedReason, mPriority, mSubject, mLatitude, mLongitude, mPictureUri);
}","{
    return new AddCallParams(mCallerInfo, mNumber, mPostDialDigits, mViaNumber, mPresentation, mCallType, mFeatures, mAccountHandle, mStart, mDuration, mDataUsage, mAddForAllUsers, mUserToBeInsertedTo, mIsRead, mCallBlockReason, mCallScreeningAppName, mCallScreeningComponentName, mMissedReason, mPriority, mSubject, mLatitude, mLongitude, mPictureUri, mIsPhoneAccountMigrationPending);
}",1,"/**
 * Builds the object
 */
","/**
 * Builds the object
 */
",0,[@NonNull],[@NonNull],0,,,,,,,1,1,"The return statement's constructor call has been changed with a new parameter (mIsPhoneAccountMigrationPending) added at the end. Therefore, the object created and returned by this method could be different in its behavior or characteristics. Hence, the code change type is 1.","The addition of a new parameter to the constructor call means that the method now potentially returns a different object with additional state, which constitutes a Compatibility Issue (type 1). The new object can behave differently due to the additional information it carries, thus potentially affecting any code that relies on the returned object's state."
393,<android.text.PrecomputedText.Params: int hashCode()>,32,33,,,,"{
    // TODO: implement MinikinPaint::hashCode and use it to keep consistency with equals.
    return Objects.hash(mPaint.getTextSize(), mPaint.getTextScaleX(), mPaint.getTextSkewX(), mPaint.getLetterSpacing(), mPaint.getWordSpacing(), mPaint.getFlags(), mPaint.getTextLocales(), mPaint.getTypeface(), mPaint.getFontVariationSettings(), mPaint.isElegantTextHeight(), mTextDir, mBreakStrategy, mHyphenationFrequency);
}","{
    // TODO: implement MinikinPaint::hashCode and use it to keep consistency with equals.
    int lineBreakStyle = (mLineBreakConfig != null) ? mLineBreakConfig.getLineBreakStyle() : LineBreakConfig.LINE_BREAK_STYLE_NONE;
    return Objects.hash(mPaint.getTextSize(), mPaint.getTextScaleX(), mPaint.getTextSkewX(), mPaint.getLetterSpacing(), mPaint.getWordSpacing(), mPaint.getFlags(), mPaint.getTextLocales(), mPaint.getTypeface(), mPaint.getFontVariationSettings(), mPaint.isElegantTextHeight(), mTextDir, mBreakStrategy, mHyphenationFrequency, lineBreakStyle);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The hashCode method now includes an additional variable 'lineBreakStyle' in the Objects.hash call in the late version, and it also includes the conditional operator for the calculation of 'lineBreakStyle'. This is a change in the return statement as well as another statement (inclusion of a new variable), so the code change type is 1,4.","The inclusion of the new 'lineBreakStyle' will make the API potentially return a different value, and this is a difference in the calculation of the hash, so the CI type is 1."
394,<android.app.PictureInPictureParams: int hashCode()>,32,33,,,,"{
    return Objects.hash(mAspectRatio, mUserActions, mSourceRectHint, mAutoEnterEnabled, mSeamlessResizeEnabled);
}","{
    return Objects.hash(mAspectRatio, mExpandedAspectRatio, mUserActions, mCloseAction, mSourceRectHint, mAutoEnterEnabled, mSeamlessResizeEnabled, mTitle, mSubtitle, mIsLaunchIntoPip);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The `hashCode()` method is modified to include additional parameters in the `Objects.hash()` call, this is a change of the method body that is not related to control structures or exception handling but alters the computation of the hash value, so the code change type is 1,4.","Since the returned hash code is different due to the inclusion of new fields in the computation (mExpandedAspectRatio, mCloseAction, mTitle, mSubtitle, mIsLaunchIntoPip), this will cause the API to return a different value. Therefore, the CI type is 1."
395,<android.os.UserManager: String getUserName()>,32,33,,,,"{
    if (UserHandle.myUserId() == mUserId) {
        try {
            return mService.getUserName();
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    } else {
        UserInfo userInfo = getUserInfo(mUserId);
        return userInfo == null ? """" : userInfo.name;
    }
}","{
    if (UserHandle.myUserId() == mUserId) {
        try {
            return mService.getUserName();
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    } else {
        UserInfo userInfo = getUserInfo(mUserId);
        if (userInfo != null && userInfo.name != null) {
            return userInfo.name;
        }
        return """";
    }
}",1,"/**
 * Returns the user name of the context user. This call is only available to applications on
 * the system image; it requires the {@code android.permission.MANAGE_USERS} or {@code
 * android.permission.GET_ACCOUNTS_PRIVILEGED} permissions.
 *
 * @return the user name
 */
","/**
 * Returns the user name of the context user. This call is only available to applications on
 * the system image.
 *
 * @return the user name
 */
",1,"[@RequiresPermission(anyOf = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.GET_ACCOUNTS_PRIVILEGED, android.Manifest.permission.CREATE_USERS }, conditional = true), @UserHandleAware, @NonNull]","[@RequiresPermission(anyOf = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.CREATE_USERS, android.Manifest.permission.QUERY_USERS, android.Manifest.permission.GET_ACCOUNTS_PRIVILEGED }), @UserHandleAware(requiresAnyOfPermissionsIfNotCaller = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.CREATE_USERS, android.Manifest.permission.QUERY_USERS }), @NonNull]",1,,,,,,,"3,4",0,"The condition for the 'return' statement has been expanded to check not only if userInfo is null but also if userInfo.name is not null. Additionally, an unnecessary 'else' statement is removed since it is redudant but it does not affect the API's behavior. Therefore, the code change types are 3 (control dependency changed) and 4 (other statement changed).","There is no CI because the logic of the program is maintained, and the method returns the same values as before in the corresponding situations. The additional null check for userInfo.name ensures that a null name is treated the same as userInfo being null, returning an empty string. It's an additional safety check rather than a change in behavior."
396,<android.view.SurfaceControlViewHost: SurfacePackage getSurfacePackage()>,32,33,,,,"{
    if (mSurfaceControl != null && mAccessibilityEmbeddedConnection != null) {
        return new SurfacePackage(mSurfaceControl, mAccessibilityEmbeddedConnection, mViewRoot.getInputToken());
    } else {
        return null;
    }
}","{
    if (mSurfaceControl != null && mAccessibilityEmbeddedConnection != null) {
        return new SurfacePackage(new SurfaceControl(mSurfaceControl, ""getSurfacePackage""), mAccessibilityEmbeddedConnection, mWm.getFocusGrantToken(), mRemoteInterface);
    } else {
        return null;
    }
}",1,"/**
 * Return a SurfacePackage for the root SurfaceControl of the embedded hierarchy.
 * Rather than be directly reparented using {@link SurfaceControl.Transaction} this
 * SurfacePackage should be passed to {@link SurfaceView#setChildSurfacePackage}
 * which will not only reparent the Surface, but ensure the accessibility hierarchies
 * are linked.
 */
","/**
 * Return a SurfacePackage for the root SurfaceControl of the embedded hierarchy.
 * Rather than be directly reparented using {@link SurfaceControl.Transaction} this
 * SurfacePackage should be passed to {@link SurfaceView#setChildSurfacePackage}
 * which will not only reparent the Surface, but ensure the accessibility hierarchies
 * are linked.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,"1,4,5",1,"The return statement has been changed with a different constructor for `SurfacePackage`, which has more parameters in the late implementation. There is also the creation of a new `SurfaceControl` object within the return statement. This indicates changes in the returned value and the construction process (using a different constructor), and it involves the dependent API `SurfaceControl`'s constructor. So, the change types are 1 for the return statements, 4 for other statement changes, and 5 for the dependent API change.","Since the constructor for `SurfacePackage` being called has changed, and it now uses a new `SurfaceControl` object with a string tag and more parameters, the method will potentially return an object with different state or behavior. This constitutes a compatibility issue due to potential different return values or types, so the CI type is 1."
397,<android.app.PictureInPictureParams: String toString()>,32,33,,,,"{
    return ""PictureInPictureParams("" + "" aspectRatio="" + getAspectRatioRational() + "" sourceRectHint="" + getSourceRectHint() + "" hasSetActions="" + hasSetActions() + "" isAutoPipEnabled="" + isAutoEnterEnabled() + "" isSeamlessResizeEnabled="" + isSeamlessResizeEnabled() + "")"";
}","{
    return ""PictureInPictureParams("" + "" aspectRatio="" + getAspectRatio() + "" expandedAspectRatio="" + mExpandedAspectRatio + "" sourceRectHint="" + getSourceRectHint() + "" hasSetActions="" + hasSetActions() + "" hasSetCloseAction="" + hasSetCloseAction() + "" isAutoPipEnabled="" + isAutoEnterEnabled() + "" isSeamlessResizeEnabled="" + isSeamlessResizeEnabled() + "" title="" + getTitle() + "" subtitle="" + getSubtitle() + "" isLaunchIntoPip="" + isLaunchIntoPip() + "")"";
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"The 'toString()' method implementation is changed with new concatenation for string building (e.g., changing getAspectRatioRational() to getAspectRatio(), addition of mExpandedAspectRatio, hasSetCloseAction(), getTitle(), getSubtitle(), and isLaunchIntoPip()), resulting in a change type 1,4.","The changes in the method's return statement will cause the 'toString()' method to return a different string value, indicating a change in the output format, hence the CI type is 1."
398,<android.view.WindowInsets: Insets getStableInsets()>,32,33,,,,"{
    return getInsets(mTypeMaxInsetsMap, mCompatInsetsTypes);
}","{
    return getInsets(mTypeMaxInsetsMap, systemBars());
}",1,"/**
 * Returns the stable insets in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The stable insets
 * @deprecated Use {@link #getInsetsIgnoringVisibility(int)} with {@link Type#systemBars()}
 * instead.
 */
","/**
 * Returns the stable insets in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The stable insets
 * @deprecated Use {@link #getInsetsIgnoringVisibility(int)} with {@link Type#systemBars()}
 * instead.
 */
",0,"[@Deprecated, @NonNull]","[@Deprecated, @NonNull]",0,,,,,,,5,1,"There's a change in the dependent method call parameter from mCompatInsetsTypes to systemBars(), which indicates a call to a different or overloaded method. Therefore, the code change type is 5.","The change in the parameters of the method call might result in the API returning different value(s), so the CI type is 1."
399,<android.os.Bundle: boolean hasFileDescriptors()>,32,33,,,,"{
    if ((mFlags & FLAG_HAS_FDS_KNOWN) == 0) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (fdFound) {
            mFlags |= FLAG_HAS_FDS;
        } else {
            mFlags &= ~FLAG_HAS_FDS;
        }
        mFlags |= FLAG_HAS_FDS_KNOWN;
    }
    return (mFlags & FLAG_HAS_FDS) != 0;
}","{
    if ((mFlags & FLAG_HAS_FDS_KNOWN) == 0) {
        Parcel p = mParcelledData;
        mFlags = (Parcel.hasFileDescriptors((p != null) ? p : mMap)) ? mFlags | FLAG_HAS_FDS : mFlags & ~FLAG_HAS_FDS;
        mFlags |= FLAG_HAS_FDS_KNOWN;
    }
    return (mFlags & FLAG_HAS_FDS) != 0;
}",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",0,,,0,,,,,,,"1,3,5",1,"The control structure has changed by consolidating the logic into a single call to Parcel.hasFileDescriptors with a ternary operator, removing the detailed manual checks that were present in the early version. Additionally, the dependent API changed, as the early implementation calls methods such as ""mParcelledData.hasFileDescriptors()"", ""Parcelable.describeContents"", and iterates through collections manually, whereas the late version uses the static method ""Parcel.hasFileDescriptors()"" which was not present before. The return statement potentially returns different values because the way the mFlags are set has changed, which changes the behavior of the method regarding the return value of (mFlags & FLAG_HAS_FDS) != 0.","The API could return a different boolean result due to the significant refactoring of the way it computes if the Bundle has file descriptors. The new version delegates this check to a static method ""Parcel.hasFileDescriptors"" which may have a different implementation than the manual checks performed in the early version. This could result in different return values for cases on the edge of the old manual logic, hence the CI type is 1."
400,<android.service.wallpaper.WallpaperService.Engine: void detach()>,32,33,,,,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mIWallpaperEngine.mDisplayManager != null) {
        mIWallpaperEngine.mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        if (mBlastBufferQueue != null) {
            mBlastBufferQueue.destroy();
            mBlastBufferQueue = null;
        }
        if (mBbqSurfaceControl != null) {
            new SurfaceControl.Transaction().remove(mBbqSurfaceControl).apply();
            mBbqSurfaceControl = null;
        }
        mCreated = false;
    }
}","{
    if (mDestroyed) {
        return;
    }
    AnimationHandler.removeRequestor(this);
    mDestroyed = true;
    if (mIWallpaperEngine.mDisplayManager != null) {
        mIWallpaperEngine.mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        if (mBlastBufferQueue != null) {
            mBlastBufferQueue.destroy();
            mBlastBufferQueue = null;
        }
        if (mBbqSurfaceControl != null) {
            new SurfaceControl.Transaction().remove(mBbqSurfaceControl).apply();
            mBbqSurfaceControl = null;
        }
        mCreated = false;
    }
}",1,,,0,,,0,,,,,,,4,0,"There is a new method call `AnimationHandler.removeRequestor(this);` added into the late version which is a change into other statements without modifying control dependencies, return statements, exception handling, or dependent APIs, therefore this change falls under the category of ""Other statement changed"".","The additional method call to `AnimationHandler.removeRequestor(this);` before changing the `mDestroyed` state does not result in a return of a different value or the throwing of a different exception, assuming that `AnimationHandler.removeRequestor(this);` does not throw an unchecked exception that would alter the control flow of the method. Thus, there is no potential compatibility issue introduced due to this change."
402,"<android.view.translation.TranslationManager: Set<TranslationCapability> getOnDeviceTranslationCapabilities(int,int)>",32,33,,,,"{
    try {
        final SynchronousResultReceiver receiver = new SynchronousResultReceiver();
        mService.onTranslationCapabilitiesRequest(sourceFormat, targetFormat, receiver, mContext.getUserId());
        final SynchronousResultReceiver.Result result = receiver.awaitResult(SYNC_CALLS_TIMEOUT_MS);
        if (result.resultCode != STATUS_SYNC_CALL_SUCCESS) {
            return Collections.emptySet();
        }
        Parcelable[] parcelables = result.bundle.getParcelableArray(EXTRA_CAPABILITIES);
        ArraySet<TranslationCapability> capabilities = new ArraySet();
        for (Parcelable obj : parcelables) {
            if (obj instanceof TranslationCapability) {
                capabilities.add((TranslationCapability) obj);
            }
        }
        return capabilities;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (TimeoutException e) {
        Log.e(TAG, ""Timed out getting supported translation capabilities: "" + e);
        return Collections.emptySet();
    }
}","{
    try {
        final SynchronousResultReceiver receiver = new SynchronousResultReceiver();
        mService.onTranslationCapabilitiesRequest(sourceFormat, targetFormat, receiver, mContext.getUserId());
        final SynchronousResultReceiver.Result result = receiver.awaitResult(SYNC_CALLS_TIMEOUT_MS);
        if (result.resultCode != STATUS_SYNC_CALL_SUCCESS) {
            return Collections.emptySet();
        }
        ParceledListSlice<TranslationCapability> listSlice = result.bundle.getParcelable(EXTRA_CAPABILITIES);
        ArraySet<TranslationCapability> capabilities = new ArraySet<>(listSlice == null ? null : listSlice.getList());
        return capabilities;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (TimeoutException e) {
        Log.e(TAG, ""Timed out getting supported translation capabilities: "" + e);
        return Collections.emptySet();
    }
}",1,"/**
 * Returns a set of {@link TranslationCapability}s describing the capabilities for on-device
 * {@link Translator}s.
 *
 * <p>These translation capabilities contains a source and target {@link TranslationSpec}
 * representing the data expected for both ends of translation process. The capabilities
 * provides the information and limitations for generating a {@link TranslationContext}.
 * The context object can then be used by
 * {@link #createOnDeviceTranslator(TranslationContext, Executor, Consumer)} to obtain a
 * {@link Translator} for translations.</p>
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * @param sourceFormat data format for the input data to be translated.
 * @param targetFormat data format for the expected translated output data.
 * @return A set of {@link TranslationCapability}s.
 */
","/**
 * Returns a set of {@link TranslationCapability}s describing the capabilities for on-device
 * {@link Translator}s.
 *
 * <p>These translation capabilities contains a source and target {@link TranslationSpec}
 * representing the data expected for both ends of translation process. The capabilities
 * provides the information and limitations for generating a {@link TranslationContext}.
 * The context object can then be used by
 * {@link #createOnDeviceTranslator(TranslationContext, Executor, Consumer)} to obtain a
 * {@link Translator} for translations.</p>
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * @param sourceFormat data format for the input data to be translated.
 * @param targetFormat data format for the expected translated output data.
 * @return A set of {@link TranslationCapability}s.
 */
",0,"[@NonNull, @WorkerThread]","[@NonNull, @WorkerThread]",0,,,,,,,"1,4",1,"The extraction of `TranslationCapability` objects from the result bundle has been modified with the use of `ParceledListSlice` in place of a `Parcelable[]` array. This does not constitute a change in control dependency, and no new method calls have been introduced outside of the framework's own modified utilities (thus no dependent API change), leading to code change classifications 1,4. ","The change in how the capabilities set is built could potentially lead to a different return value given that the construction of `ArraySet` now directly uses `ParceledListSlice.getList()`, which may have different behavior or nuances compared to the explicit casting and adding loop used previously. Hence the CI is of type 1, indicating a possible difference in returned values."
403,<android.hardware.camera2.impl.CameraExtensionSessionImpl.CameraOutputImageCallback: void close()>,32,33,,,,"{
    for (Pair<Image, OnImageAvailableListener> entry : mImageListenerMap.values()) {
        if (entry.first != null) {
            entry.first.close();
        }
    }
    mImageListenerMap.clear();
}","{
    for (Pair<Image, OnImageAvailableListener> entry : mImageListenerMap.values()) {
        if (entry.first != null) {
            entry.first.close();
        }
    }
    for (long timestamp : mImageListenerMap.keySet()) {
        Pair<Image, OnImageAvailableListener> entry = mImageListenerMap.get(timestamp);
        if (entry.second != null) {
            entry.second.onImageDropped(timestamp);
        }
    }
    mImageListenerMap.clear();
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There is a new for-loop iterating over the keySet of mImageListenerMap and calling onImageDropped() on each OnImageAvailableListener before clearing the map, which constitutes a control dependency change and an other statement change, therefore the code change type is 3,4.","This change does not affect the return value of the method because it is a void method, and it does not introduce any new exceptions or change the exception handling, thus there is no compatibility issue, and the CI type is 0."
404,<android.os.BatteryUsageStats.Builder: Builder getOrCreateUserBatteryConsumerBuilder(int)>,32,33,,,,"{
    UserBatteryConsumer.Builder builder = mUserBatteryConsumerBuilders.get(userId);
    if (builder == null) {
        builder = new UserBatteryConsumer.Builder(mCustomPowerComponentNames, mIncludePowerModels, userId);
        mUserBatteryConsumerBuilders.put(userId, builder);
    }
    return builder;
}","{
    UserBatteryConsumer.Builder builder = mUserBatteryConsumerBuilders.get(userId);
    if (builder == null) {
        final BatteryConsumer.BatteryConsumerData data = BatteryConsumer.BatteryConsumerData.create(mBatteryConsumersCursorWindow, mBatteryConsumerDataLayout);
        builder = new UserBatteryConsumer.Builder(data, userId);
        mUserBatteryConsumerBuilders.put(userId, builder);
    }
    return builder;
}",1,"/**
 * Creates or returns a UserBatteryConsumer, which represents battery attribution
 * data for an individual {@link UserHandle}.
 */
","/**
 * Creates or returns a UserBatteryConsumer, which represents battery attribution
 * data for an individual {@link UserHandle}.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The construction of `UserBatteryConsumer.Builder` objects has been modified, which involves different parameters being passed to the constructor, thus the change type is 4. Additionally, since the parameter type and the way to get the data for builder creation are changed, the underlying dependent API has changed (change type 5).","The compatibility issue is not detected here since the return type of the method is still the same (`UserBatteryConsumer.Builder`), and a new object with the same type is returned under the same condition as before. Thus, despite the changes in the implementation details and different data being fed into the builder's constructor, these changes will not lead to a direct compatibility issue unless the behavior of the newly used APIs themselves is significantly different from the behavior of the replaced one, which is not indicated by the details provided. Therefore, the CI type is 0."
405,<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionLost(long)>,32,33,,,,"{
    if (DEBUG_POSITION) {
        Log.d(TAG, String.format(""%d windowPositionLost, frameNr = %d"", System.identityHashCode(this), frameNumber));
    }
    mRTLastReportedPosition.setEmpty();
    mRTLastReportedSurfaceSize.set(-1, -1);
    /**
     * positionLost can be called while UI thread is un-paused so we
     * need to hold the lock here.
     */
    synchronized (mSurfaceControlLock) {
        if (mPendingTransaction) {
            Log.w(TAG, System.identityHashCode(SurfaceView.this) + ""Pending transaction cleared."");
            mPositionChangedTransaction.clear();
            mPendingTransaction = false;
        }
        if (mSurfaceControl == null) {
            return;
        }
        mRtTransaction.hide(mSurfaceControl);
        applyOrMergeTransaction(mRtTransaction, frameNumber);
    }
}","{
    if (DEBUG_POSITION) {
        Log.d(TAG, String.format(""%d windowPositionLost, frameNr = %d"", System.identityHashCode(this), frameNumber));
    }
    mRTLastReportedPosition.setEmpty();
    mRTLastReportedSurfaceSize.set(-1, -1);
    // positionLost can be called while UI thread is un-paused.
    synchronized (mSurfaceControlLock) {
        if (mSurfaceControl == null)
            return;
        // b/131239825
        mRtTransaction.hide(mSurfaceControl);
        applyOrMergeTransaction(mRtTransaction, frameNumber);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The change is within the comments and the log message structure within the 'synchronized' block. This type of change falls under control dependency change (3), as no actual code logic has changed.","There is no Compatibility Issue as there are no changes in the return values, exception handling, or any form of execution that would affect the API's behavior. The changes made do not affect the API's contract."
406,<android.database.sqlite.SQLiteDatabase: boolean isWriteAheadLoggingEnabled()>,32,33,,,,"{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        return (mConfigurationLocked.openFlags & ENABLE_WRITE_AHEAD_LOGGING) != 0;
    }
}","{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        return mConfigurationLocked.resolveJournalMode().equalsIgnoreCase(SQLiteDatabase.JOURNAL_MODE_WAL);
    }
}",1,"/**
 * Returns true if write-ahead logging has been enabled for this database.
 *
 * @return True if write-ahead logging has been enabled for this database.
 *
 * @see #enableWriteAheadLogging
 * @see #ENABLE_WRITE_AHEAD_LOGGING
 */
","/**
 * Returns true if write-ahead logging has been enabled for this database.
 *
 * @return True if write-ahead logging has been enabled for this database.
 *
 * @see #enableWriteAheadLogging
 * @see #ENABLE_WRITE_AHEAD_LOGGING
 */
",0,,,0,,,,,,,"1,3,4,5",1,"The return statement has changed significantly including a check with `resolveJournalMode().equalsIgnoreCase(SQLiteDatabase.JOURNAL_MODE_WAL)` instead of a bitwise operation, and possibly a change in the Dependent API (resolveJournalMode and JOURNAL_MODE_WAL), so the code change types are 1,3,4,5.","As the method of checking whether write-ahead logging is enabled has changed, the result returned by this method might differ between versions, hence, there is a potential for a different return value, which is a CI type 1."
407,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,32,33,,,,"{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""nonInteractiveUiTimeout: "").append(mNonInteractiveUiTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""interactiveUiTimeout: "").append(mInteractiveUiTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(getId());
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""summary: "").append(mNonLocalizedSummary);
    stringBuilder.append("", "");
    stringBuilder.append(""isAccessibilityTool: "").append(mIsAccessibilityTool);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}","{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""nonInteractiveUiTimeout: "").append(mNonInteractiveUiTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""interactiveUiTimeout: "").append(mInteractiveUiTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(getId());
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""tileServiceName: "").append(mTileServiceName);
    stringBuilder.append("", "");
    stringBuilder.append(""summary: "").append(mNonLocalizedSummary);
    stringBuilder.append("", "");
    stringBuilder.append(""isAccessibilityTool: "").append(mIsAccessibilityTool);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There's an addition of a new line that appends ""tileServiceName"" to the stringBuilder in the late version, indicating an other statement changed (4).","The addition of the new property ""tileServiceName"" to the toString() method output doesn't affect the behavior of the method in terms of returned value type or exception changes. It merely adds additional information to the string representation. Therefore, there is no Compatibility Issue (0)."
408,<android.app.admin.DevicePolicyManager: void setPreferentialNetworkServiceEnabled(boolean)>,32,33,,,,"{
    throwIfParentInstance(""setPreferentialNetworkServiceEnabled"");
    if (mService == null) {
        return;
    }
    try {
        mService.setPreferentialNetworkServiceEnabled(enabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setPreferentialNetworkServiceEnabled"");
    PreferentialNetworkServiceConfig.Builder configBuilder = new PreferentialNetworkServiceConfig.Builder();
    configBuilder.setEnabled(enabled);
    if (enabled) {
        configBuilder.setNetworkId(NET_ENTERPRISE_ID_1);
    }
    setPreferentialNetworkServiceConfigs(List.of(configBuilder.build()));
}",1,"/**
 * Sets whether preferential network service is enabled on the work profile.
 * For example, an organization can have a deal/agreement with a carrier that all of
 * the work data from its employeesÂ¡Â¯ devices will be sent via a network service dedicated
 * for enterprise use.
 *
 * An example of a supported preferential network service is the Enterprise
 * slice on 5G networks.
 *
 * By default, preferential network service is disabled on the work profile on supported
 * carriers and devices. Admins can explicitly enable it with this API.
 * On fully-managed devices this method is unsupported because all traffic is considered
 * work traffic.
 *
 * <p>This method can only be called by the profile owner of a managed profile.
 * @param enabled whether preferential network service should be enabled.
 * @throws SecurityException if the caller is not the profile owner.
 */
","/**
 * Sets whether preferential network service is enabled.
 * For example, an organization can have a deal/agreement with a carrier that all of
 * the work data from its employeesÂ¡Â¯ devices will be sent via a network service dedicated
 * for enterprise use.
 *
 * An example of a supported preferential network service is the Enterprise
 * slice on 5G networks. For devices on 4G networks, the profile owner needs to additionally
 * configure enterprise APN to set up data call for the preferential network service.
 * These APNs can be added using {@link #addOverrideApn}.
 *
 * By default, preferential network service is disabled on the work profile and
 * fully managed devices, on supported carriers and devices.
 * Admins can explicitly enable it with this API.
 *
 * <p> This method enables preferential network service with a default configuration.
 * To fine-tune the configuration, use {@link #setPreferentialNetworkServiceConfigs) instead.
 * <p> Before Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * this method can be called by the profile owner of a managed profile.
 * <p> Starting from Android version {@link android.os.Build.VERSION_CODES#TIRAMISU}:
 * This method can be called by the profile owner of a managed profile
 * or device owner.
 *
 * @param enabled whether preferential network service should be enabled.
 * @throws SecurityException if the caller is not the profile owner or device owner.
 */
",1,,,0,,,,,,,"4,5",0,"The entire content of the method has changed, introducing a new way of setting the preferential network service through the use of a builder and a config object rather than directly calling a method on the mService object. The building of the configuration now controls whether the feature is enabled and assigns a network ID if enabled, and it is now applying configurations through setPreferentialNetworkServiceConfigs. The code change type is 4,5 since the implementation approach has changed, not just the code itself but also the dependent APIs.","There is no Compatibility Issue, as the older public API method 'setPreferentialNetworkServiceEnabled' is entirely replaced by the logic encapsulated in constructing a 'PreferentialNetworkServiceConfig' and applying it through 'setPreferentialNetworkServiceConfigs'. The original functionality, to enable or disable a service, is maintained, albeit via different internal API calls. Without evidence that the change leads to different external behavior (i.e., different effects when invoked by client code with the same parameters), we cannot classify it as a CI."
409,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,32,33,,,,"{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
}","{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode(), mDynamicRangeProfile, mStreamUseCase, mTimestampBase, mMirrorMode);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode(), mDynamicRangeProfile, mStreamUseCase, mTimestampBase, mMirrorMode);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,"1,4",1,"New parameters (mDynamicRangeProfile, mStreamUseCase, mTimestampBase, mMirrorMode) are added to both branches of the if-else statement of the hashCode() method. More information is now included when computing the hash code, which makes the return statement changed. The new logic added to the return statement doesn't fit into control dependency or exception handling, but alters other parts of the statement; thus, the change type includes 1 and 4.","With the new parameters added to the hashCode() calculation, the return value, which is the hash code, could potentially be different for the same object between the two versions of the API. This leads to a possible difference in behavior as the purpose of the hashCode() is to provide a unique integer representation. Therefore, a CI may arise due to potential different return values; the CI type is 1."
411,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",32,33,,,,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, null, /*excludedPermissions=*/
        appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, null, /*excludedPermissions=*/
        null, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change observed is the modification in the parameters passed to the `broadcastIntentWithFeature` method, specifically the exclusion of the `excludedPermissions` parameter by replacing it with `null`. There are no changes to return statements, exception handling, control structures, or dependent APIs (the dependent API `broadcastIntentWithFeature` is still being called, albeit with different arguments). Hence, the categorized code change type is 4.","The change in parameters does not affect the return type, value, or exceptions thrown by this API, guaranteeing consistent behavior across both versions. Therefore, this alteration should not introduce a compatibility issue; hence, the CI type is 0."
412,<android.service.dreams.DreamService: IBinder onBind(Intent)>,32,33,,,,"{
    if (mDebug)
        Slog.v(TAG, ""onBind() intent = "" + intent);
    mDreamServiceWrapper = new DreamServiceWrapper();
    return mDreamServiceWrapper;
}","{
    if (mDebug)
        Slog.v(mTag, ""onBind() intent = "" + intent);
    mDreamServiceWrapper = new DreamServiceWrapper();
    // Connect to the overlay service if present.
    if (!mWindowless) {
        mOverlayConnection.bind(/* context= */
        this, intent.getParcelableExtra(EXTRA_DREAM_OVERLAY_COMPONENT), new ComponentName(this, getClass()));
    }
    return mDreamServiceWrapper;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,"3,4",0,"The logging tag has been changed from a constant TAG to a variable mTag and an additional control statement and method call 'mOverlayConnection.bind()' has been introduced. These changes are in 'if' and 'if (!mWindowless)' blocks, resulting in control dependency and other statement changes, so the code change types are 3,4.","Despite the control and other statement changes, the return value is always 'mDreamServiceWrapper', which is not altered. Moreover, no new exceptions are thrown nor is the exception handling mechanism changed. Therefore, no compatibility issue is introduced, and the CI type is 0."
414,<android.os.Parcel: Creator<?> readParcelableCreator(ClassLoader)>,32,33,,,,"{
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<?> creator;
    HashMap<String, Parcelable.Creator<?>> map;
    synchronized (mCreators) {
        map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
    }
    if (creator != null) {
        return creator;
    }
    try {
        // If loader == null, explicitly emulate Class.forName(String) ""caller
        // classloader"" behavior.
        ClassLoader parcelableClassLoader = (loader == null ? getClass().getClassLoader() : loader);
        // Avoid initializing the Parcelable class until we know it implements
        // Parcelable and has the necessary CREATOR field. http://b/1171613.
        Class<?> parcelableClass = Class.forName(name, false, /* initialize */
        parcelableClassLoader);
        if (!Parcelable.class.isAssignableFrom(parcelableClass)) {
            throw new BadParcelableException(""Parcelable protocol requires subclassing "" + ""from Parcelable on class "" + name);
        }
        Field f = parcelableClass.getField(""CREATOR"");
        if ((f.getModifiers() & Modifier.STATIC) == 0) {
            throw new BadParcelableException(""Parcelable protocol requires "" + ""the CREATOR object to be static on class "" + name);
        }
        Class<?> creatorType = f.getType();
        if (!Parcelable.Creator.class.isAssignableFrom(creatorType)) {
            // parcelableClass unnecessarily.
            throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + ""CREATOR on class "" + name);
        }
        creator = (Parcelable.Creator<?>) f.get(null);
    } catch (IllegalAccessException e) {
        Log.e(TAG, ""Illegal access when unmarshalling: "" + name, e);
        throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name, e);
    } catch (ClassNotFoundException e) {
        Log.e(TAG, ""Class not found when unmarshalling: "" + name, e);
        throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name, e);
    } catch (NoSuchFieldException e) {
        throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + ""CREATOR on class "" + name, e);
    }
    if (creator == null) {
        throw new BadParcelableException(""Parcelable protocol requires a "" + ""non-null Parcelable.Creator object called "" + ""CREATOR on class "" + name);
    }
    synchronized (mCreators) {
        map.put(name, creator);
    }
    return creator;
}","{
    return readParcelableCreatorInternal(loader, /* clazz */
    null);
}",1,"/**
 * Read and return a Parcelable.Creator from the parcel. The given class loader will be used to
 * load the {@link Parcelable.Creator}. If it is null, the default class loader will be used.
 *
 * @param loader A ClassLoader from which to instantiate the {@link Parcelable.Creator}
 * object, or null for the default class loader.
 * @return the previously written {@link Parcelable.Creator}, or null if a null Creator was
 * written.
 * @throws BadParcelableException Throws BadParcelableException if there was an error trying to
 * read the {@link Parcelable.Creator}.
 *
 * @see #writeParcelableCreator
 */
","/**
 * Read and return a Parcelable.Creator from the parcel. The given class loader will be used to
 * load the {@link Parcelable.Creator}. If it is null, the default class loader will be used.
 *
 * @param loader A ClassLoader from which to instantiate the {@link Parcelable.Creator}
 * object, or null for the default class loader.
 * @return the previously written {@link Parcelable.Creator}, or null if a null Creator was
 * written.
 * @throws BadParcelableException Throws BadParcelableException if there was an error trying to
 * read the {@link Parcelable.Creator}.
 *
 * @see #writeParcelableCreator
 *
 * @deprecated Use the type-safer version {@link #readParcelableCreator(ClassLoader, Class)}
 * starting from Android {@link Build.VERSION_CODES#TIRAMISU}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,5,0,"The entire implementation of the method has been replaced with a call to another method readParcelableCreatorInternal(loader, null). This indicates that the logic has been refactored or moved to a different method which is a dependent API change, so the code change type is 5.","The behavior, as seen from the method signature, should remain unchanged because it delegates the responsibility to another method that is assumed to perform the same action as the original code. Thus, the potential for a compatibility issue seems non-existent based solely on this information, so the CI type is 0."
415,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",32,33,,,,"{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new IpPrefix(address, prefixLength), null, null, RouteInfo.RTN_UNICAST));
    mConfig.updateAllowedFamilies(address);
    return this;
}","{
    checkNonPrefixBytes(address, prefixLength);
    return addRoute(new IpPrefix(address, prefixLength), RouteInfo.RTN_UNICAST);
}",1,"/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
","/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * Calling this method overrides previous calls to {@link #excludeRoute} for the same
 * destination.
 *
 * If multiple routes match the packet destination, route with the longest prefix takes
 * precedence.
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
",1,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The early version implementation includes a manual check of the bytes and throws an IllegalArgumentException based on the check. This is replaced with a call to checkNonPrefixBytes() in the late implementation, and the manual array and loop operations are removed. The addition of a route to mRoutes in the early implementation is replaced by a call to addRoute() with a new IpPrefix and route type in the late version. Thus, the change type is 4 as it involves other statements being changed, and 5 as there is a change in the dependent API (use of the new method checkNonPrefixBytes() and the different signature for addRoute()).","Even though there is a significant change in the implementation details, there is no difference in behavior if the checkNonPrefixBytes() and the new addRoute() methods properly encapsulate the previous behavior. Both methods in the early and late versions aim to add a route based on the address and prefixLength provided. Assuming that checkNonPrefixBytes() throws the same IllegalArgumentException under relevant conditions and that the new addRoute() correctly adds the route, the end effect would be equivalent. Therefore, no compatibility issue is detected."
416,<android.app.NotificationManager.Policy: String toString()>,32,33,,,,"{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",priorityConvSenders="" + conversationSendersToString(priorityConversationSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + "",areChannelsBypassingDnd="" + (((state & STATE_CHANNELS_BYPASSING_DND) != 0) ? ""true"" : ""false"") + ""]"";
}","{
    return ""NotificationManager.Policy["" + ""priorityCategories="" + priorityCategoriesToString(priorityCategories) + "",priorityCallSenders="" + prioritySendersToString(priorityCallSenders) + "",priorityMessageSenders="" + prioritySendersToString(priorityMessageSenders) + "",priorityConvSenders="" + conversationSendersToString(priorityConversationSenders) + "",suppressedVisualEffects="" + suppressedEffectsToString(suppressedVisualEffects) + "",areChannelsBypassingDnd="" + (state == STATE_UNSET ? ""unset"" : ((state & STATE_CHANNELS_BYPASSING_DND) != 0) ? ""true"" : ""false"") + ""]"";
}",1,,,0,[@Override],[@Override],0,,,,,,,4,1,"There is an additional condition check for the value of `state` being `STATE_UNSET`, which impacts the string representation of the `areChannelsBypassingDnd` field within the `toString()` method. Since this is part of the concatenated string being returned and not a control statement, the change type is 4, which is 'Other statement changed'.","Because the new condition may affect the returned string (by potentially adding ""unset"" instead of ""false"" or ""true""), this could cause the API to return a different value in some cases, which is classified as a Compatibility Issue type 1."
417,<android.inputmethodservice.InputMethodService: void onDestroy()>,32,33,,,,"{
    mDestroyed = true;
    super.onDestroy();
    mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
    doFinishInput();
    mWindow.dismissForDestroyIfNecessary();
    if (mSettingsObserver != null) {
        mSettingsObserver.unregister();
        mSettingsObserver = null;
    }
    if (mToken != null) {
        // This is completely optional, but allows us to show more explicit error messages
        // when IME developers are doing something unsupported.
        InputMethodPrivilegedOperationsRegistry.remove(mToken);
    }
}","{
    mDestroyed = true;
    super.onDestroy();
    mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
    doFinishInput();
    mNavigationBarController.onDestroy();
    mWindow.dismissForDestroyIfNecessary();
    if (mSettingsObserver != null) {
        mSettingsObserver.unregister();
        mSettingsObserver = null;
    }
    if (mToken != null) {
        // This is completely optional, but allows us to show more explicit error messages
        // when IME developers are doing something unsupported.
        InputMethodPrivilegedOperationsRegistry.remove(mToken);
    }
    mImeDispatcher = null;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change is the insertion of the new method call `mNavigationBarController.onDestroy();` and assigning `null` to `mImeDispatcher` in the late implementation. Therefore, it's classified as an ""other statement changed"" (4).","The changes do not affect the return type or value (since the method is `void` and there's no return statement) and does not introduce changes in exception handling. Therefore, there's no compatibility issue (0)."
420,<android.app.PictureInPictureParams.Builder: PictureInPictureParams build()>,32,33,,,,"{
    PictureInPictureParams params = new PictureInPictureParams(mAspectRatio, mUserActions, mSourceRectHint, mAutoEnterEnabled, mSeamlessResizeEnabled);
    return params;
}","{
    PictureInPictureParams params = new PictureInPictureParams(mAspectRatio, mExpandedAspectRatio, mUserActions, mCloseAction, mSourceRectHint, mAutoEnterEnabled, mSeamlessResizeEnabled, mTitle, mSubtitle, mIsLaunchIntoPip);
    return params;
}",1,"/**
 * @return an immutable {@link PictureInPictureParams} to be used when entering or updating
 * the activity in picture-in-picture.
 *
 * @see Activity#enterPictureInPictureMode(PictureInPictureParams)
 * @see Activity#setPictureInPictureParams(PictureInPictureParams)
 */
","/**
 * @return an immutable {@link PictureInPictureParams} to be used when entering or updating
 * the activity in picture-in-picture.
 *
 * @see Activity#enterPictureInPictureMode(PictureInPictureParams)
 * @see Activity#setPictureInPictureParams(PictureInPictureParams)
 */
",0,,,0,,,,,,,"4,5",1,"The constructor of PictureInPictureParams within the build method has been modified to include more parameters (mExpandedAspectRatio, mCloseAction, mTitle, mSubtitle, mIsLaunchIntoPip), which did not exist in the early version. This indicates that additional fields are being set in the PictureInPictureParams object in the late version, so the code change type is 4,5.","The change in the constructor call with additional parameters could potentially lead to the API returning an object with different state compared to the previous version, thus a Compatibility Issue due to different return values or types could arise, making the CI type 1."
421,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,32,33,,,,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (mWindowContextToken == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        mWindowContextToken = o.mWindowContextToken;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (preferredMinDisplayRefreshRate != o.preferredMinDisplayRefreshRate) {
        preferredMinDisplayRefreshRate = o.preferredMinDisplayRefreshRate;
        changes |= PREFERRED_MIN_DISPLAY_REFRESH_RATE;
    }
    if (preferredMaxDisplayRefreshRate != o.preferredMaxDisplayRefreshRate) {
        preferredMaxDisplayRefreshRate = o.preferredMaxDisplayRefreshRate;
        changes |= PREFERRED_MAX_DISPLAY_REFRESH_RATE;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (receiveInsetsIgnoringZOrder != o.receiveInsetsIgnoringZOrder) {
        receiveInsetsIgnoringZOrder = o.receiveInsetsIgnoringZOrder;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    if (preferMinimalPostProcessing != o.preferMinimalPostProcessing) {
        preferMinimalPostProcessing = o.preferMinimalPostProcessing;
        changes |= MINIMAL_POST_PROCESSING_PREFERENCE_CHANGED;
    }
    if (mBlurBehindRadius != o.mBlurBehindRadius) {
        mBlurBehindRadius = o.mBlurBehindRadius;
        changes |= BLUR_BEHIND_RADIUS_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    if (insetsFlags.appearance != o.insetsFlags.appearance) {
        insetsFlags.appearance = o.insetsFlags.appearance;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (insetsFlags.behavior != o.insetsFlags.behavior) {
        insetsFlags.behavior = o.insetsFlags.behavior;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (mFitInsetsTypes != o.mFitInsetsTypes) {
        mFitInsetsTypes = o.mFitInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsSides != o.mFitInsetsSides) {
        mFitInsetsSides = o.mFitInsetsSides;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsIgnoringVisibility != o.mFitInsetsIgnoringVisibility) {
        mFitInsetsIgnoringVisibility = o.mFitInsetsIgnoringVisibility;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providesInsetsTypes, o.providesInsetsTypes)) {
        providesInsetsTypes = o.providesInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (!providedInternalInsets.equals(o.providedInternalInsets)) {
        providedInternalInsets = o.providedInternalInsets;
        changes |= LAYOUT_CHANGED;
    }
    if (!providedInternalImeInsets.equals(o.providedInternalImeInsets)) {
        providedInternalImeInsets = o.providedInternalImeInsets;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(paramsForRotation, o.paramsForRotation)) {
        paramsForRotation = o.paramsForRotation;
        checkNonRecursiveParams();
        changes |= LAYOUT_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (mWindowContextToken == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        mWindowContextToken = o.mWindowContextToken;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (preferredMinDisplayRefreshRate != o.preferredMinDisplayRefreshRate) {
        preferredMinDisplayRefreshRate = o.preferredMinDisplayRefreshRate;
        changes |= PREFERRED_MIN_DISPLAY_REFRESH_RATE;
    }
    if (preferredMaxDisplayRefreshRate != o.preferredMaxDisplayRefreshRate) {
        preferredMaxDisplayRefreshRate = o.preferredMaxDisplayRefreshRate;
        changes |= PREFERRED_MAX_DISPLAY_REFRESH_RATE;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (receiveInsetsIgnoringZOrder != o.receiveInsetsIgnoringZOrder) {
        receiveInsetsIgnoringZOrder = o.receiveInsetsIgnoringZOrder;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    if (preferMinimalPostProcessing != o.preferMinimalPostProcessing) {
        preferMinimalPostProcessing = o.preferMinimalPostProcessing;
        changes |= MINIMAL_POST_PROCESSING_PREFERENCE_CHANGED;
    }
    if (mBlurBehindRadius != o.mBlurBehindRadius) {
        mBlurBehindRadius = o.mBlurBehindRadius;
        changes |= BLUR_BEHIND_RADIUS_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    if (insetsFlags.appearance != o.insetsFlags.appearance) {
        insetsFlags.appearance = o.insetsFlags.appearance;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (insetsFlags.behavior != o.insetsFlags.behavior) {
        insetsFlags.behavior = o.insetsFlags.behavior;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (mFitInsetsTypes != o.mFitInsetsTypes) {
        mFitInsetsTypes = o.mFitInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsSides != o.mFitInsetsSides) {
        mFitInsetsSides = o.mFitInsetsSides;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsIgnoringVisibility != o.mFitInsetsIgnoringVisibility) {
        mFitInsetsIgnoringVisibility = o.mFitInsetsIgnoringVisibility;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providesInsetsTypes, o.providesInsetsTypes)) {
        providesInsetsTypes = o.providesInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providedInternalInsets, o.providedInternalInsets)) {
        providedInternalInsets = o.providedInternalInsets;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providedInternalImeInsets, o.providedInternalImeInsets)) {
        providedInternalImeInsets = o.providedInternalImeInsets;
        changes |= LAYOUT_CHANGED;
    }
    if (insetsRoundedCornerFrame != o.insetsRoundedCornerFrame) {
        insetsRoundedCornerFrame = o.insetsRoundedCornerFrame;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(paramsForRotation, o.paramsForRotation)) {
        paramsForRotation = o.paramsForRotation;
        checkNonRecursiveParams();
        changes |= LAYOUT_CHANGED;
    }
    return changes;
}",1,,,0,,,0,,,,,,,,,,
422,<android.view.KeyEvent: long getEventTime()>,32,33,,,,"{
    return mEventTime;
}","{
    return TimeUnit.MILLISECONDS.convert(mEventTime, TimeUnit.NANOSECONDS);
}",1,"/**
 * Retrieve the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.
 *
 * @return Returns the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.
 */
","/**
 * Retrieve the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.
 *
 * @return Returns the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.
 */
",0,[@Override],[@Override],0,,,,,,,"1,5",1,"The code has changed the way it returns the value of mEventTime, from direct return to converting it first with TimeUnit, and this conversion is considered a change in the dependent API, thus the code change type is 1,5.","The method now returns the converted time instead of the original time. This unit change from nanoseconds to milliseconds could result in different behavior, so the potential Compatibility Issue type is 1."
423,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: boolean equals(Object)>,32,33,,,,"{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof MandatoryStreamInformation) {
        final MandatoryStreamInformation other = (MandatoryStreamInformation) obj;
        if ((mFormat != other.mFormat) || (mIsInput != other.mIsInput) || (mIsUltraHighResolution != other.mIsUltraHighResolution) || (mAvailableSizes.size() != other.mAvailableSizes.size())) {
            return false;
        }
        return mAvailableSizes.equals(other.mAvailableSizes);
    }
    return false;
}","{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof MandatoryStreamInformation) {
        final MandatoryStreamInformation other = (MandatoryStreamInformation) obj;
        if ((mFormat != other.mFormat) || (mIsInput != other.mIsInput) || (mIsUltraHighResolution != other.mIsUltraHighResolution) || (mStreamUseCase != other.mStreamUseCase) || (mAvailableSizes.size() != other.mAvailableSizes.size())) {
            return false;
        }
        return mAvailableSizes.equals(other.mAvailableSizes);
    }
    return false;
}",1,"/**
 * Check if this {@link MandatoryStreamInformation} is equal to another
 * {@link MandatoryStreamInformation}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is
 * equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link MandatoryStreamInformation} is equal to another
 * {@link MandatoryStreamInformation}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is
 * equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The equality check condition has been changed by introducing a new field comparison `mStreamUseCase != other.mStreamUseCase` in the `if` statement. Since this is not a change to the control flow or return statements, just a logical change in an `if` condition, the code change type is 4.","There is no Compatibility Issue caused by this change because the modification enhances the equality check by incorporating an additional field. If the objects were considered equal before and the value of `mStreamUseCase` is also equal between the two objects, they will still be equal after the change. If the value of `mStreamUseCase` is different between the two objects then the previous version would have potentially incorrectly considered them equal, thus the behavior is corrected and not incompatible. Therefore, this change does not introduce a CI."
425,<android.os.Bundle: Parcelable[] getParcelableArray(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Parcelable[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Parcelable[]"", e);
        return null;
    }
}","{
    unparcel();
    Object o = getValue(key);
    if (o == null) {
        return null;
    }
    try {
        return (Parcelable[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Parcelable[]"", e);
        return null;
    }
}",1,"/**
 * Returns the value associated with the given key, or {@code null} if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * <p><b>Note: </b> if the expected value is not a class provided by the Android platform,
 * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.
 * Otherwise, this method might throw an exception or return {@code null}.
 *
 * @param key a String, or {@code null}
 * @return a Parcelable[] value, or {@code null}
 */
","/**
 * Returns the value associated with the given key, or {@code null} if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * <p><b>Note: </b> if the expected value is not a class provided by the Android platform,
 * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.
 * Otherwise, this method might throw an exception or return {@code null}.
 *
 * @param key a String, or {@code null}
 * @return a Parcelable[] value, or {@code null}
 *
 * @deprecated Use the type-safer {@link #getParcelableArray(String, Class)} starting from
 * Android {@link Build.VERSION_CODES#TIRAMISU}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"4,5",0,"The method mMap.get(key) is replaced by getValue(key), which is a call to another method, and no modifications to the control flow or the exception handling are made. Thus the code change type is 4,5.","There is no compatibility issue arising from this change because the logic of the method remains unchanged. The internal implementation now uses a different means of obtaining the value for key, but the end result, as seen by the caller of getParcelableArray(String), will be the same assuming the new getValue(key) method is functionally equivalent to mMap.get(key). The annotations do not affect the method's behavior but indicate that getValue may be deprecated in future releases, which is not considered a behavior change for the current release."
426,<android.app.slice.SliceProvider: PendingIntent onCreatePermissionRequest(Uri)>,32,33,,,,"{
    return createPermissionIntent(getContext(), sliceUri, getCallingPackage());
}","{
    return createPermissionPendingIntent(getContext(), sliceUri, getCallingPackage());
}",1,"/**
 * Called when an app requests a slice it does not have write permission
 * to the uri for.
 * <p>
 * The return value will be the action on a slice that prompts the user that
 * the calling app wants to show slices from this app. The default implementation
 * launches a dialog that allows the user to grant access to this slice. Apps
 * that do not want to allow this user grant, can override this and instead
 * launch their own dialog with different behavior.
 *
 * @param sliceUri the Uri of the slice attempting to be bound.
 * @see #getCallingPackage()
 */
","/**
 * Called when an app requests a slice it does not have write permission
 * to the uri for.
 * <p>
 * The return value will be the action on a slice that prompts the user that
 * the calling app wants to show slices from this app. The default implementation
 * launches a dialog that allows the user to grant access to this slice. Apps
 * that do not want to allow this user grant, can override this and instead
 * launch their own dialog with different behavior.
 *
 * @param sliceUri the Uri of the slice attempting to be bound.
 * @see #getCallingPackage()
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The dependent method name called within the return statement is changed from createPermissionIntent() to createPermissionPendingIntent(). This indicates that another API is being used, but it does not explicitly show the signature of that method, any added or removed exceptions, or whether return types or behavior have changed. Therefore, change type 4 (Other statement changed) and 5 (Dependent API changed) apply.","The change in the dependent API used with the return statement does not inherently indicate a compatibility issue. Since there is no evidence provided in the signatures, annotations, or implementations of a change in return type, thrown exceptions, or the data returned, no compatibility issue can be detected. Thus, CI type is 0."
429,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",32,33,,,,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface due to destroyed"");
        return;
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setFitInsetsTypes(0);
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                InputChannel inputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mRequestedVisibilities, inputChannel, mInsetsState, mTempControls) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mSession.setShouldZoomOutWallpaper(mWindow, shouldZoomOutWallpaper());
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(inputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrames, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls, mSurfaceSize);
            if (mSurfaceControl.isValid()) {
                if (mBbqSurfaceControl == null) {
                    mBbqSurfaceControl = new SurfaceControl.Builder().setName(""Wallpaper BBQ wrapper"").setHidden(false).setMetadata(METADATA_WINDOW_TYPE, TYPE_WALLPAPER).setBLASTLayer().setParent(mSurfaceControl).setCallsite(""Wallpaper#relayout"").build();
                    updateSurfaceDimming();
                }
                // Propagate transform hint from WM so we can use the right hint for the
                // first frame.
                mBbqSurfaceControl.setTransformHint(mSurfaceControl.getTransformHint());
                Surface blastSurface = getOrCreateBLASTSurface(mSurfaceSize.x, mSurfaceSize.y, mFormat);
                // would then inc the generation ID and cause EGL resources to be recreated.
                if (blastSurface != null) {
                    mSurfaceHolder.mSurface.transferFrom(blastSurface);
                }
            }
            if (!mLastSurfaceSize.equals(mSurfaceSize)) {
                mLastSurfaceSize.set(mSurfaceSize.x, mSurfaceSize.y);
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrames);
            int w = mWinFrames.frame.width();
            int h = mWinFrames.frame.height();
            final DisplayCutout rawCutout = mInsetsState.getDisplayCutout();
            final Configuration config = getResources().getConfiguration();
            final Rect visibleFrame = new Rect(mWinFrames.frame);
            visibleFrame.intersect(mInsetsState.getDisplayFrame());
            WindowInsets windowInsets = mInsetsState.calculateInsets(visibleFrame, null, /* ignoringVisibilityState */
            config.isScreenRound(), false, /* alwaysConsumeSystemBars */
            mLayout.softInputMode, mLayout.flags, SYSTEM_UI_FLAG_VISIBLE, mLayout.type, config.windowConfiguration.getWindowingMode(), null);
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                windowInsets = windowInsets.insetUnchecked(-padding.left, -padding.top, -padding.right, -padding.bottom);
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            final Rect contentInsets = windowInsets.getSystemWindowInsets().toRect();
            final Rect stableInsets = windowInsets.getStableInsets().toRect();
            final DisplayCutout displayCutout = windowInsets.getDisplayCutout() != null ? windowInsets.getDisplayCutout() : rawCutout;
            insetsChanged |= !mDispatchedContentInsets.equals(contentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(stableInsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(displayCutout);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedContentInsets.set(contentInsets);
                    mDispatchedStableInsets.set(stableInsets);
                    mDispatchedDisplayCutout = displayCutout;
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + windowInsets);
                    }
                    onApplyWindowInsets(windowInsets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    resetWindowPages();
                    mSession.finishDrawing(mWindow, null);
                    processLocalColors(mPendingXOffset, mPendingXOffsetStep);
                }
                reposition();
                reportEngineShown(shouldWaitForEngineShown());
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface due to destroyed"");
        return;
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            final Configuration config = mMergedConfiguration.getMergedConfiguration();
            final WindowConfiguration winConfig = config.windowConfiguration;
            final Rect maxBounds = winConfig.getMaxBounds();
            if (myWidth == ViewGroup.LayoutParams.MATCH_PARENT && myHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
                mLayout.width = myWidth;
                mLayout.height = myHeight;
                mLayout.flags &= ~WindowManager.LayoutParams.FLAG_SCALED;
            } else {
                final float layoutScale = Math.max(maxBounds.width() / (float) myWidth, maxBounds.height() / (float) myHeight);
                mLayout.width = (int) (myWidth * layoutScale + .5f);
                mLayout.height = (int) (myHeight * layoutScale + .5f);
                mLayout.flags |= WindowManager.LayoutParams.FLAG_SCALED;
            }
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setFitInsetsTypes(0);
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                InputChannel inputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mRequestedVisibilities, inputChannel, mInsetsState, mTempControls) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mSession.setShouldZoomOutWallpaper(mWindow, shouldZoomOutWallpaper());
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(inputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            int relayoutResult = 0;
            if (LOCAL_LAYOUT) {
                if (!mSurfaceControl.isValid()) {
                    relayoutResult = mSession.updateVisibility(mWindow, mLayout, View.VISIBLE, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls);
                }
                final Rect displayCutoutSafe = mTempRect;
                mInsetsState.getDisplayCutoutSafe(displayCutoutSafe);
                mWindowLayout.computeFrames(mLayout, mInsetsState, displayCutoutSafe, winConfig.getBounds(), winConfig.getWindowingMode(), mWidth, mHeight, mRequestedVisibilities, null, /* attachedWindowFrame */
                1f, /* compatScale */
                mWinFrames);
                mSession.updateLayout(mWindow, mLayout, 0, /* flags */
                mWinFrames, mWidth, mHeight);
            } else {
                relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrames, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls, mSyncSeqIdBundle);
            }
            final int transformHint = SurfaceControl.rotationToBufferTransform((mDisplayInstallOrientation + mDisplay.getRotation()) % 4);
            mSurfaceControl.setTransformHint(transformHint);
            WindowLayout.computeSurfaceSize(mLayout, maxBounds, mWidth, mHeight, mWinFrames.frame, false, /* dragResizing */
            mSurfaceSize);
            if (mSurfaceControl.isValid()) {
                if (mBbqSurfaceControl == null) {
                    mBbqSurfaceControl = new SurfaceControl.Builder().setName(""Wallpaper BBQ wrapper"").setHidden(false).setMetadata(METADATA_WINDOW_TYPE, TYPE_WALLPAPER).setBLASTLayer().setParent(mSurfaceControl).setCallsite(""Wallpaper#relayout"").build();
                }
                // Propagate transform hint from WM, so we can use the right hint for the
                // first frame.
                mBbqSurfaceControl.setTransformHint(transformHint);
                Surface blastSurface = getOrCreateBLASTSurface(mSurfaceSize.x, mSurfaceSize.y, mFormat);
                // would then inc the generation ID and cause EGL resources to be recreated.
                if (blastSurface != null) {
                    mSurfaceHolder.mSurface.transferFrom(blastSurface);
                }
            }
            if (!mLastSurfaceSize.equals(mSurfaceSize)) {
                mLastSurfaceSize.set(mSurfaceSize.x, mSurfaceSize.y);
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrames);
            int w = mWinFrames.frame.width();
            int h = mWinFrames.frame.height();
            final DisplayCutout rawCutout = mInsetsState.getDisplayCutout();
            final Rect visibleFrame = new Rect(mWinFrames.frame);
            visibleFrame.intersect(mInsetsState.getDisplayFrame());
            WindowInsets windowInsets = mInsetsState.calculateInsets(visibleFrame, null, /* ignoringVisibilityState */
            config.isScreenRound(), false, /* alwaysConsumeSystemBars */
            mLayout.softInputMode, mLayout.flags, SYSTEM_UI_FLAG_VISIBLE, mLayout.type, winConfig.getWindowingMode(), null);
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                windowInsets = windowInsets.insetUnchecked(-padding.left, -padding.top, -padding.right, -padding.bottom);
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            final Rect contentInsets = windowInsets.getSystemWindowInsets().toRect();
            final Rect stableInsets = windowInsets.getStableInsets().toRect();
            final DisplayCutout displayCutout = windowInsets.getDisplayCutout() != null ? windowInsets.getDisplayCutout() : rawCutout;
            insetsChanged |= !mDispatchedContentInsets.equals(contentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(stableInsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(displayCutout);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedContentInsets.set(contentInsets);
                    mDispatchedStableInsets.set(stableInsets);
                    mDispatchedDisplayCutout = displayCutout;
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + windowInsets);
                    }
                    onApplyWindowInsets(windowInsets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    resetWindowPages();
                    mSession.finishDrawing(mWindow, null, /* postDrawTransaction */
                    Integer.MAX_VALUE);
                    processLocalColors(mPendingXOffset, mPendingXOffsetStep);
                }
                reposition();
                reportEngineShown(shouldWaitForEngineShown());
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,0,,,0,,,,,,,,,,
431,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,32,33,,,,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0 && !isMouseEvent;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                    final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0 && !isMouseEvent;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                    final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount;
                        }
                        if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
432,<android.window.WindowContainerTransaction.HierarchyOp.Builder: HierarchyOp build()>,32,33,,,,"{
    final HierarchyOp hierarchyOp = new HierarchyOp(mType);
    hierarchyOp.mContainer = mContainer;
    hierarchyOp.mReparent = mReparent;
    hierarchyOp.mWindowingModes = mWindowingModes != null ? Arrays.copyOf(mWindowingModes, mWindowingModes.length) : null;
    hierarchyOp.mActivityTypes = mActivityTypes != null ? Arrays.copyOf(mActivityTypes, mActivityTypes.length) : null;
    hierarchyOp.mToTop = mToTop;
    hierarchyOp.mReparentTopOnly = mReparentTopOnly;
    hierarchyOp.mMoveAdjacentTogether = mMoveAdjacentTogether;
    hierarchyOp.mLaunchOptions = mLaunchOptions;
    hierarchyOp.mActivityIntent = mActivityIntent;
    hierarchyOp.mPendingIntent = mPendingIntent;
    hierarchyOp.mTaskFragmentCreationOptions = mTaskFragmentCreationOptions;
    return hierarchyOp;
}","{
    final HierarchyOp hierarchyOp = new HierarchyOp(mType);
    hierarchyOp.mContainer = mContainer;
    hierarchyOp.mReparent = mReparent;
    hierarchyOp.mWindowingModes = mWindowingModes != null ? Arrays.copyOf(mWindowingModes, mWindowingModes.length) : null;
    hierarchyOp.mActivityTypes = mActivityTypes != null ? Arrays.copyOf(mActivityTypes, mActivityTypes.length) : null;
    hierarchyOp.mInsetsTypes = mInsetsTypes;
    hierarchyOp.mInsetsProviderFrame = mInsetsProviderFrame;
    hierarchyOp.mToTop = mToTop;
    hierarchyOp.mReparentTopOnly = mReparentTopOnly;
    hierarchyOp.mMoveAdjacentTogether = mMoveAdjacentTogether;
    hierarchyOp.mLaunchOptions = mLaunchOptions;
    hierarchyOp.mActivityIntent = mActivityIntent;
    hierarchyOp.mPendingIntent = mPendingIntent;
    hierarchyOp.mTaskFragmentCreationOptions = mTaskFragmentCreationOptions;
    hierarchyOp.mShortcutInfo = mShortcutInfo;
    return hierarchyOp;
}",1,,,0,,,0,,,,,,,"1,4",1,"There are new fields (hierarchyOp.mInsetsTypes, hierarchyOp.mInsetsProviderFrame, and hierarchyOp.mShortcutInfo) being set in the late version's implementation before returning the `hierarchyOp` object. This implies that there's an addition of new fields to the `HierarchyOp` object in the late version. The fields in question are not part of the early version implementation. So this is classified under both ""Return statement changed"" (since a different 'return' value is now expected) and ""Other statement changed"" (due to the new field assignments).","The newly introduced fields in the `HierarchyOp` object and their corresponding assignments can result in a `HierarchyOp` instance that has different state/data when the method returns. This could potentially cause a ""Compatibility Issue"" as clients relying on the API could observe new or different behavior if they interact with the new fields, leading to classifying the CI type as 1 (Compatibility Issue caused by potential different return values)."
433,"<android.companion.CompanionDeviceManager: void associate(AssociationRequest,Callback,Handler)>",32,33,,,,"{
    if (!checkFeaturePresent()) {
        return;
    }
    Objects.requireNonNull(request, ""Request cannot be null"");
    Objects.requireNonNull(callback, ""Callback cannot be null"");
    try {
        mService.associate(request, new CallbackProxy(request, callback, Handler.mainIfNull(handler)), getCallingPackage());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (!checkFeaturePresent())
        return;
    Objects.requireNonNull(request, ""Request cannot be null"");
    Objects.requireNonNull(callback, ""Callback cannot be null"");
    handler = Handler.mainIfNull(handler);
    try {
        mService.associate(request, new AssociationRequestCallbackProxy(handler, callback), mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Associate this app with a companion device, selected by user
 *
 * <p>Once at least one appropriate device is found, {@code callback} will be called with a
 * {@link PendingIntent} that can be used to show the list of available devices for the user
 * to select.
 * It should be started for result (i.e. using
 * {@link android.app.Activity#startIntentSenderForResult}), as the resulting
 * {@link android.content.Intent} will contain extra {@link #EXTRA_DEVICE}, with the selected
 * device. (e.g. {@link android.bluetooth.BluetoothDevice})</p>
 *
 * <p>If your app needs to be excluded from battery optimizations (run in the background)
 * or to have unrestricted data access (use data in the background) you can declare that
 * you use the {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and {@link
 * android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} respectively. Note that these
 * special capabilities have a negative effect on the device's battery and user's data
 * usage, therefore you should request them when absolutely necessary.</p>
 *
 * <p>You can call {@link #getAssociations} to get the list of currently associated
 * devices, and {@link #disassociate} to remove an association. Consider doing so when the
 * association is no longer relevant to avoid unnecessary battery and/or data drain resulting
 * from special privileges that the association provides</p>
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * <p>When using {@link AssociationRequest#DEVICE_PROFILE_WATCH watch}
 * {@link AssociationRequest.Builder#setDeviceProfile profile}, caller must also hold
 * {@link Manifest.permission#REQUEST_COMPANION_PROFILE_WATCH}</p>
 *
 * @param request specific details about this request
 * @param callback will be called once there's at least one device found for user to choose from
 * @param handler A handler to control which thread the callback will be delivered on, or null,
 * to deliver it on main thread
 *
 * @see AssociationRequest
 */
","/**
 * Request to associate this app with a companion device.
 *
 * <p>Note that before creating establishing association the system may need to show UI to
 * collect user confirmation.</p>
 *
 * <p>If the app needs to be excluded from battery optimizations (run in the background)
 * or to have unrestricted data access (use data in the background) it should declare use of
 * {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and
 * {@link android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} in its
 * AndroidManifest.xml respectively.
 * Note that these special capabilities have a negative effect on the device's battery and
 * user's data usage, therefore you should request them when absolutely necessary.</p>
 *
 * <p>Application can use {@link #getMyAssociations()} for retrieving the list of currently
 * {@link AssociationInfo} objects, that represent their existing associations.
 * Applications can also use {@link #disassociate(int)} to remove an association, and are
 * recommended to do when an association is no longer relevant to avoid unnecessary battery
 * and/or data drain resulting from special privileges that the association provides</p>
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 * *
 * @param request A request object that describes details of the request.
 * @param callback The callback used to notify application when the association is created.
 * @param handler The handler which will be used to invoke the callback.
 *
 * @see AssociationRequest.Builder
 * @see #getMyAssociations()
 * @see #disassociate(int)
 * @see #associate(AssociationRequest, Executor, Callback)
 */
",1,"[@RequiresPermission(value = Manifest.permission.REQUEST_COMPANION_PROFILE_WATCH, conditional = true)]","[@UserHandleAware, @RequiresPermission(anyOf = { REQUEST_COMPANION_PROFILE_WATCH, REQUEST_COMPANION_PROFILE_COMPUTER, REQUEST_COMPANION_PROFILE_APP_STREAMING, REQUEST_COMPANION_PROFILE_AUTOMOTIVE_PROJECTION }, conditional = true)]",1,,,,,,,"3,4,5",0,The control dependency has not changed but the implementation and dependent API have undergone several changes:,- The method 'mService.associate' now takes 'mContext.getOpPackageName()' and 'mContext.getUserId()' as additional parameters.
434,<android.os.incremental.V4Signature.SigningInfo: SigningInfo fromByteArray(byte[])>,32,33,,,,"{
    ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);
    byte[] apkDigest = readBytes(buffer);
    byte[] certificate = readBytes(buffer);
    byte[] additionalData = readBytes(buffer);
    byte[] publicKey = readBytes(buffer);
    int signatureAlgorithmId = buffer.getInt();
    byte[] signature = readBytes(buffer);
    return new SigningInfo(apkDigest, certificate, additionalData, publicKey, signatureAlgorithmId, signature);
}","{
    return fromByteBuffer(ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN));
}",1,"/**
 * Constructs SigningInfo from byte array.
 */
","/**
 * Constructs SigningInfo from byte array.
 */
",0,,,0,,,,,,,5,5,"The complete implementation has changed from a detailed process of reading and constructing a SigningInfo object in the early version to just a single line that delegates the construction to another method in the late version. This indicates that the implementation of 'fromByteArray(byte[])' now depends on the 'fromByteBuffer(ByteBuffer)' method, which means the dependent API changed, so the code change type is 5.","As the functionality has been delegated to another method, if the behavior of 'fromByteBuffer(ByteBuffer)' has changed between these versions, then it would cause the current API to return a different value or type. Therefore, there's a potential Compatibility Issue due to a dependent API change, and the CI type is 5."
435,<android.service.dreams.DreamService: void finish()>,32,33,,,,"{
    if (mDebug)
        Slog.v(TAG, ""finish(): mFinished="" + mFinished);
    Activity activity = mActivity;
    if (activity != null) {
        if (!activity.isFinishing()) {
            // In case the activity is not finished yet, do it now.
            activity.finishAndRemoveTask();
        }
        return;
    }
    if (mFinished) {
        return;
    }
    mFinished = true;
    if (mDreamToken == null) {
        Slog.w(TAG, ""Finish was called before the dream was attached."");
        stopSelf();
        return;
    }
    try {
        // finishSelf will unbind the dream controller from the dream service. This will
        // trigger DreamService.this.onDestroy and DreamService.this will die.
        mDreamManager.finishSelf(mDreamToken, true);
    } catch (RemoteException ex) {
    // system server died
    }
}","{
    if (mDebug)
        Slog.v(mTag, ""finish(): mFinished="" + mFinished);
    Activity activity = mActivity;
    if (activity != null) {
        if (!activity.isFinishing()) {
            // In case the activity is not finished yet, do it now.
            activity.finishAndRemoveTask();
        }
        return;
    }
    if (mFinished) {
        return;
    }
    mFinished = true;
    mOverlayConnection.unbind(this);
    if (mDreamToken == null) {
        Slog.w(mTag, ""Finish was called before the dream was attached."");
        stopSelf();
        return;
    }
    try {
        // finishSelf will unbind the dream controller from the dream service. This will
        // trigger DreamService.this.onDestroy and DreamService.this will die.
        mDreamManager.finishSelf(mDreamToken, true);
    } catch (RemoteException ex) {
    // system server died
    }
}",1,"/**
 * Stops the dream and detaches from the window.
 * <p>
 * When the dream ends, the system will be allowed to go to sleep fully unless there
 * is a reason for it to be awake such as recent user activity or wake locks being held.
 * </p>
 */
","/**
 * Stops the dream and detaches from the window.
 * <p>
 * When the dream ends, the system will be allowed to go to sleep fully unless there
 * is a reason for it to be awake such as recent user activity or wake locks being held.
 * </p>
 */
",0,,,0,,,,,,,4,0,The log tag variable name has changed from TAG to mTag and a new statement (mOverlayConnection.unbind(this)) has been added. So the change type is 4.,"Since adding a call to unbind a service does not inherently change the behavior of the return values or exception handling and the change of log tag will not affect the API's external behavior, there is no Compatibility Issue; hence, the CI type is 0."
436,<android.os.PowerComponents.Builder: double getTotalPower()>,32,33,,,,"{
    double totalPowerMah = 0;
    for (int i = mPowerComponentsMah.length - 1; i >= 0; i--) {
        totalPowerMah += mPowerComponentsMah[i];
    }
    return totalPowerMah;
}","{
    double totalPowerMah = 0;
    for (int componentId = 0; componentId < BatteryConsumer.POWER_COMPONENT_COUNT; componentId++) {
        totalPowerMah += mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex);
    }
    for (int i = 0; i < mData.layout.customPowerComponentCount; i++) {
        totalPowerMah += mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i);
    }
    return totalPowerMah;
}",1,"/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
","/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */
",0,,,0,,,,,,,"3,4,5",1,"The for-loop iteration mechanism and the method of accumulating totalPowerMah have changed, with variables and method calls being different. The totalPowerMah is now calculated by making method calls on mData and referring to constants and fields within classes (BatteryConsumer and mData.layout). The early version uses a simple array and the late version relies on additional logic to extract data, hence there's a modification in the control dependency (3), other statements (4) and it also introduces dependent API changes (5).","The modification in the control flow and other statements as well as the usage of potentially different methods to calculate total power will change how the final totalPowerMah is calculated. Since the logic to accumulate totalPowerMah has fundamentally changed, including reliance on new API calls, this could result in different return values, so the CI type is 1."
437,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,32,33,,,,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_DRAW_FINISHED:
            return ""MSG_DRAW_FINISHED"";
        case MSG_INSETS_CHANGED:
            return ""MSG_INSETS_CHANGED"";
        case MSG_INSETS_CONTROL_CHANGED:
            return ""MSG_INSETS_CONTROL_CHANGED"";
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"";
        case MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED:
            return ""MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED"";
        case MSG_SHOW_INSETS:
            return ""MSG_SHOW_INSETS"";
        case MSG_HIDE_INSETS:
            return ""MSG_HIDE_INSETS"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            return ""MSG_DISPATCH_KEY_FROM_AUTOFILL"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_SYNTHESIZE_INPUT_EVENT:
            return ""MSG_SYNTHESIZE_INPUT_EVENT"";
        case MSG_DISPATCH_WINDOW_SHOWN:
            return ""MSG_DISPATCH_WINDOW_SHOWN"";
        case MSG_UPDATE_POINTER_ICON:
            return ""MSG_UPDATE_POINTER_ICON"";
        case MSG_POINTER_CAPTURE_CHANGED:
            return ""MSG_POINTER_CAPTURE_CHANGED"";
        case MSG_INSETS_CONTROL_CHANGED:
            return ""MSG_INSETS_CONTROL_CHANGED"";
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            return ""MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED"";
        case MSG_SHOW_INSETS:
            return ""MSG_SHOW_INSETS"";
        case MSG_HIDE_INSETS:
            return ""MSG_HIDE_INSETS"";
        case MSG_WINDOW_TOUCH_MODE_CHANGED:
            return ""MSG_WINDOW_TOUCH_MODE_CHANGED"";
        case MSG_KEEP_CLEAR_RECTS_CHANGED:
            return ""MSG_KEEP_CLEAR_RECTS_CHANGED"";
    }
    return super.getMessageName(message);
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
438,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews,InlinePresentation,InlinePresentation)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null"");
    Preconditions.checkNotNull(inlineTooltipPresentation, ""inlineTooltipPresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, inlineTooltipPresentation, null);
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(presentation, ""presentation cannot be null"");
    Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null"");
    Objects.requireNonNull(inlineTooltipPresentation, ""inlineTooltipPresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, inlineTooltipPresentation, null, null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * @see #setValue(AutofillId, AutofillValue, RemoteViews, InlinePresentation)
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 * @param inlineTooltipPresentation The {@link InlinePresentation} used to show
 * the tooltip for the {@code inlinePresentation}.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * @see #setValue(AutofillId, AutofillValue, RemoteViews, InlinePresentation)
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 * @param inlineTooltipPresentation The {@link InlinePresentation} used to show
 * the tooltip for the {@code inlinePresentation}.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"4,5",0,"The check for null has been changed from the `Preconditions` class to the `Objects` class which are equivalent. Additionally, the method setLifeTheUniverseAndEverything in the late version has an extra parameter 'null' compared to the early version. Since there are no specifics on the behavior of this method, we must assume it's a dependent API which has changed in parameters, hence the code change type is 4,5.","Given that Preconditions.checkNotNull() and Objects.requireNonNull() are equivalent in terms of functionality and their usage here, there is no change in behavior due to this modification. Although there is an additional parameter null supplied to setLifeTheUniverseAndEverything, without knowing the exact implementation details of this method, it is impossible to predict whether this leads to any behavior change from the perspective of this API. Therefore, based on the information given and the scope of the API, we cannot conclude there is a Compatibility Issue, therefore the response is 0."
439,<android.os.Parcel: ArrayList readArrayList(ClassLoader)>,32,33,,,,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    ArrayList l = new ArrayList(N);
    readListInternal(l, N, loader);
    return l;
}","{
    return readArrayListInternal(loader, /* clazz */
    null);
}",1,"/**
 * Read and return a new ArrayList object from the parcel at the current
 * dataPosition().  Returns null if the previously written list object was
 * null.  The given class loader will be used to load any enclosed
 * Parcelables.
 */
","/**
 * Read and return a new ArrayList object from the parcel at the current
 * dataPosition().  Returns null if the previously written list object was
 * null.  The given class loader will be used to load any enclosed
 * Parcelables.
 *
 * @deprecated Use the type-safer version {@link #readArrayList(ClassLoader, Class)} starting
 * from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the format to
 * use {@link #createTypedArrayList(Parcelable.Creator)} if possible (eg. if the items'
 * class is final) since this is also more performant. Note that changing to the latter
 * also requires changing the writes.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,5,0,"The implementation of the method changed by calling another method, readArrayListInternal(loader, /* clazz */ null), instead of implementing the functionality in the method itself. This indicates that there is a dependency on the changed internal method, so the change type is 5.","Although the underlying implementation has been changed, the method signature, annotations, and externally expected behavior of the method appears to remain consistent between the two versions. Assuming that readArrayListInternal correctly handles the creation of the ArrayList in the same way as the early implementation did, there should be no compatibility issue resulting from this change. Therefore, CI type is 0."
441,<android.os.PowerManager: boolean isIgnoringBatteryOptimizations(String)>,32,33,,,,"{
    return getPowerWhitelistManager().isWhitelisted(packageName, true);
}","{
    return getPowerExemptionManager().isAllowListed(packageName, true);
}",1,"/**
 * Return whether the given application package name is on the device's power allowlist.
 * Apps can be placed on the allowlist through the settings UI invoked by
 * {@link android.provider.Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS}.
 * <p>Being on the power allowlist means that the system will not apply most power saving
 * features to the app. Guardrails for extreme cases may still be applied.
 */
","/**
 * Return whether the given application package name is on the device's power allowlist.
 * Apps can be placed on the allowlist through the settings UI invoked by
 * {@link android.provider.Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS}.
 * <p>Being on the power allowlist means that the system will not apply most power saving
 * features to the app. Guardrails for extreme cases may still be applied.
 */
",0,,,0,,,,,,,5,1,"The implementation has changed from calling getPowerWhitelistManager().isWhitelisted to calling getPowerExemptionManager().isAllowListed, which indicates a change in the dependent API, so the code change type is 5.","Since the dependent API has changed, it could potentially lead to the API returning a different value, and therefore the CI type is 1."
444,<android.app.UiAutomation: AccessibilityNodeInfo getRootInActiveWindow()>,32,33,,,,"{
    final int connectionId;
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        connectionId = mConnectionId;
    }
    // Calling out without a lock held.
    return AccessibilityInteractionClient.getInstance().getRootInActiveWindow(connectionId);
}","{
    final int connectionId;
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        connectionId = mConnectionId;
    }
    // Calling out without a lock held.
    return AccessibilityInteractionClient.getInstance().getRootInActiveWindow(connectionId, AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS_HYBRID);
}",1,"/**
 * Gets the root {@link AccessibilityNodeInfo} in the active window.
 *
 * @return The root info.
 * @throws IllegalStateException If the connection to the accessibility subsystem is not
 * established.
 */
","/**
 * Gets the root {@link AccessibilityNodeInfo} in the active window.
 *
 * @return The root info.
 * @throws IllegalStateException If the connection to the accessibility subsystem is not
 * established.
 */
",0,,,0,,,,,,,"1,5",1,"A new parameter (AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS_HYBRID) has been added to the method call of getRootInActiveWindow(). There is a change in the dependent API (getRootInActiveWindow of AccessibilityInteractionClient), hence the code change is classified as 1,5.","The introduction of a new parameter in the dependent API call could potentially change the return value of the method, since now a different overload of getRootInActiveWindow is being called which may behave differently. Therefore, there is a potential Compatibility Issue due to a different return value, which is type 1."
445,"<android.view.contentcapture.DataRemovalRequest.Builder: Builder addLocusId(LocusId,int)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkState(!mForEverything, ""Already is for everything"");
    Preconditions.checkNotNull(locusId);
    if (mLocusIds == null) {
        mLocusIds = new ArrayList<>();
        mFlags = new IntArray();
    }
    mLocusIds.add(locusId);
    mFlags.add(flags);
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkState(!mForEverything, ""Already is for everything"");
    Objects.requireNonNull(locusId);
    if (mLocusIds == null) {
        mLocusIds = new ArrayList<>();
        mFlags = new IntArray();
    }
    mLocusIds.add(locusId);
    mFlags.add(flags);
    return this;
}",1,"/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
","/**
 * Request service to remove data associated with a given {@link LocusId}.
 *
 * @param locusId the {@link LocusId} being requested to be removed.
 * @param flags either {@link DataRemovalRequest#FLAG_IS_PREFIX} or {@code 0}
 *
 * @return this builder
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,"The only change is the use of Objects.requireNonNull(locusId) to check for null instead of Preconditions.checkNotNull(locusId). This change does not affect the API's behavior since both methods serve the same purpose and will have the same effect (to ensure that the input `locusId` is not null). Therefore, the code change type is 4.","There is no Compatibility Issue since the method Preconditions.checkNotNull and Objects.requireNonNull are interchangeable for the purpose of null-checking, so the behavior of the API will not change."
446,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews,InlinePresentation)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null);
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(presentation, ""presentation cannot be null"");
    Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null, null, null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and an {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions,
 * this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"4,5",0,"The method Preconditions.checkNotNull() is replaced with Objects.requireNonNull(), and while they serve the same purpose there is a change in the dependent method. Additionally, the setLifeTheUniverseAndEverything() method in the late version has three more null parameters than in the early version, which indicates the dependent API has changed - from both aspects, the method call and the parameter list.",#CI_description
447,<android.text.PrecomputedText.Params: boolean equals(Object)>,32,33,,,,"{
    if (o == this) {
        return true;
    }
    if (o == null || !(o instanceof Params)) {
        return false;
    }
    Params param = (Params) o;
    return checkResultUsable(param.mPaint, param.mTextDir, param.mBreakStrategy, param.mHyphenationFrequency) == Params.USABLE;
}","{
    if (o == this) {
        return true;
    }
    if (o == null || !(o instanceof Params)) {
        return false;
    }
    Params param = (Params) o;
    return checkResultUsable(param.mPaint, param.mTextDir, param.mBreakStrategy, param.mHyphenationFrequency, param.mLineBreakConfig) == Params.USABLE;
}",1,"/**
 * Check if the same text layout.
 *
 * @return true if this and the given param result in the same text layout
 */
","/**
 * Check if the same text layout.
 *
 * @return true if this and the given param result in the same text layout
 */
",0,[@Override],[@Override],0,,,,,,,"1,5",1,"The `equals` method's return statement has changed because it includes an additional parameter `param.mLineBreakConfig` in the call to `checkResultUsable` in the late version. Also, this introduction of an additional parameter indicates a dependency on the parameter list of `checkResultUsable`, thus the code change types are 1,5.","Because the change modifies what is compared within the `equals` method (an additional parameter `param.mLineBreakConfig` is considered), this could potentially lead to different outcomes of the equality check, resulting in different boolean return values. The API could thus behave differently and a CI may occur due to potentially different return values, hence the CI type is 1."
448,<android.hardware.soundtrigger.SoundTrigger.RecognitionEvent: boolean equals(Object)>,32,33,,,,"{
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    RecognitionEvent other = (RecognitionEvent) obj;
    if (captureAvailable != other.captureAvailable)
        return false;
    if (captureDelayMs != other.captureDelayMs)
        return false;
    if (capturePreambleMs != other.capturePreambleMs)
        return false;
    if (captureSession != other.captureSession)
        return false;
    if (!Arrays.equals(data, other.data))
        return false;
    if (soundModelHandle != other.soundModelHandle)
        return false;
    if (status != other.status)
        return false;
    if (triggerInData != other.triggerInData)
        return false;
    if (captureFormat == null) {
        if (other.captureFormat != null)
            return false;
    } else {
        if (other.captureFormat == null)
            return false;
        if (captureFormat.getSampleRate() != other.captureFormat.getSampleRate())
            return false;
        if (captureFormat.getEncoding() != other.captureFormat.getEncoding())
            return false;
        if (captureFormat.getChannelMask() != other.captureFormat.getChannelMask())
            return false;
    }
    return true;
}","{
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    RecognitionEvent other = (RecognitionEvent) obj;
    if (captureAvailable != other.captureAvailable)
        return false;
    if (captureDelayMs != other.captureDelayMs)
        return false;
    if (capturePreambleMs != other.capturePreambleMs)
        return false;
    if (captureSession != other.captureSession)
        return false;
    if (!Arrays.equals(data, other.data))
        return false;
    if (recognitionStillActive != other.recognitionStillActive)
        return false;
    if (soundModelHandle != other.soundModelHandle)
        return false;
    if (status != other.status)
        return false;
    if (triggerInData != other.triggerInData)
        return false;
    if (captureFormat == null) {
        if (other.captureFormat != null)
            return false;
    } else {
        if (other.captureFormat == null)
            return false;
        if (captureFormat.getSampleRate() != other.captureFormat.getSampleRate())
            return false;
        if (captureFormat.getEncoding() != other.captureFormat.getEncoding())
            return false;
        if (captureFormat.getChannelMask() != other.captureFormat.getChannelMask())
            return false;
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,1,"The code change includes a modification to one of the comparison checks within the method: instead of comparing captureSession, the late version is comparing recognitionStillActive. This is a change in a non-control part of the method (neither return nor exception handling nor control dependency), so the change type is 4.","This change affects the conditions under which the method returns false, meaning that the objects' equality comparison logic has been altered. Because the equals method can potentially return a different result for the same inputs compared to the previous version, the CI type is 1."
449,<android.os.Parcel: Object readValue(ClassLoader)>,32,33,,,,"{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable(loader);
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        case VAL_PERSISTABLEBUNDLE:
            return readPersistableBundle(loader);
        case VAL_SIZE:
            return readSize();
        case VAL_SIZEF:
            return readSizeF();
        case VAL_DOUBLEARRAY:
            return createDoubleArray();
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException(""Parcel "" + this + "": Unmarshalling unknown type code "" + type + "" at offset "" + off);
    }
}","{
    return readValue(loader, /* clazz */
    null);
}",1,"/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
","/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,"4,5",0,"The entire switch statement has been replaced by a single return statement calling readValue(loader, /* clazz */ null). The readValue function is likely a dependent API that has changed or been introduced to handle the logic encapsulated in the former switch statement, so the change types are 4 and 5.","There is no indication that the behavior of readValue has changed in a way that would cause a Compatibility Issue. Without evidence that readValue's internals lead to different behaviors or outcomes, we assume that the encapsulation is functionally equivalent to the former implementation. Therefore, no Compatibility Issue is detected."
450,<android.view.ScrollCaptureConnection.SafeCallback: void maybeAccept(Consumer<T>)>,32,33,,,,"{
    if (mExecuted) {
        return;
    }
    mExecuted = true;
    if (mSignal.isCanceled()) {
        return;
    }
    T target = mTargetRef.get();
    if (target == null) {
        return;
    }
    mExecutor.execute(() -> targetConsumer.accept(target));
}","{
    T value = mValue.getAndSet(null);
    if (mSignal.isCanceled()) {
        return;
    }
    if (value != null) {
        mExecutor.execute(() -> consumer.accept(value));
    }
}",1,"// and only if noy cancelled, and the target is still available (not collected)
","// Provide the value to the consumer to accept only once.
",1,,,0,,,,,,,"1,3,4",1,"The early version has a check for `mExecuted`, a reference check `mTargetRef.get()`, and includes setting `mExecuted` to true, none of which are present in the late version. The late version introduces a new `mValue.getAndSet(null)` call. These are substantial changes in the code behavior, hence the changes are of type 1 (Return statement changed due to the deletion of the `return` statements related to `mExecuted` and `mTargetRef.get()`), type 3 (Control dependency changed because of the removal and addition of several conditional statements), and type 4 (Other statement changed due to the assignment `mExecuted = true;` being removed and `mValue.getAndSet(null)` being introduced).","The late version no longer checks if the operation has already been executed or if the weak reference still holds its target, and uses a different mechanism (`mValue.getAndSet(null)`) to determine if the action should proceed. Additionally, the method of obtaining the target to consume and the structure of the method's control flow have changed. These alterations can lead to the method behaving differently, like executing `consumer.accept(value)` when it wouldn't have in the early version, or not executing it when it would have. This can cause different return values (due to guarded return statements being removed) and different side effects (due to changes in the conditions that lead to the execution of the consumer), so the CI type is 1."
452,<android.companion.AssociationRequest: String toString()>,32,33,,,,"{
    return ""AssociationRequest { "" + ""singleDevice = "" + mSingleDevice + "", "" + ""deviceFilters = "" + mDeviceFilters + "", "" + ""deviceProfile = "" + mDeviceProfile + "", "" + ""callingPackage = "" + mCallingPackage + "", "" + ""deviceProfilePrivilegesDescription = "" + mDeviceProfilePrivilegesDescription + "", "" + ""creationTime = "" + mCreationTime + "", "" + ""skipPrompt = "" + mSkipPrompt + "" }"";
}","{
    return ""AssociationRequest { "" + ""singleDevice = "" + mSingleDevice + "", "" + ""deviceFilters = "" + mDeviceFilters + "", "" + ""deviceProfile = "" + mDeviceProfile + "", "" + ""displayName = "" + mDisplayName + "", "" + ""selfManaged = "" + mSelfManaged + "", "" + ""forceConfirmation = "" + mForceConfirmation + "", "" + ""packageName = "" + mPackageName + "", "" + ""userId = "" + mUserId + "", "" + ""deviceProfilePrivilegesDescription = "" + mDeviceProfilePrivilegesDescription + "", "" + ""creationTime = "" + mCreationTime + "", "" + ""skipPrompt = "" + mSkipPrompt + "" }"";
}",1,,,0,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",0,,,,,,,"1,4",1,"The code change involves modifying the content of the string being returned, by removing some member variables and adding new ones in the return statement. So, the code change type is 1 for change in return value and 4 for other statement change.","Since the toString() implementation now returns a String with different content, it will produce a different return value when called. Thus, the CI type is 1."
455,"<android.view.Choreographer: void doFrame(long,int,VsyncEventData)>",32,33,,,,"{
    final long startNanos;
    final long frameIntervalNanos = vsyncEventData.frameInterval;
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame "" + vsyncEventData.id);
        }
        synchronized (mLock) {
            if (!mFrameScheduled) {
                traceMessage(""Frame not scheduled"");
                // no work to do
                return;
            }
            if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
                mDebugPrintNextFrameTimeDelta = false;
                Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
            }
            long intendedFrameTimeNanos = frameTimeNanos;
            startNanos = System.nanoTime();
            final long jitterNanos = startNanos - frameTimeNanos;
            if (jitterNanos >= frameIntervalNanos) {
                final long skippedFrames = jitterNanos / frameIntervalNanos;
                if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                    Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main thread."");
                }
                final long lastFrameOffset = jitterNanos % frameIntervalNanos;
                if (DEBUG_JANK) {
                    Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (frameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
                }
                frameTimeNanos = startNanos - lastFrameOffset;
            }
            if (frameTimeNanos < mLastFrameTimeNanos) {
                if (DEBUG_JANK) {
                    Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
                }
                traceMessage(""Frame time goes backward"");
                scheduleVsyncLocked();
                return;
            }
            if (mFPSDivisor > 1) {
                long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;
                if (timeSinceVsync < (frameIntervalNanos * mFPSDivisor) && timeSinceVsync > 0) {
                    traceMessage(""Frame skipped due to FPSDivisor"");
                    scheduleVsyncLocked();
                    return;
                }
            }
            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos, vsyncEventData.id, vsyncEventData.frameDeadline, startNanos, vsyncEventData.frameInterval);
            mFrameScheduled = false;
            mLastFrameTimeNanos = frameTimeNanos;
            mLastFrameIntervalNanos = frameIntervalNanos;
            mLastVsyncEventData = vsyncEventData;
        }
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos, frameIntervalNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos, frameIntervalNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos, frameIntervalNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}","{
    final long startNanos;
    final long frameIntervalNanos = vsyncEventData.frameInterval;
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""Choreographer#doFrame "" + vsyncEventData.preferredFrameTimeline().vsyncId);
        }
        FrameData frameData = new FrameData(frameTimeNanos, vsyncEventData);
        synchronized (mLock) {
            if (!mFrameScheduled) {
                traceMessage(""Frame not scheduled"");
                // no work to do
                return;
            }
            if (DEBUG_JANK && mDebugPrintNextFrameTimeDelta) {
                mDebugPrintNextFrameTimeDelta = false;
                Log.d(TAG, ""Frame time delta: "" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + "" ms"");
            }
            long intendedFrameTimeNanos = frameTimeNanos;
            startNanos = System.nanoTime();
            final long jitterNanos = startNanos - frameTimeNanos;
            if (jitterNanos >= frameIntervalNanos) {
                long lastFrameOffset = 0;
                if (frameIntervalNanos == 0) {
                    Log.i(TAG, ""Vsync data empty due to timeout"");
                } else {
                    lastFrameOffset = jitterNanos % frameIntervalNanos;
                    final long skippedFrames = jitterNanos / frameIntervalNanos;
                    if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                        Log.i(TAG, ""Skipped "" + skippedFrames + "" frames!  "" + ""The application may be doing too much work on its main "" + ""thread."");
                    }
                    if (DEBUG_JANK) {
                        Log.d(TAG, ""Missed vsync by "" + (jitterNanos * 0.000001f) + "" ms "" + ""which is more than the frame interval of "" + (frameIntervalNanos * 0.000001f) + "" ms!  "" + ""Skipping "" + skippedFrames + "" frames and setting frame "" + ""time to "" + (lastFrameOffset * 0.000001f) + "" ms in the past."");
                    }
                }
                frameTimeNanos = startNanos - lastFrameOffset;
                frameData.updateFrameData(frameTimeNanos);
            }
            if (frameTimeNanos < mLastFrameTimeNanos) {
                if (DEBUG_JANK) {
                    Log.d(TAG, ""Frame time appears to be going backwards.  May be due to a "" + ""previously skipped frame.  Waiting for next vsync."");
                }
                traceMessage(""Frame time goes backward"");
                scheduleVsyncLocked();
                return;
            }
            if (mFPSDivisor > 1) {
                long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;
                if (timeSinceVsync < (frameIntervalNanos * mFPSDivisor) && timeSinceVsync > 0) {
                    traceMessage(""Frame skipped due to FPSDivisor"");
                    scheduleVsyncLocked();
                    return;
                }
            }
            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos, vsyncEventData.preferredFrameTimeline().vsyncId, vsyncEventData.preferredFrameTimeline().deadline, startNanos, vsyncEventData.frameInterval);
            mFrameScheduled = false;
            mLastFrameTimeNanos = frameTimeNanos;
            mLastFrameIntervalNanos = frameIntervalNanos;
            mLastVsyncEventData = vsyncEventData;
        }
        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);
        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameData, frameIntervalNanos);
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameData, frameIntervalNanos);
        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameData, frameIntervalNanos);
        doCallbacks(Choreographer.CALLBACK_COMMIT, frameData, frameIntervalNanos);
    } finally {
        AnimationUtils.unlockAnimationClock();
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
    if (DEBUG_FRAMES) {
        final long endNanos = System.nanoTime();
        Log.d(TAG, ""Frame "" + frame + "": Finished, took "" + (endNanos - startNanos) * 0.000001f + "" ms, latency "" + (startNanos - frameTimeNanos) * 0.000001f + "" ms."");
    }
}",1,,,0,,,0,,,,,,,,,,
456,<android.os.SystemClock: boolean setCurrentTimeMillis(long)>,32,33,,,,"{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        Slog.e(TAG, ""Unable to set RTC: mgr == null"");
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    } catch (SecurityException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    }
    return false;
}","{
    final IAlarmManager mgr = getIAlarmManager();
    if (mgr == null) {
        Slog.e(TAG, ""Unable to set RTC: mgr == null"");
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    } catch (SecurityException e) {
        Slog.e(TAG, ""Unable to set RTC"", e);
    }
    return false;
}",1,"/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
","/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
",0,,,0,,,,,,,"4,5",0,"The only change here is that the method to get the `IAlarmManager` service changed from `IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE))` to a call to a presumably new method `getIAlarmManager()`. As this is neither a return statement change, exception handing change, nor a control dependency change, the change type is 4. There is also a change in a dependent API, since it now calls `getIAlarmManager()` instead of using `ServiceManager` directly, thus the change type also includes 5.","There's no direct indication that replacing `ServiceManager.getService(Context.ALARM_SERVICE)` with `getIAlarmManager()` would lead to a different return value or change the exception handling. This appears to be an internal refactoring, so it should not affect the API's external behavior. Therefore, there is no compatibility issue: CI type is 0."
457,"<android.service.voice.VoiceInteractionSession: void performDirectAction(DirectAction,Bundle,CancellationSignal,Executor,Consumer<Bundle>)>",32,33,,,,"{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    Preconditions.checkNotNull(resultExecutor);
    Preconditions.checkNotNull(resultListener);
    if (cancellationSignal != null) {
        cancellationSignal.throwIfCanceled();
    }
    final RemoteCallback cancellationCallback = (cancellationSignal != null) ? new RemoteCallback(createSafeResultListener(b -> {
        if (b != null) {
            final IBinder cancellation = b.getBinder(VoiceInteractor.KEY_CANCELLATION_SIGNAL);
            if (cancellation != null) {
                cancellationSignal.setRemote(ICancellationSignal.Stub.asInterface(cancellation));
            }
        }
    })) : null;
    final RemoteCallback resultCallback = new RemoteCallback(createSafeResultListener(b -> {
        if (b != null) {
            resultExecutor.execute(() -> resultListener.accept(b));
        } else {
            resultExecutor.execute(() -> resultListener.accept(Bundle.EMPTY));
        }
    }));
    try {
        mSystemService.performDirectAction(mToken, action.getId(), extras, action.getTaskId(), action.getActivityId(), cancellationCallback, resultCallback);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}","{
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    Objects.requireNonNull(resultExecutor);
    Objects.requireNonNull(resultListener);
    if (cancellationSignal != null) {
        cancellationSignal.throwIfCanceled();
    }
    final RemoteCallback cancellationCallback = (cancellationSignal != null) ? new RemoteCallback(createSafeResultListener(b -> {
        if (b != null) {
            final IBinder cancellation = b.getBinder(VoiceInteractor.KEY_CANCELLATION_SIGNAL);
            if (cancellation != null) {
                cancellationSignal.setRemote(ICancellationSignal.Stub.asInterface(cancellation));
            }
        }
    })) : null;
    final RemoteCallback resultCallback = new RemoteCallback(createSafeResultListener(b -> {
        if (b != null) {
            resultExecutor.execute(() -> resultListener.accept(b));
        } else {
            resultExecutor.execute(() -> resultListener.accept(Bundle.EMPTY));
        }
    }));
    try {
        mSystemService.performDirectAction(mToken, action.getId(), extras, action.getTaskId(), action.getActivityId(), cancellationCallback, resultCallback);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}",1,"/**
 * Asks that an action be performed by the app. This will send a request to the app which
 * provided this action.
 *
 * <p> An action could take time to execute and the result is provided asynchronously
 * via a callback. If the action is taking longer and you want to cancel its execution
 * you can pass in a cancellation signal through which to notify the app to abort the
 * action.
 *
 * @param action The action to be performed.
 * @param extras Any optional extras sent to the app as part of the request
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none.
 * @param resultExecutor The handler to receive the callback.
 * @param resultListener The callback to receive the response.
 *
 * @see #requestDirectActions(ActivityId, CancellationSignal, Executor, Consumer)
 * @see Activity#onGetDirectActions(CancellationSignal, Consumer)
 */
","/**
 * Asks that an action be performed by the app. This will send a request to the app which
 * provided this action.
 *
 * <p> An action could take time to execute and the result is provided asynchronously
 * via a callback. If the action is taking longer and you want to cancel its execution
 * you can pass in a cancellation signal through which to notify the app to abort the
 * action.
 *
 * @param action The action to be performed.
 * @param extras Any optional extras sent to the app as part of the request
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none.
 * @param resultExecutor The handler to receive the callback.
 * @param resultListener The callback to receive the response.
 *
 * @see #requestDirectActions(ActivityId, CancellationSignal, Executor, Consumer)
 * @see Activity#onGetDirectActions(CancellationSignal, Consumer)
 */
",0,,,0,,,,,,,4,0,"The method `Preconditions.checkNotNull` has been replaced by `Objects.requireNonNull` which serves the same purpose and has the same behavior, so the code change type is 4 (Other statement changed).","There is no Compatibility Issue due to this code change as both methods are designed to perform the same operation, which is to check for null references and throw a NullPointerException if a null is passed. Therefore, the behavior of the API remains the same, leading to the CI type 0 (No Compatibility Issue)."
460,<android.service.autofill.FillResponse.Builder: Builder setFooter(RemoteViews)>,32,33,,,,"{
    throwIfDestroyed();
    throwIfAuthenticationCalled();
    mFooter = Preconditions.checkNotNull(footer);
    return this;
}","{
    throwIfDestroyed();
    throwIfAuthenticationCalled();
    mFooter = Objects.requireNonNull(footer);
    return this;
}",1,"// TODO(b/69796626): make it sticky / update javadoc
","// TODO(b/69796626): make it sticky / update javadoc
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"The statement changed from Preconditions.checkNotNull(footer) to Objects.requireNonNull(footer), which are both used for null checking and will throw the same type of exception (NullPointerException) if footer is null. This is a change in the dependent API, so the code change type is 4,5.",There is No Compatibility Issue because the behavior of the method has not changed; both versions will throw a NullPointerException if footer is null.
461,<android.view.contentcapture.ContentCaptureSession: void notifyViewAppeared(ViewStructure)>,32,33,,,,"{
    Preconditions.checkNotNull(node);
    if (!isContentCaptureEnabled())
        return;
    if (!(node instanceof ViewNode.ViewStructureImpl)) {
        throw new IllegalArgumentException(""Invalid node class: "" + node.getClass());
    }
    internalNotifyViewAppeared((ViewStructureImpl) node);
}","{
    Objects.requireNonNull(node);
    if (!isContentCaptureEnabled())
        return;
    if (!(node instanceof ViewNode.ViewStructureImpl)) {
        throw new IllegalArgumentException(""Invalid node class: "" + node.getClass());
    }
    internalNotifyViewAppeared((ViewStructureImpl) node);
}",1,"/**
 * Notifies the Content Capture Service that a node has been added to the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for views that return {@code true} on
 * {@link View#onProvideContentCaptureStructure(ViewStructure, int)}.
 *
 * @param node node that has been added.
 */
","/**
 * Notifies the Content Capture Service that a node has been added to the view structure.
 *
 * <p>Typically called ""manually"" by views that handle their own virtual view hierarchy, or
 * automatically by the Android System for views that return {@code true} on
 * {@link View#onProvideContentCaptureStructure(ViewStructure, int)}.
 *
 * @param node node that has been added.
 */
",0,,,0,,,,,,,4,0,"The only code change is the replacement of Preconditions.checkNotNull(node) with Objects.requireNonNull(node), which are equivalent and thus have no effect on the behavior of the method. Therefore, the change type is 4.","Both methods Preconditions.checkNotNull(node) and Objects.requireNonNull(node) serve the same purpose of checking if an object reference is null and throw a NullPointerException if it is. There are no differences in the behavior pertaining to compatibility, so there is no Compatibility Issue, which is indicated by 0."
462,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int,boolean,ColorManagementProxy)>",32,33,,,,"{
    if (mService != null) {
        try {
            if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                return null;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    synchronized (this) {
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId && !mCachedWallpaper.isRecycled()) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
        try {
            mCachedWallpaper = getCurrentWallpaperLocked(context, userId, hardware, cmProxy);
            mCachedWallpaperUserId = userId;
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""Out of memory loading the current wallpaper: "" + e);
        } catch (SecurityException e) {
            if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.O_MR1) {
                Log.w(TAG, ""No permission to access wallpaper, suppressing"" + "" exception to avoid crashing legacy app."");
            } else {
                // Post-O apps really most sincerely need the permission.
                throw e;
            }
        }
        if (mCachedWallpaper != null) {
            return mCachedWallpaper;
        }
    }
    if (returnDefault) {
        Bitmap defaultWallpaper = mDefaultWallpaper;
        if (defaultWallpaper == null || defaultWallpaper.isRecycled()) {
            defaultWallpaper = getDefaultWallpaper(context, which);
            synchronized (this) {
                mDefaultWallpaper = defaultWallpaper;
            }
        }
        return defaultWallpaper;
    }
    return null;
}","{
    if (mService != null) {
        try {
            if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                return null;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    synchronized (this) {
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId && !mCachedWallpaper.isRecycled()) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
    }
    try {
        Bitmap currentWallpaper = getCurrentWallpaperLocked(context, userId, hardware, cmProxy);
        if (currentWallpaper != null) {
            synchronized (this) {
                mCachedWallpaper = currentWallpaper;
                mCachedWallpaperUserId = userId;
                return mCachedWallpaper;
            }
        }
    } catch (OutOfMemoryError e) {
        Log.w(TAG, ""Out of memory loading the current wallpaper: "" + e);
    } catch (SecurityException e) {
        if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.O_MR1) {
            Log.w(TAG, ""No permission to access wallpaper, suppressing"" + "" exception to avoid crashing legacy app."");
        } else {
            // Post-O apps really most sincerely need the permission.
            throw e;
        }
    }
    if (returnDefault) {
        Bitmap defaultWallpaper = mDefaultWallpaper;
        if (defaultWallpaper == null || defaultWallpaper.isRecycled()) {
            defaultWallpaper = getDefaultWallpaper(context, which);
            synchronized (this) {
                mDefaultWallpaper = defaultWallpaper;
            }
        }
        return defaultWallpaper;
    }
    return null;
}",1,,,0,,,0,,,,,,,"1,3",1,"In the late version, the assignment and check of `mCachedWallpaper` have been extracted out of the `synchronized` block. Additionally, there is a rearrangement in the control flow of how `getCurrentWallpaperLocked` is called, which constitutes a control dependency change. Return statement change is also present because the code that assigns `mCachedWallpaper` and returns it has been moved outside of the synchronized block to outside the try-catch block, altering the circumstances under which the value can be returned. ",These modifications could potentially lead to a Compatibility Issue by returning a different value as the late version may update `mCachedWallpaper` and `mCachedWallpaperUserId` with a non-null bitmap outside of the synchronized block that wasn't handled in the early version.
463,<android.content.integrity.AppInstallMetadata.Builder: AppInstallMetadata build()>,32,33,,,,"{
    Objects.requireNonNull(mPackageName);
    Objects.requireNonNull(mAppCertificates);
    return new AppInstallMetadata(this);
}","{
    Objects.requireNonNull(mPackageName);
    Objects.requireNonNull(mAppCertificates);
    Objects.requireNonNull(mAppCertificateLineage);
    return new AppInstallMetadata(this);
}",1,"/**
 * Build {@link AppInstallMetadata}.
 *
 * @throws IllegalArgumentException if package name or app certificate is null
 */
","/**
 * Build {@link AppInstallMetadata}.
 *
 * @throws IllegalArgumentException if package name or app certificate is null
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,"The change is the addition of a new requireNonNull call on mAppCertificateLineage in the late implementation. This change is not in the return statement, exception handling, or control dependency, which makes it 4) Other statement changed.","The added validation of mAppCertificateLineage using requireNonNull would only affect the behavior of the method if mAppCertificateLineage were null. However, this change enforces the method's precondition that mAppCertificateLineage should not be null, which is consistent with the use of requireNonNull on other fields. As the change does not affect the method's return type, value, or the exceptions it might throw under normal circumstances (where mAppCertificateLineage is not null), there's no Compatibility Issue; thus, the CI type is 0)."
464,<android.widget.Editor.InsertionPointCursorController: void onTouchEvent(MotionEvent)>,32,33,,,,"{
    if (hasSelectionController() && getSelectionController().isCursorBeingModified()) {
        return;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_MOVE:
            if (event.isFromSource(InputDevice.SOURCE_MOUSE)) {
                break;
            }
            if (mIsDraggingCursor) {
                performCursorDrag(event);
            } else if (mFlagCursorDragFromAnywhereEnabled && mTextView.getLayout() != null && mTextView.isFocused() && mTouchState.isMovedEnoughForDrag() && (mTouchState.getInitialDragDirectionXYRatio() > mCursorDragDirectionMinXYRatio || mTouchState.isOnHandle())) {
                startCursorDrag(event);
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            if (mIsDraggingCursor) {
                endCursorDrag(event);
            }
            break;
    }
}","{
    if (hasSelectionController() && getSelectionController().isCursorBeingModified()) {
        return;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_MOVE:
            if (event.isFromSource(InputDevice.SOURCE_MOUSE) || (mTextView.isAutoHandwritingEnabled() && isFromStylus(event))) {
                break;
            }
            if (mIsDraggingCursor) {
                performCursorDrag(event);
            } else if (mFlagCursorDragFromAnywhereEnabled && mTextView.getLayout() != null && mTextView.isFocused() && mTouchState.isMovedEnoughForDrag() && (mTouchState.getInitialDragDirectionXYRatio() > mCursorDragDirectionMinXYRatio || mTouchState.isOnHandle())) {
                startCursorDrag(event);
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            if (mIsDraggingCursor) {
                endCursorDrag(event);
            }
            break;
    }
}",1,,,0,,,0,,,,,,,3,0,"An additional condition `mTextView.isAutoHandwritingEnabled() && isFromStylus(event)` has been added to the `if` statement within the `ACTION_MOVE` case block, so the change type is control dependency change (3).","The change to the condition only affects whether the subsequent code within that case block is executed or skipped. Since no new behavior is introduced, no new return values, and no new exceptions are thrown for any of the cases, there is no Compatibility Issue (0)."
465,<android.widget.TextView: Params getTextMetricsParams()>,32,33,,,,"{
    return new PrecomputedText.Params(new TextPaint(mTextPaint), getTextDirectionHeuristic(), mBreakStrategy, mHyphenationFrequency);
}","{
    return new PrecomputedText.Params(new TextPaint(mTextPaint), LineBreakConfig.getLineBreakConfig(mLineBreakStyle, mLineBreakWordStyle), getTextDirectionHeuristic(), mBreakStrategy, mHyphenationFrequency);
}",1,"/**
 * Gets the parameters for text layout precomputation, for use with {@link PrecomputedText}.
 *
 * @return a current {@link PrecomputedText.Params}
 * @see PrecomputedText
 */
","/**
 * Gets the parameters for text layout precomputation, for use with {@link PrecomputedText}.
 *
 * @return a current {@link PrecomputedText.Params}
 * @see PrecomputedText
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,5",1,"The constructor of PrecomputedText.Params in the return statement is invoked with different parameters. In the late version, it includes LineBreakConfig.getLineBreakConfig(mLineBreakStyle, mLineBreakWordStyle). This indicates not only that the return statement changed (with an additional parameter), but also that the late version API relies on a new dependent API, LineBreakConfig.getLineBreakConfig, thus the code change type is 1,5.","The change in the parameters for PrecomputedText.Params will result in a different return type or value, as an additional configuration is provided which will affect text layout related properties. Thus, the change could induce a compatibility issue by potentially causing a different return value, leading to CI type 1."
466,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,32,33,,,,"{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addAllDisplaysLocked(mTempDisplays, displayIds);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_EXTERNAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_INTERNAL);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}","{
    boolean includeDisabledDisplays = (category != null && category.equals(DISPLAY_CATEGORY_ALL_INCLUDING_DISABLED));
    final int[] displayIds = mGlobal.getDisplayIds(includeDisabledDisplays);
    synchronized (mLock) {
        try {
            if (category != null && category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_EXTERNAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_INTERNAL);
            } else if ((category == null || DISPLAY_CATEGORY_ALL_INCLUDING_DISABLED.equals(category))) {
                // All displays requested.
                addAllDisplaysLocked(mTempDisplays, displayIds);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}",1,"/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
","/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
",0,,,0,,,,,,,"1,3,5",1,"The control structure has been modified to include a new condition to check for 'DISPLAY_CATEGORY_ALL_INCLUDING_DISABLED' and also the call to getDisplayIds() now includes a parameter, which alters the number of displayIds returned based on the passed category. This change in logic and dependent API call leads to types 1, 3, and 5.  ","Since there is a new behavior introduced, which includes disabled displays when 'DISPLAY_CATEGORY_ALL_INCLUDING_DISABLED' is passed, and the change in control structure along with the altered call to getDisplayIds(), the API could potentially return a different set of Display objects. Therefore, the compatibility issue type is 1."
468,"<android.content.res.TypedArray: float getFraction(int,int,int,float)>",32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to fraction: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value + "", theme="" + mTheme);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to fraction: type=0x"" + Integer.toHexString(type) + "", theme="" + mTheme);
}",1,"/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */
","/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */
",0,,,0,,,,,,,4,0,"The change occurs in two exception messages, concatenating "", theme="" + mTheme to the existing strings. This change is only in the exception message string and has no impact on the behavior of the method in terms of returns or thrown exceptions, making it an Other statement changed, code change type 4.","The change in the exception messages does not impact the return values or the type of exceptions thrown, but simply provides additional context in the exception message itself. Thus, there is No Compatibility Issue, CI type 0."
469,"<android.os.PowerComponents.Builder: Builder setUsageDurationForCustomComponentMillis(int,long)>",32,33,,,,"{
    if (componentId < BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID) {
        throw new IllegalArgumentException(""Unsupported custom power component ID: "" + componentId);
    }
    try {
        mUsageDurationsMs[CUSTOM_POWER_COMPONENT_OFFSET + componentId] = componentUsageDurationMillis;
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new IllegalArgumentException(""Unsupported custom power component ID: "" + componentId);
    }
    return this;
}","{
    final int index = componentId - BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID;
    if (index < 0 || index >= mData.layout.customPowerComponentCount) {
        throw new IllegalArgumentException(""Unsupported custom power component ID: "" + componentId);
    }
    mData.putLong(mData.layout.firstCustomUsageDurationColumn + index, componentUsageDurationMillis);
    return this;
}",1,"/**
 * Sets the amount of time used by the specified custom component.
 *
 * @param componentId                  The ID of the custom power component.
 * @param componentUsageDurationMillis Amount of time in milliseconds.
 */
","/**
 * Sets the amount of time used by the specified custom component.
 *
 * @param componentId                  The ID of the custom power component.
 * @param componentUsageDurationMillis Amount of time in milliseconds.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,2,3,5","1,2",The method's implementation has undergone several changes: ,"- The actual statement to store the usage duration has been changed to a call to `mData.putLong` with different parameters, which means that there's a return statement changed (type 1)."
471,"<android.widget.RemoteViews.ViewGroupActionAdd: void apply(View,ViewGroup,InteractionHandler,ColorResources)>",32,33,,,,"{
    final Context context = root.getContext();
    final ViewGroup target = root.findViewById(viewId);
    if (target == null) {
        return;
    }
    // If removeAllViews was called, this returns the next potential recycled view.
    // If there are no more views to recycle (or removeAllViews was not called), this
    // will return -1.
    final int nextChild = getNextRecyclableChild(target);
    RemoteViews rvToApply = mNestedViews.getRemoteViewsToApply(context);
    if (nextChild >= 0 && mStableId != NO_ID) {
        // At that point, the views starting at index nextChild are the ones recyclable but
        // not yet recycled. All views added on that round of application are placed before.
        // Find the next view with the same stable id, or -1.
        int recycledViewIndex = findViewIndexToRecycle(target, rvToApply);
        if (recycledViewIndex >= 0) {
            View child = target.getChildAt(recycledViewIndex);
            if (rvToApply.canRecycleView(child)) {
                if (nextChild < recycledViewIndex) {
                    target.removeViews(nextChild, recycledViewIndex - nextChild);
                }
                setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
                rvToApply.reapply(context, child, handler, null, /* size */
                colorResources, false);
                return;
            }
            // If we cannot recycle the views, we still remove all views in between to
            // avoid weird behaviors and insert the new view in place of the old one.
            target.removeViews(nextChild, recycledViewIndex - nextChild + 1);
        }
    }
    // If we cannot recycle, insert the new view before the next recyclable child.
    // Inflate nested views and add as children
    View nestedView = rvToApply.apply(context, target, handler, null, /* size */
    colorResources);
    if (mStableId != NO_ID) {
        setStableId(nestedView, mStableId);
    }
    target.addView(nestedView, mIndex >= 0 ? mIndex : nextChild);
    if (nextChild >= 0) {
        // If we are at the end, there is no reason to try to recycle anymore
        setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
    }
}","{
    final Context context = root.getContext();
    final ViewGroup target = root.findViewById(viewId);
    if (target == null) {
        return;
    }
    // If removeAllViews was called, this returns the next potential recycled view.
    // If there are no more views to recycle (or removeAllViews was not called), this
    // will return -1.
    final int nextChild = getNextRecyclableChild(target);
    RemoteViews rvToApply = mNestedViews.getRemoteViewsToApply(context);
    int flagsToPropagate = mApplyFlags & FLAG_MASK_TO_PROPAGATE;
    if (flagsToPropagate != 0)
        rvToApply.addFlags(flagsToPropagate);
    if (nextChild >= 0 && mStableId != NO_ID) {
        // At that point, the views starting at index nextChild are the ones recyclable but
        // not yet recycled. All views added on that round of application are placed before.
        // Find the next view with the same stable id, or -1.
        int recycledViewIndex = findViewIndexToRecycle(target, rvToApply);
        if (recycledViewIndex >= 0) {
            View child = target.getChildAt(recycledViewIndex);
            if (rvToApply.canRecycleView(child)) {
                if (nextChild < recycledViewIndex) {
                    target.removeViews(nextChild, recycledViewIndex - nextChild);
                }
                setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
                rvToApply.reapplyNestedViews(context, child, rootParent, handler, null, /* size */
                colorResources);
                return;
            }
            // If we cannot recycle the views, we still remove all views in between to
            // avoid weird behaviors and insert the new view in place of the old one.
            target.removeViews(nextChild, recycledViewIndex - nextChild + 1);
        }
    }
    // If we cannot recycle, insert the new view before the next recyclable child.
    // Inflate nested views and add as children
    View nestedView = rvToApply.applyNestedViews(context, target, rootParent, handler, null, /* size */
    colorResources);
    if (mStableId != NO_ID) {
        setStableId(nestedView, mStableId);
    }
    target.addView(nestedView, mIndex >= 0 ? mIndex : nextChild);
    if (nextChild >= 0) {
        // If we are at the end, there is no reason to try to recycle anymore
        setNextRecyclableChild(target, nextChild + 1, target.getChildCount());
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
474,<android.content.res.TypedArray: ColorStateList getColorStateList(int)>,32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + index + "": "" + value + "", theme="" + mTheme);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}",1,"/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
","/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */
",0,[@Nullable],[@Nullable],0,,,,,,,4,0,"The change in the code is in the exception message string. The message string has additional information ("", theme="" + mTheme) at the end. Thus, the code change type is 4.","The change in the exception message does not affect the behavior of the method in terms of what it returns or the exceptions it throws, so there is no compatibility issue, and the CI type is 0."
475,<android.window.TransitionInfo.AnimationOptions: String toString()>,32,33,,,,"{
    return ""{ AnimationOtions type= "" + typeToString(mType) + "" package="" + mPackageName + "" override="" + mOverrideTaskTransition + "" b="" + mTransitionBounds + ""}"";
}","{
    return ""{ AnimationOptions type= "" + typeToString(mType) + "" package="" + mPackageName + "" override="" + mOverrideTaskTransition + "" b="" + mTransitionBounds + ""}"";
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change is a small typo correction in the string from ""AnimationOtions"" to ""AnimationOptions"" so the change type is 4.",There is no Compatibility Issue as this change does not affect the behavior of the method; it only corrects a typo in a string literal which doesn't alter the logic or functioning of the API.
476,<android.net.VpnManager: void startProvisionedVpnProfile()>,32,33,,,,"{
    try {
        mService.startVpnProfile(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    startProvisionedVpnProfileSession();
}",1,"/**
 * Request the startup of a previously provisioned VPN.
 *
 * @throws SecurityException exception if user or device settings prevent this VPN from being
 * setup, or if user consent has not been granted
 */
","/**
 * Request the startup of a previously provisioned VPN.
 *
 * @throws SecurityException exception if user or device settings prevent this VPN from being
 * setup, or if user consent has not been granted
 * @deprecated This method is replaced by startProvisionedVpnProfileSession which returns a
 * session key for the caller to diagnose the errors.
 */
",1,,[@Deprecated],1,,,,,,,5,0,"The implementation of the method has been completely changed to call another method (startProvisionedVpnProfileSession()). This indicates a change in the dependent API, therefore the change type is 5.","There is no information provided about the implementation of startProvisionedVpnProfileSession(). As such, without knowing whether the new method alters return values or exception handling, it cannot be determined there is a compatibility issue solely based on the information given. Thus, we cannot assume a compatibility issue exists. The CI situation is 0."
479,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,32,33,,,,"{
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_DEPRECATED_API_USED, AUTH_DEPRECATED_APIUSED__DEPRECATED_API__API_FINGERPRINT_MANAGER_IS_HARDWARE_DETECTED, mContext.getApplicationInfo().uid, mContext.getApplicationInfo().targetSdkVersion);
    if (mService != null) {
        try {
            return mService.isHardwareDetectedDeprecated(mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Slog.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}","{
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_DEPRECATED_API_USED, AUTH_DEPRECATED_APIUSED__DEPRECATED_API__API_FINGERPRINT_MANAGER_IS_HARDWARE_DETECTED, mContext.getApplicationInfo().uid, mContext.getApplicationInfo().targetSdkVersion);
    if (mService != null) {
        try {
            return mService.isHardwareDetectedDeprecated(mContext.getOpPackageName(), mContext.getAttributionTag());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Slog.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}",1,"/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}
 */
","/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}
 */
",0,"[@Deprecated, @RequiresPermission(USE_FINGERPRINT)]","[@Deprecated, @RequiresPermission(USE_FINGERPRINT)]",0,,,,,,,"4,5",0,"The method implementation changes by adding a new parameter (mContext.getAttributionTag()) to the dependent API call mService.isHardwareDetectedDeprecated(), which is a change to the dependent API, so the change type is 4,5.","There is no compatibility issue because both versions use a try-catch block for the exact same method call, only with an added parameter that does not affect the behavior seen by the calling method. The additional parameter does not change the nature of the exceptions being caught or the values being returned, thus there is no CI detected."
480,"<android.provider.Settings.Global: float getFloat(ContentResolver,String)>",32,33,,,,"{
    String v = getString(cr, name);
    if (v == null) {
        throw new SettingNotFoundException(name);
    }
    try {
        return Float.parseFloat(v);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    String v = getString(cr, name);
    return parseFloatSetting(v, name);
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
",0,,,0,,,,,,,5,0,"The implementation has been refactored to use a presumably new method parseFloatSetting instead of inlining the parsing logic, so the code change type is 5 (Dependent API changed).","Since the refactoring should not alter the functional behavior and the output of the method is still dictated by the same logic (parsing the string to a float), provided that the new method parseFloatSetting correctly replicates the previous behavior, there is no reason to expect a CI, so the CI type is 0."
481,<android.app.NotificationChannel: boolean equals(Object)>,32,33,,,,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    return getImportance() == that.getImportance() && mBypassDnd == that.mBypassDnd && getLockscreenVisibility() == that.getLockscreenVisibility() && mLights == that.mLights && getLightColor() == that.getLightColor() && getUserLockedFields() == that.getUserLockedFields() && isFgServiceShown() == that.isFgServiceShown() && mVibrationEnabled == that.mVibrationEnabled && mShowBadge == that.mShowBadge && isDeleted() == that.isDeleted() && getDeletedTimeMs() == that.getDeletedTimeMs() && isBlockable() == that.isBlockable() && mAllowBubbles == that.mAllowBubbles && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(mDesc, that.mDesc) && Objects.equals(getSound(), that.getSound()) && Arrays.equals(mVibration, that.mVibration) && Objects.equals(getGroup(), that.getGroup()) && Objects.equals(getAudioAttributes(), that.getAudioAttributes()) && mImportanceLockedByOEM == that.mImportanceLockedByOEM && mImportanceLockedDefaultApp == that.mImportanceLockedDefaultApp && mOriginalImportance == that.mOriginalImportance && Objects.equals(getParentChannelId(), that.getParentChannelId()) && Objects.equals(getConversationId(), that.getConversationId()) && isDemoted() == that.isDemoted() && isImportantConversation() == that.isImportantConversation();
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    return getImportance() == that.getImportance() && mBypassDnd == that.mBypassDnd && getLockscreenVisibility() == that.getLockscreenVisibility() && mLights == that.mLights && getLightColor() == that.getLightColor() && getUserLockedFields() == that.getUserLockedFields() && isFgServiceShown() == that.isFgServiceShown() && mVibrationEnabled == that.mVibrationEnabled && mShowBadge == that.mShowBadge && isDeleted() == that.isDeleted() && getDeletedTimeMs() == that.getDeletedTimeMs() && isBlockable() == that.isBlockable() && mAllowBubbles == that.mAllowBubbles && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(mDesc, that.mDesc) && Objects.equals(getSound(), that.getSound()) && Arrays.equals(mVibration, that.mVibration) && Objects.equals(getGroup(), that.getGroup()) && Objects.equals(getAudioAttributes(), that.getAudioAttributes()) && mImportanceLockedDefaultApp == that.mImportanceLockedDefaultApp && mOriginalImportance == that.mOriginalImportance && Objects.equals(getParentChannelId(), that.getParentChannelId()) && Objects.equals(getConversationId(), that.getConversationId()) && isDemoted() == that.isDemoted() && isImportantConversation() == that.isImportantConversation();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The early and late implementations differ only by one condition, `mImportanceLockedByOEM == that.mImportanceLockedByOEM`, which is present in the early implementation and has been removed in the late implementation. This change is not a return statement, exception handling statement, or control dependency change, hence it's an 'Other statement changed'.","There is no Compatibility Issue since the deleted condition would not result in a different return variable (value or type) or a different exception being thrown under the same circumstances; the method is a boolean comparison check, it will still return true or false correctly according to the remaining conditions. Removing one condition does not inherently alter the binary return outcome of the method; it only changes the criteria by which equality is judged, which is expected behaviour for an equals method between versions. The removal of `mImportanceLockedByOEM` implies that field is no longer considered part of the equality check; hence, existing code comparing NotificationChannel objects will not break, it will merely use updated criteria."
482,<android.view.textclassifier.TextLanguage.Builder: Builder setExtras(Bundle)>,32,33,,,,"{
    mBundle = Preconditions.checkNotNull(bundle);
    return this;
}","{
    mBundle = Objects.requireNonNull(bundle);
    return this;
}",1,"/**
 * Sets a bundle containing non-structured extra information about the TextLanguage object.
 */
","/**
 * Sets a bundle containing non-structured extra information about the TextLanguage object.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,5,0,"The method used to check for null has changed from Preconditions.checkNotNull(bundle) to Objects.requireNonNull(bundle), so the code change type is a Dependent API changed (5).","Despite the change of the dependent method used for null checking, this won't affect the behavior of the method. Both versions will throw a NullPointerException if the passed bundle is null. The API's contract and the behavior remain unchanged. Therefore, there is no Compatibility Issue (0)."
483,"<android.view.inputmethod.InputMethodManager.DelegateImpl: void startInputAsyncOnWindowFocusGain(View,int,int,boolean)>",32,33,,,,"{
    int startInputFlags = getStartInputFlags(focusedView, 0);
    startInputFlags |= StartInputFlags.WINDOW_GAINED_FOCUS;
    ImeTracing.getInstance().triggerClientDump(""InputMethodManager.DelegateImpl#startInputAsyncOnWindowFocusGain"", InputMethodManager.this, null);
    final ImeFocusController controller = getFocusController();
    if (controller == null) {
        return;
    }
    if (controller.checkFocus(forceNewFocus, false)) {
        // smooth.
        if (startInput(StartInputReason.WINDOW_FOCUS_GAIN, focusedView, startInputFlags, softInputMode, windowFlags)) {
            return;
        }
    }
    synchronized (mH) {
        // we'll just do a window focus gain and call it a day.
        try {
            View servedView = controller.getServedView();
            boolean nextFocusHasConnection = servedView != null && servedView == focusedView && hasActiveConnection(focusedView);
            if (DEBUG) {
                Log.v(TAG, ""Reporting focus gain, without startInput"" + "", nextFocusIsServedView="" + nextFocusHasConnection);
            }
            final int startInputReason = nextFocusHasConnection ? WINDOW_FOCUS_GAIN_REPORT_WITH_CONNECTION : WINDOW_FOCUS_GAIN_REPORT_WITHOUT_CONNECTION;
            // ignore the result
            mService.startInputOrWindowGainedFocus(startInputReason, mClient, focusedView.getWindowToken(), startInputFlags, softInputMode, windowFlags, null, null, 0, /* missingMethodFlags */
            mCurRootView.mContext.getApplicationInfo().targetSdkVersion);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    int startInputFlags = getStartInputFlags(focusedView, 0);
    startInputFlags |= StartInputFlags.WINDOW_GAINED_FOCUS;
    ImeTracing.getInstance().triggerClientDump(""InputMethodManager.DelegateImpl#startInputAsyncOnWindowFocusGain"", InputMethodManager.this, null);
    final ImeFocusController controller = getFocusController();
    if (controller == null) {
        return;
    }
    if (controller.checkFocus(forceNewFocus, false)) {
        // smooth.
        if (startInput(StartInputReason.WINDOW_FOCUS_GAIN, focusedView, startInputFlags, softInputMode, windowFlags)) {
            return;
        }
    }
    synchronized (mH) {
        // we'll just do a window focus gain and call it a day.
        try {
            View servedView = controller.getServedView();
            boolean nextFocusHasConnection = servedView != null && servedView == focusedView && hasActiveConnection(focusedView);
            if (DEBUG) {
                Log.v(TAG, ""Reporting focus gain, without startInput"" + "", nextFocusIsServedView="" + nextFocusHasConnection);
            }
            final int startInputReason = nextFocusHasConnection ? WINDOW_FOCUS_GAIN_REPORT_WITH_CONNECTION : WINDOW_FOCUS_GAIN_REPORT_WITHOUT_CONNECTION;
            // ignore the result
            mService.startInputOrWindowGainedFocus(startInputReason, mClient, focusedView.getWindowToken(), startInputFlags, softInputMode, windowFlags, null, null, null, mCurRootView.mContext.getApplicationInfo().targetSdkVersion, mImeDispatcher);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * For {@link ImeFocusController} to start input asynchronously when focus gain.
 */
","/**
 * For {@link ImeFocusController} to start input asynchronously when focus gain.
 */
",0,[@Override],[@Override],0,,,,,,,"4,5",0,"The code change involves modifying a parameter passed to a method call (`mService.startInputOrWindowGainedFocus`). Specifically, the 9th parameter has changed from `0` to `null` and a new 11th parameter `mImeDispatcher` has been added, so the code change type is 4,5.","While the late implementation has a new parameter and modified an existing one in a method call, it does not affect the behavior of this `startInputAsyncOnWindowFocusGain` method since the control flow and exception handling have not changed. Hence, there are no Compatibility Issues (CI type 0)."
484,<android.os.BatteryUsageStats.Builder: Builder getOrCreateUidBatteryConsumerBuilder(Uid)>,32,33,,,,"{
    int uid = batteryStatsUid.getUid();
    UidBatteryConsumer.Builder builder = mUidBatteryConsumerBuilders.get(uid);
    if (builder == null) {
        builder = new UidBatteryConsumer.Builder(mCustomPowerComponentNames, mIncludePowerModels, batteryStatsUid);
        mUidBatteryConsumerBuilders.put(uid, builder);
    }
    return builder;
}","{
    int uid = batteryStatsUid.getUid();
    UidBatteryConsumer.Builder builder = mUidBatteryConsumerBuilders.get(uid);
    if (builder == null) {
        final BatteryConsumer.BatteryConsumerData data = BatteryConsumer.BatteryConsumerData.create(mBatteryConsumersCursorWindow, mBatteryConsumerDataLayout);
        builder = new UidBatteryConsumer.Builder(data, batteryStatsUid);
        mUidBatteryConsumerBuilders.put(uid, builder);
    }
    return builder;
}",1,"/**
 * Creates or returns a UidBatteryConsumer, which represents battery attribution
 * data for an individual UID.
 */
","/**
 * Creates or returns a UidBatteryConsumer, which represents battery attribution
 * data for an individual UID.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,4,5",1,"The constructor for a new UidBatteryConsumer.Builder has changed in its parameters which affects the return value type, an additional local variable declaration is introduced, and there's a use of a new dependent API, BatteryConsumer.BatteryConsumerData.create, so the code changes are of types 1, 4, and 5.","The change in the parameters required to construct a new UidBatteryConsumer.Builder object could potentially lead to a different return value due to the different initial states of the created builder object, thus the CI type is 1."
485,"<android.webkit.URLUtil: String guessFileName(String,String,String)>",32,33,,,,"{
    String filename = null;
    String extension = null;
    // If we couldn't do anything with the hint, move toward the content disposition
    if (filename == null && contentDisposition != null) {
        filename = parseContentDisposition(contentDisposition);
        if (filename != null) {
            int index = filename.lastIndexOf('/') + 1;
            if (index > 0) {
                filename = filename.substring(index);
            }
        }
    }
    // If all the other http-related approaches failed, use the plain uri
    if (filename == null) {
        String decodedUrl = Uri.decode(url);
        if (decodedUrl != null) {
            int queryIndex = decodedUrl.indexOf('?');
            // If there is a query string strip it, same as desktop browsers
            if (queryIndex > 0) {
                decodedUrl = decodedUrl.substring(0, queryIndex);
            }
            if (!decodedUrl.endsWith(""/"")) {
                int index = decodedUrl.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = decodedUrl.substring(index);
                }
            }
        }
    }
    // Finally, if couldn't get filename from URI, get a generic filename
    if (filename == null) {
        filename = ""downloadfile"";
    }
    // Split filename between base and extension
    // Add an extension if filename does not have one
    int dotIndex = filename.indexOf('.');
    if (dotIndex < 0) {
        if (mimeType != null) {
            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
            if (extension != null) {
                extension = ""."" + extension;
            }
        }
        if (extension == null) {
            if (mimeType != null && mimeType.toLowerCase(Locale.ROOT).startsWith(""text/"")) {
                if (mimeType.equalsIgnoreCase(""text/html"")) {
                    extension = "".html"";
                } else {
                    extension = "".txt"";
                }
            } else {
                extension = "".bin"";
            }
        }
    } else {
        if (mimeType != null) {
            // Compare the last segment of the extension against the mime type.
            // If there's a mismatch, discard the entire extension.
            int lastDotIndex = filename.lastIndexOf('.');
            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(filename.substring(lastDotIndex + 1));
            if (typeFromExt != null && !typeFromExt.equalsIgnoreCase(mimeType)) {
                extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                if (extension != null) {
                    extension = ""."" + extension;
                }
            }
        }
        if (extension == null) {
            extension = filename.substring(dotIndex);
        }
        filename = filename.substring(0, dotIndex);
    }
    return filename + extension;
}","{
    String filename = null;
    String extension = null;
    // If we couldn't do anything with the hint, move toward the content disposition
    if (contentDisposition != null) {
        filename = parseContentDisposition(contentDisposition);
        if (filename != null) {
            int index = filename.lastIndexOf('/') + 1;
            if (index > 0) {
                filename = filename.substring(index);
            }
        }
    }
    // If all the other http-related approaches failed, use the plain uri
    if (filename == null) {
        String decodedUrl = Uri.decode(url);
        if (decodedUrl != null) {
            int queryIndex = decodedUrl.indexOf('?');
            // If there is a query string strip it, same as desktop browsers
            if (queryIndex > 0) {
                decodedUrl = decodedUrl.substring(0, queryIndex);
            }
            if (!decodedUrl.endsWith(""/"")) {
                int index = decodedUrl.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = decodedUrl.substring(index);
                }
            }
        }
    }
    // Finally, if couldn't get filename from URI, get a generic filename
    if (filename == null) {
        filename = ""downloadfile"";
    }
    // Split filename between base and extension
    // Add an extension if filename does not have one
    int dotIndex = filename.indexOf('.');
    if (dotIndex < 0) {
        if (mimeType != null) {
            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
            if (extension != null) {
                extension = ""."" + extension;
            }
        }
        if (extension == null) {
            if (mimeType != null && mimeType.toLowerCase(Locale.ROOT).startsWith(""text/"")) {
                if (mimeType.equalsIgnoreCase(""text/html"")) {
                    extension = "".html"";
                } else {
                    extension = "".txt"";
                }
            } else {
                extension = "".bin"";
            }
        }
    } else {
        if (mimeType != null) {
            // Compare the last segment of the extension against the mime type.
            // If there's a mismatch, discard the entire extension.
            int lastDotIndex = filename.lastIndexOf('.');
            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(filename.substring(lastDotIndex + 1));
            if (typeFromExt != null && !typeFromExt.equalsIgnoreCase(mimeType)) {
                extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                if (extension != null) {
                    extension = ""."" + extension;
                }
            }
        }
        if (extension == null) {
            extension = filename.substring(dotIndex);
        }
        filename = filename.substring(0, dotIndex);
    }
    return filename + extension;
}",1,"/**
 * Guesses canonical filename that a download would have, using
 * the URL and contentDisposition. File extension, if not defined,
 * is added based on the mimetype
 * @param url Url to the content
 * @param contentDisposition Content-Disposition HTTP header or {@code null}
 * @param mimeType Mime-type of the content or {@code null}
 *
 * @return suggested filename
 */
","/**
 * Guesses canonical filename that a download would have, using
 * the URL and contentDisposition. File extension, if not defined,
 * is added based on the mimetype
 * @param url Url to the content
 * @param contentDisposition Content-Disposition HTTP header or {@code null}
 * @param mimeType Mime-type of the content or {@code null}
 *
 * @return suggested filename
 */
",0,,,0,,,,,,,,,,
487,<android.os.Parcel: Object[] readArray(ClassLoader)>,32,33,,,,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    Object[] l = new Object[N];
    readArrayInternal(l, N, loader);
    return l;
}","{
    return readArrayInternal(loader, /* clazz */
    null);
}",1,"/**
 * Read and return a new Object array from the parcel at the current
 * dataPosition().  Returns null if the previously written array was
 * null.  The given class loader will be used to load any enclosed
 * Parcelables.
 */
","/**
 * Read and return a new Object array from the parcel at the current
 * dataPosition().  Returns null if the previously written array was
 * null.  The given class loader will be used to load any enclosed
 * Parcelables.
 *
 * @deprecated Use the type-safer version {@link #readArray(ClassLoader, Class)} starting from
 * Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the format to use
 * {@link #createTypedArray(Parcelable.Creator)} if possible (eg. if the items' class is
 * final) since this is also more performant. Note that changing to the latter also
 * requires changing the writes.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"1,5",1,"The method used to create and then return an Array[] has been completely replaced with a call to a different method, readArrayInternal(loader, /* clazz */ null), which indicates that the implementation of returning the array has changed. It also suggests that the logic of creating the array has potentially been moved into the 'readArrayInternal' method. This is a change in the return statement and a change in the dependent API, so the code change type is 1,5.","Because the method's return mechanism has changed, it could potentially return different types or values of the array, and thus there could be compatibility issues caused by potential different return values or types, making the CI type 1."
488,<android.companion.CompanionDeviceManager: void startObservingDevicePresence(String)>,32,33,,,,"{
    if (!checkFeaturePresent()) {
        return;
    }
    Objects.requireNonNull(deviceAddress, ""address cannot be null"");
    try {
        mService.registerDevicePresenceListenerService(mContext.getPackageName(), deviceAddress);
    } catch (RemoteException e) {
        ExceptionUtils.propagateIfInstanceOf(e.getCause(), DeviceNotAssociatedException.class);
        throw e.rethrowFromSystemServer();
    }
}","{
    if (!checkFeaturePresent()) {
        return;
    }
    Objects.requireNonNull(deviceAddress, ""address cannot be null"");
    try {
        mService.registerDevicePresenceListenerService(deviceAddress, mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        ExceptionUtils.propagateIfInstanceOf(e.getCause(), DeviceNotAssociatedException.class);
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Register to receive callbacks whenever the associated device comes in and out of range.
 *
 * The provided device must be {@link #associate associated} with the calling app before
 * calling this method.
 *
 * Caller must implement a single {@link CompanionDeviceService} which will be bound to and
 * receive callbacks to {@link CompanionDeviceService#onDeviceAppeared} and
 * {@link CompanionDeviceService#onDeviceDisappeared}.
 * The app doesn't need to remain running in order to receive its callbacks.
 *
 * Calling app must declare uses-permission
 * {@link android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE}.
 *
 * Calling app must check for feature presence of
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.
 *
 * For Bluetooth LE devices this is based on scanning for device with the given address.
 * For Bluetooth classic devices this is triggered when the device connects/disconnects.
 * WiFi devices are not supported.
 *
 * If a Bluetooth LE device wants to use a rotating mac address, it is recommended to use
 * Resolvable Private Address, and ensure the device is bonded to the phone so that android OS
 * is able to resolve the address.
 *
 * @param deviceAddress a previously-associated companion device's address
 *
 * @throws DeviceNotAssociatedException if the given device was not previously associated
 * with this app.
 */
","/**
 * Register to receive callbacks whenever the associated device comes in and out of range.
 *
 * The provided device must be {@link #associate associated} with the calling app before
 * calling this method.
 *
 * Caller must implement a single {@link CompanionDeviceService} which will be bound to and
 * receive callbacks to {@link CompanionDeviceService#onDeviceAppeared} and
 * {@link CompanionDeviceService#onDeviceDisappeared}.
 * The app doesn't need to remain running in order to receive its callbacks.
 *
 * Calling app must declare uses-permission
 * {@link android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE}.
 *
 * Calling app must check for feature presence of
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.
 *
 * For Bluetooth LE devices this is based on scanning for device with the given address.
 * For Bluetooth classic devices this is triggered when the device connects/disconnects.
 * WiFi devices are not supported.
 *
 * If a Bluetooth LE device wants to use a rotating mac address, it is recommended to use
 * Resolvable Private Address, and ensure the device is bonded to the phone so that android OS
 * is able to resolve the address.
 *
 * @param deviceAddress a previously-associated companion device's address
 *
 * @throws DeviceNotAssociatedException if the given device was not previously associated
 * with this app.
 */
",0,[@RequiresPermission(android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE)],[@RequiresPermission(android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE)],0,,,,,,,5,0,"The method call within try block changed from mService.registerDevicePresenceListenerService(mContext.getPackageName(), deviceAddress) to mService.registerDevicePresenceListenerService(deviceAddress, mContext.getOpPackageName(), mContext.getUserId()), indicating a change in the dependent API's parameters, hence the code change type is 5.","The modifications to the method call parameters within try block do not inherently imply a change in behaviour since this is merely a shift in what's being passed to the service call, without altering the method's logic or exception handling. Thus, there is no Compatibility Issue, and the CI type is 0."
489,"<android.view.View: boolean onKeyUp(int,KeyEvent)>",32,33,,,,"{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
            setPressed(false);
            if (!mHasPerformedLongPress) {
                // This is a tap, so remove the longpress check
                removeLongPressCallback();
                if (!event.isCanceled()) {
                    return performClickInternal();
                }
            }
        }
    }
    return false;
}","{
    if (KeyEvent.isConfirmKey(keyCode) && event.hasNoModifiers()) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
            setPressed(false);
            if (!mHasPerformedLongPress) {
                // This is a tap, so remove the longpress check
                removeLongPressCallback();
                if (!event.isCanceled()) {
                    return performClickInternal();
                }
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER}, {@link KeyEvent#KEYCODE_ENTER}
 * or {@link KeyEvent#KEYCODE_SPACE} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER}, {@link KeyEvent#KEYCODE_ENTER}
 * or {@link KeyEvent#KEYCODE_SPACE} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",0,,,0,,,,,,,3,0,"A new condition `event.hasNoModifiers()` is added to the if statement checking for `KeyEvent.isConfirmKey(keyCode)`. This change affects the control flow but does not change the return type or add any new exceptions. Since we need to determine whether the code changes potentially lead to a different behavior, adding an extra condition would potentially alter the flow, leading to situations where the early version would enter the block and process the key event, while the late version might not, due to the extra no-modifiers check. Therefore this change is a Control dependency change (3).","Despite the added condition, there is no Compatibility Issue with respect to different return values or types or different exception handlings, because the method returns the same value and has the same exception handling as before. The new condition is just an additional guard that may prevent the method from executing certain actions under given conditions, but when those conditions are not met, the behavior is unchanged. So there are no Compatibility Issues (0)."
490,<android.app.Service: void stopForeground(int)>,32,33,,,,"{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, 0, null, flags, 0);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, 0, null, notificationBehavior, 0);
    } catch (RemoteException ex) {
    }
}",1,"/**
 * Remove this service from foreground state, allowing it to be killed if
 * more memory is needed.  This does not stop the service from running (for that
 * you use {@link #stopSelf()} or related methods), just takes it out of the
 * foreground state.
 *
 * @param flags additional behavior options.
 * @see #startForeground(int, Notification)
 */
","/**
 * Remove this service from foreground state, allowing it to be killed if
 * more memory is needed.  This does not stop the service from running (for that
 * you use {@link #stopSelf()} or related methods), just takes it out of the
 * foreground state.
 *
 * <p>If {@link #STOP_FOREGROUND_REMOVE} is supplied, the service's associated
 * notification will be cancelled immediately.</p>
 * <p>If {@link #STOP_FOREGROUND_DETACH} is supplied, the service's association
 * with the notification will be severed.  If the notification had not yet been
 * shown, due to foreground-service notification deferral policy, it is
 * immediately posted when {@code stopForeground(STOP_FOREGROUND_DETACH)}
 * is called.  In all cases, the notification remains shown
 * even after this service is stopped fully and destroyed.</p>
 * <p>If {@code zero} is passed as the argument, the result will be the legacy
 * behavior as defined prior to Android L: the notification will remain posted until
 * the service is fully stopped, at which time it will automatically be cancelled.</p>
 *
 * @param notificationBehavior the intended behavior for the service's associated
 * notification
 * @see #startForeground(int, Notification)
 * @see #STOP_FOREGROUND_DETACH
 * @see #STOP_FOREGROUND_REMOVE
 */
",1,,,0,,,,,,,4,0,"The change is in the parameter passed to the method setServiceForeground, from 'flags' to 'notificationBehavior'. Since this parameter is not a return value or an exception, the change type is 4.","There is no Compatibility Issue in this change, because the change does not affect the return type or value, nor does it alter exception handling. The method does not return any value (it is a 'void' method) and the exception handling remains the same. Therefore, there are no changes in behavior as far as the client is concerned; the change is internal to the method's implementation."
491,"<android.text.TextShaper: void shapeText(CharSequence,int,int,TextDirectionHeuristic,TextPaint,GlyphsConsumer)>",32,33,,,,"{
    MeasuredParagraph mp = MeasuredParagraph.buildForBidi(text, start, start + count, dir, null);
    TextLine tl = TextLine.obtain();
    try {
        tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), false, /* tabstop is not supported */
        null, // ellipsis is not supported.
        -1, // ellipsis is not supported.
        -1);
        tl.shape(consumer);
    } finally {
        TextLine.recycle(tl);
    }
}","{
    MeasuredParagraph mp = MeasuredParagraph.buildForBidi(text, start, start + count, dir, null);
    TextLine tl = TextLine.obtain();
    try {
        tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), false, /* tabstop is not supported */
        null, // ellipsis is not supported.
        -1, // ellipsis is not supported.
        -1, false);
        tl.shape(consumer);
    } finally {
        TextLine.recycle(tl);
    }
}",1,"/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
","/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */
",0,,,0,,,,,,,4,0,"There is an additional `false` argument being passed to the `tl.set` method. Since this is a change in the arguments of the method call within the implementation, the code change type is 4.","The additional `false` argument for the `tl.set` method does not change the behavior of the `shapeText` API in terms of returning a different value or throwing a new/different exception. This value is just an argument passed to the method and does not constitute a change in return or exception behavior as no new control structures or exception handlers are added. It is likely that this argument is just a parameter for a configuration which is handled in the same way as before, just explicitly stating the default or existing behavior. Therefore, there is no Compatibility Issue according to the given information."
492,"<android.view.accessibility.AccessibilityNodeInfo.CollectionItemInfo: CollectionItemInfo obtain(int,int,int,int,boolean)>",32,33,,,,"{
    return obtain(rowIndex, rowSpan, columnIndex, columnSpan, heading, false);
}","{
    return new CollectionItemInfo(rowIndex, rowSpan, columnIndex, columnSpan, heading, false);
}",1,"/**
 * Obtains a pooled instance.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionItemInfo#CollectionItemInfo(int,
 * int, int, int, boolean)} instead.
 *
 * @param rowIndex The row index at which the item is located.
 * @param rowSpan The number of rows the item spans.
 * @param columnIndex The column index at which the item is located.
 * @param columnSpan The number of columns the item spans.
 * @param heading Whether the item is a heading. (Prefer
 * {@link AccessibilityNodeInfo#setHeading(boolean)}).
 */
","/**
 * Instantiates a new CollectionItemInfo.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link
 * AccessibilityNodeInfo.CollectionItemInfo#CollectionItemInfo(int,
 * int, int, int, boolean)} instead.
 * @param rowIndex The row index at which the item is located.
 * @param rowSpan The number of rows the item spans.
 * @param columnIndex The column index at which the item is located.
 * @param columnSpan The number of columns the item spans.
 * @param heading Whether the item is a heading. (Prefer
 * {@link AccessibilityNodeInfo#setHeading(boolean)}).
 */
",1,,[@Deprecated],1,,,,,,,"4,5",0,"The implementation changed from calling an overload of the obtain method to directly creating a new instance of CollectionItemInfo. Moreover, the dependent API of the overload obtain may have changed. Therefore, the code change type is 4,5.","There is no compatibility issue caused by the code change. The two implementations result in the same behavior since both create a new CollectionItemInfo object with the same arguments; the only difference is the approach. Hence, CI type is 0."
493,<android.os.BaseBundle: ArrayList<CharSequence> getCharSequenceArrayList(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<CharSequence>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""ArrayList<CharSequence>"", e);
        return null;
    }
}","{
    return getArrayList(key, CharSequence.class);
}",1,"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<CharSequence> value, or null
 */
","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<CharSequence> value, or null
 */
",0,[@Nullable],[@Nullable],0,,,,,,,5,0,"The implementation changes imply that there's a delegation to another method getArrayList(key, CharSequence.class) instead of directly returning the value or throwing an exception. This change suggests that the work previously done in this method may have been refactored into the new getArrayList method. Thus, the change falls under code change type 5.","As getCharSequenceArrayList now delegates to getArrayList with specific parameters, assuming getArrayList is correctly implemented, the behavior should theoretically remain consistent with the previous version, preserving the same return values and exception handling as before. This suggests there's no compatibility issue, so CI type is 0."
494,"<android.hardware.camera2.impl.CameraExtensionSessionImpl.BurstRequestHandler: void onCaptureCompleted(CameraCaptureSession,CaptureRequest,TotalCaptureResult)>",32,33,,,,"{
    if (!mCaptureRequestMap.containsKey(request)) {
        Log.e(TAG, ""Unexpected still capture request received!"");
        return;
    }
    Integer stageId = mCaptureRequestMap.get(request);
    Long timestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
    if (timestamp != null) {
        if (mImageProcessor != null) {
            if (mCapturePendingMap.indexOfKey(timestamp) >= 0) {
                Image img = mCapturePendingMap.get(timestamp).first;
                mCaptureStageMap.put(stageId, new Pair<>(img, result));
                checkAndFireBurstProcessing();
            } else {
                mCapturePendingMap.put(timestamp, new Pair<>(null, stageId));
                mCaptureStageMap.put(stageId, new Pair<>(null, result));
            }
        } else {
            mCaptureRequestMap.clear();
            final long ident = Binder.clearCallingIdentity();
            try {
                mExecutor.execute(() -> mCallbacks.onCaptureProcessStarted(CameraExtensionSessionImpl.this, mClientRequest));
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    } else {
        Log.e(TAG, ""Capture result without valid sensor timestamp!"");
    }
}","{
    if (!mCaptureRequestMap.containsKey(request)) {
        Log.e(TAG, ""Unexpected still capture request received!"");
        return;
    }
    Integer stageId = mCaptureRequestMap.get(request);
    Long timestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
    if (timestamp != null) {
        if (mCaptureResultsSupported && (mCaptureResultHandler == null)) {
            mCaptureResultHandler = new CaptureResultHandler(mClientRequest, mExecutor, mCallbacks, result.getSequenceId());
        }
        if (mImageProcessor != null) {
            if (mCapturePendingMap.indexOfKey(timestamp) >= 0) {
                Image img = mCapturePendingMap.get(timestamp).first;
                mCaptureStageMap.put(stageId, new Pair<>(img, result));
                checkAndFireBurstProcessing();
            } else {
                mCapturePendingMap.put(timestamp, new Pair<>(null, stageId));
                mCaptureStageMap.put(stageId, new Pair<>(null, result));
            }
        } else {
            mCaptureRequestMap.clear();
            final long ident = Binder.clearCallingIdentity();
            try {
                mExecutor.execute(() -> mCallbacks.onCaptureProcessStarted(CameraExtensionSessionImpl.this, mClientRequest));
                if (mCaptureResultHandler != null) {
                    mCaptureResultHandler.onCaptureCompleted(timestamp, initializeFilteredResults(result));
                }
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    } else {
        Log.e(TAG, ""Capture result without valid sensor timestamp!"");
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There is an 'if' block and an 'execute' block added, but neither affects the return value nor the exception handling; thus, the code change type is 4.","The changes are only in the inner workings of how the method handles the camera capture result and do not impact the return type or value, nor do they change exception handling. Therefore, no potential Compatibility Issue arises, and CI type is 0."
495,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern,RemoteViews,InlinePresentation)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, new DatasetFieldFilter(filter));
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(presentation, ""presentation cannot be null"");
    Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, null, new DatasetFieldFilter(filter), null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>, and an
 * {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions, this
 * should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>, and an
 * {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} and using the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions, this
 * should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"4,5",0,"The exception check has changed from using Preconditions.checkNotNull to Objects.requireNonNull. An additional parameter (null) is also added to the call to ""setLifeTheUniverseAndEverything"" method. Hence, the change type is 4 and 5.","Despite these internal changes, they don't affect the API's behavior regarding different return values/types or exception throwing. The null values as new parameters to the method won't change how the method behaves towards the API user. As for the null checks, both Preconditions.checkNotNull and Objects.requireNonNull serve the same purpose and will throw a NullPointerException if the object is null. The deprecation annotation does not introduce a compatibility issue as it is not related to the runtime behavior but rather to the API usage recommendation. Therefore, there is no compatibility issue."
496,<android.net.vcn.VcnGatewayConnectionConfig: boolean equals(Object)>,32,33,,,,"{
    if (!(other instanceof VcnGatewayConnectionConfig)) {
        return false;
    }
    final VcnGatewayConnectionConfig rhs = (VcnGatewayConnectionConfig) other;
    return mGatewayConnectionName.equals(rhs.mGatewayConnectionName) && mTunnelConnectionParams.equals(rhs.mTunnelConnectionParams) && mExposedCapabilities.equals(rhs.mExposedCapabilities) && Arrays.equals(mRetryIntervalsMs, rhs.mRetryIntervalsMs) && mMaxMtu == rhs.mMaxMtu;
}","{
    if (!(other instanceof VcnGatewayConnectionConfig)) {
        return false;
    }
    final VcnGatewayConnectionConfig rhs = (VcnGatewayConnectionConfig) other;
    return mGatewayConnectionName.equals(rhs.mGatewayConnectionName) && mTunnelConnectionParams.equals(rhs.mTunnelConnectionParams) && mExposedCapabilities.equals(rhs.mExposedCapabilities) && mUnderlyingNetworkTemplates.equals(rhs.mUnderlyingNetworkTemplates) && Arrays.equals(mRetryIntervalsMs, rhs.mRetryIntervalsMs) && mMaxMtu == rhs.mMaxMtu;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The equals implementation has changed with an additional condition mUnderlyingNetworkTemplates.equals(rhs.mUnderlyingNetworkTemplates). This is an internal change to the behavior of the equals method but does not affect the type of value returned or exception thrown, therefore the change type is 4.","In terms of compatibility, the method still returns a boolean value and doesn't throw any new exceptions. The equals method is expected to compare all relevant fields, so adding a new field to the comparison is a typical change when a new field is added to a class. Therefore, there is no Compatibility Issue, and the CI type is 0."
497,<android.view.Display: int getRotation()>,32,33,,,,"{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getRotation(mDisplayInfo.rotation) : mDisplayInfo.rotation;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return getLocalRotation();
    }
}",1,"/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 */
","/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 *
 * This rotation value will match the results of {@link #getMetrics}: this means that the
 * rotation value will correspond to the activity if accessed through the activity.
 */
",1,[@Surface.Rotation],[@Surface.Rotation],0,,,,,,,5,0,"The replacement of the ternary operation with a call to `getLocalRotation()` is a change in a dependent API, therefore the change type is 5. There is no direct evidence that the behavior of `getLocalRotation()` would differ from the original code's behavior.","Without knowing the internal implementation of `getLocalRotation()`, it cannot be determined if this will create a compatibility issue. Assuming `getLocalRotation()` correctly abstracts the original ternary logic, there would be no compatibility issue, so the CI type is 0. However, if the behavior of `getLocalRotation()` differs from the expected behavior of the removed ternary statement, then it could potentially return different values. Since there is no evidence provided to make this determination, the conservative assumption is that there is no compatibility issue."
499,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",32,33,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change between the two versions is the reordering of arguments in the `ActivityManager.getService().broadcastIntentWithFeature()` method call. Specifically, `appOp` was previously in the ""excludedPermissions"" parameter position, and has been moved to the correct ""appOp"" parameter position in the late version. This is an ""Other statement changed"" type of code change.","Though there was a change in the order of parameters within the method call, this does not result in a Compatibility Issue because the intended effect of the method call remains the same, and no differences in the return type, return values, or thrown exceptions are introduced. The method is essentially corrected to pass the parameters correctly and will not affect existing clients assuming they use the API as intended. Therefore, there is no Compatibility Issue."
502,<android.os.Binder: int getCallingUidOrThrow()>,32,33,,,,"{
    if (!isHandlingTransaction()) {
        throw new IllegalStateException(""Thread is not in a binder transcation"");
    }
    return getCallingUid();
}","{
    if (!isDirectlyHandlingTransaction()) {
        throw new IllegalStateException(""Thread is not in a binder transcation"");
    }
    return getCallingUid();
}",1,"/**
 * Return the Linux uid assigned to the process that sent the transaction
 * currently being processed.
 *
 * @throws IllegalStateException if the current thread is not currently
 * executing an incoming transaction.
 */
","/**
 * Return the Linux UID assigned to the process that sent the transaction
 * currently being processed.
 *
 * @throws IllegalStateException if the current thread is not currently
 * executing an incoming transaction.
 */
",1,,,0,,,,,,,5,0,"The method name called within the if statement has changed from 'isHandlingTransaction()' to 'isDirectlyHandlingTransaction()', which makes the code change type 5.","There is no explicit change in the behavior of the API visible from the given context. The difference lies in the method used to check the transaction handling status. Assuming that 'isDirectlyHandlingTransaction()' serves a similar purpose but with a possibly different scope or condition, it does not necessarily introduce a difference in the API's behavior, as long as it returns a boolean as expected. Therefore, there is no Compatibility Issue indicated by the provided code as long as the semantics of the new method align with the context in which the original method was used."
503,<android.app.WallpaperColors: WallpaperColors fromBitmap(Bitmap)>,32,33,,,,"{
    if (bitmap == null) {
        throw new IllegalArgumentException(""Bitmap can't be null"");
    }
    final int bitmapArea = bitmap.getWidth() * bitmap.getHeight();
    boolean shouldRecycle = false;
    if (bitmapArea > MAX_WALLPAPER_EXTRACTION_AREA) {
        shouldRecycle = true;
        Size optimalSize = calculateOptimalSize(bitmap.getWidth(), bitmap.getHeight());
        bitmap = Bitmap.createScaledBitmap(bitmap, optimalSize.getWidth(), optimalSize.getHeight(), false);
    }
    final Palette palette;
    if (ActivityManager.isLowRamDeviceStatic()) {
        palette = Palette.from(bitmap, new VariationalKMeansQuantizer()).maximumColorCount(5).resizeBitmapArea(MAX_WALLPAPER_EXTRACTION_AREA).generate();
    } else {
        palette = Palette.from(bitmap, new CelebiQuantizer()).maximumColorCount(128).resizeBitmapArea(MAX_WALLPAPER_EXTRACTION_AREA).generate();
    }
    // Remove insignificant colors and sort swatches by population
    final ArrayList<Palette.Swatch> swatches = new ArrayList<>(palette.getSwatches());
    swatches.sort((a, b) -> b.getPopulation() - a.getPopulation());
    final int swatchesSize = swatches.size();
    final Map<Integer, Integer> populationByColor = new HashMap<>();
    for (int i = 0; i < swatchesSize; i++) {
        Palette.Swatch swatch = swatches.get(i);
        int colorInt = swatch.getInt();
        populationByColor.put(colorInt, swatch.getPopulation());
    }
    int hints = calculateDarkHints(bitmap);
    if (shouldRecycle) {
        bitmap.recycle();
    }
    return new WallpaperColors(populationByColor, HINT_FROM_BITMAP | hints);
}","{
    if (bitmap == null) {
        throw new IllegalArgumentException(""Bitmap can't be null"");
    }
    return fromBitmap(bitmap, 0f);
}",1,"/**
 * Constructs {@link WallpaperColors} from a bitmap.
 * <p>
 * Main colors will be extracted from the bitmap.
 *
 * @param bitmap Source where to extract from.
 */
","/**
 * Constructs {@link WallpaperColors} from a bitmap.
 * <p>
 * Main colors will be extracted from the bitmap.
 *
 * @param bitmap Source where to extract from.
 */
",0,,,0,,,,,,,"1,4,5","1,2","The return statement has changed, and it now calls another method ""fromBitmap(bitmap, 0f)"" instead of the inline code to compute the WallpaperColors object. Also, the original method's implementation contained exception handling, other logic, and the use of a dependent API call ""Bitmap.createScaledBitmap"", which has been removed.",
507,"<android.content.res.TypedArray: int getInteger(int,int)>",32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to integer: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value + "", theme="" + mTheme);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to integer: type=0x"" + Integer.toHexString(type) + "", theme="" + mTheme);
}",1,"/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */
","/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */
",0,,,0,,,,,,,4,0,"The change is only in the message strings of the exceptions thrown, which does not alter the behavior of the method in terms of the value it returns or the exceptions it throws.","Since the method signatures, return types, and overall exception handling logic remain the same and only the exception messages have been modified, there is no change in the behavior of the method that could lead to a compatibility issue."
508,<android.database.sqlite.SQLiteDatabase: boolean enableWriteAheadLogging()>,32,33,,,,"{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        if ((mConfigurationLocked.openFlags & ENABLE_WRITE_AHEAD_LOGGING) != 0) {
            return true;
        }
        if (isReadOnlyLocked()) {
            // TODO: True, but connection pooling does still make sense...
            return false;
        }
        if (mConfigurationLocked.isInMemoryDb()) {
            Log.i(TAG, ""can't enable WAL for memory databases."");
            return false;
        }
        // doesn't work for databases with attached databases
        if (mHasAttachedDbsLocked) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, ""this database: "" + mConfigurationLocked.label + "" has attached databases. can't  enable WAL."");
            }
            return false;
        }
        mConfigurationLocked.openFlags |= ENABLE_WRITE_AHEAD_LOGGING;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
            throw ex;
        }
    }
    return true;
}","{
    synchronized (mLock) {
        throwIfNotOpenLocked();
        if (mConfigurationLocked.resolveJournalMode().equalsIgnoreCase(SQLiteDatabase.JOURNAL_MODE_WAL)) {
            return true;
        }
        if (isReadOnlyLocked()) {
            // TODO: True, but connection pooling does still make sense...
            return false;
        }
        if (mConfigurationLocked.isInMemoryDb()) {
            Log.i(TAG, ""can't enable WAL for memory databases."");
            return false;
        }
        // doesn't work for databases with attached databases
        if (mHasAttachedDbsLocked) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, ""this database: "" + mConfigurationLocked.label + "" has attached databases. can't  enable WAL."");
            }
            return false;
        }
        mConfigurationLocked.openFlags |= ENABLE_WRITE_AHEAD_LOGGING;
        try {
            mConnectionPoolLocked.reconfigure(mConfigurationLocked);
        } catch (RuntimeException ex) {
            mConfigurationLocked.openFlags &= ~ENABLE_WRITE_AHEAD_LOGGING;
            throw ex;
        }
    }
    return true;
}",1,"/**
 * This method enables parallel execution of queries from multiple threads on the
 * same database.  It does this by opening multiple connections to the database
 * and using a different database connection for each query.  The database
 * journal mode is also changed to enable writes to proceed concurrently with reads.
 * <p>
 * When write-ahead logging is not enabled (the default), it is not possible for
 * reads and writes to occur on the database at the same time.  Before modifying the
 * database, the writer implicitly acquires an exclusive lock on the database which
 * prevents readers from accessing the database until the write is completed.
 * </p><p>
 * In contrast, when write-ahead logging is enabled (by calling this method), write
 * operations occur in a separate log file which allows reads to proceed concurrently.
 * While a write is in progress, readers on other threads will perceive the state
 * of the database as it was before the write began.  When the write completes, readers
 * on other threads will then perceive the new state of the database.
 * </p><p>
 * It is a good idea to enable write-ahead logging whenever a database will be
 * concurrently accessed and modified by multiple threads at the same time.
 * However, write-ahead logging uses significantly more memory than ordinary
 * journaling because there are multiple connections to the same database.
 * So if a database will only be used by a single thread, or if optimizing
 * concurrency is not very important, then write-ahead logging should be disabled.
 * </p><p>
 * After calling this method, execution of queries in parallel is enabled as long as
 * the database remains open.  To disable execution of queries in parallel, either
 * call {@link #disableWriteAheadLogging} or close the database and reopen it.
 * </p><p>
 * The maximum number of connections used to execute queries in parallel is
 * dependent upon the device memory and possibly other properties.
 * </p><p>
 * If a query is part of a transaction, then it is executed on the same database handle the
 * transaction was begun.
 * </p><p>
 * Writers should use {@link #beginTransactionNonExclusive()} or
 * {@link #beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)}
 * to start a transaction.  Non-exclusive mode allows database file to be in readable
 * by other threads executing queries.
 * </p><p>
 * If the database has any attached databases, then execution of queries in parallel is NOT
 * possible.  Likewise, write-ahead logging is not supported for read-only databases
 * or memory databases.  In such cases, {@link #enableWriteAheadLogging} returns false.
 * </p><p>
 * The best way to enable write-ahead logging is to pass the
 * {@link #ENABLE_WRITE_AHEAD_LOGGING} flag to {@link #openDatabase}.  This is
 * more efficient than calling {@link #enableWriteAheadLogging}.
 * <code><pre>
 * SQLiteDatabase db = SQLiteDatabase.openDatabase(""db_filename"", cursorFactory,
 * SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING,
 * myDatabaseErrorHandler);
 * </pre></code>
 * </p><p>
 * Another way to enable write-ahead logging is to call {@link #enableWriteAheadLogging}
 * after opening the database.
 * <code><pre>
 * SQLiteDatabase db = SQLiteDatabase.openDatabase(""db_filename"", cursorFactory,
 * SQLiteDatabase.CREATE_IF_NECESSARY, myDatabaseErrorHandler);
 * db.enableWriteAheadLogging();
 * </pre></code>
 * </p><p>
 * See also <a href=""http://sqlite.org/wal.html"">SQLite Write-Ahead Logging</a> for
 * more details about how write-ahead logging works.
 * </p>
 *
 * @return True if write-ahead logging is enabled.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #ENABLE_WRITE_AHEAD_LOGGING
 * @see #disableWriteAheadLogging
 */
","/**
 * This method enables parallel execution of queries from multiple threads on the
 * same database.  It does this by opening multiple connections to the database
 * and using a different database connection for each query.  The database
 * journal mode is also changed to enable writes to proceed concurrently with reads.
 * <p>
 * When write-ahead logging is not enabled (the default), it is not possible for
 * reads and writes to occur on the database at the same time.  Before modifying the
 * database, the writer implicitly acquires an exclusive lock on the database which
 * prevents readers from accessing the database until the write is completed.
 * </p><p>
 * In contrast, when write-ahead logging is enabled (by calling this method), write
 * operations occur in a separate log file which allows reads to proceed concurrently.
 * While a write is in progress, readers on other threads will perceive the state
 * of the database as it was before the write began.  When the write completes, readers
 * on other threads will then perceive the new state of the database.
 * </p><p>
 * It is a good idea to enable write-ahead logging whenever a database will be
 * concurrently accessed and modified by multiple threads at the same time.
 * However, write-ahead logging uses significantly more memory than ordinary
 * journaling because there are multiple connections to the same database.
 * So if a database will only be used by a single thread, or if optimizing
 * concurrency is not very important, then write-ahead logging should be disabled.
 * </p><p>
 * After calling this method, execution of queries in parallel is enabled as long as
 * the database remains open.  To disable execution of queries in parallel, either
 * call {@link #disableWriteAheadLogging} or close the database and reopen it.
 * </p><p>
 * The maximum number of connections used to execute queries in parallel is
 * dependent upon the device memory and possibly other properties.
 * </p><p>
 * If a query is part of a transaction, then it is executed on the same database handle the
 * transaction was begun.
 * </p><p>
 * Writers should use {@link #beginTransactionNonExclusive()} or
 * {@link #beginTransactionWithListenerNonExclusive(SQLiteTransactionListener)}
 * to start a transaction.  Non-exclusive mode allows database file to be in readable
 * by other threads executing queries.
 * </p><p>
 * If the database has any attached databases, then execution of queries in parallel is NOT
 * possible.  Likewise, write-ahead logging is not supported for read-only databases
 * or memory databases.  In such cases, {@link #enableWriteAheadLogging} returns false.
 * </p><p>
 * The best way to enable write-ahead logging is to pass the
 * {@link #ENABLE_WRITE_AHEAD_LOGGING} flag to {@link #openDatabase}.  This is
 * more efficient than calling {@link #enableWriteAheadLogging}.
 * <code><pre>
 * SQLiteDatabase db = SQLiteDatabase.openDatabase(""db_filename"", cursorFactory,
 * SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING,
 * myDatabaseErrorHandler);
 * </pre></code>
 * </p><p>
 * Another way to enable write-ahead logging is to call {@link #enableWriteAheadLogging}
 * after opening the database.
 * <code><pre>
 * SQLiteDatabase db = SQLiteDatabase.openDatabase(""db_filename"", cursorFactory,
 * SQLiteDatabase.CREATE_IF_NECESSARY, myDatabaseErrorHandler);
 * db.enableWriteAheadLogging();
 * </pre></code>
 * </p><p>
 * See also <a href=""http://sqlite.org/wal.html"">SQLite Write-Ahead Logging</a> for
 * more details about how write-ahead logging works.
 * </p>
 *
 * @return True if write-ahead logging is enabled.
 *
 * @throws IllegalStateException if there are transactions in progress at the
 * time this method is called.  WAL mode can only be changed when there are no
 * transactions in progress.
 *
 * @see #ENABLE_WRITE_AHEAD_LOGGING
 * @see #disableWriteAheadLogging
 */
",0,,,0,,,,,,,5,0,"The dependent API `mConfigurationLocked.openFlags` condition check is changed to `mConfigurationLocked.resolveJournalMode().equalsIgnoreCase(SQLiteDatabase.JOURNAL_MODE_WAL)` to determine if write-ahead logging is enabled, this indicates a change in the way the configuration is resolved even though the logic seems semantically equivalent, so the code change type is 5.","Although the method used to check if write-ahead logging is enabled has changed, the overall functionality of the API appears to remain unchanged as the outcome of the method's execution still aligns with the same logic, albeit through a modified condition. This does not suggest a Compatibility Issue, so the CI type is 0."
509,<android.content.pm.ShortcutManager: List<ShortcutInfo> getDynamicShortcuts()>,32,33,,,,"{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",0,,,,,,,4,0,"The code change is the removal of the getFutureOrThrow() wrapper around the mService.getShortcuts() call. However, since the underlying call to mService.getShortcuts() is the same, the return value is likely not affected by this change; the change is related to how the call to the service is made or how the service's response is handled, not to a change in the definition or processing logic of the service call itself.","There is no Compatibility Issue arising due to this change because the change does not affect the return value or exception handling of the API method. The method still returns the same List<ShortcutInfo> and throws the same RuntimeException (rethrown from RemoteException), preserving the method's expected behavior."
510,<android.window.SplashScreenView: void remove()>,32,33,,,,"{
    if (mHasRemoved) {
        return;
    }
    setVisibility(GONE);
    if (mParceledIconBitmap != null) {
        if (mIconView instanceof ImageView) {
            ((ImageView) mIconView).setImageDrawable(null);
        } else if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBitmap.recycle();
        mParceledIconBitmap = null;
    }
    if (mParceledBrandingBitmap != null) {
        mBrandingImageView.setBackground(null);
        mParceledBrandingBitmap.recycle();
        mParceledBrandingBitmap = null;
    }
    if (mParceledIconBackgroundBitmap != null) {
        if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBackgroundBitmap.recycle();
        mParceledIconBackgroundBitmap = null;
    }
    if (mWindow != null) {
        final DecorView decorView = (DecorView) mWindow.peekDecorView();
        if (DEBUG) {
            Log.d(TAG, ""remove starting view"");
        }
        if (decorView != null) {
            decorView.removeView(this);
        }
        restoreSystemUIColors();
        mWindow = null;
    }
    mHasRemoved = true;
}","{
    if (mHasRemoved) {
        return;
    }
    setVisibility(GONE);
    if (mParceledIconBitmap != null) {
        if (mIconView instanceof ImageView) {
            ((ImageView) mIconView).setImageDrawable(null);
        } else if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBitmap.recycle();
        mParceledIconBitmap = null;
    }
    if (mParceledBrandingBitmap != null) {
        mBrandingImageView.setBackground(null);
        mParceledBrandingBitmap.recycle();
        mParceledBrandingBitmap = null;
    }
    if (mParceledIconBackgroundBitmap != null) {
        if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBackgroundBitmap.recycle();
        mParceledIconBackgroundBitmap = null;
    }
    if (mWindow != null) {
        final DecorView decorView = (DecorView) mWindow.peekDecorView();
        if (DEBUG) {
            Log.d(TAG, ""remove starting view"");
        }
        if (decorView != null) {
            decorView.removeView(this);
        }
        mWindow = null;
    }
    mHasRemoved = true;
}",1,"/**
 * <p>Remove this view and release its resource. </p>
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 */
","/**
 * <p>Remove this view and release its resource. </p>
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 */
",0,[@UiThread],[@UiThread],0,,,,,,,0,0,There are no changes in the implementation of the method between the early version and the late version.,"Since there is no change, no Compatibility Issue would arise from this API between the two versions."
511,"<android.service.autofill.UserData.Builder: Builder setFieldClassificationAlgorithmForCategory(String,String,Bundle)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(categoryId);
    if (mCategoryAlgorithms == null) {
        mCategoryAlgorithms = new ArrayMap<>(getMaxCategoryCount());
    }
    if (mCategoryArgs == null) {
        mCategoryArgs = new ArrayMap<>(getMaxCategoryCount());
    }
    mCategoryAlgorithms.put(categoryId, name);
    mCategoryArgs.put(categoryId, args);
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(categoryId);
    if (mCategoryAlgorithms == null) {
        mCategoryAlgorithms = new ArrayMap<>(getMaxCategoryCount());
    }
    if (mCategoryArgs == null) {
        mCategoryArgs = new ArrayMap<>(getMaxCategoryCount());
    }
    mCategoryAlgorithms.put(categoryId, name);
    mCategoryArgs.put(categoryId, args);
    return this;
}",1,"/**
 * Sets the algorithm used for <a href=""#FieldClassification"">field classification</a>
 * for the specified category.
 *
 * <p>The currently available algorithms can be retrieved through
 * {@link AutofillManager#getAvailableFieldClassificationAlgorithms()}.
 *
 * <p>If not set, the
 * {@link AutofillManager#getDefaultFieldClassificationAlgorithm() default algorithm} is
 * used instead.
 *
 * @param categoryId autofill field category.
 * @param name name of the algorithm or {@code null} to used default.
 * @param args optional arguments to the algorithm.
 *
 * @return this builder
 */
","/**
 * Sets the algorithm used for <a href=""#FieldClassification"">field classification</a>
 * for the specified category.
 *
 * <p>The currently available algorithms can be retrieved through
 * {@link AutofillManager#getAvailableFieldClassificationAlgorithms()}.
 *
 * <p>If not set, the
 * {@link AutofillManager#getDefaultFieldClassificationAlgorithm() default algorithm} is
 * used instead.
 *
 * @param categoryId autofill field category.
 * @param name name of the algorithm or {@code null} to used default.
 * @param args optional arguments to the algorithm.
 *
 * @return this builder
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,"The change from Preconditions.checkNotNull(categoryId) to Objects.requireNonNull(categoryId) is a change in the method used for null-checking the categoryId parameter. This is an internal check and does not affect the external behavior of the method, hence the code change type is 4.","There is no compatibility issue with this change because both methods Preconditions.checkNotNull() and Objects.requireNonNull() serve the same purpose of checking for non-null values and will throw a NullPointerException when the checked value is null. The external behavior of the API has not changed; hence, there is no compatibility issue."
513,"<android.provider.Settings.Global: long getLong(ContentResolver,String)>",32,33,,,,"{
    String valString = getString(cr, name);
    try {
        return Long.parseLong(valString);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    String v = getString(cr, name);
    return parseLongSetting(v, name);
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
",0,,,0,,,,,,,"1,4,5","1,2","The implementation has changed to call a different method (parseLongSetting) to parse the long value, the exception handling has changed, and the variable name has been changed from 'valString' to 'v', this can be classified as a change in the return statement, an other statement change, and a dependent API changed. The code change type is therefore 1,4,5.","The new method parseLongSetting can potentially behave differently compared to Long.parseLong; it might handle NumberFormatException differently, or possibly not at all if parseLongSetting is implemented to return a default value or throw a different exception when parsing fails. This might result in a different return value in case of a parsing error or a different exception being thrown. Therefore, there could be a Compatibility Issue caused by potential different return values or types as well as different exception handlings, so the CI type is 1,2."
514,<android.view.autofill.AutofillManager: void notifyValueChanged(View)>,32,33,,,,"{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false, false);
        } else {
            id = view.getAutofillId();
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                final boolean hideHighlight = mLastAutofilledData.keySet().size() == 1;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true, hideHighlight);
                } else {
                    view.setAutofilled(false, false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false, false);
            }
        }
        if (!mEnabled || !isActiveLocked()) {
            if (!startAutofillIfNeededLocked(view)) {
                if (sVerbose) {
                    Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + ""): ignoring on state "" + getStateAsStringLocked());
                }
            }
            return;
        }
        if (id == null) {
            id = view.getAutofillId();
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0);
    }
}","{
    if (!hasAutofillFeature()) {
        return;
    }
    AutofillId id = null;
    boolean valueWasRead = false;
    AutofillValue value = null;
    synchronized (mLock) {
        // remove the isAutofilled property even if no sessions are active.
        if (mLastAutofilledData == null) {
            view.setAutofilled(false, false);
        } else {
            id = view.getAutofillId();
            if (mLastAutofilledData.containsKey(id)) {
                value = view.getAutofillValue();
                valueWasRead = true;
                final boolean hideHighlight = mLastAutofilledData.keySet().size() == 1;
                if (Objects.equals(mLastAutofilledData.get(id), value)) {
                    view.setAutofilled(true, hideHighlight);
                } else {
                    view.setAutofilled(false, false);
                    mLastAutofilledData.remove(id);
                }
            } else {
                view.setAutofilled(false, false);
            }
        }
        if (!mEnabled || !isActiveLocked()) {
            if (!startAutofillIfNeededLocked(view)) {
                if (sVerbose) {
                    Log.v(TAG, ""notifyValueChanged("" + view.getAutofillId() + ""): ignoring on state "" + getStateAsStringLocked());
                }
            }
            return;
        }
        if (id == null) {
            id = view.getAutofillId();
        }
        if (!valueWasRead) {
            value = view.getAutofillValue();
        }
        updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, getImeStateFlag(view));
    }
}",1,"/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
","/**
 * Called to indicate the value of an autofillable {@link View} changed.
 *
 * @param view view whose value changed.
 */
",0,,,0,,,,,,,"4,5",1,"The only difference between the early and late versions is the addition of an extra parameter to the `updateSessionLocked` method call (from `updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, 0)` to `updateSessionLocked(id, null, value, ACTION_VALUE_CHANGED, getImeStateFlag(view))`). This signifies a change in the dependent API being called, thus the change type is 4,5.","Since the dependent API `updateSessionLocked` now receives a different argument, this could lead to a different behavior, and a CI might arise because the API may now behave differently based on the additional flag provided by `getImeStateFlag(view)`. The CI type is classified as 1 because the return type or value (though void, the behavior and side effects of the method) may be different as a result of this changed parameter."
515,<android.view.View: String toString()>,32,33,,,,"{
    StringBuilder out = new StringBuilder(128);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id > 0 && Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    if (mAutofillId != null) {
        out.append("" aid="");
        out.append(mAutofillId);
    }
    out.append(""}"");
    return out.toString();
}","{
    StringBuilder out = new StringBuilder(256);
    out.append(getClass().getName());
    out.append('{');
    out.append(Integer.toHexString(System.identityHashCode(this)));
    out.append(' ');
    switch(mViewFlags & VISIBILITY_MASK) {
        case VISIBLE:
            out.append('V');
            break;
        case INVISIBLE:
            out.append('I');
            break;
        case GONE:
            out.append('G');
            break;
        default:
            out.append('.');
            break;
    }
    out.append((mViewFlags & FOCUSABLE) == FOCUSABLE ? 'F' : '.');
    out.append((mViewFlags & ENABLED_MASK) == ENABLED ? 'E' : '.');
    out.append((mViewFlags & DRAW_MASK) == WILL_NOT_DRAW ? '.' : 'D');
    out.append((mViewFlags & SCROLLBARS_HORIZONTAL) != 0 ? 'H' : '.');
    out.append((mViewFlags & SCROLLBARS_VERTICAL) != 0 ? 'V' : '.');
    out.append((mViewFlags & CLICKABLE) != 0 ? 'C' : '.');
    out.append((mViewFlags & LONG_CLICKABLE) != 0 ? 'L' : '.');
    out.append((mViewFlags & CONTEXT_CLICKABLE) != 0 ? 'X' : '.');
    out.append(' ');
    out.append((mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) != 0 ? 'R' : '.');
    out.append((mPrivateFlags & PFLAG_FOCUSED) != 0 ? 'F' : '.');
    out.append((mPrivateFlags & PFLAG_SELECTED) != 0 ? 'S' : '.');
    if ((mPrivateFlags & PFLAG_PREPRESSED) != 0) {
        out.append('p');
    } else {
        out.append((mPrivateFlags & PFLAG_PRESSED) != 0 ? 'P' : '.');
    }
    out.append((mPrivateFlags & PFLAG_HOVERED) != 0 ? 'H' : '.');
    out.append((mPrivateFlags & PFLAG_ACTIVATED) != 0 ? 'A' : '.');
    out.append((mPrivateFlags & PFLAG_INVALIDATED) != 0 ? 'I' : '.');
    out.append((mPrivateFlags & PFLAG_DIRTY_MASK) != 0 ? 'D' : '.');
    out.append(' ');
    out.append(mLeft);
    out.append(',');
    out.append(mTop);
    out.append('-');
    out.append(mRight);
    out.append(',');
    out.append(mBottom);
    final int id = getId();
    if (id != NO_ID) {
        out.append("" #"");
        out.append(Integer.toHexString(id));
        final Resources r = mResources;
        if (id > 0 && Resources.resourceHasPackage(id) && r != null) {
            try {
                String pkgname;
                switch(id & 0xff000000) {
                    case 0x7f000000:
                        pkgname = ""app"";
                        break;
                    case 0x01000000:
                        pkgname = ""android"";
                        break;
                    default:
                        pkgname = r.getResourcePackageName(id);
                        break;
                }
                String typename = r.getResourceTypeName(id);
                String entryname = r.getResourceEntryName(id);
                out.append("" "");
                out.append(pkgname);
                out.append("":"");
                out.append(typename);
                out.append(""/"");
                out.append(entryname);
            } catch (Resources.NotFoundException e) {
            }
        }
    }
    if (mAutofillId != null) {
        out.append("" aid="");
        out.append(mAutofillId);
    }
    out.append(""}"");
    return out.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
517,<android.os.BaseBundle: Object get(String)>,32,33,,,,"{
    unparcel();
    return mMap.get(key);
}","{
    unparcel();
    return getValue(key);
}",1,"/**
 * Returns the entry with the given key as an object.
 *
 * @param key a String key
 * @return an Object, or null
 */
","/**
 * Returns the entry with the given key as an object.
 *
 * @param key a String key
 * @return an Object, or null
 *
 * @deprecated Use the type-safe specific APIs depending on the type of the item to be
 * retrieved, eg. {@link #getString(String)}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"4,5",0,"The only change in the method's implementation is that it's now calling getValue(key) instead of mMap.get(key). The method getValue is a different API that the current API now depends on. This is a dependent API changed situation, so the change is classified as 4,5.","Despite the change in how the value is obtained within the method, there is no indication that the actual behavior of the method in terms of return value or exception handling has changed. The use of a different method (getValue) to retrieve the data does not necessarily imply a change in the return type or value, as getValue could internally do the same thing as mMap.get(key). Unless evidence is present that indicates behavioral change, we can conclude no compatibility issue (0)."
518,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkState(mPresentation != null, ""Dataset presentation not set on constructor"");
    setLifeTheUniverseAndEverything(id, value, null, null, new DatasetFieldFilter(filter));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkState(mPresentation != null, ""Dataset presentation not set on constructor"");
    setLifeTheUniverseAndEverything(id, value, null, null, null, new DatasetFieldFilter(filter), null);
    return this;
}",1,"/**
 * Sets the value of a field using an <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling {@link #setValue(AutofillId, AutofillValue)} and
 * use the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 *
 * @return this builder.
 * @throws IllegalStateException if the builder was constructed without a
 * {@link RemoteViews presentation} or {@link #build()} was already called.
 */
","/**
 * Sets the value of a field using an <a href=""#Filtering"">explicit filter</a>.
 *
 * <p>This method is typically used when the dataset requires authentication and the service
 * does not know its value but wants to hide the dataset after the user enters a minimum
 * number of characters. For example, if the dataset represents a credit card number and the
 * service does not want to show the ""Tap to authenticate"" message until the user tapped
 * 4 digits, in which case the filter would be {@code Pattern.compile(""\\d.{4,}"")}.
 *
 * <p><b>Note:</b> If the dataset requires authentication but the service knows its text
 * value it's easier to filter by calling {@link #setValue(AutofillId, AutofillValue)} and
 * use the value to filter.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 *
 * @return this builder.
 * @throws IllegalStateException if the builder was constructed without a
 * {@link RemoteViews presentation} or {@link #build()} was already called.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"4,5",0,"The 'setLifeTheUniverseAndEverything' method's call in the late version includes additional null parameters, which is a dependent API change. The API's declaration remains the same, but its internal behavior (how it calls a dependent API) has changed, so the code change type is 4,5. However, these changes should not affect the inputs and outputs of this method directly because the additional null parameters do not change the method's behavior from the perspective of this API; they could be related to internal state or behavior not exposed through this method.","As the changes in this specific method are only related to the internal call with added null arguments to the dependent API, and as long as the method (setLifeTheUniverseAndEverything), handles the additional nulls appropriately resulting in the same behavior observed outside the method, there should be no compatibility issue caused by these changes. The dependent API's change does not alter the contract of the method in a way that would return different values or throw new exceptions due to this change. Therefore, even though the internal call has changed, it is not expected to cause a Compatibility Issue from the perspective of a client calling this API method."
519,<android.view.accessibility.AccessibilityWindowInfo: AccessibilityNodeInfo getRoot()>,32,33,,,,"{
    if (mConnectionId == UNDEFINED_WINDOW_ID) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mId, AccessibilityNodeInfo.ROOT_NODE_ID, true, AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS, null);
}","{
    return getRoot(AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS_HYBRID);
}",1,"/**
 * Gets the root node in the window's hierarchy.
 *
 * @return The root node.
 */
","/**
 * Gets the root node in the window's hierarchy.
 *
 * @return The root node.
 */
",0,,,0,,,,,,,"4,5",0,"The late implementation calls a different method getRoot(int) with a static final flag compared to multiple method calls and checks in the early version. The details of the new 'getRoot' method implementation are not provided, implying a Dependent API change. There's no return statement or exception handling changes since the logic of determining the return value or raised exception has moved to another method.",There's no Compatibility Issue as the method effectively delegates the functionality to another method without changing its signature or expected behavior. It's presumed that the new method handles null checks and connections ID checks internally to maintain compatibility.
525,<android.net.LocalSocket: LocalSocket createLocalSocketForAccept(LocalSocketImpl)>,32,33,,,,"{
    return createConnectedLocalSocket(impl, SOCKET_UNKNOWN);
}","{
    LocalSocket socket = new LocalSocket(impl, SOCKET_UNKNOWN);
    socket.checkConnected();
    return socket;
}",1,"/**
 * for use with LocalServerSocket.accept()
 */
","/**
 * for use with LocalServerSocket.accept()
 */
",0,,,0,,,,,,,"1,4",1,"The implementation of the method changed from a single return statement to creating a new LocalSocket object, calling `checkConnected` on it, and then returning it. This is an other statement change (the addition of object creation and the checkConnected() method call), and also the original method createConnectedLocalSocket was replaced with new operations, which affects the return statement.","The added method `checkConnected` could potentially throw new exceptions or affect the returned `LocalSocket` object's state, leading to different behavior. Therefore, a CI could be caused by the potential for different return values or types, indicated by CI type 1."
526,<android.net.Ikev2VpnProfile: String getServerAddr()>,32,33,,,,"{
    return mServerAddr;
}","{
    if (mIkeTunConnParams == null)
        return mServerAddr;
    final IkeSessionParams ikeSessionParams = mIkeTunConnParams.getIkeSessionParams();
    return ikeSessionParams.getServerHostname();
}",1,"/**
 * Retrieves the server address string.
 */
","/**
 * Retrieves the server address string.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"3,5",1,"The code now includes a new control dependency ('if' statement) and the return statement is changed when `mIkeTunConnParams` is non-null: it calls a method from a dependent API `ikeSessionParams.getServerHostname()` instead of returning `mServerAddr` directly, so the code change types are 3 for the control structure change and 5 for the dependent API change.","If `mIkeTunConnParams` is non-null, the late version of the API now returns a different value extracted from the `ikeSessionParams` object, which could potentially be different from `mServerAddr`. Hence, the compatibility issue type is 1."
527,<android.view.inputmethod.CursorAnchorInfo: String toString()>,32,33,,,,"{
    return ""CursorAnchorInfo{mHashCode="" + mHashCode + "" mSelection="" + mSelectionStart + "","" + mSelectionEnd + "" mComposingTextStart="" + mComposingTextStart + "" mComposingText="" + Objects.toString(mComposingText) + "" mInsertionMarkerFlags="" + mInsertionMarkerFlags + "" mInsertionMarkerHorizontal="" + mInsertionMarkerHorizontal + "" mInsertionMarkerTop="" + mInsertionMarkerTop + "" mInsertionMarkerBaseline="" + mInsertionMarkerBaseline + "" mInsertionMarkerBottom="" + mInsertionMarkerBottom + "" mCharacterBoundsArray="" + Objects.toString(mCharacterBoundsArray) + "" mMatrix="" + Arrays.toString(mMatrixValues) + ""}"";
}","{
    return ""CursorAnchorInfo{mHashCode="" + mHashCode + "" mSelection="" + mSelectionStart + "","" + mSelectionEnd + "" mComposingTextStart="" + mComposingTextStart + "" mComposingText="" + Objects.toString(mComposingText) + "" mInsertionMarkerFlags="" + mInsertionMarkerFlags + "" mInsertionMarkerHorizontal="" + mInsertionMarkerHorizontal + "" mInsertionMarkerTop="" + mInsertionMarkerTop + "" mInsertionMarkerBaseline="" + mInsertionMarkerBaseline + "" mInsertionMarkerBottom="" + mInsertionMarkerBottom + "" mCharacterBoundsArray="" + Objects.toString(mCharacterBoundsArray) + "" mEditorBoundsInfo="" + mEditorBoundsInfo + "" mMatrix="" + Arrays.toString(mMatrixValues) + ""}"";
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The implementation has added the "" mEditorBoundsInfo="" + mEditorBoundsInfo field in the toString method. This change does not affect the behavior of how the method works, it only adds additional information to the string representation of the object, so the change type is 4 (Other statement changed).","Since the modification only affects the string representation and does not change the logic or behavior of the method, there is no Compatibility Issue arising from this change. The API will behave the same way, and the additional information will not affect the invocation of the method in any way that affects the previous version's compatibility."
528,<android.net.Ikev2VpnProfile: X509Certificate getServerRootCaCert()>,32,33,,,,"{
    return mServerRootCaCert;
}","{
    if (mIkeTunConnParams != null)
        return null;
    return mServerRootCaCert;
}",1,"/**
 * Retrieves the certificate for the server's root CA.
 *
 * <p>May be null if the profile is not using RSA Digital Signature Authentication or
 * Username/Password authentication
 */
","/**
 * Retrieves the certificate for the server's root CA.
 *
 * <p>May be null if the profile is not using RSA Digital Signature Authentication or
 * Username/Password authentication, or the profile is built from an
 * {@link IkeTunnelConnectionParams}.
 */
",1,[@Nullable],[@Nullable],0,,,,,,,"1,3",1,"The introduction of a new control statement 'if' and the potential to return 'null' instead of mServerRootCaCert has changed, so the change type is 1,3.","The added condition potentially causes the method to return null instead of the actual certificate object, thus the late version can behave differently from the early version by potentially returning a different value (null). The CI type is 1."
529,<android.service.autofill.Dataset.Builder: Builder setInlinePresentation(InlinePresentation)>,32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation must be non-null"");
    mInlinePresentation = inlinePresentation;
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(inlinePresentation, ""inlinePresentation must be non-null"");
    mInlinePresentation = inlinePresentation;
    return this;
}",1,"/**
 * Sets the {@link InlinePresentation} used to visualize this dataset as inline suggestions.
 * If the dataset supports inline suggestions this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the {@link InlinePresentation} used to visualize this dataset as inline suggestions.
 * If the dataset supports inline suggestions this should not be null.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #Builder(Presentations)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,4,0,"There was a change from using Preconditions.checkNotNull to Objects.requireNonNull for the null check, which is an equivalent method, so the code change type is 4. Additionally, the Late_Version has been annotated with @Deprecated.","There is no Compatibility Issue because both Preconditions.checkNotNull and Objects.requireNonNull serve the same purpose of throwing a NullPointerException if the object is null, thus the behavior of the API has not changed."
530,<android.os.Parcel: SparseArray<T> readSparseArray(ClassLoader)>,32,33,,,,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    SparseArray sa = new SparseArray(N);
    readSparseArrayInternal(sa, N, loader);
    return sa;
}","{
    return readSparseArrayInternal(loader, /* clazz */
    null);
}",1,"/**
 * Read and return a new SparseArray object from the parcel at the current
 * dataPosition().  Returns null if the previously written list object was
 * null.  The given class loader will be used to load any enclosed
 * Parcelables.
 */
","/**
 * Read and return a new SparseArray object from the parcel at the current
 * dataPosition().  Returns null if the previously written list object was
 * null.  The given class loader will be used to load any enclosed
 * Parcelables.
 *
 * @deprecated Use the type-safer version {@link #readSparseArray(ClassLoader, Class)} starting
 * from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the format to
 * use {@link #createTypedSparseArray(Parcelable.Creator)} if possible (eg. if the items'
 * class is final) since this is also more performant. Note that changing to the latter
 * also requires changing the writes.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"1,4,5",1,"The return statement has been changed, with the introduction of a new method call to readSparseArrayInternal(loader, /* clazz */ null) that replaces several lines of code from the early version. Additionally, there's a complete change in the implementation approach and dependent APIs are also changed, so the code change types are 1, 4, and 5.","The replacement of the early implementation with a new implementation that involves calling a different method can lead to a different return value because the internals of readSparseArrayInternal could work differently from the previous code block. Therefore, there is a potential compatibility issue caused by the potential for different return values or types, and the CI type is 1."
532,<android.service.voice.AlwaysOnHotwordDetector.EventPayload: byte[] getTriggerAudio()>,32,33,,,,"{
    if (mTriggerAvailable) {
        return mData;
    } else {
        return null;
    }
}","{
    if (mDataFormat == DATA_FORMAT_TRIGGER_AUDIO) {
        return mData;
    } else {
        return null;
    }
}",1,"/**
 * Gets the raw audio that triggered the keyphrase.
 * This may be null if the trigger audio isn't available.
 * If non-null, the format of the audio can be obtained by calling
 * {@link #getCaptureAudioFormat()}.
 *
 * @see AlwaysOnHotwordDetector#RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO
 */
","/**
 * Gets the raw audio that triggered the keyphrase.
 * This may be null if the trigger audio isn't available.
 * If non-null, the format of the audio can be obtained by calling
 * {@link #getCaptureAudioFormat()}.
 *
 * @see AlwaysOnHotwordDetector#RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO
 * @deprecated Use {@link #getData()} instead.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,3,0,"Only the condition in the if statement has been changed from 'mTriggerAvailable' to 'mDataFormat == DATA_FORMAT_TRIGGER_AUDIO', so the change type is 3.","Despite the condition change, the method in either version returns ""mData"" when the condition is true and ""null"" when the condition is false. Thus, there is no change in the possible return values of the method, so there is no Compatibility Issue (0)."
533,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,32,33,,,,"{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    try {
        WindowManagerGlobal.getWindowManagerService().injectInputAfterTransactionsApplied(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH, true);
    } catch (RemoteException e) {
    }
}","{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    syncInputTransactionsAndInjectEventIntoSelf(event);
}",1,"/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
","/**
 * Dispatches a pointer event into a window owned by the instrumented application, and waits for
 * it to be processed.
 * <p>
 * If the motion event being injected is targeted at a window that is not owned by the
 * instrumented application, the input injection will fail. See {@link #getUiAutomation()} for
 * injecting events into all windows.
 * <p>
 * This method blocks until the recipient has finished handling the event. Note that the
 * recipient may <em>not</em> have completely finished reacting from the event when this method
 * returns. For example, it may still be in the process of updating its display or UI contents
 * upon reacting to the injected event.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
",1,,,0,,,,,,,"4,5",0,"The code has changed wherein a call to a method (syncInputTransactionsAndInjectEventIntoSelf(event)) replaced a block of code involving a try-catch statement for a RemoteException. Additionally, the implementation of syncInputTransactionsAndInjectEventIntoSelf() is not provided, so it's assumed to act as a wrapper for the try-catch block with the WindowManagerGlobal.getWindowManagerService().injectInputAfterTransactionsApplied() call, which is considered a change in the dependent API; this is indicated by the code change type 4,5.","Even though there is a change in how the input event is sent, without further knowledge about the syncInputTransactionsAndInjectEventIntoSelf(event) method, it cannot be determined that this change leads to a potential different return value or exception handling. There's a presumption that the method is a direct replacement meant to encapsulate the prior code within and therefore does not introduce a compatibility issue. Thus, the CI type is 0."
534,"<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>",32,33,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The position of 'excludedPermissions' within the method broadcastIntentWithFeature() call has changed from being a directly passed value of AppOpsManager.OP_NONE to occupying the position where previous 'null' value was, while the previous 'null' position is now assigned as AppOpsManager.OP_NONE. There is no modification in the functional behavior of the API, the number, or types of the parameters effectively passed to the method.","There is no compatibility issue expected because the values being passed to the method remain the same, just the position within the argument list has been interchanged. This should not affect the behavior of sendBroadcastAsUserMultiplePermissions() since the method signature of broadcastIntentWithFeature() has presumably not changed, it is just receiving the parameters in a different order, which are internal and implementation-specific details."
535,<android.companion.AssociationRequest.Builder: AssociationRequest build()>,32,33,,,,"{
    markUsed();
    return new AssociationRequest(mSingleDevice, emptyIfNull(mDeviceFilters), mDeviceProfile, null, null, -1L, false);
}","{
    markUsed();
    if (mSelfManaged && mDisplayName == null) {
        throw new IllegalStateException(""Request for a self-managed association MUST "" + ""provide the display name of the device"");
    }
    return new AssociationRequest(mSingleDevice, emptyIfNull(mDeviceFilters), mDeviceProfile, mDisplayName, mSelfManaged, mForceConfirmation);
}",1,"/**
 * @inheritDoc
 */
","/**
 * @inheritDoc
 */
",0,"[@NonNull, @Override]","[@NonNull, @Override]",0,,,,,,,"1,3,5","1,2","The return statement has changed due to different parameters being passed to the `AssociationRequest` constructor, an `if` control statement has been introduced, and an exception is being thrown if certain conditions aren't met. Additionally, there is a potential change in the dependent API `AssociationRequest` constructor because of the different parameters. Therefore, the code change types are 1, 3, and 5.","The introduction of an `if` that throws an exception based on `mSelfManaged` and `mDisplayName` being a certain state introduces a new possible exception, which is a CI of type 2. Furthermore, the changes in what is being passed to the `AssociationRequest` constructor can result in the method returning a differently constructed object, which is a CI of type 1."
537,"<android.text.StaticLayout.Builder: Builder obtain(CharSequence,int,int,TextPaint,int)>",32,33,,,,"{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = DEFAULT_LINESPACING_MULTIPLIER;
    b.mSpacingAdd = DEFAULT_LINESPACING_ADDITION;
    b.mIncludePad = true;
    b.mFallbackLineSpacing = false;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;
    return b;
}","{
    Builder b = sPool.acquire();
    if (b == null) {
        b = new Builder();
    }
    // set default initial values
    b.mText = source;
    b.mStart = start;
    b.mEnd = end;
    b.mPaint = paint;
    b.mWidth = width;
    b.mAlignment = Alignment.ALIGN_NORMAL;
    b.mTextDir = TextDirectionHeuristics.FIRSTSTRONG_LTR;
    b.mSpacingMult = DEFAULT_LINESPACING_MULTIPLIER;
    b.mSpacingAdd = DEFAULT_LINESPACING_ADDITION;
    b.mIncludePad = true;
    b.mFallbackLineSpacing = false;
    b.mEllipsizedWidth = width;
    b.mEllipsize = null;
    b.mMaxLines = Integer.MAX_VALUE;
    b.mBreakStrategy = Layout.BREAK_STRATEGY_SIMPLE;
    b.mHyphenationFrequency = Layout.HYPHENATION_FREQUENCY_NONE;
    b.mJustificationMode = Layout.JUSTIFICATION_MODE_NONE;
    b.mLineBreakConfig = LineBreakConfig.NONE;
    return b;
}",1,"/**
 * Obtain a builder for constructing StaticLayout objects.
 *
 * @param source The text to be laid out, optionally with spans
 * @param start The index of the start of the text
 * @param end The index + 1 of the end of the text
 * @param paint The base paint used for layout
 * @param width The width in pixels
 * @return a builder object used for constructing the StaticLayout
 */
","/**
 * Obtain a builder for constructing StaticLayout objects.
 *
 * @param source The text to be laid out, optionally with spans
 * @param start The index of the start of the text
 * @param end The index + 1 of the end of the text
 * @param paint The base paint used for layout
 * @param width The width in pixels
 * @return a builder object used for constructing the StaticLayout
 */
",0,[@NonNull],[@NonNull],0,,,,,,,4,0,"An assignment statement setting the 'mLineBreakConfig' to 'LineBreakConfig.NONE' has been added to the late version of the code, representing a change type of 4 (Other statement changed).","The new assignment does not alter the behavior of the existing code nor does it change the return type or value. Therefore, no compatibility issue arises from this alteration, as it appears to be setting a default value on a new field without affecting existing logic."
538,<android.widget.RemoteViews.BitmapCache: Bitmap getBitmapForId(int)>,32,33,,,,"{
    if (id == -1 || id >= mBitmaps.size()) {
        return null;
    } else {
        return mBitmaps.get(id);
    }
}","{
    if (id == -1 || id >= mBitmaps.size()) {
        return null;
    }
    return mBitmaps.get(id);
}",1,,,0,[@Nullable],[@Nullable],0,,,,,,,0,0,"There is no functional change to the logic of the code, only a redundant 'else' branch has been removed.",There is no Compatibility Issue since the behavior of the API has not changedâ€”it still checks the same conditions and returns the same values.
540,"<android.content.res.TypedArray: int getDimensionPixelOffset(int,int)>",32,33,,,,"{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type));
}","{
    if (mRecycled) {
        throw new RuntimeException(""Cannot make calls to a recycled instance!"");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException(""Failed to resolve attribute at index "" + attrIndex + "": "" + value + "", theme="" + mTheme);
    }
    throw new UnsupportedOperationException(""Can't convert value at index "" + attrIndex + "" to dimension: type=0x"" + Integer.toHexString(type) + "", theme="" + mTheme);
}",1,"/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
","/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */
",0,,,0,,,,,,,4,0,"The code has been changed by adding additional information to the exception messages (adding `, theme=` + mTheme to the messages), so the code change type is 4.","The functional behavior of the method has not been altered; the additional information in exception messages does not cause a compatibility issue because it does not affect the return value or the type of exceptions thrown by the method. Thus, no compatibility issue is expected."
541,"<android.provider.Settings.Global: int getInt(ContentResolver,String,int)>",32,33,,,,"{
    String v = getString(cr, name);
    try {
        return v != null ? Integer.parseInt(v) : def;
    } catch (NumberFormatException e) {
        return def;
    }
}","{
    String v = getString(cr, name);
    return parseIntSettingWithDefault(v, def);
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
",0,,,0,,,,,,,"4,5",1,"The late implementation calls a different method, `parseIntSettingWithDefault`, instead of directly performing the parsing and default handling within the getInt method, which might indicate that the logic for parsing and exception handling has been abstracted to another method. This change is classified as 4 (Other statement changed) because the implementation within `getInt` changed without altering control structures, and as 5 (Dependent API changed) because it now relies on the new method `parseIntSettingWithDefault`.","As the implementation now relies on the `parseIntSettingWithDefault` method, without further information on how this new method behaves in comparison to the inline code from the previous version, there is potential for a different return value, hence the CI type is 1."
542,<android.net.Ikev2VpnProfile: boolean equals(Object)>,32,33,,,,"{
    if (!(obj instanceof Ikev2VpnProfile)) {
        return false;
    }
    final Ikev2VpnProfile other = (Ikev2VpnProfile) obj;
    return mType == other.mType && Objects.equals(mServerAddr, other.mServerAddr) && Objects.equals(mUserIdentity, other.mUserIdentity) && Arrays.equals(mPresharedKey, other.mPresharedKey) && Objects.equals(mServerRootCaCert, other.mServerRootCaCert) && Objects.equals(mUsername, other.mUsername) && Objects.equals(mPassword, other.mPassword) && Objects.equals(mRsaPrivateKey, other.mRsaPrivateKey) && Objects.equals(mUserCert, other.mUserCert) && Objects.equals(mProxyInfo, other.mProxyInfo) && Objects.equals(mAllowedAlgorithms, other.mAllowedAlgorithms) && mIsBypassable == other.mIsBypassable && mIsMetered == other.mIsMetered && mMaxMtu == other.mMaxMtu && mIsRestrictedToTestNetworks == other.mIsRestrictedToTestNetworks;
}","{
    if (!(obj instanceof Ikev2VpnProfile)) {
        return false;
    }
    final Ikev2VpnProfile other = (Ikev2VpnProfile) obj;
    return mType == other.mType && Objects.equals(mServerAddr, other.mServerAddr) && Objects.equals(mUserIdentity, other.mUserIdentity) && Arrays.equals(mPresharedKey, other.mPresharedKey) && Objects.equals(mServerRootCaCert, other.mServerRootCaCert) && Objects.equals(mUsername, other.mUsername) && Objects.equals(mPassword, other.mPassword) && Objects.equals(mRsaPrivateKey, other.mRsaPrivateKey) && Objects.equals(mUserCert, other.mUserCert) && Objects.equals(mProxyInfo, other.mProxyInfo) && Objects.equals(mAllowedAlgorithms, other.mAllowedAlgorithms) && mIsBypassable == other.mIsBypassable && mIsMetered == other.mIsMetered && mMaxMtu == other.mMaxMtu && mIsRestrictedToTestNetworks == other.mIsRestrictedToTestNetworks && mExcludeLocalRoutes == other.mExcludeLocalRoutes && mRequiresInternetValidation == other.mRequiresInternetValidation && Objects.equals(mIkeTunConnParams, other.mIkeTunConnParams);
}",1,,,0,[@Override],[@Override],0,,,,,,,1,1,"The return statement in the late version includes additional conditions and object comparisons (mExcludeLocalRoutes == other.mExcludeLocalRoutes, mRequiresInternetValidation == other.mRequiresInternetValidation, and Objects.equals(mIkeTunConnParams, other.mIkeTunConnParams)) not found in the early version. Therefore, the code change type is 1.","These changes in the return statement could cause the late version API to return a different value when compared to the early version, since additional properties of the object are now being checked for equality. Thus, the CI type is 1."
545,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo getRootInActiveWindow()>,32,33,,,,"{
    return AccessibilityInteractionClient.getInstance(this).getRootInActiveWindow(mConnectionId);
}","{
    return getRootInActiveWindow(AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS_HYBRID);
}",1,"/**
 * Gets the root node in the currently active window if this service
 * can retrieve window content. The active window is the one that the user
 * is currently touching or the window with input focus, if the user is not
 * touching any window. It could be from any logical display.
 * <p>
 * The currently active window is defined as the window that most recently fired one
 * of the following events:
 * {@link AccessibilityEvent#TYPE_WINDOW_STATE_CHANGED},
 * {@link AccessibilityEvent#TYPE_VIEW_HOVER_ENTER},
 * {@link AccessibilityEvent#TYPE_VIEW_HOVER_EXIT}.
 * In other words, the last window shown that also has input focus.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to access the root node your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @return The root node if this service can retrieve window content.
 */
","/**
 * Gets the root node in the currently active window if this service
 * can retrieve window content. The active window is the one that the user
 * is currently touching or the window with input focus, if the user is not
 * touching any window. It could be from any logical display.
 * <p>
 * <strong>Note:</strong> In order to access the root node your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @return The root node if this service can retrieve window content.
 * @see AccessibilityWindowInfo#isActive() for more explanation about the active window.
 */
",1,,,0,,,,,,,"1,5",1,"The method that is being called within the return statement has changed from 'AccessibilityInteractionClient.getInstance(this).getRootInActiveWindow(mConnectionId)' to 'getRootInActiveWindow(AccessibilityNodeInfo.FLAG_PREFETCH_DESCENDANTS_HYBRID)' and the parameter passed is also different. Therefore, the return statement is altered, and a dependent API is changed since the method called and the value it depends on is different. The code change type is 1,5.","The change to the return statement could potentially result in different return values or types due to the different dependent method being called and its parameter; hence, the CI type is 1."
546,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain(AccessibilityNodeInfo)>,32,33,,,,"{
    AccessibilityNodeInfo infoClone = AccessibilityNodeInfo.obtain();
    infoClone.init(info, true);
    return infoClone;
}","{
    return new AccessibilityNodeInfo(info);
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * create. The returned instance is initialized from the given
 * <code>info</code>.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo(AccessibilityNodeInfo)} instead.
 *
 * @param info The other info.
 * @return An instance.
 */
","/**
 * Instantiates a new AccessibilityNodeInfo initialized from the given
 * <code>info</code>.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo(AccessibilityNodeInfo)} instead.
 * @param info The other info.
 * @return An instance.
 */
",1,,[@Deprecated],1,,,,,,,"1,5",1,"The implementation has been changed from using 'AccessibilityNodeInfo.obtain()' followed by 'init()' to directly invoking the constructor 'new AccessibilityNodeInfo(info)', thus there is a change in the dependent API (5) and the return statement has also changed (1).","The manner in which the AccessibilityNodeInfo is obtained and initialized has changed, invoking a new constructor instead of calling 'obtain()' and 'init()' may result in different initializations of the object, leading to CI caused by potentially different return values, so the CI type is 1."
547,"<android.service.autofill.FillResponse.Builder: Builder setAuthentication(AutofillId[],IntentSender,RemoteViews,InlinePresentation,InlinePresentation)>",32,33,,,,"{
    throwIfDestroyed();
    throwIfDisableAutofillCalled();
    if (mHeader != null || mFooter != null) {
        throw new IllegalStateException(""Already called #setHeader() or #setFooter()"");
    }
    if (authentication == null ^ (presentation == null && inlinePresentation == null)) {
        throw new IllegalArgumentException(""authentication and presentation "" + ""(dropdown or inline), must be both non-null or null"");
    }
    mAuthentication = authentication;
    mPresentation = presentation;
    mInlinePresentation = inlinePresentation;
    mInlineTooltipPresentation = inlineTooltipPresentation;
    mAuthenticationIds = assertValid(ids);
    return this;
}","{
    throwIfDestroyed();
    throwIfDisableAutofillCalled();
    return setAuthentication(ids, authentication, presentation, inlinePresentation, inlineTooltipPresentation, null);
}",1,"/**
 * Triggers a custom UI before before autofilling the screen with any data set in this
 * response.
 *
 * <p>This method like
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews, InlinePresentation)}
 * but allows setting an {@link InlinePresentation} for the inline suggestion tooltip.
 */
","/**
 * Triggers a custom UI before autofilling the screen with any data set in this
 * response.
 *
 * <p>This method like
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews, InlinePresentation)}
 * but allows setting an {@link InlinePresentation} for the inline suggestion tooltip.
 *
 * @deprecated Use
 * {@link #setAuthentication(AutofillId[], IntentSender, Presentations)}
 * instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"3,5",0,"The method body in the later version calls another method instead of directly implementing the logic, which introduces a control dependency change. The dependent API (setAuthentication overloading with different parameters) has been changed as well. So the code change type is 3,5.","There are no changes that affect the behavior of the API. The change to call another method with the same signature's arguments does not lead to a change in the method's external behavior. Therefore, there is no Compatibility Issue, and the CI type is 0."
548,"<android.view.ScrollCaptureConnection.SafeCallback: Consumer<T> create(CancellationSignal,Executor,Consumer<T>)>",32,33,,,,"{
    return new ConsumerCallback<T>(signal, executor, target);
}","{
    return new ConsumerCallback<>(signal, executor, target);
}",1,,,0,,,0,,,,,,,4,0,"The only change made in the implementation is the removal of the explicit generic type <T> on the constructor of ConsumerCallback on the Late_Implementation, which is using the diamond operator <> instead. This change is only a syntactic sugar in Java to reduce verbosity and does not affect the behavior of the code. Therefore, the code change type is 4.","Since the behavior of the API remains the same between versions, the difference in syntax does not lead to a Compatibility Issue. Thus, the CI type is 0."
549,<android.service.wallpaper.WallpaperService.Engine: void reportVisibility()>,32,33,,,,"{
    if (mScreenshotSurfaceControl != null && mVisible) {
        if (DEBUG)
            Log.v(TAG, ""Frozen so don't report visibility change"");
        return;
    }
    if (!mDestroyed) {
        mDisplayState = mDisplay == null ? Display.STATE_UNKNOWN : mDisplay.getState();
        boolean visible = mVisible && mDisplayState != Display.STATE_OFF;
        if (mReportedVisible != visible) {
            mReportedVisible = visible;
            if (DEBUG)
                Log.v(TAG, ""onVisibilityChanged("" + visible + ""): "" + this);
            if (visible) {
                // If becoming visible, in preview mode the surface
                // may have been destroyed so now we need to make
                // sure it is re-created.
                doOffsetsChanged(false);
                // force relayout to get new surface
                updateSurface(true, false, false);
            }
            onVisibilityChanged(visible);
            if (mReportedVisible && mFrozenRequested) {
                if (DEBUG)
                    Log.v(TAG, ""Freezing wallpaper after visibility update"");
                freeze();
            }
        }
    }
}","{
    if (mScreenshotSurfaceControl != null && mVisible) {
        if (DEBUG)
            Log.v(TAG, ""Frozen so don't report visibility change"");
        return;
    }
    if (!mDestroyed) {
        mDisplayState = mDisplay == null ? Display.STATE_UNKNOWN : mDisplay.getState();
        boolean visible = mVisible && mDisplayState != Display.STATE_OFF;
        if (mReportedVisible != visible) {
            mReportedVisible = visible;
            if (DEBUG)
                Log.v(TAG, ""onVisibilityChanged("" + visible + ""): "" + this);
            if (visible) {
                // If becoming visible, in preview mode the surface
                // may have been destroyed so now we need to make
                // sure it is re-created.
                doOffsetsChanged(false);
                // force relayout to get new surface
                updateSurface(true, false, false);
            }
            onVisibilityChanged(visible);
            if (mReportedVisible && mFrozenRequested) {
                if (DEBUG)
                    Log.v(TAG, ""Freezing wallpaper after visibility update"");
                freeze();
            }
            AnimationHandler.requestAnimatorsEnabled(visible, this);
        }
    }
}",1,,,0,,,0,,,,,,,4,0,"There is a new method call 'AnimationHandler.requestAnimatorsEnabled(visible, this);' at the end of the controlling block which checks if 'mReportedVisible != visible', so the code change type is 4.","This added method call does not affect the return value or the exception handling of the method 'reportVisibility()', because 'reportVisibility()' is a void method and does not return anything. It's additionally an internal change to functionality and does not inherently result in a Compatibility Issue. Thus, the CI type is 0."
550,<android.os.BatteryUsageStats.Builder: Builder getOrCreateUidBatteryConsumerBuilder(int)>,32,33,,,,"{
    UidBatteryConsumer.Builder builder = mUidBatteryConsumerBuilders.get(uid);
    if (builder == null) {
        builder = new UidBatteryConsumer.Builder(mCustomPowerComponentNames, mIncludePowerModels, uid);
        mUidBatteryConsumerBuilders.put(uid, builder);
    }
    return builder;
}","{
    UidBatteryConsumer.Builder builder = mUidBatteryConsumerBuilders.get(uid);
    if (builder == null) {
        final BatteryConsumer.BatteryConsumerData data = BatteryConsumer.BatteryConsumerData.create(mBatteryConsumersCursorWindow, mBatteryConsumerDataLayout);
        builder = new UidBatteryConsumer.Builder(data, uid);
        mUidBatteryConsumerBuilders.put(uid, builder);
    }
    return builder;
}",1,"/**
 * Creates or returns a UidBatteryConsumer, which represents battery attribution
 * data for an individual UID. This version of the method is not suitable for use
 * with PowerCalculators.
 */
","/**
 * Creates or returns a UidBatteryConsumer, which represents battery attribution
 * data for an individual UID. This version of the method is not suitable for use
 * with PowerCalculators.
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"4,5",0,"There is a change in how the UidBatteryConsumer.Builder is instantiated with different parameters and potentially a different constructor overload depending on the new internal implementation. Also, new objects and methods are being used (BatteryConsumer.BatteryConsumerData.create(...) & UidBatteryConsumer.Builder(data, uid)), which are not present in the early version, therefore the code change type is 4,5.","Despite the change in the construction process of UidBatteryConsumer.Builder, the method's contract, which is to return a UidBatteryConsumer.Builder object for a specific UID, remains unaffected. Both versions of the method guarantee to return a non-null UidBatteryConsumer.Builder object for valid input, ensuring no Compatibility Issue in this aspect. There is no difference in the eventual type of the returned object or in exception handling; hence, the CI type is 0."
552,<android.companion.CompanionDeviceManager: void disassociate(String)>,32,33,,,,"{
    if (!checkFeaturePresent()) {
        return;
    }
    try {
        mService.disassociate(deviceMacAddress, getCallingPackage());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (!checkFeaturePresent())
        return;
    try {
        mService.legacyDisassociate(deviceMacAddress, mContext.getOpPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Remove the association between this app and the device with the given mac address.
 *
 * <p>Any privileges provided via being associated with a given device will be revoked</p>
 *
 * <p>Consider doing so when the
 * association is no longer relevant to avoid unnecessary battery and/or data drain resulting
 * from special privileges that the association provides</p>
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @param deviceMacAddress the MAC address of device to disassociate from this app
 */
","/**
 * Remove the association between this app and the device with the given mac address.
 *
 * <p>Any privileges provided via being associated with a given device will be revoked</p>
 *
 * <p>Consider doing so when the
 * association is no longer relevant to avoid unnecessary battery and/or data drain resulting
 * from special privileges that the association provides</p>
 *
 * <p>Calling this API requires a uses-feature
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>
 *
 * @param deviceMacAddress the MAC address of device to disassociate from this app
 *
 * @deprecated use {@link #disassociate(int)}
 */
",1,,"[@UserHandleAware, @Deprecated]",1,,,,,,,5,0,"The dependent API has changed from `mService.disassociate(deviceMacAddress, getCallingPackage())` to `mService.legacyDisassociate(deviceMacAddress, mContext.getOpPackageName(), mContext.getUserId())`, involving different method names and additional parameters, so the change code type is 5.","While the dependent API changed, there's no Compatibility Issue detected because there is no change in return type/values nor in exception handling which could lead to different behaviors observable by the API clients. Hence, the CI type is 0."
553,<android.content.BroadcastReceiver: PendingResult goAsync()>,32,33,,,,"{
    PendingResult res = mPendingResult;
    mPendingResult = null;
    return res;
}","{
    PendingResult res = mPendingResult;
    mPendingResult = null;
    if (res != null && Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
        res.mReceiverClassName = getClass().getName();
        Trace.traceCounter(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""BroadcastReceiver#goAsync#ClassName:"" + res.mReceiverClassName, 1);
    }
    return res;
}",1,"/**
 * This can be called by an application in {@link #onReceive} to allow
 * it to keep the broadcast active after returning from that function.
 * This does <em>not</em> change the expectation of being relatively
 * responsive to the broadcast, but does allow
 * the implementation to move work related to it over to another thread
 * to avoid glitching the main UI thread due to disk IO.
 *
 * <p>As a general rule, broadcast receivers are allowed to run for up to 10 seconds
 * before they system will consider them non-responsive and ANR the app.  Since these usually
 * execute on the app's main thread, they are already bound by the ~5 second time limit
 * of various operations that can happen there (not to mention just avoiding UI jank), so
 * the receive limit is generally not of concern.  However, once you use {@code goAsync}, though
 * able to be off the main thread, the broadcast execution limit still applies, and that
 * includes the time spent between calling this method and ultimately
 * {@link PendingResult#finish() PendingResult.finish()}.</p>
 *
 * <p>If you are taking advantage of this method to have more time to execute, it is useful
 * to know that the available time can be longer in certain situations.  In particular, if
 * the broadcast you are receiving is not a foreground broadcast (that is, the sender has not
 * used {@link Intent#FLAG_RECEIVER_FOREGROUND}), then more time is allowed for the receivers
 * to run, allowing them to execute for 30 seconds or even a bit more.  This is something that
 * receivers should rarely take advantage of (long work should be punted to another system
 * facility such as {@link android.app.job.JobScheduler}, {@link android.app.Service}, or
 * see especially {@link android.support.v4.app.JobIntentService}), but can be useful in
 * certain rare cases where it is necessary to do some work as soon as the broadcast is
 * delivered.  Keep in mind that the work you do here will block further broadcasts until
 * it completes, so taking advantage of this at all excessively can be counter-productive
 * and cause later events to be received more slowly.</p>
 *
 * @return Returns a {@link PendingResult} representing the result of
 * the active broadcast.  The BroadcastRecord itself is no longer active;
 * all data and other interaction must go through {@link PendingResult}
 * APIs.  The {@link PendingResult#finish PendingResult.finish()} method
 * must be called once processing of the broadcast is done.
 */
","/**
 * This can be called by an application in {@link #onReceive} to allow
 * it to keep the broadcast active after returning from that function.
 * This does <em>not</em> change the expectation of being relatively
 * responsive to the broadcast, but does allow
 * the implementation to move work related to it over to another thread
 * to avoid glitching the main UI thread due to disk IO.
 *
 * <p>As a general rule, broadcast receivers are allowed to run for up to 10 seconds
 * before they system will consider them non-responsive and ANR the app.  Since these usually
 * execute on the app's main thread, they are already bound by the ~5 second time limit
 * of various operations that can happen there (not to mention just avoiding UI jank), so
 * the receive limit is generally not of concern.  However, once you use {@code goAsync}, though
 * able to be off the main thread, the broadcast execution limit still applies, and that
 * includes the time spent between calling this method and ultimately
 * {@link PendingResult#finish() PendingResult.finish()}.</p>
 *
 * <p>If you are taking advantage of this method to have more time to execute, it is useful
 * to know that the available time can be longer in certain situations.  In particular, if
 * the broadcast you are receiving is not a foreground broadcast (that is, the sender has not
 * used {@link Intent#FLAG_RECEIVER_FOREGROUND}), then more time is allowed for the receivers
 * to run, allowing them to execute for 30 seconds or even a bit more.  This is something that
 * receivers should rarely take advantage of (long work should be punted to another system
 * facility such as {@link android.app.job.JobScheduler}, {@link android.app.Service}, or
 * see especially {@link androidx.core.app.JobIntentService}), but can be useful in
 * certain rare cases where it is necessary to do some work as soon as the broadcast is
 * delivered.  Keep in mind that the work you do here will block further broadcasts until
 * it completes, so taking advantage of this at all excessively can be counter-productive
 * and cause later events to be received more slowly.</p>
 *
 * @return Returns a {@link PendingResult} representing the result of
 * the active broadcast.  The BroadcastRecord itself is no longer active;
 * all data and other interaction must go through {@link PendingResult}
 * APIs.  The {@link PendingResult#finish PendingResult.finish()} method
 * must be called once processing of the broadcast is done.
 */
",1,,,0,,,,,,,"3,4",0,"The late version introduces additional control dependency with the 'if' statement and an assignment statement to set the receiver class name, along with using the Trace class for debugging purposes, so the change types are 3 and 4.","These additions do not affect the value returned by the method, nor do they introduce new exceptions or alter the method's control flow in a way that would affect existing try-catch blocks that could result in a compatibility issue. Therefore, there is no compatibility issue introduced by these changes."
555,<android.os.Vibrator: boolean areAllPrimitivesSupported(int)>,32,33,,,,"{
    for (boolean supported : arePrimitivesSupported(primitiveIds)) {
        if (!supported) {
            return false;
        }
    }
    return true;
}","{
    VibratorInfo info = getInfo();
    for (int primitiveId : primitiveIds) {
        if (!info.isPrimitiveSupported(primitiveId)) {
            return false;
        }
    }
    return true;
}",1,"/**
 * Query whether the vibrator supports all of the given primitives.
 *
 * @param primitiveIds Which primitives to query for.
 * @return Whether primitives effects are supported.
 */
","/**
 * Query whether the vibrator supports all of the given primitives.
 *
 * <p>If a primitive is not supported by the device, then <em>no vibration</em> will occur if
 * it is played.
 *
 * <p>Use {@link #arePrimitivesSupported(int...)} to get individual results for each primitive.
 *
 * @param primitiveIds Which primitives to query for.
 * @return Whether all specified primitives are supported.
 */
",1,,,0,,,,,,,"3,5",0,The loop in the late implementation is changed from iterating through a 'boolean' array returned by 'arePrimitivesSupported()' to iterating through 'primitiveIds' and checking if each 'primitiveId' is supported with 'info.isPrimitiveSupported(primitiveId)'. This suggests a change in the control dependency and a change in a dependent API since the API it depends on has undergone changes.,"Although there's a change in how the check is performed, the contract of the API has not been broken. It still returns 'true' if all primitives are supported and 'false' otherwise. Thus, there is no compatibility issue as the behavior of the API remains consistent before and after the change."
558,<android.os.Bundle: T getParcelable(String)>,32,33,,,,"{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (T) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Parcelable"", e);
        return null;
    }
}","{
    unparcel();
    Object o = getValue(key);
    if (o == null) {
        return null;
    }
    try {
        return (T) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Parcelable"", e);
        return null;
    }
}",1,"/**
 * Returns the value associated with the given key, or {@code null} if
 * no mapping of the desired type exists for the given key or a {@code null}
 * value is explicitly associated with the key.
 *
 * <p><b>Note: </b> if the expected value is not a class provided by the Android platform,
 * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.
 * Otherwise, this method might throw an exception or return {@code null}.
 *
 * @param key a String, or {@code null}
 * @return a Parcelable value, or {@code null}
 */
","/**
 * Returns the value associated with the given key, or {@code null} if
 * no mapping of the desired type exists for the given key or a {@code null}
 * value is explicitly associated with the key.
 *
 * <p><b>Note: </b> if the expected value is not a class provided by the Android platform,
 * you must call {@link #setClassLoader(ClassLoader)} with the proper {@link ClassLoader} first.
 * Otherwise, this method might throw an exception or return {@code null}.
 *
 * @param key a String, or {@code null}
 * @return a Parcelable value, or {@code null}
 *
 * @deprecated Use the type-safer {@link #getParcelable(String, Class)} starting from Android
 * {@link Build.VERSION_CODES#TIRAMISU}.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,"4,5",0,"There is a change in which method is called to retrieve the value (`mMap.get(key)` was replaced with `getValue(key)`), but the logic and behavior of the method remain the same. Since 'getValue' is a dependent API, the code change type is 4,5.","There is no change that would cause a Compatibility Issue as the method's behavior with respect to return values and exception handling remains consistent between versions. The change is in an internal call that does not affect the API contract. Thus, the CI type is 0."
559,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo obtain(View)>,32,33,,,,"{
    AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
    info.setSource(source);
    return info;
}","{
    return new AccessibilityNodeInfo(source);
}",1,"/**
 * Returns a cached instance if such is available otherwise a new one
 * and sets the source.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo(View)} instead.
 *
 * @param source The source view.
 * @return An instance.
 *
 * @see #setSource(View)
 */
","/**
 * Returns a cached instance if such is available otherwise a new one
 * and sets the source.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityNodeInfo(View)} instead.
 * @param source The source view.
 * @return An instance.
 *
 * @see #setSource(View)
 */
",1,,[@Deprecated],1,,,,,,,"1,4",1,"The late version no longer calls AccessibilityNodeInfo.obtain() and info.setSource(source) but constructs the AccessibilityNodeInfo object directly with the source. Additionally, the method invocation of .setSource(source) is not in the late version, hence the change is 1,4.","The return value creation logic is different in the late version compared to the early version, which could lead to a different return value. This could result in a Compatibility Issue, so the CI type is 1."
560,<android.app.ActivityTransitionState: int addExitTransitionCoordinator(ExitTransitionCoordinator)>,32,33,,,,"{
    if (mExitTransitionCoordinators == null) {
        mExitTransitionCoordinators = new SparseArray<>();
    }
    WeakReference<ExitTransitionCoordinator> ref = new WeakReference(exitTransitionCoordinator);
    // clean up old references:
    for (int i = mExitTransitionCoordinators.size() - 1; i >= 0; i--) {
        WeakReference<ExitTransitionCoordinator> oldRef = mExitTransitionCoordinators.valueAt(i);
        if (oldRef.get() == null) {
            mExitTransitionCoordinators.removeAt(i);
        }
    }
    int newKey = mExitTransitionCoordinatorsKey++;
    mExitTransitionCoordinators.append(newKey, ref);
    return newKey;
}","{
    if (mExitTransitionCoordinators == null) {
        mExitTransitionCoordinators = new SparseArray<>();
    }
    WeakReference<ExitTransitionCoordinator> ref = new WeakReference(exitTransitionCoordinator);
    // clean up old references:
    for (int i = mExitTransitionCoordinators.size() - 1; i >= 0; i--) {
        WeakReference<ExitTransitionCoordinator> oldRef = mExitTransitionCoordinators.valueAt(i);
        if (oldRef.refersTo(null)) {
            mExitTransitionCoordinators.removeAt(i);
        }
    }
    int newKey = mExitTransitionCoordinatorsKey++;
    mExitTransitionCoordinators.append(newKey, ref);
    return newKey;
}",1,,,0,,,0,,,,,,,4,0,"The change occurs in one of the method calls from oldRef.get() == null to oldRef.refersTo(null), which does not cause a different value to be returned, it's just a change in the method used to check a WeakReference for nullity, therefore the code change type is 4.","Given this change is only in the way the null check is performed on a WeakReference and does not affect the program's control flow or the result of the function, no Compatibility Issue is introduced by this change, so the CI type is 0."
561,"<android.widget.AbsListView: void onInitializeAccessibilityNodeInfoForItem(View,int,AccessibilityNodeInfo)>",32,33,,,,"{
    if (position == INVALID_POSITION) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    boolean isItemEnabled = view.isEnabled() && isEnabled();
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemEnabled &= ((AbsListView.LayoutParams) lp).isEnabled;
    }
    info.setEnabled(isItemEnabled);
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_SELECT);
    }
    if (isItemClickable(view)) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_CLICK);
        // A disabled item is a separator which should not be clickable.
        info.setClickable(isItemEnabled);
    }
    if (isLongClickable()) {
        addAccessibilityActionIfEnabled(info, isItemEnabled, AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}","{
    if (position == INVALID_POSITION) {
        // The item doesn't exist, so there's not much we can do here.
        return;
    }
    boolean isItemActionable = isEnabled();
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    if (lp instanceof AbsListView.LayoutParams) {
        isItemActionable &= ((AbsListView.LayoutParams) lp).isEnabled;
    }
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        addAccessibilityActionIfEnabled(info, isItemActionable, AccessibilityAction.ACTION_CLEAR_SELECTION);
    } else {
        addAccessibilityActionIfEnabled(info, isItemActionable, AccessibilityAction.ACTION_SELECT);
    }
    if (isItemClickable(view)) {
        addAccessibilityActionIfEnabled(info, isItemActionable, AccessibilityAction.ACTION_CLICK);
        // A disabled item is a separator which should not be clickable.
        info.setClickable(isItemActionable);
    }
    if (isLongClickable()) {
        addAccessibilityActionIfEnabled(info, isItemActionable, AccessibilityAction.ACTION_LONG_CLICK);
        info.setLongClickable(isItemActionable);
    }
}",1,"/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
","/**
 * Initializes an {@link AccessibilityNodeInfo} with information about a
 * particular item in the list.
 *
 * @param view View representing the list item.
 * @param position Position of the list item within the adapter.
 * @param info Node info to populate.
 */
",0,,,0,,,,,,,"3,4",1,"The change includes renaming the variable from `isItemEnabled` to `isItemActionable` and removing the `view.isEnabled()` check from the condition. Now the state only depends on `isEnabled()` and the `LayoutParams`, but does not consider `view.isEnabled()`. These changes classify as both 3 (Control dependency change) and 4 (Other statement changed).","The removal of `view.isEnabled()` check affects whether certain accessibility actions are added and whether certain properties are set on the `info` object. It could cause items not previously actionable due to their view being disabled to now be considered actionable. Therefore, this can lead to a different behavior (CI type 1) as it will affect the return results of the method on how it configures the `AccessibilityNodeInfo` object for an item."
562,"<android.service.autofill.ImageTransformation.Builder: Builder addOption(Pattern,int,CharSequence)>",32,33,,,,"{
    addOptionInternal(regex, resId, Preconditions.checkNotNull(contentDescription));
    return this;
}","{
    addOptionInternal(regex, resId, Objects.requireNonNull(contentDescription));
    return this;
}",1,"/**
 * Adds an option to replace the child view with a different image and content description
 * when the regex matches.
 *
 * @param regex regular expression defining what should be matched to use this image.
 * @param resId resource id of the image (in the autofill service's package). The
 * {@link RemoteViews presentation} must contain a {@link ImageView} child with that id.
 * @param contentDescription content description to be applied in the child view.
 *
 * @return this build
 */
","/**
 * Adds an option to replace the child view with a different image and content description
 * when the regex matches.
 *
 * @param regex regular expression defining what should be matched to use this image.
 * @param resId resource id of the image (in the autofill service's package). The
 * {@link RemoteViews presentation} must contain a {@link ImageView} child with that id.
 * @param contentDescription content description to be applied in the child view.
 *
 * @return this build
 */
",0,,,0,,,,,,,"4,5",0,"The change is from Preconditions.checkNotNull(contentDescription) to Objects.requireNonNull(contentDescription), which can be categorized as an 'Other statement changed' because it's a change in the method used to check the object for non-nullity. It also represents a 'Dependent API changed' because both Preconditions.checkNotNull and Objects.requireNonNull are likely part of different library APIs that the implementation relies upon.","There is no Compatibility Issue, because both Preconditions.checkNotNull() and Objects.requireNonNull() are used to perform a null check and would throw a NullPointerException if 'contentDescription' is null. The behavior of the API remains consistent despite the change in the method used for the null check."
564,"<android.widget.AbsListView: boolean sendToTextFilter(int,int,KeyEvent)>",32,33,,,,"{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_NUMPAD_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
            if (mFiltered && mPopup != null && mPopup.isShowing()) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                    KeyEvent.DispatcherState state = getKeyDispatcherState();
                    if (state != null) {
                        state.startTracking(event, this);
                    }
                    handled = true;
                } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
                    handled = true;
                    mTextFilter.setText("""");
                }
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}","{
    if (!acceptFilter()) {
        return false;
    }
    boolean handled = false;
    boolean okToSend = true;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_UP:
        case KeyEvent.KEYCODE_DPAD_DOWN:
        case KeyEvent.KEYCODE_DPAD_LEFT:
        case KeyEvent.KEYCODE_DPAD_RIGHT:
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_NUMPAD_ENTER:
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_BACK:
        case KeyEvent.KEYCODE_ESCAPE:
            if (mFiltered && mPopup != null && mPopup.isShowing()) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
                    KeyEvent.DispatcherState state = getKeyDispatcherState();
                    if (state != null) {
                        state.startTracking(event, this);
                    }
                    handled = true;
                } else if (event.getAction() == KeyEvent.ACTION_UP && event.isTracking() && !event.isCanceled()) {
                    handled = true;
                    mTextFilter.setText("""");
                }
            }
            okToSend = false;
            break;
        case KeyEvent.KEYCODE_SPACE:
            // Only send spaces once we are filtered
            okToSend = mFiltered;
            break;
    }
    if (okToSend) {
        createTextFilter(true);
        KeyEvent forwardEvent = event;
        if (forwardEvent.getRepeatCount() > 0) {
            forwardEvent = KeyEvent.changeTimeRepeat(event, event.getEventTime(), 0);
        }
        int action = event.getAction();
        switch(action) {
            case KeyEvent.ACTION_DOWN:
                handled = mTextFilter.onKeyDown(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_UP:
                handled = mTextFilter.onKeyUp(keyCode, forwardEvent);
                break;
            case KeyEvent.ACTION_MULTIPLE:
                handled = mTextFilter.onKeyMultiple(keyCode, count, event);
                break;
        }
    }
    return handled;
}",1,"/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
","/**
 * Sends a key to the text filter window
 *
 * @param keyCode The keycode for the event
 * @param event The actual key event
 *
 * @return True if the text filter handled the event, false otherwise.
 */
",0,,,0,,,,,,,3,0,"The switch-case statement within the method has an additional case `KeyEvent.KEYCODE_ESCAPE` mapped to the same logic as the case for `KeyEvent.KEYCODE_BACK`, so the code change type is 3.","The change does not affect the return values or the exception handling; it simply extends the same logic to another case (KEYCODE_ESCAPE) which does not alter the existing behavior for any of the other key codes. Therefore, there is no Compatibility Issue, so the CI type is 0."
565,"<android.content.pm.ShortcutManager: boolean requestPinShortcut(ShortcutInfo,IntentSender)>",32,33,,,,"{
    try {
        return (boolean) getFutureOrThrow(mService.requestPinShortcut(mContext.getPackageName(), shortcut, resultIntent, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        AndroidFuture<String> ret = new AndroidFuture<>();
        mService.requestPinShortcut(mContext.getPackageName(), shortcut, resultIntent, injectMyUserId(), ret);
        return Boolean.parseBoolean(getFutureOrThrow(ret));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Request to create a pinned shortcut.  The default launcher will receive this request and
 * ask the user for approval.  If the user approves it, the shortcut will be created, and
 * {@code resultIntent} will be sent. If a request is denied by the user, however, no response
 * will be sent to the caller.
 *
 * <p>Only apps with a foreground activity or a foreground service can call this method.
 * Otherwise, it'll throw {@link IllegalStateException}.
 *
 * <p>It's up to the launcher to decide how to handle previous pending requests when the same
 * package calls this API multiple times in a row. One possible strategy is to ignore any
 * previous requests.
 *
 * <p><b>Note:</b> See also the support library counterpart
 * {@link android.support.v4.content.pm.ShortcutManagerCompat#requestPinShortcut(
 * Context, ShortcutInfoCompat, IntentSender)},
 * which supports Android versions lower than {@link VERSION_CODES#O} using the
 * legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
 *
 * @param shortcut Shortcut to pin.  If an app wants to pin an existing (either static
 * or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have
 * to be set, the target shortcut must be enabled.
 *
 * <p>If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @param resultIntent If not null, this intent will be sent when the shortcut is pinned.
 * Use {@link android.app.PendingIntent#getIntentSender()} to create an {@link IntentSender}.
 * To avoid background execution limits, use an unexported, manifest-declared receiver.
 * For more details, see
 * <a href=""/guide/topics/ui/shortcuts/creating-shortcuts.html#pinned"">
 * Creating pinned shortcuts</a>.
 *
 * @return {@code TRUE} if the launcher supports this feature.  Note the API will return without
 * waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
 * the shortcut was pinned successfully.  {@code FALSE} if the launcher doesn't support this
 * feature.
 *
 * @see #isRequestPinShortcutSupported()
 * @see IntentSender
 * @see android.app.PendingIntent#getIntentSender()
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 * @throws IllegalStateException The caller doesn't have a foreground activity or a foreground
 * service, or the device is locked.
 */
","/**
 * Request to create a pinned shortcut.  The default launcher will receive this request and
 * ask the user for approval.  If the user approves it, the shortcut will be created, and
 * {@code resultIntent} will be sent. If a request is denied by the user, however, no response
 * will be sent to the caller.
 *
 * <p>Only apps with a foreground activity or a foreground service can call this method.
 * Otherwise, it'll throw {@link IllegalStateException}.
 *
 * <p>It's up to the launcher to decide how to handle previous pending requests when the same
 * package calls this API multiple times in a row. One possible strategy is to ignore any
 * previous requests.
 *
 * <p><b>Note:</b> See also the support library counterpart
 * {@link androidx.core.content.pm.ShortcutManagerCompat#requestPinShortcut(
 * Context, ShortcutInfoCompat, IntentSender)},
 * which supports Android versions lower than {@link VERSION_CODES#O} using the
 * legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
 *
 * @param shortcut Shortcut to pin.  If an app wants to pin an existing (either static
 * or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have
 * to be set, the target shortcut must be enabled.
 *
 * <p>If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @param resultIntent If not null, this intent will be sent when the shortcut is pinned.
 * Use {@link android.app.PendingIntent#getIntentSender()} to create an {@link IntentSender}.
 * To avoid background execution limits, use an unexported, manifest-declared receiver.
 * For more details, see
 * <a href=""/guide/topics/ui/shortcuts/creating-shortcuts.html#pinned"">
 * Creating pinned shortcuts</a>.
 *
 * @return {@code TRUE} if the launcher supports this feature.  Note the API will return without
 * waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
 * the shortcut was pinned successfully.  {@code FALSE} if the launcher doesn't support this
 * feature.
 *
 * @see #isRequestPinShortcutSupported()
 * @see IntentSender
 * @see android.app.PendingIntent#getIntentSender()
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 * @throws IllegalStateException The caller doesn't have a foreground activity or a foreground
 * service, or the device is locked.
 */
",1,[@WorkerThread],[@WorkerThread],0,,,,,,,4,0,"The implementation of how the return value is obtained has changed, but the final return type remains boolean in both versions. The code change type is 4 because it's an ""other statement changed"" scenario, which doesn't include changes in return statements, exception handling, or control dependencies.","There's no Compatibility Issue since the method signature, return type, and exceptions thrown haven't been altered, and the behavior in terms of the API contract remains consistent between versions. The change internal to the method does not affect compatibility."
567,<android.net.Uri.HierarchicalUri: Uri readFrom(Parcel)>,32,33,,,,"{
    return new HierarchicalUri(parcel.readString8(), Part.readFrom(parcel), PathPart.readFrom(parcel), Part.readFrom(parcel), Part.readFrom(parcel));
}","{
    final String scheme = parcel.readString8();
    final Part authority = Part.readFrom(parcel);
    // In RFC3986 the path should be determined based on whether there is a scheme or
    // authority present (https://www.rfc-editor.org/rfc/rfc3986.html#section-3.3).
    final boolean hasSchemeOrAuthority = (scheme != null && scheme.length() > 0) || !authority.isEmpty();
    final PathPart path = PathPart.readFrom(hasSchemeOrAuthority, parcel);
    final Part query = Part.readFrom(parcel);
    final Part fragment = Part.readFrom(parcel);
    return new HierarchicalUri(scheme, authority, path, query, fragment);
}",1,,,0,,,0,,,,,,,"1,3,4",1,"The late version has additional variable declaration and an additional control statement to determine the value of 'hasSchemeOrAuthority'. Also, there's a new parameter 'hasSchemeOrAuthority' passed to 'PathPart.readFrom', and the return statement now includes these new variables. This results in a return statement change, a control dependency change, and other statement changes. So the change type is 1,3,4.","The addition of the control statement and extra parameter to 'PathPart.readFrom' can lead to a different 'PathPart' object being created, which ultimately changes the value returned by the method. Given this method returns a 'Uri' object with potentially different components (especially the path), there could be a change in behavior. Hence, the CI type is 1."
568,<android.view.Display: String toString()>,32,33,,,,"{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        final DisplayAdjustments adjustments = getDisplayAdjustments();
        mDisplayInfo.getAppMetrics(mTempMetrics, adjustments);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + (mMayAdjustByFixedRotation ? ("", "" + adjustments.getFixedRotationAdjustments() + "", "") : "", "") + mTempMetrics + "", isValid="" + mIsValid;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        final DisplayAdjustments adjustments = getDisplayAdjustments();
        mDisplayInfo.getAppMetrics(mTempMetrics, adjustments);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + "", "" + mTempMetrics + "", isValid="" + mIsValid;
    }
}",1,"// For debugging purposes
","// For debugging purposes
",0,[@Override],[@Override],0,,,,,,,"1,3",1,"The return statement has changed by removing the conditional statement related to mMayAdjustByFixedRotation which affects the string being returned, and the content under control dependency has changed. So the change type is 1,3.","The removal of the part of the return statement that includes "", "" + adjustments.getFixedRotationAdjustments() + "", "" could lead to the method returning a different string value. Therefore, the CI type is 1."
569,<android.view.translation.TranslationContext.Builder: TranslationContext build()>,32,33,,,,"{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x8;
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mTranslationFlags = defaultTranslationFlags();
    }
    TranslationContext o = new TranslationContext(mSourceSpec, mTargetSpec, mTranslationFlags);
    return o;
}","{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x10;
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mTranslationFlags = defaultTranslationFlags();
    }
    if ((mBuilderFieldsSet & 0x8) == 0) {
        mActivityId = defaultActivityId();
    }
    TranslationContext o = new TranslationContext(mSourceSpec, mTargetSpec, mTranslationFlags, mActivityId);
    return o;
}",1,"/**
 * Builds the instance. This builder should not be touched after calling this!
 */
","/**
 * Builds the instance. This builder should not be touched after calling this!
 */
",0,[@NonNull],[@NonNull],0,,,,,,,"1,3,4,5",1,"The change includes a modification to the value assigned to `mBuilderFieldsSet` from `0x8` to `0x10`, the addition of a conditional block that assigns a value to `mActivityId`, and the constructor of `TranslationContext` now includes an additional parameter `mActivityId`. The code change type includes changes to other statements (4) due to the bitwise operation, control dependency (3) because of the new 'if' statement, dependent API change (5) as the constructor called is not the same, and return statement change (1) given that the type signature of the returned object `TranslationContext` might differ due to taking different parameters in the constructor.","The API could potentially return a different `TranslationContext` object because of the new parameter passed to the constructor and the addition of setting a new field `mActivityId` if not previously set. This means the behavior of the 'build' method can change, which could lead to a CI type 1."
570,<android.widget.PopupWindow.PopupDecorView: boolean dispatchKeyEvent(KeyEvent)>,32,33,,,,"{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (getKeyDispatcherState() == null) {
            return super.dispatchKeyEvent(event);
        }
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            final KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            final KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null && state.isTracking(event) && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
        return super.dispatchKeyEvent(event);
    } else {
        return super.dispatchKeyEvent(event);
    }
}","{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK || event.getKeyCode() == KeyEvent.KEYCODE_ESCAPE) {
        if (getKeyDispatcherState() == null) {
            return super.dispatchKeyEvent(event);
        }
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            final KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            final KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null && state.isTracking(event) && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
        return super.dispatchKeyEvent(event);
    } else {
        return super.dispatchKeyEvent(event);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"The condition in the if statement has been expanded to check for an additional key code (KeyEvent.KEYCODE_ESCAPE), thus the control dependency has changed. This is a change type 3.","The additional key code check in the if condition (KeyEvent.KEYCODE_ESCAPE) extends the behavior of the method to handle a new key event, which could potentially lead to different return values based on the input KeyEvent. This is a CI type 1 because the method may return a different value if the KeyEvent passed to the method is KeyEvent.KEYCODE_ESCAPE."
571,<android.app.admin.DevicePolicyManager: boolean isOrganizationOwnedDeviceWithManagedProfile()>,32,33,,,,"{
    throwIfParentInstance(""isOrganizationOwnedDeviceWithManagedProfile"");
    if (mService != null) {
        try {
            return mService.isOrganizationOwnedDeviceWithManagedProfile();
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    throwIfParentInstance(""isOrganizationOwnedDeviceWithManagedProfile"");
    if (mService != null) {
        return mIsOrganizationOwnedDeviceWithManagedProfileCache.query(null);
    }
    return false;
}",1,"/**
 * Apps can use this method to find out if the device was provisioned as
 * organization-owend device with a managed profile.
 *
 * This, together with checking whether the device has a device owner (by calling
 * {@link #isDeviceOwnerApp}), could be used to learn whether the device is owned by an
 * organization or an individual:
 * If this method returns true OR {@link #isDeviceOwnerApp} returns true (for any package),
 * then the device is owned by an organization. Otherwise, it's owned by an individual.
 *
 * @return {@code true} if the device was provisioned as organization-owned device,
 * {@code false} otherwise.
 */
","/**
 * Apps can use this method to find out if the device was provisioned as
 * organization-owend device with a managed profile.
 *
 * This, together with checking whether the device has a device owner (by calling
 * {@link #isDeviceOwnerApp}), could be used to learn whether the device is owned by an
 * organization or an individual:
 * If this method returns true OR {@link #isDeviceOwnerApp} returns true (for any package),
 * then the device is owned by an organization. Otherwise, it's owned by an individual.
 *
 * @return {@code true} if the device was provisioned as organization-owned device,
 * {@code false} otherwise.
 */
",0,,,0,,,,,,,"4,5",1,"There is an Other statement changed as 'mService.isOrganizationOwnedDeviceWithManagedProfile()' is replaced with 'mIsOrganizationOwnedDeviceWithManagedProfileCache.query(null)', which indicates a change in the method for retrieving the boolean result. Additionally, this change also constitutes a Dependent API changed, because we have a change from using an API directly associated with 'mService' to using a different caching mechanism, which most likely introduces a dependence on a different API or an internal change to how the result is computed. Hence, the classification is 4,5.","This change in the underlying mechanism to determine if the device is organization-owned with a managed profile can potentially return different results based on the new caching system's state or logic, leading to a Compatibility Issue due to potentially different return values. Thus, the CI type is 1."
573,<android.os.RemoteException: RuntimeException rethrowFromSystemServer()>,32,33,,,,"{
    if (this instanceof DeadObjectException) {
        throw new RuntimeException(new DeadSystemException());
    } else {
        throw new RuntimeException(this);
    }
}","{
    if (this instanceof DeadObjectException) {
        throw new DeadSystemRuntimeException();
    } else {
        throw new RuntimeException(this);
    }
}",1,"/**
 * Rethrow this exception when we know it came from the system server. This
 * gives us an opportunity to throw a nice clean
 * {@link DeadSystemException} signal to avoid spamming logs with
 * misleading stack traces.
 * <p>
 * Apps making calls into the system server may end up persisting internal
 * state or making security decisions based on the perceived success or
 * failure of a call, or any default values returned. For this reason, we
 * want to strongly throw when there was trouble with the transaction.
 *
 * @throws RuntimeException
 */
","/**
 * Rethrow this exception when we know it came from the system server. This
 * gives us an opportunity to throw a nice clean
 * {@link DeadSystemRuntimeException} signal to avoid spamming logs with
 * misleading stack traces.
 * <p>
 * Apps making calls into the system server may end up persisting internal
 * state or making security decisions based on the perceived success or
 * failure of a call, or any default values returned. For this reason, we
 * want to strongly throw when there was trouble with the transaction.
 *
 * @throws RuntimeException
 */
",1,[@NonNull],[@NonNull],0,,,,,,,"1,2",2,"The exception thrown has changed from new RuntimeException(new DeadSystemException()) to new DeadSystemRuntimeException() when this is an instance of DeadObjectException, so the change type is 1,2.","The 'rethrowFromSystemServer' method has been modified to throw a different exception (DeadSystemRuntimeException instead of RuntimeException with a wrapped DeadSystemException), which will result in different exception handling by the callers. Hence, the CI type is 2, as the exception handling has altered."
574,<android.app.TaskInfo: String toString()>,32,33,,,,"{
    return ""TaskInfo{userId="" + userId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" supportsMultiWindow="" + supportsMultiWindow + "" resizeMode="" + resizeMode + "" isResizeable="" + isResizeable + "" token="" + token + "" topActivityType="" + topActivityType + "" pictureInPictureParams="" + pictureInPictureParams + "" displayCutoutSafeInsets="" + displayCutoutInsets + "" topActivityInfo="" + topActivityInfo + "" launchCookies="" + launchCookies + "" positionInParent="" + positionInParent + "" parentTaskId="" + parentTaskId + "" isFocused="" + isFocused + "" isVisible="" + isVisible + "" isSleeping="" + isSleeping + "" topActivityInSizeCompat="" + topActivityInSizeCompat + "" locusId="" + mTopActivityLocusId + "" displayAreaFeatureId="" + displayAreaFeatureId + ""}"";
}","{
    return ""TaskInfo{userId="" + userId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" supportsMultiWindow="" + supportsMultiWindow + "" resizeMode="" + resizeMode + "" isResizeable="" + isResizeable + "" minWidth="" + minWidth + "" minHeight="" + minHeight + "" defaultMinSize="" + defaultMinSize + "" token="" + token + "" topActivityType="" + topActivityType + "" pictureInPictureParams="" + pictureInPictureParams + "" shouldDockBigOverlays="" + shouldDockBigOverlays + "" launchIntoPipHostTaskId="" + launchIntoPipHostTaskId + "" displayCutoutSafeInsets="" + displayCutoutInsets + "" topActivityInfo="" + topActivityInfo + "" launchCookies="" + launchCookies + "" positionInParent="" + positionInParent + "" parentTaskId="" + parentTaskId + "" isFocused="" + isFocused + "" isVisible="" + isVisible + "" isSleeping="" + isSleeping + "" topActivityInSizeCompat="" + topActivityInSizeCompat + "" topActivityEligibleForLetterboxEducation= "" + topActivityEligibleForLetterboxEducation + "" locusId="" + mTopActivityLocusId + "" displayAreaFeatureId="" + displayAreaFeatureId + "" cameraCompatControlState="" + cameraCompatControlStateToString(cameraCompatControlState) + ""}"";
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"New fields have been added to the toString representation (`minWidth`, `minHeight`, `defaultMinSize`, `shouldDockBigOverlays`, `launchIntoPipHostTaskId`, `topActivityEligibleForLetterboxEducation`, `cameraCompatControlState` and its string conversion function `cameraCompatControlStateToString`). This is categorized as an 'Other statement changed' (type 4) because the return statement did not change its control flow or the type of its value but instead included additional information.","There is no Compatibility Issue as the toString() method inherently is used for providing a string representation and these changes do not affect programmatic decision-making when calling this method. The returned value's type remains a String, and thus the behavior would still be consistent with the expected use case of a toString() method."
575,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",32,33,,,,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,5,0,"There's a change in the parameters passed to the method broadcastIntentWithFeature(). The position of the 'null' and 'AppOpsManager.OP_NONE' values has been switched. This change is reflected in the dependant API call parameters, so the code change type is 5.","This change in parameter order does not change the return type or value of the API, nor does it introduce any new exceptions. The method's contract and the type of exceptions it can throw remain unchanged, and the method still does not return any value (void return type). Therefore, there's no compatibility issue, so the CI type is 0."
576,<android.content.pm.ShortcutManager: List<ShortcutInfo> getPinnedShortcuts()>,32,33,,,,"{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",0,,,,,,,"4,5",1,"The method getFutureOrThrow() has been removed from the try block, which is a change in the method being called to retrieve the shortcuts list, so the change type is 4,5.","Since the method getFutureOrThrow() is removed, it could affect the timing when the result is obtained (possibly previously allowing for asynchronous execution and now it might be synchronous), which could potentially lead to different ShortcutInfo objects being returned, causing a CI. Therefore, the CI type is 1."
577,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>",32,33,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        null, AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,0,"[@Override, @Deprecated]","[@Override, @Deprecated]",0,,,,,,,4,0,"The change is in the parameter list of the method broadcastIntentWithFeature() call, where an argument has changed position (/*excludedPermissions=*/ `AppOpsManager.OP_NONE` has moved after `null`). Since it's only a change in the ordering of arguments and both versions place a `null` in the parameter that now receives the `AppOpsManager.OP_NONE`, it does not affect the behavior of the method. Therefore, the code change type is 4.","The change does not affect the outward behavior of the API; it neither changes the return value nor does it alter exception handling. Therefore, there is no Compatibility Issue, and the CI type is 0."
578,<android.os.UserManager: Bundle getUserRestrictions()>,32,33,,,,"{
    return getUserRestrictions(Process.myUserHandle());
}","{
    try {
        return mService.getUserRestrictions(getContextUserIfAppropriate());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the user-wide restrictions imposed on this user.
 * @return a Bundle containing all the restrictions.
 */
","/**
 * Returns the user-wide restrictions imposed on the context user.
 * @return a Bundle containing all the restrictions.
 */
",1,,"[@UserHandleAware(enabledSinceTargetSdkVersion = Build.VERSION_CODES.TIRAMISU, requiresAnyOfPermissionsIfNotCallerProfileGroup = { android.Manifest.permission.MANAGE_USERS, android.Manifest.permission.INTERACT_ACROSS_USERS })]",1,,,,,,,"4,5",1,"The method used for obtaining the user restrictions has been changed. Instead of calling getUserRestrictions(Process.myUserHandle()), it now calls mService.getUserRestrictions(getContextUserIfAppropriate()) with a new dependent method getContextUserIfAppropriate() and a different class member (mService). An exception handling block has also been added, so the change type is 4,5.","The changes result in a different method being called to obtain the user restrictions, which could potentially alter the Bundle returned. The introduction of a call to a service and different handling of RemoteException also leads to a potential different behavior. Thus, there is a Compatibility Issue due to the potential of different return values, and the type is 1."
580,"<android.widget.TextView: void onCreateViewTranslationRequest(int[],Consumer<ViewTranslationRequest>)>",32,33,,,,"{
    if (supportedFormats == null || supportedFormats.length == 0) {
        if (UiTranslationController.DEBUG) {
            Log.w(LOG_TAG, ""Do not provide the support translation formats."");
        }
        return;
    }
    ViewTranslationRequest.Builder requestBuilder = new ViewTranslationRequest.Builder(getAutofillId());
    // Support Text translation
    if (ArrayUtils.contains(supportedFormats, TranslationSpec.DATA_FORMAT_TEXT)) {
        if (mText == null || mText.length() == 0) {
            if (UiTranslationController.DEBUG) {
                Log.w(LOG_TAG, ""Cannot create translation request for the empty text."");
            }
            return;
        }
        boolean isPassword = isAnyPasswordInputType() || hasPasswordTransformationMethod();
        // and editable text in S.
        if (isTextEditable() || isPassword || isTextSelectable()) {
            if (UiTranslationController.DEBUG) {
                Log.w(LOG_TAG, ""Cannot create translation request. editable = "" + isTextEditable() + "", isPassword = "" + isPassword + "", selectable = "" + isTextSelectable());
            }
            return;
        }
        // TODO(b/176488462): apply the view's important for translation
        requestBuilder.setValue(ViewTranslationRequest.ID_TEXT, TranslationRequestValue.forText(mText));
        if (!TextUtils.isEmpty(getContentDescription())) {
            requestBuilder.setValue(ViewTranslationRequest.ID_CONTENT_DESCRIPTION, TranslationRequestValue.forText(getContentDescription()));
        }
    }
    requestsCollector.accept(requestBuilder.build());
}","{
    if (supportedFormats == null || supportedFormats.length == 0) {
        if (UiTranslationController.DEBUG) {
            Log.w(LOG_TAG, ""Do not provide the support translation formats."");
        }
        return;
    }
    ViewTranslationRequest.Builder requestBuilder = new ViewTranslationRequest.Builder(getAutofillId());
    // Support Text translation
    if (ArrayUtils.contains(supportedFormats, TranslationSpec.DATA_FORMAT_TEXT)) {
        if (mText == null || mText.length() == 0) {
            if (UiTranslationController.DEBUG) {
                Log.w(LOG_TAG, ""Cannot create translation request for the empty text."");
            }
            return;
        }
        boolean isPassword = isAnyPasswordInputType() || hasPasswordTransformationMethod();
        if (isTextEditable() || isPassword) {
            Log.w(LOG_TAG, ""Cannot create translation request. editable = "" + isTextEditable() + "", isPassword = "" + isPassword);
            return;
        }
        // TODO(b/176488462): apply the view's important for translation
        requestBuilder.setValue(ViewTranslationRequest.ID_TEXT, TranslationRequestValue.forText(mText));
        if (!TextUtils.isEmpty(getContentDescription())) {
            requestBuilder.setValue(ViewTranslationRequest.ID_CONTENT_DESCRIPTION, TranslationRequestValue.forText(getContentDescription()));
        }
    }
    requestsCollector.accept(requestBuilder.build());
}",1,"/**
 * Collects a {@link ViewTranslationRequest} which represents the content to be translated in
 * the view.
 *
 * <p>NOTE: When overriding the method, it should not translate the password. If the subclass
 * uses {@link TransformationMethod} to display the translated result, it's also not recommend
 * to translate text is selectable or editable.
 *
 * @param supportedFormats the supported translation format. The value could be {@link
 * android.view.translation.TranslationSpec#DATA_FORMAT_TEXT}.
 * @return the {@link ViewTranslationRequest} which contains the information to be translated.
 */
","/**
 * Collects a {@link ViewTranslationRequest} which represents the content to be translated in
 * the view.
 *
 * <p>NOTE: When overriding the method, it should not collect a request to translate this
 * TextView if it is displaying a password.
 *
 * @param supportedFormats the supported translation format. The value could be {@link
 * android.view.translation.TranslationSpec#DATA_FORMAT_TEXT}.
 * @param requestsCollector {@link Consumer} to receiver the {@link ViewTranslationRequest}
 * which contains the information to be translated.
 */
",1,[@Override],[@Override],0,,,,,,,"3,4",1,"The condition in the if statement has changed by removing the part `|| isTextSelectable()`. Additionally, a Log statement that was present when `isTextSelectable()` was true in the early version has also been removed. These indicate a control dependency change (type 3) and an other statement change (type 4).","By removing `|| isTextSelectable()` from the condition, cases where isTextSelectable() was true in the early version will now be handled differently. This could lead to cases where a ViewTranslationRequest would have been returned early in the early version but will now continue to be constructed and accepted by requestsCollector. Since this alters the behavior under certain circumstances, this is a CI caused by potentially different return values (type 1)."
581,<android.os.Parcel: void writeValue(Object)>,32,33,,,,"{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof PersistableBundle) {
        writeInt(VAL_PERSISTABLEBUNDLE);
        writePersistableBundle((PersistableBundle) v);
    } else if (v instanceof Parcelable) {
        // IMPOTANT: cases for classes that implement Parcelable must
        // come before the Parcelable case, so that their specific VAL_*
        // types will be written.
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Size) {
        writeInt(VAL_SIZE);
        writeSize((Size) v);
    } else if (v instanceof SizeF) {
        writeInt(VAL_SIZEF);
        writeSizeF((SizeF) v);
    } else if (v instanceof double[]) {
        writeInt(VAL_DOUBLEARRAY);
        writeDoubleArray((double[]) v);
    } else {
        Class<?> clazz = v.getClass();
        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
            // Only pure Object[] are written here, Other arrays of non-primitive types are
            // handled by serialization as this does not record the component type.
            writeInt(VAL_OBJECTARRAY);
            writeArray((Object[]) v);
        } else if (v instanceof Serializable) {
            // Must be last
            writeInt(VAL_SERIALIZABLE);
            writeSerializable((Serializable) v);
        } else {
            throw new RuntimeException(""Parcel: unable to marshal value "" + v);
        }
    }
}","{
    if (v instanceof LazyValue) {
        LazyValue value = (LazyValue) v;
        value.writeToParcel(this);
        return;
    }
    int type = getValueType(v);
    writeInt(type);
    if (isLengthPrefixed(type)) {
        // Length
        int length = dataPosition();
        // Placeholder
        writeInt(-1);
        // Object
        int start = dataPosition();
        writeValue(type, v);
        int end = dataPosition();
        // Backpatch length
        setDataPosition(length);
        writeInt(end - start);
        setDataPosition(end);
    } else {
        writeValue(type, v);
    }
}",1,"/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class=""caution"">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */
","/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class=""caution"">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */
",0,,,0,,,,,,,,,,
583,"<android.os.Parcel: List<T> readParcelableList(List<T>,ClassLoader)>",32,33,,,,"{
    final int N = readInt();
    if (N == -1) {
        list.clear();
        return list;
    }
    final int M = list.size();
    int i = 0;
    for (; i < M && i < N; i++) {
        list.set(i, (T) readParcelable(cl));
    }
    for (; i < N; i++) {
        list.add((T) readParcelable(cl));
    }
    for (; i < M; i++) {
        list.remove(N);
    }
    return list;
}","{
    return readParcelableListInternal(list, cl, /*clazz*/
    null);
}",1,"/**
 * Read the list of {@code Parcelable} objects at the current data position into the
 * given {@code list}. The contents of the {@code list} are replaced. If the serialized
 * list was {@code null}, {@code list} is cleared.
 *
 * @see #writeParcelableList(List, int)
 */
","/**
 * Read the list of {@code Parcelable} objects at the current data position into the
 * given {@code list}. The contents of the {@code list} are replaced. If the serialized
 * list was {@code null}, {@code list} is cleared.
 *
 * @see #writeParcelableList(List, int)
 *
 * @deprecated Use the type-safer version {@link #readParcelableList(List, ClassLoader, Class)}
 * starting from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the
 * format to use {@link #readTypedList(List, Parcelable.Creator)} if possible (eg. if the
 * items' class is final) since this is also more performant. Note that changing to the
 * latter also requires changing the writes.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,5,0,"The late version of the method delegates the functionality to readParcelableListInternal(list, cl, null), indicating that the implementation relies on another API, which is 'readParcelableListInternal'. Therefore, the code change type is 5 as it's a change in a dependent API.","Since the method now relies on the internal implementation provided by readParcelableListInternal, and we cannot determine if there's any difference between the old inlined code and this new dependent method's implementation, there's no direct evidence of a compatibility issue just from the signature and annotations. If 'readParcelableListInternal' retains the same behavior as the inlined code previously within 'readParcelableList', this would not introduce a CI. But without knowing the implementation details of 'readParcelableListInternal', we can't assert if a CI exists or not, so we assume no CI as per the information given."
584,"<android.widget.AutoCompleteTextView: boolean onKeyPreIme(int,KeyEvent)>",32,33,,,,"{
    if (keyCode == KeyEvent.KEYCODE_BACK && isPopupShowing() && !mPopup.isDropDownAlwaysVisible()) {
        // to the drop down list but instead, consume it immediately
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.handleUpEvent(event);
            }
            if (event.isTracking() && !event.isCanceled()) {
                dismissDropDown();
                return true;
            }
        }
    }
    return super.onKeyPreIme(keyCode, event);
}","{
    if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE) && isPopupShowing() && !mPopup.isDropDownAlwaysVisible()) {
        // to the drop down list but instead, consume it immediately
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.handleUpEvent(event);
            }
            if (event.isTracking() && !event.isCanceled()) {
                dismissDropDown();
                return true;
            }
        }
    }
    return super.onKeyPreIme(keyCode, event);
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The control dependency has changed due to the additional check for KeyEvent.KEYCODE_ESCAPE in the if condition along with KeyEvent.KEYCODE_BACK. Consequently, the control statement has been modified, which aligns with the change type 3.","There is no Compatibility Issue because the extra condition for KeyEvent.KEYCODE_ESCAPE extends the functionality without altering the existing behavior for KeyEvent.KEYCODE_BACK. KeyCode KeyEvent.KEYCODE_ESCAPE was not handled in the early version, so the API's behavior for previously handled keycodes remains unchanged. This means there will not be a different return value or exception thrown for the cases that were handled in the early version. The change is backward compatible for the use cases considered by the early implementation."
585,<android.view.translation.TranslationManager: Translator createOnDeviceTranslator(TranslationContext)>,32,33,,,,"{
    Objects.requireNonNull(translationContext, ""translationContext cannot be null"");
    synchronized (mLock) {
        // IllegalStateException. Need to discuss if we can allow multiple Translators.
        if (mTranslatorIds.containsKey(translationContext)) {
            return mTranslators.get(mTranslatorIds.get(translationContext));
        }
        int translatorId;
        do {
            translatorId = Math.abs(ID_GENERATOR.nextInt());
        } while (translatorId == 0 || mTranslators.indexOfKey(translatorId) >= 0);
        final Translator newTranslator = new Translator(mContext, translationContext, translatorId, this, mHandler, mService);
        // Start the Translator session and wait for the result
        newTranslator.start();
        try {
            if (!newTranslator.isSessionCreated()) {
                return null;
            }
            mTranslators.put(translatorId, newTranslator);
            mTranslatorIds.put(translationContext, translatorId);
            return newTranslator;
        } catch (Translator.ServiceBinderReceiver.TimeoutException e) {
            // TODO(b/176464808): maybe make SyncResultReceiver.TimeoutException constructor
            // public and use it.
            Log.e(TAG, ""Timed out getting create session: "" + e);
            return null;
        }
    }
}","{
    Objects.requireNonNull(translationContext, ""translationContext cannot be null"");
    synchronized (mLock) {
        int translatorId;
        do {
            translatorId = Math.abs(ID_GENERATOR.nextInt());
        } while (translatorId == 0 || mTranslatorIds.indexOf(translatorId) >= 0);
        final Translator newTranslator = new Translator(mContext, translationContext, translatorId, this, mHandler, mService);
        // Start the Translator session and wait for the result
        newTranslator.start();
        try {
            if (!newTranslator.isSessionCreated()) {
                return null;
            }
            mTranslatorIds.add(translatorId);
            return newTranslator;
        } catch (Translator.ServiceBinderReceiver.TimeoutException e) {
            // TODO(b/176464808): maybe make SyncResultReceiver.TimeoutException constructor
            // public and use it.
            Log.e(TAG, ""Timed out getting create session: "" + e);
            return null;
        }
    }
}",1,"/**
 * Creates an on-device Translator for natural language translation.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * @removed use {@link #createOnDeviceTranslator(TranslationContext, Executor, Consumer)}
 * instead.
 *
 * @param translationContext {@link TranslationContext} containing the specs for creating the
 * Translator.
 */
","/**
 * Creates an on-device Translator for natural language translation.
 *
 * <p><strong>NOTE: </strong>Call on a worker thread.
 *
 * @removed use {@link #createOnDeviceTranslator(TranslationContext, Executor, Consumer)}
 * instead.
 *
 * @param translationContext {@link TranslationContext} containing the specs for creating the
 * Translator.
 */
",0,"[@Deprecated, @Nullable, @WorkerThread]","[@Deprecated, @Nullable, @WorkerThread]",0,,,,,,,"3,4",1,"The code change includes the removal of the condition and return statement regarding the mTranslatorIds.containsKey(translationContext) check, and the storing logic for mTranslatorIds and mTranslators is also changed. Therefore, types 3 (Control dependency changed) and 4 (Other statement changed) are applicable.","Since the check for existing translationContext and the return of an existing translator have been removed, under certain conditions, the late version of this API could return a different Translator object than the early version, leading to a potential Compatibility Issue type 1 (Compatibility Issue caused by potential different return values or types)."
586,<android.service.autofill.Dataset: String toString()>,32,33,,,,"{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""Dataset["");
    if (mId == null) {
        builder.append(""noId"");
    } else {
        // Cannot disclose id because it could contain PII.
        builder.append(""id="").append(mId.length()).append(""_chars"");
    }
    if (mFieldIds != null) {
        builder.append("", fieldIds="").append(mFieldIds);
    }
    if (mFieldValues != null) {
        builder.append("", fieldValues="").append(mFieldValues);
    }
    if (mFieldContent != null) {
        builder.append("", fieldContent="").append(mFieldContent);
    }
    if (mFieldPresentations != null) {
        builder.append("", fieldPresentations="").append(mFieldPresentations.size());
    }
    if (mFieldInlinePresentations != null) {
        builder.append("", fieldInlinePresentations="").append(mFieldInlinePresentations.size());
    }
    if (mFieldInlineTooltipPresentations != null) {
        builder.append("", fieldInlineTooltipInlinePresentations="").append(mFieldInlineTooltipPresentations.size());
    }
    if (mFieldFilters != null) {
        builder.append("", fieldFilters="").append(mFieldFilters.size());
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mInlineTooltipPresentation != null) {
        builder.append("", hasInlineTooltipPresentation"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    return builder.append(']').toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""Dataset["");
    if (mId == null) {
        builder.append(""noId"");
    } else {
        // Cannot disclose id because it could contain PII.
        builder.append(""id="").append(mId.length()).append(""_chars"");
    }
    if (mFieldIds != null) {
        builder.append("", fieldIds="").append(mFieldIds);
    }
    if (mFieldValues != null) {
        builder.append("", fieldValues="").append(mFieldValues);
    }
    if (mFieldContent != null) {
        builder.append("", fieldContent="").append(mFieldContent);
    }
    if (mFieldPresentations != null) {
        builder.append("", fieldPresentations="").append(mFieldPresentations.size());
    }
    if (mFieldDialogPresentations != null) {
        builder.append("", fieldDialogPresentations="").append(mFieldDialogPresentations.size());
    }
    if (mFieldInlinePresentations != null) {
        builder.append("", fieldInlinePresentations="").append(mFieldInlinePresentations.size());
    }
    if (mFieldInlineTooltipPresentations != null) {
        builder.append("", fieldInlineTooltipInlinePresentations="").append(mFieldInlineTooltipPresentations.size());
    }
    if (mFieldFilters != null) {
        builder.append("", fieldFilters="").append(mFieldFilters.size());
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mDialogPresentation != null) {
        builder.append("", hasDialogPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mInlineTooltipPresentation != null) {
        builder.append("", hasInlineTooltipPresentation"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    return builder.append(']').toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change is the addition of conditions to append information about mFieldDialogPresentations and mDialogPresentation in the StringBuilder, so the code change type is 4.","The change does not affect the return type or values because it only adds more details to the output of the `toString` method if `sDebug` is true. This change would not cause a different behavior in terms of the API's functionality; it just provides a more detailed string representation of the object for debugging purposes. Hence, there is no Compatibility Issue."
587,"<android.provider.Settings.Global: int getInt(ContentResolver,String)>",32,33,,,,"{
    String v = getString(cr, name);
    try {
        return Integer.parseInt(v);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    String v = getString(cr, name);
    return parseIntSetting(v, name);
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
",0,,,0,,,,,,,5,0,"The return logic in the late version uses a new method `parseIntSetting` instead of `Integer.parseInt` directly in the early version. This indicates a change in the dependent API, making it a change type 5.","Assuming `parseIntSetting` behaves exactly the same as the inlined code it replaces (including throwing a `SettingNotFoundException` when a `NumberFormatException` occurs), there would be no behavior change from the perspective of someone using the `getInt` API; thus, there is no compatibility issue (0). However, without knowing the implementation of `parseIntSetting`, it cannot be guaranteed there is no CI just based on this information. But following the rule strictly, since there's no clear evidence presented about potential behavior change, we should consider no compatibility issue for this scenario."
588,<android.inputmethodservice.AbstractInputMethodService: IBinder onBind(Intent)>,32,33,,,,"{
    if (mInputMethod == null) {
        mInputMethod = onCreateInputMethodInterface();
    }
    return new IInputMethodWrapper(this, mInputMethod);
}","{
    if (mInputMethod == null) {
        mInputMethod = onCreateInputMethodInterface();
    }
    if (mInputMethodServiceInternal == null) {
        mInputMethodServiceInternal = createInputMethodServiceInternal();
    }
    return new IInputMethodWrapper(mInputMethodServiceInternal, mInputMethod);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"An if-condition has been introduced to check and initialize a new variable mInputMethodServiceInternal and the constructor for IInputMethodWrapper has an additional parameter in the late version. This is a change that affects an 'other statement', so the code change type is 4.","There is no compatibility issue causing potential change in the returned value or exception thrown. The API still consistently returns an instance of IInputMethodWrapper and although the internal object passed to the constructor has changed, it does not affect clients of the API because the returned type remains the same and the constructor is not part of the API contract. Hence, there's no CI."
590,<android.hardware.soundtrigger.SoundTrigger.RecognitionEvent: int hashCode()>,32,33,,,,"{
    final int prime = 31;
    int result = 1;
    result = prime * result + (captureAvailable ? 1231 : 1237);
    result = prime * result + captureDelayMs;
    result = prime * result + capturePreambleMs;
    result = prime * result + captureSession;
    result = prime * result + (triggerInData ? 1231 : 1237);
    if (captureFormat != null) {
        result = prime * result + captureFormat.getSampleRate();
        result = prime * result + captureFormat.getEncoding();
        result = prime * result + captureFormat.getChannelMask();
    }
    result = prime * result + Arrays.hashCode(data);
    result = prime * result + soundModelHandle;
    result = prime * result + status;
    return result;
}","{
    final int prime = 31;
    int result = 1;
    result = prime * result + (captureAvailable ? 1231 : 1237);
    result = prime * result + captureDelayMs;
    result = prime * result + capturePreambleMs;
    result = prime * result + captureSession;
    result = prime * result + (triggerInData ? 1231 : 1237);
    if (captureFormat != null) {
        result = prime * result + captureFormat.getSampleRate();
        result = prime * result + captureFormat.getEncoding();
        result = prime * result + captureFormat.getChannelMask();
    }
    result = prime * result + Arrays.hashCode(data);
    result = prime * result + soundModelHandle;
    result = prime * result + status;
    result = result + (recognitionStillActive ? 1289 : 1291);
    return result;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"A new calculation has been added to the method body with the addition of `(recognitionStillActive ? 1289 : 1291)`. It is not a control statement, exception handling, or dependent API change, but an other statement change, which also changes the return value, so the code change type is 1,4.","Since an additional boolean condition contributes to the final hash code, this can result in a different return value for the same object between the two versions if the 'recognitionStillActive' flag differs. Therefore, the CI type is 1."
591,"<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>",32,33,,,,"{
    if (args != null && args.length > 0) {
        // Handle special cases
        switch(args[0]) {
            case ""--autofill"":
                dumpAutofillManager(prefix, writer);
                return;
            case ""--contentcapture"":
                dumpContentCaptureManager(prefix, writer);
                return;
            case ""--translation"":
                dumpUiTranslation(prefix, writer);
                return;
        }
    }
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    String innerPrefix = prefix + ""  "";
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mIsInMultiWindowMode="");
    writer.print(mIsInMultiWindowMode);
    writer.print("" mIsInPictureInPictureMode="");
    writer.println(mIsInPictureInPictureMode);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    if (getResources().hasOverrideDisplayAdjustments()) {
        writer.print(innerPrefix);
        writer.print(""FixedRotationAdjustments="");
        writer.println(getResources().getDisplayAdjustments().getFixedRotationAdjustments());
    }
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, writer);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    dumpAutofillManager(prefix, writer);
    dumpContentCaptureManager(prefix, writer);
    dumpUiTranslation(prefix, writer);
    ResourcesManager.getInstance().dump(prefix, writer);
}","{
    String innerPrefix = prefix + ""  "";
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mIsInMultiWindowMode="");
    writer.print(mIsInMultiWindowMode);
    writer.print("" mIsInPictureInPictureMode="");
    writer.println(mIsInPictureInPictureMode);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, writer);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    ResourcesManager.getInstance().dump(prefix, writer);
    if (mDumpableContainer != null) {
        mDumpableContainer.dumpAllDumpables(prefix, writer, args);
    }
}",1,,,0,,,0,,,,,,,"1,3,4",0,"The switch case statements are removed from the Late Implementation and a new if-statement is introduced. These changes fall under control dependency change and other statement change, leading to the code change type being 3,4. Additionally, the flow of the code has been altered; `dumpAutofillManager`, `dumpContentCaptureManager`, and `dumpUiTranslation` which were conditionally called based on `args` in the early version are now executed regardless of the `args`, except `dumpUiTranslation` which has been completely removed. This is considered a change in the return statement as well due to the removal of the return statements in the switch case, making the code change type 1,3,4. Furthermore, `mDumpableContainer.dumpAllDumpables(prefix, writer, args);`, a new line has been added at the end of the Late Implementation.","Although the implementation has significantly changed, these changes do not lead to a Compatibility Issue. The method has a return type of `void` and does not throw any checked exception, and the changes made do not introduce any new behaviors that would cause the API to return a different value or throw a different exception than before, given that it is a `dump` method intended for debugging and does not have a return value that affects the behavior of the application runtime. Therefore, there is no Compatibility Issue arising from this change."
592,<android.net.Ikev2VpnProfile: List<String> getAllowedAlgorithms()>,32,33,,,,"{
    return mAllowedAlgorithms;
}","{
    if (mIkeTunConnParams != null)
        return new ArrayList<>();
    return mAllowedAlgorithms;
}",1,"/**
 * Returns all the algorithms allowed by this VPN profile.
 */
","/**
 * Returns all the algorithms allowed by this VPN profile.
 *
 * <p>May be an empty list if the profile is built from an {@link IkeTunnelConnectionParams}.
 */
",1,[@NonNull],[@NonNull],0,,,,,,,"1,3",1,"The introduction of a control statement (`if`) and a new return statement (`return new ArrayList<>();`) are changes in the code, so the change types are 1 for the return statement and 3 for the control dependency change.","The introduction of the new 'if' check could lead to a different return type being returned (`new ArrayList<>()` instead of `mAllowedAlgorithms`). Therefore, depending on the value of `mIkeTunConnParams`, the API may return different values, which is a potential Compatibility Issue of type 1."
594,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,32,33,,,,"{
    enforceSealed();
    if ((mConnectionId == UNDEFINED) || (mSourceWindowId == AccessibilityWindowInfo.UNDEFINED_WINDOW_ID) || (AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == AccessibilityNodeInfo.UNDEFINED_ITEM_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, false, GET_SOURCE_PREFETCH_FLAGS, null);
}","{
    return getSource(GET_SOURCE_PREFETCH_FLAGS);
}",1,"/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
","/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
",0,,[@Nullable],1,,,,,,,"4,5",0,"The entire early implementation has been replaced with a single return statement that calls another method, so the change type is 4 due to the change in method body, and 5 because it now depends on another API (getSource(GET_SOURCE_PREFETCH_FLAGS)).","While at first glance it might seem like a CI because of the entire implementation change, the new implementation calls another existing method with constant flags, it likely delegates the original behavior to this overloaded method. If the overloaded method getSource(int flags) maintains the same behavior by internally performing the same checks and operations with the constant flags, then there shouldn't be any compatibility issue. Therefore, without additional evidence of changing behavior, we categorize it as no CI (0)."
595,<android.os.AggregateBatteryConsumer.Builder: Builder setConsumedPower(double)>,32,33,,,,"{
    mConsumedPowerMah = consumedPowerMah;
    return this;
}","{
    mData.putDouble(COLUMN_INDEX_CONSUMED_POWER, consumedPowerMah);
    return this;
}",1,"/**
 * Sets the total power included in this aggregate.
 */
","/**
 * Sets the total power included in this aggregate.
 */
",0,,,0,,,,,,,4,0,"The method body changed from directly assigning a value to a member variable to calling ""putDouble"" on a ""mData"" object with a constant key. This is an internal implementation detail, and it is an ""other statement changed"" type (4).","Despite the change in how the value is stored internally, there is no difference from the API user's perspective. The method still receives a double and returns the Builder instance it was called on. Therefore, there is no compatibility issue as the method's contract remains fulfilled. The return value is unchanged and no new exceptions have been introduced, so the CI type is 0."
596,<android.content.pm.ShortcutManager: List<ShortcutInfo> getManifestShortcuts()>,32,33,,,,"{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",0,"[@WorkerThread, @NonNull]","[@WorkerThread, @NonNull]",0,,,,,,,4,0,"The change is the removal of the getFutureOrThrow() wrapper around the mService.getShortcuts() call. The code change does not affect the return type or value and does not introduce any new exceptions, so the code change type is 4.","There is no Compatibility Issue because the method still throws the same exceptions and returns the same type of result, even though there is an internal change in how the result is retrieved."
599,"<android.service.voice.VoiceInteractionSession: void requestDirectActions(ActivityId,CancellationSignal,Executor,Consumer<List<DirectAction>>)>",32,33,,,,"{
    Preconditions.checkNotNull(activityId);
    Preconditions.checkNotNull(resultExecutor);
    Preconditions.checkNotNull(callback);
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    if (cancellationSignal != null) {
        cancellationSignal.throwIfCanceled();
    }
    final RemoteCallback cancellationCallback = (cancellationSignal != null) ? new RemoteCallback(b -> {
        if (b != null) {
            final IBinder cancellation = b.getBinder(VoiceInteractor.KEY_CANCELLATION_SIGNAL);
            if (cancellation != null) {
                cancellationSignal.setRemote(ICancellationSignal.Stub.asInterface(cancellation));
            }
        }
    }) : null;
    try {
        mSystemService.requestDirectActions(mToken, activityId.getTaskId(), activityId.getAssistToken(), cancellationCallback, new RemoteCallback(createSafeResultListener((result) -> {
            List<DirectAction> list;
            if (result == null) {
                list = Collections.emptyList();
            } else {
                final ParceledListSlice<DirectAction> pls = result.getParcelable(DirectAction.KEY_ACTIONS_LIST);
                if (pls != null) {
                    final List<DirectAction> receivedList = pls.getList();
                    list = (receivedList != null) ? receivedList : Collections.emptyList();
                } else {
                    list = Collections.emptyList();
                }
            }
            resultExecutor.execute(() -> callback.accept(list));
        })));
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(activityId);
    Objects.requireNonNull(resultExecutor);
    Objects.requireNonNull(callback);
    if (mToken == null) {
        throw new IllegalStateException(""Can't call before onCreate()"");
    }
    if (cancellationSignal != null) {
        cancellationSignal.throwIfCanceled();
    }
    final RemoteCallback cancellationCallback = (cancellationSignal != null) ? new RemoteCallback(b -> {
        if (b != null) {
            final IBinder cancellation = b.getBinder(VoiceInteractor.KEY_CANCELLATION_SIGNAL);
            if (cancellation != null) {
                cancellationSignal.setRemote(ICancellationSignal.Stub.asInterface(cancellation));
            }
        }
    }) : null;
    try {
        mSystemService.requestDirectActions(mToken, activityId.getTaskId(), activityId.getAssistToken(), cancellationCallback, new RemoteCallback(createSafeResultListener((result) -> {
            List<DirectAction> list;
            if (result == null) {
                list = Collections.emptyList();
            } else {
                final ParceledListSlice<DirectAction> pls = result.getParcelable(DirectAction.KEY_ACTIONS_LIST);
                if (pls != null) {
                    final List<DirectAction> receivedList = pls.getList();
                    list = (receivedList != null) ? receivedList : Collections.emptyList();
                } else {
                    list = Collections.emptyList();
                }
            }
            resultExecutor.execute(() -> callback.accept(list));
        })));
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}",1,"/**
 * Requests a list of supported actions from an app.
 *
 * @param activityId Ths activity id of the app to get the actions from.
 * @param resultExecutor The handler to receive the callback
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none.
 * @param callback The callback to receive the response
 */
","/**
 * Requests a list of supported actions from an app.
 *
 * @param activityId Ths activity id of the app to get the actions from.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none.
 * @param resultExecutor The handler to receive the callback.
 * @param callback The callback to receive the response.
 */
",1,,,0,,,,,,,4,0,"The change is the replacement of Preconditions.checkNotNull() with Objects.requireNonNull() for checking if arguments are not null. These two methods are essentially identical in purpose and functionality, thus not changing the behavior of the method.","There is no Compatibility Issue because the change from Preconditions.checkNotNull() to Objects.requireNonNull() does not affect the behavior of the API; both methods throw a NullPointerException if the checked object is null. Therefore, the API's contract is maintained, and there's no effect on return values or exceptions that could be thrown."
600,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,RemoteViews)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null, null);
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(presentation, ""presentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, null, null, null, null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the  {@code value} parameter.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it.
 *
 * <p><b>Note:</b> On Android {@link android.os.Build.VERSION_CODES#P} and
 * higher, datasets that require authentication can be also be filtered by passing a
 * {@link AutofillValue#forText(CharSequence) text value} as the  {@code value} parameter.
 *
 * <p>Theme does not work with RemoteViews layout. Avoid hardcoded text color
 * or background color: Autofill on different platforms may have different themes.
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param presentation the presentation used to visualize this field.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"4,5",0,"The method Preconditions.checkNotNull() in the early version was replaced with Objects.requireNonNull() in the late version, which serve a similar purpose of null checking, indicating a change in the dependent API. Moreover, the method setLifeTheUniverseAndEverything() call in the late version has two additional null parameters compared to the early version. This indicates that the signature of setLifeTheUniverseAndEverything() has changed, but since there is no change in the logic controlling the behavior of the API or return values, the code change type is 4,5.","The change does not affect the behavior of the API in terms of throwing different exceptions or returning different values, despite the change in the internal method called which does not alter the outcome. Thus, there is no Compatibility Issue, and the type is 0."
601,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,32,33,,,,"{
    AccessibilityEvent event = sPool.acquire();
    if (event == null)
        event = new AccessibilityEvent();
    if (DEBUG_ORIGIN)
        event.originStackTrace = Thread.currentThread().getStackTrace();
    return event;
}","{
    return new AccessibilityEvent();
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * <p>In most situations object pooling is not beneficial. Create a new instance using the
 * constructor {@link #AccessibilityEvent()} instead.
 *
 * @return An instance.
 */
","/**
 * Instantiates a new AccessibilityEvent instance.
 *
 * @deprecated Object pooling has been discontinued. Create a new instance using the
 * constructor {@link #AccessibilityEvent()} instead.
 * @return An instance.
 */
",1,,[@Deprecated],1,,,,,,,"1,4",1,"The early version uses an object pooling pattern to reuse instances of AccessibilityEvent, whereas the late version creates a new instance every time. Also, the condition checking the pool and debug stack trace assignment is removed in the late version. This means there is both a return statement change and another statement change, which is why the code change type is 1,4.","Since the late version always returns a new instance of AccessibilityEvent instead of potentially returning a reused instance from the pool, the return value of the API has changed. This could lead to Compatibility Issues due to different behavior in memory resource usage and potentially breaking any existing contract based on the object pooling pattern previously used. The CI type is 1."
602,<android.view.accessibility.AccessibilityEvent: String toString()>,32,33,,,,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    if (!DEBUG_CONCISE_TOSTRING || mMovementGranularity != 0) {
        builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    }
    if (!DEBUG_CONCISE_TOSTRING || mAction != 0) {
        builder.append(""; Action: "").append(mAction);
    }
    if (!DEBUG_CONCISE_TOSTRING || mContentChangeTypes != 0) {
        builder.append(""; ContentChangeTypes: "").append(contentChangeTypesToString(mContentChangeTypes));
    }
    if (!DEBUG_CONCISE_TOSTRING || mWindowChangeTypes != 0) {
        builder.append(""; WindowChangeTypes: "").append(windowChangeTypesToString(mWindowChangeTypes));
    }
    super.appendTo(builder);
    if (DEBUG || DEBUG_CONCISE_TOSTRING) {
        if (!DEBUG_CONCISE_TOSTRING) {
            builder.append(""\n"");
        }
        if (DEBUG) {
            builder.append(""; SourceWindowId: 0x"").append(Long.toHexString(mSourceWindowId));
            builder.append(""; SourceNodeId: 0x"").append(Long.toHexString(mSourceNodeId));
        }
        for (int i = 0; i < getRecordCount(); i++) {
            builder.append(""  Record "").append(i).append("":"");
            getRecord(i).appendTo(builder).append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    if (!DEBUG_CONCISE_TOSTRING || mMovementGranularity != 0) {
        builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    }
    if (!DEBUG_CONCISE_TOSTRING || mAction != 0) {
        builder.append(""; Action: "").append(mAction);
    }
    if (!DEBUG_CONCISE_TOSTRING || mContentChangeTypes != 0) {
        builder.append(""; ContentChangeTypes: "").append(contentChangeTypesToString(mContentChangeTypes));
    }
    if (!DEBUG_CONCISE_TOSTRING || mWindowChangeTypes != 0) {
        builder.append(""; WindowChangeTypes: "").append(windowChangeTypesToString(mWindowChangeTypes));
    }
    super.appendTo(builder);
    if (DEBUG || DEBUG_CONCISE_TOSTRING) {
        if (!DEBUG_CONCISE_TOSTRING) {
            builder.append(""\n"");
        }
        if (DEBUG) {
            builder.append(""; SourceWindowId: 0x"").append(Long.toHexString(mSourceWindowId));
            builder.append(""; SourceNodeId: 0x"").append(Long.toHexString(mSourceNodeId));
            builder.append(""; SourceDisplayId: "").append(mSourceDisplayId);
        }
        for (int i = 0; i < getRecordCount(); i++) {
            builder.append(""  Record "").append(i).append("":"");
            getRecord(i).appendTo(builder).append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only code change is the addition of the line `builder.append(""; SourceDisplayId: "").append(mSourceDisplayId);` which is under a conditional DEBUG block. This change is appending additional information to the StringBuilder object `builder`, so the change type is 4.","Despite the addition of a new field to the string representation, there is no Compatibility Issue regarding the return value or type for the method `toString()`. The methodâ€™s contract is to return a string representation of the object, and the returned string now simply contains more information when DEBUG is true. This doesn't alter the behavior in a way that would lead to incompatibility with existing clients of the API; they are already designed to handle the string potentially changing with every call to `toString()`. Thus, there is no Compatibility Issue."
603,<android.widget.AdapterViewAnimator: void refreshChildren()>,32,33,,,,"{
    if (mAdapter == null)
        return;
    for (int i = mCurrentWindowStart; i <= mCurrentWindowEnd; i++) {
        int index = modulo(i, getWindowSize());
        int adapterCount = getCount();
        // get the fresh child from the adapter
        final View updatedChild = mAdapter.getView(modulo(i, adapterCount), null, this);
        if (updatedChild.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            updatedChild.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mViewsMap.containsKey(index)) {
            final FrameLayout fl = (FrameLayout) mViewsMap.get(index).view;
            // add the new child to the frame, if it exists
            if (updatedChild != null) {
                // flush out the old child
                fl.removeAllViewsInLayout();
                fl.addView(updatedChild);
            }
        }
    }
}","{
    final int adapterCount = mAdapter == null ? 0 : getCount();
    for (int i = mCurrentWindowStart; i <= mCurrentWindowEnd; i++) {
        int index = modulo(i, getWindowSize());
        final View updatedChild;
        if (i < adapterCount) {
            // get the fresh child from the adapter
            updatedChild = mAdapter.getView(modulo(i, adapterCount), null, this);
            if (updatedChild.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                updatedChild.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
        } else {
            updatedChild = null;
        }
        if (mViewsMap.containsKey(index)) {
            final FrameLayout fl = (FrameLayout) mViewsMap.get(index).view;
            // flush out the old child
            fl.removeAllViewsInLayout();
            if (updatedChild != null) {
                // add the new child to the frame, if it exists
                fl.addView(updatedChild);
            }
        }
    }
}",1,,,0,,,0,,,,,,,"3,4",1,"The control flow structure has changed with the addition of the condition 'if (i < adapterCount)'. The assignment of 'updatedChild' is now dependent on this new condition, and the early return in case of 'mAdapter == null' has been replaced by a condition in the loop which leads to 'updatedChild = null'. These are changes in control dependency and in other non-listed statements, so the code change is classified as 3,4.","Since the new version introduces a condition that changes the flow of the method (it might skip assigning 'updatedChild' a value from mAdapter.getView() if 'i' is not less than 'adapterCount'), the behavior of the method can be different. This can potentially lead to 'updatedChild' being null in the late version where it might not have been in the early version, thus potentially causing the method to return different results. Therefore, a Compatibility Issue related to potentially different return values exists, and the CI type is 1."
604,<android.app.ActivityOptions: void update(ActivityOptions)>,32,33,,,,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mLockTaskMode = otherOptions.mLockTaskMode;
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
    mSpecsFuture = otherOptions.mSpecsFuture;
    mRemoteAnimationAdapter = otherOptions.mRemoteAnimationAdapter;
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mCustomBackgroundColor = otherOptions.mCustomBackgroundColor;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mLockTaskMode = otherOptions.mLockTaskMode;
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
    mSpecsFuture = otherOptions.mSpecsFuture;
    mRemoteAnimationAdapter = otherOptions.mRemoteAnimationAdapter;
    mLaunchIntoPipParams = otherOptions.mLaunchIntoPipParams;
    mIsEligibleForLegacyPermissionPrompt = otherOptions.mIsEligibleForLegacyPermissionPrompt;
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",0,,,0,,,,,,,,,,
605,"<android.hardware.usb.UsbDeviceConnection: boolean open(String,ParcelFileDescriptor,Context)>",32,33,,,,"{
    mContext = context.getApplicationContext();
    synchronized (mLock) {
        boolean wasOpened = native_open(name, pfd.getFileDescriptor());
        if (wasOpened) {
            mCloseGuard.open(""close"");
        }
        return wasOpened;
    }
}","{
    mContext = context.getApplicationContext();
    synchronized (mLock) {
        boolean wasOpened = native_open(name, pfd.getFileDescriptor());
        if (wasOpened) {
            mCloseGuard.open(""UsbDeviceConnection.close"");
        }
        return wasOpened;
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,4,0,"The change is in a string literal passed to the `mCloseGuard.open` method, which does not affect the return value or the behavior of exceptions of the `open` method. Therefore, the change type is 4.",There is no Compatibility Issue; the change is only in a message used for debugging purposes and does not affect the method's external behavior.
606,<android.app.usage.UsageEvents: boolean getNextEvent(Event)>,32,33,,,,"{
    if (mIndex >= mEventCount) {
        return false;
    }
    if (mParcel != null) {
        readEventFromParcel(mParcel, eventOut);
    } else {
        eventOut.copyFrom(mEventsToWrite.get(mIndex));
    }
    mIndex++;
    if (mIndex >= mEventCount && mParcel != null) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}","{
    if (eventOut == null) {
        throw new IllegalArgumentException(""Given eventOut must not be null"");
    }
    if (mIndex >= mEventCount) {
        return false;
    }
    if (mParcel != null) {
        readEventFromParcel(mParcel, eventOut);
    } else {
        eventOut.copyFrom(mEventsToWrite.get(mIndex));
    }
    mIndex++;
    if (mIndex >= mEventCount && mParcel != null) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}",1,"/**
 * Retrieve the next {@link android.app.usage.UsageEvents.Event} from the collection and put the
 * resulting data into {@code eventOut}.
 *
 * @param eventOut The {@link android.app.usage.UsageEvents.Event} object that will receive the
 * next event data.
 * @return true if an event was available, false if there are no more events.
 */
","/**
 * Retrieve the next {@link android.app.usage.UsageEvents.Event} from the collection and put the
 * resulting data into {@code eventOut}.
 *
 * @param eventOut The {@link android.app.usage.UsageEvents.Event} object that will receive the
 * next event data.
 * @return true if an event was available, false if there are no more events.
 */
",0,,,0,,,,,,,"2,4",2,"A new exception handling statement has been introduced (throw new IllegalArgumentException), which wasn't present in the early version, and the type of change associated with this is 2. Additionally, since there are no new control structures introduced and the logical flow remains the same, the code change type of Other statement changed (4) is identified because of the new contractual precondition check.","The introduction of a new throw statement for a null parameter check causes a potential Compatibility Issue of type 2, as this change can lead a previously successful method call to now throw an IllegalArgumentException if the 'eventOut' parameter is null."
607,<android.text.method.TextKeyListener: int getPrefs(Context)>,32,33,,,,"{
    synchronized (this) {
        if (!mPrefsInited || mResolver.get() == null) {
            initPrefs(context);
        }
    }
    return mPrefs;
}","{
    synchronized (this) {
        if (!mPrefsInited || mResolver.refersTo(null)) {
            initPrefs(context);
        }
    }
    return mPrefs;
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,5,0,"The method called on `mResolver` has changed from `get() == null` to `refersTo(null)`. This implies a change in the dependent API, specifically the method used to check if the reference is null.","There is no compatibility issue detected because the change does not affect the logic related to value returned or exception thrown. It's merely updating the way null check is performed on a reference, which should maintain the same logic."
609,<android.view.inputmethod.InputMethodManager: boolean isAcceptingText()>,32,33,,,,"{
    checkFocus();
    synchronized (mH) {
        return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.getInputConnection() != null;
    }
}","{
    checkFocus();
    synchronized (mH) {
        return mServedInputConnection != null && !mServedInputConnection.isFinished();
    }
}",1,"/**
 * Return {@code true} if the currently served view is accepting full text edits.
 * If {@code false}, it has no input connection, so it can only handle raw key events.
 */
","/**
 * Return {@code true} if the currently served view is accepting full text edits.
 * If {@code false}, it has no input connection, so it can only handle raw key events.
 */
",0,,,0,,,,,,,"1, 5",1,"The return statement has been changed, including the condition checked. In the early implementation, it is checking if `mServedInputConnectionWrapper` and its `getInputConnection()` method return non-null, while in the late implementation, it is checking if `mServedInputConnection` is non-null and not finished. This indicates the Dependent API has changed too, which means the change types are 1 and 5.","Since the return value is dependent on the state of a different object between the two versions (`mServedInputConnectionWrapper` vs `mServedInputConnection`), this could potentially lead to the API returning different results in the two versions. Therefore, a Compatibility Issue could arise, and the CI type is 1."
610,"<android.app.Activity: void dispatchActivityResult(String,int,int,Intent,String)>",32,33,,,,"{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(""@android:view:"")) {
        ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null && viewRoot.getView().dispatchActivityResult(who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else if (who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)) {
        Intent resultData = (resultCode == Activity.RESULT_OK) ? data : null;
        getAutofillManager().onAuthenticationResult(requestCode, resultData, getCurrentFocus());
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
    EventLogTags.writeWmOnActivityResultCalled(mIdent, getComponentName().getClassName(), reason);
}","{
    if (false)
        Log.v(TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode + "", resCode="" + resultCode + "", data="" + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(""@android:view:"")) {
        ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null && viewRoot.getView().dispatchActivityResult(who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else if (who.startsWith(AutofillClientController.AUTO_FILL_AUTH_WHO_PREFIX)) {
        getAutofillClientController().onDispatchActivityResult(requestCode, resultCode, data);
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
    EventLogTags.writeWmOnActivityResultCalled(mIdent, getComponentName().getClassName(), reason);
}",1,,,0,"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)]","[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)]",0,,,,,,,"3,5",0,"The code change includes altering a constant string from `AUTO_FILL_AUTH_WHO_PREFIX` to `AutofillClientController.AUTO_FILL_AUTH_WHO_PREFIX` and replacing the method call from `getAutofillManager().onAuthenticationResult` to `getAutofillClientController().onDispatchActivityResult`, which implies a control dependency change and a dependent API change, hence the change type is 3,5.","Despite the changes in the constant string value and the method call, these modifications don't introduce any new behavior or alter the existing behavior of the method `dispatchActivityResult`. The method's flow remains the same, and it continues to ultimately call an underlying method to handle the result. The changes are related only to the implementation details but do not affect the API's output or exception behavior. Thus, there is no Compatibility Issue, and the CI type is 0."
611,<android.os.Parcel: Parcelable[] readParcelableArray(ClassLoader)>,32,33,,,,"{
    int N = readInt();
    if (N < 0) {
        return null;
    }
    Parcelable[] p = new Parcelable[N];
    for (int i = 0; i < N; i++) {
        p[i] = readParcelable(loader);
    }
    return p;
}","{
    return readParcelableArrayInternal(loader, /* clazz */
    null);
}",1,"/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 */
","/**
 * Read and return a new Parcelable array from the parcel.
 * The given class loader will be used to load any enclosed
 * Parcelables.
 * @return the Parcelable array, or null if the array is null
 *
 * @deprecated Use the type-safer version {@link #readParcelableArray(ClassLoader, Class)}
 * starting from Android {@link Build.VERSION_CODES#TIRAMISU}. Also consider changing the
 * format to use {@link #createTypedArray(Parcelable.Creator)} if possible (eg. if the
 * items' class is final) since this is also more performant. Note that changing to the
 * latter also requires changing the writes.
 */
",1,[@Nullable],"[@Deprecated, @Nullable]",1,,,,,,,5,0,"The late version of the API relies on a new internal API readParcelableArrayInternal, so the code change type is 5 (Dependent API changed).","Since the late version delegates the function to readParcelableArrayInternal without any change in behavior reflected in the signature or annotations, and because the annotations have remained consistent with the addition of @Deprecated indicating an intention to remove or update the API without a change in functionality, there is no direct evidence of a behavioral change that could lead to a different value being returned or a different exception being thrown. Therefore, the CI type is 0 (No Compatibility Issue)."
612,"<android.view.translation.TranslationManager: void createOnDeviceTranslator(TranslationContext,Executor,Consumer<Translator>)>",32,33,,,,"{
    Objects.requireNonNull(translationContext, ""translationContext cannot be null"");
    Objects.requireNonNull(executor, ""executor cannot be null"");
    Objects.requireNonNull(callback, ""callback cannot be null"");
    synchronized (mLock) {
        // IllegalStateException. Need to discuss if we can allow multiple Translators.
        if (mTranslatorIds.containsKey(translationContext)) {
            executor.execute(() -> callback.accept(mTranslators.get(mTranslatorIds.get(translationContext))));
            return;
        }
        int translatorId;
        do {
            translatorId = Math.abs(ID_GENERATOR.nextInt());
        } while (translatorId == 0 || mTranslators.indexOfKey(translatorId) >= 0);
        final int tId = translatorId;
        new Translator(mContext, translationContext, translatorId, this, mHandler, mService, new Consumer<Translator>() {

            @Override
            public void accept(Translator translator) {
                if (translator == null) {
                    final long token = Binder.clearCallingIdentity();
                    try {
                        executor.execute(() -> callback.accept(null));
                    } finally {
                        Binder.restoreCallingIdentity(token);
                    }
                    return;
                }
                synchronized (mLock) {
                    mTranslators.put(tId, translator);
                    mTranslatorIds.put(translationContext, tId);
                }
                final long token = Binder.clearCallingIdentity();
                try {
                    executor.execute(() -> callback.accept(translator));
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            }
        });
    }
}","{
    Objects.requireNonNull(translationContext, ""translationContext cannot be null"");
    Objects.requireNonNull(executor, ""executor cannot be null"");
    Objects.requireNonNull(callback, ""callback cannot be null"");
    synchronized (mLock) {
        int translatorId;
        do {
            translatorId = Math.abs(ID_GENERATOR.nextInt());
        } while (translatorId == 0 || mTranslatorIds.indexOf(translatorId) >= 0);
        final int tId = translatorId;
        new Translator(mContext, translationContext, tId, this, mHandler, mService, translator -> {
            if (translator == null) {
                Binder.withCleanCallingIdentity(() -> executor.execute(() -> callback.accept(null)));
                return;
            }
            synchronized (mLock) {
                mTranslatorIds.add(tId);
            }
            Binder.withCleanCallingIdentity(() -> executor.execute(() -> callback.accept(translator)));
        });
    }
}",1,"/**
 * Creates an on-device Translator for natural language translation.
 *
 * @param translationContext {@link TranslationContext} containing the specs for creating the
 * Translator.
 * @param executor Executor to run callback operations
 * @param callback {@link Consumer} to receive the translator. A {@code null} value is returned
 * if the service could not create the translator.
 */
","/**
 * Creates an on-device Translator for natural language translation.
 *
 * <p>In Android 12, this method provided the same cached Translator object when given the
 * same TranslationContext object. Do not use a Translator destroyed elsewhere as this will
 * cause an exception on Android 12.
 *
 * <p>In later versions, this method never returns a cached Translator.
 *
 * @param translationContext {@link TranslationContext} containing the specs for creating the
 * Translator.
 * @param executor Executor to run callback operations
 * @param callback {@link Consumer} to receive the translator. A {@code null} value is returned
 * if the service could not create the translator.
 */
",1,,,0,,,,,,,"1,2,3,4","1,2","There are changes in return statements, exception handling, control structures, and other statements:",3. The exception handling was changed by using `Binder.withCleanCallingIdentity()` instead of manually clearing and restoring the calling identity.
613,"<android.service.autofill.Dataset.Builder: Builder setValue(AutofillId,AutofillValue,Pattern,RemoteViews,InlinePresentation,InlinePresentation)>",32,33,,,,"{
    throwIfDestroyed();
    Preconditions.checkNotNull(presentation, ""presentation cannot be null"");
    Preconditions.checkNotNull(inlinePresentation, ""inlinePresentation cannot be null"");
    Preconditions.checkNotNull(inlineTooltipPresentation, ""inlineTooltipPresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, inlineTooltipPresentation, new DatasetFieldFilter(filter));
    return this;
}","{
    throwIfDestroyed();
    Objects.requireNonNull(presentation, ""presentation cannot be null"");
    Objects.requireNonNull(inlinePresentation, ""inlinePresentation cannot be null"");
    Objects.requireNonNull(inlineTooltipPresentation, ""inlineTooltipPresentation cannot be null"");
    setLifeTheUniverseAndEverything(id, value, presentation, inlinePresentation, inlineTooltipPresentation, new DatasetFieldFilter(filter), null);
    return this;
}",1,"/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>, and an
 * {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * @see #setValue(AutofillId, AutofillValue, Pattern, RemoteViews, InlinePresentation)
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions, this
 * should not be null.
 * @param inlineTooltipPresentation The {@link InlinePresentation} used to show
 * the tooltip for the {@code inlinePresentation}.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 */
","/**
 * Sets the value of a field, using a custom {@link RemoteViews presentation} to
 * visualize it and a <a href=""#Filtering"">explicit filter</a>, and an
 * {@link InlinePresentation} to visualize it as an inline suggestion.
 *
 * @see #setValue(AutofillId, AutofillValue, Pattern, RemoteViews, InlinePresentation)
 *
 * @param id id returned by {@link
 * android.app.assist.AssistStructure.ViewNode#getAutofillId()}.
 * @param value the value to be autofilled. Pass {@code null} if you do not have the value
 * but the target view is a logical part of the dataset. For example, if
 * the dataset needs authentication and you have no access to the value.
 * @param filter regex used to determine if the dataset should be shown in the autofill UI;
 * when {@code null}, it disables filtering on that dataset (this is the recommended
 * approach when {@code value} is not {@code null} and field contains sensitive data
 * such as passwords).
 * @param presentation the presentation used to visualize this field.
 * @param inlinePresentation The {@link InlinePresentation} used to visualize this dataset
 * as inline suggestions. If the dataset supports inline suggestions, this
 * should not be null.
 * @param inlineTooltipPresentation The {@link InlinePresentation} used to show
 * the tooltip for the {@code inlinePresentation}.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 *
 * @return this builder.
 * @deprecated Use {@link #setField(AutofillId, Field)} instead.
 */
",1,[@NonNull],"[@Deprecated, @NonNull]",1,,,,,,,"4,5",0,"The method setLifeTheUniverseAndEverything has an additional parameter, 'null', in the late version, and the precondition checks have been switched from using Preconditions.checkNotNull to using Objects.requireNonNull, which have identical functionality. We also see that the method signature includes two `InlinePresentation` parameters when in fact it should likely be one `InlinePresentation` and one `Pattern` when matching the early implementation, indicating the signature has a mistake. This discrepancy could suggest a potential dependent API change as the actual parameters used during invocation are what determine compatibility issues, not the incorrectly listed types in the documentation. As the incorrect signature is given, we can only classify the change in the method invocation as Other statement changed (4). Dependent API changed (5) is also considered because of the change in parameters passed to the `setLifeTheUniverseAndEverything` method.","No Compatibility Issue is detected, because all changes are either referring to the changes in null-checking mechanism which has no impact on the behavior or adding a null to a method call, assuming 'setLifeTheUniverseAndEverything' method is adapted to handle the new additional null value without changing in externally observable behavior."
614,<android.companion.CompanionDeviceManager: void stopObservingDevicePresence(String)>,32,33,,,,"{
    if (!checkFeaturePresent()) {
        return;
    }
    Objects.requireNonNull(deviceAddress, ""address cannot be null"");
    try {
        mService.unregisterDevicePresenceListenerService(mContext.getPackageName(), deviceAddress);
    } catch (RemoteException e) {
        ExceptionUtils.propagateIfInstanceOf(e.getCause(), DeviceNotAssociatedException.class);
    }
}","{
    if (!checkFeaturePresent()) {
        return;
    }
    Objects.requireNonNull(deviceAddress, ""address cannot be null"");
    try {
        mService.unregisterDevicePresenceListenerService(deviceAddress, mContext.getPackageName(), mContext.getUserId());
    } catch (RemoteException e) {
        ExceptionUtils.propagateIfInstanceOf(e.getCause(), DeviceNotAssociatedException.class);
    }
}",1,"/**
 * Unregister for receiving callbacks whenever the associated device comes in and out of range.
 *
 * The provided device must be {@link #associate associated} with the calling app before
 * calling this method.
 *
 * Calling app must declare uses-permission
 * {@link android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE}.
 *
 * Calling app must check for feature presence of
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.
 *
 * @param deviceAddress a previously-associated companion device's address
 *
 * @throws DeviceNotAssociatedException if the given device was not previously associated
 * with this app.
 */
","/**
 * Unregister for receiving callbacks whenever the associated device comes in and out of range.
 *
 * The provided device must be {@link #associate associated} with the calling app before
 * calling this method.
 *
 * Calling app must declare uses-permission
 * {@link android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE}.
 *
 * Calling app must check for feature presence of
 * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.
 *
 * @param deviceAddress a previously-associated companion device's address
 *
 * @throws DeviceNotAssociatedException if the given device was not previously associated
 * with this app.
 */
",0,[@RequiresPermission(android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE)],[@RequiresPermission(android.Manifest.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE)],0,,,,,,,5,0,"The order and number of the parameters in the method call mService.unregisterDevicePresenceListenerService() have been changed, but the handling is functionally the same. The exception handling has not changed. There is a change in the dependent API due to the alteration in the parameters of the method being called.",There is no Compatibility Issue as the changes do not affect the behavior of the method in terms of what it returns or the exceptions it throws. The change to the parameters passed to the dependent API does not lead to a different behavior from the perspective of the code calling this API.
